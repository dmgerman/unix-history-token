begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* makeinfo -- convert Texinfo source into other formats.    $Id: makeinfo.c,v 1.195 2002/02/11 17:12:49 karl Exp $     Copyright (C) 1987, 92, 93, 94, 95, 96, 97, 98, 99, 2000, 01, 02    Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Makeinfo was authored by Brian Fox (bfox@ai.mit.edu). */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_define
define|#
directive|define
name|COMPILING_MAKEINFO
end_define

begin_include
include|#
directive|include
file|"makeinfo.h"
end_include

begin_include
include|#
directive|include
file|"cmds.h"
end_include

begin_include
include|#
directive|include
file|"files.h"
end_include

begin_include
include|#
directive|include
file|"footnote.h"
end_include

begin_include
include|#
directive|include
file|"html.h"
end_include

begin_include
include|#
directive|include
file|"index.h"
end_include

begin_include
include|#
directive|include
file|"insertion.h"
end_include

begin_include
include|#
directive|include
file|"macro.h"
end_include

begin_include
include|#
directive|include
file|"node.h"
end_include

begin_include
include|#
directive|include
file|"toc.h"
end_include

begin_include
include|#
directive|include
file|"xml.h"
end_include

begin_comment
comment|/* You can change some of the behavior of Makeinfo by changing the    following defines: */
end_comment

begin_comment
comment|/* Define INDENT_PARAGRAPHS_IN_TABLE if you want the paragraphs which    appear within an @table, @ftable, or @itemize environment to have    standard paragraph indentation.  Without this, such paragraphs have    no starting indentation. */
end_comment

begin_comment
comment|/* #define INDENT_PARAGRAPHS_IN_TABLE */
end_comment

begin_comment
comment|/* Define PARAGRAPH_START_INDENT to be the amount of indentation that    the first lines of paragraphs receive by default, where no other    value has been specified.  Users can change this value on the command    line, with the --paragraph-indent option, or within the texinfo file,    with the @paragraphindent command. */
end_comment

begin_define
define|#
directive|define
name|PARAGRAPH_START_INDENT
value|3
end_define

begin_comment
comment|/* Define DEFAULT_PARAGRAPH_SPACING as the number of blank lines that you    wish to appear between paragraphs.  A value of 1 creates a single blank    line between paragraphs.  Paragraphs are defined by 2 or more consecutive    newlines in the input file (i.e., one or more blank lines). */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_PARAGRAPH_SPACING
value|1
end_define

begin_escape
end_escape

begin_comment
comment|/* Global variables.  */
end_comment

begin_comment
comment|/* The output file name. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|output_filename
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of the output file that the user elected to pass on the command line.    Such a name overrides any name found with the @setfilename command. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|command_output_filename
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flags which control initial output string for xrefs. */
end_comment

begin_decl_stmt
name|int
name|px_ref_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ref_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INITIAL_PARAGRAPH_SPACE
value|5000
end_define

begin_decl_stmt
name|int
name|paragraph_buffer_len
init|=
name|INITIAL_PARAGRAPH_SPACE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The amount of indentation to add at the starts of paragraphs.    0 means don't change existing indentation at paragraph starts.> 0 is amount to indent new paragraphs by.< 0 means indent to column zero by removing indentation if necessary.     This is normally zero, but some people prefer paragraph starts to be    somewhat more indented than paragraph bodies.  A pretty value for    this is 3. */
end_comment

begin_decl_stmt
name|int
name|paragraph_start_indent
init|=
name|PARAGRAPH_START_INDENT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indentation that is pending insertion.  We have this for hacking lines    which look blank, but contain whitespace.  We want to treat those as    blank lines. */
end_comment

begin_decl_stmt
name|int
name|pending_indent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The index in our internal command table of the currently    executing command. */
end_comment

begin_decl_stmt
name|int
name|command_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A search string which is used to find the first @setfilename. */
end_comment

begin_decl_stmt
name|char
name|setfilename_search
index|[]
init|=
block|{
name|COMMAND_PREFIX
block|,
literal|'s'
block|,
literal|'e'
block|,
literal|'t'
block|,
literal|'f'
block|,
literal|'i'
block|,
literal|'l'
block|,
literal|'e'
block|,
literal|'n'
block|,
literal|'a'
block|,
literal|'m'
block|,
literal|'e'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Values for calling handle_variable_internal (). */
end_comment

begin_define
define|#
directive|define
name|SET
value|1
end_define

begin_define
define|#
directive|define
name|CLEAR
value|2
end_define

begin_define
define|#
directive|define
name|IFSET
value|3
end_define

begin_define
define|#
directive|define
name|IFCLEAR
value|4
end_define

begin_comment
comment|/* Flags controlling the operation of the program. */
end_comment

begin_comment
comment|/* Default is to remove output if there were errors.  */
end_comment

begin_decl_stmt
name|int
name|force
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default is to notify users of bad choices. */
end_comment

begin_decl_stmt
name|int
name|print_warnings
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of errors that we tolerate on a given fileset. */
end_comment

begin_decl_stmt
name|int
name|max_error_level
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The actual last inserted character.  Note that this may be something    other than NEWLINE even if last_char_was_newline is 1. */
end_comment

begin_decl_stmt
name|int
name|last_inserted_character
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that a newline character has already been    inserted, so close_paragraph () should insert one less. */
end_comment

begin_decl_stmt
name|int
name|line_already_broken
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When nonzero we have finished an insertion (see end_insertion ()) and we    want to ignore false continued paragraph closings. */
end_comment

begin_decl_stmt
name|int
name|insertion_paragraph_closed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means attempt to make all of the lines have fill_column width. */
end_comment

begin_decl_stmt
name|int
name|do_justification
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't replace whitespace with&nbsp; in HTML mode.  */
end_comment

begin_decl_stmt
name|int
name|in_html_elt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|brace_element
block|{
name|struct
name|brace_element
modifier|*
name|next
decl_stmt|;
name|COMMAND_FUNCTION
modifier|*
name|proc
decl_stmt|;
name|char
modifier|*
name|command
decl_stmt|;
name|int
name|pos
decl_stmt|,
name|line
decl_stmt|;
name|int
name|in_fixed_width_font
decl_stmt|;
block|}
name|BRACE_ELEMENT
typedef|;
end_typedef

begin_decl_stmt
name|BRACE_ELEMENT
modifier|*
name|brace_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|do_multitable
argument_list|()
decl_stmt|,
name|end_multitable
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|push_node_filename
argument_list|()
decl_stmt|,
name|pop_node_filename
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|remember_error
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|convert_from_stream
argument_list|()
decl_stmt|,
name|convert_from_file
argument_list|()
decl_stmt|,
name|convert_from_loaded_file
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|init_internals
argument_list|()
decl_stmt|,
name|init_paragraph
argument_list|()
decl_stmt|,
name|init_brace_stack
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|init_insertion_stack
argument_list|()
decl_stmt|,
name|init_indices
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|init_tag_table
argument_list|()
decl_stmt|,
name|write_tag_table
argument_list|()
decl_stmt|,
name|write_tag_table_internal
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|validate_file
argument_list|()
decl_stmt|,
name|validate_other_references
argument_list|()
decl_stmt|,
name|split_file
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|free_node_references
argument_list|()
decl_stmt|,
name|handle_variable
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|handle_variable_internal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|normalize_node_name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|add_anchor_name
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|free_node_node_references
argument_list|()
decl_stmt|,
name|remember_node_node_reference
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
modifier|*
name|get_brace_args
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|array_len
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|free_array
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|end_of_sentence_p
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isolate_nodename
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|reader_loop
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|remember_brace
argument_list|()
decl_stmt|,
name|remember_brace_1
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|pop_and_call_brace
argument_list|()
decl_stmt|,
name|discard_braces
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|add_word
argument_list|()
decl_stmt|,
name|add_char
argument_list|()
decl_stmt|,
name|insert
argument_list|()
decl_stmt|,
name|flush_output
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|insert_string
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|close_paragraph
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ignore_blank_line
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|do_flush_right_indentation
argument_list|()
decl_stmt|,
name|discard_insertions
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|start_paragraph
argument_list|()
decl_stmt|,
name|indent
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|inhibit_output_flushing
argument_list|()
decl_stmt|,
name|uninhibit_output_flushing
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|set_paragraph_indent
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|self_delimiting
argument_list|()
decl_stmt|,
name|search_forward
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|multitable_item
argument_list|()
decl_stmt|,
name|number_of_node
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|add_link
argument_list|()
decl_stmt|,
name|add_escaped_anchor_name
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|me_execute_string_keep_state
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|maybe_update_execution_strings
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|escape_string
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|insert_html_tag
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|sectioning_html
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|add_link
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VA_FPRINTF
argument_list|)
operator|&&
name|__STDC__
end_if

begin_comment
comment|/* Unfortunately we must use prototypes if we are to use<stdarg.h>.  */
end_comment

begin_function_decl
name|void
name|add_word_args
parameter_list|(
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|execute_string
parameter_list|(
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|void
name|add_word_args
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|execute_string
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no prototypes */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Error handling.  */
end_comment

begin_comment
comment|/* Number of errors encountered. */
end_comment

begin_decl_stmt
name|int
name|errors_printed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print the last error gotten from the file system. */
end_comment

begin_function
name|int
name|fs_error
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|remember_error
argument_list|()
expr_stmt|;
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Print an error message, and return false. */
end_comment

begin_decl_stmt
name|void
if|#
directive|if
name|defined
argument_list|(
name|VA_FPRINTF
argument_list|)
operator|&&
name|__STDC__
name|error
argument_list|(
name|char
operator|*
name|format
argument_list|,
operator|...
argument_list|)
else|#
directive|else
name|error
argument_list|(
name|format
argument_list|,
name|va_alist
argument_list|)
name|char
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
ifdef|#
directive|ifdef
name|VA_FPRINTF
name|va_list
name|ap
decl_stmt|;
endif|#
directive|endif
name|remember_error
argument_list|()
expr_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VA_FPRINTF
name|VA_FPRINTF
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not VA_FPRINTF */
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Just like error (), but print the input file and line number as well. */
end_comment

begin_function
name|void
if|#
directive|if
name|defined
argument_list|(
name|VA_FPRINTF
argument_list|)
operator|&&
name|__STDC__
name|file_line_error
parameter_list|(
name|char
modifier|*
name|infile
parameter_list|,
name|int
name|lno
parameter_list|,
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|file_line_error
parameter_list|(
name|infile
parameter_list|,
name|lno
parameter_list|,
name|format
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|infile
decl_stmt|;
name|int
name|lno
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|VA_FPRINTF
name|va_list
name|ap
decl_stmt|;
endif|#
directive|endif
name|remember_error
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|infile
argument_list|,
name|lno
argument_list|)
expr_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VA_FPRINTF
name|VA_FPRINTF
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not VA_FPRINTF */
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Just like file_line_error (), but take the input file and the line    number from global variables. */
end_comment

begin_function
name|void
if|#
directive|if
name|defined
argument_list|(
name|VA_FPRINTF
argument_list|)
operator|&&
name|__STDC__
name|line_error
parameter_list|(
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|line_error
parameter_list|(
name|format
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|VA_FPRINTF
name|va_list
name|ap
decl_stmt|;
endif|#
directive|endif
name|remember_error
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|input_filename
argument_list|,
name|line_number
argument_list|)
expr_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VA_FPRINTF
name|VA_FPRINTF
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not VA_FPRINTF */
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
if|#
directive|if
name|defined
argument_list|(
name|VA_FPRINTF
argument_list|)
operator|&&
name|__STDC__
name|warning
argument_list|(
name|char
operator|*
name|format
argument_list|,
operator|...
argument_list|)
else|#
directive|else
name|warning
argument_list|(
name|format
argument_list|,
name|va_alist
argument_list|)
name|char
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
ifdef|#
directive|ifdef
name|VA_FPRINTF
name|va_list
name|ap
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|print_warnings
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s:%d: warning: "
argument_list|)
argument_list|,
name|input_filename
argument_list|,
name|line_number
argument_list|)
expr_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VA_FPRINTF
name|VA_FPRINTF
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not VA_FPRINTF */
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Remember that an error has been printed.  If more than    max_error_level have been printed, then exit the program. */
end_comment

begin_function
name|void
name|remember_error
parameter_list|()
block|{
name|errors_printed
operator|++
expr_stmt|;
if|if
condition|(
name|max_error_level
operator|&&
operator|(
name|errors_printed
operator|>
name|max_error_level
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Too many errors!  Gave up.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|flush_file_stack
argument_list|()
expr_stmt|;
name|cm_bye
argument_list|()
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The other side of a malformed expression. */
end_comment

begin_function
name|void
name|misplaced_brace
parameter_list|()
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Misplaced %c"
argument_list|)
argument_list|,
literal|'}'
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Main.  */
end_comment

begin_comment
comment|/* Display the version info of this invocation of Makeinfo. */
end_comment

begin_function
specifier|static
name|void
name|print_version_info
parameter_list|()
block|{
name|printf
argument_list|(
literal|"makeinfo (GNU %s) %s\n"
argument_list|,
name|PACKAGE
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If EXIT_VALUE is zero, print the full usage message to stdout.    Otherwise, just say to use --help for more info.    Then exit with EXIT_VALUE. */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|exit_value
parameter_list|)
name|int
name|exit_value
decl_stmt|;
block|{
if|if
condition|(
name|exit_value
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Try `%s --help' for more information.\n"
argument_list|)
argument_list|,
name|progname
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Usage: %s [OPTION]... TEXINFO-FILE...\n"
argument_list|)
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* xgettext: no-wrap */
name|puts
argument_list|(
name|_
argument_list|(
literal|"\ Translate Texinfo source documentation to various other formats, by default\n\ Info files suitable for reading online with Emacs or standalone GNU Info.\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* xgettext: no-wrap */
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ General options:\n\       --error-limit=NUM       quit after NUM errors (default %d).\n\       --force                 preserve output even if errors.\n\       --help                  display this help and exit.\n\       --no-validate           suppress node cross-reference validation.\n\       --no-warn               suppress warnings (but not errors).\n\       --reference-limit=NUM   warn about at most NUM references (default %d).\n\   -v, --verbose               explain what is being done.\n\       --version               display version information and exit.\n"
argument_list|)
argument_list|,
name|max_error_level
argument_list|,
name|reference_warning_limit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* xgettext: no-wrap */
name|puts
argument_list|(
name|_
argument_list|(
literal|"\ Output format selection (default is to produce Info):\n\       --docbook             output DocBook rather than Info.\n\       --html                output HTML rather than Info.\n\       --no-headers          output plain text, suppressing Info node\n\                               separators and Node: lines; also, write to\n\                               standard output without --output.\n\       --xml                 output XML (TexinfoML) rather than Info.\n\ "
argument_list|)
argument_list|)
expr_stmt|;
name|puts
argument_list|(
name|_
argument_list|(
literal|"\ General output options:\n\   -E, --macro-expand FILE   output macro-expanded source to FILE.\n\                             ignoring any @setfilename.\n\       --no-split            suppress splitting of Info or HTML output,\n\                             generate only one output file.\n\       --number-sections     output chapter and sectioning numbers.\n\   -o, --output=FILE         output to FILE (directory if split HTML),\n\ "
argument_list|)
argument_list|)
expr_stmt|;
comment|/* xgettext: no-wrap */
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ Options for Info and plain text:\n\       --enable-encoding       output accented and special characters in\n\                                 Info output based on @documentencoding.\n\       --fill-column=NUM       break Info lines at NUM characters (default %d).\n\       --footnote-style=STYLE  output footnotes in Info according to STYLE:\n\                                 `separate' to put them in their own node;\n\                                 `end' to put them at the end of the node\n\                                   in which they are defined (default).\n\       --paragraph-indent=VAL  indent Info paragraphs by VAL spaces (default %d).\n\                                 If VAL is `none', do not indent; if VAL is\n\                                 `asis', preserve existing indentation.\n\       --split-size=NUM        split Info files at size NUM (default %d).\n"
argument_list|)
argument_list|,
name|fill_column
argument_list|,
name|paragraph_start_indent
argument_list|,
name|DEFAULT_SPLIT_SIZE
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* xgettext: no-wrap */
name|puts
argument_list|(
name|_
argument_list|(
literal|"\ Input file options:\n\       --commands-in-node-names   allow @ commands in node names.\n\   -D VAR                         define the variable VAR, as with @set.\n\   -I DIR                         append DIR to the @include search path.\n\   -P DIR                         prepend DIR to the @include search path.\n\   -U VAR                         undefine the variable VAR, as with @clear.\n\ "
argument_list|)
argument_list|)
expr_stmt|;
comment|/* xgettext: no-wrap */
name|puts
argument_list|(
name|_
argument_list|(
literal|"\ Conditional processing in input:\n\      --ifhtml      process @ifhtml and @html even if not generating HTML.\n\      --ifinfo      process @ifinfo text even when generating HTML.\n\      --iftex       process @iftex and @tex text; implies --no-split.\n\      --no-ifhtml   do not process @ifhtml and @html text.\n\      --no-ifinfo   do not process @ifinfo text.\n\      --no-iftex    do not process @iftex and @tex text.\n\ "
argument_list|)
argument_list|)
expr_stmt|;
comment|/* xgettext: no-wrap */
name|puts
argument_list|(
name|_
argument_list|(
literal|"\   The defaults for the @if... conditionals depend on the output format:\n\   if generating HTML, --ifhtml is on and the others are off;\n\   if generating Info or plain text, --ifinfo is on and the others are off.\n\ "
argument_list|)
argument_list|)
expr_stmt|;
comment|/* xgettext: no-wrap */
name|puts
argument_list|(
name|_
argument_list|(
literal|"\ Examples:\n\   makeinfo foo.texi                     write Info to foo's @setfilename\n\   makeinfo --html foo.texi              write HTML to foo's @setfilename\n\   makeinfo --no-headers -o - foo.texi   write plain text to standard output\n\   makeinfo --number-sections foo.texi   write Info with numbered sections\n\   makeinfo --no-split foo.texi          write one Info file however big\n\ "
argument_list|)
argument_list|)
expr_stmt|;
comment|/* xgettext: no-wrap */
name|puts
argument_list|(
name|_
argument_list|(
literal|"\ Email bug reports to bug-texinfo@gnu.org,\n\ general questions and discussion to help-texinfo@gnu.org."
argument_list|)
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
name|exit_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"commands-in-node-names"
block|,
literal|0
block|,
operator|&
name|expensive_validation
block|,
literal|1
block|}
block|,
block|{
literal|"docbook"
block|,
literal|0
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"enable-encoding"
block|,
literal|0
block|,
operator|&
name|enable_encoding
block|,
literal|1
block|}
block|,
block|{
literal|"error-limit"
block|,
literal|1
block|,
literal|0
block|,
literal|'e'
block|}
block|,
block|{
literal|"fill-column"
block|,
literal|1
block|,
literal|0
block|,
literal|'f'
block|}
block|,
block|{
literal|"footnote-style"
block|,
literal|1
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"force"
block|,
literal|0
block|,
operator|&
name|force
block|,
literal|1
block|}
block|,
block|{
literal|"help"
block|,
literal|0
block|,
literal|0
block|,
literal|'h'
block|}
block|,
block|{
literal|"html"
block|,
literal|0
block|,
literal|0
block|,
literal|'w'
block|}
block|,
block|{
literal|"ifhtml"
block|,
literal|0
block|,
operator|&
name|process_html
block|,
literal|1
block|}
block|,
block|{
literal|"ifinfo"
block|,
literal|0
block|,
operator|&
name|process_info
block|,
literal|1
block|}
block|,
block|{
literal|"iftex"
block|,
literal|0
block|,
operator|&
name|process_tex
block|,
literal|1
block|}
block|,
block|{
literal|"macro-expand"
block|,
literal|1
block|,
literal|0
block|,
literal|'E'
block|}
block|,
block|{
literal|"no-headers"
block|,
literal|0
block|,
operator|&
name|no_headers
block|,
literal|1
block|}
block|,
block|{
literal|"no-ifhtml"
block|,
literal|0
block|,
operator|&
name|process_html
block|,
literal|0
block|}
block|,
block|{
literal|"no-ifinfo"
block|,
literal|0
block|,
operator|&
name|process_info
block|,
literal|0
block|}
block|,
block|{
literal|"no-iftex"
block|,
literal|0
block|,
operator|&
name|process_tex
block|,
literal|0
block|}
block|,
block|{
literal|"no-number-footnotes"
block|,
literal|0
block|,
operator|&
name|number_footnotes
block|,
literal|0
block|}
block|,
block|{
literal|"no-number-sections"
block|,
literal|0
block|,
operator|&
name|number_sections
block|,
literal|0
block|}
block|,
block|{
literal|"no-pointer-validate"
block|,
literal|0
block|,
operator|&
name|validating
block|,
literal|0
block|}
block|,
block|{
literal|"no-split"
block|,
literal|0
block|,
operator|&
name|splitting
block|,
literal|0
block|}
block|,
block|{
literal|"no-validate"
block|,
literal|0
block|,
operator|&
name|validating
block|,
literal|0
block|}
block|,
block|{
literal|"no-warn"
block|,
literal|0
block|,
operator|&
name|print_warnings
block|,
literal|0
block|}
block|,
block|{
literal|"number-footnotes"
block|,
literal|0
block|,
operator|&
name|number_footnotes
block|,
literal|1
block|}
block|,
block|{
literal|"number-sections"
block|,
literal|0
block|,
operator|&
name|number_sections
block|,
literal|1
block|}
block|,
block|{
literal|"output"
block|,
literal|1
block|,
literal|0
block|,
literal|'o'
block|}
block|,
block|{
literal|"paragraph-indent"
block|,
literal|1
block|,
literal|0
block|,
literal|'p'
block|}
block|,
block|{
literal|"reference-limit"
block|,
literal|1
block|,
literal|0
block|,
literal|'r'
block|}
block|,
block|{
literal|"split-size"
block|,
literal|1
block|,
literal|0
block|,
literal|'S'
block|}
block|,
block|{
literal|"verbose"
block|,
literal|0
block|,
operator|&
name|verbose_mode
block|,
literal|1
block|}
block|,
block|{
literal|"version"
block|,
literal|0
block|,
literal|0
block|,
literal|'V'
block|}
block|,
block|{
literal|"xml"
block|,
literal|0
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each file mentioned in the command line, process it, turning    Texinfo commands into wonderfully formatted output text. */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|extern
name|int
name|errors_printed
decl_stmt|;
name|int
name|c
decl_stmt|,
name|ind
decl_stmt|;
name|int
name|reading_from_stdin
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SETLOCALE
comment|/* Do not use LC_ALL, because LC_NUMERIC screws up the scanf parsing      of the argument to @multicolumn.  */
name|setlocale
argument_list|(
name|LC_TIME
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|setlocale
argument_list|(
name|LC_COLLATE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set the text message domain.  */
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
comment|/* Parse argument flags from the input line. */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"D:de:E:f:hI:o:p:P:r:s:U:vV:wx"
argument_list|,
name|long_options
argument_list|,
operator|&
name|ind
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|0
operator|&&
name|long_options
index|[
name|ind
index|]
operator|.
name|flag
operator|==
literal|0
condition|)
name|c
operator|=
name|long_options
index|[
name|ind
index|]
operator|.
name|val
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'D'
case|:
case|case
literal|'U'
case|:
comment|/* User specified variable to set or clear. */
name|handle_variable_internal
argument_list|(
operator|(
name|c
operator|==
literal|'D'
operator|)
condition|?
name|SET
else|:
name|CLEAR
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* --docbook */
name|splitting
operator|=
literal|0
expr_stmt|;
name|xml
operator|=
literal|1
expr_stmt|;
name|docbook
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* --error-limit */
if|if
condition|(
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|max_error_level
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: %s arg must be numeric, not `%s'.\n"
argument_list|)
argument_list|,
literal|"--error-limit"
argument_list|,
name|progname
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'E'
case|:
comment|/* --macro-expand */
if|if
condition|(
operator|!
name|macro_expansion_output_stream
condition|)
block|{
name|macro_expansion_filename
operator|=
name|optarg
expr_stmt|;
name|macro_expansion_output_stream
operator|=
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|?
name|stdout
else|:
name|fopen
argument_list|(
name|optarg
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|macro_expansion_output_stream
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"Couldn't open macro expansion output `%s'"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
name|_
argument_list|(
literal|"Cannot specify more than one macro expansion output"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* --fill-column */
if|if
condition|(
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|fill_column
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: %s arg must be numeric, not `%s'.\n"
argument_list|)
argument_list|,
literal|"--fill-column"
argument_list|,
name|progname
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'h'
case|:
comment|/* --help */
name|usage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* Append user-specified dir to include file path. */
if|if
condition|(
operator|!
name|include_files_path
condition|)
name|include_files_path
operator|=
name|xstrdup
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|include_files_path
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|include_files_path
argument_list|,
literal|2
operator|+
name|strlen
argument_list|(
name|include_files_path
argument_list|)
operator|+
name|strlen
argument_list|(
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|include_files_path
argument_list|,
name|PATH_SEP
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|include_files_path
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* --output */
name|command_output_filename
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* --paragraph-indent */
if|if
condition|(
name|set_paragraph_indent
argument_list|(
name|optarg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: --paragraph-indent arg must be numeric/`none'/`asis', not `%s'.\n"
argument_list|)
argument_list|,
name|progname
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'P'
case|:
comment|/* Prepend user-specified include dir to include path. */
if|if
condition|(
operator|!
name|include_files_path
condition|)
block|{
name|include_files_path
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|include_files_path
operator|=
name|xrealloc
argument_list|(
name|include_files_path
argument_list|,
name|strlen
argument_list|(
name|include_files_path
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
comment|/* 3 for ":.\0" */
name|strcat
argument_list|(
name|strcat
argument_list|(
name|include_files_path
argument_list|,
name|PATH_SEP
argument_list|)
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|tmp
init|=
name|xstrdup
argument_list|(
name|include_files_path
argument_list|)
decl_stmt|;
name|include_files_path
operator|=
name|xrealloc
argument_list|(
name|include_files_path
argument_list|,
name|strlen
argument_list|(
name|include_files_path
argument_list|)
operator|+
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* 2 for ":\0" */
name|strcpy
argument_list|(
name|include_files_path
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|include_files_path
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|include_files_path
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
comment|/* --reference-limit */
if|if
condition|(
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|reference_warning_limit
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: %s arg must be numeric, not `%s'.\n"
argument_list|)
argument_list|,
literal|"--reference-limit"
argument_list|,
name|progname
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'s'
case|:
comment|/* --footnote-style */
if|if
condition|(
name|set_footnote_style
argument_list|(
name|optarg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: --footnote-style arg must be `separate' or `end', not `%s'.\n"
argument_list|)
argument_list|,
name|progname
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|footnote_style_preset
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* --split-size */
if|if
condition|(
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|split_size
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: %s arg must be numeric, not `%s'.\n"
argument_list|)
argument_list|,
literal|"--split-size"
argument_list|,
name|progname
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
name|verbose_mode
operator|++
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* --version */
name|print_version_info
argument_list|()
expr_stmt|;
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Copyright (C) %s Free Software Foundation, Inc.\n\ There is NO warranty.  You may redistribute this software\n\ under the terms of the GNU General Public License.\n\ For more information about these matters, see the files named COPYING.\n"
argument_list|)
argument_list|,
literal|"2002"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* --html */
name|html
operator|=
literal|1
expr_stmt|;
name|process_html
operator|=
literal|1
expr_stmt|;
name|process_info
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* --xml */
name|splitting
operator|=
literal|0
expr_stmt|;
name|xml
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|validating
condition|)
name|expensive_validation
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
block|{
comment|/* Check to see if input is a file.  If so, process that. */
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
name|reading_from_stdin
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: missing file argument.\n"
argument_list|)
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|no_headers
condition|)
block|{
if|if
condition|(
name|html
operator|&&
name|splitting
condition|)
block|{
comment|/* --no-headers --no-split --html indicates confusion. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: --no-headers conflicts with --no-split for --html.\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* --no-headers implies --no-split.  */
name|splitting
operator|=
literal|0
expr_stmt|;
comment|/* If the user did not specify an output file, use stdout. */
if|if
condition|(
operator|!
name|command_output_filename
condition|)
name|command_output_filename
operator|=
name|xstrdup
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose_mode
condition|)
name|print_version_info
argument_list|()
expr_stmt|;
comment|/* Remaining arguments are file names of texinfo files.      Convert them, one by one. */
if|if
condition|(
operator|!
name|reading_from_stdin
condition|)
block|{
while|while
condition|(
name|optind
operator|!=
name|argc
condition|)
name|convert_from_file
argument_list|(
name|argv
index|[
name|optind
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|convert_from_stream
argument_list|(
name|stdin
argument_list|,
literal|"stdin"
argument_list|)
expr_stmt|;
return|return
name|errors_printed
condition|?
literal|2
else|:
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hacking tokens and strings.  */
end_comment

begin_comment
comment|/* Return the next token as a string pointer.  We cons the string. */
end_comment

begin_function
name|char
modifier|*
name|read_token
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|character
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
comment|/* If the first character to be read is self-delimiting, then that      is the command itself. */
name|character
operator|=
name|curchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|self_delimiting
argument_list|(
name|character
argument_list|)
condition|)
block|{
name|input_text_offset
operator|++
expr_stmt|;
if|if
condition|(
name|character
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
name|result
operator|=
name|xstrdup
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|character
expr_stmt|;
return|return
name|result
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|input_text_offset
operator|!=
name|input_text_length
operator|)
operator|&&
operator|(
name|character
operator|=
name|curchar
argument_list|()
operator|)
operator|&&
name|command_char
argument_list|(
name|character
argument_list|)
operator|)
condition|;
name|i
operator|++
operator|,
name|input_text_offset
operator|++
control|)
empty_stmt|;
name|result
operator|=
name|xmalloc
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|result
argument_list|,
operator|&
name|input_text
index|[
name|input_text_offset
operator|-
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|result
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if CHARACTER is self-delimiting. */
end_comment

begin_function
name|int
name|self_delimiting
parameter_list|(
name|character
parameter_list|)
name|int
name|character
decl_stmt|;
block|{
comment|/* @; and @\ are not Texinfo commands, but they are listed here      anyway.  I don't know why.  --karl, 10aug96.  */
return|return
name|strchr
argument_list|(
literal|"~{|}`^\\@?=;:.-,*\'\" !\n\t"
argument_list|,
name|character
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Clear whitespace from the front and end of string. */
end_comment

begin_function
name|void
name|canon_white
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|x
decl_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
return|return;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|len
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|cr_or_whitespace
argument_list|(
name|string
index|[
name|x
index|]
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|string
argument_list|,
name|string
operator|+
name|x
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|len
operator|--
expr_stmt|;
while|while
condition|(
name|len
operator|>
operator|-
literal|1
operator|&&
name|cr_or_whitespace
argument_list|(
name|string
index|[
name|len
index|]
argument_list|)
condition|)
name|len
operator|--
expr_stmt|;
name|string
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Bash STRING, replacing all whitespace with just one space. */
end_comment

begin_function
name|void
name|fix_whitespace
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|temp
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|string_index
init|=
literal|0
decl_stmt|;
name|int
name|temp_index
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|canon_white
argument_list|(
name|string
argument_list|)
expr_stmt|;
while|while
condition|(
name|string
index|[
name|string_index
index|]
condition|)
block|{
name|c
operator|=
name|temp
index|[
name|temp_index
operator|++
index|]
operator|=
name|string
index|[
name|string_index
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
block|{
name|temp
index|[
name|temp_index
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|string
index|[
name|string_index
index|]
operator|)
operator|&&
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
name|string_index
operator|++
expr_stmt|;
block|}
block|}
name|temp
index|[
name|temp_index
index|]
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|string
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Discard text until the desired string is found.  The string is    included in the discarded text. */
end_comment

begin_function
name|void
name|discard_until
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|int
name|temp
init|=
name|search_forward
argument_list|(
name|string
argument_list|,
name|input_text_offset
argument_list|)
decl_stmt|;
name|int
name|tt
init|=
operator|(
name|temp
operator|<
literal|0
operator|)
condition|?
name|input_text_length
else|:
name|temp
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|from
init|=
name|input_text_offset
decl_stmt|;
comment|/* Find out what line we are on. */
while|while
condition|(
name|from
operator|!=
name|tt
condition|)
if|if
condition|(
name|input_text
index|[
name|from
operator|++
index|]
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|input_text_offset
operator|=
name|input_text_length
operator|-
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"\n"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Expected `%s'"
argument_list|)
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|input_text_offset
operator|=
name|temp
expr_stmt|;
name|input_text_offset
operator|+=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read characters from the file until we are at MATCH.    Place the characters read into STRING.    On exit input_text_offset is after the match string.    Return the offset where the string starts. */
end_comment

begin_function
name|int
name|get_until
parameter_list|(
name|match
parameter_list|,
name|string
parameter_list|)
name|char
modifier|*
name|match
decl_stmt|,
decl|*
modifier|*
name|string
decl_stmt|;
end_function

begin_block
block|{
name|int
name|len
decl_stmt|,
name|current_point
decl_stmt|,
name|x
decl_stmt|,
name|new_point
decl_stmt|,
name|tem
decl_stmt|;
name|current_point
operator|=
name|x
operator|=
name|input_text_offset
expr_stmt|;
name|new_point
operator|=
name|search_forward
argument_list|(
name|match
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_point
operator|<
literal|0
condition|)
name|new_point
operator|=
name|input_text_length
expr_stmt|;
name|len
operator|=
name|new_point
operator|-
name|current_point
expr_stmt|;
comment|/* Keep track of which line number we are at. */
name|tem
operator|=
name|new_point
operator|+
operator|(
name|strlen
argument_list|(
name|match
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|x
operator|!=
name|tem
condition|)
if|if
condition|(
name|input_text
index|[
name|x
operator|++
index|]
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
operator|*
name|string
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|string
argument_list|,
operator|&
name|input_text
index|[
name|current_point
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
operator|*
name|string
operator|)
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Now leave input_text_offset in a consistent state. */
name|input_text_offset
operator|=
name|tem
expr_stmt|;
if|if
condition|(
name|input_text_offset
operator|>
name|input_text_length
condition|)
name|input_text_offset
operator|=
name|input_text_length
expr_stmt|;
return|return
name|new_point
return|;
block|}
end_block

begin_comment
comment|/* Replace input_text[FROM .. TO] with its expansion.  */
end_comment

begin_function
name|void
name|replace_with_expansion
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|int
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|xp
decl_stmt|;
name|unsigned
name|xp_len
decl_stmt|,
name|new_len
decl_stmt|;
name|char
modifier|*
name|old_input
init|=
name|input_text
decl_stmt|;
name|unsigned
name|raw_len
init|=
operator|*
name|to
operator|-
name|from
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
comment|/* The rest of the code here moves large buffers, so let's      not waste time if the input cannot possibly expand      into anything.  Unfortunately, we cannot avoid expansion      when we see things like @code etc., even if they only      asked for expansion of macros, since any Texinfo command      can be potentially redefined with a macro.  */
if|if
condition|(
name|only_macro_expansion
operator|&&
name|memchr
argument_list|(
name|input_text
operator|+
name|from
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|raw_len
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* Get original string from input.  */
name|str
operator|=
name|xmalloc
argument_list|(
name|raw_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|str
argument_list|,
name|input_text
operator|+
name|from
argument_list|,
name|raw_len
argument_list|)
expr_stmt|;
name|str
index|[
name|raw_len
index|]
operator|=
literal|0
expr_stmt|;
comment|/* We are going to relocate input_text, so we had better output      pending portion of input_text now, before the pointer changes.  */
if|if
condition|(
name|macro_expansion_output_stream
operator|&&
operator|!
name|executing_string
operator|&&
operator|!
name|me_inhibit_expansion
condition|)
name|append_to_expansion_output
argument_list|(
name|from
argument_list|)
expr_stmt|;
comment|/* Expand it.  */
name|xp
operator|=
name|expansion
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xp_len
operator|=
name|strlen
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* Plunk the expansion into the middle of `input_text' --      which is terminated by a newline, not a null.  Avoid      expensive move of the rest of the input if the expansion      has the same length as the original string.  */
if|if
condition|(
name|xp_len
operator|!=
name|raw_len
condition|)
block|{
name|new_len
operator|=
name|from
operator|+
name|xp_len
operator|+
name|input_text_length
operator|-
operator|*
name|to
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|executing_string
condition|)
block|{
comment|/* If we are in execute_string, we might need to update              the relevant element in the execution_strings[] array,              since it could have to be relocated from under our              feet.  (input_text is reallocated here as well, if needed.)  */
name|maybe_update_execution_strings
argument_list|(
operator|&
name|input_text
argument_list|,
name|new_len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new_len
operator|>
name|input_text_length
operator|+
literal|1
condition|)
comment|/* Don't bother to realloc if we have enough space.  */
name|input_text
operator|=
name|xrealloc
argument_list|(
name|input_text
argument_list|,
name|new_len
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|input_text
operator|+
name|from
operator|+
name|xp_len
argument_list|,
name|input_text
operator|+
operator|*
name|to
argument_list|,
name|input_text_length
operator|-
operator|*
name|to
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|to
operator|+=
name|xp_len
operator|-
name|raw_len
expr_stmt|;
comment|/* Since we change input_text_length here, the comparison above          isn't really valid, but it seems the worst that might happen is          an extra xrealloc or two, so let's not worry.  */
name|input_text_length
operator|+=
name|xp_len
operator|-
name|raw_len
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|input_text
operator|+
name|from
argument_list|,
name|xp
argument_list|,
name|xp_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xp
argument_list|)
expr_stmt|;
comment|/* Synchronize the macro-expansion pointers with our new input_text.  */
if|if
condition|(
name|input_text
operator|!=
name|old_input
condition|)
name|forget_itext
argument_list|(
name|old_input
argument_list|)
expr_stmt|;
if|if
condition|(
name|macro_expansion_output_stream
operator|&&
operator|!
name|executing_string
condition|)
name|remember_itext
argument_list|(
name|input_text
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Read characters from the file until we are at MATCH or end of line.    Place the characters read into STRING.  If EXPAND is nonzero,    expand the text before looking for MATCH for those cases where    MATCH might be produced by some macro.  */
end_comment

begin_function
name|void
name|get_until_in_line
parameter_list|(
name|expand
parameter_list|,
name|match
parameter_list|,
name|string
parameter_list|)
name|int
name|expand
decl_stmt|;
name|char
modifier|*
name|match
decl_stmt|,
decl|*
modifier|*
name|string
decl_stmt|;
end_function

begin_block
block|{
name|int
name|real_bottom
init|=
name|input_text_length
decl_stmt|;
name|int
name|limit
init|=
name|search_forward
argument_list|(
literal|"\n"
argument_list|,
name|input_text_offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|limit
operator|<
literal|0
condition|)
name|limit
operator|=
name|input_text_length
expr_stmt|;
comment|/* Replace input_text[input_text_offset .. limit-1] with its expansion.      This allows the node names and menu entries themselves to be      constructed via a macro, as in:         @macro foo{p, q}         Together: \p\& \q\.         @end macro          @node @foo{A,B}, next, prev, top       Otherwise, the `,' separating the macro args A and B is taken as      the node argument separator, so the node name is `@foo{A'.  This      expansion is only necessary on the first call, since we expand the      whole line then.  */
if|if
condition|(
name|expand
condition|)
block|{
name|replace_with_expansion
argument_list|(
name|input_text_offset
argument_list|,
operator|&
name|limit
argument_list|)
expr_stmt|;
block|}
name|real_bottom
operator|=
name|input_text_length
expr_stmt|;
name|input_text_length
operator|=
name|limit
expr_stmt|;
name|get_until
argument_list|(
name|match
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|input_text_length
operator|=
name|real_bottom
expr_stmt|;
block|}
end_block

begin_function
name|void
name|get_rest_of_line
parameter_list|(
name|expand
parameter_list|,
name|string
parameter_list|)
name|int
name|expand
decl_stmt|;
name|char
modifier|*
modifier|*
name|string
decl_stmt|;
block|{
name|xml_no_para
operator|++
expr_stmt|;
if|if
condition|(
name|expand
condition|)
block|{
name|char
modifier|*
name|tem
decl_stmt|;
comment|/* Don't expand non-macros in input, since we want them 	 intact in the macro-expanded output.  */
name|only_macro_expansion
operator|++
expr_stmt|;
name|get_until_in_line
argument_list|(
literal|1
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|tem
argument_list|)
expr_stmt|;
name|only_macro_expansion
operator|--
expr_stmt|;
operator|*
name|string
operator|=
name|expansion
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
else|else
name|get_until_in_line
argument_list|(
literal|0
argument_list|,
literal|"\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|canon_white
argument_list|(
operator|*
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|'\n'
condition|)
comment|/* as opposed to the end of the file... */
block|{
name|line_number
operator|++
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
block|}
name|xml_no_para
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Backup the input pointer to the previous character, keeping track    of the current line number. */
end_comment

begin_function
name|void
name|backup_input_pointer
parameter_list|()
block|{
if|if
condition|(
name|input_text_offset
condition|)
block|{
name|input_text_offset
operator|--
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|'\n'
condition|)
name|line_number
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read characters from the file until we are at MATCH or closing brace.    Place the characters read into STRING.  */
end_comment

begin_function
name|void
name|get_until_in_braces
parameter_list|(
name|match
parameter_list|,
name|string
parameter_list|)
name|char
modifier|*
name|match
decl_stmt|,
decl|*
modifier|*
name|string
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|brace
init|=
literal|0
decl_stmt|;
name|int
name|match_len
init|=
name|strlen
argument_list|(
name|match
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|input_text_offset
init|;
name|i
operator|<
name|input_text_length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|input_text_length
operator|-
literal|1
operator|&&
name|input_text
index|[
name|i
index|]
operator|==
literal|'@'
condition|)
block|{
name|i
operator|++
expr_stmt|;
comment|/* skip commands like @, and @{ */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|input_text
index|[
name|i
index|]
operator|==
literal|'{'
condition|)
name|brace
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|input_text
index|[
name|i
index|]
operator|==
literal|'}'
condition|)
block|{
name|brace
operator|--
expr_stmt|;
comment|/* If looking for a brace, don't stop at the interior brace,              like after "baz" in "@foo{something @bar{baz} more}".  */
if|if
condition|(
name|brace
operator|==
literal|0
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|input_text
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
if|if
condition|(
name|brace
operator|<
literal|0
operator|||
operator|(
name|brace
operator|==
literal|0
operator|&&
name|strncmp
argument_list|(
name|input_text
operator|+
name|i
argument_list|,
name|match
argument_list|,
name|match_len
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
name|match_len
operator|=
name|i
operator|-
name|input_text_offset
expr_stmt|;
name|temp
operator|=
name|xmalloc
argument_list|(
literal|2
operator|+
name|match_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|temp
argument_list|,
name|input_text
operator|+
name|input_text_offset
argument_list|,
name|match_len
argument_list|)
expr_stmt|;
name|temp
index|[
name|match_len
index|]
operator|=
literal|0
expr_stmt|;
name|input_text_offset
operator|=
name|i
expr_stmt|;
operator|*
name|string
operator|=
name|temp
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Converting a file.  */
end_comment

begin_comment
comment|/* Convert the file named by NAME.  The output is saved on the file    named as the argument to the @setfilename command. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|suffixes
index|[]
init|=
block|{
comment|/* ".txi" is checked first so that on 8+3 DOS filesystems, if they      have "texinfo.txi" and "texinfo.tex" in the same directory, the      former is used rather than the latter, due to file name truncation.  */
literal|".txi"
block|,
literal|".texinfo"
block|,
literal|".texi"
block|,
literal|".txinfo"
block|,
literal|""
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|initialize_conversion
parameter_list|()
block|{
name|init_tag_table
argument_list|()
expr_stmt|;
name|init_indices
argument_list|()
expr_stmt|;
name|init_internals
argument_list|()
expr_stmt|;
name|init_paragraph
argument_list|()
expr_stmt|;
comment|/* This is used for splitting the output file and for doing section      headings.  It was previously initialized in `init_paragraph', but its      use there loses with the `init_paragraph' calls done by the      multitable code; the tag indices get reset to zero.  */
name|output_position
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|generic_list
block|{
name|struct
name|generic_list
modifier|*
name|next
decl_stmt|;
block|}
name|GENERIC_LIST
typedef|;
end_typedef

begin_comment
comment|/* Reverse the chain of structures in LIST.  Output the new head    of the chain.  You should always assign the output value of this    function to something, or you will lose the chain. */
end_comment

begin_function
name|GENERIC_LIST
modifier|*
name|reverse_list
parameter_list|(
name|list
parameter_list|)
name|GENERIC_LIST
modifier|*
name|list
decl_stmt|;
block|{
name|GENERIC_LIST
modifier|*
name|next
decl_stmt|;
name|GENERIC_LIST
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|next
operator|=
name|list
operator|->
name|next
expr_stmt|;
name|list
operator|->
name|next
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|next
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* We read in multiples of 4k, simply because it is a typical pipe size    on unix systems. */
end_comment

begin_define
define|#
directive|define
name|READ_BUFFER_GROWTH
value|(4 * 4096)
end_define

begin_comment
comment|/* Convert the Texinfo file coming from the open stream STREAM.  Assume the    source of the stream is named NAME. */
end_comment

begin_function
name|void
name|convert_from_stream
parameter_list|(
name|stream
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|buffer
init|=
name|NULL
decl_stmt|;
name|int
name|buffer_offset
init|=
literal|0
decl_stmt|,
name|buffer_size
init|=
literal|0
decl_stmt|;
name|initialize_conversion
argument_list|()
expr_stmt|;
comment|/* Read until the end of the stream.  This isn't strictly correct, since      the texinfo input may end before the stream ends, but it is a quick      working hueristic. */
while|while
condition|(
operator|!
name|feof
argument_list|(
name|stream
argument_list|)
condition|)
block|{
name|int
name|count
decl_stmt|;
if|if
condition|(
name|buffer_offset
operator|+
operator|(
name|READ_BUFFER_GROWTH
operator|+
literal|1
operator|)
operator|>=
name|buffer_size
condition|)
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buffer
argument_list|,
operator|(
name|buffer_size
operator|+=
name|READ_BUFFER_GROWTH
operator|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|fread
argument_list|(
name|buffer
operator|+
name|buffer_offset
argument_list|,
literal|1
argument_list|,
name|READ_BUFFER_GROWTH
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|buffer_offset
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* Set the globals to the new file. */
name|input_text
operator|=
name|buffer
expr_stmt|;
name|input_text_length
operator|=
name|buffer_offset
expr_stmt|;
name|input_filename
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|node_filename
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|input_text_offset
operator|=
literal|0
expr_stmt|;
name|line_number
operator|=
literal|1
expr_stmt|;
comment|/* Not strictly necessary.  This magic prevents read_token () from doing      extra unnecessary work each time it is called (that is a lot of times).      The INPUT_TEXT_LENGTH is one past the actual end of the text. */
name|input_text
index|[
name|input_text_length
index|]
operator|=
literal|'\n'
expr_stmt|;
name|convert_from_loaded_file
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|convert_from_file
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|filename
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|50
argument_list|)
decl_stmt|;
name|initialize_conversion
argument_list|()
expr_stmt|;
comment|/* Try to load the file specified by NAME, concatenated with our      various suffixes.  Prefer files like `makeinfo.texi' to      `makeinfo'.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|suffixes
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|strcpy
argument_list|(
name|filename
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|filename
argument_list|,
name|suffixes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_and_load
argument_list|(
name|filename
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|suffixes
index|[
name|i
index|]
index|[
literal|0
index|]
operator|&&
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'.'
argument_list|)
condition|)
block|{
name|fs_error
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|suffixes
index|[
name|i
index|]
condition|)
block|{
name|fs_error
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
name|input_filename
operator|=
name|filename
expr_stmt|;
name|convert_from_loaded_file
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given OUTPUT_FILENAME == ``/foo/bar/baz.html'', return    ``/foo/bar/baz/baz.html''.       Split html output goes into the subdirectory of the toplevel   filename, without extension.  For example:        @setfilename foo.info    produces output in files foo/index.html, foo/second-node.html, .... */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|insert_toplevel_subdirectory
parameter_list|(
name|output_filename
parameter_list|)
name|char
modifier|*
name|output_filename
decl_stmt|;
block|{
name|char
modifier|*
name|dir
decl_stmt|,
modifier|*
name|subdir
decl_stmt|,
modifier|*
name|base
decl_stmt|,
modifier|*
name|basename
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|max_name_len
decl_stmt|;
specifier|static
specifier|const
name|char
name|index_name
index|[]
init|=
literal|"index.html"
decl_stmt|;
specifier|const
name|int
name|index_len
init|=
sizeof|sizeof
argument_list|(
name|index_name
argument_list|)
operator|-
literal|1
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|output_filename
argument_list|)
expr_stmt|;
name|dir
operator|=
name|pathname_part
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|base
operator|=
name|filename_part
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|basename
operator|=
name|xstrdup
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* remember real @setfilename name */
name|p
operator|=
name|dir
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|>
name|dir
operator|&&
name|IS_SLASH
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|base
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|/* Split html output goes into subdirectory of toplevel name. */
name|subdir
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|FILENAME_CMP
argument_list|(
name|base
argument_list|,
name|filename_part
argument_list|(
name|dir
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|subdir
operator|=
name|base
expr_stmt|;
name|max_name_len
operator|=
name|strlen
argument_list|(
name|basename
argument_list|)
expr_stmt|;
if|if
condition|(
name|index_len
operator|>
name|max_name_len
condition|)
name|max_name_len
operator|=
name|index_len
expr_stmt|;
name|free
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
name|output_filename
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|subdir
argument_list|)
operator|+
literal|1
operator|+
name|max_name_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|output_filename
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|dir
argument_list|)
condition|)
name|strcat
argument_list|(
name|output_filename
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|output_filename
argument_list|,
name|subdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|output_filename
argument_list|,
literal|0777
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EEXIST
condition|)
block|{
comment|/* that failed, try subdir name with .html */
name|strcpy
argument_list|(
name|output_filename
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|dir
argument_list|)
condition|)
name|strcat
argument_list|(
name|output_filename
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|output_filename
argument_list|,
name|basename
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|output_filename
argument_list|,
literal|0777
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EEXIST
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Can't create directory `%s': %s"
argument_list|)
argument_list|,
name|output_filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|output_filename
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strlen
argument_list|(
name|subdir
argument_list|)
condition|)
name|strcat
argument_list|(
name|output_filename
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|output_filename
argument_list|,
name|index_name
argument_list|)
expr_stmt|;
return|return
name|output_filename
return|;
block|}
end_function

begin_comment
comment|/* FIXME: this is way too hairy */
end_comment

begin_function
name|void
name|convert_from_loaded_file
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|real_output_filename
init|=
name|NULL
decl_stmt|;
name|remember_itext
argument_list|(
name|input_text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|input_text_offset
operator|=
literal|0
expr_stmt|;
comment|/* Avoid the `\input texinfo' line in HTML output (assuming it starts      the file).  */
if|if
condition|(
name|looking_at
argument_list|(
literal|"\\input"
argument_list|)
condition|)
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Search this file looking for the special string which starts conversion.      Once found, we may truly begin. */
while|while
condition|(
name|input_text_offset
operator|>=
literal|0
condition|)
block|{
name|input_text_offset
operator|=
name|search_forward
argument_list|(
name|setfilename_search
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_text_offset
operator|==
literal|0
operator|||
operator|(
name|input_text_offset
operator|>
literal|0
operator|&&
name|input_text
index|[
name|input_text_offset
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|input_text_offset
operator|>
literal|0
condition|)
name|input_text_offset
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|input_text_offset
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|command_output_filename
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|REQUIRE_SETFILENAME
argument_list|)
name|error
argument_list|(
name|_
argument_list|(
literal|"No `%s' found in `%s'"
argument_list|)
argument_list|,
name|setfilename_search
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|finished
goto|;
else|#
directive|else
name|command_output_filename
operator|=
name|output_name_from_input_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !REQUIRE_SETFILENAME */
block|}
block|{
name|int
name|i
decl_stmt|,
name|end_of_first_line
decl_stmt|;
comment|/* Find the end of the first line in the file. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|input_text_length
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|input_text
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
break|break;
name|end_of_first_line
operator|=
name|i
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|end_of_first_line
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|input_text
index|[
name|i
index|]
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|input_text
operator|+
name|i
operator|+
literal|1
argument_list|,
literal|"input"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|input_text_offset
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
else|else
name|input_text_offset
operator|+=
name|strlen
argument_list|(
name|setfilename_search
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|command_output_filename
condition|)
block|{
name|get_until
argument_list|(
literal|"\n"
argument_list|,
operator|&
name|output_filename
argument_list|)
expr_stmt|;
comment|/* read rest of line */
if|if
condition|(
name|xml
operator|&&
operator|!
name|docbook
condition|)
name|xml_begin_document
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|html
operator|||
name|xml
condition|)
block|{
comment|/* Change any extension to .html or .xml.  */
name|char
modifier|*
name|html_name
decl_stmt|,
modifier|*
name|directory_part
decl_stmt|,
modifier|*
name|basename_part
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|canon_white
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
name|directory_part
operator|=
name|pathname_part
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
name|basename_part
operator|=
name|filename_part
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
comment|/* Zap any existing extension.  */
name|temp
operator|=
name|strrchr
argument_list|(
name|basename_part
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
operator|*
name|temp
operator|=
literal|0
expr_stmt|;
comment|/* Construct new filename.  */
name|html_name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|directory_part
argument_list|)
operator|+
name|strlen
argument_list|(
name|basename_part
argument_list|)
operator|+
literal|6
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|html_name
argument_list|,
name|directory_part
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|html_name
argument_list|,
name|basename_part
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|html_name
argument_list|,
name|html
condition|?
literal|".html"
else|:
literal|".xml"
argument_list|)
expr_stmt|;
comment|/* Replace name from @setfilename with the html name.  */
name|free
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
name|output_filename
operator|=
name|html_name
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|input_text_offset
operator|!=
operator|-
literal|1
condition|)
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
else|else
name|input_text_offset
operator|=
literal|0
expr_stmt|;
name|real_output_filename
operator|=
name|output_filename
operator|=
name|command_output_filename
expr_stmt|;
name|command_output_filename
operator|=
name|NULL
expr_stmt|;
block|}
name|canon_white
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
name|toplevel_output_filename
operator|=
name|xstrdup
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_output_filename
operator|&&
name|strcmp
argument_list|(
name|real_output_filename
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|macro_expansion_filename
operator|&&
name|strcmp
argument_list|(
name|macro_expansion_filename
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: Skipping macro expansion to stdout as Info output is going there.\n"
argument_list|)
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|macro_expansion_output_stream
operator|=
name|NULL
expr_stmt|;
block|}
name|real_output_filename
operator|=
name|xstrdup
argument_list|(
name|real_output_filename
argument_list|)
expr_stmt|;
name|output_stream
operator|=
name|stdout
expr_stmt|;
name|splitting
operator|=
literal|0
expr_stmt|;
comment|/* Cannot split when writing to stdout. */
block|}
else|else
block|{
if|if
condition|(
name|html
operator|&&
name|splitting
condition|)
block|{
if|if
condition|(
name|FILENAME_CMP
argument_list|(
name|output_filename
argument_list|,
name|NULL_DEVICE
argument_list|)
operator|==
literal|0
operator|||
name|FILENAME_CMP
argument_list|(
name|output_filename
argument_list|,
name|ALSO_NULL_DEVICE
argument_list|)
operator|==
literal|0
condition|)
name|splitting
operator|=
literal|0
expr_stmt|;
else|else
name|output_filename
operator|=
name|insert_toplevel_subdirectory
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
name|real_output_filename
operator|=
name|xstrdup
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|real_output_filename
condition|)
name|real_output_filename
operator|=
name|expand_filename
argument_list|(
name|output_filename
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|real_output_filename
operator|=
name|xstrdup
argument_list|(
name|real_output_filename
argument_list|)
expr_stmt|;
name|output_stream
operator|=
name|fopen
argument_list|(
name|real_output_filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
name|set_current_output_filename
argument_list|(
name|real_output_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose_mode
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"Making %s file `%s' from `%s'.\n"
argument_list|)
argument_list|,
name|no_headers
condition|?
literal|"text"
else|:
name|html
condition|?
literal|"HTML"
else|:
name|xml
condition|?
literal|"XML"
else|:
literal|"info"
argument_list|,
name|output_filename
argument_list|,
name|input_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_stream
operator|==
name|NULL
condition|)
block|{
name|fs_error
argument_list|(
name|real_output_filename
argument_list|)
expr_stmt|;
goto|goto
name|finished
goto|;
block|}
comment|/* Make the displayable filename from output_filename.  Only the base      portion of the filename need be displayed. */
name|flush_output
argument_list|()
expr_stmt|;
comment|/* in case there was no @bye */
if|if
condition|(
name|output_stream
operator|!=
name|stdout
condition|)
name|pretty_output_filename
operator|=
name|filename_part
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
else|else
name|pretty_output_filename
operator|=
name|xstrdup
argument_list|(
literal|"stdout"
argument_list|)
expr_stmt|;
comment|/* For this file only, count the number of newlines from the top of      the file to here.  This way, we keep track of line numbers for      error reporting.  Line_number starts at 1, since the user isn't      zero-based. */
block|{
name|int
name|temp
init|=
literal|0
decl_stmt|;
name|line_number
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|temp
operator|!=
name|input_text_offset
condition|)
if|if
condition|(
name|input_text
index|[
name|temp
operator|++
index|]
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
block|}
comment|/* html fixxme: should output this as trailer on first page.  */
if|if
condition|(
operator|!
name|no_headers
operator|&&
operator|!
name|html
operator|&&
operator|!
name|xml
condition|)
name|add_word_args
argument_list|(
name|_
argument_list|(
literal|"This is %s, produced by makeinfo version %s from %s.\n"
argument_list|)
argument_list|,
name|output_filename
argument_list|,
name|VERSION
argument_list|,
name|input_filename
argument_list|)
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|reader_loop
argument_list|()
expr_stmt|;
if|if
condition|(
name|xml
condition|)
name|xml_end_document
argument_list|()
expr_stmt|;
name|finished
label|:
name|discard_insertions
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|flush_file_stack
argument_list|()
expr_stmt|;
if|if
condition|(
name|macro_expansion_output_stream
condition|)
block|{
name|fclose
argument_list|(
name|macro_expansion_output_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|errors_printed
operator|&&
operator|!
name|force
operator|&&
name|strcmp
argument_list|(
name|macro_expansion_filename
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
operator|&&
name|FILENAME_CMP
argument_list|(
name|macro_expansion_filename
argument_list|,
name|NULL_DEVICE
argument_list|)
operator|!=
literal|0
operator|&&
name|FILENAME_CMP
argument_list|(
name|macro_expansion_filename
argument_list|,
name|ALSO_NULL_DEVICE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: Removing macro output file `%s' due to errors; use --force to preserve.\n"
argument_list|)
argument_list|,
name|progname
argument_list|,
name|macro_expansion_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|macro_expansion_filename
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
name|macro_expansion_filename
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|output_stream
condition|)
block|{
name|output_pending_notes
argument_list|()
expr_stmt|;
if|if
condition|(
name|tag_table
condition|)
block|{
name|tag_table
operator|=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|reverse_list
argument_list|(
name|tag_table
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_headers
operator|&&
operator|!
name|html
condition|)
name|write_tag_table
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|html
condition|)
block|{
name|start_paragraph
argument_list|()
expr_stmt|;
name|add_word
argument_list|(
literal|"</body></html>\n"
argument_list|)
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
block|}
name|flush_output
argument_list|()
expr_stmt|;
comment|/* in case there was no @bye */
if|if
condition|(
name|output_stream
operator|!=
name|stdout
condition|)
name|fclose
argument_list|(
name|output_stream
argument_list|)
expr_stmt|;
comment|/* If validating, then validate the entire file right now. */
if|if
condition|(
name|validating
condition|)
name|validate_file
argument_list|(
name|tag_table
argument_list|)
expr_stmt|;
comment|/* If we need to output the table of contents, do it now.  */
if|if
condition|(
name|contents_filename
operator|||
name|shortcontents_filename
condition|)
name|toc_update
argument_list|()
expr_stmt|;
if|if
condition|(
name|splitting
operator|&&
operator|!
name|html
operator|&&
operator|(
operator|!
name|errors_printed
operator|||
name|force
operator|)
condition|)
name|split_file
argument_list|(
name|real_output_filename
argument_list|,
name|split_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|errors_printed
operator|&&
operator|!
name|force
operator|&&
name|strcmp
argument_list|(
name|real_output_filename
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
operator|&&
name|FILENAME_CMP
argument_list|(
name|real_output_filename
argument_list|,
name|NULL_DEVICE
argument_list|)
operator|!=
literal|0
operator|&&
name|FILENAME_CMP
argument_list|(
name|real_output_filename
argument_list|,
name|ALSO_NULL_DEVICE
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* If there were errors, and no --force, remove the output.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: Removing output file `%s' due to errors; use --force to preserve.\n"
argument_list|)
argument_list|,
name|progname
argument_list|,
name|real_output_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|real_output_filename
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
name|real_output_filename
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|real_output_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|free_and_clear
parameter_list|(
name|pointer
parameter_list|)
name|char
modifier|*
modifier|*
name|pointer
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|pointer
condition|)
block|{
name|free
argument_list|(
operator|*
name|pointer
argument_list|)
expr_stmt|;
operator|*
name|pointer
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize some state. */
end_comment

begin_function
name|void
name|init_internals
parameter_list|()
block|{
name|free_and_clear
argument_list|(
operator|&
name|output_filename
argument_list|)
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
name|command
argument_list|)
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
name|input_filename
argument_list|)
expr_stmt|;
name|free_node_references
argument_list|()
expr_stmt|;
name|free_node_node_references
argument_list|()
expr_stmt|;
name|toc_free
argument_list|()
expr_stmt|;
name|init_insertion_stack
argument_list|()
expr_stmt|;
name|init_brace_stack
argument_list|()
expr_stmt|;
name|current_node
operator|=
name|NULL
expr_stmt|;
comment|/* sometimes already freed */
name|command_index
operator|=
literal|0
expr_stmt|;
name|in_menu
operator|=
literal|0
expr_stmt|;
name|in_detailmenu
operator|=
literal|0
expr_stmt|;
name|top_node_seen
operator|=
literal|0
expr_stmt|;
name|non_top_node_seen
operator|=
literal|0
expr_stmt|;
name|node_number
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_paragraph
parameter_list|()
block|{
name|free_and_clear
argument_list|(
operator|&
name|output_paragraph
argument_list|)
expr_stmt|;
name|output_paragraph
operator|=
name|xmalloc
argument_list|(
name|paragraph_buffer_len
argument_list|)
expr_stmt|;
name|output_paragraph
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|output_paragraph_offset
operator|=
literal|0
expr_stmt|;
name|output_column
operator|=
literal|0
expr_stmt|;
name|paragraph_is_open
operator|=
literal|0
expr_stmt|;
name|current_indent
operator|=
literal|0
expr_stmt|;
name|meta_char_pos
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is called from `reader_loop' when we are at the * beginning a    menu line.  */
end_comment

begin_function
specifier|static
name|void
name|handle_menu_entry
parameter_list|()
block|{
name|char
modifier|*
name|tem
decl_stmt|;
comment|/* Ugh, glean_node_from_menu wants to read the * itself.  */
name|input_text_offset
operator|--
expr_stmt|;
comment|/* Find node name in menu entry and save it in references list for      later validation.  Use followed_reference type for detailmenu      references since we don't want to use them for default node pointers.  */
name|tem
operator|=
name|glean_node_from_menu
argument_list|(
literal|1
argument_list|,
name|in_detailmenu
condition|?
name|followed_reference
else|:
name|menu_reference
argument_list|)
expr_stmt|;
if|if
condition|(
name|html
operator|&&
name|tem
condition|)
block|{
comment|/* Start a menu item with the cleaned-up line.  Put an anchor          around the start text (before `:' or the node name). */
name|char
modifier|*
name|string
decl_stmt|;
name|discard_until
argument_list|(
literal|"* "
argument_list|)
expr_stmt|;
comment|/* The line number was already incremented in reader_loop when we          saw the newline, and discard_until has now incremented again.  */
name|line_number
operator|--
expr_stmt|;
if|if
condition|(
name|had_menu_commentary
condition|)
block|{
name|add_word
argument_list|(
literal|"<ul>\n"
argument_list|)
expr_stmt|;
name|had_menu_commentary
operator|=
literal|0
expr_stmt|;
name|in_paragraph
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|in_paragraph
operator|&&
operator|!
name|paragraph_is_open
condition|)
block|{
name|add_word
argument_list|(
literal|"<p>\n"
argument_list|)
expr_stmt|;
name|in_paragraph
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|in_paragraph
condition|)
block|{
name|add_word
argument_list|(
literal|"</p>"
argument_list|)
expr_stmt|;
name|in_paragraph
operator|=
literal|0
expr_stmt|;
block|}
name|add_word
argument_list|(
literal|"<li><a href=\""
argument_list|)
expr_stmt|;
name|string
operator|=
name|expansion
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_anchor_name
argument_list|(
name|string
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"\">"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
comment|/* The menu item may use macros, so expand them now.  */
name|only_macro_expansion
operator|++
expr_stmt|;
name|get_until_in_line
argument_list|(
literal|1
argument_list|,
literal|":"
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
name|only_macro_expansion
operator|--
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
comment|/* get escaping done */
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"</a>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|looking_at
argument_list|(
literal|"::"
argument_list|)
condition|)
name|discard_until
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* discard the node name */
name|get_until_in_line
argument_list|(
literal|0
argument_list|,
literal|"."
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
name|input_text_offset
operator|++
expr_stmt|;
comment|/* discard the second colon or the period */
name|add_word
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xml
operator|&&
name|tem
condition|)
block|{
name|xml_start_menu_entry
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tem
condition|)
block|{
comment|/* For Info output, we can just use the input and the main case in          reader_loop where we output what comes in.  Just move off the *          so the next time through reader_loop we don't end up back here.  */
name|add_char
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
name|input_text_offset
operator|+=
literal|2
expr_stmt|;
comment|/* undo the pointer back-up above.  */
block|}
if|if
condition|(
name|tem
condition|)
name|free
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the command corresponding to STRING.  If the command is found,    return a pointer to the data structure.  Otherwise return -1.  */
end_comment

begin_function
specifier|static
name|COMMAND
modifier|*
name|get_command_entry
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|command_table
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|command_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|string
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|command_table
index|[
name|i
index|]
return|;
comment|/* This command is not in our predefined command table.  Perhaps      it is a user defined command. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|user_command_array_len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|user_command_array
index|[
name|i
index|]
operator|&&
operator|(
name|strcmp
argument_list|(
name|user_command_array
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|string
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|user_command_array
index|[
name|i
index|]
return|;
comment|/* We never heard of this command. */
return|return
operator|(
name|COMMAND
operator|*
operator|)
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* input_text_offset is right at the command prefix character.    Read the next token to determine what to do.  Return zero    if there's no known command or macro after the prefix character.  */
end_comment

begin_function
specifier|static
name|int
name|read_command
parameter_list|()
block|{
name|COMMAND
modifier|*
name|entry
decl_stmt|;
name|int
name|old_text_offset
init|=
name|input_text_offset
operator|++
decl_stmt|;
name|free_and_clear
argument_list|(
operator|&
name|command
argument_list|)
expr_stmt|;
name|command
operator|=
name|read_token
argument_list|()
expr_stmt|;
comment|/* Check to see if this command is a macro.  If so, execute it here. */
block|{
name|MACRO_DEF
modifier|*
name|def
decl_stmt|;
name|def
operator|=
name|find_macro
argument_list|(
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
condition|)
block|{
comment|/* We disallow recursive use of a macro call.  Inhibit the expansion            of this macro during the life of its execution. */
if|if
condition|(
operator|!
operator|(
name|def
operator|->
name|flags
operator|&
name|ME_RECURSE
operator|)
condition|)
name|def
operator|->
name|inhibited
operator|=
literal|1
expr_stmt|;
name|execute_macro
argument_list|(
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|def
operator|->
name|flags
operator|&
name|ME_RECURSE
operator|)
condition|)
name|def
operator|->
name|inhibited
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|only_macro_expansion
condition|)
block|{
comment|/* Back up to the place where we were called, so the          caller will have a chance to process this non-macro.  */
name|input_text_offset
operator|=
name|old_text_offset
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Perform alias expansion */
name|command
operator|=
name|alias_expand
argument_list|(
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|enclosure_command
argument_list|(
name|command
argument_list|)
condition|)
block|{
name|remember_brace
argument_list|(
name|enclosure_expand
argument_list|)
expr_stmt|;
name|enclosure_expand
argument_list|(
name|START
argument_list|,
name|output_paragraph_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|entry
operator|=
name|get_command_entry
argument_list|(
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
operator|(
name|COMMAND
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Unknown command `%s'"
argument_list|)
argument_list|,
name|command
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|entry
operator|->
name|argument_in_braces
operator|==
name|BRACE_ARGS
condition|)
name|remember_brace
argument_list|(
name|entry
operator|->
name|proc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|argument_in_braces
operator|==
name|MAYBE_BRACE_ARGS
condition|)
block|{
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|'{'
condition|)
name|remember_brace
argument_list|(
name|entry
operator|->
name|proc
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* No braces, so arg is next char.  */
name|int
name|ch
decl_stmt|;
name|int
name|saved_offset
init|=
name|output_paragraph_offset
decl_stmt|;
operator|(
operator|*
operator|(
name|entry
operator|->
name|proc
operator|)
operator|)
operator|(
name|START
operator|,
name|output_paragraph_offset
operator|,
literal|0
operator|)
expr_stmt|;
comment|/* Possibilities left for the next character: @ (error), }              (error), whitespace (skip) anything else (normal char).  */
name|skip_whitespace
argument_list|()
expr_stmt|;
name|ch
operator|=
name|curchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'@'
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Use braces to give a command as an argument to @%s"
argument_list|)
argument_list|,
name|entry
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'}'
condition|)
block|{
comment|/* Our caller will give the error message, because this }                  won't match anything.  */
return|return
literal|0
return|;
block|}
name|add_char
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
operator|(
operator|*
operator|(
name|entry
operator|->
name|proc
operator|)
operator|)
operator|(
name|END
operator|,
name|saved_offset
operator|,
name|output_paragraph_offset
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* Get here if we have BRACE_ARGS, NO_BRACE_ARGS, or MAYBE_BRACE_ARGS      with braces.  */
operator|(
operator|*
operator|(
name|entry
operator|->
name|proc
operator|)
operator|)
operator|(
name|START
operator|,
name|output_paragraph_offset
operator|,
literal|0
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Okay, we are ready to start the conversion.  Call the reader on    some text, and fill the text as it is output.  Handle commands by    remembering things like open braces and the current file position on a    stack, and when the corresponding close brace is found, you can call    the function with the proper arguments.  Although the filling isn't    necessary for HTML, it should do no harm.  */
end_comment

begin_function
name|void
name|reader_loop
parameter_list|()
block|{
name|int
name|character
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|int
name|dash_count
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|input_text_offset
operator|>=
name|input_text_length
condition|)
break|break;
name|character
operator|=
name|curchar
argument_list|()
expr_stmt|;
comment|/* If only_macro_expansion, only handle macros and leave          everything else intact.  */
if|if
condition|(
operator|!
name|only_macro_expansion
operator|&&
operator|!
name|in_fixed_width_font
operator|&&
operator|(
name|character
operator|==
literal|'\''
operator|||
name|character
operator|==
literal|'`'
operator|)
operator|&&
name|input_text
index|[
name|input_text_offset
operator|+
literal|1
index|]
operator|==
name|character
condition|)
block|{
name|input_text_offset
operator|++
expr_stmt|;
name|character
operator|=
literal|'"'
expr_stmt|;
comment|/* html fixxme */
block|}
comment|/* Convert --- to --.  */
if|if
condition|(
operator|!
name|only_macro_expansion
operator|&&
name|character
operator|==
literal|'-'
condition|)
block|{
name|dash_count
operator|++
expr_stmt|;
if|if
condition|(
name|dash_count
operator|==
literal|2
operator|&&
operator|!
name|in_fixed_width_font
condition|)
block|{
name|input_text_offset
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|dash_count
operator|>
literal|0
condition|)
name|dash_count
operator|=
literal|0
expr_stmt|;
comment|/* If this is a whitespace character, then check to see if the line          is blank.  If so, advance to the carriage return. */
if|if
condition|(
operator|!
name|only_macro_expansion
operator|&&
name|whitespace
argument_list|(
name|character
argument_list|)
condition|)
block|{
name|int
name|i
init|=
name|input_text_offset
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|input_text_length
operator|&&
name|whitespace
argument_list|(
name|input_text
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|input_text_length
operator|||
name|input_text
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|input_text_length
condition|)
name|i
operator|--
expr_stmt|;
name|input_text_offset
operator|=
name|i
expr_stmt|;
name|character
operator|=
name|curchar
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|character
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
switch|switch
condition|(
name|character
condition|)
block|{
case|case
literal|'*'
case|:
comment|/* perhaps we are at a menu */
comment|/* We used to check for this in the \n case but an @c in a              menu swallows its newline, so check here instead.  */
if|if
condition|(
operator|!
name|only_macro_expansion
operator|&&
name|in_menu
operator|&&
name|input_text_offset
operator|+
literal|1
operator|<
name|input_text_length
operator|&&
name|input_text
index|[
name|input_text_offset
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|handle_menu_entry
argument_list|()
expr_stmt|;
else|else
block|{
comment|/* Duplicate code from below, but not worth twisting the                  fallthroughs to get down there.  */
name|add_char
argument_list|(
name|character
argument_list|)
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
block|}
break|break;
comment|/* Escapes for HTML unless we're outputting raw HTML.  Do            this always, even if SGML rules don't require it since            that's easier and safer for non-conforming browsers. */
case|case
literal|'&'
case|:
if|if
condition|(
name|html
operator|&&
name|escape_html
condition|)
name|add_word
argument_list|(
literal|"&amp;"
argument_list|)
expr_stmt|;
else|else
name|add_char
argument_list|(
name|character
argument_list|)
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|html
operator|&&
name|escape_html
condition|)
name|add_word
argument_list|(
literal|"&lt;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xml
condition|)
name|xml_insert_entity
argument_list|(
literal|"lt"
argument_list|)
expr_stmt|;
else|else
name|add_char
argument_list|(
name|character
argument_list|)
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|html
operator|&&
name|escape_html
condition|)
name|add_word
argument_list|(
literal|"&gt;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xml
condition|)
name|xml_insert_entity
argument_list|(
literal|"gt"
argument_list|)
expr_stmt|;
else|else
name|add_char
argument_list|(
name|character
argument_list|)
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
break|break;
case|case
name|COMMAND_PREFIX
case|:
comment|/* @ */
if|if
condition|(
name|read_command
argument_list|()
operator|||
operator|!
name|only_macro_expansion
condition|)
break|break;
comment|/* FALLTHROUGH (usually) */
case|case
literal|'{'
case|:
comment|/* Special case.  We're not supposed to see this character by itself.              If we do, it means there is a syntax error in the input text.              Report the error here, but remember this brace on the stack so              we can ignore its partner. */
if|if
condition|(
operator|!
name|only_macro_expansion
condition|)
block|{
if|if
condition|(
operator|!
name|STREQ
argument_list|(
name|command
argument_list|,
literal|"math"
argument_list|)
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Misplaced %c"
argument_list|)
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
name|remember_brace
argument_list|(
name|misplaced_brace
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We don't mind `extra' braces inside @math.  */
specifier|extern
name|void
name|cm_no_op
parameter_list|()
function_decl|;
name|remember_brace
argument_list|(
name|cm_no_op
argument_list|)
expr_stmt|;
block|}
comment|/* remember_brace advances input_text_offset.  */
break|break;
block|}
comment|/* FALLTHROUGH (usually) */
case|case
literal|'}'
case|:
if|if
condition|(
operator|!
name|only_macro_expansion
condition|)
block|{
name|pop_and_call_brace
argument_list|()
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH (usually) */
default|default:
name|add_char
argument_list|(
name|character
argument_list|)
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|macro_expansion_output_stream
operator|&&
operator|!
name|only_macro_expansion
condition|)
name|maybe_write_itext
argument_list|(
name|input_text
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|init_brace_stack
parameter_list|()
block|{
name|brace_stack
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|remember_brace
parameter_list|(
name|proc
parameter_list|)
name|COMMAND_FUNCTION
modifier|*
name|proc
decl_stmt|;
block|{
if|if
condition|(
name|curchar
argument_list|()
operator|!=
literal|'{'
condition|)
name|line_error
argument_list|(
name|_
argument_list|(
literal|"%c%s expected `{...}'"
argument_list|)
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
else|else
name|input_text_offset
operator|++
expr_stmt|;
name|remember_brace_1
argument_list|(
name|proc
argument_list|,
name|output_paragraph_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remember the current output position here.  Save PROC    along with it so you can call it later. */
end_comment

begin_function
name|void
name|remember_brace_1
parameter_list|(
name|proc
parameter_list|,
name|position
parameter_list|)
name|COMMAND_FUNCTION
modifier|*
name|proc
decl_stmt|;
name|int
name|position
decl_stmt|;
block|{
name|BRACE_ELEMENT
modifier|*
name|new
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BRACE_ELEMENT
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|next
operator|=
name|brace_stack
expr_stmt|;
name|new
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|new
operator|->
name|command
operator|=
name|command
condition|?
name|xstrdup
argument_list|(
name|command
argument_list|)
else|:
literal|""
expr_stmt|;
name|new
operator|->
name|pos
operator|=
name|position
expr_stmt|;
name|new
operator|->
name|line
operator|=
name|line_number
expr_stmt|;
name|new
operator|->
name|in_fixed_width_font
operator|=
name|in_fixed_width_font
expr_stmt|;
name|brace_stack
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop the top of the brace stack, and call the associated function    with the args END and POS. */
end_comment

begin_function
name|void
name|pop_and_call_brace
parameter_list|()
block|{
if|if
condition|(
name|brace_stack
operator|==
name|NULL
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Unmatched }"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|{
name|BRACE_ELEMENT
modifier|*
name|temp
decl_stmt|;
name|int
name|pos
init|=
name|brace_stack
operator|->
name|pos
decl_stmt|;
name|COMMAND_FUNCTION
modifier|*
name|proc
init|=
name|brace_stack
operator|->
name|proc
decl_stmt|;
name|in_fixed_width_font
operator|=
name|brace_stack
operator|->
name|in_fixed_width_font
expr_stmt|;
comment|/* Reset current command, so the proc can know who it is.  This is        used in cm_accent.  */
name|command
operator|=
name|brace_stack
operator|->
name|command
expr_stmt|;
name|temp
operator|=
name|brace_stack
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|brace_stack
argument_list|)
expr_stmt|;
name|brace_stack
operator|=
name|temp
expr_stmt|;
call|(
modifier|*
name|proc
call|)
argument_list|(
name|END
argument_list|,
name|pos
argument_list|,
name|output_paragraph_offset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Shift all of the markers in `brace_stack' by AMOUNT. */
end_comment

begin_function
name|void
name|adjust_braces_following
parameter_list|(
name|here
parameter_list|,
name|amount
parameter_list|)
name|int
name|here
decl_stmt|,
name|amount
decl_stmt|;
block|{
name|BRACE_ELEMENT
modifier|*
name|stack
init|=
name|brace_stack
decl_stmt|;
while|while
condition|(
name|stack
condition|)
block|{
if|if
condition|(
name|stack
operator|->
name|pos
operator|>=
name|here
condition|)
name|stack
operator|->
name|pos
operator|+=
name|amount
expr_stmt|;
name|stack
operator|=
name|stack
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the string which invokes PROC; a pointer to a function.    Always returns the first function in the command table if more than    one matches PROC.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_proc_name
parameter_list|(
name|proc
parameter_list|)
name|COMMAND_FUNCTION
modifier|*
name|proc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|command_table
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|proc
operator|==
name|command_table
index|[
name|i
index|]
operator|.
name|proc
condition|)
return|return
name|command_table
index|[
name|i
index|]
operator|.
name|name
return|;
return|return
name|_
argument_list|(
literal|"NO_NAME!"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* You call discard_braces () when you shouldn't have any braces on the stack.    I used to think that this happens for commands that don't take arguments    in braces, but that was wrong because of things like @code{foo @@}.  So now    I only detect it at the beginning of nodes. */
end_comment

begin_function
name|void
name|discard_braces
parameter_list|()
block|{
if|if
condition|(
operator|!
name|brace_stack
condition|)
return|return;
while|while
condition|(
name|brace_stack
condition|)
block|{
if|if
condition|(
name|brace_stack
operator|->
name|proc
operator|!=
name|misplaced_brace
condition|)
block|{
name|char
modifier|*
name|proc_name
decl_stmt|;
name|proc_name
operator|=
name|find_proc_name
argument_list|(
name|brace_stack
operator|->
name|proc
argument_list|)
expr_stmt|;
name|file_line_error
argument_list|(
name|input_filename
argument_list|,
name|brace_stack
operator|->
name|line
argument_list|,
name|_
argument_list|(
literal|"%c%s missing close brace"
argument_list|)
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|proc_name
argument_list|)
expr_stmt|;
name|pop_and_call_brace
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|BRACE_ELEMENT
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|brace_stack
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|brace_stack
argument_list|)
expr_stmt|;
name|brace_stack
operator|=
name|temp
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|get_char_len
parameter_list|(
name|character
parameter_list|)
name|int
name|character
decl_stmt|;
block|{
comment|/* Return the printed length of the character. */
name|int
name|len
decl_stmt|;
switch|switch
condition|(
name|character
condition|)
block|{
case|case
literal|'\t'
case|:
name|len
operator|=
operator|(
name|output_column
operator|+
literal|8
operator|)
operator|&
literal|0xf7
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|fill_column
condition|)
name|len
operator|=
name|fill_column
operator|-
name|output_column
expr_stmt|;
else|else
name|len
operator|=
name|len
operator|-
name|output_column
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|len
operator|=
name|fill_column
operator|-
name|output_column
expr_stmt|;
break|break;
default|default:
comment|/* ASCII control characters appear as two characters in the output          (e.g., ^A).  But characters with the high bit set are just one          on suitable terminals, so don't count them as two for line          breaking purposes.  */
if|if
condition|(
literal|0
operator|<=
name|character
operator|&&
name|character
operator|<
literal|' '
condition|)
name|len
operator|=
literal|2
expr_stmt|;
else|else
name|len
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
if|#
directive|if
name|defined
argument_list|(
name|VA_FPRINTF
argument_list|)
operator|&&
name|__STDC__
name|add_word_args
parameter_list|(
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|add_word_args
parameter_list|(
name|format
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
name|char
name|buffer
index|[
literal|2000
index|]
decl_stmt|;
comment|/* xx no fixed limits */
ifdef|#
directive|ifdef
name|VA_FPRINTF
name|va_list
name|ap
decl_stmt|;
endif|#
directive|endif
name|VA_START
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VA_SPRINTF
name|VA_SPRINTF
argument_list|(
name|buffer
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|format
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not VA_SPRINTF */
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add STRING to output_paragraph. */
end_comment

begin_function
name|void
name|add_word
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|string
condition|)
name|add_char
argument_list|(
operator|*
name|string
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like add_word, but inhibits conversion of whitespace into&nbsp;.    Use this to output HTML directives with embedded blanks, to make    them @w-safe.  */
end_comment

begin_function
name|void
name|add_html_elt
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|in_html_elt
operator|++
expr_stmt|;
name|add_word
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|in_html_elt
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add the character to the current paragraph.  If filling_enabled is    nonzero, then do filling as well. */
end_comment

begin_function
name|void
name|add_char
parameter_list|(
name|character
parameter_list|)
name|int
name|character
decl_stmt|;
block|{
if|if
condition|(
name|xml
condition|)
block|{
name|xml_add_char
argument_list|(
name|character
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we are avoiding outputting headers, and we are currently      in a menu, then simply return.  But if we're only expanding macros,      then we're being called from glean_node_from_menu to try to      remember a menu reference, and we need that so we can do defaulting.  */
if|if
condition|(
name|no_headers
operator|&&
operator|!
name|only_macro_expansion
operator|&&
operator|(
name|in_menu
operator|||
name|in_detailmenu
operator|)
condition|)
return|return;
comment|/* If we are adding a character now, then we don't have to      ignore close_paragraph () calls any more. */
if|if
condition|(
name|must_start_paragraph
operator|&&
name|character
operator|!=
literal|'\n'
condition|)
block|{
name|must_start_paragraph
operator|=
literal|0
expr_stmt|;
name|line_already_broken
operator|=
literal|0
expr_stmt|;
comment|/* The line is no longer broken. */
if|if
condition|(
name|current_indent
operator|>
name|output_column
condition|)
block|{
name|indent
argument_list|(
name|current_indent
operator|-
name|output_column
argument_list|)
expr_stmt|;
name|output_column
operator|=
name|current_indent
expr_stmt|;
block|}
block|}
if|if
condition|(
name|non_splitting_words
operator|&&
operator|!
operator|(
name|html
operator|&&
name|in_html_elt
operator|)
operator|&&
name|strchr
argument_list|(
literal|" \t\n"
argument_list|,
name|character
argument_list|)
condition|)
block|{
if|if
condition|(
name|html
operator|||
name|docbook
condition|)
block|{
comment|/* Seems cleaner to use&nbsp; than an 8-bit char.  */
name|add_word
argument_list|(
literal|"&nbsp"
argument_list|)
expr_stmt|;
name|character
operator|=
literal|';'
expr_stmt|;
block|}
else|else
name|character
operator|=
name|META
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
comment|/* unmeta-d in flush_output */
block|}
name|insertion_paragraph_closed
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|character
condition|)
block|{
case|case
literal|'\n'
case|:
if|if
condition|(
operator|!
name|filling_enabled
operator|&&
operator|!
operator|(
name|html
operator|&&
operator|(
name|in_menu
operator|||
name|in_detailmenu
operator|)
operator|)
condition|)
block|{
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_flush_right
condition|)
block|{
name|close_paragraph
argument_list|()
expr_stmt|;
comment|/* Hack to force single blank lines out in this mode. */
name|flush_output
argument_list|()
expr_stmt|;
block|}
name|output_column
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|no_indent
operator|&&
name|paragraph_is_open
condition|)
name|indent
argument_list|(
name|output_column
operator|=
name|current_indent
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|end_of_sentence_p
argument_list|()
condition|)
comment|/* CHARACTER is newline, and filling is enabled. */
block|{
name|insert
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|output_column
operator|++
expr_stmt|;
name|last_inserted_character
operator|=
name|character
expr_stmt|;
block|}
if|if
condition|(
name|last_char_was_newline
condition|)
block|{
if|if
condition|(
name|html
condition|)
name|last_char_was_newline
operator|++
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|pending_indent
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|last_char_was_newline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
else|else
name|insert
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|output_column
operator|++
expr_stmt|;
block|}
break|break;
default|default:
comment|/* not at newline */
block|{
name|int
name|len
init|=
name|get_char_len
argument_list|(
name|character
argument_list|)
decl_stmt|;
name|int
name|suppress_insert
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|character
operator|==
literal|' '
operator|)
operator|&&
operator|(
name|last_char_was_newline
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|paragraph_is_open
condition|)
block|{
name|pending_indent
operator|++
expr_stmt|;
return|return;
block|}
block|}
comment|/* This is sad, but it seems desirable to not force any 	   particular order on the front matter commands.  This way, 	   the document can do @settitle, @documentlanguage, etc, in 	   any order and with any omissions, and we'll still output 	   the html<head> `just in time'.  */
if|if
condition|(
operator|!
name|executing_string
operator|&&
name|html
operator|&&
operator|!
name|html_output_head_p
condition|)
name|html_output_head
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|paragraph_is_open
condition|)
block|{
name|start_paragraph
argument_list|()
expr_stmt|;
comment|/* If the paragraph is supposed to be indented a certain                way, then discard all of the pending whitespace.                Otherwise, we let the whitespace stay. */
if|if
condition|(
operator|!
name|paragraph_start_indent
condition|)
name|indent
argument_list|(
name|pending_indent
argument_list|)
expr_stmt|;
name|pending_indent
operator|=
literal|0
expr_stmt|;
comment|/* This horrible kludge of checking for a< prevents<p>                from being inserted when we already have html markup                starting a paragraph, as with<ul> and<h1> and the like.  */
if|if
condition|(
name|html
operator|&&
name|escape_html
operator|&&
name|character
operator|!=
literal|'<'
operator|&&
operator|(
operator|!
name|in_fixed_width_font
operator|||
name|in_menu
operator|||
name|in_detailmenu
operator|)
condition|)
block|{
name|insert_string
argument_list|(
literal|"<p>"
argument_list|)
expr_stmt|;
name|in_paragraph
operator|=
literal|1
expr_stmt|;
name|adjust_braces_following
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* adjust for<p> */
block|}
block|}
name|output_column
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|output_column
operator|>
name|fill_column
condition|)
block|{
if|if
condition|(
name|filling_enabled
operator|&&
operator|!
name|html
condition|)
block|{
name|int
name|temp
init|=
name|output_paragraph_offset
decl_stmt|;
while|while
condition|(
operator|--
name|temp
operator|>
literal|0
operator|&&
name|output_paragraph
index|[
name|temp
index|]
operator|!=
literal|'\n'
condition|)
block|{
comment|/* If we have found a space, we have the place to break                        the line. */
if|if
condition|(
name|output_paragraph
index|[
name|temp
index|]
operator|==
literal|' '
condition|)
block|{
comment|/* Remove trailing whitespace from output. */
while|while
condition|(
name|temp
operator|&&
name|whitespace
argument_list|(
name|output_paragraph
index|[
name|temp
operator|-
literal|1
index|]
argument_list|)
condition|)
name|temp
operator|--
expr_stmt|;
comment|/* If we went back all the way to the newline of the                            preceding line, it probably means that the word we                            are adding is itself wider than the space that the                            indentation and the fill_column let us use.  In                            that case, do NOT insert another newline, since it                            won't help.  Just indent to current_indent and                            leave it alone, since that's the most we can do.  */
if|if
condition|(
name|temp
operator|&&
name|output_paragraph
index|[
name|temp
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|output_paragraph
index|[
name|temp
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
comment|/* We have correctly broken the line where we want                            to.  What we don't want is spaces following where                            we have decided to break the line.  We get rid of                            them. */
block|{
name|int
name|t1
init|=
name|temp
decl_stmt|;
for|for
control|(
init|;
condition|;
name|t1
operator|++
control|)
block|{
if|if
condition|(
name|t1
operator|==
name|output_paragraph_offset
condition|)
block|{
if|if
condition|(
name|whitespace
argument_list|(
name|character
argument_list|)
condition|)
name|suppress_insert
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|output_paragraph
index|[
name|t1
index|]
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|t1
operator|!=
name|temp
condition|)
block|{
name|adjust_braces_following
argument_list|(
name|temp
argument_list|,
operator|(
operator|-
operator|(
name|t1
operator|-
name|temp
operator|)
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|output_paragraph
index|[
name|temp
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|output_paragraph
index|[
name|t1
index|]
argument_list|,
operator|(
name|output_paragraph_offset
operator|-
name|t1
operator|)
argument_list|)
expr_stmt|;
name|output_paragraph_offset
operator|-=
operator|(
name|t1
operator|-
name|temp
operator|)
expr_stmt|;
block|}
block|}
comment|/* Filled, but now indent if that is right. */
if|if
condition|(
name|indented_fill
operator|&&
name|current_indent
operator|>
literal|0
condition|)
block|{
name|int
name|buffer_len
init|=
operator|(
operator|(
name|output_paragraph_offset
operator|-
name|temp
operator|)
operator|+
name|current_indent
operator|)
decl_stmt|;
name|char
modifier|*
name|temp_buffer
init|=
name|xmalloc
argument_list|(
name|buffer_len
argument_list|)
decl_stmt|;
name|int
name|indentation
init|=
literal|0
decl_stmt|;
comment|/* We have to shift any markers that are in                                front of the wrap point. */
name|adjust_braces_following
argument_list|(
name|temp
argument_list|,
name|current_indent
argument_list|)
expr_stmt|;
while|while
condition|(
name|current_indent
operator|>
literal|0
operator|&&
name|indentation
operator|!=
name|current_indent
condition|)
name|temp_buffer
index|[
name|indentation
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|temp_buffer
index|[
name|current_indent
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|output_paragraph
index|[
name|temp
index|]
argument_list|,
name|buffer_len
operator|-
name|current_indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_paragraph_offset
operator|+
name|buffer_len
operator|>=
name|paragraph_buffer_len
condition|)
block|{
name|unsigned
name|char
modifier|*
name|tt
init|=
name|xrealloc
argument_list|(
name|output_paragraph
argument_list|,
operator|(
name|paragraph_buffer_len
operator|+=
name|buffer_len
operator|)
argument_list|)
decl_stmt|;
name|output_paragraph
operator|=
name|tt
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|output_paragraph
index|[
name|temp
index|]
argument_list|,
name|temp_buffer
argument_list|,
name|buffer_len
argument_list|)
expr_stmt|;
name|output_paragraph_offset
operator|+=
name|current_indent
expr_stmt|;
name|free
argument_list|(
name|temp_buffer
argument_list|)
expr_stmt|;
block|}
name|output_column
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|temp
operator|<
name|output_paragraph_offset
condition|)
name|output_column
operator|+=
name|get_char_len
argument_list|(
name|output_paragraph
index|[
name|temp
operator|++
index|]
argument_list|)
expr_stmt|;
name|output_column
operator|+=
name|len
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|suppress_insert
condition|)
block|{
name|insert
argument_list|(
name|character
argument_list|)
expr_stmt|;
name|last_inserted_character
operator|=
name|character
expr_stmt|;
block|}
name|last_char_was_newline
operator|=
literal|0
expr_stmt|;
name|line_already_broken
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Add a character and store its position in meta_char_pos.  */
end_comment

begin_function
name|void
name|add_meta_char
parameter_list|(
name|character
parameter_list|)
name|int
name|character
decl_stmt|;
block|{
name|meta_char_pos
operator|=
name|output_paragraph_offset
expr_stmt|;
name|add_char
argument_list|(
name|character
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert CHARACTER into `output_paragraph'. */
end_comment

begin_function
name|void
name|insert
parameter_list|(
name|character
parameter_list|)
name|int
name|character
decl_stmt|;
block|{
name|output_paragraph
index|[
name|output_paragraph_offset
operator|++
index|]
operator|=
name|character
expr_stmt|;
if|if
condition|(
name|output_paragraph_offset
operator|==
name|paragraph_buffer_len
condition|)
block|{
name|output_paragraph
operator|=
name|xrealloc
argument_list|(
name|output_paragraph
argument_list|,
operator|(
name|paragraph_buffer_len
operator|+=
literal|100
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Insert the null-terminated string STRING into `output_paragraph'.  */
end_comment

begin_function
name|void
name|insert_string
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|string
condition|)
name|insert
argument_list|(
operator|*
name|string
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sentences might have these characters after the period (or whatever).  */
end_comment

begin_define
define|#
directive|define
name|POST_SENTENCE
parameter_list|(
name|c
parameter_list|)
value|((c) == ')' || (c) == '\'' || (c) == '"' \                           || (c) == ']')
end_define

begin_comment
comment|/* Return true if at an end-of-sentence character, possibly followed by    post-sentence punctuation to ignore.  */
end_comment

begin_function
specifier|static
name|int
name|end_of_sentence_p
parameter_list|()
block|{
name|int
name|loc
init|=
name|output_paragraph_offset
operator|-
literal|1
decl_stmt|;
comment|/* If nothing has been output, don't check output_paragraph[-1].  */
if|if
condition|(
name|loc
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* A post-sentence character that is at meta_char_pos is not really      a post-sentence character; it was produced by a markup such as      @samp.  We don't want the period inside @samp to be treated as a      sentence ender. */
while|while
condition|(
name|loc
operator|>
literal|0
operator|&&
name|loc
operator|!=
name|meta_char_pos
operator|&&
name|POST_SENTENCE
argument_list|(
name|output_paragraph
index|[
name|loc
index|]
argument_list|)
condition|)
name|loc
operator|--
expr_stmt|;
return|return
name|loc
operator|!=
name|meta_char_pos
operator|&&
name|sentence_ender
argument_list|(
name|output_paragraph
index|[
name|loc
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Remove upto COUNT characters of whitespace from the    the current output line.  If COUNT is less than zero,    then remove until none left. */
end_comment

begin_function
name|void
name|kill_self_indent
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
block|{
comment|/* Handle infinite case first. */
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|output_column
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|output_paragraph_offset
condition|)
block|{
if|if
condition|(
name|whitespace
argument_list|(
name|output_paragraph
index|[
name|output_paragraph_offset
operator|-
literal|1
index|]
argument_list|)
condition|)
name|output_paragraph_offset
operator|--
expr_stmt|;
else|else
break|break;
block|}
block|}
else|else
block|{
while|while
condition|(
name|output_paragraph_offset
operator|&&
name|count
operator|--
condition|)
if|if
condition|(
name|whitespace
argument_list|(
name|output_paragraph
index|[
name|output_paragraph_offset
operator|-
literal|1
index|]
argument_list|)
condition|)
name|output_paragraph_offset
operator|--
expr_stmt|;
else|else
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Nonzero means do not honor calls to flush_output (). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flushing_ignored
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prevent calls to flush_output () from having any effect. */
end_comment

begin_function
name|void
name|inhibit_output_flushing
parameter_list|()
block|{
name|flushing_ignored
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allow calls to flush_output () to write the paragraph data. */
end_comment

begin_function
name|void
name|uninhibit_output_flushing
parameter_list|()
block|{
name|flushing_ignored
operator|--
expr_stmt|;
block|}
end_function

begin_function
name|void
name|flush_output
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|output_paragraph_offset
operator|||
name|flushing_ignored
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|output_paragraph_offset
condition|;
name|i
operator|++
control|)
block|{
comment|/* If we turned on the 8th bit for a space inside @w, turn it          back off for output.  This might be problematic, since the          0x80 character may be used in 8-bit character sets.  Sigh.          In any case, don't do this for HTML, since the nbsp character          is valid input and must be passed along to the browser.  */
if|if
condition|(
operator|!
name|html
operator|&&
operator|(
name|output_paragraph
index|[
name|i
index|]
operator|&
name|meta_character_bit
operator|)
condition|)
block|{
name|int
name|temp
init|=
name|UNMETA
argument_list|(
name|output_paragraph
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|==
literal|' '
condition|)
name|output_paragraph
index|[
name|i
index|]
operator|&=
literal|0x7f
expr_stmt|;
block|}
block|}
name|fwrite
argument_list|(
name|output_paragraph
argument_list|,
literal|1
argument_list|,
name|output_paragraph_offset
argument_list|,
name|output_stream
argument_list|)
expr_stmt|;
name|output_position
operator|+=
name|output_paragraph_offset
expr_stmt|;
name|output_paragraph_offset
operator|=
literal|0
expr_stmt|;
name|meta_char_pos
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* How to close a paragraph controlling the number of lines between    this one and the last one. */
end_comment

begin_comment
comment|/* Paragraph spacing is controlled by this variable.  It is the number of    blank lines that you wish to appear between paragraphs.  A value of    1 creates a single blank line between paragraphs. */
end_comment

begin_decl_stmt
name|int
name|paragraph_spacing
init|=
name|DEFAULT_PARAGRAPH_SPACING
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|close_paragraph_with_lines
parameter_list|(
name|lines
parameter_list|)
name|int
name|lines
decl_stmt|;
block|{
name|int
name|old_spacing
init|=
name|paragraph_spacing
decl_stmt|;
name|paragraph_spacing
operator|=
name|lines
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|paragraph_spacing
operator|=
name|old_spacing
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close the current paragraph, leaving no blank lines between them. */
end_comment

begin_function
name|void
name|close_single_paragraph
parameter_list|()
block|{
name|close_paragraph_with_lines
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close a paragraph after an insertion has ended. */
end_comment

begin_function
name|void
name|close_insertion_paragraph
parameter_list|()
block|{
if|if
condition|(
operator|!
name|insertion_paragraph_closed
condition|)
block|{
comment|/* Close the current paragraph, breaking the line. */
name|close_single_paragraph
argument_list|()
expr_stmt|;
comment|/* Start a new paragraph, with the correct indentation for the now          current insertion level (one above the one that we are ending). */
name|start_paragraph
argument_list|()
expr_stmt|;
comment|/* Tell `close_paragraph' that the previous line has already been          broken, so it should insert one less newline. */
name|line_already_broken
operator|=
literal|1
expr_stmt|;
comment|/* Tell functions such as `add_char' we've already found a newline. */
name|ignore_blank_line
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* If the insertion paragraph is closed already, then we are seeing          two `@end' commands in a row.  Note that the first one we saw was          handled in the first part of this if-then-else clause, and at that          time `start_paragraph' was called, partially to handle the proper          indentation of the current line.  However, the indentation level          may have just changed again, so we may have to outdent the current          line to the new indentation level. */
if|if
condition|(
name|current_indent
operator|<
name|output_column
condition|)
name|kill_self_indent
argument_list|(
name|output_column
operator|-
name|current_indent
argument_list|)
expr_stmt|;
block|}
name|insertion_paragraph_closed
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close the currently open paragraph. */
end_comment

begin_function
name|void
name|close_paragraph
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* The insertion paragraph is no longer closed. */
name|insertion_paragraph_closed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|paragraph_is_open
operator|&&
operator|!
name|must_start_paragraph
condition|)
block|{
name|int
name|tindex
decl_stmt|,
name|c
decl_stmt|;
name|tindex
operator|=
name|output_paragraph_offset
expr_stmt|;
comment|/* Back up to last non-newline/space character, forcing all such          subsequent characters to be newlines.  This isn't strictly          necessary, but a couple of functions use the presence of a newline          to make decisions. */
for|for
control|(
name|tindex
operator|=
name|output_paragraph_offset
operator|-
literal|1
init|;
name|tindex
operator|>=
literal|0
condition|;
operator|--
name|tindex
control|)
block|{
name|c
operator|=
name|output_paragraph
index|[
name|tindex
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
condition|)
name|output_paragraph
index|[
name|tindex
index|]
operator|=
literal|'\n'
expr_stmt|;
else|else
break|break;
block|}
comment|/* All trailing whitespace is ignored. */
name|output_paragraph_offset
operator|=
operator|++
name|tindex
expr_stmt|;
comment|/* Break the line if that is appropriate. */
if|if
condition|(
name|paragraph_spacing
operator|>=
literal|0
condition|)
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* Add as many blank lines as is specified in `paragraph_spacing'. */
if|if
condition|(
operator|!
name|force_flush_right
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|paragraph_spacing
operator|-
name|line_already_broken
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* Don't need anything extra for HTML in usual case of no                  extra paragraph spacing.  */
if|if
condition|(
name|html
operator|&&
name|i
operator|>
literal|0
condition|)
name|insert_string
argument_list|(
literal|"<br>"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we are doing flush right indentation, then do it now          on the paragraph (really a single line). */
if|if
condition|(
name|force_flush_right
condition|)
name|do_flush_right_indentation
argument_list|()
expr_stmt|;
name|flush_output
argument_list|()
expr_stmt|;
name|paragraph_is_open
operator|=
literal|0
expr_stmt|;
name|no_indent
operator|=
literal|0
expr_stmt|;
name|output_column
operator|=
literal|0
expr_stmt|;
block|}
name|ignore_blank_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make the last line just read look as if it were only a newline. */
end_comment

begin_function
name|void
name|ignore_blank_line
parameter_list|()
block|{
name|last_inserted_character
operator|=
literal|'\n'
expr_stmt|;
name|last_char_was_newline
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Align the end of the text in output_paragraph with fill_column. */
end_comment

begin_function
name|void
name|do_flush_right_indentation
parameter_list|()
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|temp_len
decl_stmt|;
name|kill_self_indent
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_paragraph
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|output_paragraph
index|[
name|output_paragraph_offset
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|output_paragraph_offset
operator|<
name|fill_column
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fill_column
operator|>=
name|paragraph_buffer_len
condition|)
name|output_paragraph
operator|=
name|xrealloc
argument_list|(
name|output_paragraph
argument_list|,
operator|(
name|paragraph_buffer_len
operator|+=
name|fill_column
operator|)
argument_list|)
expr_stmt|;
name|temp_len
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|output_paragraph
argument_list|)
expr_stmt|;
name|temp
operator|=
name|xmalloc
argument_list|(
name|temp_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|temp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|output_paragraph
argument_list|,
name|temp_len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fill_column
operator|-
name|output_paragraph_offset
condition|;
name|i
operator|++
control|)
name|output_paragraph
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|output_paragraph
operator|+
name|i
argument_list|,
name|temp
argument_list|,
name|temp_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|output_paragraph_offset
operator|=
name|fill_column
expr_stmt|;
name|adjust_braces_following
argument_list|(
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Begin a new paragraph. */
end_comment

begin_function
name|void
name|start_paragraph
parameter_list|()
block|{
comment|/* First close existing one. */
if|if
condition|(
name|paragraph_is_open
condition|)
name|close_paragraph
argument_list|()
expr_stmt|;
comment|/* In either case, the insertion paragraph is no longer closed. */
name|insertion_paragraph_closed
operator|=
literal|0
expr_stmt|;
comment|/* However, the paragraph is open! */
name|paragraph_is_open
operator|=
literal|1
expr_stmt|;
comment|/* If we MUST_START_PARAGRAPH, that simply means that start_paragraph ()      had to be called before we would allow any other paragraph operations      to have an effect. */
if|if
condition|(
operator|!
name|must_start_paragraph
condition|)
block|{
name|int
name|amount_to_indent
init|=
literal|0
decl_stmt|;
comment|/* If doing indentation, then insert the appropriate amount. */
if|if
condition|(
operator|!
name|no_indent
condition|)
block|{
if|if
condition|(
name|inhibit_paragraph_indentation
condition|)
block|{
name|amount_to_indent
operator|=
name|current_indent
expr_stmt|;
if|if
condition|(
name|inhibit_paragraph_indentation
operator|<
literal|0
condition|)
name|inhibit_paragraph_indentation
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|paragraph_start_indent
operator|<
literal|0
condition|)
name|amount_to_indent
operator|=
name|current_indent
expr_stmt|;
else|else
name|amount_to_indent
operator|=
name|current_indent
operator|+
name|paragraph_start_indent
expr_stmt|;
if|if
condition|(
name|amount_to_indent
operator|>=
name|output_column
condition|)
block|{
name|amount_to_indent
operator|-=
name|output_column
expr_stmt|;
name|indent
argument_list|(
name|amount_to_indent
argument_list|)
expr_stmt|;
name|output_column
operator|+=
name|amount_to_indent
expr_stmt|;
block|}
block|}
block|}
else|else
name|must_start_paragraph
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert the indentation specified by AMOUNT. */
end_comment

begin_function
name|void
name|indent
parameter_list|(
name|amount
parameter_list|)
name|int
name|amount
decl_stmt|;
block|{
if|if
condition|(
name|html
condition|)
return|return;
comment|/* For every START_POS saved within the brace stack which will be affected      by this indentation, bump that start pos forward. */
name|adjust_braces_following
argument_list|(
name|output_paragraph_offset
argument_list|,
name|amount
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|amount
operator|>=
literal|0
condition|)
name|insert
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Search forward for STRING in input_text.    FROM says where where to start. */
end_comment

begin_function
name|int
name|search_forward
parameter_list|(
name|string
parameter_list|,
name|from
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|from
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
while|while
condition|(
name|from
operator|<
name|input_text_length
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|input_text
operator|+
name|from
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|from
return|;
name|from
operator|++
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Cross references.  */
end_comment

begin_comment
comment|/* Return next comma-delimited argument, but do not cross a close-brace    boundary.  Clean up whitespace, too.  If EXPAND is nonzero, replace    the entire brace-delimited argument list with its expansion before    looking for the next comma.  */
end_comment

begin_function
name|char
modifier|*
name|get_xref_token
parameter_list|(
name|expand
parameter_list|)
name|int
name|expand
decl_stmt|;
block|{
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|expand
condition|)
block|{
name|int
name|old_offset
init|=
name|input_text_offset
decl_stmt|;
name|int
name|old_lineno
init|=
name|line_number
decl_stmt|;
name|get_until_in_braces
argument_list|(
literal|"}"
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|'}'
condition|)
comment|/* as opposed to end of text */
name|input_text_offset
operator|++
expr_stmt|;
if|if
condition|(
name|input_text_offset
operator|>
name|old_offset
condition|)
block|{
name|int
name|limit
init|=
name|input_text_offset
decl_stmt|;
name|input_text_offset
operator|=
name|old_offset
expr_stmt|;
name|line_number
operator|=
name|old_lineno
expr_stmt|;
name|only_macro_expansion
operator|++
expr_stmt|;
name|replace_with_expansion
argument_list|(
name|input_text_offset
argument_list|,
operator|&
name|limit
argument_list|)
expr_stmt|;
name|only_macro_expansion
operator|--
expr_stmt|;
block|}
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
name|get_until_in_braces
argument_list|(
literal|","
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|','
condition|)
name|input_text_offset
operator|++
expr_stmt|;
name|fix_whitespace
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/* NOTE: If you wonder why the HTML output is produced with such a    peculiar mix of calls to add_word and execute_string, here's the    reason.  get_xref_token (1) expands all macros in a reference, but    any other commands, like @value, @@, etc., are left intact.  To    expand them, we need to run the arguments through execute_string.    However, characters like<,&,> and others cannot be let into    execute_string, because they will be escaped.  See the mess?  */
end_comment

begin_comment
comment|/* Make a cross reference. */
end_comment

begin_function
name|void
name|cm_xref
parameter_list|(
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
name|char
modifier|*
name|arg1
init|=
name|get_xref_token
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|/* expands all macros in xref */
name|char
modifier|*
name|arg2
init|=
name|get_xref_token
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|char
modifier|*
name|arg3
init|=
name|get_xref_token
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|char
modifier|*
name|arg4
init|=
name|get_xref_token
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|char
modifier|*
name|arg5
init|=
name|get_xref_token
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|char
modifier|*
name|tem
decl_stmt|;
comment|/* "@xref{,Foo,, Bar, Baz} is not valid usage of @xref.  The 	 first argument must never be blank." --rms. 	 We hereby comply by disallowing such constructs.  */
if|if
condition|(
operator|!
operator|*
name|arg1
condition|)
name|line_error
argument_list|(
name|_
argument_list|(
literal|"First argument to cross-reference may not be empty"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xml
operator|&&
name|docbook
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|arg4
operator|&&
operator|!
operator|*
name|arg5
condition|)
block|{
name|char
modifier|*
name|arg1_id
init|=
name|xml_id
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|arg2
condition|)
block|{
name|xml_insert_element_with_attribute
argument_list|(
name|XREFNODENAME
argument_list|,
name|START
argument_list|,
literal|"linkend=\"%s\""
argument_list|,
name|arg1_id
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|arg1_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg2
condition|)
name|execute_string
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|XREFNODENAME
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xml_insert_element_with_attribute
argument_list|(
name|XREF
argument_list|,
name|START
argument_list|,
literal|"linkend=\"%s\""
argument_list|,
name|arg1_id
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|arg1_id
argument_list|)
expr_stmt|;
name|xml_pop_current_element
argument_list|()
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|xml
condition|)
block|{
name|xml_insert_element
argument_list|(
name|XREF
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|XREFNODENAME
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|XREFNODENAME
argument_list|,
name|END
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg2
condition|)
block|{
name|xml_insert_element
argument_list|(
name|XREFINFONAME
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|XREFINFONAME
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|arg3
condition|)
block|{
name|xml_insert_element
argument_list|(
name|XREFPRINTEDDESC
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|XREFPRINTEDDESC
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|arg4
condition|)
block|{
name|xml_insert_element
argument_list|(
name|XREFINFOFILE
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
name|arg4
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|XREFINFOFILE
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|arg5
condition|)
block|{
name|xml_insert_element
argument_list|(
name|XREFPRINTEDNAME
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
name|arg5
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|XREFPRINTEDNAME
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
name|xml_insert_element
argument_list|(
name|XREF
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|html
condition|)
block|{
if|if
condition|(
operator|!
name|ref_flag
condition|)
name|add_word_args
argument_list|(
literal|"%s"
argument_list|,
name|px_ref_flag
condition|?
name|_
argument_list|(
literal|"see "
argument_list|)
else|:
name|_
argument_list|(
literal|"See "
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|add_word_args
argument_list|(
literal|"%s"
argument_list|,
name|px_ref_flag
condition|?
literal|"*note "
else|:
literal|"*Note "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xml
condition|)
block|{
if|if
condition|(
operator|*
name|arg5
operator|||
operator|*
name|arg4
condition|)
block|{
comment|/* arg1 - node name 		 arg2 - reference name 		 arg3 - title or topic (and reference name if arg2 is NULL) 		 arg4 - info file name 		 arg5 - printed manual title  */
name|char
modifier|*
name|ref_name
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|arg2
condition|)
block|{
if|if
condition|(
operator|*
name|arg3
condition|)
name|ref_name
operator|=
name|arg3
expr_stmt|;
else|else
name|ref_name
operator|=
name|arg1
expr_stmt|;
block|}
else|else
name|ref_name
operator|=
name|arg2
expr_stmt|;
if|if
condition|(
name|html
condition|)
block|{
comment|/* html fixxme: revisit this; external node name not 		     much use to us with numbered nodes. */
name|add_html_elt
argument_list|(
literal|"<a href="
argument_list|)
expr_stmt|;
comment|/* Note that if we are splitting, and the referenced 		     tag is an anchor rather than a node, we will 		     produce a reference to a file whose name is 		     derived from the anchor name.  However, only 		     nodes create files, so we are referencing a 		     non-existent file.  cm_anchor, which see, deals 		     with that problem.  */
if|if
condition|(
name|splitting
condition|)
name|execute_string
argument_list|(
literal|"\"../%s/"
argument_list|,
name|arg4
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"\"%s.html"
argument_list|,
name|arg4
argument_list|)
expr_stmt|;
comment|/* Do not collapse -- to -, etc., in references.  */
name|in_fixed_width_font
operator|++
expr_stmt|;
name|tem
operator|=
name|expansion
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* expand @-commands in node */
name|in_fixed_width_font
operator|--
expr_stmt|;
name|add_anchor_name
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"\">"
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|ref_name
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"</a>"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execute_string
argument_list|(
literal|"%s:"
argument_list|,
name|ref_name
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|++
expr_stmt|;
name|execute_string
argument_list|(
literal|" (%s)%s%s"
argument_list|,
name|arg4
argument_list|,
name|arg1
argument_list|,
name|px_ref_flag
condition|?
literal|"."
else|:
literal|""
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|--
expr_stmt|;
block|}
comment|/* Free all of the arguments found. */
if|if
condition|(
name|arg1
condition|)
name|free
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg2
condition|)
name|free
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg3
condition|)
name|free
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg4
condition|)
name|free
argument_list|(
name|arg4
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg5
condition|)
name|free
argument_list|(
name|arg5
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|remember_node_reference
argument_list|(
name|arg1
argument_list|,
name|line_number
argument_list|,
name|followed_reference
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg3
condition|)
block|{
if|if
condition|(
name|html
condition|)
block|{
name|add_html_elt
argument_list|(
literal|"<a href=\""
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|++
expr_stmt|;
name|tem
operator|=
name|expansion
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|--
expr_stmt|;
name|add_anchor_name
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"\">"
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
operator|*
name|arg2
condition|?
name|arg2
else|:
name|arg3
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"</a>"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execute_string
argument_list|(
literal|"%s:"
argument_list|,
operator|*
name|arg2
condition|?
name|arg2
else|:
name|arg3
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|++
expr_stmt|;
name|execute_string
argument_list|(
literal|" %s%s"
argument_list|,
name|arg1
argument_list|,
name|px_ref_flag
condition|?
literal|"."
else|:
literal|""
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|html
condition|)
block|{
name|add_html_elt
argument_list|(
literal|"<a href=\""
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|++
expr_stmt|;
name|tem
operator|=
name|expansion
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|--
expr_stmt|;
name|add_anchor_name
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"\">"
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
operator|*
name|arg2
condition|?
name|arg2
else|:
name|arg1
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"</a>"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|arg2
condition|)
block|{
name|execute_string
argument_list|(
literal|"%s:"
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|++
expr_stmt|;
name|execute_string
argument_list|(
literal|" %s%s"
argument_list|,
name|arg1
argument_list|,
name|px_ref_flag
condition|?
literal|"."
else|:
literal|""
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|--
expr_stmt|;
block|}
else|else
block|{
name|in_fixed_width_font
operator|++
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s::"
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|--
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Free all of the arguments found. */
if|if
condition|(
name|arg1
condition|)
name|free
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg2
condition|)
name|free
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg3
condition|)
name|free
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg4
condition|)
name|free
argument_list|(
name|arg4
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg5
condition|)
name|free
argument_list|(
name|arg5
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check to make sure that the next non-whitespace character is          valid to follow an xref (so info readers can find the node          names).  `input_text_offset' is pointing at the "}" which ended          the xref or ref command. */
name|int
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|input_text_offset
operator|+
literal|1
init|;
name|temp
operator|<
name|input_text_length
condition|;
control|)
block|{
if|if
condition|(
name|cr_or_whitespace
argument_list|(
name|input_text
index|[
name|temp
index|]
argument_list|)
condition|)
name|temp
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|input_text
index|[
name|temp
index|]
operator|!=
literal|'.'
operator|&&
name|input_text
index|[
name|temp
index|]
operator|!=
literal|','
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"`.' or `,' must follow cross reference, not %c"
argument_list|)
argument_list|,
name|input_text
index|[
name|temp
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|cm_pxref
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
name|px_ref_flag
operator|++
expr_stmt|;
name|cm_xref
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|px_ref_flag
operator|--
expr_stmt|;
block|}
comment|/* Note that cm_xref isn't called with arg == END, which disables      the code near the end of cm_xref that checks for `.' or `,'      after the cross-reference.  This is because @pxref{} generates      the required character itself, when needed.  */
block|}
end_function

begin_function
name|void
name|cm_ref
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
name|ref_flag
operator|++
expr_stmt|;
name|cm_xref
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|ref_flag
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|cm_inforef
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
name|char
modifier|*
name|node
init|=
name|get_xref_token
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|/* expands all macros in inforef */
name|char
modifier|*
name|pname
init|=
name|get_xref_token
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|get_xref_token
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/* (see comments at cm_xref).  */
if|if
condition|(
operator|!
operator|*
name|node
condition|)
name|line_error
argument_list|(
name|_
argument_list|(
literal|"First argument to @inforef may not be empty"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xml
operator|&&
operator|!
name|docbook
condition|)
block|{
name|xml_insert_element
argument_list|(
name|INFOREF
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|INFOREFNODENAME
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|INFOREFNODENAME
argument_list|,
name|END
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pname
condition|)
block|{
name|xml_insert_element
argument_list|(
name|INFOREFREFNAME
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
name|pname
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|INFOREFREFNAME
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
name|xml_insert_element
argument_list|(
name|INFOREFINFONAME
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|INFOREFINFONAME
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|INFOREF
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|html
condition|)
block|{
name|char
modifier|*
name|tem
decl_stmt|;
name|add_word
argument_list|(
name|_
argument_list|(
literal|"see "
argument_list|)
argument_list|)
expr_stmt|;
comment|/* html fixxme: revisit this */
name|add_html_elt
argument_list|(
literal|"<a href="
argument_list|)
expr_stmt|;
if|if
condition|(
name|splitting
condition|)
name|execute_string
argument_list|(
literal|"\"../%s/"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"\"%s.html"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expansion
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_anchor_name
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"\">"
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
operator|*
name|pname
condition|?
name|pname
else|:
name|tem
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"</a>"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|pname
condition|)
name|execute_string
argument_list|(
literal|"*note %s: (%s)%s"
argument_list|,
name|pname
argument_list|,
name|file
argument_list|,
name|node
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"*note (%s)%s::"
argument_list|,
name|file
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* A URL reference.  */
end_comment

begin_function
name|void
name|cm_uref
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
specifier|extern
name|int
name|printing_index
decl_stmt|;
name|char
modifier|*
name|url
init|=
name|get_xref_token
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|/* expands all macros in uref */
name|char
modifier|*
name|desc
init|=
name|get_xref_token
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|char
modifier|*
name|replacement
init|=
name|get_xref_token
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|xml
condition|)
block|{
name|xml_insert_element
argument_list|(
name|UREF
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|UREFURL
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|UREFURL
argument_list|,
name|END
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|desc
condition|)
block|{
name|xml_insert_element
argument_list|(
name|UREFDESC
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|UREFDESC
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|replacement
condition|)
block|{
name|xml_insert_element
argument_list|(
name|UREFREPLACEMENT
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|UREFREPLACEMENT
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
name|xml_insert_element
argument_list|(
name|UREF
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|html
condition|)
block|{
comment|/* never need to show the url */
name|add_html_elt
argument_list|(
literal|"<a href="
argument_list|)
expr_stmt|;
comment|/* don't collapse `--' etc. in the url */
name|in_fixed_width_font
operator|++
expr_stmt|;
name|execute_string
argument_list|(
literal|"\"%s\""
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|--
expr_stmt|;
name|add_word
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
operator|*
name|replacement
condition|?
name|replacement
else|:
operator|(
operator|*
name|desc
condition|?
name|desc
else|:
name|url
operator|)
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"</a>"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|replacement
condition|)
comment|/* do not show the url */
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|desc
condition|)
comment|/* show both text and url */
block|{
name|execute_string
argument_list|(
literal|"%s "
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|++
expr_stmt|;
name|execute_string
argument_list|(
literal|"(%s)"
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|--
expr_stmt|;
block|}
else|else
comment|/* no text at all, so have the url to show */
block|{
name|in_fixed_width_font
operator|++
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s%s%s"
argument_list|,
name|printing_index
condition|?
literal|""
else|:
literal|"`"
argument_list|,
name|url
argument_list|,
name|printing_index
condition|?
literal|""
else|:
literal|"'"
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|url
condition|)
name|free
argument_list|(
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
condition|)
name|free
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|replacement
condition|)
name|free
argument_list|(
name|replacement
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* An email reference.  */
end_comment

begin_function
name|void
name|cm_email
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
name|char
modifier|*
name|addr
init|=
name|get_xref_token
argument_list|(
literal|1
argument_list|)
decl_stmt|;
comment|/* expands all macros in email */
name|char
modifier|*
name|name
init|=
name|get_xref_token
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|xml
operator|&&
name|docbook
condition|)
block|{
name|xml_insert_element_with_attribute
argument_list|(
name|EMAIL
argument_list|,
name|START
argument_list|,
literal|"url=\"mailto:%s\""
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
condition|)
name|execute_string
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|EMAIL
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xml
condition|)
block|{
name|xml_insert_element
argument_list|(
name|EMAIL
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|EMAILADDRESS
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|EMAILADDRESS
argument_list|,
name|END
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
condition|)
block|{
name|xml_insert_element
argument_list|(
name|EMAILNAME
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|EMAILNAME
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
name|xml_insert_element
argument_list|(
name|EMAIL
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|html
condition|)
block|{
name|add_html_elt
argument_list|(
literal|"<a href="
argument_list|)
expr_stmt|;
comment|/* don't collapse `--' etc. in the address */
name|in_fixed_width_font
operator|++
expr_stmt|;
name|execute_string
argument_list|(
literal|"\"mailto:%s\""
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|--
expr_stmt|;
name|add_word
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
operator|*
name|name
condition|?
name|name
else|:
name|addr
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"</a>"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execute_string
argument_list|(
literal|"%s%s"
argument_list|,
name|name
argument_list|,
operator|*
name|name
condition|?
literal|" "
else|:
literal|""
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|++
expr_stmt|;
name|execute_string
argument_list|(
literal|"<%s>"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|addr
condition|)
name|free
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* An external image is a reference, kind of.  The parsing is (not    coincidentally) similar, anyway.  */
end_comment

begin_function
name|void
name|cm_image
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|name_arg
decl_stmt|,
modifier|*
name|rest
decl_stmt|,
modifier|*
name|alt_arg
decl_stmt|,
modifier|*
name|ext_arg
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|END
condition|)
return|return;
name|name_arg
operator|=
name|get_xref_token
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* expands all macros in image */
comment|/* We don't (yet) care about the next two args, but read them so they      don't end up in the text.  */
name|rest
operator|=
name|get_xref_token
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rest
condition|)
name|free
argument_list|(
name|rest
argument_list|)
expr_stmt|;
name|rest
operator|=
name|get_xref_token
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rest
condition|)
name|free
argument_list|(
name|rest
argument_list|)
expr_stmt|;
name|alt_arg
operator|=
name|get_xref_token
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* expands all macros in alt text */
name|ext_arg
operator|=
name|get_xref_token
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name_arg
condition|)
block|{
name|char
modifier|*
name|fullname
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name_arg
argument_list|)
operator|+
operator|(
name|ext_arg
operator|&&
operator|*
name|ext_arg
condition|?
name|strlen
argument_list|(
name|ext_arg
argument_list|)
operator|+
literal|1
else|:
literal|4
operator|)
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|html
condition|)
block|{
if|if
condition|(
name|ext_arg
operator|&&
operator|*
name|ext_arg
condition|)
block|{
name|sprintf
argument_list|(
name|fullname
argument_list|,
literal|"%s.%s"
argument_list|,
name|name_arg
argument_list|,
name|ext_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|fullname
argument_list|,
name|R_OK
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"@image file `%s' (for HTML) not readable: %s"
argument_list|)
argument_list|,
name|fullname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|sprintf
argument_list|(
name|fullname
argument_list|,
literal|"%s.png"
argument_list|,
name|name_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|fullname
argument_list|,
name|R_OK
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|fullname
argument_list|,
literal|"%s.jpg"
argument_list|,
name|name_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|fullname
argument_list|,
name|R_OK
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"No `%s.png' or `.jpg', and no extension supplied"
argument_list|)
argument_list|,
name|name_arg
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|add_html_elt
argument_list|(
literal|"<img src="
argument_list|)
expr_stmt|;
name|add_word_args
argument_list|(
literal|"\"%s\""
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
name|add_html_elt
argument_list|(
literal|" alt="
argument_list|)
expr_stmt|;
name|add_word_args
argument_list|(
literal|"\"%s\">"
argument_list|,
operator|(
operator|*
name|alt_arg
operator|)
condition|?
name|alt_arg
else|:
name|fullname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xml
operator|&&
name|docbook
condition|)
name|xml_insert_docbook_image
argument_list|(
name|name_arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xml
condition|)
block|{
name|xml_insert_element
argument_list|(
name|IMAGE
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
name|name_arg
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|IMAGE
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Try to open foo.txt.  */
name|FILE
modifier|*
name|image_file
decl_stmt|;
name|strcpy
argument_list|(
name|fullname
argument_list|,
name|name_arg
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fullname
argument_list|,
literal|".txt"
argument_list|)
expr_stmt|;
name|image_file
operator|=
name|fopen
argument_list|(
name|fullname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|image_file
condition|)
block|{
name|int
name|ch
decl_stmt|;
name|int
name|save_inhibit_indentation
init|=
name|inhibit_paragraph_indentation
decl_stmt|;
name|int
name|save_filling_enabled
init|=
name|filling_enabled
decl_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|filling_enabled
operator|=
literal|0
expr_stmt|;
name|last_char_was_newline
operator|=
literal|0
expr_stmt|;
comment|/* Maybe we need to remove the final newline if the image                  file is only one line to allow in-line images.  On the                  other hand, they could just make the file without a                  final newline.  */
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|image_file
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|add_char
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
name|save_inhibit_indentation
expr_stmt|;
name|filling_enabled
operator|=
name|save_filling_enabled
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|image_file
argument_list|)
operator|!=
literal|0
condition|)
name|perror
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
block|}
else|else
name|line_error
argument_list|(
name|_
argument_list|(
literal|"@image file `%s' (for text) unreadable: %s"
argument_list|)
argument_list|,
name|fullname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
block|}
else|else
name|line_error
argument_list|(
name|_
argument_list|(
literal|"@image missing filename argument"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_arg
condition|)
name|free
argument_list|(
name|name_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|alt_arg
condition|)
name|free
argument_list|(
name|alt_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext_arg
condition|)
name|free
argument_list|(
name|ext_arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Conditionals.  */
end_comment

begin_comment
comment|/* A structure which contains `defined' variables. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|defines
block|{
name|struct
name|defines
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|}
name|DEFINE
typedef|;
end_typedef

begin_comment
comment|/* The linked list of `set' defines. */
end_comment

begin_decl_stmt
name|DEFINE
modifier|*
name|defines
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add NAME to the list of `set' defines. */
end_comment

begin_function
name|void
name|set
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|DEFINE
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|defines
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|temp
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|temp
operator|->
name|value
argument_list|)
expr_stmt|;
name|temp
operator|->
name|value
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
name|temp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DEFINE
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|defines
expr_stmt|;
name|temp
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|temp
operator|->
name|value
operator|=
name|xstrdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|defines
operator|=
name|temp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove NAME from the list of `set' defines. */
end_comment

begin_function
name|void
name|clear
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|DEFINE
modifier|*
name|temp
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|last
operator|=
name|NULL
expr_stmt|;
name|temp
operator|=
name|defines
expr_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|temp
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|last
condition|)
name|last
operator|->
name|next
operator|=
name|temp
operator|->
name|next
expr_stmt|;
else|else
name|defines
operator|=
name|temp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
block|}
name|last
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|temp
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the value of NAME.  The return value is NULL if NAME is unset. */
end_comment

begin_function
name|char
modifier|*
name|set_p
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|DEFINE
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|defines
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|temp
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|temp
operator|->
name|value
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Create a variable whose name appears as the first word on this line. */
end_comment

begin_function
name|void
name|cm_set
parameter_list|()
block|{
name|handle_variable
argument_list|(
name|SET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove a variable whose name appears as the first word on this line. */
end_comment

begin_function
name|void
name|cm_clear
parameter_list|()
block|{
name|handle_variable
argument_list|(
name|CLEAR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_ifset
parameter_list|()
block|{
name|handle_variable
argument_list|(
name|IFSET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_ifclear
parameter_list|()
block|{
name|handle_variable
argument_list|(
name|IFCLEAR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This command takes braces, but we parse the contents specially, so we    don't use the standard brace popping code.     The syntax @ifeq{arg1, arg2, texinfo-commands} performs texinfo-commands    if ARG1 and ARG2 caselessly string compare to the same string, otherwise,    it produces no output. */
end_comment

begin_function
name|void
name|cm_ifeq
parameter_list|()
block|{
name|char
modifier|*
modifier|*
name|arglist
decl_stmt|;
name|arglist
operator|=
name|get_brace_args
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
condition|)
block|{
if|if
condition|(
name|array_len
argument_list|(
name|arglist
argument_list|)
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|strcasecmp
argument_list|(
name|arglist
index|[
literal|0
index|]
argument_list|,
name|arglist
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|arglist
index|[
literal|2
index|]
operator|)
condition|)
name|execute_string
argument_list|(
literal|"%s\n"
argument_list|,
name|arglist
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
name|free_array
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|cm_value
parameter_list|(
name|arg
parameter_list|,
name|start_pos
parameter_list|,
name|end_pos
parameter_list|)
name|int
name|arg
decl_stmt|,
name|start_pos
decl_stmt|,
name|end_pos
decl_stmt|;
block|{
specifier|static
name|int
name|value_level
init|=
literal|0
decl_stmt|,
name|saved_meta_pos
init|=
operator|-
literal|1
decl_stmt|;
comment|/* All the text after @value{ upto the matching } will eventually      disappear from output_paragraph, when this function is called      with ARG == END.  If the text produced until then sets      meta_char_pos, we will need to restore it to the value it had      before @value was seen.  So we need to save the previous value      of meta_char_pos here.  */
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
comment|/* If we are already inside some outer @value, don't overwrite          the value saved in saved_meta_pos.  */
if|if
condition|(
operator|!
name|value_level
condition|)
name|saved_meta_pos
operator|=
name|meta_char_pos
expr_stmt|;
name|value_level
operator|++
expr_stmt|;
comment|/* While the argument of @value is processed, we need to inhibit 	 textual transformations like "--" into "-", since @set didn't 	 do that when it grabbed the name of the variable.  */
name|in_fixed_width_font
operator|++
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|output_paragraph
index|[
name|start_pos
index|]
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|output_paragraph
index|[
name|end_pos
index|]
operator|=
literal|0
expr_stmt|;
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|value
operator|=
name|set_p
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|output_column
operator|-=
name|end_pos
operator|-
name|start_pos
expr_stmt|;
name|output_paragraph_offset
operator|=
name|start_pos
expr_stmt|;
comment|/* Restore the previous value of meta_char_pos if the stuff          inside this @value{} moved it.  */
if|if
condition|(
name|saved_meta_pos
operator|==
operator|-
literal|1
condition|)
comment|/* can't happen inside @value{} */
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|value_level
operator|==
literal|1
operator|&&
name|meta_char_pos
operator|>=
name|start_pos
operator|&&
name|meta_char_pos
operator|<
name|end_pos
condition|)
block|{
name|meta_char_pos
operator|=
name|saved_meta_pos
expr_stmt|;
name|saved_meta_pos
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|value_level
operator|--
expr_stmt|;
comment|/* No need to decrement in_fixed_width_font, since before 	 we are called with arg == END, the reader loop already 	 popped the brace stack, which restored in_fixed_width_font, 	 among other things.  */
if|if
condition|(
name|value
condition|)
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|add_word_args
argument_list|(
name|_
argument_list|(
literal|"{No value for `%s'}"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set, clear, or conditionalize based on ACTION. */
end_comment

begin_function
name|void
name|handle_variable
parameter_list|(
name|action
parameter_list|)
name|int
name|action
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
comment|/* If we hit the end of text in get_rest_of_line, backing up      input pointer will cause the last character of the last line      be pushed back onto the input, which is wrong.  */
if|if
condition|(
name|input_text_offset
operator|<
name|input_text_length
condition|)
name|backup_input_pointer
argument_list|()
expr_stmt|;
name|handle_variable_internal
argument_list|(
name|action
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|handle_variable_internal
parameter_list|(
name|action
parameter_list|,
name|name
parameter_list|)
name|int
name|action
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|delimiter
decl_stmt|,
name|additional_text_present
init|=
literal|0
decl_stmt|;
comment|/* Only the first word of NAME is a valid tag. */
name|temp
operator|=
name|name
expr_stmt|;
name|delimiter
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|temp
operator|&&
operator|(
name|delimiter
operator|||
operator|!
name|whitespace
argument_list|(
operator|*
name|temp
argument_list|)
operator|)
condition|)
block|{
comment|/* #if defined (SET_WITH_EQUAL) */
if|if
condition|(
operator|*
name|temp
operator|==
literal|'"'
operator|||
operator|*
name|temp
operator|==
literal|'\''
condition|)
block|{
if|if
condition|(
operator|*
name|temp
operator|==
name|delimiter
condition|)
name|delimiter
operator|=
literal|0
expr_stmt|;
else|else
name|delimiter
operator|=
operator|*
name|temp
expr_stmt|;
block|}
comment|/* #endif SET_WITH_EQUAL */
name|temp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|temp
condition|)
name|additional_text_present
operator|++
expr_stmt|;
operator|*
name|temp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|name
condition|)
name|line_error
argument_list|(
name|_
argument_list|(
literal|"%c%s requires a name"
argument_list|)
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|SET
case|:
block|{
name|char
modifier|*
name|value
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SET_WITH_EQUAL
argument_list|)
comment|/* Allow a value to be saved along with a variable.  The value is                the text following an `=' sign in NAME, if any is present. */
for|for
control|(
name|value
operator|=
name|name
init|;
operator|*
name|value
operator|&&
operator|*
name|value
operator|!=
literal|'='
condition|;
name|value
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|value
condition|)
operator|*
name|value
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|value
operator|==
literal|'"'
operator|||
operator|*
name|value
operator|==
literal|'\''
condition|)
block|{
name|value
operator|++
expr_stmt|;
name|value
index|[
name|strlen
argument_list|(
name|value
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
comment|/* !SET_WITH_EQUAL */
comment|/* The VALUE of NAME is the remainder of the line sans                whitespace. */
if|if
condition|(
name|additional_text_present
condition|)
block|{
name|value
operator|=
name|temp
operator|+
literal|1
expr_stmt|;
name|canon_white
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
name|value
operator|=
literal|""
expr_stmt|;
endif|#
directive|endif
comment|/* !SET_WITH_VALUE */
name|set
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CLEAR
case|:
name|clear
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|IFSET
case|:
case|case
name|IFCLEAR
case|:
comment|/* If IFSET and NAME is not set, or if IFCLEAR and NAME is set,              read lines from the the file until we reach a matching              "@end CONDITION".  This means that we only take note of              "@ifset/clear" and "@end" commands. */
block|{
name|char
name|condition
index|[
literal|8
index|]
decl_stmt|;
name|int
name|condition_len
decl_stmt|;
name|int
name|orig_line_number
init|=
name|line_number
decl_stmt|;
if|if
condition|(
name|action
operator|==
name|IFSET
condition|)
name|strcpy
argument_list|(
name|condition
argument_list|,
literal|"ifset"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|condition
argument_list|,
literal|"ifclear"
argument_list|)
expr_stmt|;
name|condition_len
operator|=
name|strlen
argument_list|(
name|condition
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|action
operator|==
name|IFSET
operator|&&
operator|!
name|set_p
argument_list|(
name|name
argument_list|)
operator|)
operator|||
operator|(
name|action
operator|==
name|IFCLEAR
operator|&&
name|set_p
argument_list|(
name|name
argument_list|)
operator|)
condition|)
block|{
name|int
name|level
init|=
literal|0
decl_stmt|,
name|done
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
name|input_text_offset
operator|<
name|input_text_length
condition|)
block|{
name|char
modifier|*
name|freeable_line
decl_stmt|,
modifier|*
name|line
decl_stmt|;
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|freeable_line
argument_list|)
expr_stmt|;
for|for
control|(
name|line
operator|=
name|freeable_line
init|;
name|whitespace
argument_list|(
operator|*
name|line
argument_list|)
condition|;
name|line
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
name|COMMAND_PREFIX
operator|&&
operator|(
name|strncmp
argument_list|(
name|line
operator|+
literal|1
argument_list|,
name|condition
argument_list|,
name|condition_len
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|level
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"@end"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|cname
init|=
name|line
operator|+
literal|4
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
while|while
condition|(
operator|*
name|cname
operator|&&
name|whitespace
argument_list|(
operator|*
name|cname
argument_list|)
condition|)
name|cname
operator|++
expr_stmt|;
name|temp
operator|=
name|cname
expr_stmt|;
while|while
condition|(
operator|*
name|temp
operator|&&
operator|!
name|whitespace
argument_list|(
operator|*
name|temp
argument_list|)
condition|)
name|temp
operator|++
expr_stmt|;
operator|*
name|temp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cname
argument_list|,
name|condition
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|level
condition|)
block|{
name|done
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|level
operator|--
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|freeable_line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|done
condition|)
name|file_line_error
argument_list|(
name|input_filename
argument_list|,
name|orig_line_number
argument_list|,
name|_
argument_list|(
literal|"Reached eof before matching @end %s"
argument_list|)
argument_list|,
name|condition
argument_list|)
expr_stmt|;
comment|/* We found the end of a false @ifset/ifclear.  If we are                  in a menu, back up over the newline that ends the ifset,                  since that newline may also begin the next menu entry. */
break|break;
block|}
else|else
block|{
if|if
condition|(
name|action
operator|==
name|IFSET
condition|)
name|begin_insertion
argument_list|(
name|ifset
argument_list|)
expr_stmt|;
else|else
name|begin_insertion
argument_list|(
name|ifclear
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Execution of random text not in file. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|string
decl_stmt|;
comment|/* The string buffer. */
name|int
name|size
decl_stmt|;
comment|/* The size of the buffer. */
name|int
name|in_use
decl_stmt|;
comment|/* Nonzero means string currently in use. */
block|}
name|EXECUTION_STRING
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|EXECUTION_STRING
modifier|*
modifier|*
name|execution_strings
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|execution_strings_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|execution_strings_slots
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|EXECUTION_STRING
modifier|*
name|get_execution_string
parameter_list|(
name|initial_size
parameter_list|)
name|int
name|initial_size
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|EXECUTION_STRING
modifier|*
name|es
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|execution_strings
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|execution_strings_index
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|execution_strings
index|[
name|i
index|]
operator|&&
operator|(
name|execution_strings
index|[
name|i
index|]
operator|->
name|in_use
operator|==
literal|0
operator|)
condition|)
block|{
name|es
operator|=
name|execution_strings
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|es
condition|)
block|{
if|if
condition|(
name|execution_strings_index
operator|+
literal|1
operator|>=
name|execution_strings_slots
condition|)
block|{
name|execution_strings
operator|=
name|xrealloc
argument_list|(
name|execution_strings
argument_list|,
operator|(
name|execution_strings_slots
operator|+=
literal|3
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|EXECUTION_STRING
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|execution_strings_slots
condition|;
name|i
operator|++
control|)
name|execution_strings
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|execution_strings
index|[
name|execution_strings_index
index|]
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|EXECUTION_STRING
argument_list|)
argument_list|)
expr_stmt|;
name|es
operator|=
name|execution_strings
index|[
name|execution_strings_index
index|]
expr_stmt|;
name|execution_strings_index
operator|++
expr_stmt|;
name|es
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|es
operator|->
name|string
operator|=
name|NULL
expr_stmt|;
name|es
operator|->
name|in_use
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|initial_size
operator|>
name|es
operator|->
name|size
condition|)
block|{
name|es
operator|->
name|string
operator|=
name|xrealloc
argument_list|(
name|es
operator|->
name|string
argument_list|,
name|initial_size
argument_list|)
expr_stmt|;
name|es
operator|->
name|size
operator|=
name|initial_size
expr_stmt|;
block|}
return|return
name|es
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to TEXT and its desired length NEW_LEN, find TEXT's    entry in the execution_strings[] array and change the .STRING and    .SIZE members of that entry as appropriate.  */
end_comment

begin_function
name|void
name|maybe_update_execution_strings
parameter_list|(
name|text
parameter_list|,
name|new_len
parameter_list|)
name|char
modifier|*
modifier|*
name|text
decl_stmt|;
name|unsigned
name|new_len
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|execution_strings
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|execution_strings_index
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|execution_strings
index|[
name|i
index|]
operator|&&
operator|(
name|execution_strings
index|[
name|i
index|]
operator|->
name|in_use
operator|==
literal|1
operator|)
operator|&&
name|execution_strings
index|[
name|i
index|]
operator|->
name|string
operator|==
operator|*
name|text
condition|)
block|{
comment|/* Don't ever shrink the string storage in execution_strings[]!                execute_string assumes that it is always big enough to store                every possible execution_string, and will break if that's                not true.  So we only enlarge the string storage if the                current size isn't big enough.  */
if|if
condition|(
name|execution_strings
index|[
name|i
index|]
operator|->
name|size
operator|<
name|new_len
condition|)
block|{
name|execution_strings
index|[
name|i
index|]
operator|->
name|string
operator|=
operator|*
name|text
operator|=
name|xrealloc
argument_list|(
operator|*
name|text
argument_list|,
name|new_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|execution_strings
index|[
name|i
index|]
operator|->
name|size
operator|=
name|new_len
operator|+
literal|1
expr_stmt|;
block|}
return|return;
block|}
block|}
comment|/* We should *never* end up here, since if we are inside      execute_string, TEXT is always in execution_strings[].  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Execute the string produced by formatting the ARGs with FORMAT.  This    is like submitting a new file with @include. */
end_comment

begin_function
name|void
if|#
directive|if
name|defined
argument_list|(
name|VA_FPRINTF
argument_list|)
operator|&&
name|__STDC__
name|execute_string
parameter_list|(
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|execute_string
parameter_list|(
name|format
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
name|EXECUTION_STRING
modifier|*
name|es
decl_stmt|;
name|char
modifier|*
name|temp_string
decl_stmt|;
ifdef|#
directive|ifdef
name|VA_FPRINTF
name|va_list
name|ap
decl_stmt|;
endif|#
directive|endif
name|es
operator|=
name|get_execution_string
argument_list|(
literal|4000
argument_list|)
expr_stmt|;
name|temp_string
operator|=
name|es
operator|->
name|string
expr_stmt|;
name|es
operator|->
name|in_use
operator|=
literal|1
expr_stmt|;
name|VA_START
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VA_SPRINTF
name|VA_SPRINTF
argument_list|(
name|temp_string
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|temp_string
argument_list|,
name|format
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not VA_SPRINTF */
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|pushfile
argument_list|()
expr_stmt|;
name|input_text_offset
operator|=
literal|0
expr_stmt|;
name|input_text
operator|=
name|temp_string
expr_stmt|;
name|input_filename
operator|=
name|xstrdup
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|input_text_length
operator|=
name|strlen
argument_list|(
name|temp_string
argument_list|)
expr_stmt|;
name|executing_string
operator|++
expr_stmt|;
name|reader_loop
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|popfile
argument_list|()
expr_stmt|;
name|executing_string
operator|--
expr_stmt|;
name|es
operator|->
name|in_use
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return what would be output for STR (in newly-malloced memory), i.e.,    expand Texinfo commands.  If IMPLICIT_CODE is set, expand @code{STR}.  */
end_comment

begin_function
name|char
modifier|*
name|expansion
parameter_list|(
name|str
parameter_list|,
name|implicit_code
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|implicit_code
decl_stmt|;
block|{
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
comment|/* Inhibit any real output.  */
name|int
name|start
init|=
name|output_paragraph_offset
decl_stmt|;
name|int
name|saved_paragraph_is_open
init|=
name|paragraph_is_open
decl_stmt|;
name|int
name|saved_output_column
init|=
name|output_column
decl_stmt|;
comment|/* Inhibit indentation and filling, so that extra newlines      are not added to the expansion.  (This is undesirable if      we write the expanded text to macro_expansion_output_stream.)  */
name|int
name|saved_filling_enabled
init|=
name|filling_enabled
decl_stmt|;
name|int
name|saved_indented_fill
init|=
name|indented_fill
decl_stmt|;
name|int
name|saved_no_indent
init|=
name|no_indent
decl_stmt|;
name|int
name|saved_escape_html
init|=
name|escape_html
decl_stmt|;
name|int
name|saved_meta_pos
init|=
name|meta_char_pos
decl_stmt|;
name|int
name|saved_last_char
init|=
name|last_inserted_character
decl_stmt|;
name|int
name|saved_last_nl
init|=
name|last_char_was_newline
decl_stmt|;
comment|/* If we are called in the middle of processing a command, we need      to dup and save the global variable `command' (which holds the      name of this command), since the recursive reader loop will free      it from under our feet if it finds any macros in STR.  */
name|char
modifier|*
name|saved_command
init|=
name|command
condition|?
name|xstrdup
argument_list|(
name|command
argument_list|)
else|:
name|NULL
decl_stmt|;
name|filling_enabled
operator|=
literal|0
expr_stmt|;
name|indented_fill
operator|=
literal|0
expr_stmt|;
name|no_indent
operator|=
literal|1
expr_stmt|;
name|escape_html
operator|=
literal|0
expr_stmt|;
name|inhibit_output_flushing
argument_list|()
expr_stmt|;
name|paragraph_is_open
operator|=
literal|1
expr_stmt|;
name|execute_string
argument_list|(
name|implicit_code
condition|?
literal|"@code{%s}"
else|:
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|uninhibit_output_flushing
argument_list|()
expr_stmt|;
comment|/* Copy the expansion from the buffer.  */
name|length
operator|=
name|output_paragraph_offset
operator|-
name|start
expr_stmt|;
name|result
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|length
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|result
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|output_paragraph
operator|+
name|start
operator|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|result
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Pretend it never happened.  */
name|free_and_clear
argument_list|(
operator|&
name|command
argument_list|)
expr_stmt|;
name|command
operator|=
name|saved_command
expr_stmt|;
name|output_paragraph_offset
operator|=
name|start
expr_stmt|;
name|paragraph_is_open
operator|=
name|saved_paragraph_is_open
expr_stmt|;
name|output_column
operator|=
name|saved_output_column
expr_stmt|;
name|filling_enabled
operator|=
name|saved_filling_enabled
expr_stmt|;
name|indented_fill
operator|=
name|saved_indented_fill
expr_stmt|;
name|no_indent
operator|=
name|saved_no_indent
expr_stmt|;
name|escape_html
operator|=
name|saved_escape_html
expr_stmt|;
name|meta_char_pos
operator|=
name|saved_meta_pos
expr_stmt|;
name|last_inserted_character
operator|=
name|saved_last_char
expr_stmt|;
name|last_char_was_newline
operator|=
name|saved_last_nl
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return text (info) expansion of STR no matter what the current output    format is.  */
end_comment

begin_function
name|char
modifier|*
name|text_expansion
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|int
name|save_html
init|=
name|html
decl_stmt|;
name|html
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|expansion
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|html
operator|=
name|save_html
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the paragraph indentation variable to the value specified in STRING.    Values can be:      `asis': Don't change existing indentation.      `none': Remove existing indentation.         NUM: Indent NUM spaces at the starts of paragraphs.              If NUM is zero, we assume `none'.    Returns 0 if successful, or nonzero if STRING isn't one of the above. */
end_comment

begin_function
name|int
name|set_paragraph_indent
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"asis"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|string
argument_list|,
name|_
argument_list|(
literal|"asis"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|paragraph_start_indent
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|string
argument_list|,
name|_
argument_list|(
literal|"none"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|paragraph_start_indent
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|string
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|paragraph_start_indent
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
else|else
block|{
if|if
condition|(
name|paragraph_start_indent
operator|==
literal|0
condition|)
name|paragraph_start_indent
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

