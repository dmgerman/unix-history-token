begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Makeinfo -- convert texinfo format files into info files.    $Id: makeinfo.c,v 1.37 1996/10/04 18:20:52 karl Exp $     Copyright (C) 1987, 92, 93, 94, 95, 96 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Makeinfo is authored by Brian Fox (bfox@ai.mit.edu). */
end_comment

begin_decl_stmt
name|int
name|major_version
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|minor_version
init|=
literal|67
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* You can change some of the behaviour of Makeinfo by changing the    following defines: */
end_comment

begin_comment
comment|/* Define INDENT_PARAGRAPHS_IN_TABLE if you want the paragraphs which    appear within an @table, @ftable, or @itemize environment to have    standard paragraph indentation.  Without this, such paragraphs have    no starting indentation. */
end_comment

begin_comment
comment|/* #define INDENT_PARAGRAPHS_IN_TABLE */
end_comment

begin_comment
comment|/* Define DEFAULT_INDENTATION_INCREMENT as an integer which is the amount    that @example should increase indentation by.  This incremement is used    for all insertions which indent the enclosed text. */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_INDENTATION_INCREMENT
value|5
end_define

begin_comment
comment|/* Define PARAGRAPH_START_INDENT to be the amount of indentation that    the first lines of paragraphs receive by default, where no other    value has been specified.  Users can change this value on the command    line, with the --paragraph-indent option, or within the texinfo file,    with the @paragraphindent command. */
end_comment

begin_define
define|#
directive|define
name|PARAGRAPH_START_INDENT
value|3
end_define

begin_comment
comment|/* Define DEFAULT_PARAGRAPH_SPACING as the number of blank lines that you    wish to appear between paragraphs.  A value of 1 creates a single blank    line between paragraphs.  Paragraphs are defined by 2 or more consecutive    newlines in the input file (i.e., one or more blank lines). */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_PARAGRAPH_SPACING
value|1
end_define

begin_comment
comment|/* Define HAVE_MACROS to enable the macro facility of Texinfo.  Using this    facility, users can create their own command procedures with arguments. */
end_comment

begin_define
define|#
directive|define
name|HAVE_MACROS
end_define

begin_comment
comment|/* Indent #pragma so that older Cpp's don't try to parse it. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_AIX
argument_list|)
end_if

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _AIX */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_VARARGS_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_VARARGS_H */
end_comment

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_UNISTD_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<perror.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STRING_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_STRING_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TM_IN_SYS_TIME
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !TM_IN_SYS_TIME */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_FCNTL_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_SYS_FCNTL_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_FILE_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_FILE_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_ALLOCA_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !HAVE_ALLOCA_H */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_AIX
argument_list|)
end_if

begin_function_decl
specifier|extern
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_AIX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_ALLOCA_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__GNUC__ */
end_comment

begin_decl_stmt
name|void
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__osf__
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|void
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|realloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __osf__ */
end_comment

begin_function_decl
name|char
modifier|*
modifier|*
name|get_brace_args
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|array_len
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|free_array
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|isolate_nodename
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|COMPILING_MAKEINFO
end_define

begin_include
include|#
directive|include
file|"makeinfo.h"
end_include

begin_comment
comment|/* Non-zero means that we are currently hacking the insides of an    insertion which would use a fixed width font. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|in_fixed_width_font
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that start_paragraph () MUST be called before we pay    any attention to close_paragraph () calls. */
end_comment

begin_decl_stmt
name|int
name|must_start_paragraph
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means a string is in execution, as opposed to a file. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|executing_string
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
end_if

begin_comment
comment|/* If non-NULL, this is an output stream to write the full macro expansion    of the input text to.  The resultant file is another texinfo file, but    missing @include, @infoinclude, @macro, and macro invocations.  Instead,    all of the text is placed within the file. */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|macro_expansion_output_stream
init|=
operator|(
name|FILE
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Here is a structure used to remember input text strings and offsets    within them. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|pointer
decl_stmt|;
comment|/* Pointer to the input text. */
name|int
name|offset
decl_stmt|;
comment|/* Offset of the last character output. */
block|}
name|ITEXT
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|ITEXT
modifier|*
modifier|*
name|itext_info
init|=
operator|(
name|ITEXT
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|itext_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to inhibit the writing of macro expansions to the output    stream.  This is used in special cases where the output has already been    written. */
end_comment

begin_decl_stmt
name|int
name|me_inhibit_expansion
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
name|ITEXT
modifier|*
name|remember_itext
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|forget_itext
argument_list|()
decl_stmt|,
name|me_append_before_this_command
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|append_to_expansion_output
argument_list|()
decl_stmt|,
name|write_region_to_macro_output
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|maybe_write_itext
argument_list|()
decl_stmt|,
name|me_execute_string
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_MACROS */
end_comment

begin_comment
comment|/* Some systems don't declare this function in pwd.h. */
end_comment

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			    Global Variables			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Global pointer to argv[0]. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return non-zero if STRING is the text at input_text + input_text_offset,    else zero. */
end_comment

begin_define
define|#
directive|define
name|looking_at
parameter_list|(
name|string
parameter_list|)
define|\
value|(strncmp (input_text + input_text_offset, string, strlen (string)) == 0)
end_define

begin_comment
comment|/* And writing to the output. */
end_comment

begin_comment
comment|/* The output file name. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|output_filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|pretty_output_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of the output file that the user elected to pass on the command line.    Such a name overrides any name found with the @setfilename command. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|command_output_filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A colon separated list of directories to search for files included    with @include.  This can be controlled with the `-I' option to makeinfo. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|include_files_path
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current output stream. */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|output_stream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Position in the output file. */
end_comment

begin_decl_stmt
name|int
name|output_position
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INITIAL_PARAGRAPH_SPACE
value|5000
end_define

begin_decl_stmt
name|int
name|paragraph_buffer_len
init|=
name|INITIAL_PARAGRAPH_SPACE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Filling.. */
end_comment

begin_comment
comment|/* Non-zero indicates that filling will take place on long lines. */
end_comment

begin_decl_stmt
name|int
name|filling_enabled
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that words are not to be split, even in long lines.  This    gets changed for cm_w (). */
end_comment

begin_decl_stmt
name|int
name|non_splitting_words
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero indicates that filling a line also indents the new line. */
end_comment

begin_decl_stmt
name|int
name|indented_fill
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The amount of indentation to add at the starts of paragraphs.    0 means don't change existing indentation at paragraph starts.> 0 is amount to indent new paragraphs by.< 0 means indent to column zero by removing indentation if necessary.     This is normally zero, but some people prefer paragraph starts to be    somewhat more indented than paragraph bodies.  A pretty value for    this is 3. */
end_comment

begin_decl_stmt
name|int
name|paragraph_start_indent
init|=
name|PARAGRAPH_START_INDENT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that the use of paragraph_start_indent is inhibited.    @example uses this to line up the left columns of the example text.    A negative value for this variable is incremented each time it is used.    @noindent uses this to inhibit indentation for a single paragraph.  */
end_comment

begin_decl_stmt
name|int
name|inhibit_paragraph_indentation
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indentation that is pending insertion.  We have this for hacking lines    which look blank, but contain whitespace.  We want to treat those as    blank lines. */
end_comment

begin_decl_stmt
name|int
name|pending_indent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The amount that indentation increases/decreases by. */
end_comment

begin_decl_stmt
name|int
name|default_indentation_increment
init|=
name|DEFAULT_INDENTATION_INCREMENT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero indicates that indentation is temporarily turned off. */
end_comment

begin_decl_stmt
name|int
name|no_indent
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means forcing output text to be flushright. */
end_comment

begin_decl_stmt
name|int
name|force_flush_right
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that the footnote style for this document was set on    the command line, which overrides any other settings. */
end_comment

begin_decl_stmt
name|int
name|footnote_style_preset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that we automatically number footnotes that have no    specified marker. */
end_comment

begin_decl_stmt
name|int
name|number_footnotes
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current footnote number in this node.  Each time a new node is    started this is reset to 1. */
end_comment

begin_decl_stmt
name|int
name|current_footnote_number
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command name in the process of being hacked. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|command
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The index in our internal command table of the currently    executing command. */
end_comment

begin_decl_stmt
name|int
name|command_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A search string which is used to find a line defining a node. */
end_comment

begin_decl_stmt
name|char
name|node_search_string
index|[]
init|=
block|{
literal|'\n'
block|,
name|COMMAND_PREFIX
block|,
literal|'n'
block|,
literal|'o'
block|,
literal|'d'
block|,
literal|'e'
block|,
literal|' '
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A search string which is used to find a line defining a menu. */
end_comment

begin_decl_stmt
name|char
name|menu_search_string
index|[]
init|=
block|{
literal|'\n'
block|,
name|COMMAND_PREFIX
block|,
literal|'m'
block|,
literal|'e'
block|,
literal|'n'
block|,
literal|'u'
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A search string which is used to find the first @setfilename. */
end_comment

begin_decl_stmt
name|char
name|setfilename_search
index|[]
init|=
block|{
name|COMMAND_PREFIX
block|,
literal|'s'
block|,
literal|'e'
block|,
literal|'t'
block|,
literal|'f'
block|,
literal|'i'
block|,
literal|'l'
block|,
literal|'e'
block|,
literal|'n'
block|,
literal|'a'
block|,
literal|'m'
block|,
literal|'e'
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A stack of file information records.  If a new file is read in with    "@input", we remember the old input file state on this stack. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|fstack
block|{
name|struct
name|fstack
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|line_number
decl_stmt|;
block|}
name|FSTACK
typedef|;
end_typedef

begin_decl_stmt
name|FSTACK
modifier|*
name|filestack
init|=
operator|(
name|FSTACK
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stuff for nodes. */
end_comment

begin_comment
comment|/* The current nodes node name. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|current_node
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current nodes section level. */
end_comment

begin_decl_stmt
name|int
name|current_section
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The filename of the current input file.  This is never freed. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|node_filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What we remember for each node. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|tentry
block|{
name|struct
name|tentry
modifier|*
name|next_ent
decl_stmt|;
name|char
modifier|*
name|node
decl_stmt|;
comment|/* name of this node. */
name|char
modifier|*
name|prev
decl_stmt|;
comment|/* name of "Prev:" for this node. */
name|char
modifier|*
name|next
decl_stmt|;
comment|/* name of "Next:" for this node. */
name|char
modifier|*
name|up
decl_stmt|;
comment|/* name of "Up:" for this node.   */
name|int
name|position
decl_stmt|;
comment|/* output file position of this node. */
name|int
name|line_no
decl_stmt|;
comment|/* defining line in source file. */
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* The file that this node was found in. */
name|int
name|touched
decl_stmt|;
comment|/* non-zero means this node has been referenced. */
name|int
name|flags
decl_stmt|;
comment|/* Room for growth.  Right now, contains 1 bit. */
block|}
name|TAG_ENTRY
typedef|;
end_typedef

begin_comment
comment|/* If node-a has a "Next" for node-b, but node-b has no "Prev" for node-a,    we turn on this flag bit in node-b's tag entry.  This means that when    it is time to validate node-b, we don't report an additional error    if there was no "Prev" field. */
end_comment

begin_define
define|#
directive|define
name|PREV_ERROR
value|0x1
end_define

begin_define
define|#
directive|define
name|NEXT_ERROR
value|0x2
end_define

begin_define
define|#
directive|define
name|UP_ERROR
value|0x4
end_define

begin_define
define|#
directive|define
name|NO_WARN
value|0x8
end_define

begin_define
define|#
directive|define
name|IS_TOP
value|0x10
end_define

begin_decl_stmt
name|TAG_ENTRY
modifier|*
name|tag_table
init|=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
end_if

begin_define
define|#
directive|define
name|ME_RECURSE
value|0x01
end_define

begin_define
define|#
directive|define
name|ME_QUOTE_ARG
value|0x02
end_define

begin_comment
comment|/* Macro definitions for user-defined commands. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of the macro. */
name|char
modifier|*
modifier|*
name|arglist
decl_stmt|;
comment|/* Args to replace when executing. */
name|char
modifier|*
name|body
decl_stmt|;
comment|/* Macro body. */
name|char
modifier|*
name|source_file
decl_stmt|;
comment|/* File where this macro is defined. */
name|int
name|source_lineno
decl_stmt|;
comment|/* Line number within FILENAME. */
name|int
name|inhibited
decl_stmt|;
comment|/* Non-zero means make find_macro () fail. */
name|int
name|flags
decl_stmt|;
comment|/* ME_RECURSE, ME_QUOTE_ARG, etc. */
block|}
name|MACRO_DEF
typedef|;
end_typedef

begin_decl_stmt
name|void
name|add_macro
argument_list|()
decl_stmt|,
name|execute_macro
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MACRO_DEF
modifier|*
name|find_macro
argument_list|()
decl_stmt|,
modifier|*
name|delete_macro
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_MACROS */
end_comment

begin_comment
comment|/* Menu reference, *note reference, and validation hacking. */
end_comment

begin_comment
comment|/* The various references that we know about. */
end_comment

begin_enum
enum|enum
name|reftype
block|{
name|menu_reference
block|,
name|followed_reference
block|}
enum|;
end_enum

begin_comment
comment|/* A structure to remember references with.  A reference to a node is    either an entry in a menu, or a cross-reference made with [px]ref. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|node_ref
block|{
name|struct
name|node_ref
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|node
decl_stmt|;
comment|/* Name of node referred to. */
name|char
modifier|*
name|containing_node
decl_stmt|;
comment|/* Name of node containing this reference. */
name|int
name|line_no
decl_stmt|;
comment|/* Line number where the reference occurs. */
name|int
name|section
decl_stmt|;
comment|/* Section level where the reference occurs. */
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* Name of file where the reference occurs. */
name|enum
name|reftype
name|type
decl_stmt|;
comment|/* Type of reference, either menu or note. */
block|}
name|NODE_REF
typedef|;
end_typedef

begin_comment
comment|/* The linked list of such structures. */
end_comment

begin_decl_stmt
name|NODE_REF
modifier|*
name|node_references
init|=
operator|(
name|NODE_REF
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag which tells us whether to examine menu lines or not. */
end_comment

begin_decl_stmt
name|int
name|in_menu
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag which tells us how to examine menu lines. */
end_comment

begin_decl_stmt
name|int
name|in_detailmenu
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that we have seen "@top" once already. */
end_comment

begin_decl_stmt
name|int
name|top_node_seen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that we have seen a non-"@top" node already. */
end_comment

begin_decl_stmt
name|int
name|non_top_node_seen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flags controlling the operation of the program. */
end_comment

begin_comment
comment|/* Default is to notify users of bad choices. */
end_comment

begin_decl_stmt
name|int
name|print_warnings
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default is to check node references. */
end_comment

begin_decl_stmt
name|int
name|validating
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means do not output "Node: Foo" for node separations. */
end_comment

begin_decl_stmt
name|int
name|no_headers
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of errors that we tolerate on a given fileset. */
end_comment

begin_decl_stmt
name|int
name|max_error_level
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum number of references to a single node before complaining. */
end_comment

begin_decl_stmt
name|int
name|reference_warning_limit
init|=
literal|1000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means print out information about what is going on when it    is going on. */
end_comment

begin_decl_stmt
name|int
name|verbose_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to be relaxed about the input file.  This is useful when    we can successfully format the input, but it doesn't strictly match our    somewhat pedantic ideas of correctness.  Right now, it affects what    @table and @itemize do without arguments. */
end_comment

begin_decl_stmt
name|int
name|allow_lax_format
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of commands that we hack in texinfo.  Each one    has an associated function.  When the command is encountered in the    text, the associated function is called with START as the argument.    If the function expects arguments in braces, it remembers itself on    the stack.  When the corresponding close brace is encountered, the    function is called with END as the argument. */
end_comment

begin_define
define|#
directive|define
name|START
value|0
end_define

begin_define
define|#
directive|define
name|END
value|1
end_define

begin_typedef
typedef|typedef
struct|struct
name|brace_element
block|{
name|struct
name|brace_element
modifier|*
name|next
decl_stmt|;
name|COMMAND_FUNCTION
modifier|*
name|proc
decl_stmt|;
name|int
name|pos
decl_stmt|,
name|line
decl_stmt|;
name|int
name|in_fixed_width_font
decl_stmt|;
block|}
name|BRACE_ELEMENT
typedef|;
end_typedef

begin_decl_stmt
name|BRACE_ELEMENT
modifier|*
name|brace_stack
init|=
operator|(
name|BRACE_ELEMENT
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_STRDUP
argument_list|)
end_if

begin_function_decl
specifier|extern
name|char
modifier|*
name|strdup
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STRDUP */
end_comment

begin_function_decl
specifier|extern
name|void
name|do_multitable
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_version_info
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|usage
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|push_node_filename
argument_list|()
decl_stmt|,
name|pop_node_filename
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|remember_error
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|convert_from_stream
argument_list|()
decl_stmt|,
name|convert_from_file
argument_list|()
decl_stmt|,
name|convert_from_loaded_file
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|init_internals
argument_list|()
decl_stmt|,
name|init_paragraph
argument_list|()
decl_stmt|,
name|init_brace_stack
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|init_insertion_stack
argument_list|()
decl_stmt|,
name|init_indices
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|init_tag_table
argument_list|()
decl_stmt|,
name|write_tag_table
argument_list|()
decl_stmt|,
name|write_tag_table_internal
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|validate_file
argument_list|()
decl_stmt|,
name|validate_other_references
argument_list|()
decl_stmt|,
name|split_file
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|free_node_references
argument_list|()
decl_stmt|,
name|do_enumeration
argument_list|()
decl_stmt|,
name|handle_variable
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|handle_variable_internal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|execute_string
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|normalize_node_name
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|undefindex
argument_list|()
decl_stmt|,
name|top_defindex
argument_list|()
decl_stmt|,
name|gen_defindex
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|define_user_command
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|free_pending_notes
argument_list|()
decl_stmt|,
name|output_pending_notes
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|reader_loop
argument_list|()
decl_stmt|,
name|read_command
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|remember_brace
argument_list|()
decl_stmt|,
name|remember_brace_1
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|pop_and_call_brace
argument_list|()
decl_stmt|,
name|discard_braces
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|add_word_args
argument_list|()
decl_stmt|,
name|add_word
argument_list|()
decl_stmt|,
name|add_char
argument_list|()
decl_stmt|,
name|insert
argument_list|()
decl_stmt|,
name|flush_output
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|insert_string
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|close_paragraph_with_lines
argument_list|()
decl_stmt|,
name|close_paragraph
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|ignore_blank_line
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|do_flush_right_indentation
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|start_paragraph
argument_list|()
decl_stmt|,
name|indent
argument_list|()
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
name|void
name|insert_self
argument_list|()
decl_stmt|,
name|insert_space
argument_list|()
decl_stmt|,
name|cm_ignore_line
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|cm_TeX
argument_list|()
decl_stmt|,
name|cm_asterisk
argument_list|()
decl_stmt|,
name|cm_bullet
argument_list|()
decl_stmt|,
name|cm_cite
argument_list|()
decl_stmt|,
name|cm_code
argument_list|()
decl_stmt|,
name|cm_copyright
argument_list|()
decl_stmt|,
name|cm_ctrl
argument_list|()
decl_stmt|,
name|cm_dfn
argument_list|()
decl_stmt|,
name|cm_dircategory
argument_list|()
decl_stmt|,
name|cm_direntry
argument_list|()
decl_stmt|,
name|cm_dots
argument_list|()
decl_stmt|,
name|cm_emph
argument_list|()
decl_stmt|,
name|cm_enddots
argument_list|()
decl_stmt|,
name|cm_kbd
argument_list|()
decl_stmt|,
name|cm_angle_brackets
argument_list|()
decl_stmt|,
name|cm_no_op
argument_list|()
decl_stmt|,
name|cm_not_fixed_width
argument_list|()
decl_stmt|,
name|cm_strong
argument_list|()
decl_stmt|,
name|cm_var
argument_list|()
decl_stmt|,
name|cm_w
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sectioning.  */
end_comment

begin_decl_stmt
name|void
name|cm_chapter
argument_list|()
decl_stmt|,
name|cm_unnumbered
argument_list|()
decl_stmt|,
name|cm_appendix
argument_list|()
decl_stmt|,
name|cm_top
argument_list|()
decl_stmt|,
name|cm_section
argument_list|()
decl_stmt|,
name|cm_unnumberedsec
argument_list|()
decl_stmt|,
name|cm_appendixsec
argument_list|()
decl_stmt|,
name|cm_subsection
argument_list|()
decl_stmt|,
name|cm_unnumberedsubsec
argument_list|()
decl_stmt|,
name|cm_appendixsubsec
argument_list|()
decl_stmt|,
name|cm_subsubsection
argument_list|()
decl_stmt|,
name|cm_unnumberedsubsubsec
argument_list|()
decl_stmt|,
name|cm_appendixsubsubsec
argument_list|()
decl_stmt|,
name|cm_heading
argument_list|()
decl_stmt|,
name|cm_chapheading
argument_list|()
decl_stmt|,
name|cm_subheading
argument_list|()
decl_stmt|,
name|cm_subsubheading
argument_list|()
decl_stmt|,
name|cm_majorheading
argument_list|()
decl_stmt|,
name|cm_raisesections
argument_list|()
decl_stmt|,
name|cm_lowersections
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All @defxxx commands map to cm_defun, most accent commands map to    cm_accent, most non-English letters map to cm_special_char.  */
end_comment

begin_decl_stmt
name|void
name|cm_defun
argument_list|()
decl_stmt|,
name|cm_accent
argument_list|()
decl_stmt|,
name|cm_special_char
argument_list|()
decl_stmt|,
name|cm_dotless
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|cm_node
argument_list|()
decl_stmt|,
name|cm_menu
argument_list|()
decl_stmt|,
name|cm_xref
argument_list|()
decl_stmt|,
name|cm_ftable
argument_list|()
decl_stmt|,
name|cm_vtable
argument_list|()
decl_stmt|,
name|cm_pxref
argument_list|()
decl_stmt|,
name|cm_inforef
argument_list|()
decl_stmt|,
name|cm_quotation
argument_list|()
decl_stmt|,
name|cm_display
argument_list|()
decl_stmt|,
name|cm_itemize
argument_list|()
decl_stmt|,
name|cm_enumerate
argument_list|()
decl_stmt|,
name|cm_tab
argument_list|()
decl_stmt|,
name|cm_table
argument_list|()
decl_stmt|,
name|cm_itemx
argument_list|()
decl_stmt|,
name|cm_noindent
argument_list|()
decl_stmt|,
name|cm_setfilename
argument_list|()
decl_stmt|,
name|cm_br
argument_list|()
decl_stmt|,
name|cm_sp
argument_list|()
decl_stmt|,
name|cm_page
argument_list|()
decl_stmt|,
name|cm_group
argument_list|()
decl_stmt|,
name|cm_center
argument_list|()
decl_stmt|,
name|cm_include
argument_list|()
decl_stmt|,
name|cm_bye
argument_list|()
decl_stmt|,
name|cm_item
argument_list|()
decl_stmt|,
name|cm_end
argument_list|()
decl_stmt|,
name|cm_ifinfo
argument_list|()
decl_stmt|,
name|cm_kindex
argument_list|()
decl_stmt|,
name|cm_cindex
argument_list|()
decl_stmt|,
name|cm_findex
argument_list|()
decl_stmt|,
name|cm_pindex
argument_list|()
decl_stmt|,
name|cm_vindex
argument_list|()
decl_stmt|,
name|cm_tindex
argument_list|()
decl_stmt|,
name|cm_synindex
argument_list|()
decl_stmt|,
name|cm_printindex
argument_list|()
decl_stmt|,
name|cm_minus
argument_list|()
decl_stmt|,
name|cm_footnote
argument_list|()
decl_stmt|,
name|cm_example
argument_list|()
decl_stmt|,
name|cm_smallexample
argument_list|()
decl_stmt|,
name|cm_lisp
argument_list|()
decl_stmt|,
name|cm_format
argument_list|()
decl_stmt|,
name|cm_exdent
argument_list|()
decl_stmt|,
name|cm_defindex
argument_list|()
decl_stmt|,
name|cm_defcodeindex
argument_list|()
decl_stmt|,
name|cm_sc
argument_list|()
decl_stmt|,
name|cm_result
argument_list|()
decl_stmt|,
name|cm_expansion
argument_list|()
decl_stmt|,
name|cm_equiv
argument_list|()
decl_stmt|,
name|cm_print
argument_list|()
decl_stmt|,
name|cm_error
argument_list|()
decl_stmt|,
name|cm_point
argument_list|()
decl_stmt|,
name|cm_today
argument_list|()
decl_stmt|,
name|cm_flushleft
argument_list|()
decl_stmt|,
name|cm_flushright
argument_list|()
decl_stmt|,
name|cm_smalllisp
argument_list|()
decl_stmt|,
name|cm_finalout
argument_list|()
decl_stmt|,
name|cm_cartouche
argument_list|()
decl_stmt|,
name|cm_detailmenu
argument_list|()
decl_stmt|,
name|cm_multitable
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Conditionals. */
end_comment

begin_decl_stmt
name|void
name|cm_set
argument_list|()
decl_stmt|,
name|cm_clear
argument_list|()
decl_stmt|,
name|cm_ifset
argument_list|()
decl_stmt|,
name|cm_ifclear
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|cm_value
argument_list|()
decl_stmt|,
name|cm_ifeq
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
end_if

begin_comment
comment|/* Define a user-defined command which is simple substitution. */
end_comment

begin_decl_stmt
name|void
name|cm_macro
argument_list|()
decl_stmt|,
name|cm_unmacro
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_MACROS */
end_comment

begin_comment
comment|/* Options. */
end_comment

begin_decl_stmt
name|void
name|cm_paragraphindent
argument_list|()
decl_stmt|,
name|cm_footnotestyle
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Internals. */
end_comment

begin_decl_stmt
name|void
name|command_name_condition
argument_list|()
decl_stmt|,
name|misplaced_brace
argument_list|()
decl_stmt|,
name|cm_obsolete
argument_list|()
decl_stmt|,
name|cm_ideprecated
argument_list|()
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|COMMAND_FUNCTION
modifier|*
name|proc
decl_stmt|;
name|int
name|argument_in_braces
decl_stmt|;
block|}
name|COMMAND
typedef|;
end_typedef

begin_comment
comment|/* Stuff for defining commands on the fly. */
end_comment

begin_decl_stmt
name|COMMAND
modifier|*
modifier|*
name|user_command_array
init|=
operator|(
name|COMMAND
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|user_command_array_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NO_BRACE_ARGS
value|0
end_define

begin_define
define|#
directive|define
name|BRACE_ARGS
value|1
end_define

begin_decl_stmt
specifier|static
name|COMMAND
name|CommandTable
index|[]
init|=
block|{
block|{
literal|"\t"
block|,
name|insert_space
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"\n"
block|,
name|insert_space
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|" "
block|,
name|insert_self
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"!"
block|,
name|insert_self
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"\""
block|,
name|insert_self
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"'"
block|,
name|insert_self
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"*"
block|,
name|cm_asterisk
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|","
block|,
name|cm_accent
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"-"
block|,
name|cm_no_op
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"."
block|,
name|insert_self
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|":"
block|,
name|cm_no_op
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"="
block|,
name|insert_self
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"?"
block|,
name|insert_self
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"@"
block|,
name|insert_self
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"^"
block|,
name|insert_self
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"`"
block|,
name|insert_self
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"{"
block|,
name|insert_self
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"|"
block|,
name|cm_no_op
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"}"
block|,
name|insert_self
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"~"
block|,
name|insert_self
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"AA"
block|,
name|insert_self
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"AE"
block|,
name|insert_self
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"H"
block|,
name|cm_accent
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"L"
block|,
name|cm_special_char
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"O"
block|,
name|cm_special_char
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"OE"
block|,
name|insert_self
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"TeX"
block|,
name|cm_TeX
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"aa"
block|,
name|insert_self
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"ae"
block|,
name|insert_self
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"appendix"
block|,
name|cm_appendix
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"appendixsection"
block|,
name|cm_appendixsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"appendixsec"
block|,
name|cm_appendixsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"appendixsubsec"
block|,
name|cm_appendixsubsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"appendixsubsubsec"
block|,
name|cm_appendixsubsubsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"asis"
block|,
name|cm_no_op
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"b"
block|,
name|cm_not_fixed_width
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"bullet"
block|,
name|cm_bullet
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"bye"
block|,
name|cm_bye
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"c"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"cartouche"
block|,
name|cm_cartouche
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"center"
block|,
name|cm_center
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"centerchap"
block|,
name|cm_unnumbered
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"chapheading"
block|,
name|cm_chapheading
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"chapter"
block|,
name|cm_chapter
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"cindex"
block|,
name|cm_cindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"cite"
block|,
name|cm_cite
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"clear"
block|,
name|cm_clear
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"code"
block|,
name|cm_code
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"comment"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"contents"
block|,
name|cm_no_op
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"copyright"
block|,
name|cm_copyright
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"ctrl"
block|,
name|cm_obsolete
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"defcodeindex"
block|,
name|cm_defcodeindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defindex"
block|,
name|cm_defindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
comment|/* The `def' commands. */
block|{
literal|"defcv"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defcvx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deffn"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deffnx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defivar"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defivarx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defmac"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defmacx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defmethod"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defmethodx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defop"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defopt"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defoptx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defopx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defspec"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defspecx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftp"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftpx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypefn"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypefnx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypefun"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypefunx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypemethod"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypemethodx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypevar"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypevarx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypevr"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypevrx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defun"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defunx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defvar"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defvarx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defvr"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defvrx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
comment|/* The end of the `def' commands. */
block|{
literal|"detailmenu"
block|,
name|cm_detailmenu
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"dfn"
block|,
name|cm_dfn
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"dircategory"
block|,
name|cm_dircategory
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"direntry"
block|,
name|cm_direntry
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"display"
block|,
name|cm_display
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"dmn"
block|,
name|cm_no_op
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"dotaccent"
block|,
name|cm_accent
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"dotless"
block|,
name|cm_dotless
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"dots"
block|,
name|cm_dots
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"email"
block|,
name|cm_angle_brackets
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"emph"
block|,
name|cm_emph
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"end"
block|,
name|cm_end
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"enddots"
block|,
name|cm_enddots
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"enumerate"
block|,
name|cm_enumerate
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"equiv"
block|,
name|cm_equiv
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"error"
block|,
name|cm_error
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"example"
block|,
name|cm_example
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"exclamdown"
block|,
name|cm_special_char
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"exdent"
block|,
name|cm_exdent
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"expansion"
block|,
name|cm_expansion
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"file"
block|,
name|cm_code
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"finalout"
block|,
name|cm_no_op
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"findex"
block|,
name|cm_findex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"flushleft"
block|,
name|cm_flushleft
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"flushright"
block|,
name|cm_flushright
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"footnote"
block|,
name|cm_footnote
block|,
name|NO_BRACE_ARGS
block|}
block|,
comment|/* self-arg eater */
block|{
literal|"footnotestyle"
block|,
name|cm_footnotestyle
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"format"
block|,
name|cm_format
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ftable"
block|,
name|cm_ftable
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"group"
block|,
name|cm_group
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"heading"
block|,
name|cm_heading
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"headings"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"hyphenation"
block|,
name|cm_no_op
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"i"
block|,
name|cm_not_fixed_width
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"ifclear"
block|,
name|cm_ifclear
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ifeq"
block|,
name|cm_ifeq
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ifhtml"
block|,
name|command_name_condition
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ifinfo"
block|,
name|cm_ifinfo
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ifset"
block|,
name|cm_ifset
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iftex"
block|,
name|command_name_condition
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ignore"
block|,
name|command_name_condition
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"include"
block|,
name|cm_include
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"inforef"
block|,
name|cm_inforef
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"item"
block|,
name|cm_item
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"itemize"
block|,
name|cm_itemize
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"itemx"
block|,
name|cm_itemx
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"kbd"
block|,
name|cm_kbd
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"key"
block|,
name|cm_angle_brackets
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"kindex"
block|,
name|cm_kindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"l"
block|,
name|cm_special_char
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"lisp"
block|,
name|cm_lisp
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"lowersections"
block|,
name|cm_lowersections
block|,
name|NO_BRACE_ARGS
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
block|{
literal|"macro"
block|,
name|cm_macro
block|,
name|NO_BRACE_ARGS
block|}
block|,
endif|#
directive|endif
block|{
literal|"majorheading"
block|,
name|cm_majorheading
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"math"
block|,
name|cm_no_op
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"menu"
block|,
name|cm_menu
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"minus"
block|,
name|cm_minus
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"multitable"
block|,
name|cm_multitable
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"need"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"node"
block|,
name|cm_node
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"noindent"
block|,
name|cm_noindent
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"nwnode"
block|,
name|cm_node
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"o"
block|,
name|cm_special_char
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"oe"
block|,
name|insert_self
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"page"
block|,
name|cm_no_op
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"paragraphindent"
block|,
name|cm_paragraphindent
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"pindex"
block|,
name|cm_pindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"point"
block|,
name|cm_point
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"pounds"
block|,
name|cm_special_char
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"print"
block|,
name|cm_print
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"printindex"
block|,
name|cm_printindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"pxref"
block|,
name|cm_pxref
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"questiondown"
block|,
name|cm_special_char
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"quotation"
block|,
name|cm_quotation
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"r"
block|,
name|cm_not_fixed_width
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"raisesections"
block|,
name|cm_raisesections
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ref"
block|,
name|cm_xref
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"refill"
block|,
name|cm_no_op
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"result"
block|,
name|cm_result
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"ringaccent"
block|,
name|cm_accent
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"samp"
block|,
name|cm_code
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"sc"
block|,
name|cm_sc
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"section"
block|,
name|cm_section
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"set"
block|,
name|cm_set
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"setchapternewpage"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"setchapterstyle"
block|,
name|cm_obsolete
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"setfilename"
block|,
name|cm_setfilename
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"settitle"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"shortcontents"
block|,
name|cm_no_op
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"shorttitlepage"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"smallbook"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"smallexample"
block|,
name|cm_smallexample
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"smalllisp"
block|,
name|cm_smalllisp
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"sp"
block|,
name|cm_sp
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ss"
block|,
name|insert_self
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"strong"
block|,
name|cm_strong
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"subheading"
block|,
name|cm_subheading
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"subsection"
block|,
name|cm_subsection
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"subsubheading"
block|,
name|cm_subsubheading
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"subsubsection"
block|,
name|cm_subsubsection
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"summarycontents"
block|,
name|cm_no_op
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"syncodeindex"
block|,
name|cm_synindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"synindex"
block|,
name|cm_synindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"t"
block|,
name|cm_no_op
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"tab"
block|,
name|cm_tab
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"table"
block|,
name|cm_table
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"tex"
block|,
name|command_name_condition
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"tieaccent"
block|,
name|cm_accent
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"tindex"
block|,
name|cm_tindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"titlefont"
block|,
name|cm_not_fixed_width
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"titlepage"
block|,
name|command_name_condition
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"today"
block|,
name|cm_today
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"top"
block|,
name|cm_top
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"u"
block|,
name|cm_accent
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"ubaraccent"
block|,
name|cm_accent
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"udotaccent"
block|,
name|cm_accent
block|,
name|BRACE_ARGS
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
block|{
literal|"unmacro"
block|,
name|cm_unmacro
block|,
name|NO_BRACE_ARGS
block|}
block|,
endif|#
directive|endif
block|{
literal|"unnumbered"
block|,
name|cm_unnumbered
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"unnumberedsec"
block|,
name|cm_unnumberedsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"unnumberedsubsec"
block|,
name|cm_unnumberedsubsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"unnumberedsubsubsec"
block|,
name|cm_unnumberedsubsubsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"url"
block|,
name|cm_code
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"v"
block|,
name|cm_accent
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"value"
block|,
name|cm_value
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"var"
block|,
name|cm_var
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"vindex"
block|,
name|cm_vindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"vtable"
block|,
name|cm_vtable
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"w"
block|,
name|cm_w
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"xref"
block|,
name|cm_xref
block|,
name|BRACE_ARGS
block|}
block|,
comment|/* Deprecated commands.  These used to be for italics.  */
block|{
literal|"iappendix"
block|,
name|cm_ideprecated
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iappendixsec"
block|,
name|cm_ideprecated
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iappendixsection"
block|,
name|cm_ideprecated
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iappendixsubsec"
block|,
name|cm_ideprecated
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iappendixsubsubsec"
block|,
name|cm_ideprecated
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ichapter"
block|,
name|cm_ideprecated
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"isection"
block|,
name|cm_ideprecated
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"isubsection"
block|,
name|cm_ideprecated
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"isubsubsection"
block|,
name|cm_ideprecated
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iunnumbered"
block|,
name|cm_ideprecated
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iunnumberedsec"
block|,
name|cm_ideprecated
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iunnumberedsubsec"
block|,
name|cm_ideprecated
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iunnumberedsubsubsec"
block|,
name|cm_ideprecated
block|,
name|NO_BRACE_ARGS
block|}
block|,
comment|/* Now @include does what this was supposed to. */
block|{
literal|"infoinclude"
block|,
name|cm_obsolete
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"titlespec"
block|,
name|cm_obsolete
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|COMMAND_FUNCTION
operator|*
operator|)
name|NULL
block|}
block|,
name|NO_BRACE_ARGS
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"error-limit"
block|,
literal|1
block|,
literal|0
block|,
literal|'e'
block|}
block|,
comment|/* formerly -el */
block|{
literal|"fill-column"
block|,
literal|1
block|,
literal|0
block|,
literal|'f'
block|}
block|,
comment|/* formerly -fc */
block|{
literal|"footnote-style"
block|,
literal|1
block|,
literal|0
block|,
literal|'s'
block|}
block|,
comment|/* formerly -ft */
block|{
literal|"no-headers"
block|,
literal|0
block|,
operator|&
name|no_headers
block|,
literal|1
block|}
block|,
comment|/* Do not output Node: foo */
block|{
literal|"no-pointer-validate"
block|,
literal|0
block|,
operator|&
name|validating
block|,
literal|0
block|}
block|,
comment|/* formerly -nv */
block|{
literal|"no-validate"
block|,
literal|0
block|,
operator|&
name|validating
block|,
literal|0
block|}
block|,
comment|/* formerly -nv */
block|{
literal|"no-split"
block|,
literal|0
block|,
operator|&
name|splitting
block|,
literal|0
block|}
block|,
comment|/* formerly -ns */
block|{
literal|"no-warn"
block|,
literal|0
block|,
operator|&
name|print_warnings
block|,
literal|0
block|}
block|,
comment|/* formerly -nw */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
block|{
literal|"macro-expand"
block|,
literal|1
block|,
literal|0
block|,
literal|'E'
block|}
block|,
endif|#
directive|endif
comment|/* HAVE_MACROS */
block|{
literal|"number-footnotes"
block|,
literal|0
block|,
operator|&
name|number_footnotes
block|,
literal|1
block|}
block|,
block|{
literal|"no-number-footnotes"
block|,
literal|0
block|,
operator|&
name|number_footnotes
block|,
literal|0
block|}
block|,
block|{
literal|"output"
block|,
literal|1
block|,
literal|0
block|,
literal|'o'
block|}
block|,
block|{
literal|"paragraph-indent"
block|,
literal|1
block|,
literal|0
block|,
literal|'p'
block|}
block|,
comment|/* formerly -pi */
block|{
literal|"reference-limit"
block|,
literal|1
block|,
literal|0
block|,
literal|'r'
block|}
block|,
comment|/* formerly -rl */
block|{
literal|"verbose"
block|,
literal|0
block|,
operator|&
name|verbose_mode
block|,
literal|1
block|}
block|,
comment|/* formerly -verbose */
block|{
literal|"help"
block|,
literal|0
block|,
literal|0
block|,
literal|'h'
block|}
block|,
block|{
literal|"version"
block|,
literal|0
block|,
literal|0
block|,
literal|'V'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Values for calling handle_variable_internal (). */
end_comment

begin_define
define|#
directive|define
name|SET
value|1
end_define

begin_define
define|#
directive|define
name|CLEAR
value|2
end_define

begin_define
define|#
directive|define
name|IFSET
value|3
end_define

begin_define
define|#
directive|define
name|IFCLEAR
value|4
end_define

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Main ()  Start of code  		    */
end_comment

begin_comment
comment|/*					        		    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* For each file mentioned in the command line, process it, turning    Texinfo commands into wonderfully formatted output text. */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|extern
name|int
name|errors_printed
decl_stmt|;
name|char
modifier|*
name|filename_part
parameter_list|()
function_decl|;
name|int
name|c
decl_stmt|,
name|ind
decl_stmt|;
name|int
name|reading_from_stdin
init|=
literal|0
decl_stmt|;
comment|/* The name of this program is the last filename in argv[0]. */
name|progname
operator|=
name|filename_part
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Parse argument flags from the input line. */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
literal|"D:E:U:I:f:o:p:e:r:s:V"
argument_list|,
else|#
directive|else
literal|"D:U:I:f:o:p:e:r:s:V"
argument_list|,
endif|#
directive|endif
comment|/* !HAVE_MACROS */
name|long_options
argument_list|,
operator|&
name|ind
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|0
operator|&&
name|long_options
index|[
name|ind
index|]
operator|.
name|flag
operator|==
literal|0
condition|)
name|c
operator|=
name|long_options
index|[
name|ind
index|]
operator|.
name|val
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* User specified variable to set or clear? */
case|case
literal|'D'
case|:
case|case
literal|'U'
case|:
name|handle_variable_internal
argument_list|(
operator|(
name|c
operator|==
literal|'D'
operator|)
condition|?
name|SET
else|:
name|CLEAR
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
comment|/* Use specified a macro expansion output file? */
case|case
literal|'E'
case|:
if|if
condition|(
operator|!
name|macro_expansion_output_stream
condition|)
block|{
name|macro_expansion_output_stream
operator|=
name|fopen
argument_list|(
name|optarg
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|macro_expansion_output_stream
condition|)
name|error
argument_list|(
literal|"Couldn't open macro expansion output \"%s\""
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Cannot specify more than one macro expansion output"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* HAVE_MACROS */
comment|/* User specified include file path? */
case|case
literal|'I'
case|:
if|if
condition|(
operator|!
name|include_files_path
condition|)
name|include_files_path
operator|=
name|strdup
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|include_files_path
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|include_files_path
argument_list|,
literal|2
operator|+
name|strlen
argument_list|(
name|include_files_path
argument_list|)
operator|+
name|strlen
argument_list|(
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|include_files_path
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|include_files_path
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
comment|/* User specified fill_column? */
case|case
literal|'f'
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|fill_column
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: --fill-column arg must be numeric, not `%s'.\n"
argument_list|,
name|progname
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|FATAL
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* User specified output file? */
case|case
literal|'o'
case|:
name|command_output_filename
operator|=
name|strdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
comment|/* User specified paragraph indent (paragraph_start_index)? */
case|case
literal|'p'
case|:
if|if
condition|(
name|set_paragraph_indent
argument_list|(
name|optarg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: --paragraph-indent arg must be numeric/none/asis, not `%s'.\n"
argument_list|,
name|progname
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|FATAL
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* User specified error level? */
case|case
literal|'e'
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|max_error_level
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: --error-limit arg must be numeric, not `%s'.\n"
argument_list|,
name|progname
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
block|}
name|usage
argument_list|(
name|stderr
argument_list|,
name|FATAL
argument_list|)
expr_stmt|;
break|break;
comment|/* User specified reference warning limit? */
case|case
literal|'r'
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|reference_warning_limit
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: --reference-limit arg must be numeric, not `%s'.\n"
argument_list|,
name|progname
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|FATAL
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* User specified footnote style? */
case|case
literal|'s'
case|:
if|if
condition|(
name|set_footnote_style
argument_list|(
name|optarg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: --footnote-style arg must be `separate' or `end', not `%s'.\n"
argument_list|,
name|progname
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|FATAL
argument_list|)
expr_stmt|;
block|}
name|footnote_style_preset
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|usage
argument_list|(
name|NO_ERROR
argument_list|)
expr_stmt|;
break|break;
comment|/* User requested version info? */
case|case
literal|'V'
case|:
name|print_version_info
argument_list|()
expr_stmt|;
name|puts
argument_list|(
literal|"Copyright (C) 1996 Free Software Foundation, Inc.\n\ There is NO warranty.  You may redistribute this software\n\ under the terms of the GNU General Public License.\n\ For more information about these matters, see the files named COPYING."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|NO_ERROR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|usage
argument_list|(
name|FATAL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
block|{
comment|/* Check to see if input is a file.  If so, process that. */
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
name|reading_from_stdin
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: missing file argument.\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|FATAL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the user has specified --no-headers, this should imply --no-split.      Do that here.  I think it might also imply that we should ignore the      setfilename at the top of the file, but this might break some FSF things,      so I will hold off on that. */
if|if
condition|(
name|no_headers
condition|)
block|{
name|splitting
operator|=
literal|0
expr_stmt|;
comment|/* If the user has not specified an output file, then use stdout by 	 default. */
if|if
condition|(
operator|!
name|command_output_filename
condition|)
name|command_output_filename
operator|=
name|strdup
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose_mode
condition|)
name|print_version_info
argument_list|()
expr_stmt|;
comment|/* Remaining arguments are file names of texinfo files.      Convert them, one by one. */
if|if
condition|(
operator|!
name|reading_from_stdin
condition|)
block|{
while|while
condition|(
name|optind
operator|!=
name|argc
condition|)
name|convert_from_file
argument_list|(
name|argv
index|[
name|optind
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|convert_from_stream
argument_list|(
name|stdin
argument_list|,
literal|"stdin"
argument_list|)
expr_stmt|;
if|if
condition|(
name|errors_printed
condition|)
return|return
operator|(
name|SYNTAX
operator|)
return|;
else|else
return|return
operator|(
name|NO_ERROR
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Display the version info of this invocation of Makeinfo. */
end_comment

begin_function
name|void
name|print_version_info
parameter_list|()
block|{
name|printf
argument_list|(
literal|"GNU Makeinfo (Texinfo 3.9) %d.%d\n"
argument_list|,
name|major_version
argument_list|,
name|minor_version
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Generic Utilities			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|memory_error
parameter_list|(
name|callers_name
parameter_list|,
name|bytes_wanted
parameter_list|)
name|char
modifier|*
name|callers_name
decl_stmt|;
name|int
name|bytes_wanted
decl_stmt|;
block|{
name|char
name|printable_string
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|printable_string
argument_list|,
literal|"Virtual memory exhausted in %s ()!  Needed %d bytes."
argument_list|,
name|callers_name
argument_list|,
name|bytes_wanted
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|printable_string
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Just like malloc, but kills the program in case of fatal error. */
end_comment

begin_function
name|void
modifier|*
name|xmalloc
parameter_list|(
name|nbytes
parameter_list|)
name|unsigned
name|int
name|nbytes
decl_stmt|;
block|{
name|void
modifier|*
name|temp
init|=
operator|(
name|void
operator|*
operator|)
name|malloc
argument_list|(
name|nbytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|nbytes
operator|&&
name|temp
operator|==
operator|(
name|void
operator|*
operator|)
name|NULL
condition|)
name|memory_error
argument_list|(
literal|"xmalloc"
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like realloc (), but barfs if there isn't enough memory. */
end_comment

begin_function
name|void
modifier|*
name|xrealloc
parameter_list|(
name|pointer
parameter_list|,
name|nbytes
parameter_list|)
name|void
modifier|*
name|pointer
decl_stmt|;
name|unsigned
name|int
name|nbytes
decl_stmt|;
block|{
name|void
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|pointer
condition|)
name|temp
operator|=
operator|(
name|void
operator|*
operator|)
name|xmalloc
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
operator|(
name|void
operator|*
operator|)
name|realloc
argument_list|(
name|pointer
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|&&
operator|!
name|temp
condition|)
name|memory_error
argument_list|(
literal|"xrealloc"
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If EXIT_VALUE is zero, print the full usage message to stdout.    Otherwise, just say to use --help for more info.    Then exit with EXIT_VALUE. */
end_comment

begin_function
name|void
name|usage
parameter_list|(
name|exit_value
parameter_list|)
name|int
name|exit_value
decl_stmt|;
block|{
if|if
condition|(
name|exit_value
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Try `%s --help' for more information.\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Usage: %s [OPTION]... TEXINFO-FILE...\n\ \n\ Translate Texinfo source documentation to a format suitable for reading\n\ with GNU Info.\n\ \n\ Options:\n\ -D VAR                 define a variable, as with @set.\n\ -E MACRO-OFILE	       process macros only, output texinfo source.\n\ -I DIR                 add DIR to the directory search list for @include.\n\ -U VAR                 undefine a variable, as with @clear.\n\ --error-limit NUM      quit after NUM errors (default %d).\n\ --fill-column NUM      break lines at NUM characters (default %d).\n\ --footnote-style STYLE output footnotes according to STYLE:\n\                          `separate' to place footnotes in their own node,\n\                          `end' to place the footnotes at the end of\n\                          the node in which they are defined (the default).\n\ --help                 display this help and exit.\n\ --no-validate          suppress node cross-reference validation.\n\ --no-warn              suppress warnings (but not errors).\n\ --no-split             suppress splitting of large files.\n\ --no-headers           suppress node separators and Node: Foo headers.\n\ --output FILE, -o FILE output to FILE, and ignore any @setfilename.\n\ --paragraph-indent NUM indent paragraphs with NUM spaces (default %d).\n\ --reference-limit NUM  complain about at most NUM references (default %d).\n\ --verbose              report about what is being done.\n\ --version              display version information and exit.\n\ \n\ Email bug reports to bug-texinfo@prep.ai.mit.edu.\n\ "
argument_list|,
name|progname
argument_list|,
name|paragraph_start_indent
argument_list|,
name|fill_column
argument_list|,
name|max_error_level
argument_list|,
name|reference_warning_limit
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Manipulating Lists */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|generic_list
block|{
name|struct
name|generic_list
modifier|*
name|next
decl_stmt|;
block|}
name|GENERIC_LIST
typedef|;
end_typedef

begin_comment
comment|/* Reverse the chain of structures in LIST.  Output the new head    of the chain.  You should always assign the output value of this    function to something, or you will lose the chain. */
end_comment

begin_function
name|GENERIC_LIST
modifier|*
name|reverse_list
parameter_list|(
name|list
parameter_list|)
specifier|register
name|GENERIC_LIST
modifier|*
name|list
decl_stmt|;
block|{
specifier|register
name|GENERIC_LIST
modifier|*
name|next
decl_stmt|;
specifier|register
name|GENERIC_LIST
modifier|*
name|prev
init|=
operator|(
name|GENERIC_LIST
operator|*
operator|)
name|NULL
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|next
operator|=
name|list
operator|->
name|next
expr_stmt|;
name|list
operator|->
name|next
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|next
expr_stmt|;
block|}
return|return
operator|(
name|prev
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Pushing and Popping Files */
end_comment

begin_comment
comment|/* Find and load the file named FILENAME.  Return a pointer to    the loaded file, or NULL if it can't be loaded. */
end_comment

begin_function
name|char
modifier|*
name|find_and_load
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|struct
name|stat
name|fileinfo
decl_stmt|;
name|long
name|file_size
decl_stmt|;
name|int
name|file
init|=
operator|-
literal|1
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|fullpath
decl_stmt|,
modifier|*
name|result
decl_stmt|,
modifier|*
name|get_file_info_in_path
argument_list|()
decl_stmt|;
name|result
operator|=
name|fullpath
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|fullpath
operator|=
name|get_file_info_in_path
argument_list|(
name|filename
argument_list|,
name|include_files_path
argument_list|,
operator|&
name|fileinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fullpath
condition|)
goto|goto
name|error_exit
goto|;
name|filename
operator|=
name|fullpath
expr_stmt|;
name|file_size
operator|=
operator|(
name|long
operator|)
name|fileinfo
operator|.
name|st_size
expr_stmt|;
name|file
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|<
literal|0
condition|)
goto|goto
name|error_exit
goto|;
comment|/* Load the file. */
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|file_size
argument_list|)
expr_stmt|;
comment|/* VMS stat lies about the st_size value.  The actual number of      readable bytes is always less than this value.  The arcane      mysteries of VMS/RMS are too much to probe, so this hack     suffices to make things work. */
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|file
argument_list|,
name|result
operator|+
name|count
argument_list|,
name|file_size
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|count
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
else|#
directive|else
comment|/* !VMS */
name|count
operator|=
name|file_size
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|file
argument_list|,
name|result
argument_list|,
name|file_size
argument_list|)
operator|!=
name|file_size
condition|)
endif|#
directive|endif
comment|/* !VMS */
name|error_exit
label|:
block|{
if|if
condition|(
name|result
condition|)
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullpath
condition|)
name|free
argument_list|(
name|fullpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* Set the globals to the new file. */
name|input_text
operator|=
name|result
expr_stmt|;
name|size_of_input_text
operator|=
name|count
expr_stmt|;
name|input_filename
operator|=
name|fullpath
expr_stmt|;
name|node_filename
operator|=
name|strdup
argument_list|(
name|fullpath
argument_list|)
expr_stmt|;
name|input_text_offset
operator|=
literal|0
expr_stmt|;
name|line_number
operator|=
literal|1
expr_stmt|;
comment|/* Not strictly necessary.  This magic prevents read_token () from doing      extra unnecessary work each time it is called (that is a lot of times).      The SIZE_OF_INPUT_TEXT is one past the actual end of the text. */
name|input_text
index|[
name|size_of_input_text
index|]
operator|=
literal|'\n'
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Save the state of the current input file. */
end_comment

begin_function
name|void
name|pushfile
parameter_list|()
block|{
name|FSTACK
modifier|*
name|newstack
init|=
operator|(
name|FSTACK
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FSTACK
argument_list|)
argument_list|)
decl_stmt|;
name|newstack
operator|->
name|filename
operator|=
name|input_filename
expr_stmt|;
name|newstack
operator|->
name|text
operator|=
name|input_text
expr_stmt|;
name|newstack
operator|->
name|size
operator|=
name|size_of_input_text
expr_stmt|;
name|newstack
operator|->
name|offset
operator|=
name|input_text_offset
expr_stmt|;
name|newstack
operator|->
name|line_number
operator|=
name|line_number
expr_stmt|;
name|newstack
operator|->
name|next
operator|=
name|filestack
expr_stmt|;
name|filestack
operator|=
name|newstack
expr_stmt|;
name|push_node_filename
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make the current file globals be what is on top of the file stack. */
end_comment

begin_function
name|void
name|popfile
parameter_list|()
block|{
name|FSTACK
modifier|*
name|tos
init|=
name|filestack
decl_stmt|;
if|if
condition|(
operator|!
name|tos
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* My fault.  I wonder what I did? */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
if|if
condition|(
name|macro_expansion_output_stream
condition|)
block|{
name|maybe_write_itext
argument_list|(
name|input_text
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
name|forget_itext
argument_list|(
name|input_text
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_MACROS */
comment|/* Pop the stack. */
name|filestack
operator|=
name|filestack
operator|->
name|next
expr_stmt|;
comment|/* Make sure that commands with braces have been satisfied. */
if|if
condition|(
operator|!
name|executing_string
condition|)
name|discard_braces
argument_list|()
expr_stmt|;
comment|/* Get the top of the stack into the globals. */
name|input_filename
operator|=
name|tos
operator|->
name|filename
expr_stmt|;
name|input_text
operator|=
name|tos
operator|->
name|text
expr_stmt|;
name|size_of_input_text
operator|=
name|tos
operator|->
name|size
expr_stmt|;
name|input_text_offset
operator|=
name|tos
operator|->
name|offset
expr_stmt|;
name|line_number
operator|=
name|tos
operator|->
name|line_number
expr_stmt|;
name|free
argument_list|(
name|tos
argument_list|)
expr_stmt|;
comment|/* Go back to the (now) current node. */
name|pop_node_filename
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flush all open files on the file stack. */
end_comment

begin_function
name|void
name|flush_file_stack
parameter_list|()
block|{
while|while
condition|(
name|filestack
condition|)
block|{
name|char
modifier|*
name|fname
init|=
name|input_filename
decl_stmt|;
name|char
modifier|*
name|text
init|=
name|input_text
decl_stmt|;
name|popfile
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|int
name|node_filename_stack_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|node_filename_stack_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|node_filename_stack
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|push_node_filename
parameter_list|()
block|{
if|if
condition|(
name|node_filename_stack_index
operator|+
literal|1
operator|>
name|node_filename_stack_size
condition|)
name|node_filename_stack
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|node_filename_stack
argument_list|,
operator|(
name|node_filename_stack_size
operator|+=
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|node_filename_stack
index|[
name|node_filename_stack_index
index|]
operator|=
name|node_filename
expr_stmt|;
name|node_filename_stack_index
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_node_filename
parameter_list|()
block|{
name|node_filename
operator|=
name|node_filename_stack
index|[
operator|--
name|node_filename_stack_index
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return just the simple part of the filename; i.e. the    filename without the path information, or extensions.    This conses up a new string. */
end_comment

begin_function
name|char
modifier|*
name|filename_part
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|basename
decl_stmt|;
name|basename
operator|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|basename
condition|)
name|basename
operator|=
name|filename
expr_stmt|;
else|else
name|basename
operator|++
expr_stmt|;
name|basename
operator|=
name|strdup
argument_list|(
name|basename
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|REMOVE_OUTPUT_EXTENSIONS
argument_list|)
comment|/* See if there is an extension to remove.  If so, remove it. */
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|strrchr
argument_list|(
name|basename
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
operator|*
name|temp
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* REMOVE_OUTPUT_EXTENSIONS */
return|return
operator|(
name|basename
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the pathname part of filename.  This can be NULL. */
end_comment

begin_function
name|char
modifier|*
name|pathname_part
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|expand_filename
parameter_list|()
function_decl|;
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|filename
operator|=
name|expand_filename
argument_list|(
name|filename
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|&&
name|filename
index|[
name|i
index|]
operator|!=
literal|'/'
condition|)
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|filename
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|i
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|result
argument_list|,
name|filename
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|result
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|filename_non_directory
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
literal|1
init|;
name|i
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|name
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
return|return
operator|(
name|strdup
argument_list|(
name|name
operator|+
name|i
operator|+
literal|1
argument_list|)
operator|)
return|;
return|return
operator|(
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the expansion of FILENAME. */
end_comment

begin_function
name|char
modifier|*
name|expand_filename
parameter_list|(
name|filename
parameter_list|,
name|input_name
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|,
decl|*
name|input_name
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|full_pathname
parameter_list|()
function_decl|;
if|if
condition|(
name|filename
condition|)
name|filename
operator|=
name|full_pathname
argument_list|(
name|filename
argument_list|)
expr_stmt|;
else|else
block|{
name|filename
operator|=
name|filename_non_directory
argument_list|(
name|input_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|filename
condition|)
block|{
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|filename
operator|=
name|strdup
argument_list|(
literal|"noname.texi"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
operator|-
literal|1
init|;
name|i
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|filename
index|[
name|i
index|]
operator|==
literal|'.'
condition|)
break|break;
if|if
condition|(
operator|!
name|i
condition|)
name|i
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|6
operator|>
operator|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|)
condition|)
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|filename
argument_list|,
name|i
operator|+
literal|6
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|filename
operator|+
name|i
argument_list|,
literal|".info"
argument_list|)
expr_stmt|;
return|return
operator|(
name|filename
operator|)
return|;
block|}
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|==
literal|'.'
operator|||
name|filename
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
return|return
operator|(
name|filename
operator|)
return|;
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|&&
name|input_name
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* Make it so that relative names work. */
name|char
modifier|*
name|result
decl_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|input_name
argument_list|)
operator|-
literal|1
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|input_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|input_name
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
index|[
name|i
index|]
operator|!=
literal|'/'
operator|&&
name|i
condition|)
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|result
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
name|i
operator|++
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|result
index|[
name|i
index|]
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
return|return
operator|(
name|filename
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Return the full path to FILENAME. */
end_comment

begin_function
name|char
modifier|*
name|full_pathname
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|initial_character
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
comment|/* No filename given? */
if|if
condition|(
operator|!
name|filename
operator|||
operator|!
operator|(
name|initial_character
operator|=
operator|*
name|filename
operator|)
condition|)
return|return
operator|(
name|strdup
argument_list|(
literal|""
argument_list|)
operator|)
return|;
comment|/* Already absolute? */
if|if
condition|(
operator|(
name|initial_character
operator|==
literal|'/'
operator|)
operator|||
operator|(
operator|(
name|strncmp
argument_list|(
name|filename
argument_list|,
literal|"./"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|filename
argument_list|,
literal|"../"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
operator|(
name|strdup
argument_list|(
name|filename
argument_list|)
operator|)
return|;
if|if
condition|(
name|initial_character
operator|!=
literal|'~'
condition|)
block|{
name|char
modifier|*
name|localdir
decl_stmt|;
name|localdir
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1025
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GETCWD
argument_list|)
if|if
condition|(
operator|!
name|getcwd
argument_list|(
name|localdir
argument_list|,
literal|1024
argument_list|)
condition|)
else|#
directive|else
comment|/*  !HAVE_GETCWD */
if|if
condition|(
operator|!
name|getwd
argument_list|(
name|localdir
argument_list|)
condition|)
endif|#
directive|endif
comment|/* !HAVE_GETCWD */
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: getwd: %s, %s\n"
argument_list|,
name|progname
argument_list|,
name|filename
argument_list|,
name|localdir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|localdir
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|localdir
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|result
operator|=
name|strdup
argument_list|(
name|localdir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|localdir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|filename
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* Return the concatenation of the environment variable HOME 	     and the rest of the string. */
name|char
modifier|*
name|temp_home
decl_stmt|;
name|temp_home
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
operator|&
name|filename
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
operator|+
name|temp_home
condition|?
name|strlen
argument_list|(
name|temp_home
argument_list|)
else|:
literal|0
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|temp_home
condition|)
name|strcpy
argument_list|(
name|result
argument_list|,
name|temp_home
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|result
argument_list|,
operator|&
name|filename
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|passwd
modifier|*
name|user_entry
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|char
modifier|*
name|username
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|257
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|c
operator|=
name|filename
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
break|break;
else|else
name|username
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|c
condition|)
name|username
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|user_entry
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|user_entry
condition|)
return|return
operator|(
name|strdup
argument_list|(
name|filename
argument_list|)
operator|)
return|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|user_entry
operator|->
name|pw_dir
argument_list|)
operator|+
name|strlen
argument_list|(
operator|&
name|filename
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|user_entry
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|result
argument_list|,
operator|&
name|filename
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|output_name_from_input_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
operator|(
name|expand_filename
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Error Handling				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Number of errors encountered. */
end_comment

begin_decl_stmt
name|int
name|errors_printed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print the last error gotten from the file system. */
end_comment

begin_function
name|int
name|fs_error
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|remember_error
argument_list|()
expr_stmt|;
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Print an error message, and return false. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_VARARGS_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_VFPRINTF
argument_list|)
end_if

begin_function
name|int
name|error
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|remember_error
argument_list|()
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Just like error (), but print the line number as well. */
end_comment

begin_function
name|int
name|line_error
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|remember_error
argument_list|()
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|input_filename
argument_list|,
name|line_number
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|warning
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_warnings
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: Warning: "
argument_list|,
name|input_filename
argument_list|,
name|line_number
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !(HAVE_VARARGS_H&& HAVE_VFPRINTF) */
end_comment

begin_function
name|int
name|error
parameter_list|(
name|format
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|,
name|arg4
parameter_list|,
name|arg5
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
block|{
name|remember_error
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Just like error (), but print the line number as well. */
end_comment

begin_function
name|int
name|line_error
parameter_list|(
name|format
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|,
name|arg4
parameter_list|,
name|arg5
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
block|{
name|remember_error
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|input_filename
argument_list|,
name|line_number
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|warning
parameter_list|(
name|format
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|,
name|arg4
parameter_list|,
name|arg5
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
block|{
if|if
condition|(
name|print_warnings
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: Warning: "
argument_list|,
name|input_filename
argument_list|,
name|line_number
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|int
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !(HAVE_VARARGS_H&& HAVE_VFPRINTF) */
end_comment

begin_comment
comment|/* Remember that an error has been printed.  If this is the first    error printed, then tell them which program is printing them.    If more than max_error_level have been printed, then exit the    program. */
end_comment

begin_function
name|void
name|remember_error
parameter_list|()
block|{
name|errors_printed
operator|++
expr_stmt|;
if|if
condition|(
name|max_error_level
operator|&&
operator|(
name|errors_printed
operator|>
name|max_error_level
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many errors!  Gave up.\n"
argument_list|)
expr_stmt|;
name|flush_file_stack
argument_list|()
expr_stmt|;
name|cm_bye
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Hacking Tokens and Strings		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Return the next token as a string pointer.  We cons the string. */
end_comment

begin_function
name|char
modifier|*
name|read_token
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|character
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
comment|/* If the first character to be read is self-delimiting, then that      is the command itself. */
name|character
operator|=
name|curchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|self_delimiting
argument_list|(
name|character
argument_list|)
condition|)
block|{
name|input_text_offset
operator|++
expr_stmt|;
if|if
condition|(
name|character
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
name|result
operator|=
name|strdup
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|character
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|input_text_offset
operator|!=
name|size_of_input_text
operator|)
operator|&&
operator|(
name|character
operator|=
name|curchar
argument_list|()
operator|)
operator|&&
name|command_char
argument_list|(
name|character
argument_list|)
operator|)
condition|;
name|i
operator|++
operator|,
name|input_text_offset
operator|++
control|)
empty_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|result
argument_list|,
operator|&
name|input_text
index|[
name|input_text_offset
operator|-
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|result
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if CHARACTER is self-delimiting. */
end_comment

begin_function
name|int
name|self_delimiting
parameter_list|(
name|character
parameter_list|)
name|int
name|character
decl_stmt|;
block|{
comment|/* @; and @\ are not Texinfo commands, but they are listed here      anyway.  I don't know why.  --karl, 10aug96.  */
return|return
name|member
argument_list|(
name|character
argument_list|,
literal|"~{|}`^\\@?=;:.-,*\'\" !\n\t"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Clear whitespace from the front and end of string. */
end_comment

begin_function
name|void
name|canon_white
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|x
decl_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
return|return;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|len
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|cr_or_whitespace
argument_list|(
name|string
index|[
name|x
index|]
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|string
argument_list|,
name|string
operator|+
name|x
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|len
operator|--
expr_stmt|;
while|while
condition|(
name|len
operator|>
operator|-
literal|1
operator|&&
name|cr_or_whitespace
argument_list|(
name|string
index|[
name|len
index|]
argument_list|)
condition|)
name|len
operator|--
expr_stmt|;
name|string
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Bash STRING, replacing all whitespace with just one space. */
end_comment

begin_function
name|void
name|fix_whitespace
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|string_index
init|=
literal|0
decl_stmt|;
name|int
name|temp_index
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|canon_white
argument_list|(
name|string
argument_list|)
expr_stmt|;
while|while
condition|(
name|string
index|[
name|string_index
index|]
condition|)
block|{
name|c
operator|=
name|temp
index|[
name|temp_index
operator|++
index|]
operator|=
name|string
index|[
name|string_index
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
block|{
name|temp
index|[
name|temp_index
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|string
index|[
name|string_index
index|]
operator|)
operator|&&
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
name|string_index
operator|++
expr_stmt|;
block|}
block|}
name|temp
index|[
name|temp_index
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|string
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Discard text until the desired string is found.  The string is    included in the discarded text. */
end_comment

begin_function
name|void
name|discard_until
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|int
name|temp
init|=
name|search_forward
argument_list|(
name|string
argument_list|,
name|input_text_offset
argument_list|)
decl_stmt|;
name|int
name|tt
init|=
operator|(
name|temp
operator|<
literal|0
operator|)
condition|?
name|size_of_input_text
else|:
name|temp
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|from
init|=
name|input_text_offset
decl_stmt|;
comment|/* Find out what line we are on. */
while|while
condition|(
name|from
operator|!=
name|tt
condition|)
if|if
condition|(
name|input_text
index|[
name|from
operator|++
index|]
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|input_text_offset
operator|=
name|size_of_input_text
operator|-
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"\n"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|line_error
argument_list|(
literal|"Expected `%s'"
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|input_text_offset
operator|=
name|temp
expr_stmt|;
name|input_text_offset
operator|+=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read characters from the file until we are at MATCH.    Place the characters read into STRING.    On exit input_text_offset is after the match string.    Return the offset where the string starts. */
end_comment

begin_function
name|int
name|get_until
parameter_list|(
name|match
parameter_list|,
name|string
parameter_list|)
name|char
modifier|*
name|match
decl_stmt|,
decl|*
modifier|*
name|string
decl_stmt|;
end_function

begin_block
block|{
name|int
name|len
decl_stmt|,
name|current_point
decl_stmt|,
name|x
decl_stmt|,
name|new_point
decl_stmt|,
name|tem
decl_stmt|;
name|current_point
operator|=
name|x
operator|=
name|input_text_offset
expr_stmt|;
name|new_point
operator|=
name|search_forward
argument_list|(
name|match
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_point
operator|<
literal|0
condition|)
name|new_point
operator|=
name|size_of_input_text
expr_stmt|;
name|len
operator|=
name|new_point
operator|-
name|current_point
expr_stmt|;
comment|/* Keep track of which line number we are at. */
name|tem
operator|=
name|new_point
operator|+
operator|(
name|strlen
argument_list|(
name|match
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|x
operator|!=
name|tem
condition|)
if|if
condition|(
name|input_text
index|[
name|x
operator|++
index|]
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
operator|*
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|string
argument_list|,
operator|&
name|input_text
index|[
name|current_point
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
operator|*
name|string
operator|)
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Now leave input_text_offset in a consistent state. */
name|input_text_offset
operator|=
name|tem
expr_stmt|;
if|if
condition|(
name|input_text_offset
operator|>
name|size_of_input_text
condition|)
name|input_text_offset
operator|=
name|size_of_input_text
expr_stmt|;
return|return
operator|(
name|new_point
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Read characters from the file until we are at MATCH or end of line.    Place the characters read into STRING.  */
end_comment

begin_function
name|void
name|get_until_in_line
parameter_list|(
name|match
parameter_list|,
name|string
parameter_list|)
name|char
modifier|*
name|match
decl_stmt|,
decl|*
modifier|*
name|string
decl_stmt|;
end_function

begin_block
block|{
name|int
name|real_bottom
decl_stmt|,
name|temp
decl_stmt|;
name|real_bottom
operator|=
name|size_of_input_text
expr_stmt|;
name|temp
operator|=
name|search_forward
argument_list|(
literal|"\n"
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
name|temp
operator|=
name|size_of_input_text
expr_stmt|;
name|size_of_input_text
operator|=
name|temp
expr_stmt|;
name|get_until
argument_list|(
name|match
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|size_of_input_text
operator|=
name|real_bottom
expr_stmt|;
block|}
end_block

begin_function
name|void
name|get_rest_of_line
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
modifier|*
name|string
decl_stmt|;
block|{
name|get_until
argument_list|(
literal|"\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|canon_white
argument_list|(
operator|*
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|'\n'
condition|)
comment|/* as opposed to the end of the file... */
block|{
name|line_number
operator|++
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Backup the input pointer to the previous character, keeping track    of the current line number. */
end_comment

begin_function
name|void
name|backup_input_pointer
parameter_list|()
block|{
if|if
condition|(
name|input_text_offset
condition|)
block|{
name|input_text_offset
operator|--
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|'\n'
condition|)
name|line_number
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read characters from the file until we are at MATCH or closing brace.    Place the characters read into STRING.  */
end_comment

begin_function
name|void
name|get_until_in_braces
parameter_list|(
name|match
parameter_list|,
name|string
parameter_list|)
name|char
modifier|*
name|match
decl_stmt|,
decl|*
modifier|*
name|string
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|,
name|brace
init|=
literal|0
decl_stmt|;
name|int
name|match_len
init|=
name|strlen
argument_list|(
name|match
argument_list|)
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|i
operator|=
name|input_text_offset
init|;
name|i
operator|<
name|size_of_input_text
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|input_text
index|[
name|i
index|]
operator|==
literal|'{'
condition|)
name|brace
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|input_text
index|[
name|i
index|]
operator|==
literal|'}'
condition|)
name|brace
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|input_text
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
if|if
condition|(
name|brace
operator|<
literal|0
operator|||
operator|(
name|brace
operator|==
literal|0
operator|&&
name|strncmp
argument_list|(
name|input_text
operator|+
name|i
argument_list|,
name|match
argument_list|,
name|match_len
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
name|match_len
operator|=
name|i
operator|-
name|input_text_offset
expr_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|+
name|match_len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|temp
argument_list|,
name|input_text
operator|+
name|input_text_offset
argument_list|,
name|match_len
argument_list|)
expr_stmt|;
name|temp
index|[
name|match_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|input_text_offset
operator|=
name|i
expr_stmt|;
operator|*
name|string
operator|=
name|temp
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Converting the File     		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Convert the file named by NAME.  The output is saved on the file    named as the argument to the @setfilename command. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|suffixes
index|[]
init|=
block|{
literal|".texinfo"
block|,
literal|".texi"
block|,
literal|".txinfo"
block|,
literal|""
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|initialize_conversion
parameter_list|()
block|{
name|init_tag_table
argument_list|()
expr_stmt|;
name|init_indices
argument_list|()
expr_stmt|;
name|init_internals
argument_list|()
expr_stmt|;
name|init_paragraph
argument_list|()
expr_stmt|;
comment|/* This is used for splitting the output file and for doing section      headings.  It was previously initialized in `init_paragraph', but its      use there loses with the `init_paragraph' calls done by the      multitable code; the tag indices get reset to zero.  */
name|output_position
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We read in multiples of 4k, simply because it is a typical pipe size    on unix systems. */
end_comment

begin_define
define|#
directive|define
name|READ_BUFFER_GROWTH
value|(4 * 4096)
end_define

begin_comment
comment|/* Convert the texinfo file coming from the open stream STREAM.  Assume the    source of the stream is named NAME. */
end_comment

begin_function
name|void
name|convert_from_stream
parameter_list|(
name|stream
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|buffer
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|buffer_offset
init|=
literal|0
decl_stmt|,
name|buffer_size
init|=
literal|0
decl_stmt|;
name|initialize_conversion
argument_list|()
expr_stmt|;
comment|/* Read until the end of the stream.  This isn't strictly correct, since      the texinfo input may end before the stream ends, but it is a quick      working hueristic. */
while|while
condition|(
operator|!
name|feof
argument_list|(
name|stream
argument_list|)
condition|)
block|{
name|int
name|count
decl_stmt|;
if|if
condition|(
name|buffer_offset
operator|+
operator|(
name|READ_BUFFER_GROWTH
operator|+
literal|1
operator|)
operator|>=
name|buffer_size
condition|)
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buffer
argument_list|,
operator|(
name|buffer_size
operator|+=
name|READ_BUFFER_GROWTH
operator|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|fread
argument_list|(
name|buffer
operator|+
name|buffer_offset
argument_list|,
literal|1
argument_list|,
name|READ_BUFFER_GROWTH
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL
argument_list|)
expr_stmt|;
block|}
name|buffer_offset
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* Set the globals to the new file. */
name|input_text
operator|=
name|buffer
expr_stmt|;
name|size_of_input_text
operator|=
name|buffer_offset
expr_stmt|;
name|input_filename
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|node_filename
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|input_text_offset
operator|=
literal|0
expr_stmt|;
name|line_number
operator|=
literal|1
expr_stmt|;
comment|/* Not strictly necessary.  This magic prevents read_token () from doing      extra unnecessary work each time it is called (that is a lot of times).      The SIZE_OF_INPUT_TEXT is one past the actual end of the text. */
name|input_text
index|[
name|size_of_input_text
index|]
operator|=
literal|'\n'
expr_stmt|;
name|convert_from_loaded_file
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|convert_from_file
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|filename
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|50
argument_list|)
decl_stmt|;
name|initialize_conversion
argument_list|()
expr_stmt|;
comment|/* Try to load the file specified by NAME, concatenated with our      various suffixes.  Prefer files like `makeinfo.texi' to      `makeinfo'.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|suffixes
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|strcpy
argument_list|(
name|filename
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|filename
argument_list|,
name|suffixes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_and_load
argument_list|(
name|filename
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|suffixes
index|[
name|i
index|]
index|[
literal|0
index|]
operator|&&
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'.'
argument_list|)
condition|)
block|{
name|fs_error
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|suffixes
index|[
name|i
index|]
condition|)
block|{
name|fs_error
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
name|input_filename
operator|=
name|filename
expr_stmt|;
name|convert_from_loaded_file
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|convert_from_loaded_file
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|expand_filename
argument_list|()
decl_stmt|,
modifier|*
name|filename_part
argument_list|()
decl_stmt|;
name|char
modifier|*
name|real_output_filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
name|remember_itext
argument_list|(
name|input_text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MACROS */
comment|/* Search this file looking for the special string which starts conversion.      Once found, we may truly begin. */
name|input_text_offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|input_text_offset
operator|>=
literal|0
condition|)
block|{
name|input_text_offset
operator|=
name|search_forward
argument_list|(
name|setfilename_search
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|input_text_offset
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|input_text_offset
operator|>
literal|0
operator|)
operator|&&
operator|(
name|input_text
index|[
name|input_text_offset
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
operator|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|input_text_offset
operator|>
literal|0
condition|)
name|input_text_offset
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|input_text_offset
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|command_output_filename
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|REQUIRE_SETFILENAME
argument_list|)
name|error
argument_list|(
literal|"No `%s' found in `%s'"
argument_list|,
name|setfilename_search
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|finished
goto|;
else|#
directive|else
specifier|register
name|int
name|i
decl_stmt|,
name|end_of_first_line
decl_stmt|;
comment|/* Find the end of the first line in the file. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size_of_input_text
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|input_text
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
break|break;
name|end_of_first_line
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|input_text_offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|end_of_first_line
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|input_text
index|[
name|i
index|]
operator|==
literal|'\\'
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|input_text
operator|+
name|i
operator|+
literal|1
argument_list|,
literal|"include"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|input_text_offset
operator|=
name|end_of_first_line
expr_stmt|;
break|break;
block|}
block|}
name|command_output_filename
operator|=
name|output_name_from_input_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !REQUIRE_SETFILENAME */
block|}
block|}
else|else
name|input_text_offset
operator|+=
name|strlen
argument_list|(
name|setfilename_search
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|command_output_filename
condition|)
name|get_until
argument_list|(
literal|"\n"
argument_list|,
operator|&
name|output_filename
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|input_text_offset
operator|!=
operator|-
literal|1
condition|)
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
else|else
name|input_text_offset
operator|=
literal|0
expr_stmt|;
name|real_output_filename
operator|=
name|output_filename
operator|=
name|command_output_filename
expr_stmt|;
name|command_output_filename
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|canon_white
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_output_filename
operator|&&
name|strcmp
argument_list|(
name|real_output_filename
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|real_output_filename
operator|=
name|strdup
argument_list|(
name|real_output_filename
argument_list|)
expr_stmt|;
name|output_stream
operator|=
name|stdout
expr_stmt|;
name|splitting
operator|=
literal|0
expr_stmt|;
comment|/* Cannot split when writing to stdout. */
block|}
else|else
block|{
if|if
condition|(
operator|!
name|real_output_filename
condition|)
name|real_output_filename
operator|=
name|expand_filename
argument_list|(
name|output_filename
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|real_output_filename
operator|=
name|strdup
argument_list|(
name|real_output_filename
argument_list|)
expr_stmt|;
name|output_stream
operator|=
name|fopen
argument_list|(
name|real_output_filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose_mode
operator|&&
name|output_stream
operator|!=
name|stdout
condition|)
name|printf
argument_list|(
literal|"Making %s file `%s' from `%s'.\n"
argument_list|,
name|no_headers
condition|?
literal|"text"
else|:
literal|"info"
argument_list|,
name|output_filename
argument_list|,
name|input_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_stream
operator|==
name|NULL
condition|)
block|{
name|fs_error
argument_list|(
name|real_output_filename
argument_list|)
expr_stmt|;
goto|goto
name|finished
goto|;
block|}
comment|/* Make the displayable filename from output_filename.  Only the base      portion of the filename need be displayed. */
if|if
condition|(
name|output_stream
operator|!=
name|stdout
condition|)
name|pretty_output_filename
operator|=
name|filename_part
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
else|else
name|pretty_output_filename
operator|=
name|strdup
argument_list|(
literal|"stdout"
argument_list|)
expr_stmt|;
comment|/* For this file only, count the number of newlines from the top of      the file to here.  This way, we keep track of line numbers for      error reporting.  Line_number starts at 1, since the user isn't      zero-based. */
block|{
name|int
name|temp
init|=
literal|0
decl_stmt|;
name|line_number
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|temp
operator|!=
name|input_text_offset
condition|)
if|if
condition|(
name|input_text
index|[
name|temp
operator|++
index|]
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|no_headers
condition|)
block|{
name|add_word_args
argument_list|(
literal|"This is Info file %s, produced by Makeinfo version %d.%d"
argument_list|,
name|output_filename
argument_list|,
name|major_version
argument_list|,
name|minor_version
argument_list|)
expr_stmt|;
name|add_word_args
argument_list|(
literal|" from the input file %s.\n"
argument_list|,
name|input_filename
argument_list|)
expr_stmt|;
block|}
name|close_paragraph
argument_list|()
expr_stmt|;
name|reader_loop
argument_list|()
expr_stmt|;
name|finished
label|:
name|close_paragraph
argument_list|()
expr_stmt|;
name|flush_file_stack
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
if|if
condition|(
name|macro_expansion_output_stream
condition|)
name|fclose
argument_list|(
name|macro_expansion_output_stream
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MACROS */
if|if
condition|(
name|output_stream
operator|!=
name|NULL
condition|)
block|{
name|output_pending_notes
argument_list|()
expr_stmt|;
name|free_pending_notes
argument_list|()
expr_stmt|;
if|if
condition|(
name|tag_table
operator|!=
name|NULL
condition|)
block|{
name|tag_table
operator|=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|reverse_list
argument_list|(
name|tag_table
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_headers
condition|)
name|write_tag_table
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|output_stream
operator|!=
name|stdout
condition|)
name|fclose
argument_list|(
name|output_stream
argument_list|)
expr_stmt|;
comment|/* If validating, then validate the entire file right now. */
if|if
condition|(
name|validating
condition|)
name|validate_file
argument_list|(
name|tag_table
argument_list|)
expr_stmt|;
comment|/* This used to test&& !errors_printed. 	 But some files might have legit warnings.  So split anyway.  */
if|if
condition|(
name|splitting
condition|)
name|split_file
argument_list|(
name|real_output_filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|real_output_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|free_and_clear
parameter_list|(
name|pointer
parameter_list|)
name|char
modifier|*
modifier|*
name|pointer
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|*
name|pointer
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|*
name|pointer
argument_list|)
expr_stmt|;
operator|*
name|pointer
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize some state. */
end_comment

begin_function
name|void
name|init_internals
parameter_list|()
block|{
name|free_and_clear
argument_list|(
operator|&
name|current_node
argument_list|)
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
name|output_filename
argument_list|)
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
name|command
argument_list|)
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
name|input_filename
argument_list|)
expr_stmt|;
name|free_node_references
argument_list|()
expr_stmt|;
name|init_insertion_stack
argument_list|()
expr_stmt|;
name|init_brace_stack
argument_list|()
expr_stmt|;
name|command_index
operator|=
literal|0
expr_stmt|;
name|in_menu
operator|=
literal|0
expr_stmt|;
name|in_detailmenu
operator|=
literal|0
expr_stmt|;
name|top_node_seen
operator|=
literal|0
expr_stmt|;
name|non_top_node_seen
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_paragraph
parameter_list|()
block|{
name|free_and_clear
argument_list|(
operator|&
name|output_paragraph
argument_list|)
expr_stmt|;
name|output_paragraph
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|paragraph_buffer_len
argument_list|)
expr_stmt|;
name|output_paragraph
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|output_paragraph_offset
operator|=
literal|0
expr_stmt|;
name|output_column
operator|=
literal|0
expr_stmt|;
name|paragraph_is_open
operator|=
literal|0
expr_stmt|;
name|current_indent
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Okay, we are ready to start the conversion.  Call the reader on    some text, and fill the text as it is output.  Handle commands by    remembering things like open braces and the current file position on a    stack, and when the corresponding close brace is found, you can call    the function with the proper arguments. */
end_comment

begin_function
name|void
name|reader_loop
parameter_list|()
block|{
name|int
name|character
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|int
name|dash_count
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|input_text_offset
operator|>=
name|size_of_input_text
condition|)
break|break;
name|character
operator|=
name|curchar
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|in_fixed_width_font
operator|&&
operator|(
name|character
operator|==
literal|'\''
operator|||
name|character
operator|==
literal|'`'
operator|)
operator|&&
name|input_text
index|[
name|input_text_offset
operator|+
literal|1
index|]
operator|==
name|character
condition|)
block|{
name|input_text_offset
operator|++
expr_stmt|;
name|character
operator|=
literal|'"'
expr_stmt|;
block|}
if|if
condition|(
name|character
operator|==
literal|'-'
condition|)
block|{
name|dash_count
operator|++
expr_stmt|;
if|if
condition|(
name|dash_count
operator|==
literal|2
operator|&&
operator|!
name|in_fixed_width_font
condition|)
block|{
name|input_text_offset
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|dash_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this is a whitespace character, then check to see if the line 	 is blank.  If so, advance to the carriage return. */
if|if
condition|(
name|whitespace
argument_list|(
name|character
argument_list|)
condition|)
block|{
specifier|register
name|int
name|i
init|=
name|input_text_offset
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|size_of_input_text
operator|&&
name|whitespace
argument_list|(
name|input_text
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|size_of_input_text
operator|||
name|input_text
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|size_of_input_text
condition|)
name|i
operator|--
expr_stmt|;
name|input_text_offset
operator|=
name|i
expr_stmt|;
name|character
operator|=
name|curchar
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|character
operator|==
literal|'\n'
condition|)
block|{
name|line_number
operator|++
expr_stmt|;
comment|/* Check for a menu entry here, since the "escape sequence" 	     that begins menu entries is "\n* ". */
if|if
condition|(
name|in_menu
operator|&&
name|input_text_offset
operator|+
literal|1
operator|<
name|size_of_input_text
condition|)
block|{
name|char
modifier|*
name|glean_node_from_menu
argument_list|()
decl_stmt|,
modifier|*
name|tem
decl_stmt|;
comment|/* Note that the value of TEM is discarded, since it is 		 gauranteed to be NULL when glean_node_from_menu () is 		 called with a non-zero argument. */
if|if
condition|(
operator|!
name|in_detailmenu
condition|)
name|tem
operator|=
name|glean_node_from_menu
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|character
condition|)
block|{
case|case
name|COMMAND_PREFIX
case|:
name|read_command
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
comment|/* Special case.  I'm not supposed to see this character by itself. 	     If I do, it means there is a syntax error in the input text. 	     Report the error here, but remember this brace on the stack so 	     you can ignore its partner. */
name|line_error
argument_list|(
literal|"Misplaced `{'"
argument_list|)
expr_stmt|;
name|remember_brace
argument_list|(
name|misplaced_brace
argument_list|)
expr_stmt|;
comment|/* Don't advance input_text_offset since this happens in 	     remember_brace (). 	     input_text_offset++;            */
break|break;
case|case
literal|'}'
case|:
name|pop_and_call_brace
argument_list|()
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
break|break;
default|default:
name|add_char
argument_list|(
name|character
argument_list|)
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
if|if
condition|(
name|macro_expansion_output_stream
condition|)
name|maybe_write_itext
argument_list|(
name|input_text
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MACROS */
block|}
end_function

begin_comment
comment|/* Find the command corresponding to STRING.  If the command    is found, return a pointer to the data structure.  Otherwise    return (-1). */
end_comment

begin_function
name|COMMAND
modifier|*
name|get_command_entry
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|CommandTable
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|CommandTable
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|string
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|&
name|CommandTable
index|[
name|i
index|]
operator|)
return|;
comment|/* This command is not in our predefined command table.  Perhaps      it is a user defined command. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|user_command_array_len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|user_command_array
index|[
name|i
index|]
operator|&&
operator|(
name|strcmp
argument_list|(
name|user_command_array
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|string
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|user_command_array
index|[
name|i
index|]
operator|)
return|;
comment|/* Nope, we never heard of this command. */
return|return
operator|(
operator|(
name|COMMAND
operator|*
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* input_text_offset is right at the command prefix character.    Read the next token to determine what to do. */
end_comment

begin_function
name|void
name|read_command
parameter_list|()
block|{
name|COMMAND
modifier|*
name|entry
decl_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
name|command
argument_list|)
expr_stmt|;
name|command
operator|=
name|read_token
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
comment|/* Check to see if this command is a macro.  If so, execute it here. */
block|{
name|MACRO_DEF
modifier|*
name|def
decl_stmt|;
name|def
operator|=
name|find_macro
argument_list|(
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
condition|)
block|{
comment|/* We disallow recursive use of a macro call.  Inhibit the expansion 	   of this macro during the life of its execution. */
if|if
condition|(
operator|!
operator|(
name|def
operator|->
name|flags
operator|&
name|ME_RECURSE
operator|)
condition|)
name|def
operator|->
name|inhibited
operator|=
literal|1
expr_stmt|;
name|execute_macro
argument_list|(
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|def
operator|->
name|flags
operator|&
name|ME_RECURSE
operator|)
condition|)
name|def
operator|->
name|inhibited
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_MACROS */
name|entry
operator|=
name|get_command_entry
argument_list|(
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
operator|(
name|COMMAND
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|line_error
argument_list|(
literal|"Unknown command `%s'"
argument_list|,
name|command
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|entry
operator|->
name|argument_in_braces
condition|)
name|remember_brace
argument_list|(
name|entry
operator|->
name|proc
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|entry
operator|->
name|proc
operator|)
operator|)
operator|(
name|START
operator|,
name|output_paragraph_offset
operator|,
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the string which invokes PROC; a pointer to a function. */
end_comment

begin_function
name|char
modifier|*
name|find_proc_name
parameter_list|(
name|proc
parameter_list|)
name|COMMAND_FUNCTION
modifier|*
name|proc
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|CommandTable
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|proc
operator|==
name|CommandTable
index|[
name|i
index|]
operator|.
name|proc
condition|)
return|return
operator|(
name|CommandTable
index|[
name|i
index|]
operator|.
name|name
operator|)
return|;
return|return
operator|(
literal|"NO_NAME!"
operator|)
return|;
block|}
end_function

begin_function
name|void
name|init_brace_stack
parameter_list|()
block|{
name|brace_stack
operator|=
operator|(
name|BRACE_ELEMENT
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|remember_brace
parameter_list|(
name|proc
parameter_list|)
name|COMMAND_FUNCTION
modifier|*
name|proc
decl_stmt|;
block|{
if|if
condition|(
name|curchar
argument_list|()
operator|!=
literal|'{'
condition|)
name|line_error
argument_list|(
literal|"%c%s expected `{..}'"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
else|else
name|input_text_offset
operator|++
expr_stmt|;
name|remember_brace_1
argument_list|(
name|proc
argument_list|,
name|output_paragraph_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remember the current output position here.  Save PROC    along with it so you can call it later. */
end_comment

begin_function
name|void
name|remember_brace_1
parameter_list|(
name|proc
parameter_list|,
name|position
parameter_list|)
name|COMMAND_FUNCTION
modifier|*
name|proc
decl_stmt|;
name|int
name|position
decl_stmt|;
block|{
name|BRACE_ELEMENT
modifier|*
name|new
init|=
operator|(
name|BRACE_ELEMENT
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BRACE_ELEMENT
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|next
operator|=
name|brace_stack
expr_stmt|;
name|new
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|new
operator|->
name|pos
operator|=
name|position
expr_stmt|;
name|new
operator|->
name|line
operator|=
name|line_number
expr_stmt|;
name|new
operator|->
name|in_fixed_width_font
operator|=
name|in_fixed_width_font
expr_stmt|;
name|brace_stack
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop the top of the brace stack, and call the associated function    with the args END and POS. */
end_comment

begin_function
name|void
name|pop_and_call_brace
parameter_list|()
block|{
name|BRACE_ELEMENT
modifier|*
name|temp
decl_stmt|;
name|COMMAND_FUNCTION
modifier|*
name|proc
decl_stmt|;
name|int
name|pos
decl_stmt|;
if|if
condition|(
name|brace_stack
operator|==
operator|(
name|BRACE_ELEMENT
operator|*
operator|)
name|NULL
condition|)
block|{
name|line_error
argument_list|(
literal|"Unmatched }"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pos
operator|=
name|brace_stack
operator|->
name|pos
expr_stmt|;
name|proc
operator|=
name|brace_stack
operator|->
name|proc
expr_stmt|;
name|in_fixed_width_font
operator|=
name|brace_stack
operator|->
name|in_fixed_width_font
expr_stmt|;
name|temp
operator|=
name|brace_stack
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|brace_stack
argument_list|)
expr_stmt|;
name|brace_stack
operator|=
name|temp
expr_stmt|;
call|(
modifier|*
name|proc
call|)
argument_list|(
name|END
argument_list|,
name|pos
argument_list|,
name|output_paragraph_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Shift all of the markers in `brace_stack' by AMOUNT. */
end_comment

begin_function
name|void
name|adjust_braces_following
parameter_list|(
name|here
parameter_list|,
name|amount
parameter_list|)
name|int
name|here
decl_stmt|,
name|amount
decl_stmt|;
block|{
specifier|register
name|BRACE_ELEMENT
modifier|*
name|stack
init|=
name|brace_stack
decl_stmt|;
while|while
condition|(
name|stack
condition|)
block|{
if|if
condition|(
name|stack
operator|->
name|pos
operator|>=
name|here
condition|)
name|stack
operator|->
name|pos
operator|+=
name|amount
expr_stmt|;
name|stack
operator|=
name|stack
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* You call discard_braces () when you shouldn't have any braces on the stack.    I used to think that this happens for commands that don't take arguments    in braces, but that was wrong because of things like @code{foo @@}.  So now    I only detect it at the beginning of nodes. */
end_comment

begin_function
name|void
name|discard_braces
parameter_list|()
block|{
if|if
condition|(
operator|!
name|brace_stack
condition|)
return|return;
while|while
condition|(
name|brace_stack
condition|)
block|{
if|if
condition|(
name|brace_stack
operator|->
name|proc
operator|!=
name|misplaced_brace
condition|)
block|{
name|char
modifier|*
name|proc_name
decl_stmt|;
name|int
name|temp_line_number
init|=
name|line_number
decl_stmt|;
name|line_number
operator|=
name|brace_stack
operator|->
name|line
expr_stmt|;
name|proc_name
operator|=
name|find_proc_name
argument_list|(
name|brace_stack
operator|->
name|proc
argument_list|)
expr_stmt|;
name|line_error
argument_list|(
literal|"%c%s missing close brace"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|proc_name
argument_list|)
expr_stmt|;
name|line_number
operator|=
name|temp_line_number
expr_stmt|;
name|pop_and_call_brace
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|BRACE_ELEMENT
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|brace_stack
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|brace_stack
argument_list|)
expr_stmt|;
name|brace_stack
operator|=
name|temp
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|get_char_len
parameter_list|(
name|character
parameter_list|)
name|int
name|character
decl_stmt|;
block|{
comment|/* Return the printed length of the character. */
name|int
name|len
decl_stmt|;
switch|switch
condition|(
name|character
condition|)
block|{
case|case
literal|'\t'
case|:
name|len
operator|=
operator|(
name|output_column
operator|+
literal|8
operator|)
operator|&
literal|0xf7
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|fill_column
condition|)
name|len
operator|=
name|fill_column
operator|-
name|output_column
expr_stmt|;
else|else
name|len
operator|=
name|len
operator|-
name|output_column
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|len
operator|=
name|fill_column
operator|-
name|output_column
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|character
operator|<
literal|' '
condition|)
name|len
operator|=
literal|2
expr_stmt|;
else|else
name|len
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_VARARGS_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_VSPRINTF
argument_list|)
end_if

begin_function
name|void
name|add_word_args
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|char
name|buffer
index|[
literal|1000
index|]
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|buffer
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !(HAVE_VARARGS_H&& HAVE_VSPRINTF) */
end_comment

begin_function
name|void
name|add_word_args
parameter_list|(
name|format
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|,
name|arg4
parameter_list|,
name|arg5
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
block|{
name|char
name|buffer
index|[
literal|1000
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !(HAVE_VARARGS_H&& HAVE_VSPRINTF) */
end_comment

begin_comment
comment|/* Add STRING to output_paragraph. */
end_comment

begin_function
name|void
name|add_word
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|string
condition|)
name|add_char
argument_list|(
operator|*
name|string
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Non-zero if the last character inserted has the syntax class of NEWLINE. */
end_comment

begin_decl_stmt
name|int
name|last_char_was_newline
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The actual last inserted character.  Note that this may be something    other than NEWLINE even if last_char_was_newline is 1. */
end_comment

begin_decl_stmt
name|int
name|last_inserted_character
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that a newline character has already been    inserted, so close_paragraph () should insert one less. */
end_comment

begin_decl_stmt
name|int
name|line_already_broken
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When non-zero we have finished an insertion (see end_insertion ()) and we    want to ignore false continued paragraph closings. */
end_comment

begin_decl_stmt
name|int
name|insertion_paragraph_closed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means attempt to make all of the lines have fill_column width. */
end_comment

begin_decl_stmt
name|int
name|do_justification
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add the character to the current paragraph.  If filling_enabled is    non-zero, then do filling as well. */
end_comment

begin_function
name|void
name|add_char
parameter_list|(
name|character
parameter_list|)
name|int
name|character
decl_stmt|;
block|{
comment|/* If we are avoiding outputting headers, and we are currently      in a menu, then simply return. */
if|if
condition|(
name|no_headers
operator|&&
operator|(
name|in_menu
operator|||
name|in_detailmenu
operator|)
condition|)
return|return;
comment|/* If we are adding a character now, then we don't have to      ignore close_paragraph () calls any more. */
if|if
condition|(
name|must_start_paragraph
operator|&&
name|character
operator|!=
literal|'\n'
condition|)
block|{
name|must_start_paragraph
operator|=
literal|0
expr_stmt|;
name|line_already_broken
operator|=
literal|0
expr_stmt|;
comment|/* The line is no longer broken. */
if|if
condition|(
name|current_indent
operator|>
name|output_column
condition|)
block|{
name|indent
argument_list|(
name|current_indent
operator|-
name|output_column
argument_list|)
expr_stmt|;
name|output_column
operator|=
name|current_indent
expr_stmt|;
block|}
block|}
if|if
condition|(
name|non_splitting_words
operator|&&
name|member
argument_list|(
name|character
argument_list|,
literal|" \t\n"
argument_list|)
condition|)
name|character
operator|=
literal|' '
operator||
literal|0x80
expr_stmt|;
name|insertion_paragraph_closed
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|character
condition|)
block|{
case|case
literal|'\n'
case|:
if|if
condition|(
operator|!
name|filling_enabled
condition|)
block|{
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_flush_right
condition|)
block|{
name|close_paragraph
argument_list|()
expr_stmt|;
comment|/* Hack to force single blank lines out in this mode. */
name|flush_output
argument_list|()
expr_stmt|;
block|}
name|output_column
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|no_indent
operator|&&
name|paragraph_is_open
condition|)
name|indent
argument_list|(
name|output_column
operator|=
name|current_indent
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
comment|/* CHARACTER is newline, and filling is enabled. */
block|{
if|if
condition|(
name|sentence_ender
argument_list|(
name|last_inserted_character
argument_list|)
condition|)
block|{
name|insert
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|output_column
operator|++
expr_stmt|;
name|last_inserted_character
operator|=
name|character
expr_stmt|;
block|}
block|}
if|if
condition|(
name|last_char_was_newline
condition|)
block|{
name|close_paragraph
argument_list|()
expr_stmt|;
name|pending_indent
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|last_char_was_newline
operator|=
literal|1
expr_stmt|;
name|insert
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|output_column
operator|++
expr_stmt|;
block|}
break|break;
default|default:
block|{
name|int
name|len
init|=
name|get_char_len
argument_list|(
name|character
argument_list|)
decl_stmt|;
name|int
name|suppress_insert
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|character
operator|==
literal|' '
operator|)
operator|&&
operator|(
name|last_char_was_newline
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|paragraph_is_open
condition|)
block|{
name|pending_indent
operator|++
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|paragraph_is_open
condition|)
block|{
name|start_paragraph
argument_list|()
expr_stmt|;
comment|/* If the paragraph is supposed to be indented a certain way, 	       then discard all of the pending whitespace.  Otherwise, we 	       let the whitespace stay. */
if|if
condition|(
operator|!
name|paragraph_start_indent
condition|)
name|indent
argument_list|(
name|pending_indent
argument_list|)
expr_stmt|;
name|pending_indent
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|output_column
operator|+=
name|len
operator|)
operator|>
name|fill_column
condition|)
block|{
if|if
condition|(
name|filling_enabled
condition|)
block|{
name|int
name|temp
init|=
name|output_paragraph_offset
decl_stmt|;
while|while
condition|(
operator|--
name|temp
operator|>
literal|0
operator|&&
name|output_paragraph
index|[
name|temp
index|]
operator|!=
literal|'\n'
condition|)
block|{
comment|/* If we have found a space, we have the place to break 		       the line. */
if|if
condition|(
name|output_paragraph
index|[
name|temp
index|]
operator|==
literal|' '
condition|)
block|{
comment|/* Remove trailing whitespace from output. */
while|while
condition|(
name|temp
operator|&&
name|whitespace
argument_list|(
name|output_paragraph
index|[
name|temp
operator|-
literal|1
index|]
argument_list|)
condition|)
name|temp
operator|--
expr_stmt|;
name|output_paragraph
index|[
name|temp
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
comment|/* We have correctly broken the line where we want 			   to.  What we don't want is spaces following where 			   we have decided to break the line.  We get rid of 			   them. */
block|{
name|int
name|t1
init|=
name|temp
decl_stmt|;
for|for
control|(
init|;
condition|;
name|t1
operator|++
control|)
block|{
if|if
condition|(
name|t1
operator|==
name|output_paragraph_offset
condition|)
block|{
if|if
condition|(
name|whitespace
argument_list|(
name|character
argument_list|)
condition|)
name|suppress_insert
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|output_paragraph
index|[
name|t1
index|]
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|t1
operator|!=
name|temp
condition|)
block|{
name|adjust_braces_following
argument_list|(
name|temp
argument_list|,
operator|(
operator|-
operator|(
name|t1
operator|-
name|temp
operator|)
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|output_paragraph
index|[
name|temp
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|output_paragraph
index|[
name|t1
index|]
argument_list|,
operator|(
name|output_paragraph_offset
operator|-
name|t1
operator|)
argument_list|)
expr_stmt|;
name|output_paragraph_offset
operator|-=
operator|(
name|t1
operator|-
name|temp
operator|)
expr_stmt|;
block|}
block|}
comment|/* Filled, but now indent if that is right. */
if|if
condition|(
name|indented_fill
operator|&&
name|current_indent
condition|)
block|{
name|int
name|buffer_len
init|=
operator|(
operator|(
name|output_paragraph_offset
operator|-
name|temp
operator|)
operator|+
name|current_indent
operator|)
decl_stmt|;
name|char
modifier|*
name|temp_buffer
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|buffer_len
argument_list|)
decl_stmt|;
name|int
name|indentation
init|=
literal|0
decl_stmt|;
comment|/* We have to shift any markers that are in 			       front of the wrap point. */
name|adjust_braces_following
argument_list|(
name|temp
argument_list|,
name|current_indent
argument_list|)
expr_stmt|;
while|while
condition|(
name|current_indent
operator|>
literal|0
operator|&&
name|indentation
operator|!=
name|current_indent
condition|)
name|temp_buffer
index|[
name|indentation
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|temp_buffer
index|[
name|current_indent
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|output_paragraph
index|[
name|temp
index|]
argument_list|,
name|buffer_len
operator|-
name|current_indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_paragraph_offset
operator|+
name|buffer_len
operator|>=
name|paragraph_buffer_len
condition|)
block|{
name|unsigned
name|char
modifier|*
name|tt
init|=
name|xrealloc
argument_list|(
name|output_paragraph
argument_list|,
operator|(
name|paragraph_buffer_len
operator|+=
name|buffer_len
operator|)
argument_list|)
decl_stmt|;
name|output_paragraph
operator|=
name|tt
expr_stmt|;
block|}
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|output_paragraph
index|[
name|temp
index|]
argument_list|,
name|temp_buffer
argument_list|,
name|buffer_len
argument_list|)
expr_stmt|;
name|output_paragraph_offset
operator|+=
name|current_indent
expr_stmt|;
name|free
argument_list|(
name|temp_buffer
argument_list|)
expr_stmt|;
block|}
name|output_column
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|temp
operator|<
name|output_paragraph_offset
condition|)
name|output_column
operator|+=
name|get_char_len
argument_list|(
name|output_paragraph
index|[
name|temp
operator|++
index|]
argument_list|)
expr_stmt|;
name|output_column
operator|+=
name|len
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|suppress_insert
condition|)
block|{
name|insert
argument_list|(
name|character
argument_list|)
expr_stmt|;
name|last_inserted_character
operator|=
name|character
expr_stmt|;
block|}
name|last_char_was_newline
operator|=
literal|0
expr_stmt|;
name|line_already_broken
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Insert CHARACTER into `output_paragraph'. */
end_comment

begin_function
name|void
name|insert
parameter_list|(
name|character
parameter_list|)
name|int
name|character
decl_stmt|;
block|{
name|output_paragraph
index|[
name|output_paragraph_offset
operator|++
index|]
operator|=
name|character
expr_stmt|;
if|if
condition|(
name|output_paragraph_offset
operator|==
name|paragraph_buffer_len
condition|)
block|{
name|output_paragraph
operator|=
name|xrealloc
argument_list|(
name|output_paragraph
argument_list|,
operator|(
name|paragraph_buffer_len
operator|+=
literal|100
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Insert the null-terminated string STRING into `output_paragraph'.  */
end_comment

begin_function
name|void
name|insert_string
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|string
condition|)
name|insert
argument_list|(
operator|*
name|string
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove upto COUNT characters of whitespace from the    the current output line.  If COUNT is less than zero,    then remove until none left. */
end_comment

begin_function
name|void
name|kill_self_indent
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
block|{
comment|/* Handle infinite case first. */
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|output_column
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|output_paragraph_offset
condition|)
block|{
if|if
condition|(
name|whitespace
argument_list|(
name|output_paragraph
index|[
name|output_paragraph_offset
operator|-
literal|1
index|]
argument_list|)
condition|)
name|output_paragraph_offset
operator|--
expr_stmt|;
else|else
break|break;
block|}
block|}
else|else
block|{
while|while
condition|(
name|output_paragraph_offset
operator|&&
name|count
operator|--
condition|)
if|if
condition|(
name|whitespace
argument_list|(
name|output_paragraph
index|[
name|output_paragraph_offset
operator|-
literal|1
index|]
argument_list|)
condition|)
name|output_paragraph_offset
operator|--
expr_stmt|;
else|else
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Non-zero means do not honor calls to flush_output (). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flushing_ignored
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prevent calls to flush_output () from having any effect. */
end_comment

begin_function
name|void
name|inhibit_output_flushing
parameter_list|()
block|{
name|flushing_ignored
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allow calls to flush_output () to write the paragraph data. */
end_comment

begin_function
name|void
name|uninhibit_output_flushing
parameter_list|()
block|{
name|flushing_ignored
operator|--
expr_stmt|;
block|}
end_function

begin_function
name|void
name|flush_output
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|output_paragraph_offset
operator|||
name|flushing_ignored
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|output_paragraph_offset
condition|;
name|i
operator|++
control|)
block|{
comment|/* If we turned on the 8th bit for a space          inside @w, turn it back off for output.  */
if|if
condition|(
name|output_paragraph
index|[
name|i
index|]
operator|&
name|meta_character_bit
condition|)
block|{
name|int
name|temp
init|=
name|UNMETA
argument_list|(
name|output_paragraph
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|==
literal|' '
condition|)
name|output_paragraph
index|[
name|i
index|]
operator|&=
literal|0x7f
expr_stmt|;
block|}
block|}
name|fwrite
argument_list|(
name|output_paragraph
argument_list|,
literal|1
argument_list|,
name|output_paragraph_offset
argument_list|,
name|output_stream
argument_list|)
expr_stmt|;
name|output_position
operator|+=
name|output_paragraph_offset
expr_stmt|;
name|output_paragraph_offset
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* How to close a paragraph controlling the number of lines between    this one and the last one. */
end_comment

begin_comment
comment|/* Paragraph spacing is controlled by this variable.  It is the number of    blank lines that you wish to appear between paragraphs.  A value of    1 creates a single blank line between paragraphs. */
end_comment

begin_decl_stmt
name|int
name|paragraph_spacing
init|=
name|DEFAULT_PARAGRAPH_SPACING
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Close the current paragraph, leaving no blank lines between them. */
end_comment

begin_function
name|void
name|close_single_paragraph
parameter_list|()
block|{
name|close_paragraph_with_lines
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close a paragraph after an insertion has ended. */
end_comment

begin_function
name|void
name|close_insertion_paragraph
parameter_list|()
block|{
if|if
condition|(
operator|!
name|insertion_paragraph_closed
condition|)
block|{
comment|/* Close the current paragraph, breaking the line. */
name|close_single_paragraph
argument_list|()
expr_stmt|;
comment|/* Start a new paragraph here, inserting whatever indention is correct 	 for the now current insertion level (one above the one that we are 	 ending). */
name|start_paragraph
argument_list|()
expr_stmt|;
comment|/* Tell close_paragraph () that the previous line has already been 	 broken, so it should insert one less newline. */
name|line_already_broken
operator|=
literal|1
expr_stmt|;
comment|/* Let functions such as add_char () know that we have already found a 	 newline. */
name|ignore_blank_line
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* If the insertion paragraph is closed already, then we are seeing 	 two `@end' commands in a row.  Note that the first one we saw was 	 handled in the first part of this if-then-else clause, and at that 	 time start_paragraph () was called, partially to handle the proper 	 indentation of the current line.  However, the indentation level 	 may have just changed again, so we may have to outdent the current 	 line to the new indentation level. */
if|if
condition|(
name|current_indent
operator|<
name|output_column
condition|)
name|kill_self_indent
argument_list|(
name|output_column
operator|-
name|current_indent
argument_list|)
expr_stmt|;
block|}
name|insertion_paragraph_closed
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|close_paragraph_with_lines
parameter_list|(
name|lines
parameter_list|)
name|int
name|lines
decl_stmt|;
block|{
name|int
name|old_spacing
init|=
name|paragraph_spacing
decl_stmt|;
name|paragraph_spacing
operator|=
name|lines
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|paragraph_spacing
operator|=
name|old_spacing
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close the currently open paragraph. */
end_comment

begin_function
name|void
name|close_paragraph
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* The insertion paragraph is no longer closed. */
name|insertion_paragraph_closed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|paragraph_is_open
operator|&&
operator|!
name|must_start_paragraph
condition|)
block|{
specifier|register
name|int
name|tindex
decl_stmt|,
name|c
decl_stmt|;
name|tindex
operator|=
name|output_paragraph_offset
expr_stmt|;
comment|/* Back up to last non-newline/space character, forcing all such 	 subsequent characters to be newlines.  This isn't strictly 	 necessary, but a couple of functions use the presence of a newline 	 to make decisions. */
for|for
control|(
name|tindex
operator|=
name|output_paragraph_offset
operator|-
literal|1
init|;
name|tindex
operator|>=
literal|0
condition|;
operator|--
name|tindex
control|)
block|{
name|c
operator|=
name|output_paragraph
index|[
name|tindex
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
condition|)
name|output_paragraph
index|[
name|tindex
index|]
operator|=
literal|'\n'
expr_stmt|;
else|else
break|break;
block|}
comment|/* All trailing whitespace is ignored. */
name|output_paragraph_offset
operator|=
operator|++
name|tindex
expr_stmt|;
comment|/* Break the line if that is appropriate. */
if|if
condition|(
name|paragraph_spacing
operator|>=
literal|0
condition|)
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* Add as many blank lines as is specified in PARAGRAPH_SPACING. */
if|if
condition|(
operator|!
name|force_flush_right
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|paragraph_spacing
operator|-
name|line_already_broken
operator|)
condition|;
name|i
operator|++
control|)
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
comment|/* If we are doing flush right indentation, then do it now 	 on the paragraph (really a single line). */
if|if
condition|(
name|force_flush_right
condition|)
name|do_flush_right_indentation
argument_list|()
expr_stmt|;
name|flush_output
argument_list|()
expr_stmt|;
name|paragraph_is_open
operator|=
literal|0
expr_stmt|;
name|no_indent
operator|=
literal|0
expr_stmt|;
name|output_column
operator|=
literal|0
expr_stmt|;
block|}
name|ignore_blank_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make the last line just read look as if it were only a newline. */
end_comment

begin_function
name|void
name|ignore_blank_line
parameter_list|()
block|{
name|last_inserted_character
operator|=
literal|'\n'
expr_stmt|;
name|last_char_was_newline
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Align the end of the text in output_paragraph with fill_column. */
end_comment

begin_function
name|void
name|do_flush_right_indentation
parameter_list|()
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|temp_len
decl_stmt|;
name|kill_self_indent
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_paragraph
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|output_paragraph
index|[
name|output_paragraph_offset
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|output_paragraph_offset
operator|<
name|fill_column
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fill_column
operator|>=
name|paragraph_buffer_len
condition|)
name|output_paragraph
operator|=
name|xrealloc
argument_list|(
name|output_paragraph
argument_list|,
operator|(
name|paragraph_buffer_len
operator|+=
name|fill_column
operator|)
argument_list|)
expr_stmt|;
name|temp_len
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|output_paragraph
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|temp_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|temp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|output_paragraph
argument_list|,
name|temp_len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fill_column
operator|-
name|output_paragraph_offset
condition|;
name|i
operator|++
control|)
name|output_paragraph
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|output_paragraph
operator|+
name|i
argument_list|,
name|temp
argument_list|,
name|temp_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|output_paragraph_offset
operator|=
name|fill_column
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Begin a new paragraph. */
end_comment

begin_function
name|void
name|start_paragraph
parameter_list|()
block|{
comment|/* First close existing one. */
if|if
condition|(
name|paragraph_is_open
condition|)
name|close_paragraph
argument_list|()
expr_stmt|;
comment|/* In either case, the insertion paragraph is no longer closed. */
name|insertion_paragraph_closed
operator|=
literal|0
expr_stmt|;
comment|/* However, the paragraph is open! */
name|paragraph_is_open
operator|=
literal|1
expr_stmt|;
comment|/* If we MUST_START_PARAGRAPH, that simply means that start_paragraph ()      had to be called before we would allow any other paragraph operations      to have an effect. */
if|if
condition|(
operator|!
name|must_start_paragraph
condition|)
block|{
name|int
name|amount_to_indent
init|=
literal|0
decl_stmt|;
comment|/* If doing indentation, then insert the appropriate amount. */
if|if
condition|(
operator|!
name|no_indent
condition|)
block|{
if|if
condition|(
name|inhibit_paragraph_indentation
condition|)
block|{
name|amount_to_indent
operator|=
name|current_indent
expr_stmt|;
if|if
condition|(
name|inhibit_paragraph_indentation
operator|<
literal|0
condition|)
name|inhibit_paragraph_indentation
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|paragraph_start_indent
operator|<
literal|0
condition|)
name|amount_to_indent
operator|=
name|current_indent
expr_stmt|;
else|else
name|amount_to_indent
operator|=
name|current_indent
operator|+
name|paragraph_start_indent
expr_stmt|;
if|if
condition|(
name|amount_to_indent
operator|>=
name|output_column
condition|)
block|{
name|amount_to_indent
operator|-=
name|output_column
expr_stmt|;
name|indent
argument_list|(
name|amount_to_indent
argument_list|)
expr_stmt|;
name|output_column
operator|+=
name|amount_to_indent
expr_stmt|;
block|}
block|}
block|}
else|else
name|must_start_paragraph
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert the indentation specified by AMOUNT. */
end_comment

begin_function
name|void
name|indent
parameter_list|(
name|amount
parameter_list|)
name|int
name|amount
decl_stmt|;
block|{
specifier|register
name|BRACE_ELEMENT
modifier|*
name|elt
init|=
name|brace_stack
decl_stmt|;
comment|/* For every START_POS saved within the brace stack which will be affected      by this indentation, bump that start pos forward. */
while|while
condition|(
name|elt
condition|)
block|{
if|if
condition|(
name|elt
operator|->
name|pos
operator|>=
name|output_paragraph_offset
condition|)
name|elt
operator|->
name|pos
operator|+=
name|amount
expr_stmt|;
name|elt
operator|=
name|elt
operator|->
name|next
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|amount
operator|>=
literal|0
condition|)
name|insert
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Search forward for STRING in input_text.    FROM says where where to start. */
end_comment

begin_function
name|int
name|search_forward
parameter_list|(
name|string
parameter_list|,
name|from
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|from
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
while|while
condition|(
name|from
operator|<
name|size_of_input_text
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|input_text
operator|+
name|from
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|from
operator|)
return|;
name|from
operator|++
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Whoops, Unix doesn't have strcasecmp. */
end_comment

begin_comment
comment|/* Case independent string compare. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_STRCASECMP
argument_list|)
end_if

begin_function
name|int
name|strcasecmp
parameter_list|(
name|string1
parameter_list|,
name|string2
parameter_list|)
name|char
modifier|*
name|string1
decl_stmt|,
decl|*
name|string2
decl_stmt|;
end_function

begin_block
block|{
name|char
name|ch1
decl_stmt|,
name|ch2
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ch1
operator|=
operator|*
name|string1
operator|++
expr_stmt|;
name|ch2
operator|=
operator|*
name|string2
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ch1
operator||
name|ch2
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ch1
operator|=
name|coerce_to_upper
argument_list|(
name|ch1
argument_list|)
expr_stmt|;
name|ch2
operator|=
name|coerce_to_upper
argument_list|(
name|ch2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch1
operator|!=
name|ch2
condition|)
return|return
operator|(
name|ch1
operator|-
name|ch2
operator|)
return|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_STRCASECMP */
end_comment

begin_function
name|void
name|init_insertion_stack
parameter_list|()
block|{
name|insertion_stack
operator|=
operator|(
name|INSERTION_ELT
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the type of the current insertion. */
end_comment

begin_function
name|enum
name|insertion_type
name|current_insertion_type
parameter_list|()
block|{
if|if
condition|(
operator|!
name|insertion_level
condition|)
return|return
operator|(
name|bad_type
operator|)
return|;
else|else
return|return
operator|(
name|insertion_stack
operator|->
name|insertion
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the string which is the function to wrap around    items. */
end_comment

begin_function
name|char
modifier|*
name|current_item_function
parameter_list|()
block|{
specifier|register
name|int
name|level
decl_stmt|,
name|done
decl_stmt|;
specifier|register
name|INSERTION_ELT
modifier|*
name|elt
decl_stmt|;
name|level
operator|=
name|insertion_level
expr_stmt|;
name|elt
operator|=
name|insertion_stack
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
comment|/* Skip down through the stack until we find a non-conditional insertion. */
while|while
condition|(
operator|!
name|done
operator|&&
operator|(
name|elt
operator|!=
name|NULL
operator|)
condition|)
block|{
switch|switch
condition|(
name|elt
operator|->
name|insertion
condition|)
block|{
case|case
name|ifinfo
case|:
case|case
name|ifset
case|:
case|case
name|ifclear
case|:
case|case
name|cartouche
case|:
name|elt
operator|=
name|elt
operator|->
name|next
expr_stmt|;
name|level
operator|--
expr_stmt|;
break|break;
default|default:
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|level
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|elt
operator|->
name|item_function
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|get_item_function
parameter_list|()
block|{
name|char
modifier|*
name|item_function
decl_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|item_function
argument_list|)
expr_stmt|;
name|backup_input_pointer
argument_list|()
expr_stmt|;
name|canon_white
argument_list|(
name|item_function
argument_list|)
expr_stmt|;
return|return
operator|(
name|item_function
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Push the state of the current insertion on the stack. */
end_comment

begin_function
name|void
name|push_insertion
parameter_list|(
name|type
parameter_list|,
name|item_function
parameter_list|)
name|enum
name|insertion_type
name|type
decl_stmt|;
name|char
modifier|*
name|item_function
decl_stmt|;
block|{
name|INSERTION_ELT
modifier|*
name|new
init|=
operator|(
name|INSERTION_ELT
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|INSERTION_ELT
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|item_function
operator|=
name|item_function
expr_stmt|;
name|new
operator|->
name|filling_enabled
operator|=
name|filling_enabled
expr_stmt|;
name|new
operator|->
name|indented_fill
operator|=
name|indented_fill
expr_stmt|;
name|new
operator|->
name|insertion
operator|=
name|type
expr_stmt|;
name|new
operator|->
name|line_number
operator|=
name|line_number
expr_stmt|;
name|new
operator|->
name|filename
operator|=
name|strdup
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|new
operator|->
name|inhibited
operator|=
name|inhibit_paragraph_indentation
expr_stmt|;
name|new
operator|->
name|in_fixed_width_font
operator|=
name|in_fixed_width_font
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|insertion_stack
expr_stmt|;
name|insertion_stack
operator|=
name|new
expr_stmt|;
name|insertion_level
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop the value on top of the insertion stack into the     global variables. */
end_comment

begin_function
name|void
name|pop_insertion
parameter_list|()
block|{
name|INSERTION_ELT
modifier|*
name|temp
init|=
name|insertion_stack
decl_stmt|;
if|if
condition|(
name|temp
operator|==
operator|(
name|INSERTION_ELT
operator|*
operator|)
name|NULL
condition|)
return|return;
name|in_fixed_width_font
operator|=
name|temp
operator|->
name|in_fixed_width_font
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
name|temp
operator|->
name|inhibited
expr_stmt|;
name|filling_enabled
operator|=
name|temp
operator|->
name|filling_enabled
expr_stmt|;
name|indented_fill
operator|=
name|temp
operator|->
name|indented_fill
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
operator|(
name|temp
operator|->
name|item_function
operator|)
argument_list|)
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
operator|(
name|temp
operator|->
name|filename
operator|)
argument_list|)
expr_stmt|;
name|insertion_stack
operator|=
name|insertion_stack
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|insertion_level
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the print name of this     enumerated type. */
end_comment

begin_function
name|char
modifier|*
name|insertion_type_pname
parameter_list|(
name|type
parameter_list|)
name|enum
name|insertion_type
name|type
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|type
operator|<
operator|(
name|int
operator|)
name|bad_type
condition|)
return|return
operator|(
name|insertion_type_names
index|[
operator|(
name|int
operator|)
name|type
index|]
operator|)
return|;
else|else
return|return
operator|(
literal|"Broken-Type in insertion_type_pname"
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the insertion_type associated with NAME.    If the type is not one of the known ones, return BAD_TYPE. */
end_comment

begin_function
name|enum
name|insertion_type
name|find_type_from_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|index
operator|<
operator|(
name|int
operator|)
name|bad_type
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|insertion_type_names
index|[
name|index
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
expr|enum
name|insertion_type
operator|)
name|index
return|;
name|index
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|bad_type
operator|)
return|;
block|}
end_function

begin_function
name|int
name|defun_insertion
parameter_list|(
name|type
parameter_list|)
name|enum
name|insertion_type
name|type
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|type
operator|==
name|deffn
operator|)
operator|||
operator|(
name|type
operator|==
name|defun
operator|)
operator|||
operator|(
name|type
operator|==
name|defmac
operator|)
operator|||
operator|(
name|type
operator|==
name|defspec
operator|)
operator|||
operator|(
name|type
operator|==
name|defvr
operator|)
operator|||
operator|(
name|type
operator|==
name|defvar
operator|)
operator|||
operator|(
name|type
operator|==
name|defopt
operator|)
operator|||
operator|(
name|type
operator|==
name|deftypefn
operator|)
operator|||
operator|(
name|type
operator|==
name|deftypefun
operator|)
operator|||
operator|(
name|type
operator|==
name|deftypevr
operator|)
operator|||
operator|(
name|type
operator|==
name|deftypevar
operator|)
operator|||
operator|(
name|type
operator|==
name|defcv
operator|)
operator|||
operator|(
name|type
operator|==
name|defivar
operator|)
operator|||
operator|(
name|type
operator|==
name|defop
operator|)
operator|||
operator|(
name|type
operator|==
name|defmethod
operator|)
operator|||
operator|(
name|type
operator|==
name|deftypemethod
operator|)
operator|||
operator|(
name|type
operator|==
name|deftp
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* MAX_NS is the maximum nesting level for enumerations.  I picked 100    which seemed reasonable.  This doesn't control the number of items,    just the number of nested lists. */
end_comment

begin_define
define|#
directive|define
name|max_stack_depth
value|100
end_define

begin_define
define|#
directive|define
name|ENUM_DIGITS
value|1
end_define

begin_define
define|#
directive|define
name|ENUM_ALPHA
value|2
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|enumtype
decl_stmt|;
name|int
name|enumval
decl_stmt|;
block|}
name|DIGIT_ALPHA
typedef|;
end_typedef

begin_decl_stmt
name|DIGIT_ALPHA
name|enumstack
index|[
name|max_stack_depth
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|enumstack_offset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_enumval
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_enumtype
init|=
name|ENUM_DIGITS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|enumeration_arg
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|start_enumerating
parameter_list|(
name|at
parameter_list|,
name|type
parameter_list|)
name|int
name|at
decl_stmt|,
name|type
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|enumstack_offset
operator|+
literal|1
operator|)
operator|==
name|max_stack_depth
condition|)
block|{
name|line_error
argument_list|(
literal|"Enumeration stack overflow"
argument_list|)
expr_stmt|;
return|return;
block|}
name|enumstack
index|[
name|enumstack_offset
index|]
operator|.
name|enumtype
operator|=
name|current_enumtype
expr_stmt|;
name|enumstack
index|[
name|enumstack_offset
index|]
operator|.
name|enumval
operator|=
name|current_enumval
expr_stmt|;
name|enumstack_offset
operator|++
expr_stmt|;
name|current_enumval
operator|=
name|at
expr_stmt|;
name|current_enumtype
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_function
name|void
name|stop_enumerating
parameter_list|()
block|{
operator|--
name|enumstack_offset
expr_stmt|;
if|if
condition|(
name|enumstack_offset
operator|<
literal|0
condition|)
name|enumstack_offset
operator|=
literal|0
expr_stmt|;
name|current_enumval
operator|=
name|enumstack
index|[
name|enumstack_offset
index|]
operator|.
name|enumval
expr_stmt|;
name|current_enumtype
operator|=
name|enumstack
index|[
name|enumstack_offset
index|]
operator|.
name|enumtype
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Place a letter or digits into the output stream. */
end_comment

begin_function
name|void
name|enumerate_item
parameter_list|()
block|{
name|char
name|temp
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|current_enumtype
operator|==
name|ENUM_ALPHA
condition|)
block|{
if|if
condition|(
name|current_enumval
operator|==
operator|(
literal|'z'
operator|+
literal|1
operator|)
operator|||
name|current_enumval
operator|==
operator|(
literal|'Z'
operator|+
literal|1
operator|)
condition|)
block|{
name|current_enumval
operator|=
operator|(
operator|(
name|current_enumval
operator|-
literal|1
operator|)
operator|==
literal|'z'
condition|?
literal|'a'
else|:
literal|'A'
operator|)
expr_stmt|;
name|warning
argument_list|(
literal|"Lettering overflow, restarting at %c"
argument_list|,
name|current_enumval
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%c. "
argument_list|,
name|current_enumval
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%d. "
argument_list|,
name|current_enumval
argument_list|)
expr_stmt|;
name|indent
argument_list|(
name|output_column
operator|+=
operator|(
name|current_indent
operator|-
name|strlen
argument_list|(
name|temp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|current_enumval
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is where the work for all the "insertion" style    commands is done.  A huge switch statement handles the    various setups, and generic code is on both sides. */
end_comment

begin_function
name|void
name|begin_insertion
parameter_list|(
name|type
parameter_list|)
name|enum
name|insertion_type
name|type
decl_stmt|;
block|{
name|int
name|no_discard
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|defun_insertion
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|push_insertion
argument_list|(
name|type
argument_list|,
name|strdup
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|no_discard
operator|++
expr_stmt|;
block|}
else|else
name|push_insertion
argument_list|(
name|type
argument_list|,
name|get_item_function
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|menu
case|:
if|if
condition|(
operator|!
name|no_headers
condition|)
name|close_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|no_indent
operator|=
literal|0
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|no_headers
condition|)
name|add_word
argument_list|(
literal|"* Menu:\n"
argument_list|)
expr_stmt|;
name|in_menu
operator|++
expr_stmt|;
name|no_discard
operator|++
expr_stmt|;
break|break;
case|case
name|detailmenu
case|:
if|if
condition|(
operator|!
name|in_menu
condition|)
block|{
if|if
condition|(
operator|!
name|no_headers
condition|)
name|close_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|no_indent
operator|=
literal|0
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|no_discard
operator|++
expr_stmt|;
block|}
name|in_detailmenu
operator|++
expr_stmt|;
break|break;
case|case
name|direntry
case|:
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|no_indent
operator|=
literal|0
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|insert_string
argument_list|(
literal|"START-INFO-DIR-ENTRY\n"
argument_list|)
expr_stmt|;
break|break;
comment|/* I think @quotation is meant to do filling. 	 If you don't want filling, then use @display. */
case|case
name|quotation
case|:
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|last_char_was_newline
operator|=
name|no_indent
operator|=
literal|0
expr_stmt|;
name|indented_fill
operator|=
name|filling_enabled
operator|=
literal|1
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
break|break;
case|case
name|display
case|:
case|case
name|example
case|:
case|case
name|smallexample
case|:
case|case
name|lisp
case|:
case|case
name|smalllisp
case|:
comment|/* Just like @example, but no indentation. */
case|case
name|format
case|:
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|in_fixed_width_font
operator|++
expr_stmt|;
name|filling_enabled
operator|=
literal|0
expr_stmt|;
name|last_char_was_newline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|format
condition|)
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
break|break;
case|case
name|multitable
case|:
name|do_multitable
argument_list|()
expr_stmt|;
break|break;
case|case
name|table
case|:
case|case
name|ftable
case|:
case|case
name|vtable
case|:
case|case
name|itemize
case|:
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INDENT_PARAGRAPHS_IN_TABLE
argument_list|)
name|inhibit_paragraph_indentation
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* !INDENT_PARAGRAPHS_IN_TABLE */
comment|/* Make things work for losers who forget the itemize syntax. */
if|if
condition|(
name|allow_lax_format
operator|&&
operator|(
name|type
operator|==
name|itemize
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|insertion_stack
operator|->
name|item_function
operator|)
condition|)
block|{
name|free
argument_list|(
name|insertion_stack
operator|->
name|item_function
argument_list|)
expr_stmt|;
name|insertion_stack
operator|->
name|item_function
operator|=
name|strdup
argument_list|(
literal|"@bullet"
argument_list|)
expr_stmt|;
name|insertion_stack
operator|->
name|item_function
index|[
literal|0
index|]
operator|=
name|COMMAND_PREFIX
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|insertion_stack
operator|->
name|item_function
condition|)
block|{
name|line_error
argument_list|(
literal|"%s requires an argument: the formatter for %citem"
argument_list|,
name|insertion_type_pname
argument_list|(
name|type
argument_list|)
argument_list|,
name|COMMAND_PREFIX
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|enumerate
case|:
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|no_indent
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INDENT_PARAGRAPHS_IN_TABLE
argument_list|)
name|inhibit_paragraph_indentation
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* !INDENT_PARAGRAPHS_IN_TABLE */
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|enumeration_arg
argument_list|)
condition|)
name|start_enumerating
argument_list|(
name|atoi
argument_list|(
name|enumeration_arg
argument_list|)
argument_list|,
name|ENUM_DIGITS
argument_list|)
expr_stmt|;
else|else
name|start_enumerating
argument_list|(
operator|*
name|enumeration_arg
argument_list|,
name|ENUM_ALPHA
argument_list|)
expr_stmt|;
break|break;
comment|/* Does nothing special in makeinfo. */
case|case
name|group
case|:
comment|/* Only close the paragraph if we are not inside of an @example. */
if|if
condition|(
operator|!
name|insertion_stack
operator|->
name|next
operator|||
name|insertion_stack
operator|->
name|next
operator|->
name|insertion
operator|!=
name|example
condition|)
name|close_single_paragraph
argument_list|()
expr_stmt|;
break|break;
comment|/* Insertions that are no-ops in info, but do something in TeX. */
case|case
name|ifinfo
case|:
case|case
name|ifset
case|:
case|case
name|ifclear
case|:
case|case
name|cartouche
case|:
if|if
condition|(
name|in_menu
condition|)
name|no_discard
operator|++
expr_stmt|;
break|break;
case|case
name|deffn
case|:
case|case
name|defun
case|:
case|case
name|defmac
case|:
case|case
name|defspec
case|:
case|case
name|defvr
case|:
case|case
name|defvar
case|:
case|case
name|defopt
case|:
case|case
name|deftypefn
case|:
case|case
name|deftypefun
case|:
case|case
name|deftypevr
case|:
case|case
name|deftypevar
case|:
case|case
name|defcv
case|:
case|case
name|defivar
case|:
case|case
name|defop
case|:
case|case
name|defmethod
case|:
case|case
name|deftypemethod
case|:
case|case
name|deftp
case|:
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|1
expr_stmt|;
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
name|no_indent
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|flushleft
case|:
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
name|no_indent
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|flushright
case|:
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
name|no_indent
operator|=
literal|0
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|force_flush_right
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|no_discard
condition|)
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try to end the insertion with the specified TYPE.    TYPE, with a value of bad_type,  gets translated to match    the value currently on top of the stack.    Otherwise, if TYPE doesn't match the top of the insertion stack,    give error. */
end_comment

begin_function
name|void
name|end_insertion
parameter_list|(
name|type
parameter_list|)
name|enum
name|insertion_type
name|type
decl_stmt|;
block|{
name|enum
name|insertion_type
name|temp_type
decl_stmt|;
if|if
condition|(
operator|!
name|insertion_level
condition|)
return|return;
name|temp_type
operator|=
name|current_insertion_type
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|bad_type
condition|)
name|type
operator|=
name|temp_type
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|temp_type
condition|)
block|{
name|line_error
argument_list|(
literal|"`%cend' expected `%s', but saw `%s'"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|insertion_type_pname
argument_list|(
name|temp_type
argument_list|)
argument_list|,
name|insertion_type_pname
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|pop_insertion
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
comment|/* Insertions which have no effect on paragraph formatting. */
case|case
name|ifinfo
case|:
case|case
name|ifset
case|:
case|case
name|ifclear
case|:
break|break;
case|case
name|direntry
case|:
name|insert_string
argument_list|(
literal|"END-INFO-DIR-ENTRY\n\n"
argument_list|)
expr_stmt|;
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
break|break;
case|case
name|detailmenu
case|:
name|in_detailmenu
operator|--
expr_stmt|;
comment|/* No longer hacking menus. */
if|if
condition|(
operator|!
name|in_menu
condition|)
block|{
if|if
condition|(
operator|!
name|no_headers
condition|)
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|menu
case|:
name|in_menu
operator|--
expr_stmt|;
comment|/* No longer hacking menus. */
if|if
condition|(
operator|!
name|no_headers
condition|)
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
break|break;
case|case
name|multitable
case|:
name|end_multitable
argument_list|()
expr_stmt|;
break|break;
case|case
name|enumerate
case|:
name|stop_enumerating
argument_list|()
expr_stmt|;
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
break|break;
case|case
name|flushleft
case|:
case|case
name|group
case|:
case|case
name|cartouche
case|:
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
break|break;
case|case
name|format
case|:
case|case
name|display
case|:
case|case
name|example
case|:
case|case
name|smallexample
case|:
case|case
name|lisp
case|:
case|case
name|smalllisp
case|:
case|case
name|quotation
case|:
comment|/* @format is the only fixed_width insertion without a change 	 in indentation. */
if|if
condition|(
name|type
operator|!=
name|format
condition|)
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
comment|/* The ending of one of these insertions always marks the 	 start of a new paragraph. */
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
break|break;
case|case
name|table
case|:
case|case
name|ftable
case|:
case|case
name|vtable
case|:
case|case
name|itemize
case|:
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
break|break;
case|case
name|flushright
case|:
name|force_flush_right
operator|--
expr_stmt|;
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
break|break;
comment|/* Handle the @defun style insertions with a default clause. */
default|default:
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Insertions cannot cross certain boundaries, such as node beginnings.  In    code that creates such boundaries, you should call discard_insertions ()    before doing anything else.  It prints the errors for you, and cleans up    the insertion stack. */
end_comment

begin_function
name|void
name|discard_insertions
parameter_list|()
block|{
name|int
name|real_line_number
init|=
name|line_number
decl_stmt|;
while|while
condition|(
name|insertion_stack
condition|)
block|{
if|if
condition|(
name|insertion_stack
operator|->
name|insertion
operator|==
name|ifinfo
operator|||
name|insertion_stack
operator|->
name|insertion
operator|==
name|ifset
operator|||
name|insertion_stack
operator|->
name|insertion
operator|==
name|ifclear
condition|)
break|break;
else|else
block|{
name|char
modifier|*
name|offender
decl_stmt|;
name|char
modifier|*
name|current_filename
decl_stmt|;
name|current_filename
operator|=
name|input_filename
expr_stmt|;
name|offender
operator|=
operator|(
name|char
operator|*
operator|)
name|insertion_type_pname
argument_list|(
name|insertion_stack
operator|->
name|insertion
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|insertion_stack
operator|->
name|filename
expr_stmt|;
name|line_number
operator|=
name|insertion_stack
operator|->
name|line_number
expr_stmt|;
name|line_error
argument_list|(
literal|"This `%s' doesn't have a matching `%cend %s'"
argument_list|,
name|offender
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|offender
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|current_filename
expr_stmt|;
name|pop_insertion
argument_list|()
expr_stmt|;
block|}
block|}
name|line_number
operator|=
name|real_line_number
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The Texinfo commands. */
end_comment

begin_comment
comment|/* Commands which insert their own names. */
end_comment

begin_function
name|void
name|insert_self
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_word
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|insert_space
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Force a line break in the output. */
end_comment

begin_function
name|void
name|cm_asterisk
parameter_list|()
block|{
name|close_single_paragraph
argument_list|()
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ASTERISK_NEW_PARAGRAPH
argument_list|)
name|cm_noindent
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* ASTERISK_NEW_PARAGRAPH */
block|}
end_function

begin_comment
comment|/* Insert ellipsis. */
end_comment

begin_function
name|void
name|cm_dots
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_word
argument_list|(
literal|"..."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert ellipsis for sentence end. */
end_comment

begin_function
name|void
name|cm_enddots
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_word
argument_list|(
literal|"...."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_bullet
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_char
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_minus
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert "TeX". */
end_comment

begin_function
name|void
name|cm_TeX
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_word
argument_list|(
literal|"TeX"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copyright symbol.  */
end_comment

begin_function
name|void
name|cm_copyright
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_word
argument_list|(
literal|"(C)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Accent commands that take explicit arguments.  */
end_comment

begin_function
name|void
name|cm_accent
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
literal|"dotaccent"
argument_list|)
operator|==
literal|0
condition|)
comment|/* overdot */
name|add_char
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
literal|"H"
argument_list|)
operator|==
literal|0
condition|)
comment|/* Hungarian umlaut */
name|add_word
argument_list|(
literal|"''"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
literal|"ringaccent"
argument_list|)
operator|==
literal|0
condition|)
name|add_char
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
literal|"tieaccent"
argument_list|)
operator|==
literal|0
condition|)
name|add_char
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
literal|"u"
argument_list|)
operator|==
literal|0
condition|)
comment|/* breve */
name|add_char
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
literal|"v"
argument_list|)
operator|==
literal|0
condition|)
comment|/* hacek/check */
name|add_char
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
name|END
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
literal|"ubaraccent"
argument_list|)
operator|==
literal|0
condition|)
comment|/* underbar */
name|add_char
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
literal|"udotaccent"
argument_list|)
operator|==
literal|0
condition|)
comment|/* underdot */
name|add_word
argument_list|(
literal|"-."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
literal|","
argument_list|)
operator|==
literal|0
condition|)
comment|/* cedilla */
name|add_word
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Non-English letters/characters that don't insert themselves.  */
end_comment

begin_function
name|void
name|cm_special_char
parameter_list|(
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|command
operator|==
literal|'L'
operator|||
operator|*
name|command
operator|==
literal|'l'
operator|||
operator|*
name|command
operator|==
literal|'O'
operator|||
operator|*
name|command
operator|==
literal|'o'
operator|)
operator|&&
name|command
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
comment|/* Lslash lslash Oslash oslash */
name|add_char
argument_list|(
operator|*
name|command
argument_list|)
expr_stmt|;
name|add_char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
literal|"exclamdown"
argument_list|)
operator|==
literal|0
condition|)
name|add_char
argument_list|(
literal|'!'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
literal|"pounds"
argument_list|)
operator|==
literal|0
condition|)
name|add_char
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
literal|"questiondown"
argument_list|)
operator|==
literal|0
condition|)
name|add_char
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"How did @%s end up in cm_special_char?\n"
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dotless i or j.  */
end_comment

begin_function
name|void
name|cm_dotless
parameter_list|(
name|arg
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|int
name|arg
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
block|{
if|if
condition|(
name|output_paragraph
index|[
name|start
index|]
operator|!=
literal|'i'
operator|&&
name|output_paragraph
index|[
name|start
index|]
operator|!=
literal|'j'
condition|)
comment|/* This error message isn't perfect if the argument is multiple            characters, but it doesn't seem worth getting right.  */
name|line_error
argument_list|(
literal|"%c%s expects `i' or `j' as argument, not `%c'"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|,
name|output_paragraph
index|[
name|start
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|end
operator|-
name|start
operator|!=
literal|1
condition|)
name|line_error
argument_list|(
literal|"%c%s expects a single character `i' or `j' as argument"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/* We've already inserted the `i' or `j', so nothing to do.  */
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__osf__
argument_list|)
end_if

begin_define
define|#
directive|define
name|LOCALTIME_CAST
parameter_list|(
name|x
parameter_list|)
value|(time_t *)(x)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LOCALTIME_CAST
parameter_list|(
name|x
parameter_list|)
value|(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|cm_today
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|months
index|[
literal|12
index|]
init|=
block|{
literal|"January"
block|,
literal|"February"
block|,
literal|"March"
block|,
literal|"April"
block|,
literal|"May"
block|,
literal|"June"
block|,
literal|"July"
block|,
literal|"August"
block|,
literal|"September"
block|,
literal|"October"
block|,
literal|"November"
block|,
literal|"December"
block|}
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
name|long
name|timer
init|=
name|time
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|struct
name|tm
modifier|*
name|ts
init|=
name|localtime
argument_list|(
name|LOCALTIME_CAST
argument_list|(
operator|&
name|timer
argument_list|)
argument_list|)
decl_stmt|;
name|add_word_args
argument_list|(
literal|"%d %s %d"
argument_list|,
operator|(
name|ts
operator|->
name|tm_mday
operator|)
argument_list|,
operator|(
name|months
index|[
name|ts
operator|->
name|tm_mon
index|]
operator|)
argument_list|,
operator|(
operator|(
name|ts
operator|->
name|tm_year
operator|)
operator|+
literal|1900
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|cm_code
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
specifier|extern
name|int
name|printing_index
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
name|in_fixed_width_font
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|printing_index
condition|)
name|add_char
argument_list|(
literal|'`'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|printing_index
condition|)
name|add_char
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|cm_kbd
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
comment|/* People use @kbd in an example to get the "user input" font.      We don't want quotes in that case.  */
if|if
condition|(
operator|!
name|in_fixed_width_font
condition|)
name|cm_code
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_angle_brackets
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
name|add_char
argument_list|(
name|arg
operator|==
name|START
condition|?
literal|'<'
else|:
literal|'>'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert the character at position into a true control character. */
end_comment

begin_function
name|void
name|cm_ctrl
parameter_list|(
name|arg
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|int
name|arg
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
comment|/* Should we allow multiple character arguments?  I think yes. */
if|if
condition|(
name|arg
operator|==
name|END
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|character
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NO_MULTIPLE_CTRL
argument_list|)
if|if
condition|(
operator|(
name|end
operator|-
name|start
operator|)
operator|!=
literal|1
condition|)
name|line_error
argument_list|(
literal|"%c%s expects a single character as an argument"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
block|{
name|character
operator|=
name|output_paragraph
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|isletter
argument_list|(
name|character
argument_list|)
condition|)
name|output_paragraph
index|[
name|i
index|]
operator|=
name|CTL
argument_list|(
name|coerce_to_upper
argument_list|(
name|character
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Handle a command that switches to a non-fixed-width font.  */
end_comment

begin_function
name|void
name|not_fixed_width
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|in_fixed_width_font
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Small caps in makeinfo has to do just all caps. */
end_comment

begin_function
name|void
name|cm_sc
parameter_list|(
name|arg
parameter_list|,
name|start_pos
parameter_list|,
name|end_pos
parameter_list|)
name|int
name|arg
decl_stmt|,
name|start_pos
decl_stmt|,
name|end_pos
decl_stmt|;
block|{
name|not_fixed_width
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|END
condition|)
block|{
while|while
condition|(
name|start_pos
operator|<
name|end_pos
condition|)
block|{
name|output_paragraph
index|[
name|start_pos
index|]
operator|=
name|coerce_to_upper
argument_list|(
name|output_paragraph
index|[
name|start_pos
index|]
argument_list|)
expr_stmt|;
name|start_pos
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* @var in makeinfo just uppercases the text. */
end_comment

begin_function
name|void
name|cm_var
parameter_list|(
name|arg
parameter_list|,
name|start_pos
parameter_list|,
name|end_pos
parameter_list|)
name|int
name|arg
decl_stmt|,
name|start_pos
decl_stmt|,
name|end_pos
decl_stmt|;
block|{
name|not_fixed_width
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|END
condition|)
block|{
while|while
condition|(
name|start_pos
operator|<
name|end_pos
condition|)
block|{
name|output_paragraph
index|[
name|start_pos
index|]
operator|=
name|coerce_to_upper
argument_list|(
name|output_paragraph
index|[
name|start_pos
index|]
argument_list|)
expr_stmt|;
name|start_pos
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|cm_dfn
parameter_list|(
name|arg
parameter_list|,
name|position
parameter_list|)
name|int
name|arg
decl_stmt|,
name|position
decl_stmt|;
block|{
name|add_char
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_emph
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
name|add_char
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_strong
parameter_list|(
name|arg
parameter_list|,
name|position
parameter_list|)
name|int
name|arg
decl_stmt|,
name|position
decl_stmt|;
block|{
name|cm_emph
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_cite
parameter_list|(
name|arg
parameter_list|,
name|position
parameter_list|)
name|int
name|arg
decl_stmt|,
name|position
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_word
argument_list|(
literal|"`"
argument_list|)
expr_stmt|;
else|else
name|add_word
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* No highlighting, but argument switches fonts.  */
end_comment

begin_function
name|void
name|cm_not_fixed_width
parameter_list|(
name|arg
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|int
name|arg
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
name|not_fixed_width
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Various commands are NOP's. */
end_comment

begin_function
name|void
name|cm_no_op
parameter_list|()
block|{ }
end_function

begin_comment
comment|/* Prevent the argument from being split across two lines. */
end_comment

begin_function
name|void
name|cm_w
parameter_list|(
name|arg
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|int
name|arg
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|non_splitting_words
operator|++
expr_stmt|;
else|else
name|non_splitting_words
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Explain that this command is obsolete, thus the user shouldn't    do anything with it. */
end_comment

begin_function
name|void
name|cm_obsolete
parameter_list|(
name|arg
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|int
name|arg
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|warning
argument_list|(
literal|"The command `%c%s' is obsolete"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert the text following input_text_offset up to the end of the line    in a new, separate paragraph.  Directly underneath it, insert a    line of WITH_CHAR, the same length of the inserted text. */
end_comment

begin_function
name|void
name|insert_and_underscore
parameter_list|(
name|with_char
parameter_list|)
name|int
name|with_char
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|int
name|old_no_indent
decl_stmt|,
name|starting_pos
decl_stmt|,
name|ending_pos
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|0
expr_stmt|;
name|old_no_indent
operator|=
name|no_indent
expr_stmt|;
name|no_indent
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
if|if
condition|(
name|macro_expansion_output_stream
condition|)
name|append_to_expansion_output
argument_list|(
name|input_text_offset
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MACROS */
name|get_rest_of_line
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
name|starting_pos
operator|=
name|output_position
operator|+
name|output_paragraph_offset
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
if|if
condition|(
name|macro_expansion_output_stream
condition|)
block|{
name|char
modifier|*
name|temp1
decl_stmt|;
name|temp1
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp1
argument_list|,
literal|"%s\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|remember_itext
argument_list|(
name|input_text
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
name|me_execute_string
argument_list|(
name|temp1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp1
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* HAVE_MACROS */
name|execute_string
argument_list|(
literal|"%s\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|ending_pos
operator|=
name|output_position
operator|+
name|output_paragraph_offset
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|ending_pos
operator|-
name|starting_pos
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|add_char
argument_list|(
name|with_char
argument_list|)
expr_stmt|;
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
literal|1
expr_stmt|;
name|no_indent
operator|=
name|old_no_indent
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Here is a structure which associates sectioning commands with    an integer, hopefully to reflect the `depth' of the current    section. */
end_comment

begin_struct
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|level
decl_stmt|;
block|}
name|section_alist
index|[]
init|=
block|{
block|{
literal|"unnumberedsubsubsec"
block|,
literal|5
block|}
block|,
block|{
literal|"unnumberedsubsec"
block|,
literal|4
block|}
block|,
block|{
literal|"unnumberedsec"
block|,
literal|3
block|}
block|,
block|{
literal|"unnumbered"
block|,
literal|2
block|}
block|,
block|{
literal|"appendixsubsubsec"
block|,
literal|5
block|}
block|,
block|{
literal|"appendixsubsec"
block|,
literal|4
block|}
block|,
block|{
literal|"appendixsec"
block|,
literal|3
block|}
block|,
block|{
literal|"appendixsection"
block|,
literal|3
block|}
block|,
block|{
literal|"appendix"
block|,
literal|2
block|}
block|,
block|{
literal|"subsubsec"
block|,
literal|5
block|}
block|,
block|{
literal|"subsubsection"
block|,
literal|5
block|}
block|,
block|{
literal|"subsection"
block|,
literal|4
block|}
block|,
block|{
literal|"section"
block|,
literal|3
block|}
block|,
block|{
literal|"chapter"
block|,
literal|2
block|}
block|,
block|{
literal|"top"
block|,
literal|1
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Amount to offset the name of sectioning commands to levels by. */
end_comment

begin_decl_stmt
name|int
name|section_alist_offset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Shift the meaning of @section to @chapter. */
end_comment

begin_function
name|void
name|cm_raisesections
parameter_list|()
block|{
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|section_alist_offset
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Shift the meaning of @chapter to @section. */
end_comment

begin_function
name|void
name|cm_lowersections
parameter_list|()
block|{
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|section_alist_offset
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return an integer which identifies the type section present in TEXT. */
end_comment

begin_function
name|int
name|what_section
parameter_list|(
name|text
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|find_section_command
label|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|text
index|[
name|j
index|]
operator|&&
name|cr_or_whitespace
argument_list|(
name|text
index|[
name|j
index|]
argument_list|)
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|text
index|[
name|j
index|]
operator|!=
name|COMMAND_PREFIX
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|text
operator|=
name|text
operator|+
name|j
operator|+
literal|1
expr_stmt|;
comment|/* We skip @c, @comment, and @?index commands. */
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|text
argument_list|,
literal|"comment"
argument_list|,
name|strlen
argument_list|(
literal|"comment"
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|text
index|[
literal|0
index|]
operator|==
literal|'c'
operator|&&
name|cr_or_whitespace
argument_list|(
name|text
index|[
literal|1
index|]
argument_list|)
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|text
operator|+
literal|1
argument_list|,
literal|"index"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
while|while
condition|(
operator|*
name|text
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
goto|goto
name|find_section_command
goto|;
block|}
comment|/* Handle italicized sectioning commands. */
if|if
condition|(
operator|*
name|text
operator|==
literal|'i'
condition|)
name|text
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|text
index|[
name|j
index|]
operator|&&
operator|!
name|cr_or_whitespace
argument_list|(
name|text
index|[
name|j
index|]
argument_list|)
condition|;
name|j
operator|++
control|)
empty_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|t
operator|=
name|section_alist
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
name|strlen
argument_list|(
name|t
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|t
argument_list|,
name|text
argument_list|,
name|j
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|return_val
decl_stmt|;
name|return_val
operator|=
operator|(
name|section_alist
index|[
name|i
index|]
operator|.
name|level
operator|+
name|section_alist_offset
operator|)
expr_stmt|;
if|if
condition|(
name|return_val
operator|<
literal|0
condition|)
name|return_val
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|return_val
operator|>
literal|5
condition|)
name|return_val
operator|=
literal|5
expr_stmt|;
return|return
operator|(
name|return_val
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set the level of @top to LEVEL.  Return the old level of @top. */
end_comment

begin_function
name|int
name|set_top_section_level
parameter_list|(
name|level
parameter_list|)
name|int
name|level
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|result
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|section_alist
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|section_alist
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"top"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|section_alist
index|[
name|i
index|]
operator|.
name|level
expr_stmt|;
name|section_alist
index|[
name|i
index|]
operator|.
name|level
operator|=
name|level
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Treat this just like @unnumbered.  The only difference is    in node defaulting. */
end_comment

begin_function
name|void
name|cm_top
parameter_list|()
block|{
comment|/* It is an error to have more than one @top. */
if|if
condition|(
name|top_node_seen
condition|)
block|{
name|TAG_ENTRY
modifier|*
name|tag
init|=
name|tag_table
decl_stmt|;
name|line_error
argument_list|(
literal|"There already is a node having %ctop as a section"
argument_list|,
name|COMMAND_PREFIX
argument_list|)
expr_stmt|;
while|while
condition|(
name|tag
operator|!=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|tag
operator|->
name|flags
operator|&
name|IS_TOP
operator|)
condition|)
block|{
name|int
name|old_line_number
init|=
name|line_number
decl_stmt|;
name|char
modifier|*
name|old_input_filename
init|=
name|input_filename
decl_stmt|;
name|line_number
operator|=
name|tag
operator|->
name|line_no
expr_stmt|;
name|input_filename
operator|=
name|tag
operator|->
name|filename
expr_stmt|;
name|line_error
argument_list|(
literal|"Here is the %ctop node"
argument_list|,
name|COMMAND_PREFIX
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|old_input_filename
expr_stmt|;
name|line_number
operator|=
name|old_line_number
expr_stmt|;
return|return;
block|}
name|tag
operator|=
name|tag
operator|->
name|next_ent
expr_stmt|;
block|}
block|}
else|else
block|{
name|top_node_seen
operator|=
literal|1
expr_stmt|;
comment|/* It is an error to use @top before you have used @node. */
if|if
condition|(
operator|!
name|tag_table
condition|)
block|{
name|char
modifier|*
name|top_name
decl_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|top_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|top_name
argument_list|)
expr_stmt|;
name|line_error
argument_list|(
literal|"%ctop used before %cnode, defaulting to %s"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|top_name
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"@node Top, , (dir), (dir)\n@top %s\n"
argument_list|,
name|top_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|cm_unnumbered
argument_list|()
expr_stmt|;
comment|/* The most recently defined node is the top node. */
name|tag_table
operator|->
name|flags
operator||=
name|IS_TOP
expr_stmt|;
comment|/* Now set the logical hierarchical level of the Top node. */
block|{
name|int
name|orig_offset
init|=
name|input_text_offset
decl_stmt|;
name|input_text_offset
operator|=
name|search_forward
argument_list|(
name|node_search_string
argument_list|,
name|orig_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_text_offset
operator|>
literal|0
condition|)
block|{
name|int
name|this_section
decl_stmt|;
comment|/* We have encountered a non-top node, so mark that one exists. */
name|non_top_node_seen
operator|=
literal|1
expr_stmt|;
comment|/* Move to the end of this line, and find out what the 	       sectioning command is here. */
while|while
condition|(
name|input_text
index|[
name|input_text_offset
index|]
operator|!=
literal|'\n'
condition|)
name|input_text_offset
operator|++
expr_stmt|;
if|if
condition|(
name|input_text_offset
operator|<
name|size_of_input_text
condition|)
name|input_text_offset
operator|++
expr_stmt|;
name|this_section
operator|=
name|what_section
argument_list|(
name|input_text
operator|+
name|input_text_offset
argument_list|)
expr_stmt|;
comment|/* If we found a sectioning command, then give the top section 	       a level of this section - 1. */
if|if
condition|(
name|this_section
operator|!=
operator|-
literal|1
condition|)
name|set_top_section_level
argument_list|(
name|this_section
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|input_text_offset
operator|=
name|orig_offset
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Organized by level commands.  That is, "*" == chapter, "=" == section. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|scoring_characters
init|=
literal|"*=-."
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|sectioning_underscore
parameter_list|(
name|command
parameter_list|)
name|char
modifier|*
name|command
decl_stmt|;
block|{
name|char
name|character
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|level
decl_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
name|command
argument_list|)
argument_list|)
expr_stmt|;
name|temp
index|[
literal|0
index|]
operator|=
name|COMMAND_PREFIX
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|temp
index|[
literal|1
index|]
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|level
operator|=
name|what_section
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|level
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|level
operator|<
literal|0
condition|)
name|level
operator|=
literal|0
expr_stmt|;
name|character
operator|=
name|scoring_characters
index|[
name|level
index|]
expr_stmt|;
name|insert_and_underscore
argument_list|(
name|character
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The command still works, but prints a warning message in addition. */
end_comment

begin_function
name|void
name|cm_ideprecated
parameter_list|(
name|arg
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|int
name|arg
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
name|warning
argument_list|(
literal|"The command `%c%s' is obsolete; use `%c%s' instead"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sectioning_underscore
argument_list|(
name|command
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The remainder of the text on this line is a chapter heading. */
end_comment

begin_function
name|void
name|cm_chapter
parameter_list|()
block|{
name|sectioning_underscore
argument_list|(
literal|"chapter"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The remainder of the text on this line is a section heading. */
end_comment

begin_function
name|void
name|cm_section
parameter_list|()
block|{
name|sectioning_underscore
argument_list|(
literal|"section"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The remainder of the text on this line is a subsection heading. */
end_comment

begin_function
name|void
name|cm_subsection
parameter_list|()
block|{
name|sectioning_underscore
argument_list|(
literal|"subsection"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The remainder of the text on this line is a subsubsection heading. */
end_comment

begin_function
name|void
name|cm_subsubsection
parameter_list|()
block|{
name|sectioning_underscore
argument_list|(
literal|"subsubsection"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The remainder of the text on this line is an unnumbered heading. */
end_comment

begin_function
name|void
name|cm_unnumbered
parameter_list|()
block|{
name|cm_chapter
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The remainder of the text on this line is an unnumbered section heading. */
end_comment

begin_function
name|void
name|cm_unnumberedsec
parameter_list|()
block|{
name|cm_section
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The remainder of the text on this line is an unnumbered    subsection heading. */
end_comment

begin_function
name|void
name|cm_unnumberedsubsec
parameter_list|()
block|{
name|cm_subsection
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The remainder of the text on this line is an unnumbered    subsubsection heading. */
end_comment

begin_function
name|void
name|cm_unnumberedsubsubsec
parameter_list|()
block|{
name|cm_subsubsection
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The remainder of the text on this line is an appendix heading. */
end_comment

begin_function
name|void
name|cm_appendix
parameter_list|()
block|{
name|cm_chapter
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The remainder of the text on this line is an appendix section heading. */
end_comment

begin_function
name|void
name|cm_appendixsec
parameter_list|()
block|{
name|cm_section
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The remainder of the text on this line is an appendix subsection heading. */
end_comment

begin_function
name|void
name|cm_appendixsubsec
parameter_list|()
block|{
name|cm_subsection
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The remainder of the text on this line is an appendix    subsubsection heading. */
end_comment

begin_function
name|void
name|cm_appendixsubsubsec
parameter_list|()
block|{
name|cm_subsubsection
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compatibility functions substitute for chapter, section, etc. */
end_comment

begin_function
name|void
name|cm_majorheading
parameter_list|()
block|{
name|cm_chapheading
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_chapheading
parameter_list|()
block|{
name|cm_chapter
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_heading
parameter_list|()
block|{
name|cm_section
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_subheading
parameter_list|()
block|{
name|cm_subsection
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_subsubheading
parameter_list|()
block|{
name|cm_subsubsection
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		   Adding nodes, and making tags		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Start a new tag table. */
end_comment

begin_function
name|void
name|init_tag_table
parameter_list|()
block|{
while|while
condition|(
name|tag_table
operator|!=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|NULL
condition|)
block|{
name|TAG_ENTRY
modifier|*
name|temp
init|=
name|tag_table
decl_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|prev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|up
argument_list|)
expr_stmt|;
name|tag_table
operator|=
name|tag_table
operator|->
name|next_ent
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|write_tag_table
parameter_list|()
block|{
name|write_tag_table_internal
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Not indirect. */
block|}
end_function

begin_function
name|void
name|write_tag_table_indirect
parameter_list|()
block|{
name|write_tag_table_internal
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out the contents of the existing tag table.    INDIRECT_P says how to format the output. */
end_comment

begin_function
name|void
name|write_tag_table_internal
parameter_list|(
name|indirect_p
parameter_list|)
name|int
name|indirect_p
decl_stmt|;
block|{
name|TAG_ENTRY
modifier|*
name|node
init|=
name|tag_table
decl_stmt|;
name|int
name|old_indent
init|=
name|no_indent
decl_stmt|;
name|no_indent
operator|=
literal|1
expr_stmt|;
name|filling_enabled
operator|=
literal|0
expr_stmt|;
name|must_start_paragraph
operator|=
literal|0
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|indirect_p
condition|)
block|{
name|no_indent
operator|=
literal|1
expr_stmt|;
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|add_word_args
argument_list|(
literal|"\037\nTag Table:\n%s"
argument_list|,
name|indirect_p
condition|?
literal|"(Indirect)\n"
else|:
literal|""
argument_list|)
expr_stmt|;
while|while
condition|(
name|node
operator|!=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|NULL
condition|)
block|{
name|execute_string
argument_list|(
literal|"Node: %s"
argument_list|,
name|node
operator|->
name|node
argument_list|)
expr_stmt|;
name|add_word_args
argument_list|(
literal|"\177%d\n"
argument_list|,
name|node
operator|->
name|position
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|->
name|next_ent
expr_stmt|;
block|}
name|add_word
argument_list|(
literal|"\037\nEnd Tag Table\n"
argument_list|)
expr_stmt|;
name|flush_output
argument_list|()
expr_stmt|;
name|no_indent
operator|=
name|old_indent
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|get_node_token
parameter_list|()
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|get_until_in_line
argument_list|(
literal|","
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|','
condition|)
name|input_text_offset
operator|++
expr_stmt|;
name|canon_white
argument_list|(
name|string
argument_list|)
expr_stmt|;
comment|/* Force all versions of "top" to be "Top". */
name|normalize_node_name
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
operator|(
name|string
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert "top" and friends into "Top". */
end_comment

begin_function
name|void
name|normalize_node_name
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|string
argument_list|,
literal|"Top"
argument_list|)
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"Top"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up NAME in the tag table, and return the associated    tag_entry.  If the node is not in the table return NULL. */
end_comment

begin_function
name|TAG_ENTRY
modifier|*
name|find_node
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|TAG_ENTRY
modifier|*
name|tag
init|=
name|tag_table
decl_stmt|;
while|while
condition|(
name|tag
operator|!=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|tag
operator|->
name|node
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|tag
operator|)
return|;
name|tag
operator|=
name|tag
operator|->
name|next_ent
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Remember NODE and associates. */
end_comment

begin_function
name|void
name|remember_node
parameter_list|(
name|node
parameter_list|,
name|prev
parameter_list|,
name|next
parameter_list|,
name|up
parameter_list|,
name|position
parameter_list|,
name|line_no
parameter_list|,
name|no_warn
parameter_list|)
name|char
modifier|*
name|node
decl_stmt|,
decl|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|up
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|position
decl_stmt|,
name|line_no
decl_stmt|,
name|no_warn
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Check for existence of this tag already. */
if|if
condition|(
name|validating
condition|)
block|{
specifier|register
name|TAG_ENTRY
modifier|*
name|tag
init|=
name|find_node
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|tag
condition|)
block|{
name|line_error
argument_list|(
literal|"Node `%s' multiply defined (%d is first definition)"
argument_list|,
name|node
argument_list|,
name|tag
operator|->
name|line_no
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* First, make this the current node. */
name|current_node
operator|=
name|node
expr_stmt|;
comment|/* Now add it to the list. */
block|{
name|TAG_ENTRY
modifier|*
name|new
init|=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TAG_ENTRY
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|node
operator|=
name|node
expr_stmt|;
name|new
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|new
operator|->
name|up
operator|=
name|up
expr_stmt|;
name|new
operator|->
name|position
operator|=
name|position
expr_stmt|;
name|new
operator|->
name|line_no
operator|=
name|line_no
expr_stmt|;
name|new
operator|->
name|filename
operator|=
name|node_filename
expr_stmt|;
name|new
operator|->
name|touched
operator|=
literal|0
expr_stmt|;
comment|/* not yet referenced. */
name|new
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|no_warn
condition|)
name|new
operator|->
name|flags
operator||=
name|NO_WARN
expr_stmt|;
name|new
operator|->
name|next_ent
operator|=
name|tag_table
expr_stmt|;
name|tag_table
operator|=
name|new
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* The order is: nodename, nextnode, prevnode, upnode.    If all of the NEXT, PREV, and UP fields are empty, they are defaulted.    You must follow a node command which has those fields defaulted    with a sectioning command (e.g. @chapter) giving the "level" of that node.    It is an error not to do so.    The defaults come from the menu in this node's parent. */
end_comment

begin_function
name|void
name|cm_node
parameter_list|()
block|{
name|char
modifier|*
name|node
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|up
decl_stmt|;
name|int
name|new_node_pos
decl_stmt|,
name|defaulting
decl_stmt|,
name|this_section
decl_stmt|,
name|no_warn
init|=
literal|0
decl_stmt|;
specifier|extern
name|int
name|already_outputting_pending_notes
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
literal|"nwnode"
argument_list|)
operator|==
literal|0
condition|)
name|no_warn
operator|=
literal|1
expr_stmt|;
comment|/* Get rid of unmatched brace arguments from previous commands. */
name|discard_braces
argument_list|()
expr_stmt|;
comment|/* There also might be insertions left lying around that haven't been      ended yet.  Do that also. */
name|discard_insertions
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|already_outputting_pending_notes
condition|)
block|{
name|close_paragraph
argument_list|()
expr_stmt|;
name|output_pending_notes
argument_list|()
expr_stmt|;
name|free_pending_notes
argument_list|()
expr_stmt|;
block|}
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|0
expr_stmt|;
name|new_node_pos
operator|=
name|output_position
expr_stmt|;
name|current_footnote_number
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
if|if
condition|(
name|macro_expansion_output_stream
condition|)
name|append_to_expansion_output
argument_list|(
name|input_text_offset
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MACROS */
name|node
operator|=
name|get_node_token
argument_list|()
expr_stmt|;
name|next
operator|=
name|get_node_token
argument_list|()
expr_stmt|;
name|prev
operator|=
name|get_node_token
argument_list|()
expr_stmt|;
name|up
operator|=
name|get_node_token
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
if|if
condition|(
name|macro_expansion_output_stream
condition|)
name|remember_itext
argument_list|(
name|input_text
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MACROS */
name|no_indent
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|no_headers
condition|)
block|{
name|add_word_args
argument_list|(
literal|"\037\nFile: %s,  Node: "
argument_list|,
name|pretty_output_filename
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
if|if
condition|(
name|macro_expansion_output_stream
condition|)
name|me_execute_string
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* HAVE_MACROS */
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Check for defaulting of this node's next, prev, and up fields. */
name|defaulting
operator|=
operator|(
operator|(
name|strlen
argument_list|(
name|next
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strlen
argument_list|(
name|prev
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strlen
argument_list|(
name|up
argument_list|)
operator|==
literal|0
operator|)
operator|)
expr_stmt|;
name|this_section
operator|=
name|what_section
argument_list|(
name|input_text
operator|+
name|input_text_offset
argument_list|)
expr_stmt|;
comment|/* If we are defaulting, then look at the immediately following      sectioning command (error if none) to determine the node's      level.  Find the node that contains the menu mentioning this node      that is one level up (error if not found).  That node is the "Up"      of this node.  Default the "Next" and "Prev" from the menu. */
if|if
condition|(
name|defaulting
condition|)
block|{
name|NODE_REF
modifier|*
name|last_ref
init|=
operator|(
name|NODE_REF
operator|*
operator|)
name|NULL
decl_stmt|;
name|NODE_REF
modifier|*
name|ref
init|=
name|node_references
decl_stmt|;
if|if
condition|(
operator|(
name|this_section
operator|<
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|node
argument_list|,
literal|"Top"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|char
modifier|*
name|polite_section_name
init|=
literal|"top"
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|section_alist
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|section_alist
index|[
name|i
index|]
operator|.
name|level
operator|==
name|current_section
operator|+
literal|1
condition|)
block|{
name|polite_section_name
operator|=
name|section_alist
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
break|break;
block|}
name|line_error
argument_list|(
literal|"Node `%s' requires a sectioning command (e.g. %c%s)"
argument_list|,
name|node
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|polite_section_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|node
argument_list|,
literal|"Top"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Default the NEXT pointer to be the first menu item in 		 this node, if there is a menu in this node.  We have to 		 try very hard to find the menu, as it may be obscured 		 by execution_strings which are on the filestack.  For 		 every member of the filestack which has a FILENAME 		 member which is identical to the current INPUT_FILENAME, 		 search forward from that offset. */
name|int
name|saved_input_text_offset
init|=
name|input_text_offset
decl_stmt|;
name|int
name|saved_size_of_input_text
init|=
name|size_of_input_text
decl_stmt|;
name|char
modifier|*
name|saved_input_text
init|=
name|input_text
decl_stmt|;
name|FSTACK
modifier|*
name|next_file
init|=
name|filestack
decl_stmt|;
name|int
name|orig_offset
decl_stmt|,
name|orig_size
decl_stmt|;
name|char
modifier|*
name|glean_node_from_menu
parameter_list|()
function_decl|;
comment|/* No matter what, make this file point back at `(dir)'. */
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
name|up
operator|=
name|strdup
argument_list|(
literal|"(dir)"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|orig_offset
operator|=
name|input_text_offset
expr_stmt|;
name|orig_size
operator|=
name|search_forward
argument_list|(
name|node_search_string
argument_list|,
name|orig_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_size
operator|<
literal|0
condition|)
name|orig_size
operator|=
name|size_of_input_text
expr_stmt|;
name|input_text_offset
operator|=
name|search_forward
argument_list|(
name|menu_search_string
argument_list|,
name|orig_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_text_offset
operator|>
operator|-
literal|1
condition|)
block|{
name|char
modifier|*
name|nodename_from_menu
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|input_text_offset
operator|=
name|search_forward
argument_list|(
literal|"\n* "
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_text_offset
operator|!=
operator|-
literal|1
condition|)
name|nodename_from_menu
operator|=
name|glean_node_from_menu
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodename_from_menu
condition|)
block|{
name|free
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
name|nodename_from_menu
expr_stmt|;
break|break;
block|}
block|}
comment|/* We got here, so it hasn't been found yet.  Try 		     the next file on the filestack if there is one. */
if|if
condition|(
name|next_file
operator|&&
operator|(
name|strcmp
argument_list|(
name|next_file
operator|->
name|filename
argument_list|,
name|input_filename
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|input_text
operator|=
name|next_file
operator|->
name|text
expr_stmt|;
name|input_text_offset
operator|=
name|next_file
operator|->
name|offset
expr_stmt|;
name|size_of_input_text
operator|=
name|next_file
operator|->
name|size
expr_stmt|;
name|next_file
operator|=
name|next_file
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
comment|/* No more input files to check. */
break|break;
block|}
block|}
name|input_text
operator|=
name|saved_input_text
expr_stmt|;
name|input_text_offset
operator|=
name|saved_input_text_offset
expr_stmt|;
name|size_of_input_text
operator|=
name|saved_size_of_input_text
expr_stmt|;
block|}
block|}
comment|/* Fix the level of the menu references in the Top node, iff it 	 was declared with @top, and no subsequent reference was found. */
if|if
condition|(
name|top_node_seen
operator|&&
operator|!
name|non_top_node_seen
condition|)
block|{
comment|/* Then this is the first non-@top node seen. */
name|int
name|level
decl_stmt|;
name|level
operator|=
name|set_top_section_level
argument_list|(
name|this_section
operator|-
literal|1
argument_list|)
expr_stmt|;
name|non_top_node_seen
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|ref
condition|)
block|{
if|if
condition|(
name|ref
operator|->
name|section
operator|==
name|level
condition|)
name|ref
operator|->
name|section
operator|=
name|this_section
operator|-
literal|1
expr_stmt|;
name|ref
operator|=
name|ref
operator|->
name|next
expr_stmt|;
block|}
name|ref
operator|=
name|node_references
expr_stmt|;
block|}
while|while
condition|(
name|ref
condition|)
block|{
if|if
condition|(
name|ref
operator|->
name|section
operator|==
operator|(
name|this_section
operator|-
literal|1
operator|)
operator|&&
name|ref
operator|->
name|type
operator|==
name|menu_reference
operator|&&
name|strcmp
argument_list|(
name|ref
operator|->
name|node
argument_list|,
name|node
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|containing_node
init|=
name|ref
operator|->
name|containing_node
decl_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
name|up
operator|=
name|strdup
argument_list|(
name|containing_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_ref
operator|&&
name|last_ref
operator|->
name|type
operator|==
name|menu_reference
operator|&&
operator|(
name|strcmp
argument_list|(
name|last_ref
operator|->
name|containing_node
argument_list|,
name|containing_node
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|free
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
name|strdup
argument_list|(
name|last_ref
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|ref
operator|->
name|section
operator|==
name|this_section
operator|-
literal|1
operator|)
operator|&&
operator|(
name|ref
operator|->
name|next
operator|)
operator|&&
operator|(
name|ref
operator|->
name|next
operator|->
name|type
operator|!=
name|menu_reference
operator|)
condition|)
name|ref
operator|=
name|ref
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ref
operator|->
name|next
operator|&&
name|ref
operator|->
name|type
operator|==
name|menu_reference
operator|&&
operator|(
name|strcmp
argument_list|(
name|ref
operator|->
name|next
operator|->
name|containing_node
argument_list|,
name|containing_node
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|prev
operator|=
name|strdup
argument_list|(
name|ref
operator|->
name|next
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ref
operator|->
name|next
operator|&&
name|strcasecmp
argument_list|(
name|ref
operator|->
name|containing_node
argument_list|,
literal|"Top"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|prev
operator|=
name|strdup
argument_list|(
name|ref
operator|->
name|containing_node
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|last_ref
operator|=
name|ref
expr_stmt|;
name|ref
operator|=
name|ref
operator|->
name|next
expr_stmt|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
comment|/* Insert the correct args if we are expanding macros, and the node's      pointers weren't defaulted. */
if|if
condition|(
name|macro_expansion_output_stream
operator|&&
operator|!
name|defaulting
condition|)
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|op_orig
init|=
name|output_paragraph_offset
decl_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|3
operator|+
name|strlen
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|", %s"
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|me_execute_string
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|3
operator|+
name|strlen
argument_list|(
name|prev
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|", %s"
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|me_execute_string
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|4
operator|+
name|strlen
argument_list|(
name|up
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|", %s"
argument_list|,
name|up
argument_list|)
expr_stmt|;
name|me_execute_string
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|output_paragraph_offset
operator|=
name|op_orig
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_MACROS */
if|if
condition|(
operator|!
name|no_headers
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
if|if
condition|(
name|macro_expansion_output_stream
condition|)
name|me_inhibit_expansion
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MACROS */
if|if
condition|(
operator|*
name|next
condition|)
block|{
name|execute_string
argument_list|(
literal|",  Next: %s"
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|prev
condition|)
block|{
name|execute_string
argument_list|(
literal|",  Prev: %s"
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|up
condition|)
block|{
name|execute_string
argument_list|(
literal|",  Up: %s"
argument_list|,
name|up
argument_list|)
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
if|if
condition|(
name|macro_expansion_output_stream
condition|)
name|me_inhibit_expansion
operator|--
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MACROS */
block|}
name|close_paragraph
argument_list|()
expr_stmt|;
name|no_indent
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|node
condition|)
block|{
name|line_error
argument_list|(
literal|"No node name specified for `%c%s' command"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|*
name|next
condition|)
block|{
name|free
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|prev
condition|)
block|{
name|free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|prev
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|up
condition|)
block|{
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
name|up
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|remember_node
argument_list|(
name|node
argument_list|,
name|prev
argument_list|,
name|next
argument_list|,
name|up
argument_list|,
name|new_node_pos
argument_list|,
name|line_number
argument_list|,
name|no_warn
argument_list|)
expr_stmt|;
block|}
comment|/* Change the section only if there was a sectioning command. */
if|if
condition|(
name|this_section
operator|>=
literal|0
condition|)
name|current_section
operator|=
name|this_section
expr_stmt|;
name|filling_enabled
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Validation of an info file.    Scan through the list of tag entries touching the Prev, Next, and Up    elements of each.  It is an error not to be able to touch one of them,    except in the case of external node references, such as "(DIR)".     If the Prev is different from the Up,    then the Prev node must have a Next pointing at this node.     Every node except Top must have an Up.    The Up node must contain some sort of reference, other than a Next,    to this node.     If the Next is different from the Next of the Up,    then the Next node must have a Prev pointing at this node. */
end_comment

begin_function
name|void
name|validate_file
parameter_list|(
name|tag_table
parameter_list|)
name|TAG_ENTRY
modifier|*
name|tag_table
decl_stmt|;
block|{
name|char
modifier|*
name|old_input_filename
init|=
name|input_filename
decl_stmt|;
name|TAG_ENTRY
modifier|*
name|tags
init|=
name|tag_table
decl_stmt|;
while|while
condition|(
name|tags
operator|!=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|NULL
condition|)
block|{
specifier|register
name|TAG_ENTRY
modifier|*
name|temp_tag
decl_stmt|;
name|input_filename
operator|=
name|tags
operator|->
name|filename
expr_stmt|;
name|line_number
operator|=
name|tags
operator|->
name|line_no
expr_stmt|;
comment|/* If this is a "no warn" node, don't validate it in any way. */
if|if
condition|(
name|tags
operator|->
name|flags
operator|&
name|NO_WARN
condition|)
block|{
name|tags
operator|=
name|tags
operator|->
name|next_ent
expr_stmt|;
continue|continue;
block|}
comment|/* If this node has a Next, then make sure that the Next exists. */
if|if
condition|(
name|tags
operator|->
name|next
condition|)
block|{
name|validate
argument_list|(
name|tags
operator|->
name|next
argument_list|,
name|tags
operator|->
name|line_no
argument_list|,
literal|"Next"
argument_list|)
expr_stmt|;
comment|/* If the Next node exists, and there is no Up, then make 	     sure that the Prev of the Next points back. */
if|if
condition|(
name|temp_tag
operator|=
name|find_node
argument_list|(
name|tags
operator|->
name|next
argument_list|)
condition|)
block|{
name|char
modifier|*
name|prev
decl_stmt|;
if|if
condition|(
name|temp_tag
operator|->
name|flags
operator|&
name|NO_WARN
condition|)
block|{
comment|/* Do nothing if we aren't supposed to issue warnings 		     about this node. */
block|}
else|else
block|{
name|prev
operator|=
name|temp_tag
operator|->
name|prev
expr_stmt|;
if|if
condition|(
operator|!
name|prev
operator|||
operator|(
name|strcmp
argument_list|(
name|prev
argument_list|,
name|tags
operator|->
name|node
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|line_error
argument_list|(
literal|"Node `%s''s Next field not pointed back to"
argument_list|,
name|tags
operator|->
name|node
argument_list|)
expr_stmt|;
name|line_number
operator|=
name|temp_tag
operator|->
name|line_no
expr_stmt|;
name|input_filename
operator|=
name|temp_tag
operator|->
name|filename
expr_stmt|;
name|line_error
argument_list|(
literal|"This node (`%s') is the one with the bad `Prev'"
argument_list|,
name|temp_tag
operator|->
name|node
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|tags
operator|->
name|filename
expr_stmt|;
name|line_number
operator|=
name|tags
operator|->
name|line_no
expr_stmt|;
name|temp_tag
operator|->
name|flags
operator||=
name|PREV_ERROR
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Validate the Prev field if there is one, and we haven't already 	 complained about it in some way.  You don't have to have a Prev 	 field at this stage. */
if|if
condition|(
operator|!
operator|(
name|tags
operator|->
name|flags
operator|&
name|PREV_ERROR
operator|)
operator|&&
name|tags
operator|->
name|prev
condition|)
block|{
name|int
name|valid
init|=
name|validate
argument_list|(
name|tags
operator|->
name|prev
argument_list|,
name|tags
operator|->
name|line_no
argument_list|,
literal|"Prev"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|valid
condition|)
name|tags
operator|->
name|flags
operator||=
name|PREV_ERROR
expr_stmt|;
else|else
block|{
comment|/* If the Prev field is not the same as the Up field, 		 then the node pointed to by the Prev field must have 		 a Next field which points to this node. */
if|if
condition|(
name|tags
operator|->
name|up
operator|&&
operator|(
name|strcmp
argument_list|(
name|tags
operator|->
name|prev
argument_list|,
name|tags
operator|->
name|up
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|temp_tag
operator|=
name|find_node
argument_list|(
name|tags
operator|->
name|prev
argument_list|)
expr_stmt|;
comment|/* If we aren't supposed to issue warnings about the 		     target node, do nothing. */
if|if
condition|(
operator|!
name|temp_tag
operator|||
operator|(
name|temp_tag
operator|->
name|flags
operator|&
name|NO_WARN
operator|)
condition|)
block|{
comment|/* Do nothing. */
block|}
else|else
block|{
if|if
condition|(
operator|!
name|temp_tag
operator|->
name|next
operator|||
operator|(
name|strcmp
argument_list|(
name|temp_tag
operator|->
name|next
argument_list|,
name|tags
operator|->
name|node
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|line_error
argument_list|(
literal|"Node `%s''s Prev field not pointed back to"
argument_list|,
name|tags
operator|->
name|node
argument_list|)
expr_stmt|;
name|line_number
operator|=
name|temp_tag
operator|->
name|line_no
expr_stmt|;
name|input_filename
operator|=
name|temp_tag
operator|->
name|filename
expr_stmt|;
name|line_error
argument_list|(
literal|"This node (`%s') is the one with the bad `Next'"
argument_list|,
name|temp_tag
operator|->
name|node
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|tags
operator|->
name|filename
expr_stmt|;
name|line_number
operator|=
name|tags
operator|->
name|line_no
expr_stmt|;
name|temp_tag
operator|->
name|flags
operator||=
name|NEXT_ERROR
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|tags
operator|->
name|up
operator|&&
operator|(
name|strcasecmp
argument_list|(
name|tags
operator|->
name|node
argument_list|,
literal|"Top"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|line_error
argument_list|(
literal|"Node `%s' is missing an \"Up\" field"
argument_list|,
name|tags
operator|->
name|node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tags
operator|->
name|up
condition|)
block|{
name|int
name|valid
init|=
name|validate
argument_list|(
name|tags
operator|->
name|up
argument_list|,
name|tags
operator|->
name|line_no
argument_list|,
literal|"Up"
argument_list|)
decl_stmt|;
comment|/* If node X has Up: Y, then warn if Y fails to have a menu item 	     or note pointing at X, if Y isn't of the form "(Y)". */
if|if
condition|(
name|valid
operator|&&
operator|*
name|tags
operator|->
name|up
operator|!=
literal|'('
condition|)
block|{
name|NODE_REF
modifier|*
name|nref
decl_stmt|,
modifier|*
name|tref
decl_stmt|,
modifier|*
name|list
decl_stmt|;
name|NODE_REF
modifier|*
name|find_node_reference
parameter_list|()
function_decl|;
name|tref
operator|=
operator|(
name|NODE_REF
operator|*
operator|)
name|NULL
expr_stmt|;
name|list
operator|=
name|node_references
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|nref
operator|=
name|find_node_reference
argument_list|(
name|tags
operator|->
name|node
argument_list|,
name|list
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|strcmp
argument_list|(
name|nref
operator|->
name|containing_node
argument_list|,
name|tags
operator|->
name|up
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nref
operator|->
name|type
operator|!=
name|menu_reference
condition|)
block|{
name|tref
operator|=
name|nref
expr_stmt|;
name|list
operator|=
name|nref
operator|->
name|next
expr_stmt|;
block|}
else|else
break|break;
block|}
name|list
operator|=
name|nref
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nref
condition|)
block|{
name|temp_tag
operator|=
name|find_node
argument_list|(
name|tags
operator|->
name|up
argument_list|)
expr_stmt|;
name|line_number
operator|=
name|temp_tag
operator|->
name|line_no
expr_stmt|;
name|input_filename
operator|=
name|temp_tag
operator|->
name|filename
expr_stmt|;
if|if
condition|(
operator|!
name|tref
condition|)
name|line_error
argument_list|(
literal|"`%s' has an Up field of `%s', but `%s' has no menu item for `%s'"
argument_list|,
name|tags
operator|->
name|node
argument_list|,
name|tags
operator|->
name|up
argument_list|,
name|tags
operator|->
name|up
argument_list|,
name|tags
operator|->
name|node
argument_list|)
expr_stmt|;
name|line_number
operator|=
name|tags
operator|->
name|line_no
expr_stmt|;
name|input_filename
operator|=
name|tags
operator|->
name|filename
expr_stmt|;
block|}
block|}
block|}
name|tags
operator|=
name|tags
operator|->
name|next_ent
expr_stmt|;
block|}
name|validate_other_references
argument_list|(
name|node_references
argument_list|)
expr_stmt|;
comment|/* We have told the user about the references which didn't exist.      Now tell him about the nodes which aren't referenced. */
name|tags
operator|=
name|tag_table
expr_stmt|;
while|while
condition|(
name|tags
operator|!=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* If this node is a "no warn" node, do nothing. */
if|if
condition|(
name|tags
operator|->
name|flags
operator|&
name|NO_WARN
condition|)
block|{
name|tags
operator|=
name|tags
operator|->
name|next_ent
expr_stmt|;
continue|continue;
block|}
comment|/* Special hack.  If the node in question appears to have          been referenced more than REFERENCE_WARNING_LIMIT times,          give a warning. */
if|if
condition|(
name|tags
operator|->
name|touched
operator|>
name|reference_warning_limit
condition|)
block|{
name|input_filename
operator|=
name|tags
operator|->
name|filename
expr_stmt|;
name|line_number
operator|=
name|tags
operator|->
name|line_no
expr_stmt|;
name|warning
argument_list|(
literal|"Node `%s' has been referenced %d times"
argument_list|,
name|tags
operator|->
name|node
argument_list|,
name|tags
operator|->
name|touched
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tags
operator|->
name|touched
operator|==
literal|0
condition|)
block|{
name|input_filename
operator|=
name|tags
operator|->
name|filename
expr_stmt|;
name|line_number
operator|=
name|tags
operator|->
name|line_no
expr_stmt|;
comment|/* Notice that the node "Top" is special, and doesn't have to 	     be referenced. */
if|if
condition|(
name|strcasecmp
argument_list|(
name|tags
operator|->
name|node
argument_list|,
literal|"Top"
argument_list|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"Unreferenced node `%s'"
argument_list|,
name|tags
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
name|tags
operator|=
name|tags
operator|->
name|next_ent
expr_stmt|;
block|}
name|input_filename
operator|=
name|old_input_filename
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if tag correctly validated, or 0 if not. */
end_comment

begin_function
name|int
name|validate
parameter_list|(
name|tag
parameter_list|,
name|line
parameter_list|,
name|label
parameter_list|)
name|char
modifier|*
name|tag
decl_stmt|;
name|int
name|line
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
block|{
name|TAG_ENTRY
modifier|*
name|result
decl_stmt|;
comment|/* If there isn't a tag to verify, or if the tag is in another file,      then it must be okay. */
if|if
condition|(
operator|!
name|tag
operator|||
operator|!
operator|*
name|tag
operator|||
operator|*
name|tag
operator|==
literal|'('
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Otherwise, the tag must exist. */
name|result
operator|=
name|find_node
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|line_number
operator|=
name|line
expr_stmt|;
name|line_error
argument_list|(
literal|"Validation error.  `%s' field points to node `%s', which doesn't exist"
argument_list|,
name|label
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|result
operator|->
name|touched
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Split large output files into a series of smaller files.  Each file    is pointed to in the tag table, which then gets written out as the    original file.  The new files have the same name as the original file    with a "-num" attached.  SIZE is the largest number of bytes to allow    in any single split file. */
end_comment

begin_function
name|void
name|split_file
parameter_list|(
name|filename
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|root_filename
decl_stmt|,
modifier|*
name|root_pathname
decl_stmt|;
name|char
modifier|*
name|the_file
decl_stmt|,
modifier|*
name|filename_part
argument_list|()
decl_stmt|;
name|struct
name|stat
name|fileinfo
decl_stmt|;
name|long
name|file_size
decl_stmt|;
name|char
modifier|*
name|the_header
decl_stmt|;
name|int
name|header_size
decl_stmt|;
comment|/* Can only do this to files with tag tables. */
if|if
condition|(
operator|!
name|tag_table
condition|)
return|return;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
name|DEFAULT_SPLIT_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|fileinfo
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
operator|(
name|long
operator|)
name|fileinfo
operator|.
name|st_size
operator|)
operator|<
name|SPLIT_SIZE_THRESHOLD
operator|)
condition|)
return|return;
name|file_size
operator|=
operator|(
name|long
operator|)
name|fileinfo
operator|.
name|st_size
expr_stmt|;
name|the_file
operator|=
name|find_and_load
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|the_file
condition|)
return|return;
name|root_filename
operator|=
name|filename_part
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|root_pathname
operator|=
name|pathname_part
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|root_pathname
condition|)
name|root_pathname
operator|=
name|strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Start splitting the file.  Walk along the tag table      outputting sections of the file.  When we have written      all of the nodes in the tag table, make the top-level      pointer file, which contains indirect pointers and      tags for the nodes. */
block|{
name|int
name|which_file
init|=
literal|1
decl_stmt|;
name|TAG_ENTRY
modifier|*
name|tags
init|=
name|tag_table
decl_stmt|;
name|char
modifier|*
name|indirect_info
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* Remember the `header' of this file.  The first tag in the file is        the bottom of the header; the top of the file is the start. */
name|the_header
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
operator|(
name|header_size
operator|=
name|tags
operator|->
name|position
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|the_header
argument_list|,
name|the_file
argument_list|,
name|header_size
argument_list|)
expr_stmt|;
while|while
condition|(
name|tags
condition|)
block|{
name|int
name|file_top
decl_stmt|,
name|file_bot
decl_stmt|,
name|limit
decl_stmt|;
comment|/* Have to include the Control-_. */
name|file_top
operator|=
name|file_bot
operator|=
name|tags
operator|->
name|position
expr_stmt|;
name|limit
operator|=
name|file_top
operator|+
name|size
expr_stmt|;
comment|/* If the rest of this file is only one node, then 	   that is the entire subfile. */
if|if
condition|(
operator|!
name|tags
operator|->
name|next_ent
condition|)
block|{
name|int
name|i
init|=
name|tags
operator|->
name|position
operator|+
literal|1
decl_stmt|;
name|char
name|last_char
init|=
name|the_file
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|file_size
condition|)
block|{
if|if
condition|(
operator|(
name|the_file
index|[
name|i
index|]
operator|==
literal|'\037'
operator|)
operator|&&
operator|(
operator|(
name|last_char
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|last_char
operator|==
literal|'\014'
operator|)
operator|)
condition|)
break|break;
else|else
name|last_char
operator|=
name|the_file
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|file_bot
operator|=
name|i
expr_stmt|;
name|tags
operator|=
name|tags
operator|->
name|next_ent
expr_stmt|;
goto|goto
name|write_region
goto|;
block|}
comment|/* Otherwise, find the largest number of nodes that can fit in 	   this subfile. */
for|for
control|(
init|;
name|tags
condition|;
name|tags
operator|=
name|tags
operator|->
name|next_ent
control|)
block|{
if|if
condition|(
operator|!
name|tags
operator|->
name|next_ent
condition|)
block|{
comment|/* This entry is the last node.  Search forward for the end 	           of this node, and that is the end of this file. */
name|int
name|i
init|=
name|tags
operator|->
name|position
operator|+
literal|1
decl_stmt|;
name|char
name|last_char
init|=
name|the_file
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|file_size
condition|)
block|{
if|if
condition|(
operator|(
name|the_file
index|[
name|i
index|]
operator|==
literal|'\037'
operator|)
operator|&&
operator|(
operator|(
name|last_char
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|last_char
operator|==
literal|'\014'
operator|)
operator|)
condition|)
break|break;
else|else
name|last_char
operator|=
name|the_file
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|file_bot
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|file_bot
operator|<
name|limit
condition|)
block|{
name|tags
operator|=
name|tags
operator|->
name|next_ent
expr_stmt|;
goto|goto
name|write_region
goto|;
block|}
else|else
block|{
comment|/* Here we want to write out everything before the last 		       node, and then write the last node out in a file 		       by itself. */
name|file_bot
operator|=
name|tags
operator|->
name|position
expr_stmt|;
goto|goto
name|write_region
goto|;
block|}
block|}
if|if
condition|(
name|tags
operator|->
name|next_ent
operator|->
name|position
operator|>
name|limit
condition|)
block|{
if|if
condition|(
name|tags
operator|->
name|position
operator|==
name|file_top
condition|)
name|tags
operator|=
name|tags
operator|->
name|next_ent
expr_stmt|;
name|file_bot
operator|=
name|tags
operator|->
name|position
expr_stmt|;
name|write_region
label|:
block|{
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|split_filename
decl_stmt|;
name|split_filename
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|10
operator|+
name|strlen
argument_list|(
name|root_pathname
argument_list|)
operator|+
name|strlen
argument_list|(
name|root_filename
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|split_filename
argument_list|,
literal|"%s%s-%d"
argument_list|,
name|root_pathname
argument_list|,
name|root_filename
argument_list|,
name|which_file
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|split_filename
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|<
literal|0
operator|)
operator|||
operator|(
name|write
argument_list|(
name|fd
argument_list|,
name|the_header
argument_list|,
name|header_size
argument_list|)
operator|!=
name|header_size
operator|)
operator|||
operator|(
name|write
argument_list|(
name|fd
argument_list|,
name|the_file
operator|+
name|file_top
argument_list|,
name|file_bot
operator|-
name|file_top
argument_list|)
operator|!=
operator|(
name|file_bot
operator|-
name|file_top
operator|)
operator|)
operator|||
operator|(
operator|(
name|close
argument_list|(
name|fd
argument_list|)
operator|)
operator|<
literal|0
operator|)
condition|)
block|{
name|perror
argument_list|(
name|split_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|indirect_info
condition|)
block|{
name|indirect_info
operator|=
name|the_file
operator|+
name|file_top
expr_stmt|;
name|sprintf
argument_list|(
name|indirect_info
argument_list|,
literal|"\037\nIndirect:\n"
argument_list|)
expr_stmt|;
name|indirect_info
operator|+=
name|strlen
argument_list|(
name|indirect_info
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|indirect_info
argument_list|,
literal|"%s-%d: %d\n"
argument_list|,
name|root_filename
argument_list|,
name|which_file
argument_list|,
name|file_top
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|split_filename
argument_list|)
expr_stmt|;
name|indirect_info
operator|+=
name|strlen
argument_list|(
name|indirect_info
argument_list|)
expr_stmt|;
name|which_file
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* We have sucessfully created the subfiles.  Now write out the        original again.  We must use `output_stream', or        write_tag_table_indirect () won't know where to place the output. */
name|output_stream
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|output_stream
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL
argument_list|)
expr_stmt|;
block|}
block|{
name|int
name|distance
init|=
name|indirect_info
operator|-
name|the_file
decl_stmt|;
name|fwrite
argument_list|(
name|the_file
argument_list|,
literal|1
argument_list|,
name|distance
argument_list|,
name|output_stream
argument_list|)
expr_stmt|;
comment|/* Inhibit newlines. */
name|paragraph_is_open
operator|=
literal|0
expr_stmt|;
name|write_tag_table_indirect
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|output_stream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|the_header
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|the_file
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Some menu hacking.  This is used to remember menu references while    reading the input file.  After the output file has been written, if    validation is on, then we use the contents of NODE_REFERENCES as a    list of nodes to validate. */
end_comment

begin_function
name|char
modifier|*
name|reftype_type_string
parameter_list|(
name|type
parameter_list|)
name|enum
name|reftype
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|menu_reference
case|:
return|return
operator|(
literal|"Menu"
operator|)
return|;
case|case
name|followed_reference
case|:
return|return
operator|(
literal|"Followed-Reference"
operator|)
return|;
default|default:
return|return
operator|(
literal|"Internal-bad-reference-type"
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Remember this node name for later validation use. */
end_comment

begin_function
name|void
name|remember_node_reference
parameter_list|(
name|node
parameter_list|,
name|line
parameter_list|,
name|type
parameter_list|)
name|char
modifier|*
name|node
decl_stmt|;
name|int
name|line
decl_stmt|;
name|enum
name|reftype
name|type
decl_stmt|;
block|{
name|NODE_REF
modifier|*
name|temp
init|=
operator|(
name|NODE_REF
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NODE_REF
argument_list|)
argument_list|)
decl_stmt|;
name|temp
operator|->
name|next
operator|=
name|node_references
expr_stmt|;
name|temp
operator|->
name|node
operator|=
name|strdup
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|temp
operator|->
name|line_no
operator|=
name|line
expr_stmt|;
name|temp
operator|->
name|section
operator|=
name|current_section
expr_stmt|;
name|temp
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|temp
operator|->
name|containing_node
operator|=
name|strdup
argument_list|(
name|current_node
condition|?
name|current_node
else|:
literal|""
argument_list|)
expr_stmt|;
name|temp
operator|->
name|filename
operator|=
name|node_filename
expr_stmt|;
name|node_references
operator|=
name|temp
expr_stmt|;
block|}
end_function

begin_function
name|void
name|validate_other_references
parameter_list|(
name|ref_list
parameter_list|)
specifier|register
name|NODE_REF
modifier|*
name|ref_list
decl_stmt|;
block|{
name|char
modifier|*
name|old_input_filename
init|=
name|input_filename
decl_stmt|;
while|while
condition|(
name|ref_list
operator|!=
operator|(
name|NODE_REF
operator|*
operator|)
name|NULL
condition|)
block|{
name|input_filename
operator|=
name|ref_list
operator|->
name|filename
expr_stmt|;
name|validate
argument_list|(
name|ref_list
operator|->
name|node
argument_list|,
name|ref_list
operator|->
name|line_no
argument_list|,
name|reftype_type_string
argument_list|(
name|ref_list
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|ref_list
operator|=
name|ref_list
operator|->
name|next
expr_stmt|;
block|}
name|input_filename
operator|=
name|old_input_filename
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find NODE in REF_LIST. */
end_comment

begin_function
name|NODE_REF
modifier|*
name|find_node_reference
parameter_list|(
name|node
parameter_list|,
name|ref_list
parameter_list|)
name|char
modifier|*
name|node
decl_stmt|;
specifier|register
name|NODE_REF
modifier|*
name|ref_list
decl_stmt|;
block|{
while|while
condition|(
name|ref_list
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|node
argument_list|,
name|ref_list
operator|->
name|node
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|ref_list
operator|=
name|ref_list
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|ref_list
operator|)
return|;
block|}
end_function

begin_function
name|void
name|free_node_references
parameter_list|()
block|{
specifier|register
name|NODE_REF
modifier|*
name|list
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|list
operator|=
name|node_references
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|temp
operator|=
name|list
expr_stmt|;
name|free
argument_list|(
name|list
operator|->
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
operator|->
name|containing_node
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|node_references
operator|=
operator|(
name|NODE_REF
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function gets called at the start of every line while inside of      a menu.  It checks to see if the line starts with "* ", and if so,      remembers the node reference that this menu refers to.      input_text_offset is at the \n just before the line start. */
end_comment

begin_define
define|#
directive|define
name|menu_starter
value|"* "
end_define

begin_function
name|char
modifier|*
name|glean_node_from_menu
parameter_list|(
name|remember_reference
parameter_list|)
name|int
name|remember_reference
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|orig_offset
init|=
name|input_text_offset
decl_stmt|;
name|char
modifier|*
name|nodename
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|input_text
index|[
name|input_text_offset
operator|+
literal|1
index|]
argument_list|,
name|menu_starter
argument_list|,
name|strlen
argument_list|(
name|menu_starter
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
else|else
name|input_text_offset
operator|+=
name|strlen
argument_list|(
name|menu_starter
argument_list|)
operator|+
literal|1
expr_stmt|;
name|get_until_in_line
argument_list|(
literal|":"
argument_list|,
operator|&
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|':'
condition|)
name|input_text_offset
operator|++
expr_stmt|;
name|canon_white
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|':'
condition|)
goto|goto
name|save_node
goto|;
name|free
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|nodename
argument_list|)
expr_stmt|;
comment|/* Special hack: If the nodename follows the menu item name,      then we have to read the rest of the line in order to find      out what the nodename is.  But we still have to read the      line later, in order to process any formatting commands that      might be present.  So un-count the carriage return that has just      been counted. */
name|line_number
operator|--
expr_stmt|;
name|isolate_nodename
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
name|save_node
label|:
name|input_text_offset
operator|=
name|orig_offset
expr_stmt|;
name|normalize_node_name
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&&
name|nodename
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|':'
condition|)
name|nodename
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|remember_reference
condition|)
block|{
name|remember_node_reference
argument_list|(
name|nodename
argument_list|,
name|line_number
argument_list|,
name|menu_reference
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
else|else
return|return
operator|(
name|nodename
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isolate_nodename
parameter_list|(
name|nodename
parameter_list|)
name|char
modifier|*
name|nodename
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|int
name|paren_seen
decl_stmt|,
name|paren
decl_stmt|;
if|if
condition|(
operator|!
name|nodename
condition|)
return|return;
name|canon_white
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
name|paren_seen
operator|=
name|paren
operator|=
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|nodename
operator|==
literal|'.'
operator|||
operator|!
operator|*
name|nodename
condition|)
block|{
operator|*
name|nodename
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|nodename
operator|==
literal|'('
condition|)
block|{
name|paren
operator|++
expr_stmt|;
name|paren_seen
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|c
operator|=
name|nodename
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|paren
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
name|paren
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
name|paren
operator|--
expr_stmt|;
continue|continue;
block|}
comment|/* If the character following the close paren is a space, then this 	 node has no more characters associated with it. */
if|if
condition|(
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|','
operator|||
operator|(
operator|(
name|paren_seen
operator|&&
name|nodename
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|')'
operator|)
operator|&&
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'.'
operator|)
operator|)
operator|||
operator|(
name|c
operator|==
literal|'.'
operator|&&
operator|(
operator|(
operator|!
name|nodename
index|[
name|i
operator|+
literal|1
index|]
operator|||
operator|(
name|cr_or_whitespace
argument_list|(
name|nodename
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|)
operator|||
operator|(
name|nodename
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|')'
operator|)
operator|)
operator|)
operator|)
condition|)
break|break;
block|}
name|nodename
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_menu
parameter_list|()
block|{
if|if
condition|(
name|current_node
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"%cmenu seen before a node has been defined"
argument_list|,
name|COMMAND_PREFIX
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Creating `TOP' node."
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"@node Top"
argument_list|)
expr_stmt|;
block|}
name|begin_insertion
argument_list|(
name|menu
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_detailmenu
parameter_list|()
block|{
if|if
condition|(
name|current_node
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"%cmenu seen before a node has been defined"
argument_list|,
name|COMMAND_PREFIX
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Creating `TOP' node."
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"@node Top"
argument_list|)
expr_stmt|;
block|}
name|begin_insertion
argument_list|(
name|detailmenu
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Cross Reference Hacking			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function
name|char
modifier|*
name|get_xref_token
parameter_list|()
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|get_until_in_braces
argument_list|(
literal|","
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|','
condition|)
name|input_text_offset
operator|++
expr_stmt|;
name|fix_whitespace
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
operator|(
name|string
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|px_ref_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls initial output string. */
end_comment

begin_comment
comment|/* Make a cross reference. */
end_comment

begin_function
name|void
name|cm_xref
parameter_list|(
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
name|char
modifier|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|,
modifier|*
name|arg3
decl_stmt|,
modifier|*
name|arg4
decl_stmt|,
modifier|*
name|arg5
decl_stmt|;
name|arg1
operator|=
name|get_xref_token
argument_list|()
expr_stmt|;
name|arg2
operator|=
name|get_xref_token
argument_list|()
expr_stmt|;
name|arg3
operator|=
name|get_xref_token
argument_list|()
expr_stmt|;
name|arg4
operator|=
name|get_xref_token
argument_list|()
expr_stmt|;
name|arg5
operator|=
name|get_xref_token
argument_list|()
expr_stmt|;
name|add_word_args
argument_list|(
literal|"%s"
argument_list|,
name|px_ref_flag
condition|?
literal|"*note "
else|:
literal|"*Note "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg5
operator|||
operator|*
name|arg4
condition|)
block|{
name|char
modifier|*
name|node_name
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|arg2
condition|)
block|{
if|if
condition|(
operator|*
name|arg3
condition|)
name|node_name
operator|=
name|arg3
expr_stmt|;
else|else
name|node_name
operator|=
name|arg1
expr_stmt|;
block|}
else|else
name|node_name
operator|=
name|arg2
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s: (%s)%s"
argument_list|,
name|node_name
argument_list|,
name|arg4
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
comment|/* Free all of the arguments found. */
if|if
condition|(
name|arg1
condition|)
name|free
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg2
condition|)
name|free
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg3
condition|)
name|free
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg4
condition|)
name|free
argument_list|(
name|arg4
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg5
condition|)
name|free
argument_list|(
name|arg5
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|remember_node_reference
argument_list|(
name|arg1
argument_list|,
name|line_number
argument_list|,
name|followed_reference
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg3
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|arg2
condition|)
name|execute_string
argument_list|(
literal|"%s: %s"
argument_list|,
name|arg3
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"%s: %s"
argument_list|,
name|arg2
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|arg2
condition|)
name|execute_string
argument_list|(
literal|"%s: %s"
argument_list|,
name|arg2
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"%s::"
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
block|}
comment|/* Free all of the arguments found. */
if|if
condition|(
name|arg1
condition|)
name|free
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg2
condition|)
name|free
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg3
condition|)
name|free
argument_list|(
name|arg3
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg4
condition|)
name|free
argument_list|(
name|arg4
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg5
condition|)
name|free
argument_list|(
name|arg5
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check to make sure that the next non-whitespace character is either          a period or a comma. input_text_offset is pointing at the "}" which          ended the xref or pxref command. */
name|int
name|temp
init|=
name|input_text_offset
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|output_paragraph
index|[
name|output_paragraph_offset
operator|-
literal|2
index|]
operator|==
literal|':'
operator|&&
name|output_paragraph
index|[
name|output_paragraph_offset
operator|-
literal|1
index|]
operator|==
literal|':'
condition|)
return|return;
while|while
condition|(
name|temp
operator|<
name|size_of_input_text
condition|)
block|{
if|if
condition|(
name|cr_or_whitespace
argument_list|(
name|input_text
index|[
name|temp
index|]
argument_list|)
condition|)
name|temp
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|input_text
index|[
name|temp
index|]
operator|==
literal|'.'
operator|||
name|input_text
index|[
name|temp
index|]
operator|==
literal|','
operator|||
name|input_text
index|[
name|temp
index|]
operator|==
literal|'\t'
condition|)
return|return;
else|else
block|{
name|line_error
argument_list|(
literal|"Cross-reference must be terminated with a period or a comma"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|cm_pxref
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
name|px_ref_flag
operator|++
expr_stmt|;
name|cm_xref
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|px_ref_flag
operator|--
expr_stmt|;
block|}
else|else
name|add_char
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_inforef
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
name|char
modifier|*
name|node
decl_stmt|,
modifier|*
name|pname
decl_stmt|,
modifier|*
name|file
decl_stmt|;
name|node
operator|=
name|get_xref_token
argument_list|()
expr_stmt|;
name|pname
operator|=
name|get_xref_token
argument_list|()
expr_stmt|;
name|file
operator|=
name|get_xref_token
argument_list|()
expr_stmt|;
name|execute_string
argument_list|(
literal|"*note %s: (%s)%s"
argument_list|,
name|pname
argument_list|,
name|file
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Insertion Command Stubs			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function
name|void
name|cm_quotation
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|quotation
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_example
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|example
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_smallexample
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|smallexample
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_lisp
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|lisp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_smalllisp
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|smalllisp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* @cartouche/@end cartouche draws box with rounded corners in    TeX output.  Right now, just a NOP insertion. */
end_comment

begin_function
name|void
name|cm_cartouche
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|cartouche
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_format
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|format
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_display
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|display
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_direntry
parameter_list|()
block|{
if|if
condition|(
name|no_headers
condition|)
name|command_name_condition
argument_list|()
expr_stmt|;
else|else
name|begin_insertion
argument_list|(
name|direntry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_itemize
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|itemize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_enumerate
parameter_list|()
block|{
name|do_enumeration
argument_list|(
name|enumerate
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start an enumeration insertion of type TYPE.  If the user supplied    no argument on the line, then use DEFAULT_STRING as the initial string. */
end_comment

begin_function
name|void
name|do_enumeration
parameter_list|(
name|type
parameter_list|,
name|default_string
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|default_string
decl_stmt|;
block|{
name|get_until_in_line
argument_list|(
literal|"."
argument_list|,
operator|&
name|enumeration_arg
argument_list|)
expr_stmt|;
name|canon_white
argument_list|(
name|enumeration_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|enumeration_arg
condition|)
block|{
name|free
argument_list|(
name|enumeration_arg
argument_list|)
expr_stmt|;
name|enumeration_arg
operator|=
name|strdup
argument_list|(
name|default_string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|enumeration_arg
argument_list|)
operator|&&
operator|!
name|isletter
argument_list|(
operator|*
name|enumeration_arg
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"%s requires a letter or a digit"
argument_list|,
name|insertion_type_pname
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|enumerate
case|:
name|default_string
operator|=
literal|"1"
expr_stmt|;
break|break;
block|}
name|enumeration_arg
operator|=
name|strdup
argument_list|(
name|default_string
argument_list|)
expr_stmt|;
block|}
name|begin_insertion
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_table
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_multitable
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|multitable
argument_list|)
expr_stmt|;
comment|/* @@ */
block|}
end_function

begin_function
name|void
name|cm_ftable
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|ftable
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_vtable
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|vtable
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_group
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_ifinfo
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|ifinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin an insertion where the lines are not filled or indented. */
end_comment

begin_function
name|void
name|cm_flushleft
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|flushleft
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin an insertion where the lines are not filled, and each line is    forced to the right-hand side of the page. */
end_comment

begin_function
name|void
name|cm_flushright
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|flushright
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			  Conditional Handling			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* A structure which contains `defined' variables. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|defines
block|{
name|struct
name|defines
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|}
name|DEFINE
typedef|;
end_typedef

begin_comment
comment|/* The linked list of `set' defines. */
end_comment

begin_decl_stmt
name|DEFINE
modifier|*
name|defines
init|=
operator|(
name|DEFINE
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add NAME to the list of `set' defines. */
end_comment

begin_function
name|void
name|set
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|DEFINE
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|defines
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|temp
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|temp
operator|->
name|value
argument_list|)
expr_stmt|;
name|temp
operator|->
name|value
operator|=
name|strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
name|temp
operator|=
operator|(
name|DEFINE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DEFINE
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|defines
expr_stmt|;
name|temp
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|temp
operator|->
name|value
operator|=
name|strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|defines
operator|=
name|temp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove NAME from the list of `set' defines. */
end_comment

begin_function
name|void
name|clear
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|DEFINE
modifier|*
name|temp
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|last
operator|=
operator|(
name|DEFINE
operator|*
operator|)
name|NULL
expr_stmt|;
name|temp
operator|=
name|defines
expr_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|temp
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|last
condition|)
name|last
operator|->
name|next
operator|=
name|temp
operator|->
name|next
expr_stmt|;
else|else
name|defines
operator|=
name|temp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
block|}
name|last
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|temp
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the value of NAME.  The return value is NULL if NAME is unset. */
end_comment

begin_function
name|char
modifier|*
name|set_p
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|DEFINE
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|defines
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|temp
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|temp
operator|->
name|value
operator|)
return|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Conditionally parse based on the current command name. */
end_comment

begin_function
name|void
name|command_name_condition
parameter_list|()
block|{
name|char
modifier|*
name|discarder
decl_stmt|;
name|discarder
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|8
operator|+
name|strlen
argument_list|(
name|command
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|discarder
argument_list|,
literal|"\n%cend %s"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|discard_until
argument_list|(
name|discarder
argument_list|)
expr_stmt|;
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|discarder
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a variable whose name appears as the first word on this line. */
end_comment

begin_function
name|void
name|cm_set
parameter_list|()
block|{
name|handle_variable
argument_list|(
name|SET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove a variable whose name appears as the first word on this line. */
end_comment

begin_function
name|void
name|cm_clear
parameter_list|()
block|{
name|handle_variable
argument_list|(
name|CLEAR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_ifset
parameter_list|()
block|{
name|handle_variable
argument_list|(
name|IFSET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_ifclear
parameter_list|()
block|{
name|handle_variable
argument_list|(
name|IFCLEAR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This command takes braces, but we parse the contents specially, so we    don't use the standard brace popping code.     The syntax @ifeq{arg1, arg2, texinfo-commands} performs texinfo-commands    if ARG1 and ARG2 caselessly string compare to the same string, otherwise,    it produces no output. */
end_comment

begin_function
name|void
name|cm_ifeq
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|arglist
decl_stmt|;
name|arglist
operator|=
name|get_brace_args
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
condition|)
block|{
if|if
condition|(
name|array_len
argument_list|(
name|arglist
argument_list|)
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|strcasecmp
argument_list|(
name|arglist
index|[
literal|0
index|]
argument_list|,
name|arglist
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|arglist
index|[
literal|2
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
condition|)
name|execute_string
argument_list|(
literal|"%s\n"
argument_list|,
name|arglist
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
name|free_array
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|cm_value
parameter_list|(
name|arg
parameter_list|,
name|start_pos
parameter_list|,
name|end_pos
parameter_list|)
name|int
name|arg
decl_stmt|,
name|start_pos
decl_stmt|,
name|end_pos
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|output_paragraph
index|[
name|start_pos
index|]
expr_stmt|;
name|output_paragraph
index|[
name|end_pos
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|value
operator|=
name|set_p
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|output_column
operator|-=
name|end_pos
operator|-
name|start_pos
expr_stmt|;
name|output_paragraph_offset
operator|=
name|start_pos
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|add_word_args
argument_list|(
literal|"{No Value For \"%s\"}"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set, clear, or conditionalize based on ACTION. */
end_comment

begin_function
name|void
name|handle_variable
parameter_list|(
name|action
parameter_list|)
name|int
name|action
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
name|backup_input_pointer
argument_list|()
expr_stmt|;
name|canon_white
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|handle_variable_internal
argument_list|(
name|action
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|handle_variable_internal
parameter_list|(
name|action
parameter_list|,
name|name
parameter_list|)
name|int
name|action
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|delimiter
decl_stmt|,
name|additional_text_present
init|=
literal|0
decl_stmt|;
comment|/* Only the first word of NAME is a valid tag. */
name|temp
operator|=
name|name
expr_stmt|;
name|delimiter
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|temp
operator|&&
operator|(
name|delimiter
operator|||
operator|!
name|whitespace
argument_list|(
operator|*
name|temp
argument_list|)
operator|)
condition|)
block|{
comment|/* #if defined (SET_WITH_EQUAL) */
if|if
condition|(
operator|*
name|temp
operator|==
literal|'"'
operator|||
operator|*
name|temp
operator|==
literal|'\''
condition|)
block|{
if|if
condition|(
operator|*
name|temp
operator|==
name|delimiter
condition|)
name|delimiter
operator|=
literal|0
expr_stmt|;
else|else
name|delimiter
operator|=
operator|*
name|temp
expr_stmt|;
block|}
comment|/* #endif SET_WITH_EQUAL */
name|temp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|temp
condition|)
name|additional_text_present
operator|++
expr_stmt|;
operator|*
name|temp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|name
condition|)
name|line_error
argument_list|(
literal|"%c%s requires a name"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|SET
case|:
block|{
name|char
modifier|*
name|value
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SET_WITH_EQUAL
argument_list|)
comment|/* Allow a value to be saved along with a variable.  The value is 	       the text following an `=' sign in NAME, if any is present. */
for|for
control|(
name|value
operator|=
name|name
init|;
operator|*
name|value
operator|&&
operator|*
name|value
operator|!=
literal|'='
condition|;
name|value
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|value
condition|)
operator|*
name|value
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|value
operator|==
literal|'"'
operator|||
operator|*
name|value
operator|==
literal|'\''
condition|)
block|{
name|value
operator|++
expr_stmt|;
name|value
index|[
name|strlen
argument_list|(
name|value
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|#
directive|else
comment|/* !SET_WITH_EQUAL */
comment|/* The VALUE of NAME is the remainder of the line sans 	       whitespace. */
if|if
condition|(
name|additional_text_present
condition|)
block|{
name|value
operator|=
name|temp
operator|+
literal|1
expr_stmt|;
name|canon_white
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
name|value
operator|=
literal|""
expr_stmt|;
endif|#
directive|endif
comment|/* !SET_WITH_VALUE */
name|set
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CLEAR
case|:
name|clear
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|IFSET
case|:
case|case
name|IFCLEAR
case|:
comment|/* If IFSET and NAME is not set, or if IFCLEAR and NAME is set, 	     read lines from the the file until we reach a matching 	     "@end CONDITION".  This means that we only take note of 	     "@ifset/clear" and "@end" commands. */
block|{
name|char
name|condition
index|[
literal|8
index|]
decl_stmt|;
name|int
name|condition_len
decl_stmt|;
if|if
condition|(
name|action
operator|==
name|IFSET
condition|)
name|strcpy
argument_list|(
name|condition
argument_list|,
literal|"ifset"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|condition
argument_list|,
literal|"ifclear"
argument_list|)
expr_stmt|;
name|condition_len
operator|=
name|strlen
argument_list|(
name|condition
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|action
operator|==
name|IFSET
operator|&&
operator|!
name|set_p
argument_list|(
name|name
argument_list|)
operator|)
operator|||
operator|(
name|action
operator|==
name|IFCLEAR
operator|&&
name|set_p
argument_list|(
name|name
argument_list|)
operator|)
condition|)
block|{
name|int
name|level
init|=
literal|0
decl_stmt|,
name|done
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|char
modifier|*
name|freeable_line
decl_stmt|,
modifier|*
name|line
decl_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|freeable_line
argument_list|)
expr_stmt|;
for|for
control|(
name|line
operator|=
name|freeable_line
init|;
name|whitespace
argument_list|(
operator|*
name|line
argument_list|)
condition|;
name|line
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
name|COMMAND_PREFIX
operator|&&
operator|(
name|strncmp
argument_list|(
name|line
operator|+
literal|1
argument_list|,
name|condition
argument_list|,
name|condition_len
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|level
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"@end"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|cname
init|=
name|line
operator|+
literal|4
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
while|while
condition|(
operator|*
name|cname
operator|&&
name|whitespace
argument_list|(
operator|*
name|cname
argument_list|)
condition|)
name|cname
operator|++
expr_stmt|;
name|temp
operator|=
name|cname
expr_stmt|;
while|while
condition|(
operator|*
name|temp
operator|&&
operator|!
name|whitespace
argument_list|(
operator|*
name|temp
argument_list|)
condition|)
name|temp
operator|++
expr_stmt|;
operator|*
name|temp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cname
argument_list|,
name|condition
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|level
condition|)
block|{
name|done
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|level
operator|--
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|freeable_line
argument_list|)
expr_stmt|;
block|}
comment|/* We found the end of a false @ifset/ifclear.  If we are 		 in a menu, back up over the newline that ends the ifset, 		 since that newline may also begin the next menu entry. */
break|break;
block|}
else|else
block|{
if|if
condition|(
name|action
operator|==
name|IFSET
condition|)
name|begin_insertion
argument_list|(
name|ifset
argument_list|)
expr_stmt|;
else|else
name|begin_insertion
argument_list|(
name|ifclear
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Execution of random text not in file. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|string
decl_stmt|;
comment|/* The string buffer. */
name|int
name|size
decl_stmt|;
comment|/* The size of the buffer. */
name|int
name|in_use
decl_stmt|;
comment|/* Non-zero means string currently in use. */
block|}
name|EXECUTION_STRING
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|EXECUTION_STRING
modifier|*
modifier|*
name|execution_strings
init|=
operator|(
name|EXECUTION_STRING
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|execution_strings_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|execution_strings_slots
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|EXECUTION_STRING
modifier|*
name|get_execution_string
parameter_list|(
name|initial_size
parameter_list|)
name|int
name|initial_size
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
name|EXECUTION_STRING
modifier|*
name|es
init|=
operator|(
name|EXECUTION_STRING
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|execution_strings
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|execution_strings_index
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|execution_strings
index|[
name|i
index|]
operator|&&
operator|(
name|execution_strings
index|[
name|i
index|]
operator|->
name|in_use
operator|==
literal|0
operator|)
condition|)
block|{
name|es
operator|=
name|execution_strings
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|es
condition|)
block|{
if|if
condition|(
name|execution_strings_index
operator|+
literal|1
operator|>=
name|execution_strings_slots
condition|)
block|{
name|execution_strings
operator|=
operator|(
name|EXECUTION_STRING
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|execution_strings
argument_list|,
operator|(
name|execution_strings_slots
operator|+=
literal|3
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|EXECUTION_STRING
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|execution_strings_slots
condition|;
name|i
operator|++
control|)
name|execution_strings
index|[
name|i
index|]
operator|=
operator|(
name|EXECUTION_STRING
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|execution_strings
index|[
name|execution_strings_index
index|]
operator|=
operator|(
name|EXECUTION_STRING
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|EXECUTION_STRING
argument_list|)
argument_list|)
expr_stmt|;
name|es
operator|=
name|execution_strings
index|[
name|execution_strings_index
index|]
expr_stmt|;
name|execution_strings_index
operator|++
expr_stmt|;
name|es
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|es
operator|->
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|es
operator|->
name|in_use
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|initial_size
operator|>
name|es
operator|->
name|size
condition|)
block|{
name|es
operator|->
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|es
operator|->
name|string
argument_list|,
name|initial_size
argument_list|)
expr_stmt|;
name|es
operator|->
name|size
operator|=
name|initial_size
expr_stmt|;
block|}
return|return
operator|(
name|es
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Execute the string produced by formatting the ARGs with FORMAT.  This    is like submitting a new file with @include. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_VARARGS_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_VSPRINTF
argument_list|)
end_if

begin_function
name|void
name|execute_string
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|EXECUTION_STRING
modifier|*
name|es
decl_stmt|;
name|char
modifier|*
name|temp_string
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|es
operator|=
name|get_execution_string
argument_list|(
literal|4000
argument_list|)
expr_stmt|;
name|temp_string
operator|=
name|es
operator|->
name|string
expr_stmt|;
name|es
operator|->
name|in_use
operator|=
literal|1
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|temp_string
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !(HAVE_VARARGS_H&& HAVE_VSPRINTF) */
name|void
name|execute_string
parameter_list|(
name|format
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|,
name|arg4
parameter_list|,
name|arg5
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
block|{
name|EXECUTION_STRING
modifier|*
name|es
decl_stmt|;
name|char
modifier|*
name|temp_string
decl_stmt|;
name|es
operator|=
name|get_execution_string
argument_list|(
literal|4000
argument_list|)
expr_stmt|;
name|temp_string
operator|=
name|es
operator|->
name|string
expr_stmt|;
name|es
operator|->
name|in_use
operator|=
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|temp_string
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !(HAVE_VARARGS_H&& HAVE_VSPRINTF) */
name|pushfile
argument_list|()
expr_stmt|;
name|input_text_offset
operator|=
literal|0
expr_stmt|;
name|input_text
operator|=
name|temp_string
expr_stmt|;
name|input_filename
operator|=
name|strdup
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|size_of_input_text
operator|=
name|strlen
argument_list|(
name|temp_string
argument_list|)
expr_stmt|;
name|executing_string
operator|++
expr_stmt|;
name|reader_loop
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|popfile
argument_list|()
expr_stmt|;
name|executing_string
operator|--
expr_stmt|;
name|es
operator|->
name|in_use
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Return what would be output for STR, i.e., expand Texinfo commands.    If IMPLICIT_CODE is set, expand @code{STR}.  */
name|char
modifier|*
name|expansion
parameter_list|(
name|str
parameter_list|,
name|implicit_code
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|implicit_code
decl_stmt|;
block|{
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
comment|/* Inhibit any real output.  */
name|int
name|start
init|=
name|output_paragraph_offset
decl_stmt|;
name|int
name|saved_paragraph_is_open
init|=
name|paragraph_is_open
decl_stmt|;
name|inhibit_output_flushing
argument_list|()
expr_stmt|;
name|execute_string
argument_list|(
name|implicit_code
condition|?
literal|"@code{%s}"
else|:
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|uninhibit_output_flushing
argument_list|()
expr_stmt|;
comment|/* Copy the expansion from the buffer.  */
name|length
operator|=
name|output_paragraph_offset
operator|-
name|start
expr_stmt|;
name|result
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|length
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|result
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|output_paragraph
operator|+
name|start
operator|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|result
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Pretend it never happened.  */
name|output_paragraph_offset
operator|=
name|start
expr_stmt|;
name|paragraph_is_open
operator|=
name|saved_paragraph_is_open
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/* @itemx, @item. */
specifier|static
name|int
name|itemx_flag
init|=
literal|0
decl_stmt|;
name|void
name|cm_itemx
parameter_list|()
block|{
name|itemx_flag
operator|++
expr_stmt|;
name|cm_item
argument_list|()
expr_stmt|;
name|itemx_flag
operator|--
expr_stmt|;
block|}
name|void
name|cm_item
parameter_list|()
block|{
name|char
modifier|*
name|rest_of_line
decl_stmt|,
modifier|*
name|item_func
decl_stmt|;
comment|/* Can only hack "@item" while inside of an insertion. */
if|if
condition|(
name|insertion_level
condition|)
block|{
name|INSERTION_ELT
modifier|*
name|stack
init|=
name|insertion_stack
decl_stmt|;
name|int
name|original_input_text_offset
decl_stmt|;
name|skip_whitespace
argument_list|()
expr_stmt|;
name|original_input_text_offset
operator|=
name|input_text_offset
expr_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|rest_of_line
argument_list|)
expr_stmt|;
name|canon_white
argument_list|(
name|rest_of_line
argument_list|)
expr_stmt|;
name|item_func
operator|=
name|current_item_function
argument_list|()
expr_stmt|;
comment|/* Okay, do the right thing depending on which insertion function 	 is active. */
name|switch_top
label|:
switch|switch
condition|(
name|stack
operator|->
name|insertion
condition|)
block|{
case|case
name|multitable
case|:
name|multitable_item
argument_list|()
expr_stmt|;
comment|/* Ultra special hack.  It appears that some people incorrectly 	     place text directly after the @item, instead of on a new line 	     by itself.  This happens to work in TeX, so I make it work 	     here. */
if|if
condition|(
operator|*
name|rest_of_line
condition|)
block|{
name|line_number
operator|--
expr_stmt|;
name|input_text_offset
operator|=
name|original_input_text_offset
expr_stmt|;
block|}
break|break;
case|case
name|ifinfo
case|:
case|case
name|ifset
case|:
case|case
name|ifclear
case|:
case|case
name|cartouche
case|:
name|stack
operator|=
name|stack
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|stack
condition|)
goto|goto
name|no_insertion
goto|;
else|else
goto|goto
name|switch_top
goto|;
break|break;
case|case
name|menu
case|:
case|case
name|quotation
case|:
case|case
name|example
case|:
case|case
name|smallexample
case|:
case|case
name|lisp
case|:
case|case
name|format
case|:
case|case
name|display
case|:
case|case
name|group
case|:
name|line_error
argument_list|(
literal|"The `%c%s' command is meaningless within a `@%s' block"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|,
name|insertion_type_pname
argument_list|(
name|current_insertion_type
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|itemize
case|:
case|case
name|enumerate
case|:
if|if
condition|(
name|itemx_flag
condition|)
block|{
name|line_error
argument_list|(
literal|"%citemx is not meaningful inside of a `%s' block"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|insertion_type_pname
argument_list|(
name|current_insertion_type
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|start_paragraph
argument_list|()
expr_stmt|;
name|kill_self_indent
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|current_insertion_type
argument_list|()
operator|==
name|itemize
condition|)
block|{
name|indent
argument_list|(
name|output_column
operator|=
name|current_indent
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* I need some way to determine whether this command 		     takes braces or not.  I believe the user can type 		     either "@bullet" or "@bullet{}".  Of course, they 		     can also type "o" or "#" or whatever else they want. */
if|if
condition|(
name|item_func
operator|&&
operator|*
name|item_func
condition|)
block|{
if|if
condition|(
operator|*
name|item_func
operator|==
name|COMMAND_PREFIX
condition|)
if|if
condition|(
name|item_func
index|[
name|strlen
argument_list|(
name|item_func
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'}'
condition|)
name|execute_string
argument_list|(
literal|"%s{}"
argument_list|,
name|item_func
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|item_func
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|item_func
argument_list|)
expr_stmt|;
block|}
name|insert
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|output_column
operator|++
expr_stmt|;
block|}
else|else
name|enumerate_item
argument_list|()
expr_stmt|;
comment|/* Special hack.  This makes close paragraph ignore you until 		 the start_paragraph () function has been called. */
name|must_start_paragraph
operator|=
literal|1
expr_stmt|;
comment|/* Ultra special hack.  It appears that some people incorrectly 		 place text directly after the @item, instead of on a new line 		 by itself.  This happens to work in TeX, so I make it work 		 here. */
if|if
condition|(
operator|*
name|rest_of_line
condition|)
block|{
name|line_number
operator|--
expr_stmt|;
name|input_text_offset
operator|=
name|original_input_text_offset
expr_stmt|;
block|}
block|}
break|break;
case|case
name|table
case|:
case|case
name|ftable
case|:
case|case
name|vtable
case|:
block|{
comment|/* Get rid of extra characters. */
name|kill_self_indent
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* close_paragraph () almost does what we want.  The problem 	       is when paragraph_is_open, and last_char_was_newline, and 	       the last newline has been turned into a space, because 	       filling_enabled. I handle it here. */
if|if
condition|(
name|last_char_was_newline
operator|&&
name|filling_enabled
operator|&&
name|paragraph_is_open
condition|)
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INDENT_PARAGRAPHS_IN_TABLE
argument_list|)
comment|/* Indent on a new line, but back up one indentation level. */
block|{
name|int
name|t
decl_stmt|;
name|t
operator|=
name|inhibit_paragraph_indentation
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
comment|/* At this point, inserting any non-whitespace character will 		 force the existing indentation to be output. */
name|add_char
argument_list|(
literal|'i'
argument_list|)
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
name|t
expr_stmt|;
block|}
else|#
directive|else
comment|/* !INDENT_PARAGRAPHS_IN_TABLE */
name|add_char
argument_list|(
literal|'i'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !INDENT_PARAGRAPHS_IN_TABLE */
name|output_paragraph_offset
operator|--
expr_stmt|;
name|kill_self_indent
argument_list|(
name|default_indentation_increment
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Add item's argument to the line. */
name|filling_enabled
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|item_func
operator|&&
operator|*
name|item_func
condition|)
name|execute_string
argument_list|(
literal|"%s{%s}"
argument_list|,
name|item_func
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_insertion_type
argument_list|()
operator|==
name|ftable
condition|)
name|execute_string
argument_list|(
literal|"%cfindex %s\n"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_insertion_type
argument_list|()
operator|==
name|vtable
condition|)
name|execute_string
argument_list|(
literal|"%cvindex %s\n"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
comment|/* Start a new line, and let start_paragraph () 	       do the indenting of it for you. */
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|indented_fill
operator|=
name|filling_enabled
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|rest_of_line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|no_insertion
label|:
name|line_error
argument_list|(
literal|"%c%s found outside of an insertion block"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* **************************************************************** */
comment|/*								    */
comment|/*			Defun and Friends       		    */
comment|/*								    */
comment|/* **************************************************************** */
define|#
directive|define
name|DEFUN_SELF_DELIMITING
parameter_list|(
name|c
parameter_list|)
define|\
value|(((c) == '(')								\    || ((c) == ')')							\    || ((c) == '[')							\    || ((c) == ']'))
struct|struct
name|token_accumulator
block|{
name|unsigned
name|int
name|length
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
name|char
modifier|*
modifier|*
name|tokens
decl_stmt|;
block|}
struct|;
name|void
name|initialize_token_accumulator
parameter_list|(
name|accumulator
parameter_list|)
name|struct
name|token_accumulator
modifier|*
name|accumulator
decl_stmt|;
block|{
operator|(
name|accumulator
operator|->
name|length
operator|)
operator|=
literal|0
expr_stmt|;
operator|(
name|accumulator
operator|->
name|index
operator|)
operator|=
literal|0
expr_stmt|;
operator|(
name|accumulator
operator|->
name|tokens
operator|)
operator|=
name|NULL
expr_stmt|;
block|}
name|void
name|accumulate_token
parameter_list|(
name|accumulator
parameter_list|,
name|token
parameter_list|)
name|struct
name|token_accumulator
modifier|*
name|accumulator
decl_stmt|;
name|char
modifier|*
name|token
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|accumulator
operator|->
name|index
operator|)
operator|>=
operator|(
name|accumulator
operator|->
name|length
operator|)
condition|)
block|{
operator|(
name|accumulator
operator|->
name|length
operator|)
operator|+=
literal|10
expr_stmt|;
operator|(
name|accumulator
operator|->
name|tokens
operator|)
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|accumulator
operator|->
name|tokens
argument_list|,
operator|(
name|accumulator
operator|->
name|length
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|accumulator
operator|->
name|tokens
index|[
name|accumulator
operator|->
name|index
index|]
operator|=
name|token
expr_stmt|;
name|accumulator
operator|->
name|index
operator|+=
literal|1
expr_stmt|;
block|}
name|char
modifier|*
name|copy_substring
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
block|{
name|char
modifier|*
name|result
decl_stmt|,
modifier|*
name|scan
decl_stmt|,
modifier|*
name|scan_result
decl_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|end
operator|-
name|start
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|scan_result
operator|=
name|result
expr_stmt|;
name|scan
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|end
condition|)
operator|*
name|scan_result
operator|++
operator|=
operator|*
name|scan
operator|++
expr_stmt|;
operator|*
name|scan_result
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/* Given `string' pointing at an open brace, skip forward and return a    pointer to just past the matching close brace. */
name|int
name|scan_group_in_string
parameter_list|(
name|string_pointer
parameter_list|)
name|char
modifier|*
modifier|*
name|string_pointer
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|scan_string
decl_stmt|;
specifier|register
name|unsigned
name|int
name|level
init|=
literal|1
decl_stmt|;
name|scan_string
operator|=
operator|(
operator|*
name|string_pointer
operator|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|string_pointer
operator|)
operator|=
name|scan_string
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|c
operator|=
operator|(
operator|*
name|scan_string
operator|++
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
comment|/* Tweak line_number to compensate for fact that 	     we gobbled the whole line before coming here. */
name|line_number
operator|-=
literal|1
expr_stmt|;
name|line_error
argument_list|(
literal|"Missing `}' in %cdef arg"
argument_list|,
name|COMMAND_PREFIX
argument_list|)
expr_stmt|;
name|line_number
operator|+=
literal|1
expr_stmt|;
operator|(
operator|*
name|string_pointer
operator|)
operator|=
operator|(
name|scan_string
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
name|level
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
name|level
operator|-=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Return a list of tokens from the contents of `string'.    Commands and brace-delimited groups count as single tokens.    Contiguous whitespace characters are converted to a token    consisting of a single space. */
name|char
modifier|*
modifier|*
name|args_from_string
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|token_accumulator
name|accumulator
decl_stmt|;
specifier|register
name|char
modifier|*
name|scan_string
init|=
name|string
decl_stmt|;
name|char
modifier|*
name|token_start
decl_stmt|,
modifier|*
name|token_end
decl_stmt|;
name|initialize_token_accumulator
argument_list|(
operator|&
name|accumulator
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|scan_string
operator|)
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Replace arbitrary whitespace by a single space. */
if|if
condition|(
name|whitespace
argument_list|(
operator|*
name|scan_string
argument_list|)
condition|)
block|{
name|scan_string
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
name|whitespace
argument_list|(
operator|*
name|scan_string
argument_list|)
condition|)
name|scan_string
operator|+=
literal|1
expr_stmt|;
name|accumulate_token
argument_list|(
operator|(
operator|&
name|accumulator
operator|)
argument_list|,
operator|(
name|strdup
argument_list|(
literal|" "
argument_list|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Commands count as single tokens. */
if|if
condition|(
operator|(
operator|*
name|scan_string
operator|)
operator|==
name|COMMAND_PREFIX
condition|)
block|{
name|token_start
operator|=
name|scan_string
expr_stmt|;
name|scan_string
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|self_delimiting
argument_list|(
operator|*
name|scan_string
argument_list|)
condition|)
name|scan_string
operator|+=
literal|1
expr_stmt|;
else|else
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
operator|*
name|scan_string
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'{'
operator|)
operator|||
operator|(
name|whitespace
argument_list|(
name|c
argument_list|)
operator|)
condition|)
block|{
name|scan_string
operator|-=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|scan_string
operator|==
literal|'{'
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|scan_string
decl_stmt|;
operator|(
name|void
operator|)
name|scan_group_in_string
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|scan_string
operator|=
name|s
expr_stmt|;
block|}
block|}
name|token_end
operator|=
name|scan_string
expr_stmt|;
block|}
comment|/* Parentheses and brackets are self-delimiting. */
elseif|else
if|if
condition|(
name|DEFUN_SELF_DELIMITING
argument_list|(
operator|*
name|scan_string
argument_list|)
condition|)
block|{
name|token_start
operator|=
name|scan_string
expr_stmt|;
name|scan_string
operator|+=
literal|1
expr_stmt|;
name|token_end
operator|=
name|scan_string
expr_stmt|;
block|}
comment|/* Open brace introduces a group that is a single token. */
elseif|else
if|if
condition|(
operator|*
name|scan_string
operator|==
literal|'{'
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|scan_string
decl_stmt|;
name|int
name|balanced
init|=
name|scan_group_in_string
argument_list|(
operator|&
name|s
argument_list|)
decl_stmt|;
name|token_start
operator|=
name|scan_string
operator|+
literal|1
expr_stmt|;
name|scan_string
operator|=
name|s
expr_stmt|;
name|token_end
operator|=
name|balanced
condition|?
operator|(
name|scan_string
operator|-
literal|1
operator|)
else|:
name|scan_string
expr_stmt|;
block|}
comment|/* Otherwise a token is delimited by whitespace, parentheses, 	 brackets, or braces.  A token is also ended by a command. */
else|else
block|{
name|token_start
operator|=
name|scan_string
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|scan_string
operator|++
expr_stmt|;
comment|/* Do not back up if we're looking at a }; since the only                  valid }'s are those matched with {'s, we want to give                  an error.  If we back up, we go into an infinite loop.  */
if|if
condition|(
operator|!
name|c
operator|||
name|whitespace
argument_list|(
name|c
argument_list|)
operator|||
name|DEFUN_SELF_DELIMITING
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'{'
condition|)
block|{
name|scan_string
operator|--
expr_stmt|;
break|break;
block|}
comment|/* If we encounter a command embedded within a token, 		 then end the token. */
if|if
condition|(
name|c
operator|==
name|COMMAND_PREFIX
condition|)
block|{
name|scan_string
operator|--
expr_stmt|;
break|break;
block|}
block|}
name|token_end
operator|=
name|scan_string
expr_stmt|;
block|}
name|accumulate_token
argument_list|(
operator|&
name|accumulator
argument_list|,
name|copy_substring
argument_list|(
name|token_start
argument_list|,
name|token_end
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|accumulate_token
argument_list|(
operator|&
name|accumulator
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|accumulator
operator|.
name|tokens
operator|)
return|;
block|}
name|void
name|process_defun_args
parameter_list|(
name|defun_args
parameter_list|,
name|auto_var_p
parameter_list|)
name|char
modifier|*
modifier|*
name|defun_args
decl_stmt|;
name|int
name|auto_var_p
decl_stmt|;
block|{
name|int
name|pending_space
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|defun_arg
init|=
operator|*
name|defun_args
operator|++
decl_stmt|;
if|if
condition|(
name|defun_arg
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|defun_arg
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
block|{
name|pending_space
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pending_space
condition|)
block|{
name|add_char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|pending_space
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|DEFUN_SELF_DELIMITING
argument_list|(
name|defun_arg
index|[
literal|0
index|]
argument_list|)
condition|)
name|add_char
argument_list|(
name|defun_arg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|defun_arg
index|[
literal|0
index|]
operator|==
literal|'&'
condition|)
name|add_word
argument_list|(
name|defun_arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|defun_arg
index|[
literal|0
index|]
operator|==
name|COMMAND_PREFIX
condition|)
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|defun_arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|auto_var_p
condition|)
name|execute_string
argument_list|(
literal|"%cvar{%s}"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|defun_arg
argument_list|)
expr_stmt|;
else|else
name|add_word
argument_list|(
name|defun_arg
argument_list|)
expr_stmt|;
block|}
block|}
name|char
modifier|*
name|next_nonwhite_defun_arg
parameter_list|(
name|arg_pointer
parameter_list|)
name|char
modifier|*
modifier|*
modifier|*
name|arg_pointer
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|scan
init|=
operator|(
operator|*
name|arg_pointer
operator|)
decl_stmt|;
name|char
modifier|*
name|arg
init|=
operator|(
operator|*
name|scan
operator|++
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|arg
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|*
name|arg
operator|==
literal|' '
operator|)
condition|)
name|arg
operator|=
operator|*
name|scan
operator|++
expr_stmt|;
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
name|scan
operator|-=
literal|1
expr_stmt|;
operator|*
name|arg_pointer
operator|=
name|scan
expr_stmt|;
return|return
operator|(
operator|(
name|arg
operator|==
literal|0
operator|)
condition|?
literal|""
else|:
name|arg
operator|)
return|;
block|}
comment|/* Make the defun type insertion.    TYPE says which insertion this is.    X_P says not to start a new insertion if non-zero. */
name|void
name|defun_internal
parameter_list|(
name|type
parameter_list|,
name|x_p
parameter_list|)
name|enum
name|insertion_type
name|type
decl_stmt|;
name|int
name|x_p
decl_stmt|;
block|{
name|enum
name|insertion_type
name|base_type
decl_stmt|;
name|char
modifier|*
modifier|*
name|defun_args
decl_stmt|,
modifier|*
modifier|*
name|scan_args
decl_stmt|;
name|char
modifier|*
name|category
decl_stmt|,
modifier|*
name|defined_name
decl_stmt|,
modifier|*
name|type_name
decl_stmt|,
modifier|*
name|type_name2
decl_stmt|;
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|defun_args
operator|=
operator|(
name|args_from_string
argument_list|(
name|line
argument_list|)
operator|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|scan_args
operator|=
name|defun_args
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|defun
case|:
name|category
operator|=
literal|"Function"
expr_stmt|;
name|base_type
operator|=
name|deffn
expr_stmt|;
break|break;
case|case
name|defmac
case|:
name|category
operator|=
literal|"Macro"
expr_stmt|;
name|base_type
operator|=
name|deffn
expr_stmt|;
break|break;
case|case
name|defspec
case|:
name|category
operator|=
literal|"Special Form"
expr_stmt|;
name|base_type
operator|=
name|deffn
expr_stmt|;
break|break;
case|case
name|defvar
case|:
name|category
operator|=
literal|"Variable"
expr_stmt|;
name|base_type
operator|=
name|defvr
expr_stmt|;
break|break;
case|case
name|defopt
case|:
name|category
operator|=
literal|"User Option"
expr_stmt|;
name|base_type
operator|=
name|defvr
expr_stmt|;
break|break;
case|case
name|deftypefun
case|:
name|category
operator|=
literal|"Function"
expr_stmt|;
name|base_type
operator|=
name|deftypefn
expr_stmt|;
break|break;
case|case
name|deftypevar
case|:
name|category
operator|=
literal|"Variable"
expr_stmt|;
name|base_type
operator|=
name|deftypevr
expr_stmt|;
break|break;
case|case
name|defivar
case|:
name|category
operator|=
literal|"Instance Variable"
expr_stmt|;
name|base_type
operator|=
name|defcv
expr_stmt|;
break|break;
case|case
name|defmethod
case|:
name|category
operator|=
literal|"Method"
expr_stmt|;
name|base_type
operator|=
name|defop
expr_stmt|;
break|break;
case|case
name|deftypemethod
case|:
name|category
operator|=
literal|"Method"
expr_stmt|;
name|base_type
operator|=
name|deftypemethod
expr_stmt|;
break|break;
default|default:
name|category
operator|=
name|next_nonwhite_defun_arg
argument_list|(
operator|&
name|scan_args
argument_list|)
expr_stmt|;
name|base_type
operator|=
name|type
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|base_type
operator|==
name|deftypefn
operator|)
operator|||
operator|(
name|base_type
operator|==
name|deftypevr
operator|)
operator|||
operator|(
name|base_type
operator|==
name|defcv
operator|)
operator|||
operator|(
name|base_type
operator|==
name|defop
operator|)
operator|||
operator|(
name|base_type
operator|==
name|deftypemethod
operator|)
condition|)
name|type_name
operator|=
name|next_nonwhite_defun_arg
argument_list|(
operator|&
name|scan_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_type
operator|==
name|deftypemethod
condition|)
name|type_name2
operator|=
name|next_nonwhite_defun_arg
argument_list|(
operator|&
name|scan_args
argument_list|)
expr_stmt|;
name|defined_name
operator|=
name|next_nonwhite_defun_arg
argument_list|(
operator|&
name|scan_args
argument_list|)
expr_stmt|;
comment|/* This hack exists solely for the purposes of formatting the texinfo      manual.  I couldn't think of a better way.  The token might be      a simple @@ followed immediately by more text.  If this is the case,      then the next defun arg is part of this one, and we should concatenate      them. */
if|if
condition|(
operator|*
name|scan_args
operator|&&
operator|*
operator|*
name|scan_args
operator|&&
operator|!
name|whitespace
argument_list|(
operator|*
operator|*
name|scan_args
argument_list|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|defined_name
argument_list|,
literal|"@@"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|char
modifier|*
name|tem
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|3
operator|+
name|strlen
argument_list|(
name|scan_args
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|tem
argument_list|,
literal|"@@%s"
argument_list|,
name|scan_args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scan_args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|scan_args
index|[
literal|0
index|]
operator|=
name|tem
expr_stmt|;
name|scan_args
operator|++
expr_stmt|;
name|defined_name
operator|=
name|tem
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|x_p
condition|)
name|begin_insertion
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Write the definition header line.      This should start at the normal indentation.  */
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
name|start_paragraph
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|deffn
case|:
case|case
name|defvr
case|:
case|case
name|deftp
case|:
name|execute_string
argument_list|(
literal|" -- %s: %s"
argument_list|,
name|category
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|deftypefn
case|:
case|case
name|deftypevr
case|:
name|execute_string
argument_list|(
literal|" -- %s: %s %s"
argument_list|,
name|category
argument_list|,
name|type_name
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|defcv
case|:
name|execute_string
argument_list|(
literal|" -- %s of %s: %s"
argument_list|,
name|category
argument_list|,
name|type_name
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|defop
case|:
name|execute_string
argument_list|(
literal|" -- %s on %s: %s"
argument_list|,
name|category
argument_list|,
name|type_name
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|deftypemethod
case|:
name|execute_string
argument_list|(
literal|" -- %s on %s: %s %s"
argument_list|,
name|category
argument_list|,
name|type_name
argument_list|,
name|type_name2
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
block|}
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
comment|/* Now process the function arguments, if any.      If these carry onto the next line, they should be indented by two      increments to distinguish them from the body of the definition,      which is indented by one increment.  */
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|deffn
case|:
case|case
name|defop
case|:
name|process_defun_args
argument_list|(
name|scan_args
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|deftp
case|:
case|case
name|deftypefn
case|:
case|case
name|deftypemethod
case|:
name|process_defun_args
argument_list|(
name|scan_args
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
name|close_single_paragraph
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|macro_expansion_output_stream
condition|)
comment|/* Make an entry in the appropriate index unless we are just        expanding macros. */
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|deffn
case|:
case|case
name|deftypefn
case|:
name|execute_string
argument_list|(
literal|"%cfindex %s\n"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|defvr
case|:
case|case
name|deftypevr
case|:
case|case
name|defcv
case|:
name|execute_string
argument_list|(
literal|"%cvindex %s\n"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|defop
case|:
case|case
name|deftypemethod
case|:
name|execute_string
argument_list|(
literal|"%cfindex %s on %s\n"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|defined_name
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|deftp
case|:
name|execute_string
argument_list|(
literal|"%ctindex %s\n"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Deallocate the token list. */
name|scan_args
operator|=
name|defun_args
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|arg
init|=
operator|(
operator|*
name|scan_args
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
break|break;
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|defun_args
argument_list|)
expr_stmt|;
block|}
comment|/* Add an entry for a function, macro, special form, variable, or option.    If the name of the calling command ends in `x', then this is an extra    entry included in the body of an insertion of the same type. */
name|void
name|cm_defun
parameter_list|()
block|{
name|int
name|x_p
decl_stmt|;
name|enum
name|insertion_type
name|type
decl_stmt|;
name|char
modifier|*
name|temp
init|=
name|strdup
argument_list|(
name|command
argument_list|)
decl_stmt|;
name|x_p
operator|=
operator|(
name|command
index|[
name|strlen
argument_list|(
name|command
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'x'
operator|)
expr_stmt|;
if|if
condition|(
name|x_p
condition|)
name|temp
index|[
name|strlen
argument_list|(
name|temp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|type
operator|=
name|find_type_from_name
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* If we are adding to an already existing insertion, then make sure      that we are already in an insertion of type TYPE. */
if|if
condition|(
name|x_p
operator|&&
operator|(
operator|!
name|insertion_level
operator|||
name|insertion_stack
operator|->
name|insertion
operator|!=
name|type
operator|)
condition|)
block|{
name|line_error
argument_list|(
literal|"Must be in a `%s' insertion in order to use `%s'x"
argument_list|,
name|command
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|defun_internal
argument_list|(
name|type
argument_list|,
name|x_p
argument_list|)
expr_stmt|;
block|}
comment|/* End existing insertion block. */
name|void
name|cm_end
parameter_list|()
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|enum
name|insertion_type
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|insertion_level
condition|)
block|{
name|line_error
argument_list|(
literal|"Unmatched `%c%s'"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
return|return;
block|}
name|get_rest_of_line
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
name|canon_white
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|temp
argument_list|)
operator|==
literal|0
condition|)
name|line_error
argument_list|(
literal|"`%c%s' needs something after it"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|type
operator|=
name|find_type_from_name
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|bad_type
condition|)
block|{
name|line_error
argument_list|(
literal|"Bad argument to `%s', `%s', using `%s'"
argument_list|,
name|command
argument_list|,
name|temp
argument_list|,
name|insertion_type_pname
argument_list|(
name|current_insertion_type
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|end_insertion
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* **************************************************************** */
comment|/*								    */
comment|/*			Other Random Commands		   	    */
comment|/*								    */
comment|/* **************************************************************** */
comment|/* This says to inhibit the indentation of the next paragraph, but    not of following paragraphs.  */
name|void
name|cm_noindent
parameter_list|()
block|{
if|if
condition|(
operator|!
name|inhibit_paragraph_indentation
condition|)
name|inhibit_paragraph_indentation
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* I don't know exactly what to do with this.  Should I allow    someone to switch filenames in the middle of output?  Since the    file could be partially written, this doesn't seem to make sense.    Another option: ignore it, since they don't *really* want to    switch files.  Finally, complain, or at least warn. */
name|void
name|cm_setfilename
parameter_list|()
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|filename
argument_list|)
expr_stmt|;
comment|/* warning ("`@%s %s' encountered and ignored", command, filename); */
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
name|void
name|cm_ignore_line
parameter_list|()
block|{
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* @br can be immediately followed by `{}', so we have to read those here.    It should simply close the paragraph. */
name|void
name|cm_br
parameter_list|()
block|{
if|if
condition|(
name|looking_at
argument_list|(
literal|"{}"
argument_list|)
condition|)
name|input_text_offset
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|'\n'
condition|)
block|{
name|input_text_offset
operator|++
expr_stmt|;
name|line_number
operator|++
expr_stmt|;
block|}
name|close_paragraph
argument_list|()
expr_stmt|;
block|}
comment|/* Insert the number of blank lines passed as argument. */
name|void
name|cm_sp
parameter_list|()
block|{
name|int
name|lines
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|line
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|lines
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|line_error
argument_list|(
literal|"%csp requires a positive numeric argument"
argument_list|,
name|COMMAND_PREFIX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lines
operator|<
literal|0
condition|)
name|lines
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lines
operator|--
condition|)
name|add_char
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
comment|/* @dircategory LINE  outputs  INFO-DIR-SECTION LINE,    but not if --no-headers.  */
name|void
name|cm_dircategory
parameter_list|()
block|{
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
empty_stmt|;
if|if
condition|(
operator|!
name|no_headers
condition|)
block|{
name|insert_string
argument_list|(
literal|"INFO-DIR-SECTION "
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
comment|/* Start a new line with just this text on it.    Then center the line of text.    This always ends the current paragraph. */
name|void
name|cm_center
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|start
decl_stmt|,
name|length
decl_stmt|;
name|int
name|fudge_factor
init|=
literal|1
decl_stmt|;
name|unsigned
name|char
modifier|*
name|line
decl_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|0
expr_stmt|;
name|cm_noindent
argument_list|()
expr_stmt|;
name|start
operator|=
name|output_paragraph_offset
expr_stmt|;
name|inhibit_output_flushing
argument_list|()
expr_stmt|;
name|get_rest_of_line
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|line
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|uninhibit_output_flushing
argument_list|()
expr_stmt|;
name|i
operator|=
name|output_paragraph_offset
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|>
operator|(
name|start
operator|-
literal|1
operator|)
operator|&&
name|output_paragraph
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
name|i
operator|--
expr_stmt|;
name|output_paragraph_offset
operator|=
operator|++
name|i
expr_stmt|;
name|length
operator|=
name|output_paragraph_offset
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|length
operator|<
operator|(
name|fill_column
operator|-
name|fudge_factor
operator|)
condition|)
block|{
name|line
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|length
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|line
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|output_paragraph
operator|+
name|start
operator|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|fill_column
operator|-
name|fudge_factor
operator|-
name|length
operator|)
operator|/
literal|2
expr_stmt|;
name|output_paragraph_offset
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
name|insert
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
name|insert
argument_list|(
name|line
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Show what an expression returns. */
name|void
name|cm_result
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|add_word
argument_list|(
literal|"=>"
argument_list|)
expr_stmt|;
block|}
comment|/* What an expression expands to. */
name|void
name|cm_expansion
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|add_word
argument_list|(
literal|"==>"
argument_list|)
expr_stmt|;
block|}
comment|/* Indicates two expressions are equivalent. */
name|void
name|cm_equiv
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|add_word
argument_list|(
literal|"=="
argument_list|)
expr_stmt|;
block|}
comment|/* What an expression may print. */
name|void
name|cm_print
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|add_word
argument_list|(
literal|"-|"
argument_list|)
expr_stmt|;
block|}
comment|/* An error signaled. */
name|void
name|cm_error
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|add_word
argument_list|(
literal|"error-->"
argument_list|)
expr_stmt|;
block|}
comment|/* The location of point in an example of a buffer. */
name|void
name|cm_point
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|add_word
argument_list|(
literal|"-!-"
argument_list|)
expr_stmt|;
block|}
comment|/* Start a new line with just this text on it.    The text is outdented one level if possible. */
name|void
name|cm_exdent
parameter_list|()
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|i
init|=
name|current_indent
decl_stmt|;
if|if
condition|(
name|current_indent
condition|)
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|current_indent
operator|=
name|i
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|close_single_paragraph
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_STRERROR
argument_list|)
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
name|char
modifier|*
name|strerror
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
if|if
condition|(
name|num
operator|>=
name|sys_nerr
condition|)
return|return
operator|(
literal|"Unknown file system error"
operator|)
return|;
else|else
return|return
operator|(
name|sys_errlist
index|[
name|num
index|]
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* !HAVE_STRERROR */
comment|/* Remember this file, and move onto the next. */
name|void
name|cm_include
parameter_list|()
block|{
name|char
modifier|*
name|filename
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
if|if
condition|(
name|macro_expansion_output_stream
condition|)
name|me_append_before_this_command
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MACROS */
name|close_paragraph
argument_list|()
expr_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|filename
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
if|if
condition|(
name|macro_expansion_output_stream
condition|)
name|remember_itext
argument_list|(
name|input_text
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MACROS */
name|pushfile
argument_list|()
expr_stmt|;
comment|/* In verbose mode we print info about including another file. */
if|if
condition|(
name|verbose_mode
condition|)
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|register
name|FSTACK
modifier|*
name|stack
init|=
name|filestack
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|stack
operator|=
name|filestack
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
operator|,
name|i
operator|++
control|)
empty_stmt|;
name|i
operator|*=
literal|2
expr_stmt|;
name|printf
argument_list|(
literal|"%*s"
argument_list|,
name|i
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c%s %s\n"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|find_and_load
argument_list|(
name|filename
argument_list|)
condition|)
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
name|popfile
argument_list|()
expr_stmt|;
name|line_number
operator|--
expr_stmt|;
comment|/* Cannot "@include foo", in line 5 of "/wh/bar". */
name|line_error
argument_list|(
literal|"`%c%s %s': %s"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
if|if
condition|(
name|macro_expansion_output_stream
condition|)
name|remember_itext
argument_list|(
name|input_text
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MACROS */
name|reader_loop
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|popfile
argument_list|()
expr_stmt|;
block|}
comment|/* The other side of a malformed expression. */
name|void
name|misplaced_brace
parameter_list|()
block|{
name|line_error
argument_list|(
literal|"Misplaced `}'"
argument_list|)
expr_stmt|;
block|}
comment|/* Signals end of processing.  Easy to make this happen. */
name|void
name|cm_bye
parameter_list|()
block|{
name|input_text_offset
operator|=
name|size_of_input_text
expr_stmt|;
block|}
comment|/* **************************************************************** */
comment|/*								    */
comment|/*			Indexing Stuff				    */
comment|/*								    */
comment|/* **************************************************************** */
comment|/* An index element... */
typedef|typedef
struct|struct
name|index_elt
block|{
name|struct
name|index_elt
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|entry
decl_stmt|;
comment|/* The index entry itself. */
name|char
modifier|*
name|node
decl_stmt|;
comment|/* The node from whence it came. */
name|int
name|code
decl_stmt|;
comment|/* Non-zero means add `@code{...}' when 				   printing this element. */
name|int
name|defining_line
decl_stmt|;
comment|/* Line number where this entry was written. */
block|}
name|INDEX_ELT
typedef|;
comment|/* A list of short-names for each index, and the index to that index in our    index array, the_indices.  In addition, for each index, it is remembered    whether that index is a code index or not.  Code indices have @code{}    inserted around the first word when they are printed with printindex. */
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|code
decl_stmt|;
block|}
name|INDEX_ALIST
typedef|;
name|INDEX_ALIST
modifier|*
modifier|*
name|name_index_alist
init|=
operator|(
name|INDEX_ALIST
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* An array of pointers.  Each one is for a different index.  The    "synindex" command changes which array slot is pointed to by a    given "index". */
name|INDEX_ELT
modifier|*
modifier|*
name|the_indices
init|=
operator|(
name|INDEX_ELT
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* The number of defined indices. */
name|int
name|defined_indices
init|=
literal|0
decl_stmt|;
comment|/* We predefine these. */
define|#
directive|define
name|program_index
value|0
define|#
directive|define
name|function_index
value|1
define|#
directive|define
name|concept_index
value|2
define|#
directive|define
name|variable_index
value|3
define|#
directive|define
name|datatype_index
value|4
define|#
directive|define
name|key_index
value|5
name|void
name|init_indices
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* Create the default data structures. */
comment|/* Initialize data space. */
if|if
condition|(
operator|!
name|the_indices
condition|)
block|{
name|the_indices
operator|=
operator|(
name|INDEX_ELT
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
name|defined_indices
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ELT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|the_indices
index|[
name|defined_indices
index|]
operator|=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|NULL
expr_stmt|;
name|name_index_alist
operator|=
operator|(
name|INDEX_ALIST
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
name|defined_indices
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ALIST
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|name_index_alist
index|[
name|defined_indices
index|]
operator|=
operator|(
name|INDEX_ALIST
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* If there were existing indices, get rid of them now. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|defined_indices
condition|;
name|i
operator|++
control|)
name|undefindex
argument_list|(
name|name_index_alist
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Add the default indices. */
name|top_defindex
argument_list|(
literal|"pg"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|top_defindex
argument_list|(
literal|"fn"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* "fn" is a code index.  */
name|top_defindex
argument_list|(
literal|"cp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|top_defindex
argument_list|(
literal|"vr"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|top_defindex
argument_list|(
literal|"tp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|top_defindex
argument_list|(
literal|"ky"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Find which element in the known list of indices has this name.    Returns -1 if NAME isn't found. */
name|int
name|find_index_offset
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|defined_indices
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name_index_alist
index|[
name|i
index|]
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|name_index_alist
index|[
name|i
index|]
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|name_index_alist
index|[
name|i
index|]
operator|->
name|index
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Return a pointer to the entry of (name . index) for this name.    Return NULL if the index doesn't exist. */
name|INDEX_ALIST
modifier|*
name|find_index
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|offset
init|=
name|find_index_offset
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|>
operator|-
literal|1
condition|)
return|return
operator|(
name|name_index_alist
index|[
name|offset
index|]
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|INDEX_ALIST
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
comment|/* Given an index name, return the offset in the_indices of this index,    or -1 if there is no such index. */
name|int
name|translate_index
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|INDEX_ALIST
modifier|*
name|which
init|=
name|find_index
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|which
condition|)
return|return
operator|(
name|which
operator|->
name|index
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Return the index list which belongs to NAME. */
name|INDEX_ELT
modifier|*
name|index_list
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|which
init|=
name|translate_index
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|which
operator|<
literal|0
condition|)
return|return
operator|(
operator|(
name|INDEX_ELT
operator|*
operator|)
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|the_indices
index|[
name|which
index|]
operator|)
return|;
block|}
comment|/* Please release me, let me go... */
name|void
name|free_index
parameter_list|(
name|index
parameter_list|)
name|INDEX_ELT
modifier|*
name|index
decl_stmt|;
block|{
name|INDEX_ELT
modifier|*
name|temp
decl_stmt|;
while|while
condition|(
operator|(
name|temp
operator|=
name|index
operator|)
operator|!=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|NULL
condition|)
block|{
name|free
argument_list|(
name|temp
operator|->
name|entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|node
argument_list|)
expr_stmt|;
name|index
operator|=
name|index
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Flush an index by name. */
name|void
name|undefindex
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|which
init|=
name|find_index_offset
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|which
operator|<
literal|0
condition|)
return|return;
name|i
operator|=
name|name_index_alist
index|[
name|which
index|]
operator|->
name|index
expr_stmt|;
name|free_index
argument_list|(
name|the_indices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|the_indices
index|[
name|i
index|]
operator|=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|NULL
expr_stmt|;
name|free
argument_list|(
name|name_index_alist
index|[
name|which
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name_index_alist
index|[
name|which
index|]
argument_list|)
expr_stmt|;
name|name_index_alist
index|[
name|which
index|]
operator|=
operator|(
name|INDEX_ALIST
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* Define an index known as NAME.  We assign the slot number.    CODE if non-zero says to make this a code index. */
name|void
name|defindex
parameter_list|(
name|name
parameter_list|,
name|code
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|slot
decl_stmt|;
comment|/* If it already exists, flush it. */
name|undefindex
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Try to find an empty slot. */
name|slot
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|defined_indices
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|name_index_alist
index|[
name|i
index|]
condition|)
block|{
name|slot
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|slot
operator|<
literal|0
condition|)
block|{
comment|/* No such luck.  Make space for another index. */
name|slot
operator|=
name|defined_indices
expr_stmt|;
name|defined_indices
operator|++
expr_stmt|;
name|name_index_alist
operator|=
operator|(
name|INDEX_ALIST
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name_index_alist
argument_list|,
operator|(
literal|1
operator|+
name|defined_indices
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ALIST
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|the_indices
operator|=
operator|(
name|INDEX_ELT
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|the_indices
argument_list|,
operator|(
literal|1
operator|+
name|defined_indices
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ELT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We have a slot.  Start assigning. */
name|name_index_alist
index|[
name|slot
index|]
operator|=
operator|(
name|INDEX_ALIST
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|INDEX_ALIST
argument_list|)
argument_list|)
expr_stmt|;
name|name_index_alist
index|[
name|slot
index|]
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name_index_alist
index|[
name|slot
index|]
operator|->
name|index
operator|=
name|slot
expr_stmt|;
name|name_index_alist
index|[
name|slot
index|]
operator|->
name|code
operator|=
name|code
expr_stmt|;
name|the_indices
index|[
name|slot
index|]
operator|=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* Add the arguments to the current index command to the index NAME. */
name|void
name|index_add_arg
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|which
decl_stmt|;
name|char
modifier|*
name|index_entry
decl_stmt|;
name|INDEX_ALIST
modifier|*
name|tem
decl_stmt|;
name|tem
operator|=
name|find_index
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|which
operator|=
name|tem
condition|?
name|tem
operator|->
name|index
else|:
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
if|if
condition|(
name|macro_expansion_output_stream
condition|)
name|append_to_expansion_output
argument_list|(
name|input_text_offset
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MACROS */
name|get_rest_of_line
argument_list|(
operator|&
name|index_entry
argument_list|)
expr_stmt|;
name|ignore_blank_line
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
if|if
condition|(
name|macro_expansion_output_stream
condition|)
block|{
name|int
name|op_orig
decl_stmt|;
name|remember_itext
argument_list|(
name|input_text
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
name|op_orig
operator|=
name|output_paragraph_offset
expr_stmt|;
name|me_execute_string
argument_list|(
name|index_entry
argument_list|)
expr_stmt|;
name|me_execute_string
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|output_paragraph_offset
operator|=
name|op_orig
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_MACROS */
if|if
condition|(
name|which
operator|<
literal|0
condition|)
block|{
name|line_error
argument_list|(
literal|"Unknown index reference `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|index_entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|INDEX_ELT
modifier|*
name|new
init|=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|INDEX_ELT
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|next
operator|=
name|the_indices
index|[
name|which
index|]
expr_stmt|;
name|new
operator|->
name|entry
operator|=
name|index_entry
expr_stmt|;
name|new
operator|->
name|node
operator|=
name|current_node
expr_stmt|;
name|new
operator|->
name|code
operator|=
name|tem
operator|->
name|code
expr_stmt|;
name|new
operator|->
name|defining_line
operator|=
name|line_number
operator|-
literal|1
expr_stmt|;
name|the_indices
index|[
name|which
index|]
operator|=
name|new
expr_stmt|;
block|}
block|}
define|#
directive|define
name|INDEX_COMMAND_SUFFIX
value|"index"
comment|/* The function which user defined index commands call. */
name|void
name|gen_index
parameter_list|()
block|{
name|char
modifier|*
name|name
init|=
name|strdup
argument_list|(
name|command
argument_list|)
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|>=
name|strlen
argument_list|(
literal|"index"
argument_list|)
condition|)
name|name
index|[
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
name|strlen
argument_list|(
literal|"index"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|index_add_arg
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|void
name|top_defindex
parameter_list|(
name|name
parameter_list|,
name|code
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
literal|"index"
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%sindex"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|define_user_command
argument_list|(
name|temp
argument_list|,
name|gen_index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|defindex
argument_list|(
name|name
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* Define a new index command.  Arg is name of index. */
name|void
name|cm_defindex
parameter_list|()
block|{
name|gen_defindex
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|void
name|cm_defcodeindex
parameter_list|()
block|{
name|gen_defindex
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|void
name|gen_defindex
parameter_list|(
name|code
parameter_list|)
name|int
name|code
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_index
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|line_error
argument_list|(
literal|"Index `%s' already exists"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
literal|"index"
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%sindex"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|define_user_command
argument_list|(
name|temp
argument_list|,
name|gen_index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|defindex
argument_list|(
name|name
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Append LIST2 to LIST1.  Return the head of the list. */
name|INDEX_ELT
modifier|*
name|index_append
parameter_list|(
name|head
parameter_list|,
name|tail
parameter_list|)
name|INDEX_ELT
modifier|*
name|head
decl_stmt|,
decl|*
name|tail
decl_stmt|;
block|{
specifier|register
name|INDEX_ELT
modifier|*
name|t_head
init|=
name|head
decl_stmt|;
if|if
condition|(
operator|!
name|t_head
condition|)
return|return
operator|(
name|tail
operator|)
return|;
while|while
condition|(
name|t_head
operator|->
name|next
condition|)
name|t_head
operator|=
name|t_head
operator|->
name|next
expr_stmt|;
name|t_head
operator|->
name|next
operator|=
name|tail
expr_stmt|;
return|return
operator|(
name|head
operator|)
return|;
block|}
comment|/* Expects 2 args, on the same line.  Both are index abbreviations.    Make the first one be a synonym for the second one, i.e. make the    first one have the same index as the second one. */
name|void
name|cm_synindex
parameter_list|()
block|{
name|int
name|redirector
decl_stmt|,
name|redirectee
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|skip_whitespace
argument_list|()
expr_stmt|;
name|get_until_in_line
argument_list|(
literal|" "
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|redirectee
operator|=
name|find_index_offset
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|skip_whitespace
argument_list|()
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
name|get_until_in_line
argument_list|(
literal|" "
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|redirector
operator|=
name|find_index_offset
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|redirector
operator|<
literal|0
operator|||
name|redirectee
operator|<
literal|0
condition|)
block|{
name|line_error
argument_list|(
literal|"Unknown index reference"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* I think that we should let the user make indices synonymous to          each other without any lossage of info.  This means that one can          say @synindex cp dt anywhere in the file, and things that used to          be in cp will go into dt. */
name|INDEX_ELT
modifier|*
name|i1
init|=
name|the_indices
index|[
name|redirectee
index|]
decl_stmt|,
modifier|*
name|i2
init|=
name|the_indices
index|[
name|redirector
index|]
decl_stmt|;
if|if
condition|(
name|i1
operator|||
name|i2
condition|)
block|{
if|if
condition|(
name|i1
condition|)
name|the_indices
index|[
name|redirectee
index|]
operator|=
name|index_append
argument_list|(
name|i1
argument_list|,
name|i2
argument_list|)
expr_stmt|;
else|else
name|the_indices
index|[
name|redirectee
index|]
operator|=
name|index_append
argument_list|(
name|i2
argument_list|,
name|i1
argument_list|)
expr_stmt|;
block|}
name|name_index_alist
index|[
name|redirectee
index|]
operator|->
name|index
operator|=
name|name_index_alist
index|[
name|redirector
index|]
operator|->
name|index
expr_stmt|;
block|}
block|}
name|void
name|cm_pindex
parameter_list|()
comment|/* Pinhead index. */
block|{
name|index_add_arg
argument_list|(
literal|"pg"
argument_list|)
expr_stmt|;
block|}
name|void
name|cm_vindex
parameter_list|()
comment|/* Variable index. */
block|{
name|index_add_arg
argument_list|(
literal|"vr"
argument_list|)
expr_stmt|;
block|}
name|void
name|cm_kindex
parameter_list|()
comment|/* Key index. */
block|{
name|index_add_arg
argument_list|(
literal|"ky"
argument_list|)
expr_stmt|;
block|}
name|void
name|cm_cindex
parameter_list|()
comment|/* Concept index. */
block|{
name|index_add_arg
argument_list|(
literal|"cp"
argument_list|)
expr_stmt|;
block|}
name|void
name|cm_findex
parameter_list|()
comment|/* Function index. */
block|{
name|index_add_arg
argument_list|(
literal|"fn"
argument_list|)
expr_stmt|;
block|}
name|void
name|cm_tindex
parameter_list|()
comment|/* Data Type index. */
block|{
name|index_add_arg
argument_list|(
literal|"tp"
argument_list|)
expr_stmt|;
block|}
comment|/* Sorting the index. */
name|int
name|index_element_compare
parameter_list|(
name|element1
parameter_list|,
name|element2
parameter_list|)
name|INDEX_ELT
modifier|*
modifier|*
name|element1
decl_stmt|,
decl|*
modifier|*
name|element2
decl_stmt|;
block|{
return|return
operator|(
name|strcasecmp
argument_list|(
operator|(
operator|*
name|element1
operator|)
operator|->
name|entry
argument_list|,
operator|(
operator|*
name|element2
operator|)
operator|->
name|entry
argument_list|)
operator|)
return|;
block|}
comment|/* Force all index entries to be unique. */
name|void
name|make_index_entries_unique
parameter_list|(
name|array
parameter_list|,
name|count
parameter_list|)
name|INDEX_ELT
modifier|*
modifier|*
name|array
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|INDEX_ELT
modifier|*
modifier|*
name|copy
decl_stmt|;
name|int
name|counter
init|=
literal|1
decl_stmt|;
name|copy
operator|=
operator|(
name|INDEX_ELT
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
name|count
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ELT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|==
operator|(
name|count
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|array
index|[
name|i
index|]
operator|->
name|node
operator|!=
name|array
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|node
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|array
index|[
name|i
index|]
operator|->
name|entry
argument_list|,
name|array
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|entry
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|copy
index|[
name|j
operator|++
index|]
operator|=
name|array
index|[
name|i
index|]
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|array
index|[
name|i
index|]
operator|->
name|entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|copy
index|[
name|j
index|]
operator|=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Now COPY contains only unique entries.  Duplicated entries in the      original array have been freed.  Replace the current array with      the copy, fixing the NEXT pointers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|copy
index|[
name|i
index|]
operator|!=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|copy
index|[
name|i
index|]
operator|->
name|next
operator|=
name|copy
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
comment|/* Fix entry names which are the same.  They point to different nodes, 	 so we make the entry name unique. */
if|if
condition|(
operator|(
name|copy
index|[
name|i
operator|+
literal|1
index|]
operator|!=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|copy
index|[
name|i
index|]
operator|->
name|entry
argument_list|,
name|copy
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|entry
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|char
modifier|*
name|new_entry_name
decl_stmt|;
name|new_entry_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|10
operator|+
name|strlen
argument_list|(
name|copy
index|[
name|i
index|]
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new_entry_name
argument_list|,
literal|"%s<%d>"
argument_list|,
name|copy
index|[
name|i
index|]
operator|->
name|entry
argument_list|,
name|counter
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|copy
index|[
name|i
index|]
operator|->
name|entry
argument_list|)
expr_stmt|;
name|copy
index|[
name|i
index|]
operator|->
name|entry
operator|=
name|new_entry_name
expr_stmt|;
name|counter
operator|++
expr_stmt|;
block|}
else|else
name|counter
operator|=
literal|1
expr_stmt|;
name|array
index|[
name|i
index|]
operator|=
name|copy
index|[
name|i
index|]
expr_stmt|;
block|}
name|array
index|[
name|i
index|]
operator|=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Free the storage used only by COPY. */
name|free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
comment|/* Sort the index passed in INDEX, returning an array of    pointers to elements.  The array is terminated with a NULL    pointer.  We call qsort because it's supposed to be fast.    I think this looks bad. */
name|INDEX_ELT
modifier|*
modifier|*
name|sort_index
parameter_list|(
name|index
parameter_list|)
name|INDEX_ELT
modifier|*
name|index
decl_stmt|;
block|{
name|INDEX_ELT
modifier|*
name|temp
init|=
name|index
decl_stmt|;
name|INDEX_ELT
modifier|*
modifier|*
name|array
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|temp
operator|!=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|NULL
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|temp
operator|=
name|temp
operator|->
name|next
expr_stmt|;
block|}
comment|/* We have the length.  Make an array. */
name|array
operator|=
operator|(
name|INDEX_ELT
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ELT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|index
expr_stmt|;
while|while
condition|(
name|temp
operator|!=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|NULL
condition|)
block|{
name|array
index|[
name|count
operator|++
index|]
operator|=
name|temp
expr_stmt|;
comment|/* Maybe should set line number to the defining_line?  Any errors          have already been given, though, I think.  */
comment|/* If this particular entry should be printed as a "code" index, 	 then wrap the entry with "@code{...}". */
name|array
index|[
name|count
operator|-
literal|1
index|]
operator|->
name|entry
operator|=
name|expansion
argument_list|(
name|temp
operator|->
name|entry
argument_list|,
name|index
operator|->
name|code
argument_list|)
expr_stmt|;
name|temp
operator|=
name|temp
operator|->
name|next
expr_stmt|;
block|}
name|array
index|[
name|count
index|]
operator|=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* terminate the array. */
comment|/* Sort the array. */
name|qsort
argument_list|(
name|array
argument_list|,
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|INDEX_ELT
operator|*
argument_list|)
argument_list|,
name|index_element_compare
argument_list|)
expr_stmt|;
name|make_index_entries_unique
argument_list|(
name|array
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|array
operator|)
return|;
block|}
comment|/* Non-zero means that we are in the middle of printing an index. */
name|int
name|printing_index
init|=
literal|0
decl_stmt|;
comment|/* Takes one arg, a short name of an index to print.    Outputs a menu of the sorted elements of the index. */
name|void
name|cm_printindex
parameter_list|()
block|{
name|int
name|item
decl_stmt|;
name|INDEX_ELT
modifier|*
name|index
decl_stmt|;
name|INDEX_ELT
modifier|*
modifier|*
name|array
decl_stmt|;
name|char
modifier|*
name|index_name
decl_stmt|;
name|unsigned
name|line_length
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|saved_inhibit_paragraph_indentation
init|=
name|inhibit_paragraph_indentation
decl_stmt|;
name|int
name|saved_filling_enabled
init|=
name|filling_enabled
decl_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|index_name
argument_list|)
expr_stmt|;
name|index
operator|=
name|index_list
argument_list|(
name|index_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
operator|(
name|INDEX_ELT
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|line_error
argument_list|(
literal|"Unknown index name `%s'"
argument_list|,
name|index_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|index_name
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|free
argument_list|(
name|index_name
argument_list|)
expr_stmt|;
comment|/* Do this before sorting, so execute_string in index_element_compare      will give the same results as when we actually print.  */
name|printing_index
operator|=
literal|1
expr_stmt|;
name|filling_enabled
operator|=
literal|0
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|array
operator|=
name|sort_index
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|add_word
argument_list|(
literal|"* Menu:\n\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
name|me_inhibit_expansion
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MACROS */
comment|/* This will probably be enough.  */
name|line_length
operator|=
literal|100
expr_stmt|;
name|line
operator|=
name|xmalloc
argument_list|(
name|line_length
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
literal|0
init|;
operator|(
name|index
operator|=
name|array
index|[
name|item
index|]
operator|)
condition|;
name|item
operator|++
control|)
block|{
comment|/* A pathological document might have an index entry outside of any          node.  Don't crash.  Perhaps should warn.  */
name|char
modifier|*
name|index_node
init|=
name|index
operator|->
name|node
condition|?
name|index
operator|->
name|node
else|:
literal|"(none)"
decl_stmt|;
name|unsigned
name|new_length
init|=
name|strlen
argument_list|(
name|index
operator|->
name|entry
argument_list|)
operator|+
name|strlen
argument_list|(
name|index_node
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_length
operator|>
name|line_length
condition|)
block|{
name|line_length
operator|=
name|new_length
operator|+
literal|6
expr_stmt|;
comment|/* * : .\0 */
name|line
operator|=
name|xrealloc
argument_list|(
name|line
argument_list|,
name|line_length
argument_list|)
expr_stmt|;
block|}
comment|/* Print the entry, nicely formatted.  We've already expanded any          commands, including any implicit @code.  Thus, can't call          execute_string, since @@ has turned into @.  */
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"* %-37s  %s.\n"
argument_list|,
name|index
operator|->
name|entry
argument_list|,
name|index_node
argument_list|)
expr_stmt|;
name|line
index|[
literal|2
operator|+
name|strlen
argument_list|(
name|index
operator|->
name|entry
argument_list|)
index|]
operator|=
literal|':'
expr_stmt|;
name|insert_string
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* Previous `output_paragraph' from growing to the size of the          whole index.  */
name|flush_output
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
name|me_inhibit_expansion
operator|--
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MACROS */
name|printing_index
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|saved_filling_enabled
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
name|saved_inhibit_paragraph_indentation
expr_stmt|;
block|}
comment|/* User-defined commands. */
name|void
name|define_user_command
parameter_list|(
name|name
parameter_list|,
name|proc
parameter_list|,
name|needs_braces_p
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|COMMAND_FUNCTION
modifier|*
name|proc
decl_stmt|;
name|int
name|needs_braces_p
decl_stmt|;
block|{
name|int
name|slot
init|=
name|user_command_array_len
decl_stmt|;
name|user_command_array_len
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|user_command_array
condition|)
name|user_command_array
operator|=
operator|(
name|COMMAND
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|*
sizeof|sizeof
argument_list|(
name|COMMAND
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|user_command_array
operator|=
operator|(
name|COMMAND
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|user_command_array
argument_list|,
operator|(
literal|1
operator|+
name|user_command_array_len
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|COMMAND
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|user_command_array
index|[
name|slot
index|]
operator|=
operator|(
name|COMMAND
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|COMMAND
argument_list|)
argument_list|)
expr_stmt|;
name|user_command_array
index|[
name|slot
index|]
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|user_command_array
index|[
name|slot
index|]
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|user_command_array
index|[
name|slot
index|]
operator|->
name|argument_in_braces
operator|=
name|needs_braces_p
expr_stmt|;
block|}
comment|/* Set the paragraph indentation variable to the value specified in STRING.    Values can be:    `asis': Don't change existing indentation.    `none': Remove existing indentation.       NUM: Indent NUM spaces at the starts of paragraphs.            Note that if NUM is zero, we assume `none'.     Returns 0 if successful, or non-zero if STRING isn't one of the above. */
name|int
name|set_paragraph_indent
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"asis"
argument_list|)
operator|==
literal|0
condition|)
name|paragraph_start_indent
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
name|paragraph_start_indent
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|string
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|paragraph_start_indent
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
block|{
if|if
condition|(
name|paragraph_start_indent
operator|==
literal|0
condition|)
name|paragraph_start_indent
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|void
name|cm_paragraphindent
parameter_list|()
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_paragraph_indent
argument_list|(
name|arg
argument_list|)
operator|!=
literal|0
condition|)
name|line_error
argument_list|(
literal|"Bad argument to %c%s"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
comment|/* Some support for footnotes. */
comment|/* Footnotes are a new construct in Info.  We don't know the best method    of implementing them for sure, so we present two possiblities.     SeparateNode: 	Make them look like followed references, with the reference 	destinations in a makeinfo manufactured node or,     EndNode: 	Make them appear at the bottom of the node that they originally 	appeared in. */
define|#
directive|define
name|SeparateNode
value|0
define|#
directive|define
name|EndNode
value|1
name|int
name|footnote_style
init|=
name|EndNode
decl_stmt|;
name|int
name|first_footnote_this_node
init|=
literal|1
decl_stmt|;
name|int
name|footnote_count
init|=
literal|0
decl_stmt|;
comment|/* Set the footnote style based on he style identifier in STRING. */
name|int
name|set_footnote_style
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|strcasecmp
argument_list|(
name|string
argument_list|,
literal|"separate"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcasecmp
argument_list|(
name|string
argument_list|,
literal|"MN"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|footnote_style
operator|=
name|SeparateNode
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|strcasecmp
argument_list|(
name|string
argument_list|,
literal|"end"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcasecmp
argument_list|(
name|string
argument_list|,
literal|"EN"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|footnote_style
operator|=
name|EndNode
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|void
name|cm_footnotestyle
parameter_list|()
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
comment|/* If set on command line, do not change the footnote style.  */
if|if
condition|(
operator|!
name|footnote_style_preset
operator|&&
name|set_footnote_style
argument_list|(
name|arg
argument_list|)
operator|!=
literal|0
condition|)
name|line_error
argument_list|(
literal|"Bad argument to %c%s"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
typedef|typedef
struct|struct
name|fn
block|{
name|struct
name|fn
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|marker
decl_stmt|;
name|char
modifier|*
name|note
decl_stmt|;
block|}
name|FN
typedef|;
name|FN
modifier|*
name|pending_notes
init|=
operator|(
name|FN
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* A method for remembering footnotes.  Note that this list gets output    at the end of the current node. */
name|void
name|remember_note
parameter_list|(
name|marker
parameter_list|,
name|note
parameter_list|)
name|char
modifier|*
name|marker
decl_stmt|,
decl|*
name|note
decl_stmt|;
block|{
name|FN
modifier|*
name|temp
init|=
operator|(
name|FN
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FN
argument_list|)
argument_list|)
decl_stmt|;
name|temp
operator|->
name|marker
operator|=
name|strdup
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|temp
operator|->
name|note
operator|=
name|strdup
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|pending_notes
expr_stmt|;
name|pending_notes
operator|=
name|temp
expr_stmt|;
name|footnote_count
operator|++
expr_stmt|;
block|}
comment|/* How to get rid of existing footnotes. */
name|void
name|free_pending_notes
parameter_list|()
block|{
name|FN
modifier|*
name|temp
decl_stmt|;
while|while
condition|(
operator|(
name|temp
operator|=
name|pending_notes
operator|)
operator|!=
operator|(
name|FN
operator|*
operator|)
name|NULL
condition|)
block|{
name|free
argument_list|(
name|temp
operator|->
name|marker
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|note
argument_list|)
expr_stmt|;
name|pending_notes
operator|=
name|pending_notes
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|first_footnote_this_node
operator|=
literal|1
expr_stmt|;
name|footnote_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* What to do when you see a @footnote construct. */
comment|/* Handle a "footnote".     footnote *{this is a footnote}     where "*" is the marker character for this note. */
name|void
name|cm_footnote
parameter_list|()
block|{
name|char
modifier|*
name|marker
decl_stmt|;
name|char
modifier|*
name|note
decl_stmt|;
name|get_until
argument_list|(
literal|"{"
argument_list|,
operator|&
name|marker
argument_list|)
expr_stmt|;
name|canon_white
argument_list|(
name|marker
argument_list|)
expr_stmt|;
comment|/* Read the argument in braces. */
if|if
condition|(
name|curchar
argument_list|()
operator|!=
literal|'{'
condition|)
block|{
name|line_error
argument_list|(
literal|"`%c%s' expected more than just `%s'.  It needs something in `{...}'"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|marker
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|int
name|braces
init|=
literal|1
decl_stmt|;
name|int
name|temp
init|=
operator|++
name|input_text_offset
decl_stmt|;
name|int
name|len
decl_stmt|;
while|while
condition|(
name|braces
condition|)
block|{
if|if
condition|(
name|temp
operator|==
name|size_of_input_text
condition|)
block|{
name|line_error
argument_list|(
literal|"No closing brace for footnote `%s'"
argument_list|,
name|marker
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|input_text
index|[
name|temp
index|]
operator|==
literal|'{'
condition|)
name|braces
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|input_text
index|[
name|temp
index|]
operator|==
literal|'}'
condition|)
name|braces
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|input_text
index|[
name|temp
index|]
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
name|temp
operator|++
expr_stmt|;
block|}
name|len
operator|=
operator|(
name|temp
operator|-
name|input_text_offset
operator|)
operator|-
literal|1
expr_stmt|;
name|note
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|note
argument_list|,
operator|&
name|input_text
index|[
name|input_text_offset
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|note
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|input_text_offset
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|current_node
operator|||
operator|!
operator|*
name|current_node
condition|)
block|{
name|line_error
argument_list|(
literal|"Footnote defined without parent node"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|note
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|*
name|marker
condition|)
block|{
name|free
argument_list|(
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|number_footnotes
condition|)
block|{
name|marker
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|marker
argument_list|,
literal|"%d"
argument_list|,
name|current_footnote_number
argument_list|)
expr_stmt|;
name|current_footnote_number
operator|++
expr_stmt|;
block|}
else|else
name|marker
operator|=
name|strdup
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
block|}
name|remember_note
argument_list|(
name|marker
argument_list|,
name|note
argument_list|)
expr_stmt|;
comment|/* Your method should at least insert MARKER. */
switch|switch
condition|(
name|footnote_style
condition|)
block|{
case|case
name|SeparateNode
case|:
name|add_word_args
argument_list|(
literal|"(%s)"
argument_list|,
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_footnote_this_node
condition|)
block|{
name|char
modifier|*
name|temp_string
decl_stmt|;
name|temp_string
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|strlen
argument_list|(
name|current_node
argument_list|)
operator|)
operator|+
operator|(
name|strlen
argument_list|(
literal|"-Footnotes"
argument_list|)
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|add_word_args
argument_list|(
literal|" (*note %s-Footnotes::)"
argument_list|,
name|current_node
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp_string
argument_list|,
name|current_node
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp_string
argument_list|,
literal|"-Footnotes"
argument_list|)
expr_stmt|;
name|remember_node_reference
argument_list|(
name|temp_string
argument_list|,
name|line_number
argument_list|,
name|followed_reference
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_string
argument_list|)
expr_stmt|;
name|first_footnote_this_node
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|EndNode
case|:
name|add_word_args
argument_list|(
literal|"(%s)"
argument_list|,
name|marker
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|free
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|note
argument_list|)
expr_stmt|;
block|}
comment|/* Non-zero means that we are currently in the process of outputting    footnotes. */
name|int
name|already_outputting_pending_notes
init|=
literal|0
decl_stmt|;
comment|/* Output the footnotes.  We are at the end of the current node. */
name|void
name|output_pending_notes
parameter_list|()
block|{
name|FN
modifier|*
name|footnote
init|=
name|pending_notes
decl_stmt|;
if|if
condition|(
operator|!
name|pending_notes
condition|)
return|return;
switch|switch
condition|(
name|footnote_style
condition|)
block|{
case|case
name|SeparateNode
case|:
block|{
name|char
modifier|*
name|old_current_node
init|=
name|current_node
decl_stmt|;
name|char
modifier|*
name|old_command
init|=
name|strdup
argument_list|(
name|command
argument_list|)
decl_stmt|;
name|already_outputting_pending_notes
operator|++
expr_stmt|;
name|execute_string
argument_list|(
literal|"%cnode %s-Footnotes,,,%s\n"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|current_node
argument_list|,
name|current_node
argument_list|)
expr_stmt|;
name|already_outputting_pending_notes
operator|--
expr_stmt|;
name|current_node
operator|=
name|old_current_node
expr_stmt|;
name|free
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|command
operator|=
name|old_command
expr_stmt|;
block|}
break|break;
case|case
name|EndNode
case|:
name|close_paragraph
argument_list|()
expr_stmt|;
name|in_fixed_width_font
operator|++
expr_stmt|;
name|execute_string
argument_list|(
literal|"---------- Footnotes ----------\n\n"
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|--
expr_stmt|;
break|break;
block|}
comment|/* Handle the footnotes in reverse order. */
block|{
name|FN
modifier|*
modifier|*
name|array
init|=
operator|(
name|FN
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|footnote_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|FN
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|array
index|[
name|footnote_count
index|]
operator|=
operator|(
name|FN
operator|*
operator|)
name|NULL
expr_stmt|;
while|while
condition|(
operator|--
name|footnote_count
operator|>
operator|-
literal|1
condition|)
block|{
name|array
index|[
name|footnote_count
index|]
operator|=
name|footnote
expr_stmt|;
name|footnote
operator|=
name|footnote
operator|->
name|next
expr_stmt|;
block|}
name|filling_enabled
operator|=
literal|1
expr_stmt|;
name|indented_fill
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|footnote
operator|=
name|array
index|[
operator|++
name|footnote_count
index|]
condition|)
block|{
switch|switch
condition|(
name|footnote_style
condition|)
block|{
case|case
name|SeparateNode
case|:
case|case
name|EndNode
case|:
name|execute_string
argument_list|(
literal|"(%s)  %s"
argument_list|,
name|footnote
operator|->
name|marker
argument_list|,
name|footnote
operator|->
name|note
argument_list|)
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|close_paragraph
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* **************************************************************** */
comment|/*                                                                  */
comment|/*              User definable Macros (text substitution)	    */
comment|/*                                                                  */
comment|/* **************************************************************** */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
comment|/* Array of macros and definitions. */
name|MACRO_DEF
modifier|*
modifier|*
name|macro_list
init|=
operator|(
name|MACRO_DEF
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|macro_list_len
init|=
literal|0
decl_stmt|;
comment|/* Number of elements. */
name|int
name|macro_list_size
init|=
literal|0
decl_stmt|;
comment|/* Number of slots in total. */
comment|/* Return the macro definition of NAME or NULL if NAME is not defined. */
name|MACRO_DEF
modifier|*
name|find_macro
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|MACRO_DEF
modifier|*
name|def
decl_stmt|;
name|def
operator|=
operator|(
name|MACRO_DEF
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|macro_list
operator|&&
operator|(
name|def
operator|=
name|macro_list
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|!
name|def
operator|->
name|inhibited
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|def
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
return|return
operator|(
name|def
operator|)
return|;
block|}
comment|/* Add the macro NAME with ARGLIST and BODY to the list of defined macros.    SOURCE_FILE is the name of the file where this definition can be found,    and SOURCE_LINENO is the line number within that file.  If a macro already    exists with NAME, then a warning is produced, and that previous    definition is overwritten. */
name|void
name|add_macro
parameter_list|(
name|name
parameter_list|,
name|arglist
parameter_list|,
name|body
parameter_list|,
name|source_file
parameter_list|,
name|source_lineno
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|arglist
decl_stmt|;
name|char
modifier|*
name|body
decl_stmt|;
name|char
modifier|*
name|source_file
decl_stmt|;
name|int
name|source_lineno
decl_stmt|,
name|flags
decl_stmt|;
block|{
specifier|register
name|MACRO_DEF
modifier|*
name|def
decl_stmt|;
name|def
operator|=
name|find_macro
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|def
condition|)
block|{
if|if
condition|(
name|macro_list_len
operator|+
literal|2
operator|>=
name|macro_list_size
condition|)
name|macro_list
operator|=
operator|(
name|MACRO_DEF
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|macro_list
argument_list|,
operator|(
operator|(
name|macro_list_size
operator|+=
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|MACRO_DEF
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|macro_list
index|[
name|macro_list_len
index|]
operator|=
operator|(
name|MACRO_DEF
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|MACRO_DEF
argument_list|)
argument_list|)
expr_stmt|;
name|macro_list
index|[
name|macro_list_len
operator|+
literal|1
index|]
operator|=
operator|(
name|MACRO_DEF
operator|*
operator|)
name|NULL
expr_stmt|;
name|def
operator|=
name|macro_list
index|[
name|macro_list_len
index|]
expr_stmt|;
name|macro_list_len
operator|+=
literal|1
expr_stmt|;
name|def
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|temp_filename
init|=
name|input_filename
decl_stmt|;
name|int
name|temp_line
init|=
name|line_number
decl_stmt|;
name|warning
argument_list|(
literal|"The macro `%s' is previously defined"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|def
operator|->
name|source_file
expr_stmt|;
name|line_number
operator|=
name|def
operator|->
name|source_lineno
expr_stmt|;
name|warning
argument_list|(
literal|"Here is the previous definition of `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|temp_filename
expr_stmt|;
name|line_number
operator|=
name|temp_line
expr_stmt|;
if|if
condition|(
name|def
operator|->
name|arglist
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|def
operator|->
name|arglist
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|def
operator|->
name|arglist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|def
operator|->
name|arglist
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|def
operator|->
name|source_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|def
operator|->
name|body
argument_list|)
expr_stmt|;
block|}
name|def
operator|->
name|source_file
operator|=
name|strdup
argument_list|(
name|source_file
argument_list|)
expr_stmt|;
name|def
operator|->
name|source_lineno
operator|=
name|source_lineno
expr_stmt|;
name|def
operator|->
name|body
operator|=
name|body
expr_stmt|;
name|def
operator|->
name|arglist
operator|=
name|arglist
expr_stmt|;
name|def
operator|->
name|inhibited
operator|=
literal|0
expr_stmt|;
name|def
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
block|}
comment|/* Delete the macro with name NAME.  The macro is deleted from the list,    but it is also returned.  If there was no macro defined, NULL is    returned. */
name|MACRO_DEF
modifier|*
name|delete_macro
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|MACRO_DEF
modifier|*
name|def
decl_stmt|;
name|def
operator|=
operator|(
name|MACRO_DEF
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|macro_list
operator|&&
operator|(
name|def
operator|=
name|macro_list
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|def
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|memmove
argument_list|(
name|macro_list
operator|+
name|i
argument_list|,
name|macro_list
operator|+
name|i
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|macro_list_len
operator|+
literal|1
operator|)
operator|-
name|i
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|MACRO_DEF
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|def
operator|)
return|;
block|}
comment|/* Return the arglist on the current line.  This can behave in two different    ways, depending on the variable BRACES_REQUIRED_FOR_MACRO_ARGS. */
name|int
name|braces_required_for_macro_args
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|get_macro_args
parameter_list|(
name|def
parameter_list|)
name|MACRO_DEF
modifier|*
name|def
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|word
decl_stmt|;
comment|/* Quickly check to see if this macro has been invoked with any arguments.      If not, then don't skip any of the following whitespace. */
for|for
control|(
name|i
operator|=
name|input_text_offset
init|;
name|i
operator|<
name|size_of_input_text
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|cr_or_whitespace
argument_list|(
name|input_text
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|input_text
index|[
name|i
index|]
operator|!=
literal|'{'
condition|)
block|{
if|if
condition|(
name|braces_required_for_macro_args
condition|)
block|{
return|return
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
else|else
block|{
comment|/* Braces are not required to fill out the macro arguments.  If 	     this macro takes one argument, it is considered to be the 	     remainder of the line, sans whitespace. */
if|if
condition|(
name|def
operator|->
name|arglist
operator|&&
name|def
operator|->
name|arglist
index|[
literal|0
index|]
operator|&&
operator|!
name|def
operator|->
name|arglist
index|[
literal|1
index|]
condition|)
block|{
name|char
modifier|*
modifier|*
name|arglist
decl_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_text
index|[
name|input_text_offset
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|input_text_offset
operator|--
expr_stmt|;
comment|/* canon_white (word); */
name|arglist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
index|[
literal|0
index|]
operator|=
name|word
expr_stmt|;
name|arglist
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|arglist
operator|)
return|;
block|}
else|else
block|{
comment|/* The macro either took no arguments, or took more than 		 one argument.  In that case, it must be invoked with 		 arguments surrounded by braces. */
return|return
operator|(
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|get_brace_args
argument_list|(
name|def
operator|->
name|flags
operator|&
name|ME_QUOTE_ARG
argument_list|)
operator|)
return|;
block|}
comment|/* Substitute actual parameters for named parameters in body.    The named parameters which appear in BODY must by surrounded    reverse slashes, as in \foo\. */
name|char
modifier|*
name|apply
parameter_list|(
name|named
parameter_list|,
name|actuals
parameter_list|,
name|body
parameter_list|)
name|char
modifier|*
modifier|*
name|named
decl_stmt|,
decl|*
modifier|*
name|actuals
decl_stmt|,
modifier|*
name|body
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|new_body_index
decl_stmt|,
name|new_body_size
decl_stmt|;
name|char
modifier|*
name|new_body
decl_stmt|,
modifier|*
name|text
decl_stmt|;
name|int
name|length_of_actuals
decl_stmt|;
name|length_of_actuals
operator|=
name|array_len
argument_list|(
name|actuals
argument_list|)
expr_stmt|;
name|new_body_size
operator|=
name|strlen
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|new_body
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|new_body_size
argument_list|)
expr_stmt|;
comment|/* Copy chars from BODY into NEW_BODY. */
name|i
operator|=
literal|0
expr_stmt|;
name|new_body_index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|body
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|body
index|[
name|i
index|]
operator|!=
literal|'\\'
condition|)
name|new_body
index|[
name|new_body_index
operator|++
index|]
operator|=
name|body
index|[
name|i
operator|++
index|]
expr_stmt|;
else|else
block|{
comment|/* Snarf parameter name, check against named parameters. */
name|char
modifier|*
name|param
decl_stmt|;
name|int
name|param_start
decl_stmt|,
name|which
decl_stmt|,
name|len
decl_stmt|;
name|param_start
operator|=
operator|++
name|i
expr_stmt|;
while|while
condition|(
operator|(
name|body
index|[
name|i
index|]
operator|)
operator|&&
operator|(
name|body
index|[
name|i
index|]
operator|!=
literal|'\\'
operator|)
condition|)
name|i
operator|++
expr_stmt|;
name|len
operator|=
name|i
operator|-
name|param_start
expr_stmt|;
name|param
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|param
argument_list|,
name|body
operator|+
name|param_start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|param
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|body
index|[
name|i
index|]
condition|)
name|i
operator|++
expr_stmt|;
comment|/* Now check against named parameters. */
for|for
control|(
name|which
operator|=
literal|0
init|;
name|named
operator|&&
name|named
index|[
name|which
index|]
condition|;
name|which
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|named
index|[
name|which
index|]
argument_list|,
name|param
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|named
index|[
name|which
index|]
condition|)
block|{
if|if
condition|(
name|which
operator|<
name|length_of_actuals
condition|)
name|text
operator|=
name|actuals
index|[
name|which
index|]
expr_stmt|;
else|else
name|text
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|text
condition|)
name|text
operator|=
literal|""
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|+=
literal|2
expr_stmt|;
name|text
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|text
argument_list|,
literal|"\\%s\\"
argument_list|,
name|param
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
literal|2
operator|+
name|strlen
argument_list|(
name|param
argument_list|)
operator|)
operator|<
name|len
condition|)
name|new_body
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|new_body
argument_list|,
name|new_body_size
operator|+=
operator|(
literal|1
operator|+
name|len
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new_body
operator|+
name|new_body_index
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|new_body_index
operator|+=
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|named
index|[
name|which
index|]
condition|)
name|free
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
block|}
name|new_body
index|[
name|new_body_index
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|new_body
operator|)
return|;
block|}
comment|/* Execute the macro passed in DEF, a pointer to a MACRO_DEF.  */
name|void
name|execute_macro
parameter_list|(
name|def
parameter_list|)
name|MACRO_DEF
modifier|*
name|def
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|arglist
decl_stmt|;
name|int
name|num_args
decl_stmt|;
name|char
modifier|*
name|execution_string
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|macro_expansion_output_stream
operator|&&
operator|!
name|me_inhibit_expansion
condition|)
name|me_append_before_this_command
argument_list|()
expr_stmt|;
comment|/* Find out how many arguments this macro definition takes. */
name|num_args
operator|=
name|array_len
argument_list|(
name|def
operator|->
name|arglist
argument_list|)
expr_stmt|;
comment|/* Gather the arguments present on the line if there are any. */
name|arglist
operator|=
name|get_macro_args
argument_list|(
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_args
operator|<
name|array_len
argument_list|(
name|arglist
argument_list|)
condition|)
block|{
name|free_array
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|line_error
argument_list|(
literal|"Macro `%s' called with too many args"
argument_list|,
name|def
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|def
operator|->
name|body
condition|)
name|execution_string
operator|=
name|apply
argument_list|(
name|def
operator|->
name|arglist
argument_list|,
name|arglist
argument_list|,
name|def
operator|->
name|body
argument_list|)
expr_stmt|;
name|free_array
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|->
name|body
condition|)
block|{
if|if
condition|(
name|macro_expansion_output_stream
operator|&&
operator|!
name|me_inhibit_expansion
condition|)
block|{
name|remember_itext
argument_list|(
name|input_text
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
name|me_execute_string
argument_list|(
name|execution_string
argument_list|)
expr_stmt|;
block|}
else|else
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|execution_string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|execution_string
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Read and remember the definition of a macro. */
name|void
name|cm_macro
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
modifier|*
name|arglist
decl_stmt|,
modifier|*
name|body
decl_stmt|,
modifier|*
name|line
decl_stmt|;
name|int
name|body_size
decl_stmt|,
name|body_index
decl_stmt|;
name|int
name|depth
init|=
literal|1
decl_stmt|;
name|int
name|defining_line
init|=
name|line_number
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|arglist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
name|body
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|body_size
operator|=
literal|0
expr_stmt|;
name|body_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|macro_expansion_output_stream
condition|)
name|me_append_before_this_command
argument_list|()
expr_stmt|;
name|skip_whitespace
argument_list|()
expr_stmt|;
comment|/* Get the name of the macro.  This is the set of characters which are      not whitespace and are not `{' immediately following the @macro. */
block|{
name|int
name|start
init|=
name|input_text_offset
decl_stmt|;
name|int
name|len
decl_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
operator|(
name|i
operator|<
name|size_of_input_text
operator|)
operator|&&
operator|(
name|input_text
index|[
name|i
index|]
operator|!=
literal|'{'
operator|)
operator|&&
operator|(
operator|!
name|cr_or_whitespace
argument_list|(
name|input_text
index|[
name|i
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|len
operator|=
name|i
operator|-
name|start
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|input_text
operator|+
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|input_text_offset
operator|=
name|i
expr_stmt|;
block|}
name|skip_whitespace
argument_list|()
expr_stmt|;
comment|/* It is not required that the definition of a macro includes an arglist.      If not, don't try to get the named parameters, just use a null list. */
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|'{'
condition|)
block|{
name|int
name|arglist_index
init|=
literal|0
decl_stmt|,
name|arglist_size
init|=
literal|0
decl_stmt|;
name|int
name|gathering_words
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|word
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|character
decl_stmt|;
comment|/* Read the words inside of the braces which determine the arglist. 	 These words will be replaced within the body of the macro at 	 execution time. */
name|input_text_offset
operator|++
expr_stmt|;
name|skip_whitespace_and_newlines
argument_list|()
expr_stmt|;
while|while
condition|(
name|gathering_words
condition|)
block|{
name|int
name|len
decl_stmt|;
for|for
control|(
name|i
operator|=
name|input_text_offset
init|;
name|character
operator|=
name|input_text
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|character
condition|)
block|{
case|case
literal|'\n'
case|:
name|line_number
operator|++
expr_stmt|;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|','
case|:
case|case
literal|'}'
case|:
comment|/* Found the end of the current arglist word.  Save it. */
name|len
operator|=
name|i
operator|-
name|input_text_offset
expr_stmt|;
name|word
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|word
argument_list|,
name|input_text
operator|+
name|input_text_offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|word
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|input_text_offset
operator|=
name|i
expr_stmt|;
comment|/* Advance to the comma or close-brace that signified 		     the end of the argument. */
while|while
condition|(
operator|(
name|character
operator|=
name|curchar
argument_list|()
operator|)
operator|&&
name|character
operator|!=
literal|','
operator|&&
name|character
operator|!=
literal|'}'
condition|)
block|{
name|input_text_offset
operator|++
expr_stmt|;
if|if
condition|(
name|character
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
block|}
comment|/* Add the word to our list of words. */
if|if
condition|(
operator|(
name|arglist_index
operator|+
literal|2
operator|)
operator|>=
name|arglist_size
condition|)
name|arglist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|arglist
argument_list|,
operator|(
name|arglist_size
operator|+=
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
index|[
name|arglist_index
operator|++
index|]
operator|=
name|word
expr_stmt|;
name|arglist
index|[
name|arglist_index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|character
operator|==
literal|'}'
condition|)
block|{
name|input_text_offset
operator|++
expr_stmt|;
name|gathering_words
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|character
operator|==
literal|','
condition|)
block|{
name|input_text_offset
operator|++
expr_stmt|;
name|skip_whitespace_and_newlines
argument_list|()
expr_stmt|;
name|i
operator|=
name|input_text_offset
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Read the text carefully until we find an "@end macro" which      matches this one.  The text in between is the body of the macro. */
name|skip_whitespace_and_newlines
argument_list|()
expr_stmt|;
while|while
condition|(
name|depth
condition|)
block|{
if|if
condition|(
operator|(
name|input_text_offset
operator|+
literal|9
operator|)
operator|>
name|size_of_input_text
condition|)
block|{
name|int
name|temp_line
init|=
name|line_number
decl_stmt|;
name|line_number
operator|=
name|defining_line
expr_stmt|;
name|line_error
argument_list|(
literal|"%cend macro not found"
argument_list|,
name|COMMAND_PREFIX
argument_list|)
expr_stmt|;
name|line_number
operator|=
name|temp_line
expr_stmt|;
return|return;
block|}
name|get_rest_of_line
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
comment|/* Handle commands only meaningful within a macro. */
if|if
condition|(
operator|(
operator|*
name|line
operator|==
name|COMMAND_PREFIX
operator|)
operator|&&
operator|(
name|depth
operator|==
literal|1
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|line
operator|+
literal|1
argument_list|,
literal|"allow-recursion"
argument_list|,
literal|15
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|line
index|[
literal|16
index|]
operator|==
literal|'\0'
operator|||
name|whitespace
argument_list|(
name|line
index|[
literal|16
index|]
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|16
init|;
name|whitespace
argument_list|(
name|line
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|strcpy
argument_list|(
name|line
argument_list|,
name|line
operator|+
name|i
argument_list|)
expr_stmt|;
name|flags
operator||=
name|ME_RECURSE
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|line
condition|)
block|{
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
operator|*
name|line
operator|==
name|COMMAND_PREFIX
operator|)
operator|&&
operator|(
name|depth
operator|==
literal|1
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|line
operator|+
literal|1
argument_list|,
literal|"quote-arg"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|line
index|[
literal|10
index|]
operator|==
literal|'\0'
operator|||
name|whitespace
argument_list|(
name|line
index|[
literal|10
index|]
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|10
init|;
name|whitespace
argument_list|(
name|line
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|strcpy
argument_list|(
name|line
argument_list|,
name|line
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&&
name|arglist
index|[
literal|0
index|]
operator|&&
operator|!
name|arglist
index|[
literal|1
index|]
condition|)
block|{
name|flags
operator||=
name|ME_QUOTE_ARG
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|line
condition|)
block|{
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|line_error
argument_list|(
literal|"%cquote-arg only useful when the macro takes a single argument"
argument_list|,
name|COMMAND_PREFIX
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|*
name|line
operator|==
name|COMMAND_PREFIX
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|line
operator|+
literal|1
argument_list|,
literal|"macro "
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|depth
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|line
operator|==
name|COMMAND_PREFIX
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|line
operator|+
literal|1
argument_list|,
literal|"end macro"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|depth
operator|--
expr_stmt|;
if|if
condition|(
name|depth
condition|)
block|{
if|if
condition|(
operator|(
name|body_index
operator|+
name|strlen
argument_list|(
name|line
argument_list|)
operator|+
literal|3
operator|)
operator|>=
name|body_size
condition|)
name|body
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|body
argument_list|,
name|body_size
operator|+=
literal|3
operator|+
name|strlen
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|body
operator|+
name|body_index
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|body_index
operator|+=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|body
index|[
name|body_index
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|body
index|[
name|body_index
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
comment|/* We now have the name, the arglist, and the body.  However, BODY      includes the final newline which preceded the `@end macro' text.      Delete it. */
if|if
condition|(
name|body
operator|&&
name|strlen
argument_list|(
name|body
argument_list|)
condition|)
name|body
index|[
name|strlen
argument_list|(
name|body
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|add_macro
argument_list|(
name|name
argument_list|,
name|arglist
argument_list|,
name|body
argument_list|,
name|input_filename
argument_list|,
name|defining_line
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|macro_expansion_output_stream
condition|)
name|remember_itext
argument_list|(
name|input_text
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
block|}
name|void
name|cm_unmacro
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|MACRO_DEF
modifier|*
name|def
decl_stmt|;
if|if
condition|(
name|macro_expansion_output_stream
condition|)
name|me_append_before_this_command
argument_list|()
expr_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|canon_white
argument_list|(
name|line
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|line
index|[
name|i
index|]
operator|&&
operator|!
name|whitespace
argument_list|(
name|line
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|line
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|name
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|def
operator|=
name|delete_macro
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
condition|)
block|{
name|free
argument_list|(
name|def
operator|->
name|source_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|def
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|def
operator|->
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|->
name|arglist
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|def
operator|->
name|arglist
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|def
operator|->
name|arglist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|def
operator|->
name|arglist
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|def
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|macro_expansion_output_stream
condition|)
name|remember_itext
argument_list|(
name|input_text
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
block|}
comment|/* How to output sections of the input file verbatim. */
comment|/* Set the value of POINTER's offset to OFFSET. */
name|ITEXT
modifier|*
name|remember_itext
parameter_list|(
name|pointer
parameter_list|,
name|offset
parameter_list|)
name|char
modifier|*
name|pointer
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|ITEXT
modifier|*
name|itext
init|=
operator|(
name|ITEXT
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* If we have no info, initialize a blank list. */
if|if
condition|(
operator|!
name|itext_info
condition|)
block|{
name|itext_info
operator|=
operator|(
name|ITEXT
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|itext_size
operator|=
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ITEXT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|itext_size
condition|;
name|i
operator|++
control|)
name|itext_info
index|[
name|i
index|]
operator|=
operator|(
name|ITEXT
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* If the pointer is already present in the list, then set the offset. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|itext_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|itext_info
index|[
name|i
index|]
operator|!=
operator|(
name|ITEXT
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|itext_info
index|[
name|i
index|]
operator|->
name|pointer
operator|==
name|pointer
operator|)
condition|)
block|{
name|itext
operator|=
name|itext_info
index|[
name|i
index|]
expr_stmt|;
name|itext_info
index|[
name|i
index|]
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|itext_size
condition|)
block|{
comment|/* Find a blank slot, (or create a new one), and remember the 	 pointer and offset. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|itext_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|itext_info
index|[
name|i
index|]
operator|==
operator|(
name|ITEXT
operator|*
operator|)
name|NULL
condition|)
break|break;
comment|/* If not found, then add some slots. */
if|if
condition|(
name|i
operator|==
name|itext_size
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|itext_info
operator|=
operator|(
name|ITEXT
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|itext_info
argument_list|,
operator|(
name|itext_size
operator|+=
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ITEXT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|itext_size
condition|;
name|j
operator|++
control|)
name|itext_info
index|[
name|j
index|]
operator|=
operator|(
name|ITEXT
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* Now add the pointer and the offset. */
name|itext_info
index|[
name|i
index|]
operator|=
operator|(
name|ITEXT
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ITEXT
argument_list|)
argument_list|)
expr_stmt|;
name|itext_info
index|[
name|i
index|]
operator|->
name|pointer
operator|=
name|pointer
expr_stmt|;
name|itext_info
index|[
name|i
index|]
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|itext
operator|=
name|itext_info
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
operator|(
name|itext
operator|)
return|;
block|}
comment|/* Forget the input text associated with POINTER. */
name|void
name|forget_itext
parameter_list|(
name|pointer
parameter_list|)
name|char
modifier|*
name|pointer
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|itext_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|itext_info
index|[
name|i
index|]
operator|&&
operator|(
name|itext_info
index|[
name|i
index|]
operator|->
name|pointer
operator|==
name|pointer
operator|)
condition|)
block|{
name|free
argument_list|(
name|itext_info
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|itext_info
index|[
name|i
index|]
operator|=
operator|(
name|ITEXT
operator|*
operator|)
name|NULL
expr_stmt|;
break|break;
block|}
block|}
comment|/* Append the text which appeared in input_text from the last offset to    the character just before the command that we are currently executing. */
name|void
name|me_append_before_this_command
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|input_text_offset
init|;
name|i
operator|&&
operator|(
name|input_text
index|[
name|i
index|]
operator|!=
name|COMMAND_PREFIX
operator|)
condition|;
name|i
operator|--
control|)
empty_stmt|;
name|maybe_write_itext
argument_list|(
name|input_text
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Similar to execute_string (), but only takes a single string argument,    and remembers the input text location, etc. */
name|void
name|me_execute_string
parameter_list|(
name|execution_string
parameter_list|)
name|char
modifier|*
name|execution_string
decl_stmt|;
block|{
name|pushfile
argument_list|()
expr_stmt|;
name|input_text_offset
operator|=
literal|0
expr_stmt|;
name|input_text
operator|=
name|execution_string
expr_stmt|;
name|input_filename
operator|=
name|strdup
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|size_of_input_text
operator|=
name|strlen
argument_list|(
name|execution_string
argument_list|)
expr_stmt|;
name|remember_itext
argument_list|(
name|execution_string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|executing_string
operator|++
expr_stmt|;
name|reader_loop
argument_list|()
expr_stmt|;
name|popfile
argument_list|()
expr_stmt|;
name|executing_string
operator|--
expr_stmt|;
block|}
comment|/* Append the text which appears in input_text from the last offset to    the current OFFSET. */
name|void
name|append_to_expansion_output
parameter_list|(
name|offset
parameter_list|)
name|int
name|offset
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|ITEXT
modifier|*
name|itext
init|=
operator|(
name|ITEXT
operator|*
operator|)
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|itext_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|itext_info
index|[
name|i
index|]
operator|&&
name|itext_info
index|[
name|i
index|]
operator|->
name|pointer
operator|==
name|input_text
condition|)
block|{
name|itext
operator|=
name|itext_info
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|itext
condition|)
name|itext
operator|=
name|remember_itext
argument_list|(
name|input_text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|itext
operator|->
name|offset
condition|)
block|{
name|write_region_to_macro_output
argument_list|(
name|input_text
argument_list|,
name|itext
operator|->
name|offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|remember_itext
argument_list|(
name|input_text
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Only write this input text iff it appears in our itext list. */
name|void
name|maybe_write_itext
parameter_list|(
name|pointer
parameter_list|,
name|offset
parameter_list|)
name|char
modifier|*
name|pointer
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|ITEXT
modifier|*
name|itext
init|=
operator|(
name|ITEXT
operator|*
operator|)
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|itext_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|itext_info
index|[
name|i
index|]
operator|&&
operator|(
name|itext_info
index|[
name|i
index|]
operator|->
name|pointer
operator|==
name|pointer
operator|)
condition|)
block|{
name|itext
operator|=
name|itext_info
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|itext
operator|&&
operator|(
name|itext
operator|->
name|offset
operator|<
name|offset
operator|)
condition|)
block|{
name|write_region_to_macro_output
argument_list|(
name|itext
operator|->
name|pointer
argument_list|,
name|itext
operator|->
name|offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|remember_itext
argument_list|(
name|pointer
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|write_region_to_macro_output
parameter_list|(
name|string
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
if|if
condition|(
name|macro_expansion_output_stream
condition|)
name|fwrite
argument_list|(
name|string
operator|+
name|start
argument_list|,
literal|1
argument_list|,
name|end
operator|-
name|start
argument_list|,
name|macro_expansion_output_stream
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_MACROS */
comment|/* Return the length of the array in ARRAY. */
name|int
name|array_len
parameter_list|(
name|array
parameter_list|)
name|char
modifier|*
modifier|*
name|array
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|array
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|array
index|[
name|i
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|;
name|i
operator|++
control|)
empty_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
name|void
name|free_array
parameter_list|(
name|array
parameter_list|)
name|char
modifier|*
modifier|*
name|array
decl_stmt|;
block|{
if|if
condition|(
name|array
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|array
index|[
name|i
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Function is used even when we don't have macros.  Although, I have    to admit, it is unlikely that you would have a use for it if you    aren't using macros. */
name|char
modifier|*
modifier|*
name|get_brace_args
parameter_list|(
name|quote_single
parameter_list|)
name|int
name|quote_single
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|arglist
decl_stmt|,
modifier|*
name|word
decl_stmt|;
name|int
name|arglist_index
decl_stmt|,
name|arglist_size
decl_stmt|;
name|int
name|character
decl_stmt|,
name|escape_seen
decl_stmt|,
name|start
decl_stmt|;
name|int
name|depth
init|=
literal|1
decl_stmt|;
comment|/* There is an arglist in braces here, so gather the args inside of it. */
name|skip_whitespace_and_newlines
argument_list|()
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
name|arglist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
name|arglist_index
operator|=
name|arglist_size
operator|=
literal|0
expr_stmt|;
name|get_arg
label|:
name|skip_whitespace_and_newlines
argument_list|()
expr_stmt|;
name|start
operator|=
name|input_text_offset
expr_stmt|;
name|escape_seen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|character
operator|=
name|curchar
argument_list|()
condition|)
block|{
if|if
condition|(
name|character
operator|==
literal|'\\'
condition|)
block|{
name|input_text_offset
operator|+=
literal|2
expr_stmt|;
name|escape_seen
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|character
operator|==
literal|'{'
condition|)
block|{
name|depth
operator|++
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|character
operator|==
literal|','
operator|&&
operator|!
name|quote_single
operator|)
operator|||
operator|(
operator|(
name|character
operator|==
literal|'}'
operator|)
operator|&&
name|depth
operator|==
literal|1
operator|)
condition|)
block|{
name|int
name|len
init|=
name|input_text_offset
operator|-
name|start
decl_stmt|;
if|if
condition|(
name|len
operator|||
operator|(
name|character
operator|!=
literal|'}'
operator|)
condition|)
block|{
name|word
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|word
argument_list|,
name|input_text
operator|+
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|word
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Clean up escaped characters. */
if|if
condition|(
name|escape_seen
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|word
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|word
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
name|memmove
argument_list|(
name|word
operator|+
name|i
argument_list|,
name|word
operator|+
name|i
operator|+
literal|1
argument_list|,
literal|1
operator|+
name|strlen
argument_list|(
name|word
operator|+
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arglist_index
operator|+
literal|2
operator|>=
name|arglist_size
condition|)
name|arglist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|arglist
argument_list|,
operator|(
name|arglist_size
operator|+=
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
index|[
name|arglist_index
operator|++
index|]
operator|=
name|word
expr_stmt|;
name|arglist
index|[
name|arglist_index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|input_text_offset
operator|++
expr_stmt|;
if|if
condition|(
name|character
operator|==
literal|'}'
condition|)
break|break;
else|else
goto|goto
name|get_arg
goto|;
block|}
elseif|else
if|if
condition|(
name|character
operator|==
literal|'}'
condition|)
block|{
name|depth
operator|--
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
block|}
else|else
block|{
name|input_text_offset
operator|++
expr_stmt|;
if|if
condition|(
name|character
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|arglist
operator|)
return|;
block|}
comment|/* **************************************************************** */
comment|/*                                                                  */
comment|/*                  Looking For Include Files                       */
comment|/*                                                                  */
comment|/* **************************************************************** */
comment|/* Given a string containing units of information separated by colons,    return the next one pointed to by INDEX, or NULL if there are no more.    Advance INDEX to the character after the colon. */
name|char
modifier|*
name|extract_colon_unit
parameter_list|(
name|string
parameter_list|,
name|index
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|index
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|start
decl_stmt|;
name|i
operator|=
operator|*
name|index
expr_stmt|;
if|if
condition|(
operator|!
name|string
operator|||
operator|(
name|i
operator|>=
name|strlen
argument_list|(
name|string
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* Each call to this routine leaves the index pointing at a colon if      there is more to the path.  If I is> 0, then increment past the      `:'.  If I is 0, then the path has a leading colon.  Trailing colons      are handled OK by the `else' part of the if statement; an empty      string is returned in that case. */
if|if
condition|(
name|i
operator|&&
name|string
index|[
name|i
index|]
operator|==
literal|':'
condition|)
name|i
operator|++
expr_stmt|;
name|start
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|string
index|[
name|i
index|]
operator|&&
name|string
index|[
name|i
index|]
operator|!=
literal|':'
condition|)
name|i
operator|++
expr_stmt|;
operator|*
name|index
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|start
condition|)
block|{
if|if
condition|(
name|string
index|[
name|i
index|]
condition|)
operator|(
operator|*
name|index
operator|)
operator|++
expr_stmt|;
comment|/* Return "" in the case of a trailing `:'. */
return|return
operator|(
name|strdup
argument_list|(
literal|""
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|char
modifier|*
name|value
decl_stmt|;
name|value
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
operator|(
name|i
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|value
argument_list|,
operator|&
name|string
index|[
name|start
index|]
argument_list|,
operator|(
name|i
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
name|value
index|[
name|i
operator|-
name|start
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
block|}
comment|/* Return the full pathname for FILENAME by searching along PATH.    When found, return the stat () info for FILENAME in FINFO.    If PATH is NULL, only the current directory is searched.    If the file could not be found, return a NULL pointer. */
name|char
modifier|*
name|get_file_info_in_path
parameter_list|(
name|filename
parameter_list|,
name|path
parameter_list|,
name|finfo
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|,
decl|*
name|path
decl_stmt|;
name|struct
name|stat
modifier|*
name|finfo
decl_stmt|;
block|{
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|result
decl_stmt|,
name|index
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|path
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|path
operator|=
literal|"."
expr_stmt|;
comment|/* Handle absolute pathnames. "./foo", "/foo", "../foo". */
if|if
condition|(
operator|*
name|filename
operator|==
literal|'/'
operator|||
operator|(
operator|*
name|filename
operator|==
literal|'.'
operator|&&
operator|(
name|filename
index|[
literal|1
index|]
operator|==
literal|'/'
operator|||
operator|(
name|filename
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|filename
index|[
literal|2
index|]
operator|==
literal|'/'
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
name|finfo
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|strdup
argument_list|(
name|filename
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
while|while
condition|(
name|dir
operator|=
name|extract_colon_unit
argument_list|(
name|path
argument_list|,
operator|&
name|index
argument_list|)
condition|)
block|{
name|char
modifier|*
name|fullpath
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|dir
condition|)
block|{
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|dir
operator|=
name|strdup
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
name|fullpath
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fullpath
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|result
operator|=
name|stat
argument_list|(
name|fullpath
argument_list|,
name|finfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
return|return
operator|(
name|fullpath
operator|)
return|;
else|else
name|free
argument_list|(
name|fullpath
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

end_unit

