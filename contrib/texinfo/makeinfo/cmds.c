begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* cmds.c -- Texinfo commands.    $Id: cmds.c,v 1.55 2004/12/14 00:15:36 karl Exp $     Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software    Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cmds.h"
end_include

begin_include
include|#
directive|include
file|"defun.h"
end_include

begin_include
include|#
directive|include
file|"files.h"
end_include

begin_include
include|#
directive|include
file|"footnote.h"
end_include

begin_include
include|#
directive|include
file|"html.h"
end_include

begin_include
include|#
directive|include
file|"insertion.h"
end_include

begin_include
include|#
directive|include
file|"lang.h"
end_include

begin_include
include|#
directive|include
file|"macro.h"
end_include

begin_include
include|#
directive|include
file|"makeinfo.h"
end_include

begin_include
include|#
directive|include
file|"node.h"
end_include

begin_include
include|#
directive|include
file|"sectioning.h"
end_include

begin_include
include|#
directive|include
file|"toc.h"
end_include

begin_include
include|#
directive|include
file|"xml.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TM_IN_SYS_TIME
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Options. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|cm_exampleindent
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|cm_firstparagraphindent
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|cm_paragraphindent
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|cm_novalidate
argument_list|(
name|void
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Internals. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|cm_obsolete
argument_list|(
name|int
name|arg
argument_list|,
name|int
name|start
argument_list|,
name|int
name|end
argument_list|)
decl_stmt|,
name|not_fixed_width
argument_list|(
name|int
name|arg
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The dispatch table.  */
end_comment

begin_decl_stmt
name|COMMAND
name|command_table
index|[]
init|=
block|{
block|{
literal|"\t"
block|,
name|insert_space
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"\n"
block|,
name|insert_space
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|" "
block|,
name|insert_space
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"!"
block|,
name|cm_punct
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"\""
block|,
name|cm_accent_umlaut
block|,
name|MAYBE_BRACE_ARGS
block|}
block|,
block|{
literal|"'"
block|,
name|cm_accent_acute
block|,
name|MAYBE_BRACE_ARGS
block|}
block|,
block|{
literal|"*"
block|,
name|cm_asterisk
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|","
block|,
name|cm_accent_cedilla
block|,
name|MAYBE_BRACE_ARGS
block|}
block|,
block|{
literal|"-"
block|,
name|cm_no_op
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"."
block|,
name|cm_punct
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"/"
block|,
name|cm_no_op
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|":"
block|,
name|cm_colon
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"="
block|,
name|cm_accent
block|,
name|MAYBE_BRACE_ARGS
block|}
block|,
block|{
literal|"?"
block|,
name|cm_punct
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"@"
block|,
name|insert_self
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"\\"
block|,
name|insert_self
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"^"
block|,
name|cm_accent_hat
block|,
name|MAYBE_BRACE_ARGS
block|}
block|,
block|{
literal|"`"
block|,
name|cm_accent_grave
block|,
name|MAYBE_BRACE_ARGS
block|}
block|,
block|{
literal|"{"
block|,
name|insert_self
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"|"
block|,
name|cm_no_op
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"}"
block|,
name|insert_self
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"~"
block|,
name|cm_accent_tilde
block|,
name|MAYBE_BRACE_ARGS
block|}
block|,
block|{
literal|"AA"
block|,
name|cm_special_char
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"AE"
block|,
name|cm_special_char
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"H"
block|,
name|cm_accent
block|,
name|MAYBE_BRACE_ARGS
block|}
block|,
block|{
literal|"L"
block|,
name|cm_special_char
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"LaTeX"
block|,
name|cm_LaTeX
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"O"
block|,
name|cm_special_char
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"OE"
block|,
name|cm_special_char
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"TeX"
block|,
name|cm_TeX
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"aa"
block|,
name|cm_special_char
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"abbr"
block|,
name|cm_abbr
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"acronym"
block|,
name|cm_acronym
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"ae"
block|,
name|cm_special_char
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"afivepaper"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"afourlatex"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"afourpaper"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"afourwide"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"alias"
block|,
name|cm_alias
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"anchor"
block|,
name|cm_anchor
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"appendix"
block|,
name|cm_appendix
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"appendixsection"
block|,
name|cm_appendixsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"appendixsec"
block|,
name|cm_appendixsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"appendixsubsec"
block|,
name|cm_appendixsubsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"appendixsubsubsec"
block|,
name|cm_appendixsubsubsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"asis"
block|,
name|cm_no_op
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"author"
block|,
name|cm_author
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"b"
block|,
name|cm_b
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"bullet"
block|,
name|cm_bullet
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"bye"
block|,
name|cm_bye
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"c"
block|,
name|cm_comment
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"caption"
block|,
name|cm_caption
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"cartouche"
block|,
name|cm_cartouche
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"center"
block|,
name|cm_center
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"centerchap"
block|,
name|cm_unnumbered
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"chapheading"
block|,
name|cm_chapheading
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"chapter"
block|,
name|cm_chapter
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"cindex"
block|,
name|cm_cindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"cite"
block|,
name|cm_cite
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"clear"
block|,
name|cm_clear
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"code"
block|,
name|cm_code
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"comma"
block|,
name|cm_comma
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"command"
block|,
name|cm_code
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"comment"
block|,
name|cm_comment
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"contents"
block|,
name|cm_contents
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"copying"
block|,
name|cm_copying
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"copyright"
block|,
name|cm_copyright
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"ctrl"
block|,
name|cm_obsolete
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"defcodeindex"
block|,
name|cm_defcodeindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defcv"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defcvx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deffn"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deffnx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defindex"
block|,
name|cm_defindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"definfoenclose"
block|,
name|cm_definfoenclose
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defivar"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defivarx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defmac"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defmacx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defmethod"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defmethodx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defop"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defopt"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defoptx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defopx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defspec"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defspecx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftp"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftpx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypecv"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypecvx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypefn"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypefnx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypefun"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypefunx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypeivar"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypeivarx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypemethod"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypemethodx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypeop"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypeopx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypevar"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypevarx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypevr"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypevrx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defun"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defunx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defvar"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defvarx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defvr"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defvrx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"detailmenu"
block|,
name|cm_detailmenu
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"dfn"
block|,
name|cm_dfn
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"dircategory"
block|,
name|cm_dircategory
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"direntry"
block|,
name|cm_direntry
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"display"
block|,
name|cm_display
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"dmn"
block|,
name|cm_dmn
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"docbook"
block|,
name|cm_docbook
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"documentdescription"
block|,
name|cm_documentdescription
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"documentencoding"
block|,
name|cm_documentencoding
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"documentlanguage"
block|,
name|cm_documentlanguage
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"dotaccent"
block|,
name|cm_accent
block|,
name|MAYBE_BRACE_ARGS
block|}
block|,
block|{
literal|"dotless"
block|,
name|cm_dotless
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"dots"
block|,
name|cm_dots
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"email"
block|,
name|cm_email
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"emph"
block|,
name|cm_emph
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"end"
block|,
name|cm_end
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"enddots"
block|,
name|cm_enddots
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"enumerate"
block|,
name|cm_enumerate
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"env"
block|,
name|cm_code
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"equiv"
block|,
name|cm_equiv
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"error"
block|,
name|cm_error
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"euro"
block|,
name|cm_special_char
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"evenfooting"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"evenheading"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"everyfooting"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"everyheading"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"example"
block|,
name|cm_example
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"exampleindent"
block|,
name|cm_exampleindent
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"exclamdown"
block|,
name|cm_special_char
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"exdent"
block|,
name|cm_exdent
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"expansion"
block|,
name|cm_expansion
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"file"
block|,
name|cm_code
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"finalout"
block|,
name|cm_no_op
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"findex"
block|,
name|cm_findex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"firstparagraphindent"
block|,
name|cm_firstparagraphindent
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"float"
block|,
name|cm_float
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"flushleft"
block|,
name|cm_flushleft
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"flushright"
block|,
name|cm_flushright
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"footnote"
block|,
name|cm_footnote
block|,
name|NO_BRACE_ARGS
block|}
block|,
comment|/* self-arg eater */
block|{
literal|"footnotestyle"
block|,
name|cm_footnotestyle
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"format"
block|,
name|cm_format
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ftable"
block|,
name|cm_ftable
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"group"
block|,
name|cm_group
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"heading"
block|,
name|cm_heading
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"headings"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"headitem"
block|,
name|cm_headitem
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"html"
block|,
name|cm_html
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"hyphenation"
block|,
name|cm_ignore_arg
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"i"
block|,
name|cm_i
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"ifclear"
block|,
name|cm_ifclear
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ifeq"
block|,
name|cm_ifeq
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ifdocbook"
block|,
name|cm_ifdocbook
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ifhtml"
block|,
name|cm_ifhtml
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ifinfo"
block|,
name|cm_ifinfo
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ifnotdocbook"
block|,
name|cm_ifnotdocbook
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ifnothtml"
block|,
name|cm_ifnothtml
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ifnotinfo"
block|,
name|cm_ifnotinfo
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ifnotplaintext"
block|,
name|cm_ifnotplaintext
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ifnottex"
block|,
name|cm_ifnottex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ifnotxml"
block|,
name|cm_ifnotxml
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ifplaintext"
block|,
name|cm_ifplaintext
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ifset"
block|,
name|cm_ifset
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iftex"
block|,
name|cm_iftex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ifxml"
block|,
name|cm_ifxml
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ignore"
block|,
name|command_name_condition
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"image"
block|,
name|cm_image
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"include"
block|,
name|cm_include
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"indent"
block|,
name|cm_indent
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"indicateurl"
block|,
name|cm_indicate_url
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"inforef"
block|,
name|cm_inforef
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"insertcopying"
block|,
name|cm_insert_copying
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"item"
block|,
name|cm_item
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"itemize"
block|,
name|cm_itemize
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"itemx"
block|,
name|cm_itemx
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"kbd"
block|,
name|cm_kbd
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"kbdinputstyle"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"key"
block|,
name|cm_key
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"kindex"
block|,
name|cm_kindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"l"
block|,
name|cm_special_char
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"lisp"
block|,
name|cm_lisp
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"listoffloats"
block|,
name|cm_listoffloats
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"lowersections"
block|,
name|cm_lowersections
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"macro"
block|,
name|cm_macro
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"majorheading"
block|,
name|cm_majorheading
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"math"
block|,
name|cm_math
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"menu"
block|,
name|cm_menu
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"minus"
block|,
name|cm_minus
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"multitable"
block|,
name|cm_multitable
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"need"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"node"
block|,
name|cm_node
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"noindent"
block|,
name|cm_noindent_cmd
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"novalidate"
block|,
name|cm_novalidate
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"nwnode"
block|,
name|cm_node
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"o"
block|,
name|cm_special_char
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"oddfooting"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"oddheading"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"oe"
block|,
name|cm_special_char
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"option"
block|,
name|cm_code
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"ordf"
block|,
name|cm_special_char
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"ordm"
block|,
name|cm_special_char
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"page"
block|,
name|cm_no_op
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"pagesizes"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"paragraphindent"
block|,
name|cm_paragraphindent
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"pindex"
block|,
name|cm_pindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"point"
block|,
name|cm_point
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"pounds"
block|,
name|cm_special_char
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"print"
block|,
name|cm_print
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"printindex"
block|,
name|cm_printindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"pxref"
block|,
name|cm_pxref
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"questiondown"
block|,
name|cm_special_char
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"quotation"
block|,
name|cm_quotation
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"r"
block|,
name|cm_r
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"raisesections"
block|,
name|cm_raisesections
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ref"
block|,
name|cm_ref
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"refill"
block|,
name|cm_no_op
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"registeredsymbol"
block|,
name|cm_registeredsymbol
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"result"
block|,
name|cm_result
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"ringaccent"
block|,
name|cm_accent
block|,
name|MAYBE_BRACE_ARGS
block|}
block|,
block|{
literal|"rmacro"
block|,
name|cm_rmacro
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"samp"
block|,
name|cm_code
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"sansserif"
block|,
name|cm_sansserif
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"sc"
block|,
name|cm_sc
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"section"
block|,
name|cm_section
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"set"
block|,
name|cm_set
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"setchapternewpage"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"setchapterstyle"
block|,
name|cm_obsolete
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"setcontentsaftertitlepage"
block|,
name|cm_no_op
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"setfilename"
block|,
name|cm_setfilename
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"setshortcontentsaftertitlepage"
block|,
name|cm_no_op
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"settitle"
block|,
name|cm_settitle
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"shortcaption"
block|,
name|cm_caption
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"shortcontents"
block|,
name|cm_contents
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"shorttitlepage"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"slanted"
block|,
name|cm_slanted
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"smallbook"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"smalldisplay"
block|,
name|cm_smalldisplay
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"smallexample"
block|,
name|cm_smallexample
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"smallformat"
block|,
name|cm_smallformat
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"smalllisp"
block|,
name|cm_smalllisp
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"sp"
block|,
name|cm_sp
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ss"
block|,
name|cm_special_char
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"strong"
block|,
name|cm_strong
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"subheading"
block|,
name|cm_subheading
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"subsection"
block|,
name|cm_subsection
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"subsubheading"
block|,
name|cm_subsubheading
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"subsubsection"
block|,
name|cm_subsubsection
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"subtitle"
block|,
name|cm_titlepage_cmds
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"summarycontents"
block|,
name|cm_contents
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"syncodeindex"
block|,
name|cm_synindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"synindex"
block|,
name|cm_synindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"t"
block|,
name|cm_tt
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"tab"
block|,
name|cm_tab
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"table"
block|,
name|cm_table
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"tex"
block|,
name|cm_tex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"tie"
block|,
name|cm_tie
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"tieaccent"
block|,
name|cm_accent
block|,
name|MAYBE_BRACE_ARGS
block|}
block|,
block|{
literal|"tindex"
block|,
name|cm_tindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"title"
block|,
name|cm_titlepage_cmds
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"titlefont"
block|,
name|cm_titlefont
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"titlepage"
block|,
name|cm_titlepage
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"today"
block|,
name|cm_today
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"top"
block|,
name|cm_top
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"u"
block|,
name|cm_accent
block|,
name|MAYBE_BRACE_ARGS
block|}
block|,
block|{
literal|"ubaraccent"
block|,
name|cm_accent
block|,
name|MAYBE_BRACE_ARGS
block|}
block|,
block|{
literal|"udotaccent"
block|,
name|cm_accent
block|,
name|MAYBE_BRACE_ARGS
block|}
block|,
block|{
literal|"unmacro"
block|,
name|cm_unmacro
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"unnumbered"
block|,
name|cm_unnumbered
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"unnumberedsec"
block|,
name|cm_unnumberedsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"unnumberedsubsec"
block|,
name|cm_unnumberedsubsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"unnumberedsubsubsec"
block|,
name|cm_unnumberedsubsubsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"uref"
block|,
name|cm_uref
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"url"
block|,
name|cm_uref
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"v"
block|,
name|cm_accent
block|,
name|MAYBE_BRACE_ARGS
block|}
block|,
block|{
literal|"value"
block|,
name|cm_value
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"var"
block|,
name|cm_var
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"verb"
block|,
name|cm_verb
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"verbatim"
block|,
name|cm_verbatim
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"verbatiminclude"
block|,
name|cm_verbatiminclude
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"vindex"
block|,
name|cm_vindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"vtable"
block|,
name|cm_vtable
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"vskip"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"w"
block|,
name|cm_w
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"xml"
block|,
name|cm_xml
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"xref"
block|,
name|cm_xref
block|,
name|BRACE_ARGS
block|}
block|,
comment|/* Deprecated commands.  These used to be for italics.  */
block|{
literal|"iappendix"
block|,
name|cm_ideprecated
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iappendixsec"
block|,
name|cm_ideprecated
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iappendixsection"
block|,
name|cm_ideprecated
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iappendixsubsec"
block|,
name|cm_ideprecated
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iappendixsubsubsec"
block|,
name|cm_ideprecated
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ichapter"
block|,
name|cm_ideprecated
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"isection"
block|,
name|cm_ideprecated
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"isubsection"
block|,
name|cm_ideprecated
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"isubsubsection"
block|,
name|cm_ideprecated
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iunnumbered"
block|,
name|cm_ideprecated
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iunnumberedsec"
block|,
name|cm_ideprecated
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iunnumberedsubsec"
block|,
name|cm_ideprecated
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iunnumberedsubsubsec"
block|,
name|cm_ideprecated
block|,
name|NO_BRACE_ARGS
block|}
block|,
comment|/* Now @include does what this was used to. */
block|{
literal|"infoinclude"
block|,
name|cm_obsolete
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"titlespec"
block|,
name|cm_obsolete
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NO_BRACE_ARGS
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The bulk of the Texinfo commands. */
end_comment

begin_comment
comment|/* Commands which insert their own names. */
end_comment

begin_function
name|void
name|insert_self
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_word
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|insert_space
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
if|if
condition|(
name|xml
operator|&&
operator|!
name|docbook
condition|)
name|xml_insert_entity
argument_list|(
literal|"space"
argument_list|)
expr_stmt|;
else|else
name|add_char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Insert a comma.  Useful when a literal , would break our parsing of    multiple arguments.  */
end_comment

begin_function
name|void
name|cm_comma
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_char
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Force a line break in the output. */
end_comment

begin_function
name|void
name|cm_asterisk
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"<br>"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xml
operator|&&
operator|!
name|docbook
condition|)
name|xml_insert_entity
argument_list|(
literal|"linebreak"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|docbook
condition|)
name|xml_asterisk
argument_list|()
expr_stmt|;
else|else
block|{
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|cm_noindent
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Insert ellipsis. */
end_comment

begin_function
name|void
name|cm_dots
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
if|if
condition|(
name|xml
operator|&&
operator|!
name|docbook
condition|)
name|xml_insert_entity
argument_list|(
literal|"dots"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|docbook
condition|)
name|xml_insert_entity
argument_list|(
literal|"hellip"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|html
operator|&&
operator|!
name|in_fixed_width_font
condition|)
name|insert_string
argument_list|(
literal|"<small class=\"dots\">...</small>"
argument_list|)
expr_stmt|;
else|else
name|add_word
argument_list|(
literal|"..."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Insert ellipsis for sentence end. */
end_comment

begin_function
name|void
name|cm_enddots
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
if|if
condition|(
name|xml
operator|&&
operator|!
name|docbook
condition|)
name|xml_insert_entity
argument_list|(
literal|"enddots"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|docbook
condition|)
block|{
name|xml_insert_entity
argument_list|(
literal|"hellip"
argument_list|)
expr_stmt|;
name|add_char
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|html
operator|&&
operator|!
name|in_fixed_width_font
condition|)
name|insert_string
argument_list|(
literal|"<small class=\"enddots\">....</small>"
argument_list|)
expr_stmt|;
else|else
name|add_word
argument_list|(
literal|"...."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|cm_bullet
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"&bull;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xml
operator|&&
operator|!
name|docbook
condition|)
name|xml_insert_entity
argument_list|(
literal|"bullet"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|docbook
condition|)
name|xml_insert_entity
argument_list|(
literal|"bull"
argument_list|)
expr_stmt|;
else|else
name|add_char
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|cm_minus
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
if|if
condition|(
name|xml
condition|)
name|xml_insert_entity
argument_list|(
literal|"minus"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"&minus;"
argument_list|)
expr_stmt|;
else|else
name|add_char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Formatting a dimension unit.  */
end_comment

begin_function
name|void
name|cm_dmn
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|html
condition|)
name|insert_html_tag_with_attribute
argument_list|(
name|arg
argument_list|,
literal|"span"
argument_list|,
literal|"class=\"dmn\""
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|docbook
condition|)
comment|/* No units in docbook yet.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|DIMENSION
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert "TeX". */
end_comment

begin_function
name|void
name|cm_TeX
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
specifier|static
name|int
name|last_position
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
if|if
condition|(
name|xml
condition|)
name|xml_insert_entity
argument_list|(
literal|"tex"
argument_list|)
expr_stmt|;
else|else
name|add_word
argument_list|(
literal|"TeX"
argument_list|)
expr_stmt|;
name|last_position
operator|=
name|output_paragraph_offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last_position
operator|!=
name|output_paragraph_offset
condition|)
block|{
name|warning
argument_list|(
name|_
argument_list|(
literal|"arguments to @%s ignored"
argument_list|)
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|output_paragraph_offset
operator|=
name|last_position
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Insert "LaTeX".  */
end_comment

begin_function
name|void
name|cm_LaTeX
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
specifier|static
name|int
name|last_position
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
if|if
condition|(
name|xml
condition|)
name|xml_insert_entity
argument_list|(
literal|"latex"
argument_list|)
expr_stmt|;
else|else
name|add_word
argument_list|(
literal|"LaTeX"
argument_list|)
expr_stmt|;
name|last_position
operator|=
name|output_paragraph_offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last_position
operator|!=
name|output_paragraph_offset
condition|)
block|{
name|warning
argument_list|(
name|_
argument_list|(
literal|"arguments to @%s ignored"
argument_list|)
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|output_paragraph_offset
operator|=
name|last_position
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Copyright symbol.  */
end_comment

begin_function
name|void
name|cm_copyright
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"&copy;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xml
operator|&&
operator|!
name|docbook
condition|)
name|xml_insert_entity
argument_list|(
literal|"copyright"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|docbook
condition|)
name|xml_insert_entity
argument_list|(
literal|"copy"
argument_list|)
expr_stmt|;
else|else
name|add_word
argument_list|(
literal|"(C)"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Registered symbol.  */
end_comment

begin_function
name|void
name|cm_registeredsymbol
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"&reg;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|docbook
condition|)
name|xml_insert_entity
argument_list|(
literal|"reg"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xml
operator|&&
operator|!
name|docbook
condition|)
name|xml_insert_entity
argument_list|(
literal|"registered"
argument_list|)
expr_stmt|;
else|else
name|add_word
argument_list|(
literal|"(R)"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|cm_today
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|months
index|[
literal|12
index|]
init|=
block|{
name|N_
argument_list|(
literal|"January"
argument_list|)
block|,
name|N_
argument_list|(
literal|"February"
argument_list|)
block|,
name|N_
argument_list|(
literal|"March"
argument_list|)
block|,
name|N_
argument_list|(
literal|"April"
argument_list|)
block|,
name|N_
argument_list|(
literal|"May"
argument_list|)
block|,
name|N_
argument_list|(
literal|"June"
argument_list|)
block|,
name|N_
argument_list|(
literal|"July"
argument_list|)
block|,
name|N_
argument_list|(
literal|"August"
argument_list|)
block|,
name|N_
argument_list|(
literal|"September"
argument_list|)
block|,
name|N_
argument_list|(
literal|"October"
argument_list|)
block|,
name|N_
argument_list|(
literal|"November"
argument_list|)
block|,
name|N_
argument_list|(
literal|"December"
argument_list|)
block|}
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
name|time_t
name|timer
init|=
name|time
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|struct
name|tm
modifier|*
name|ts
init|=
name|localtime
argument_list|(
operator|&
name|timer
argument_list|)
decl_stmt|;
name|add_word_args
argument_list|(
literal|"%d %s %d"
argument_list|,
name|ts
operator|->
name|tm_mday
argument_list|,
name|_
argument_list|(
name|months
index|[
name|ts
operator|->
name|tm_mon
index|]
argument_list|)
argument_list|,
name|ts
operator|->
name|tm_year
operator|+
literal|1900
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|cm_comment
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* For HTML, do not output comments before HTML header is written,      otherwise comments before @settitle cause an empty<title> in the      header.  */
if|if
condition|(
operator|(
name|html
operator|&&
name|html_output_head_p
operator|)
operator|||
name|xml
condition|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|line
argument_list|)
operator|>
literal|0
condition|)
block|{
name|int
name|save_inhibit_indentation
init|=
name|inhibit_paragraph_indentation
decl_stmt|;
name|int
name|save_paragraph_is_open
init|=
name|paragraph_is_open
decl_stmt|;
name|int
name|save_escape_html
init|=
name|escape_html
decl_stmt|;
name|int
name|save_xml_no_para
init|=
name|xml_no_para
decl_stmt|;
name|int
name|i
decl_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|escape_html
operator|=
literal|0
expr_stmt|;
name|xml_no_para
operator|=
literal|1
expr_stmt|;
comment|/* @c and @comment can appear between @item and @itemx,              @deffn and @deffnx.  */
name|xml_dont_touch_items_defs
operator|++
expr_stmt|;
comment|/* Use insert for HTML, and XML when indentation is enabled.              For Docbook, use add_char.  */
if|if
condition|(
name|xml
operator|&&
name|xml_indentation_increment
operator|>
literal|0
operator|&&
name|output_paragraph
index|[
name|output_paragraph_offset
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* Crunch double hyphens in comments.  */
name|add_html_block_elt
argument_list|(
literal|"<!-- "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strlen
argument_list|(
name|line
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|line
index|[
name|i
index|]
operator|!=
literal|'-'
operator|||
operator|(
name|i
operator|&&
name|line
index|[
name|i
operator|-
literal|1
index|]
operator|!=
literal|'-'
operator|)
condition|)
name|add_char
argument_list|(
name|line
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|" -->"
argument_list|)
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|add_char
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
name|save_inhibit_indentation
expr_stmt|;
name|paragraph_is_open
operator|=
name|save_paragraph_is_open
expr_stmt|;
name|escape_html
operator|=
name|save_escape_html
expr_stmt|;
name|xml_no_para
operator|=
name|save_xml_no_para
expr_stmt|;
name|xml_dont_touch_items_defs
operator|--
expr_stmt|;
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
else|else
name|cm_ignore_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We keep acronyms with two arguments around, to be able to refer to them    later with only one argument.  */
end_comment

begin_decl_stmt
specifier|static
name|ACRONYM_DESC
modifier|*
name|acronyms_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|cm_acronym_or_abbr
parameter_list|(
name|int
name|arg
parameter_list|,
name|int
name|is_abbr
parameter_list|)
block|{
name|char
modifier|*
name|aa
decl_stmt|,
modifier|*
name|description
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
comment|/* We do everything at START.  */
if|if
condition|(
name|arg
operator|==
name|END
condition|)
return|return;
name|get_until_in_braces
argument_list|(
literal|","
argument_list|,
operator|&
name|aa
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_text
index|[
name|input_text_offset
index|]
operator|==
literal|','
condition|)
name|input_text_offset
operator|++
expr_stmt|;
name|get_until_in_braces
argument_list|(
literal|"}"
argument_list|,
operator|&
name|description
argument_list|)
expr_stmt|;
name|canon_white
argument_list|(
name|aa
argument_list|)
expr_stmt|;
name|canon_white
argument_list|(
name|description
argument_list|)
expr_stmt|;
comment|/* If not enclosed in braces, strip after comma to be compatible      with texinfo.tex.  */
if|if
condition|(
name|description
index|[
literal|0
index|]
operator|!=
literal|'{'
operator|&&
name|strchr
argument_list|(
name|description
argument_list|,
literal|','
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|description
index|[
name|i
index|]
operator|!=
literal|','
condition|)
name|i
operator|++
expr_stmt|;
comment|/* For now, just terminate the string at comma.  */
name|description
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Get description out of braces.  */
if|if
condition|(
name|description
index|[
literal|0
index|]
operator|==
literal|'{'
condition|)
name|description
operator|++
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|description
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&&
name|description
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'}'
condition|)
name|description
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Save new description.  */
if|if
condition|(
name|strlen
argument_list|(
name|description
argument_list|)
operator|>
literal|0
condition|)
block|{
name|ACRONYM_DESC
modifier|*
name|new
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ACRONYM_DESC
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|acronym
operator|=
name|xstrdup
argument_list|(
name|aa
argument_list|)
expr_stmt|;
name|new
operator|->
name|description
operator|=
name|xstrdup
argument_list|(
name|description
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|acronyms_stack
expr_stmt|;
name|acronyms_stack
operator|=
name|new
expr_stmt|;
block|}
if|if
condition|(
name|html
condition|)
block|{
name|add_word
argument_list|(
name|is_abbr
condition|?
literal|"<abbr"
else|:
literal|"<acronym"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|description
argument_list|)
operator|>
literal|0
condition|)
name|add_word_args
argument_list|(
literal|" title=\"%s\""
argument_list|,
name|text_expansion
argument_list|(
name|description
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|acronyms_stack
condition|)
block|{
comment|/* No second argument, get from previous.  Search order is from              last to first defined, so we get the most recent version of              the description.  */
name|ACRONYM_DESC
modifier|*
name|temp
init|=
name|acronyms_stack
decl_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|aa
argument_list|,
name|temp
operator|->
name|acronym
argument_list|)
operator|&&
name|strlen
argument_list|(
name|temp
operator|->
name|description
argument_list|)
operator|>
literal|0
condition|)
block|{
name|add_word_args
argument_list|(
literal|" title=\"%s\""
argument_list|,
name|text_expansion
argument_list|(
name|temp
operator|->
name|description
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|temp
operator|=
name|temp
operator|->
name|next
expr_stmt|;
block|}
block|}
name|add_char
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|aa
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
name|is_abbr
condition|?
literal|"</abbr>"
else|:
literal|"</acronym>"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|docbook
condition|)
block|{
name|xml_insert_element
argument_list|(
name|is_abbr
condition|?
name|ABBREV
else|:
name|ACRONYM
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|aa
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|is_abbr
condition|?
name|ABBREV
else|:
name|ACRONYM
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xml
condition|)
block|{
name|xml_insert_element
argument_list|(
name|is_abbr
condition|?
name|ABBREV
else|:
name|ACRONYM
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|is_abbr
condition|?
name|ABBREVWORD
else|:
name|ACRONYMWORD
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|aa
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|is_abbr
condition|?
name|ABBREVWORD
else|:
name|ACRONYMWORD
argument_list|,
name|END
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|description
argument_list|)
operator|>
literal|0
condition|)
block|{
name|xml_insert_element
argument_list|(
name|is_abbr
condition|?
name|ABBREVDESC
else|:
name|ACRONYMDESC
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|description
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|is_abbr
condition|?
name|ABBREVDESC
else|:
name|ACRONYMDESC
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
name|xml_insert_element
argument_list|(
name|is_abbr
condition|?
name|ABBREV
else|:
name|ACRONYM
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
else|else
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|aa
argument_list|)
expr_stmt|;
comment|/* Put description into parenthesis after the acronym for all outputs      except XML.  */
if|if
condition|(
name|strlen
argument_list|(
name|description
argument_list|)
operator|>
literal|0
operator|&&
operator|(
operator|!
name|xml
operator|||
name|docbook
operator|)
condition|)
name|add_word_args
argument_list|(
literal|" (%s)"
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_acronym
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
name|cm_acronym_or_abbr
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_abbr
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
name|cm_acronym_or_abbr
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_tt
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
comment|/* @t{} is a no-op in Info.  */
if|if
condition|(
name|html
condition|)
name|insert_html_tag
argument_list|(
name|arg
argument_list|,
literal|"tt"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|TT
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_code
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|in_fixed_width_font
operator|++
expr_stmt|;
if|if
condition|(
name|xml
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|command
argument_list|,
literal|"command"
argument_list|)
condition|)
name|xml_insert_element
argument_list|(
name|COMMAND_TAG
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|command
argument_list|,
literal|"env"
argument_list|)
condition|)
name|xml_insert_element
argument_list|(
name|ENV
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|command
argument_list|,
literal|"file"
argument_list|)
condition|)
name|xml_insert_element
argument_list|(
name|FILE_TAG
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|command
argument_list|,
literal|"option"
argument_list|)
condition|)
name|xml_insert_element
argument_list|(
name|OPTION
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|command
argument_list|,
literal|"samp"
argument_list|)
condition|)
block|{
if|if
condition|(
name|docbook
operator|&&
name|arg
operator|==
name|START
condition|)
block|{
comment|/* Even though @samp is in_fixed_width_font, it                  should always start a paragraph.  Unfortunately,                  in_fixed_width_font inhibits that.  */
name|xml_start_para
argument_list|()
expr_stmt|;
name|xml_insert_entity
argument_list|(
literal|"lsquo"
argument_list|)
expr_stmt|;
block|}
name|xml_insert_element
argument_list|(
name|SAMP
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|docbook
operator|&&
name|arg
operator|==
name|END
condition|)
name|xml_insert_entity
argument_list|(
literal|"rsquo"
argument_list|)
expr_stmt|;
block|}
else|else
name|xml_insert_element
argument_list|(
name|CODE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|html
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|command
argument_list|,
literal|"code"
argument_list|)
condition|)
name|insert_html_tag
argument_list|(
name|arg
argument_list|,
literal|"code"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Use<samp> tag in general to get typewriter.  */
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
comment|/* If @samp specifically, add quotes a la TeX output.  */
if|if
condition|(
name|STREQ
argument_list|(
name|command
argument_list|,
literal|"samp"
argument_list|)
condition|)
name|add_char
argument_list|(
literal|'`'
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"<samp>"
argument_list|)
expr_stmt|;
block|}
name|insert_html_tag_with_attribute
argument_list|(
name|arg
argument_list|,
literal|"span"
argument_list|,
literal|"class=\"%s\""
argument_list|,
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|END
condition|)
block|{
name|add_word
argument_list|(
literal|"</samp>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|command
argument_list|,
literal|"samp"
argument_list|)
condition|)
name|add_char
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
specifier|extern
name|int
name|printing_index
decl_stmt|;
if|if
condition|(
operator|!
name|printing_index
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_char
argument_list|(
literal|'`'
argument_list|)
expr_stmt|;
else|else
name|add_meta_char
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|cm_kbd
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|KBD
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|html
condition|)
block|{
comment|/* Seems like we should increment in_fixed_width_font for Info          format too, but then the quote-omitting special case gets          confused.  Punt.  */
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|in_fixed_width_font
operator|++
expr_stmt|;
name|insert_html_tag
argument_list|(
name|arg
argument_list|,
literal|"kbd"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* People use @kbd in an example to get the "user input" font.          We don't want quotes in that case.  */
if|if
condition|(
operator|!
name|in_fixed_width_font
condition|)
name|cm_code
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Just show a url (http://example.org/..., for example), don't link to it.  */
end_comment

begin_function
name|void
name|cm_indicate_url
parameter_list|(
name|int
name|arg
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|URL
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|html
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_word
argument_list|(
literal|"&lt;"
argument_list|)
expr_stmt|;
name|insert_html_tag
argument_list|(
name|arg
argument_list|,
literal|"code"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|!=
name|START
condition|)
name|add_word
argument_list|(
literal|"&gt;"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_word
argument_list|(
literal|"<"
argument_list|)
expr_stmt|;
else|else
name|add_word
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_key
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|KEY
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
name|arg
operator|==
name|START
condition|?
literal|"&lt;"
else|:
literal|"&gt;"
argument_list|)
expr_stmt|;
else|else
name|add_char
argument_list|(
name|arg
operator|==
name|START
condition|?
literal|'<'
else|:
literal|'>'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a command that switches to a non-fixed-width font.  */
end_comment

begin_function
name|void
name|not_fixed_width
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|in_fixed_width_font
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* @var in makeinfo just uppercases the text. */
end_comment

begin_function
name|void
name|cm_var
parameter_list|(
name|int
name|arg
parameter_list|,
name|int
name|start_pos
parameter_list|,
name|int
name|end_pos
parameter_list|)
block|{
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|VAR
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|not_fixed_width
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|insert_html_tag
argument_list|(
name|arg
argument_list|,
literal|"var"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|==
name|END
condition|)
block|{
while|while
condition|(
name|start_pos
operator|<
name|end_pos
condition|)
block|{
name|unsigned
name|char
name|c
init|=
name|output_paragraph
index|[
name|start_pos
index|]
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"[](),"
argument_list|,
name|c
argument_list|)
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"unlikely character %c in @var"
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|output_paragraph
index|[
name|start_pos
index|]
operator|=
name|coerce_to_upper
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|start_pos
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|cm_sc
parameter_list|(
name|int
name|arg
parameter_list|,
name|int
name|start_pos
parameter_list|,
name|int
name|end_pos
parameter_list|)
block|{
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|SC
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|not_fixed_width
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
if|if
condition|(
name|html
condition|)
name|insert_html_tag_with_attribute
argument_list|(
name|arg
argument_list|,
literal|"span"
argument_list|,
literal|"class=\"sc\""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|all_upper
decl_stmt|;
if|if
condition|(
name|html
condition|)
name|start_pos
operator|+=
sizeof|sizeof
argument_list|(
literal|"<span class=\"sc\">"
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* skip<span> */
comment|/* Avoid the warning below if there's no text inside @sc{}, or              when processing menus under --no-headers.  */
name|all_upper
operator|=
name|start_pos
operator|<
name|end_pos
expr_stmt|;
while|while
condition|(
name|start_pos
operator|<
name|end_pos
condition|)
block|{
name|unsigned
name|char
name|c
init|=
name|output_paragraph
index|[
name|start_pos
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|all_upper
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|html
condition|)
name|output_paragraph
index|[
name|start_pos
index|]
operator|=
name|coerce_to_upper
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|start_pos
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|all_upper
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"@sc argument all uppercase, thus no effect"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|insert_html_tag
argument_list|(
name|arg
argument_list|,
literal|"span"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|cm_dfn
parameter_list|(
name|int
name|arg
parameter_list|,
name|int
name|position
parameter_list|)
block|{
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|DFN
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|html
condition|)
name|insert_html_tag
argument_list|(
name|arg
argument_list|,
literal|"dfn"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_char
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
else|else
name|add_meta_char
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|cm_emph
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|EMPH
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|html
condition|)
name|insert_html_tag
argument_list|(
name|arg
argument_list|,
literal|"em"
argument_list|)
expr_stmt|;
else|else
name|add_char
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_verb
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
name|int
name|character
decl_stmt|;
name|int
name|delimiter
init|=
literal|0
decl_stmt|;
comment|/* avoid warning */
name|int
name|seen_end
init|=
literal|0
decl_stmt|;
name|in_fixed_width_font
operator|++
expr_stmt|;
comment|/* are these necessary ? */
name|last_char_was_newline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"<tt>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_text_offset
operator|<
name|input_text_length
condition|)
block|{
name|character
operator|=
name|curchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|character
operator|==
literal|'{'
condition|)
name|input_text_offset
operator|++
expr_stmt|;
else|else
name|line_error
argument_list|(
name|_
argument_list|(
literal|"`{' expected, but saw `%c'"
argument_list|)
argument_list|,
name|character
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|input_text_offset
operator|<
name|input_text_length
condition|)
block|{
name|delimiter
operator|=
name|curchar
argument_list|()
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|input_text_offset
operator|<
name|input_text_length
condition|)
block|{
name|character
operator|=
name|curchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|character
operator|==
literal|'\n'
condition|)
block|{
name|line_number
operator|++
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"<br>\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|html
operator|&&
name|character
operator|==
literal|'<'
condition|)
name|add_word
argument_list|(
literal|"&lt;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|html
operator|&&
name|character
operator|==
literal|'&'
condition|)
name|add_word
argument_list|(
literal|"&amp;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|character
operator|==
name|delimiter
operator|&&
name|input_text
index|[
name|input_text_offset
operator|+
literal|1
index|]
operator|==
literal|'}'
condition|)
block|{
comment|/* Assume no newlines in END_VERBATIM. */
name|seen_end
operator|=
literal|1
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
break|break;
block|}
else|else
name|add_char
argument_list|(
name|character
argument_list|)
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|seen_end
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"end of file inside verb block"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_text_offset
operator|<
name|input_text_length
condition|)
block|{
name|character
operator|=
name|curchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|character
operator|==
literal|'}'
condition|)
name|input_text_offset
operator|++
expr_stmt|;
else|else
name|line_error
argument_list|(
name|_
argument_list|(
literal|"`}' expected, but saw `%c'"
argument_list|)
argument_list|,
name|character
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"</tt>"
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|--
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_strong
parameter_list|(
name|int
name|arg
parameter_list|,
name|int
name|start_pos
parameter_list|,
name|int
name|end_pos
parameter_list|)
block|{
if|if
condition|(
name|docbook
operator|&&
name|arg
operator|==
name|START
condition|)
name|xml_insert_element_with_attribute
argument_list|(
name|B
argument_list|,
name|arg
argument_list|,
literal|"role=\"bold\""
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|STRONG
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|html
condition|)
name|insert_html_tag
argument_list|(
name|arg
argument_list|,
literal|"strong"
argument_list|)
expr_stmt|;
else|else
name|add_char
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xml
operator|&&
operator|!
name|html
operator|&&
operator|!
name|docbook
operator|&&
operator|!
name|no_headers
operator|&&
name|arg
operator|==
name|END
operator|&&
name|end_pos
operator|-
name|start_pos
operator|>=
literal|6
operator|&&
operator|(
name|STRNCASEEQ
argument_list|(
operator|(
name|char
operator|*
operator|)
name|output_paragraph
operator|+
name|start_pos
argument_list|,
literal|"*Note:"
argument_list|,
literal|6
argument_list|)
operator|||
name|STRNCASEEQ
argument_list|(
operator|(
name|char
operator|*
operator|)
name|output_paragraph
operator|+
name|start_pos
argument_list|,
literal|"*Note "
argument_list|,
literal|6
argument_list|)
operator|)
condition|)
block|{
comment|/* Translators: "Note:" is literal here and should not be          translated.  @strong{Nota}, say, does not cause the problem.  */
name|warning
argument_list|(
name|_
argument_list|(
literal|"@strong{Note...} produces a spurious cross-reference in Info; reword to avoid that"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Adjust the output to avoid writing the bad xref.  */
name|output_paragraph
index|[
name|start_pos
operator|+
literal|5
index|]
operator|=
literal|'_'
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|cm_cite
parameter_list|(
name|int
name|arg
parameter_list|,
name|int
name|position
parameter_list|)
block|{
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|CITE
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|html
condition|)
name|insert_html_tag
argument_list|(
name|arg
argument_list|,
literal|"cite"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_char
argument_list|(
literal|'`'
argument_list|)
expr_stmt|;
else|else
name|add_char
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* No highlighting, but argument switches fonts.  */
end_comment

begin_function
name|void
name|cm_not_fixed_width
parameter_list|(
name|int
name|arg
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|NOTFIXEDWIDTH
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|not_fixed_width
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_i
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
comment|/* Make use of<lineannotation> of Docbook, if we are      inside an @example or similar.  */
specifier|extern
name|int
name|printing_index
decl_stmt|;
if|if
condition|(
name|docbook
operator|&&
operator|!
name|filling_enabled
operator|&&
operator|!
name|printing_index
condition|)
name|xml_insert_element
argument_list|(
name|LINEANNOTATION
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|I
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|html
condition|)
name|insert_html_tag
argument_list|(
name|arg
argument_list|,
literal|"i"
argument_list|)
expr_stmt|;
else|else
name|not_fixed_width
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_slanted
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
comment|/* Make use of<lineannotation> of Docbook, if we are      inside an @example or similar.  */
specifier|extern
name|int
name|printing_index
decl_stmt|;
if|if
condition|(
name|docbook
operator|&&
operator|!
name|filling_enabled
operator|&&
operator|!
name|printing_index
condition|)
name|xml_insert_element
argument_list|(
name|LINEANNOTATION
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|SLANTED
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|html
condition|)
name|insert_html_tag
argument_list|(
name|arg
argument_list|,
literal|"i"
argument_list|)
expr_stmt|;
else|else
name|not_fixed_width
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_b
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
comment|/* See cm_i comments.  */
specifier|extern
name|int
name|printing_index
decl_stmt|;
if|if
condition|(
name|docbook
operator|&&
operator|!
name|filling_enabled
operator|&&
operator|!
name|printing_index
condition|)
name|xml_insert_element
argument_list|(
name|LINEANNOTATION
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|docbook
operator|&&
name|arg
operator|==
name|START
condition|)
name|xml_insert_element_with_attribute
argument_list|(
name|B
argument_list|,
name|arg
argument_list|,
literal|"role=\"bold\""
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|B
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|html
condition|)
name|insert_html_tag
argument_list|(
name|arg
argument_list|,
literal|"b"
argument_list|)
expr_stmt|;
else|else
name|not_fixed_width
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_r
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
comment|/* See cm_i comments.  */
specifier|extern
name|int
name|printing_index
decl_stmt|;
if|if
condition|(
name|docbook
operator|&&
operator|!
name|filling_enabled
operator|&&
operator|!
name|printing_index
condition|)
name|xml_insert_element
argument_list|(
name|LINEANNOTATION
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|R
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|html
condition|)
name|insert_html_tag_with_attribute
argument_list|(
name|arg
argument_list|,
literal|"span"
argument_list|,
literal|"class=\"roman\""
argument_list|)
expr_stmt|;
else|else
name|not_fixed_width
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_sansserif
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
comment|/* See cm_i comments.  */
specifier|extern
name|int
name|printing_index
decl_stmt|;
if|if
condition|(
name|docbook
operator|&&
operator|!
name|filling_enabled
operator|&&
operator|!
name|printing_index
condition|)
name|xml_insert_element
argument_list|(
name|LINEANNOTATION
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|SANSSERIF
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|html
condition|)
name|insert_html_tag_with_attribute
argument_list|(
name|arg
argument_list|,
literal|"span"
argument_list|,
literal|"class=\"sansserif\""
argument_list|)
expr_stmt|;
else|else
name|not_fixed_width
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_titlefont
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|TITLEFONT
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|not_fixed_width
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|html
condition|)
block|{
name|html_title_written
operator|=
literal|1
expr_stmt|;
comment|/* suppress title from @settitle */
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_word
argument_list|(
literal|"<h1 class=\"titlefont\">"
argument_list|)
expr_stmt|;
else|else
name|add_word
argument_list|(
literal|"</h1>\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Unfortunately, we cannot interpret @math{} contents like TeX does.  We just    pass them through.  */
end_comment

begin_function
name|void
name|cm_math
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|xml
operator|&&
operator|!
name|docbook
condition|)
name|xml_insert_element
argument_list|(
name|MATH
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Various commands are no-op's. */
end_comment

begin_function
name|void
name|cm_no_op
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* For proofing single chapters, etc.  */
end_comment

begin_function
name|void
name|cm_novalidate
parameter_list|(
name|void
parameter_list|)
block|{
name|validating
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prevent the argument from being split across two lines. */
end_comment

begin_function
name|void
name|cm_w
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|non_splitting_words
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|docbook
operator|||
name|html
operator|||
name|xml
condition|)
comment|/* This is so @w{$}Log$ doesn't end up as<dollar>Log<dollar>            in the output.  */
name|insert_string
argument_list|(
literal|"<!-- /@w -->"
argument_list|)
expr_stmt|;
name|non_splitting_words
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* An unbreakable word space.  Same as @w{ } for makeinfo, but different    for TeX (the space stretches and stretches, and does not inhibit    hyphenation).  */
end_comment

begin_function
name|void
name|cm_tie
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
name|cm_w
argument_list|(
name|START
argument_list|)
expr_stmt|;
name|add_char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
name|cm_w
argument_list|(
name|END
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Explain that this command is obsolete, thus the user shouldn't    do anything with it. */
end_comment

begin_function
specifier|static
name|void
name|cm_obsolete
parameter_list|(
name|int
name|arg
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"%c%s is obsolete"
argument_list|)
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Inhibit the indentation of the next paragraph, but not of following    paragraphs.  */
end_comment

begin_function
name|void
name|cm_noindent
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inhibit_paragraph_indentation
condition|)
name|inhibit_paragraph_indentation
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_noindent_cmd
parameter_list|(
name|void
parameter_list|)
block|{
name|cm_noindent
argument_list|()
expr_stmt|;
name|xml_no_indent
operator|=
literal|1
expr_stmt|;
name|skip_whitespace_and_newlines
argument_list|()
expr_stmt|;
if|if
condition|(
name|xml
condition|)
name|xml_start_para
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|html
operator|&&
operator|!
name|paragraph_is_open
condition|)
name|add_html_block_elt
argument_list|(
literal|"<p class=\"noindent\">"
argument_list|)
expr_stmt|;
else|else
block|{
name|paragraph_is_open
operator|=
literal|0
expr_stmt|;
name|start_paragraph
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Force indentation of the next paragraph. */
end_comment

begin_function
name|void
name|cm_indent
parameter_list|(
name|void
parameter_list|)
block|{
name|inhibit_paragraph_indentation
operator|=
literal|0
expr_stmt|;
name|xml_no_indent
operator|=
literal|0
expr_stmt|;
name|skip_whitespace_and_newlines
argument_list|()
expr_stmt|;
if|if
condition|(
name|xml
condition|)
name|xml_start_para
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|html
operator|&&
operator|!
name|paragraph_is_open
condition|)
name|add_html_block_elt
argument_list|(
literal|"<p class=\"indent\">"
argument_list|)
expr_stmt|;
else|else
name|start_paragraph
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* I don't know exactly what to do with this.  Should I allow    someone to switch filenames in the middle of output?  Since the    file could be partially written, this doesn't seem to make sense.    Another option: ignore it, since they don't really want to    switch files.  Finally, complain, or at least warn.  It doesn't    really matter, anyway, since this doesn't get executed.  */
end_comment

begin_function
name|void
name|cm_setfilename
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|get_rest_of_line
argument_list|(
literal|1
argument_list|,
operator|&
name|filename
argument_list|)
expr_stmt|;
comment|/* warning ("`@%s %s' encountered and ignored", command, filename); */
if|if
condition|(
name|xml
condition|)
name|add_word_args
argument_list|(
literal|"<setfilename>%s</setfilename>"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_settitle
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|xml
condition|)
block|{
name|xml_begin_document
argument_list|(
name|current_output_filename
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|SETTITLE
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_in_book_title
operator|=
literal|1
expr_stmt|;
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|title
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|title
argument_list|)
expr_stmt|;
name|xml_in_book_title
operator|=
literal|0
expr_stmt|;
name|xml_insert_element
argument_list|(
name|SETTITLE
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
else|else
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|title
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Ignore argument in braces.  */
end_comment

begin_function
name|void
name|cm_ignore_arg
parameter_list|(
name|int
name|arg
parameter_list|,
name|int
name|start_pos
parameter_list|,
name|int
name|end_pos
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|output_paragraph_offset
operator|=
name|start_pos
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Ignore argument on rest of line.  */
end_comment

begin_function
name|void
name|cm_ignore_line
parameter_list|(
name|void
parameter_list|)
block|{
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert the number of blank lines passed as argument. */
end_comment

begin_function
name|void
name|cm_sp
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|lines
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
comment|/* Due to tricky stuff in execute_string(), @value{} can't be expanded.      So there is really no reason to enable expansion for @sp parameters.  */
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|line
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|lines
argument_list|)
operator|!=
literal|1
operator|||
name|lines
operator|<=
literal|0
condition|)
name|line_error
argument_list|(
name|_
argument_list|(
literal|"@sp requires a positive numeric argument, not `%s'"
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|xml
condition|)
block|{
comment|/* @sp can appear between @item and @itemx, @deffn and @deffnx.  */
name|xml_dont_touch_items_defs
operator|++
expr_stmt|;
name|xml_insert_element_with_attribute
argument_list|(
name|SP
argument_list|,
name|START
argument_list|,
literal|"lines=\"%s\""
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/*	  insert_string (line);*/
name|xml_insert_element
argument_list|(
name|SP
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_dont_touch_items_defs
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* Must disable filling since otherwise multiple newlines is like              multiple spaces.  Must close paragraph since that's what the              manual says and that's what TeX does.  */
name|int
name|save_filling_enabled
init|=
name|filling_enabled
decl_stmt|;
name|filling_enabled
operator|=
literal|0
expr_stmt|;
comment|/* close_paragraph generates an extra blank line.  */
name|close_single_paragraph
argument_list|()
expr_stmt|;
if|if
condition|(
name|lines
operator|&&
name|html
operator|&&
operator|!
name|executing_string
condition|)
name|html_output_head
argument_list|()
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|add_html_block_elt
argument_list|(
literal|"<pre class=\"sp\">\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|lines
operator|--
condition|)
name|add_char
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|add_html_block_elt
argument_list|(
literal|"</pre>\n"
argument_list|)
expr_stmt|;
name|filling_enabled
operator|=
name|save_filling_enabled
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* @dircategory LINE outputs INFO-DIR-SECTION LINE, unless --no-headers.  */
end_comment

begin_function
name|void
name|cm_dircategory
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
if|if
condition|(
name|html
operator|||
name|docbook
condition|)
name|cm_ignore_line
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|xml
condition|)
block|{
name|xml_insert_element
argument_list|(
name|DIRCATEGORY
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|get_rest_of_line
argument_list|(
literal|1
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|DIRCATEGORY
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|get_rest_of_line
argument_list|(
literal|1
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_headers
operator|&&
operator|!
name|html
condition|)
block|{
name|kill_self_indent
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* make sure there's no indentation */
name|insert_string
argument_list|(
literal|"INFO-DIR-SECTION "
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Start a new line with just this text on it.    Then center the line of text.    */
end_comment

begin_function
name|void
name|cm_center
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|xml
condition|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|xml_insert_element
argument_list|(
name|CENTER
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|CENTER
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|,
name|start
decl_stmt|,
name|length
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|save_indented_fill
init|=
name|indented_fill
decl_stmt|;
name|int
name|save_filling_enabled
init|=
name|filling_enabled
decl_stmt|;
name|int
name|fudge_factor
init|=
literal|1
decl_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|0
expr_stmt|;
name|cm_noindent
argument_list|()
expr_stmt|;
name|start
operator|=
name|output_paragraph_offset
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|add_html_block_elt
argument_list|(
literal|"<div align=\"center\">"
argument_list|)
expr_stmt|;
name|inhibit_output_flushing
argument_list|()
expr_stmt|;
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|uninhibit_output_flushing
argument_list|()
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|add_html_block_elt
argument_list|(
literal|"</div>"
argument_list|)
expr_stmt|;
else|else
block|{
name|i
operator|=
name|output_paragraph_offset
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|>
operator|(
name|start
operator|-
literal|1
operator|)
operator|&&
name|output_paragraph
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
name|i
operator|--
expr_stmt|;
name|output_paragraph_offset
operator|=
operator|++
name|i
expr_stmt|;
name|length
operator|=
name|output_paragraph_offset
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|length
operator|<
operator|(
name|fill_column
operator|-
name|fudge_factor
operator|)
condition|)
block|{
name|line
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|length
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|line
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|output_paragraph
operator|+
name|start
operator|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|fill_column
operator|-
name|fudge_factor
operator|-
name|length
operator|)
operator|/
literal|2
expr_stmt|;
name|output_paragraph_offset
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
name|insert
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
name|insert
argument_list|(
name|line
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
block|}
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|filling_enabled
operator|=
name|save_filling_enabled
expr_stmt|;
name|indented_fill
operator|=
name|save_indented_fill
expr_stmt|;
name|close_single_paragraph
argument_list|()
expr_stmt|;
if|if
condition|(
name|looking_at
argument_list|(
literal|"\n"
argument_list|)
condition|)
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Show what an expression returns. */
end_comment

begin_function
name|void
name|cm_result
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|add_word
argument_list|(
name|html
condition|?
literal|"=&gt;"
else|:
literal|"=>"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* What an expression expands to. */
end_comment

begin_function
name|void
name|cm_expansion
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|add_word
argument_list|(
name|html
condition|?
literal|"==&gt;"
else|:
literal|"==>"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Indicates two expressions are equivalent. */
end_comment

begin_function
name|void
name|cm_equiv
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|add_word
argument_list|(
literal|"=="
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* What an expression may print. */
end_comment

begin_function
name|void
name|cm_print
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|add_word
argument_list|(
literal|"-|"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* An error signaled. */
end_comment

begin_function
name|void
name|cm_error
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|add_word
argument_list|(
name|html
condition|?
literal|"error--&gt;"
else|:
literal|"error-->"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The location of point in an example of a buffer. */
end_comment

begin_function
name|void
name|cm_point
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|add_word
argument_list|(
literal|"-!-"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* @exdent: Start a new line with just this text on it.    The text is outdented one level if possible. */
end_comment

begin_function
name|void
name|cm_exdent
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|save_indent
init|=
name|current_indent
decl_stmt|;
name|int
name|save_in_fixed_width_font
init|=
name|in_fixed_width_font
decl_stmt|;
comment|/* Read argument.  */
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
comment|/* Exdent the output.  Actually this may be a no-op.   */
if|if
condition|(
name|current_indent
condition|)
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
comment|/* @exdent arg is supposed to be in roman.  */
name|in_fixed_width_font
operator|=
literal|0
expr_stmt|;
comment|/* The preceding newline already inserted the `current_indent'.      Remove one level's worth.  */
name|kill_self_indent
argument_list|(
name|default_indentation_increment
argument_list|)
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"<br>"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|docbook
condition|)
name|xml_insert_element
argument_list|(
name|LINEANNOTATION
argument_list|,
name|START
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|EXDENT
argument_list|,
name|START
argument_list|)
expr_stmt|;
comment|/* Can't close_single_paragraph, then we lose preceding blank lines.  */
name|flush_output
argument_list|()
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"<br>"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xml
condition|)
block|{
name|xml_insert_element
argument_list|(
name|docbook
condition|?
name|LINEANNOTATION
else|:
name|EXDENT
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|current_indent
operator|=
name|save_indent
expr_stmt|;
name|in_fixed_width_font
operator|=
name|save_in_fixed_width_font
expr_stmt|;
if|if
condition|(
operator|!
name|xml
condition|)
name|start_paragraph
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*    Read include-filename, process the include-file:     verbatim_include == 0: process through reader_loop     verbatim_include != 0: process through handle_verbatim_environment  */
end_comment

begin_function
specifier|static
name|void
name|handle_include
parameter_list|(
name|int
name|verbatim_include
parameter_list|)
block|{
name|char
modifier|*
name|arg
decl_stmt|,
modifier|*
name|filename
decl_stmt|;
if|if
condition|(
name|macro_expansion_output_stream
operator|&&
operator|!
name|executing_string
condition|)
name|me_append_before_this_command
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|insertion_stack
condition|)
name|close_paragraph
argument_list|()
expr_stmt|;
comment|/* No blank lines etc. if not at outer level.  */
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
comment|/* We really only want to expand @value, but it's easier to just do      everything.  TeX will only work with @value.  */
name|filename
operator|=
name|text_expansion
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|macro_expansion_output_stream
operator|&&
operator|!
name|executing_string
condition|)
name|remember_itext
argument_list|(
name|input_text
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
name|pushfile
argument_list|()
expr_stmt|;
comment|/* In verbose mode we print info about including another file. */
if|if
condition|(
name|verbose_mode
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|FSTACK
modifier|*
name|stack
init|=
name|filestack
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|stack
operator|=
name|filestack
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
operator|,
name|i
operator|++
control|)
empty_stmt|;
name|i
operator|*=
literal|2
expr_stmt|;
name|printf
argument_list|(
literal|"%*s"
argument_list|,
name|i
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c%s `%s'\n"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|find_and_load
argument_list|(
name|filename
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|popfile
argument_list|()
expr_stmt|;
name|line_number
operator|--
expr_stmt|;
comment|/* /wh/bar:5: @include/@verbatiminclude `foo': No such file or dir */
name|line_error
argument_list|(
literal|"%c%s `%s': %s"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|macro_expansion_output_stream
operator|&&
operator|!
name|executing_string
condition|)
name|remember_itext
argument_list|(
name|input_text
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|verbatim_include
condition|)
name|reader_loop
argument_list|()
expr_stmt|;
else|else
name|handle_verbatim_environment
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|popfile
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Include file as if put in @verbatim environment */
end_comment

begin_function
name|void
name|cm_verbatiminclude
parameter_list|(
name|void
parameter_list|)
block|{
name|handle_include
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remember this file, and move onto the next. */
end_comment

begin_function
name|void
name|cm_include
parameter_list|(
name|void
parameter_list|)
block|{
name|handle_include
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* @bye: Signals end of processing.  Easy to make this happen. */
end_comment

begin_function
name|void
name|cm_bye
parameter_list|(
name|void
parameter_list|)
block|{
name|discard_braces
argument_list|()
expr_stmt|;
comment|/* should not have any unclosed braces left */
name|input_text_offset
operator|=
name|input_text_length
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* @paragraphindent */
end_comment

begin_function
specifier|static
name|void
name|cm_paragraphindent
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|get_rest_of_line
argument_list|(
literal|1
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_paragraph_indent
argument_list|(
name|arg
argument_list|)
operator|!=
literal|0
condition|)
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Bad argument to %c%s"
argument_list|)
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* @exampleindent: change indentation of example-like environments.   */
end_comment

begin_function
specifier|static
name|int
name|set_example_indentation_increment
parameter_list|(
name|char
modifier|*
name|string
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"asis"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|string
argument_list|,
name|_
argument_list|(
literal|"asis"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|string
argument_list|,
name|_
argument_list|(
literal|"none"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|example_indentation_increment
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|string
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|example_indentation_increment
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cm_exampleindent
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|get_rest_of_line
argument_list|(
literal|1
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_example_indentation_increment
argument_list|(
name|arg
argument_list|)
operator|!=
literal|0
condition|)
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Bad argument to @%s"
argument_list|)
argument_list|,
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_text
index|[
name|input_text_offset
index|]
operator|==
literal|'\n'
condition|)
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* @firstparagraphindent: suppress indentation in first paragraphs after    headings. */
end_comment

begin_function
specifier|static
name|int
name|set_firstparagraphindent
parameter_list|(
name|char
modifier|*
name|string
parameter_list|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|string
argument_list|,
literal|"insert"
argument_list|)
operator|||
name|STREQ
argument_list|(
name|string
argument_list|,
name|_
argument_list|(
literal|"insert"
argument_list|)
argument_list|)
condition|)
name|do_first_par_indent
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|string
argument_list|,
literal|"none"
argument_list|)
operator|||
name|STREQ
argument_list|(
name|string
argument_list|,
name|_
argument_list|(
literal|"none"
argument_list|)
argument_list|)
condition|)
name|do_first_par_indent
operator|=
literal|0
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cm_firstparagraphindent
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|get_rest_of_line
argument_list|(
literal|1
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_firstparagraphindent
argument_list|(
name|arg
argument_list|)
operator|!=
literal|0
condition|)
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Bad argument to %c%s"
argument_list|)
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For DocBook and XML, produce&period; for `.@:'. This gives the processing    software a fighting chance to treat it specially by not adding extra space.       Do this also for ?, !, and :.  */
end_comment

begin_function
name|void
name|cm_colon
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|xml
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
literal|".?!:"
argument_list|,
name|input_text
index|[
name|input_text_offset
operator|-
literal|3
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Erase literal character that's there, except `>', which is              part of the XML tag.  */
if|if
condition|(
name|output_paragraph
index|[
name|output_paragraph_offset
operator|-
literal|1
index|]
operator|!=
literal|'>'
condition|)
name|output_paragraph_offset
operator|--
expr_stmt|;
switch|switch
condition|(
name|input_text
index|[
name|input_text_offset
operator|-
literal|3
index|]
condition|)
block|{
case|case
literal|'.'
case|:
name|xml_insert_entity
argument_list|(
literal|"period"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|xml_insert_entity
argument_list|(
literal|"quest"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|xml_insert_entity
argument_list|(
literal|"excl"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|':'
case|:
name|xml_insert_entity
argument_list|(
literal|"colon"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Ending sentences explicitly.  Currently, only outputs entities for XML    output, for other formats it calls insert_self.  */
end_comment

begin_function
name|void
name|cm_punct
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|xml
operator|&&
operator|!
name|docbook
condition|)
block|{
switch|switch
condition|(
name|input_text
index|[
name|input_text_offset
operator|-
literal|1
index|]
condition|)
block|{
case|case
literal|'.'
case|:
name|xml_insert_entity
argument_list|(
literal|"eosperiod"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|xml_insert_entity
argument_list|(
literal|"eosquest"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|xml_insert_entity
argument_list|(
literal|"eosexcl"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|insert_self
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

