begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* defun.c -- @defun and friends.    $Id: defun.c,v 1.3 2002/11/11 00:57:49 feloy Exp $     Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"defun.h"
end_include

begin_include
include|#
directive|include
file|"xml.h"
end_include

begin_include
include|#
directive|include
file|"insertion.h"
end_include

begin_include
include|#
directive|include
file|"makeinfo.h"
end_include

begin_include
include|#
directive|include
file|"cmds.h"
end_include

begin_include
include|#
directive|include
file|"html.h"
end_include

begin_define
define|#
directive|define
name|DEFUN_SELF_DELIMITING
parameter_list|(
name|c
parameter_list|)
define|\
value|((c) == '(' || (c) == ')' || (c) == '[' || (c) == ']')
end_define

begin_struct
struct|struct
name|token_accumulator
block|{
name|unsigned
name|int
name|length
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
name|char
modifier|*
modifier|*
name|tokens
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|initialize_token_accumulator
parameter_list|(
name|accumulator
parameter_list|)
name|struct
name|token_accumulator
modifier|*
name|accumulator
decl_stmt|;
block|{
name|accumulator
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|accumulator
operator|->
name|index
operator|=
literal|0
expr_stmt|;
name|accumulator
operator|->
name|tokens
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|accumulate_token
parameter_list|(
name|accumulator
parameter_list|,
name|token
parameter_list|)
name|struct
name|token_accumulator
modifier|*
name|accumulator
decl_stmt|;
name|char
modifier|*
name|token
decl_stmt|;
block|{
if|if
condition|(
name|accumulator
operator|->
name|index
operator|>=
name|accumulator
operator|->
name|length
condition|)
block|{
name|accumulator
operator|->
name|length
operator|+=
literal|10
expr_stmt|;
name|accumulator
operator|->
name|tokens
operator|=
name|xrealloc
argument_list|(
name|accumulator
operator|->
name|tokens
argument_list|,
operator|(
name|accumulator
operator|->
name|length
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|accumulator
operator|->
name|tokens
index|[
name|accumulator
operator|->
name|index
index|]
operator|=
name|token
expr_stmt|;
name|accumulator
operator|->
name|index
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given STRING_POINTER pointing at an open brace, skip forward and return a    pointer to just past the matching close brace. */
end_comment

begin_function
specifier|static
name|int
name|scan_group_in_string
parameter_list|(
name|string_pointer
parameter_list|)
name|char
modifier|*
modifier|*
name|string_pointer
decl_stmt|;
block|{
name|char
modifier|*
name|scan_string
init|=
operator|(
operator|*
name|string_pointer
operator|)
operator|+
literal|1
decl_stmt|;
name|unsigned
name|int
name|level
init|=
literal|1
decl_stmt|;
name|int
name|started_command
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
operator|*
name|string_pointer
operator|=
name|scan_string
expr_stmt|;
return|return
literal|1
return|;
block|}
name|c
operator|=
operator|*
name|scan_string
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
comment|/* Tweak line_number to compensate for fact that              we gobbled the whole line before coming here. */
name|line_number
operator|--
expr_stmt|;
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Missing `}' in @def arg"
argument_list|)
argument_list|)
expr_stmt|;
name|line_number
operator|++
expr_stmt|;
operator|*
name|string_pointer
operator|=
name|scan_string
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'{'
operator|&&
operator|!
name|started_command
condition|)
name|level
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'}'
operator|&&
operator|!
name|started_command
condition|)
name|level
operator|--
expr_stmt|;
comment|/* remember if at @.  */
name|started_command
operator|=
operator|(
name|c
operator|==
literal|'@'
operator|&&
operator|!
name|started_command
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a list of tokens from the contents of STRING.    Commands and brace-delimited groups count as single tokens.    Contiguous whitespace characters are converted to a token    consisting of a single space. */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|args_from_string
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|token_accumulator
name|accumulator
decl_stmt|;
name|char
modifier|*
name|token_start
decl_stmt|,
modifier|*
name|token_end
decl_stmt|;
name|char
modifier|*
name|scan_string
init|=
name|string
decl_stmt|;
name|initialize_token_accumulator
argument_list|(
operator|&
name|accumulator
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|scan_string
condition|)
block|{
comment|/* Replace arbitrary whitespace by a single space. */
if|if
condition|(
name|whitespace
argument_list|(
operator|*
name|scan_string
argument_list|)
condition|)
block|{
name|scan_string
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
name|whitespace
argument_list|(
operator|*
name|scan_string
argument_list|)
condition|)
name|scan_string
operator|+=
literal|1
expr_stmt|;
name|accumulate_token
argument_list|(
operator|(
operator|&
name|accumulator
operator|)
argument_list|,
operator|(
name|xstrdup
argument_list|(
literal|" "
argument_list|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Commands count as single tokens. */
if|if
condition|(
operator|*
name|scan_string
operator|==
name|COMMAND_PREFIX
condition|)
block|{
name|token_start
operator|=
name|scan_string
expr_stmt|;
name|scan_string
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|self_delimiting
argument_list|(
operator|*
name|scan_string
argument_list|)
condition|)
name|scan_string
operator|+=
literal|1
expr_stmt|;
else|else
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
operator|*
name|scan_string
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|0
operator|)
operator|||
operator|(
name|c
operator|==
literal|'{'
operator|)
operator|||
operator|(
name|whitespace
argument_list|(
name|c
argument_list|)
operator|)
condition|)
block|{
name|scan_string
operator|-=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|scan_string
operator|==
literal|'{'
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|scan_string
decl_stmt|;
operator|(
name|void
operator|)
name|scan_group_in_string
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|scan_string
operator|=
name|s
expr_stmt|;
block|}
block|}
name|token_end
operator|=
name|scan_string
expr_stmt|;
block|}
comment|/* Parentheses and brackets are self-delimiting. */
elseif|else
if|if
condition|(
name|DEFUN_SELF_DELIMITING
argument_list|(
operator|*
name|scan_string
argument_list|)
condition|)
block|{
name|token_start
operator|=
name|scan_string
expr_stmt|;
name|scan_string
operator|+=
literal|1
expr_stmt|;
name|token_end
operator|=
name|scan_string
expr_stmt|;
block|}
comment|/* Open brace introduces a group that is a single token. */
elseif|else
if|if
condition|(
operator|*
name|scan_string
operator|==
literal|'{'
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|scan_string
decl_stmt|;
name|int
name|balanced
init|=
name|scan_group_in_string
argument_list|(
operator|&
name|s
argument_list|)
decl_stmt|;
name|token_start
operator|=
name|scan_string
operator|+
literal|1
expr_stmt|;
name|scan_string
operator|=
name|s
expr_stmt|;
name|token_end
operator|=
name|balanced
condition|?
operator|(
name|scan_string
operator|-
literal|1
operator|)
else|:
name|scan_string
expr_stmt|;
block|}
comment|/* Otherwise a token is delimited by whitespace, parentheses,          brackets, or braces.  A token is also ended by a command. */
else|else
block|{
name|token_start
operator|=
name|scan_string
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|scan_string
operator|++
expr_stmt|;
comment|/* Do not back up if we're looking at a }; since the only                  valid }'s are those matched with {'s, we want to give                  an error.  If we back up, we go into an infinite loop.  */
if|if
condition|(
operator|!
name|c
operator|||
name|whitespace
argument_list|(
name|c
argument_list|)
operator|||
name|DEFUN_SELF_DELIMITING
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'{'
condition|)
block|{
name|scan_string
operator|--
expr_stmt|;
break|break;
block|}
comment|/* If we encounter a command embedded within a token,                  then end the token. */
if|if
condition|(
name|c
operator|==
name|COMMAND_PREFIX
condition|)
block|{
name|scan_string
operator|--
expr_stmt|;
break|break;
block|}
block|}
name|token_end
operator|=
name|scan_string
expr_stmt|;
block|}
name|accumulate_token
argument_list|(
operator|&
name|accumulator
argument_list|,
name|substring
argument_list|(
name|token_start
argument_list|,
name|token_end
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|accumulate_token
argument_list|(
operator|&
name|accumulator
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|accumulator
operator|.
name|tokens
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_defun_args
parameter_list|(
name|defun_args
parameter_list|,
name|auto_var_p
parameter_list|)
name|char
modifier|*
modifier|*
name|defun_args
decl_stmt|;
name|int
name|auto_var_p
decl_stmt|;
block|{
name|int
name|pending_space
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|defun_arg
init|=
operator|*
name|defun_args
operator|++
decl_stmt|;
if|if
condition|(
name|defun_arg
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|defun_arg
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
block|{
name|pending_space
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pending_space
condition|)
block|{
name|add_char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|pending_space
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|DEFUN_SELF_DELIMITING
argument_list|(
name|defun_arg
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* Within @deffn and friends, texinfo.tex makes parentheses              sans serif and brackets bold.  We use roman instead.  */
name|insert_html_tag
argument_list|(
name|START
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|add_char
argument_list|(
name|defun_arg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|insert_html_tag
argument_list|(
name|END
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|defun_arg
index|[
literal|0
index|]
operator|==
literal|'&'
condition|)
if|if
condition|(
name|html
condition|)
block|{
name|defun_arg
operator|=
name|escape_string
argument_list|(
name|xstrdup
argument_list|(
name|defun_arg
argument_list|)
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
name|defun_arg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|defun_arg
argument_list|)
expr_stmt|;
block|}
else|else
name|add_word
argument_list|(
name|defun_arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|defun_arg
index|[
literal|0
index|]
operator|==
name|COMMAND_PREFIX
condition|)
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|defun_arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|auto_var_p
condition|)
if|if
condition|(
name|html
condition|)
block|{
name|defun_arg
operator|=
name|escape_string
argument_list|(
name|xstrdup
argument_list|(
name|defun_arg
argument_list|)
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
name|defun_arg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|defun_arg
argument_list|)
expr_stmt|;
block|}
else|else
name|add_word
argument_list|(
name|defun_arg
argument_list|)
expr_stmt|;
else|else
name|add_word
argument_list|(
name|defun_arg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|next_nonwhite_defun_arg
parameter_list|(
name|arg_pointer
parameter_list|)
name|char
modifier|*
modifier|*
modifier|*
name|arg_pointer
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|scan
init|=
operator|(
operator|*
name|arg_pointer
operator|)
decl_stmt|;
name|char
modifier|*
name|arg
init|=
operator|(
operator|*
name|scan
operator|++
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|arg
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|*
name|arg
operator|==
literal|' '
operator|)
condition|)
name|arg
operator|=
operator|*
name|scan
operator|++
expr_stmt|;
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
name|scan
operator|-=
literal|1
expr_stmt|;
operator|*
name|arg_pointer
operator|=
name|scan
expr_stmt|;
return|return
operator|(
name|arg
operator|==
literal|0
operator|)
condition|?
literal|""
else|:
name|arg
return|;
block|}
end_function

begin_comment
comment|/* This is needed also in insertion.c.  */
end_comment

begin_function
name|enum
name|insertion_type
name|get_base_type
parameter_list|(
name|type
parameter_list|)
name|enum
name|insertion_type
name|type
decl_stmt|;
block|{
name|enum
name|insertion_type
name|base_type
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|defivar
case|:
name|base_type
operator|=
name|defcv
expr_stmt|;
break|break;
case|case
name|defmac
case|:
name|base_type
operator|=
name|deffn
expr_stmt|;
break|break;
case|case
name|defmethod
case|:
name|base_type
operator|=
name|defop
expr_stmt|;
break|break;
case|case
name|defopt
case|:
name|base_type
operator|=
name|defvr
expr_stmt|;
break|break;
case|case
name|defspec
case|:
name|base_type
operator|=
name|deffn
expr_stmt|;
break|break;
case|case
name|deftypefun
case|:
name|base_type
operator|=
name|deftypefn
expr_stmt|;
break|break;
case|case
name|deftypeivar
case|:
name|base_type
operator|=
name|deftypeivar
expr_stmt|;
break|break;
case|case
name|deftypemethod
case|:
name|base_type
operator|=
name|deftypemethod
expr_stmt|;
break|break;
case|case
name|deftypeop
case|:
name|base_type
operator|=
name|deftypeop
expr_stmt|;
break|break;
case|case
name|deftypevar
case|:
name|base_type
operator|=
name|deftypevr
expr_stmt|;
break|break;
case|case
name|defun
case|:
name|base_type
operator|=
name|deffn
expr_stmt|;
break|break;
case|case
name|defvar
case|:
name|base_type
operator|=
name|defvr
expr_stmt|;
break|break;
default|default:
name|base_type
operator|=
name|type
expr_stmt|;
break|break;
block|}
return|return
name|base_type
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make the defun type insertion.    TYPE says which insertion this is.    X_P, if nonzero, says not to start a new insertion. */
end_comment

begin_function
specifier|static
name|void
name|defun_internal
parameter_list|(
name|type
parameter_list|,
name|x_p
parameter_list|)
name|enum
name|insertion_type
name|type
decl_stmt|;
name|int
name|x_p
decl_stmt|;
block|{
name|enum
name|insertion_type
name|base_type
decl_stmt|;
name|char
modifier|*
modifier|*
name|defun_args
decl_stmt|,
modifier|*
modifier|*
name|scan_args
decl_stmt|;
name|char
modifier|*
name|category
decl_stmt|,
modifier|*
name|defined_name
decl_stmt|,
modifier|*
name|type_name
decl_stmt|,
modifier|*
name|type_name2
decl_stmt|;
block|{
name|char
modifier|*
name|line
decl_stmt|;
comment|/* The @def.. line is the only place in Texinfo where you are        allowed to use unquoted braces that don't delimit arguments of        a command or a macro; in any other place it will trigger an        error message from the reader loop.  The special handling of        this case inside `args_from_string' is an extra special hack        which allows this.  The side effect is that if we try to expand        the rest of the line below, the recursive reader loop will        signal an error if there are brace-delimited arguments on that line.         The best solution to this would be to change the syntax of        @def.. commands so that it doesn't violate Texinfo's own rules.        But it's probably too late for this now, as it will break a lot        of existing manuals.         Unfortunately, this means that you can't call macros, use @value, etc.        inside @def.. commands, sigh.  */
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|defun_args
operator|=
operator|(
name|args_from_string
argument_list|(
name|line
argument_list|)
operator|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|scan_args
operator|=
name|defun_args
expr_stmt|;
comment|/* Get base type and category string.  */
name|base_type
operator|=
name|get_base_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* xx all these const strings should be determined upon      documentlanguage argument and NOT via gettext  (kama).  */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|defun
case|:
case|case
name|deftypefun
case|:
name|category
operator|=
name|_
argument_list|(
literal|"Function"
argument_list|)
expr_stmt|;
break|break;
case|case
name|defmac
case|:
name|category
operator|=
name|_
argument_list|(
literal|"Macro"
argument_list|)
expr_stmt|;
break|break;
case|case
name|defspec
case|:
name|category
operator|=
name|_
argument_list|(
literal|"Special Form"
argument_list|)
expr_stmt|;
break|break;
case|case
name|defvar
case|:
case|case
name|deftypevar
case|:
name|category
operator|=
name|_
argument_list|(
literal|"Variable"
argument_list|)
expr_stmt|;
break|break;
case|case
name|defopt
case|:
name|category
operator|=
name|_
argument_list|(
literal|"User Option"
argument_list|)
expr_stmt|;
break|break;
case|case
name|defivar
case|:
case|case
name|deftypeivar
case|:
name|category
operator|=
name|_
argument_list|(
literal|"Instance Variable"
argument_list|)
expr_stmt|;
break|break;
case|case
name|defmethod
case|:
case|case
name|deftypemethod
case|:
name|category
operator|=
name|_
argument_list|(
literal|"Method"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|category
operator|=
name|next_nonwhite_defun_arg
argument_list|(
operator|&
name|scan_args
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* The class name.  */
if|if
condition|(
operator|(
name|base_type
operator|==
name|deftypefn
operator|)
operator|||
operator|(
name|base_type
operator|==
name|deftypevr
operator|)
operator|||
operator|(
name|base_type
operator|==
name|defcv
operator|)
operator|||
operator|(
name|base_type
operator|==
name|defop
operator|)
operator|||
operator|(
name|base_type
operator|==
name|deftypeivar
operator|)
operator|||
operator|(
name|base_type
operator|==
name|deftypemethod
operator|)
operator|||
operator|(
name|base_type
operator|==
name|deftypeop
operator|)
condition|)
name|type_name
operator|=
name|next_nonwhite_defun_arg
argument_list|(
operator|&
name|scan_args
argument_list|)
expr_stmt|;
comment|/* The type name for typed languages.  */
if|if
condition|(
operator|(
name|base_type
operator|==
name|deftypemethod
operator|)
operator|||
operator|(
name|base_type
operator|==
name|deftypeivar
operator|)
operator|||
operator|(
name|base_type
operator|==
name|deftypeop
operator|)
condition|)
name|type_name2
operator|=
name|next_nonwhite_defun_arg
argument_list|(
operator|&
name|scan_args
argument_list|)
expr_stmt|;
comment|/* The function or whatever that's actually being defined.  */
name|defined_name
operator|=
name|next_nonwhite_defun_arg
argument_list|(
operator|&
name|scan_args
argument_list|)
expr_stmt|;
comment|/* This hack exists solely for the purposes of formatting the Texinfo      manual.  I couldn't think of a better way.  The token might be a      simple @@ followed immediately by more text.  If this is the case,      then the next defun arg is part of this one, and we should      concatenate them. */
if|if
condition|(
operator|*
name|scan_args
operator|&&
operator|*
operator|*
name|scan_args
operator|&&
operator|!
name|whitespace
argument_list|(
operator|*
operator|*
name|scan_args
argument_list|)
operator|&&
name|STREQ
argument_list|(
name|defined_name
argument_list|,
literal|"@@"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|tem
init|=
name|xmalloc
argument_list|(
literal|3
operator|+
name|strlen
argument_list|(
name|scan_args
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|tem
argument_list|,
literal|"@@%s"
argument_list|,
name|scan_args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scan_args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|scan_args
index|[
literal|0
index|]
operator|=
name|tem
expr_stmt|;
name|scan_args
operator|++
expr_stmt|;
name|defined_name
operator|=
name|tem
expr_stmt|;
block|}
comment|/* It's easy to write @defun foo(arg1 arg2), but a following ( is      misparsed by texinfo.tex and this is next to impossible to fix.      Warn about it.  */
if|if
condition|(
operator|*
name|scan_args
operator|&&
operator|*
operator|*
name|scan_args
operator|&&
operator|*
operator|*
name|scan_args
operator|==
literal|'('
condition|)
name|warning
argument_list|(
literal|"`%c' follows defined name `%s' instead of whitespace"
argument_list|,
operator|*
operator|*
name|scan_args
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x_p
condition|)
name|begin_insertion
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Write the definition header line.      This should start at the normal indentation.  */
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
name|start_paragraph
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|x_p
condition|)
block|{
comment|/* Start the definition on new paragraph.  */
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"<p>\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|html
operator|&&
operator|!
name|docbook
condition|)
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|deffn
case|:
case|case
name|defvr
case|:
case|case
name|deftp
case|:
name|execute_string
argument_list|(
literal|" -- %s: %s"
argument_list|,
name|category
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|deftypefn
case|:
case|case
name|deftypevr
case|:
name|execute_string
argument_list|(
literal|" -- %s: %s %s"
argument_list|,
name|category
argument_list|,
name|type_name
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|defcv
case|:
name|execute_string
argument_list|(
literal|" -- %s %s %s: %s"
argument_list|,
name|category
argument_list|,
name|_
argument_list|(
literal|"of"
argument_list|)
argument_list|,
name|type_name
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|deftypeivar
case|:
name|execute_string
argument_list|(
literal|" -- %s %s %s: %s %s"
argument_list|,
name|category
argument_list|,
name|_
argument_list|(
literal|"of"
argument_list|)
argument_list|,
name|type_name
argument_list|,
name|type_name2
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|defop
case|:
name|execute_string
argument_list|(
literal|" -- %s %s %s: %s"
argument_list|,
name|category
argument_list|,
name|_
argument_list|(
literal|"on"
argument_list|)
argument_list|,
name|type_name
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|deftypeop
case|:
name|execute_string
argument_list|(
literal|" -- %s %s %s: %s %s"
argument_list|,
name|category
argument_list|,
name|_
argument_list|(
literal|"on"
argument_list|)
argument_list|,
name|type_name
argument_list|,
name|type_name2
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|deftypemethod
case|:
name|execute_string
argument_list|(
literal|" -- %s %s %s: %s %s"
argument_list|,
name|category
argument_list|,
name|_
argument_list|(
literal|"on"
argument_list|)
argument_list|,
name|type_name
argument_list|,
name|type_name2
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|html
condition|)
block|{
comment|/* If this is not a @def...x version, it could only          be a normal version @def.... So start the table here.  */
if|if
condition|(
operator|!
name|x_p
condition|)
block|{
name|add_html_elt
argument_list|(
literal|"<table width="
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"\"100%\">\n"
argument_list|)
expr_stmt|;
block|}
comment|/* If this is an @def...x there has to be an other @def... before          it, so this is only a new row within an existing table.  With          two complete standalone tables the gap between them is too big.  */
name|add_word
argument_list|(
literal|"<tr>\n"
argument_list|)
expr_stmt|;
name|add_html_elt
argument_list|(
literal|"<td align=\"left\">"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|deffn
case|:
case|case
name|defvr
case|:
case|case
name|deftp
case|:
comment|/*<i> is for the following function arguments.  */
name|insert_html_tag
argument_list|(
name|START
argument_list|,
literal|"b"
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
name|insert_html_tag
argument_list|(
name|END
argument_list|,
literal|"b"
argument_list|)
expr_stmt|;
name|insert_html_tag
argument_list|(
name|START
argument_list|,
literal|"i"
argument_list|)
expr_stmt|;
break|break;
case|case
name|deftypefn
case|:
case|case
name|deftypevr
case|:
name|execute_string
argument_list|(
literal|"%s "
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
name|insert_html_tag
argument_list|(
name|START
argument_list|,
literal|"b"
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
name|insert_html_tag
argument_list|(
name|END
argument_list|,
literal|"b"
argument_list|)
expr_stmt|;
name|insert_html_tag
argument_list|(
name|START
argument_list|,
literal|"i"
argument_list|)
expr_stmt|;
break|break;
case|case
name|defcv
case|:
case|case
name|defop
case|:
name|insert_html_tag
argument_list|(
name|START
argument_list|,
literal|"b"
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
name|insert_html_tag
argument_list|(
name|END
argument_list|,
literal|"b"
argument_list|)
expr_stmt|;
name|insert_html_tag
argument_list|(
name|START
argument_list|,
literal|"i"
argument_list|)
expr_stmt|;
break|break;
case|case
name|deftypemethod
case|:
case|case
name|deftypeop
case|:
case|case
name|deftypeivar
case|:
name|execute_string
argument_list|(
literal|"%s "
argument_list|,
name|type_name2
argument_list|)
expr_stmt|;
name|insert_html_tag
argument_list|(
name|START
argument_list|,
literal|"b"
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
name|insert_html_tag
argument_list|(
name|END
argument_list|,
literal|"b"
argument_list|)
expr_stmt|;
name|insert_html_tag
argument_list|(
name|START
argument_list|,
literal|"i"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* if (html)... */
if|if
condition|(
name|docbook
condition|)
block|{
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|deffn
case|:
case|case
name|defvr
case|:
case|case
name|deftp
case|:
case|case
name|defcv
case|:
case|case
name|defop
case|:
name|xml_insert_element
argument_list|(
name|FUNCTION
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|FUNCTION
argument_list|,
name|END
argument_list|)
expr_stmt|;
break|break;
case|case
name|deftypefn
case|:
case|case
name|deftypevr
case|:
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|FUNCTION
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|FUNCTION
argument_list|,
name|END
argument_list|)
expr_stmt|;
break|break;
case|case
name|deftypemethod
case|:
case|case
name|deftypeop
case|:
case|case
name|deftypeivar
case|:
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|type_name2
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|FUNCTION
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|FUNCTION
argument_list|,
name|END
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* if (docbook)... */
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
comment|/* Now process the function arguments, if any.  If these carry onto      the next line, they should be indented by two increments to      distinguish them from the body of the definition, which is indented      by one increment.  */
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|deffn
case|:
case|case
name|defop
case|:
name|process_defun_args
argument_list|(
name|scan_args
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
comment|/* Through Makeinfo 1.67 we processed remaining args only for deftp,          deftypefn, and deftypemethod.  But the libc manual, for example,          needs to say:             @deftypevar {char *} tzname[2]          And simply allowing the extra text seems far simpler than trying          to invent yet more defn commands.  In any case, we should either          output it or give an error, not silently ignore it.  */
default|default:
name|process_defun_args
argument_list|(
name|scan_args
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
name|close_single_paragraph
argument_list|()
expr_stmt|;
if|if
condition|(
name|html
condition|)
block|{
comment|/* xx The single words (on, off) used here, should depend on          documentlanguage and NOT on gettext  --kama.  */
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|deffn
case|:
case|case
name|defvr
case|:
case|case
name|deftp
case|:
case|case
name|deftypefn
case|:
case|case
name|deftypevr
case|:
name|insert_html_tag
argument_list|(
name|END
argument_list|,
literal|"i"
argument_list|)
expr_stmt|;
comment|/* close italic area for arguments */
comment|/* put the rest into the second column */
name|add_word
argument_list|(
literal|"</td>\n"
argument_list|)
expr_stmt|;
name|add_html_elt
argument_list|(
literal|"<td align=\"right\">"
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|category
argument_list|)
expr_stmt|;
break|break;
case|case
name|defcv
case|:
name|add_word
argument_list|(
literal|"</td>\n"
argument_list|)
expr_stmt|;
name|add_html_elt
argument_list|(
literal|"<td align=\"right\">"
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s %s %s"
argument_list|,
name|category
argument_list|,
name|_
argument_list|(
literal|"of"
argument_list|)
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|defop
case|:
case|case
name|deftypemethod
case|:
case|case
name|deftypeop
case|:
name|insert_html_tag
argument_list|(
name|END
argument_list|,
literal|"i"
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"</td>\n"
argument_list|)
expr_stmt|;
name|add_html_elt
argument_list|(
literal|"<td align=\"right\">"
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s %s %s"
argument_list|,
name|category
argument_list|,
name|_
argument_list|(
literal|"on"
argument_list|)
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|deftypeivar
case|:
name|insert_html_tag
argument_list|(
name|END
argument_list|,
literal|"i"
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"</td>\n"
argument_list|)
expr_stmt|;
name|add_html_elt
argument_list|(
literal|"<td align=\"right\">"
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s %s %s"
argument_list|,
name|category
argument_list|,
name|_
argument_list|(
literal|"of"
argument_list|)
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch (base_type)... */
name|add_word
argument_list|(
literal|"</td>\n"
argument_list|)
expr_stmt|;
comment|/* close second column */
name|add_word
argument_list|(
literal|"</tr>\n"
argument_list|)
expr_stmt|;
comment|/* close row */
comment|/* This is needed because I have to know if the next line is          normal text or another @def..x.  If text follows, create a new          table to get the indentation for the following text.           This construction would fail if someone uses:           @deffn           @sp 2           @deffnx           .           @end deffn          But we don't care. */
if|if
condition|(
operator|!
name|looking_at
argument_list|(
literal|"@def"
argument_list|)
condition|)
block|{
name|add_word
argument_list|(
literal|"</table>\n"
argument_list|)
expr_stmt|;
name|add_html_elt
argument_list|(
literal|"<table width=\"95%\" align=\"center\">"
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"\n<tr><td>\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if (html)... */
comment|/* Make an entry in the appropriate index. */
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|deffn
case|:
case|case
name|deftypefn
case|:
name|execute_string
argument_list|(
literal|"@findex %s\n"
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|defvr
case|:
case|case
name|deftypevr
case|:
case|case
name|defcv
case|:
name|execute_string
argument_list|(
literal|"@vindex %s\n"
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|deftypeivar
case|:
name|execute_string
argument_list|(
literal|"@vindex %s %s %s\n"
argument_list|,
name|defined_name
argument_list|,
name|_
argument_list|(
literal|"of"
argument_list|)
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|defop
case|:
case|case
name|deftypeop
case|:
case|case
name|deftypemethod
case|:
name|execute_string
argument_list|(
literal|"@findex %s %s %s\n"
argument_list|,
name|defined_name
argument_list|,
name|_
argument_list|(
literal|"on"
argument_list|)
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|deftp
case|:
name|execute_string
argument_list|(
literal|"@tindex %s\n"
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Deallocate the token list. */
name|scan_args
operator|=
name|defun_args
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|arg
init|=
operator|(
operator|*
name|scan_args
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
break|break;
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|defun_args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an entry for a function, macro, special form, variable, or option.    If the name of the calling command ends in `x', then this is an extra    entry included in the body of an insertion of the same type. */
end_comment

begin_function
name|void
name|cm_defun
parameter_list|()
block|{
name|int
name|x_p
decl_stmt|;
name|enum
name|insertion_type
name|type
decl_stmt|;
name|char
modifier|*
name|temp
init|=
name|xstrdup
argument_list|(
name|command
argument_list|)
decl_stmt|;
name|x_p
operator|=
operator|(
name|command
index|[
name|strlen
argument_list|(
name|command
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'x'
operator|)
expr_stmt|;
if|if
condition|(
name|x_p
condition|)
name|temp
index|[
name|strlen
argument_list|(
name|temp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|find_type_from_name
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* If we are adding to an already existing insertion, then make sure      that we are already in an insertion of type TYPE. */
if|if
condition|(
name|x_p
operator|&&
operator|(
operator|!
name|insertion_level
operator|||
name|insertion_stack
operator|->
name|insertion
operator|!=
name|type
operator|)
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Must be in `%s' insertion to use `%sx'"
argument_list|)
argument_list|,
name|command
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|defun_internal
argument_list|(
name|type
argument_list|,
name|x_p
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

