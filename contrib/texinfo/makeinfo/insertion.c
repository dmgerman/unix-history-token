begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* insertion.c -- insertions for Texinfo.    $Id: insertion.c,v 1.27 1999/07/06 23:12:53 karl Exp $     Copyright (C) 1998, 99 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cmds.h"
end_include

begin_include
include|#
directive|include
file|"defun.h"
end_include

begin_include
include|#
directive|include
file|"insertion.h"
end_include

begin_include
include|#
directive|include
file|"macro.h"
end_include

begin_include
include|#
directive|include
file|"makeinfo.h"
end_include

begin_comment
comment|/* Must match list in insertion.h.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|insertion_type_names
index|[]
init|=
block|{
literal|"cartouche"
block|,
literal|"defcv"
block|,
literal|"deffn"
block|,
literal|"defivar"
block|,
literal|"defmac"
block|,
literal|"defmethod"
block|,
literal|"defop"
block|,
literal|"defopt"
block|,
literal|"defspec"
block|,
literal|"deftp"
block|,
literal|"deftypefn"
block|,
literal|"deftypefun"
block|,
literal|"deftypeivar"
block|,
literal|"deftypemethod"
block|,
literal|"deftypeop"
block|,
literal|"deftypevar"
block|,
literal|"deftypevr"
block|,
literal|"defun"
block|,
literal|"defvar"
block|,
literal|"defvr"
block|,
literal|"detailmenu"
block|,
literal|"direntry"
block|,
literal|"display"
block|,
literal|"enumerate"
block|,
literal|"example"
block|,
literal|"flushleft"
block|,
literal|"flushright"
block|,
literal|"format"
block|,
literal|"ftable"
block|,
literal|"group"
block|,
literal|"ifclear"
block|,
literal|"ifhtml"
block|,
literal|"ifinfo"
block|,
literal|"ifnothtml"
block|,
literal|"ifnotinfo"
block|,
literal|"ifnottex"
block|,
literal|"ifset"
block|,
literal|"iftex"
block|,
literal|"itemize"
block|,
literal|"lisp"
block|,
literal|"menu"
block|,
literal|"multitable"
block|,
literal|"quotation"
block|,
literal|"rawhtml"
block|,
literal|"rawtex"
block|,
literal|"smalldisplay"
block|,
literal|"smallexample"
block|,
literal|"smallformat"
block|,
literal|"smalllisp"
block|,
literal|"table"
block|,
literal|"tex"
block|,
literal|"vtable"
block|,
literal|"bad_type"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All nested environments.  */
end_comment

begin_decl_stmt
name|INSERTION_ELT
modifier|*
name|insertion_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How deeply we're nested.  */
end_comment

begin_decl_stmt
name|int
name|insertion_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to examine menu lines.  */
end_comment

begin_decl_stmt
name|int
name|in_menu
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to examine menu lines.  */
end_comment

begin_decl_stmt
name|int
name|in_detailmenu
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 1 if we've processed (commentary) text in a @menu that    wasn't part of a menu item.  */
end_comment

begin_decl_stmt
name|int
name|had_menu_commentary
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 1 if<p> is written in normal context.     Used for menu and itemize. */
end_comment

begin_decl_stmt
name|int
name|in_paragraph
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|dl_tag
index|[]
init|=
literal|"<dl>\n"
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|init_insertion_stack
parameter_list|()
block|{
name|insertion_stack
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the type of the current insertion. */
end_comment

begin_function
specifier|static
name|enum
name|insertion_type
name|current_insertion_type
parameter_list|()
block|{
return|return
name|insertion_level
condition|?
name|insertion_stack
operator|->
name|insertion
else|:
name|bad_type
return|;
block|}
end_function

begin_comment
comment|/* Return the string which is the function to wrap around items, or NULL    if we're not in an environment where @item is ok.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|current_item_function
parameter_list|()
block|{
name|int
name|done
init|=
literal|0
decl_stmt|;
name|INSERTION_ELT
modifier|*
name|elt
init|=
name|insertion_stack
decl_stmt|;
comment|/* Skip down through the stack until we find an insertion with an      itemize function defined, i.e., skip conditionals, @cartouche, etc.  */
while|while
condition|(
operator|!
name|done
operator|&&
name|elt
condition|)
block|{
switch|switch
condition|(
name|elt
operator|->
name|insertion
condition|)
block|{
comment|/* This list should match the one in cm_item.  */
case|case
name|ifclear
case|:
case|case
name|ifhtml
case|:
case|case
name|ifinfo
case|:
case|case
name|ifnothtml
case|:
case|case
name|ifnotinfo
case|:
case|case
name|ifnottex
case|:
case|case
name|ifset
case|:
case|case
name|iftex
case|:
case|case
name|rawhtml
case|:
case|case
name|rawtex
case|:
case|case
name|tex
case|:
case|case
name|cartouche
case|:
name|elt
operator|=
name|elt
operator|->
name|next
expr_stmt|;
break|break;
default|default:
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* item_function usually gets assigned the empty string.  */
return|return
name|done
operator|&&
operator|(
operator|*
name|elt
operator|->
name|item_function
operator|)
condition|?
name|elt
operator|->
name|item_function
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Parse the item marker function off the input.  If result is just "@",    change it to "@ ", since "@" by itself is not a command.  This makes    "@ ", "@\t", and "@\n" all the same, but their default meanings are    the same anyway, and let's not worry about supporting redefining them.  */
end_comment

begin_function
name|char
modifier|*
name|get_item_function
parameter_list|()
block|{
name|char
modifier|*
name|item_function
decl_stmt|;
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|item_function
argument_list|)
expr_stmt|;
comment|/* If we hit the end of text in get_rest_of_line, backing up      input pointer will cause the last character of the last line      be pushed back onto the input, which is wrong.  */
if|if
condition|(
name|input_text_offset
operator|<
name|input_text_length
condition|)
name|backup_input_pointer
argument_list|()
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|item_function
argument_list|,
literal|"@"
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|item_function
argument_list|)
expr_stmt|;
name|item_function
operator|=
name|xstrdup
argument_list|(
literal|"@ "
argument_list|)
expr_stmt|;
block|}
return|return
name|item_function
return|;
block|}
end_function

begin_comment
comment|/* Push the state of the current insertion on the stack. */
end_comment

begin_function
name|void
name|push_insertion
parameter_list|(
name|type
parameter_list|,
name|item_function
parameter_list|)
name|enum
name|insertion_type
name|type
decl_stmt|;
name|char
modifier|*
name|item_function
decl_stmt|;
block|{
name|INSERTION_ELT
modifier|*
name|new
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|INSERTION_ELT
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|item_function
operator|=
name|item_function
expr_stmt|;
name|new
operator|->
name|filling_enabled
operator|=
name|filling_enabled
expr_stmt|;
name|new
operator|->
name|indented_fill
operator|=
name|indented_fill
expr_stmt|;
name|new
operator|->
name|insertion
operator|=
name|type
expr_stmt|;
name|new
operator|->
name|line_number
operator|=
name|line_number
expr_stmt|;
name|new
operator|->
name|filename
operator|=
name|xstrdup
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|new
operator|->
name|inhibited
operator|=
name|inhibit_paragraph_indentation
expr_stmt|;
name|new
operator|->
name|in_fixed_width_font
operator|=
name|in_fixed_width_font
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|insertion_stack
expr_stmt|;
name|insertion_stack
operator|=
name|new
expr_stmt|;
name|insertion_level
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop the value on top of the insertion stack into the     global variables. */
end_comment

begin_function
name|void
name|pop_insertion
parameter_list|()
block|{
name|INSERTION_ELT
modifier|*
name|temp
init|=
name|insertion_stack
decl_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
return|return;
name|in_fixed_width_font
operator|=
name|temp
operator|->
name|in_fixed_width_font
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
name|temp
operator|->
name|inhibited
expr_stmt|;
name|filling_enabled
operator|=
name|temp
operator|->
name|filling_enabled
expr_stmt|;
name|indented_fill
operator|=
name|temp
operator|->
name|indented_fill
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
operator|(
name|temp
operator|->
name|item_function
operator|)
argument_list|)
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
operator|(
name|temp
operator|->
name|filename
operator|)
argument_list|)
expr_stmt|;
name|insertion_stack
operator|=
name|insertion_stack
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|insertion_level
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the print name of this     enumerated type. */
end_comment

begin_function
name|char
modifier|*
name|insertion_type_pname
parameter_list|(
name|type
parameter_list|)
name|enum
name|insertion_type
name|type
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|type
operator|<
operator|(
name|int
operator|)
name|bad_type
condition|)
return|return
name|insertion_type_names
index|[
operator|(
name|int
operator|)
name|type
index|]
return|;
else|else
return|return
name|_
argument_list|(
literal|"Broken-Type in insertion_type_pname"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the insertion_type associated with NAME.    If the type is not one of the known ones, return BAD_TYPE. */
end_comment

begin_function
name|enum
name|insertion_type
name|find_type_from_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|index
operator|<
operator|(
name|int
operator|)
name|bad_type
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
name|insertion_type_names
index|[
name|index
index|]
argument_list|)
condition|)
return|return
operator|(
expr|enum
name|insertion_type
operator|)
name|index
return|;
if|if
condition|(
name|index
operator|==
name|rawhtml
operator|&&
name|STREQ
argument_list|(
name|name
argument_list|,
literal|"html"
argument_list|)
condition|)
return|return
name|rawhtml
return|;
if|if
condition|(
name|index
operator|==
name|rawtex
operator|&&
name|STREQ
argument_list|(
name|name
argument_list|,
literal|"tex"
argument_list|)
condition|)
return|return
name|rawtex
return|;
name|index
operator|++
expr_stmt|;
block|}
return|return
name|bad_type
return|;
block|}
end_function

begin_function
name|int
name|defun_insertion
parameter_list|(
name|type
parameter_list|)
name|enum
name|insertion_type
name|type
decl_stmt|;
block|{
return|return
literal|0
operator|||
operator|(
name|type
operator|==
name|defcv
operator|)
operator|||
operator|(
name|type
operator|==
name|deffn
operator|)
operator|||
operator|(
name|type
operator|==
name|defivar
operator|)
operator|||
operator|(
name|type
operator|==
name|defmac
operator|)
operator|||
operator|(
name|type
operator|==
name|defmethod
operator|)
operator|||
operator|(
name|type
operator|==
name|defop
operator|)
operator|||
operator|(
name|type
operator|==
name|defopt
operator|)
operator|||
operator|(
name|type
operator|==
name|defspec
operator|)
operator|||
operator|(
name|type
operator|==
name|deftp
operator|)
operator|||
operator|(
name|type
operator|==
name|deftypefn
operator|)
operator|||
operator|(
name|type
operator|==
name|deftypefun
operator|)
operator|||
operator|(
name|type
operator|==
name|deftypeivar
operator|)
operator|||
operator|(
name|type
operator|==
name|deftypemethod
operator|)
operator|||
operator|(
name|type
operator|==
name|deftypeop
operator|)
operator|||
operator|(
name|type
operator|==
name|deftypevar
operator|)
operator|||
operator|(
name|type
operator|==
name|deftypevr
operator|)
operator|||
operator|(
name|type
operator|==
name|defun
operator|)
operator|||
operator|(
name|type
operator|==
name|defvar
operator|)
operator|||
operator|(
name|type
operator|==
name|defvr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* MAX_NS is the maximum nesting level for enumerations.  I picked 100    which seemed reasonable.  This doesn't control the number of items,    just the number of nested lists. */
end_comment

begin_define
define|#
directive|define
name|max_stack_depth
value|100
end_define

begin_define
define|#
directive|define
name|ENUM_DIGITS
value|1
end_define

begin_define
define|#
directive|define
name|ENUM_ALPHA
value|2
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|enumtype
decl_stmt|;
name|int
name|enumval
decl_stmt|;
block|}
name|DIGIT_ALPHA
typedef|;
end_typedef

begin_decl_stmt
name|DIGIT_ALPHA
name|enumstack
index|[
name|max_stack_depth
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|enumstack_offset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_enumval
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_enumtype
init|=
name|ENUM_DIGITS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|enumeration_arg
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|start_enumerating
parameter_list|(
name|at
parameter_list|,
name|type
parameter_list|)
name|int
name|at
decl_stmt|,
name|type
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|enumstack_offset
operator|+
literal|1
operator|)
operator|==
name|max_stack_depth
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Enumeration stack overflow"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|enumstack
index|[
name|enumstack_offset
index|]
operator|.
name|enumtype
operator|=
name|current_enumtype
expr_stmt|;
name|enumstack
index|[
name|enumstack_offset
index|]
operator|.
name|enumval
operator|=
name|current_enumval
expr_stmt|;
name|enumstack_offset
operator|++
expr_stmt|;
name|current_enumval
operator|=
name|at
expr_stmt|;
name|current_enumtype
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_function
name|void
name|stop_enumerating
parameter_list|()
block|{
operator|--
name|enumstack_offset
expr_stmt|;
if|if
condition|(
name|enumstack_offset
operator|<
literal|0
condition|)
name|enumstack_offset
operator|=
literal|0
expr_stmt|;
name|current_enumval
operator|=
name|enumstack
index|[
name|enumstack_offset
index|]
operator|.
name|enumval
expr_stmt|;
name|current_enumtype
operator|=
name|enumstack
index|[
name|enumstack_offset
index|]
operator|.
name|enumtype
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Place a letter or digits into the output stream. */
end_comment

begin_function
name|void
name|enumerate_item
parameter_list|()
block|{
name|char
name|temp
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|current_enumtype
operator|==
name|ENUM_ALPHA
condition|)
block|{
if|if
condition|(
name|current_enumval
operator|==
operator|(
literal|'z'
operator|+
literal|1
operator|)
operator|||
name|current_enumval
operator|==
operator|(
literal|'Z'
operator|+
literal|1
operator|)
condition|)
block|{
name|current_enumval
operator|=
operator|(
operator|(
name|current_enumval
operator|-
literal|1
operator|)
operator|==
literal|'z'
condition|?
literal|'a'
else|:
literal|'A'
operator|)
expr_stmt|;
name|warning
argument_list|(
name|_
argument_list|(
literal|"lettering overflow, restarting at %c"
argument_list|)
argument_list|,
name|current_enumval
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%c. "
argument_list|,
name|current_enumval
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%d. "
argument_list|,
name|current_enumval
argument_list|)
expr_stmt|;
name|indent
argument_list|(
name|output_column
operator|+=
operator|(
name|current_indent
operator|-
name|strlen
argument_list|(
name|temp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|current_enumval
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|enum_html
parameter_list|()
block|{
name|char
name|type
decl_stmt|;
name|int
name|start
decl_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|enumeration_arg
argument_list|)
condition|)
block|{
name|type
operator|=
literal|'1'
expr_stmt|;
name|start
operator|=
name|atoi
argument_list|(
name|enumeration_arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|enumeration_arg
argument_list|)
condition|)
block|{
name|type
operator|=
literal|'A'
expr_stmt|;
name|start
operator|=
operator|*
name|enumeration_arg
operator|-
literal|'A'
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
literal|'a'
expr_stmt|;
name|start
operator|=
operator|*
name|enumeration_arg
operator|-
literal|'a'
operator|+
literal|1
expr_stmt|;
block|}
name|add_word_args
argument_list|(
literal|"<ol type=%c start=%d>\n"
argument_list|,
name|type
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Conditionally parse based on the current command name. */
end_comment

begin_function
name|void
name|command_name_condition
parameter_list|()
block|{
name|char
modifier|*
name|discarder
init|=
name|xmalloc
argument_list|(
literal|8
operator|+
name|strlen
argument_list|(
name|command
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|discarder
argument_list|,
literal|"\n%cend %s"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|discard_until
argument_list|(
name|discarder
argument_list|)
expr_stmt|;
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|discarder
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is where the work for all the "insertion" style    commands is done.  A huge switch statement handles the    various setups, and generic code is on both sides. */
end_comment

begin_function
name|void
name|begin_insertion
parameter_list|(
name|type
parameter_list|)
name|enum
name|insertion_type
name|type
decl_stmt|;
block|{
name|int
name|no_discard
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|defun_insertion
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|push_insertion
argument_list|(
name|type
argument_list|,
name|xstrdup
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|no_discard
operator|++
expr_stmt|;
block|}
else|else
name|push_insertion
argument_list|(
name|type
argument_list|,
name|get_item_function
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|menu
case|:
if|if
condition|(
operator|!
name|no_headers
condition|)
name|close_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|no_indent
operator|=
literal|0
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|html
condition|)
block|{
name|had_menu_commentary
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|no_headers
condition|)
name|add_word
argument_list|(
literal|"* Menu:\n"
argument_list|)
expr_stmt|;
name|in_menu
operator|++
expr_stmt|;
name|in_fixed_width_font
operator|++
expr_stmt|;
name|no_discard
operator|++
expr_stmt|;
break|break;
case|case
name|detailmenu
case|:
if|if
condition|(
operator|!
name|in_menu
condition|)
block|{
if|if
condition|(
operator|!
name|no_headers
condition|)
name|close_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|no_indent
operator|=
literal|0
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|no_discard
operator|++
expr_stmt|;
block|}
name|in_fixed_width_font
operator|++
expr_stmt|;
name|in_detailmenu
operator|++
expr_stmt|;
break|break;
case|case
name|direntry
case|:
if|if
condition|(
name|html
condition|)
name|command_name_condition
argument_list|()
expr_stmt|;
else|else
block|{
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|no_indent
operator|=
literal|0
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|insert_string
argument_list|(
literal|"START-INFO-DIR-ENTRY\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|quotation
case|:
comment|/* @quotation does filling (@display doesn't).  */
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"<blockquote>\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|last_char_was_newline
operator|=
name|no_indent
operator|=
literal|0
expr_stmt|;
name|indented_fill
operator|=
name|filling_enabled
operator|=
literal|1
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
block|}
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
break|break;
case|case
name|display
case|:
case|case
name|smalldisplay
case|:
case|case
name|example
case|:
case|case
name|smallexample
case|:
case|case
name|lisp
case|:
case|case
name|smalllisp
case|:
comment|/* Like @display but without indentation. */
case|case
name|smallformat
case|:
case|case
name|format
case|:
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|in_fixed_width_font
operator|++
expr_stmt|;
name|filling_enabled
operator|=
literal|0
expr_stmt|;
name|last_char_was_newline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|html
condition|)
comment|/* Kludge alert: if<pre> is followed by a newline, IE3            renders an extra blank line before the pre-formatted block.            Other browsers seem to not mind one way or the other.  */
name|add_word
argument_list|(
literal|"<pre>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|format
operator|&&
name|type
operator|!=
name|smallformat
condition|)
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
break|break;
case|case
name|multitable
case|:
name|do_multitable
argument_list|()
expr_stmt|;
break|break;
case|case
name|table
case|:
case|case
name|ftable
case|:
case|case
name|vtable
case|:
case|case
name|itemize
case|:
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INDENT_PARAGRAPHS_IN_TABLE
argument_list|)
name|inhibit_paragraph_indentation
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* !INDENT_PARAGRAPHS_IN_TABLE */
comment|/* Make things work for losers who forget the itemize syntax. */
if|if
condition|(
name|type
operator|==
name|itemize
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|insertion_stack
operator|->
name|item_function
operator|)
condition|)
block|{
name|free
argument_list|(
name|insertion_stack
operator|->
name|item_function
argument_list|)
expr_stmt|;
name|insertion_stack
operator|->
name|item_function
operator|=
name|xstrdup
argument_list|(
literal|"@bullet"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|insertion_stack
operator|->
name|item_function
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"%s requires an argument: the formatter for %citem"
argument_list|)
argument_list|,
name|insertion_type_pname
argument_list|(
name|type
argument_list|)
argument_list|,
name|COMMAND_PREFIX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|html
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|itemize
condition|)
block|{
name|add_word
argument_list|(
literal|"<ul>\n"
argument_list|)
expr_stmt|;
name|in_paragraph
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|add_word
argument_list|(
name|dl_tag
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|enumerate
case|:
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|no_indent
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INDENT_PARAGRAPHS_IN_TABLE
argument_list|)
name|inhibit_paragraph_indentation
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* !INDENT_PARAGRAPHS_IN_TABLE */
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|enum_html
argument_list|()
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|enumeration_arg
argument_list|)
condition|)
name|start_enumerating
argument_list|(
name|atoi
argument_list|(
name|enumeration_arg
argument_list|)
argument_list|,
name|ENUM_DIGITS
argument_list|)
expr_stmt|;
else|else
name|start_enumerating
argument_list|(
operator|*
name|enumeration_arg
argument_list|,
name|ENUM_ALPHA
argument_list|)
expr_stmt|;
break|break;
comment|/* @group does nothing special in makeinfo. */
case|case
name|group
case|:
comment|/* Only close the paragraph if we are not inside of an          @example-like environment. */
if|if
condition|(
operator|!
name|insertion_stack
operator|->
name|next
operator|||
operator|(
name|insertion_stack
operator|->
name|next
operator|->
name|insertion
operator|!=
name|display
operator|&&
name|insertion_stack
operator|->
name|next
operator|->
name|insertion
operator|!=
name|smalldisplay
operator|&&
name|insertion_stack
operator|->
name|next
operator|->
name|insertion
operator|!=
name|example
operator|&&
name|insertion_stack
operator|->
name|next
operator|->
name|insertion
operator|!=
name|smallexample
operator|&&
name|insertion_stack
operator|->
name|next
operator|->
name|insertion
operator|!=
name|lisp
operator|&&
name|insertion_stack
operator|->
name|next
operator|->
name|insertion
operator|!=
name|smalllisp
operator|&&
name|insertion_stack
operator|->
name|next
operator|->
name|insertion
operator|!=
name|format
operator|&&
name|insertion_stack
operator|->
name|next
operator|->
name|insertion
operator|!=
name|smallformat
operator|&&
name|insertion_stack
operator|->
name|next
operator|->
name|insertion
operator|!=
name|flushleft
operator|&&
name|insertion_stack
operator|->
name|next
operator|->
name|insertion
operator|!=
name|flushright
operator|)
condition|)
name|close_single_paragraph
argument_list|()
expr_stmt|;
break|break;
comment|/* Insertions that are no-ops in info, but do something in TeX. */
case|case
name|cartouche
case|:
case|case
name|ifclear
case|:
case|case
name|ifhtml
case|:
case|case
name|ifinfo
case|:
case|case
name|ifnothtml
case|:
case|case
name|ifnotinfo
case|:
case|case
name|ifnottex
case|:
case|case
name|ifset
case|:
case|case
name|iftex
case|:
case|case
name|rawtex
case|:
if|if
condition|(
name|in_menu
condition|)
name|no_discard
operator|++
expr_stmt|;
break|break;
case|case
name|rawhtml
case|:
name|escape_html
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|defcv
case|:
case|case
name|deffn
case|:
case|case
name|defivar
case|:
case|case
name|defmac
case|:
case|case
name|defmethod
case|:
case|case
name|defop
case|:
case|case
name|defopt
case|:
case|case
name|defspec
case|:
case|case
name|deftp
case|:
case|case
name|deftypefn
case|:
case|case
name|deftypefun
case|:
case|case
name|deftypeivar
case|:
case|case
name|deftypemethod
case|:
case|case
name|deftypeop
case|:
case|case
name|deftypevar
case|:
case|case
name|deftypevr
case|:
case|case
name|defun
case|:
case|case
name|defvar
case|:
case|case
name|defvr
case|:
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|1
expr_stmt|;
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
name|no_indent
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|flushleft
case|:
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
name|no_indent
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|flushright
case|:
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
name|no_indent
operator|=
literal|0
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|force_flush_right
operator|++
expr_stmt|;
break|break;
default|default:
name|line_error
argument_list|(
literal|"begin_insertion internal error: type=%d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|no_discard
condition|)
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try to end the insertion with the specified TYPE.  With a value of    `bad_type', TYPE gets translated to match the value currently on top    of the stack.  Otherwise, if TYPE doesn't match the top of the    insertion stack, give error. */
end_comment

begin_function
name|void
name|end_insertion
parameter_list|(
name|type
parameter_list|)
name|enum
name|insertion_type
name|type
decl_stmt|;
block|{
name|enum
name|insertion_type
name|temp_type
decl_stmt|;
if|if
condition|(
operator|!
name|insertion_level
condition|)
return|return;
name|temp_type
operator|=
name|current_insertion_type
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|bad_type
condition|)
name|type
operator|=
name|temp_type
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|temp_type
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"`@end' expected `%s', but saw `%s'"
argument_list|)
argument_list|,
name|insertion_type_pname
argument_list|(
name|temp_type
argument_list|)
argument_list|,
name|insertion_type_pname
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|pop_insertion
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
comment|/* Insertions which have no effect on paragraph formatting. */
case|case
name|ifclear
case|:
case|case
name|ifhtml
case|:
case|case
name|ifinfo
case|:
case|case
name|ifnothtml
case|:
case|case
name|ifnotinfo
case|:
case|case
name|ifnottex
case|:
case|case
name|ifset
case|:
case|case
name|iftex
case|:
case|case
name|rawtex
case|:
break|break;
case|case
name|rawhtml
case|:
name|escape_html
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|direntry
case|:
comment|/* Eaten if html. */
name|insert_string
argument_list|(
literal|"END-INFO-DIR-ENTRY\n\n"
argument_list|)
expr_stmt|;
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
break|break;
case|case
name|detailmenu
case|:
name|in_detailmenu
operator|--
expr_stmt|;
comment|/* No longer hacking menus. */
if|if
condition|(
operator|!
name|in_menu
condition|)
block|{
if|if
condition|(
operator|!
name|no_headers
condition|)
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|menu
case|:
name|in_menu
operator|--
expr_stmt|;
comment|/* No longer hacking menus. */
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"</ul>\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|no_headers
condition|)
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
break|break;
case|case
name|multitable
case|:
name|end_multitable
argument_list|()
expr_stmt|;
break|break;
case|case
name|enumerate
case|:
name|stop_enumerating
argument_list|()
expr_stmt|;
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"</ol>\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|flushleft
case|:
case|case
name|group
case|:
case|case
name|cartouche
case|:
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
break|break;
case|case
name|format
case|:
case|case
name|smallformat
case|:
case|case
name|display
case|:
case|case
name|smalldisplay
case|:
case|case
name|example
case|:
case|case
name|smallexample
case|:
case|case
name|lisp
case|:
case|case
name|smalllisp
case|:
case|case
name|quotation
case|:
comment|/* @format and @smallformat are the only fixed_width insertion          without a change in indentation. */
if|if
condition|(
name|type
operator|!=
name|format
operator|&&
name|type
operator|!=
name|smallformat
condition|)
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
name|type
operator|==
name|quotation
condition|?
literal|"</blockquote>\n"
else|:
literal|"</pre>\n"
argument_list|)
expr_stmt|;
comment|/* The ending of one of these insertions always marks the          start of a new paragraph. */
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
break|break;
case|case
name|table
case|:
case|case
name|ftable
case|:
case|case
name|vtable
case|:
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"</dl>\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|itemize
case|:
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"</ul>\n"
argument_list|)
expr_stmt|;
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
break|break;
case|case
name|flushright
case|:
name|force_flush_right
operator|--
expr_stmt|;
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
break|break;
comment|/* Handle the @defun insertions with this default clause. */
default|default:
block|{
name|enum
name|insertion_type
name|base_type
decl_stmt|;
if|if
condition|(
name|type
operator|<
name|defcv
operator|||
name|type
operator|>
name|defvr
condition|)
name|line_error
argument_list|(
literal|"end_insertion internal error: type=%d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|base_type
operator|=
name|get_base_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|deffn
case|:
case|case
name|defvr
case|:
case|case
name|deftp
case|:
case|case
name|deftypefn
case|:
case|case
name|deftypevr
case|:
case|case
name|defcv
case|:
case|case
name|defop
case|:
case|case
name|deftypemethod
case|:
case|case
name|deftypeop
case|:
case|case
name|deftypeivar
case|:
if|if
condition|(
name|html
condition|)
comment|/* close the tables which has been opened in defun.c */
name|add_word
argument_list|(
literal|"</TD></TR>\n</TABLE>\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch (base_type)... */
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|current_indent
operator|<
literal|0
condition|)
name|line_error
argument_list|(
literal|"end_insertion internal error: current indent=%d"
argument_list|,
name|current_indent
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insertions cannot cross certain boundaries, such as node beginnings.  In    code that creates such boundaries, you should call `discard_insertions'    before doing anything else.  It prints the errors for you, and cleans up    the insertion stack.     With nonzero SPECIALS_OK argument, allows unmatched    @if... conditionals, otherwise not.  This is because conditionals can    cross node boundaries.  Always happens with the @top node, for example.  */
end_comment

begin_function
name|void
name|discard_insertions
parameter_list|(
name|specials_ok
parameter_list|)
name|int
name|specials_ok
decl_stmt|;
block|{
name|int
name|real_line_number
init|=
name|line_number
decl_stmt|;
while|while
condition|(
name|insertion_stack
condition|)
block|{
if|if
condition|(
name|specials_ok
operator|&&
operator|(
operator|(
name|ifclear
operator|<=
name|insertion_stack
operator|->
name|insertion
operator|&&
name|insertion_stack
operator|->
name|insertion
operator|<=
name|iftex
operator|)
operator|||
name|insertion_stack
operator|->
name|insertion
operator|==
name|rawhtml
operator|||
name|insertion_stack
operator|->
name|insertion
operator|==
name|rawtex
operator|)
condition|)
break|break;
else|else
block|{
name|char
modifier|*
name|offender
init|=
name|insertion_type_pname
argument_list|(
name|insertion_stack
operator|->
name|insertion
argument_list|)
decl_stmt|;
name|char
modifier|*
name|current_filename
init|=
name|input_filename
decl_stmt|;
name|input_filename
operator|=
name|insertion_stack
operator|->
name|filename
expr_stmt|;
name|line_number
operator|=
name|insertion_stack
operator|->
name|line_number
expr_stmt|;
name|line_error
argument_list|(
name|_
argument_list|(
literal|"No matching `%cend %s'"
argument_list|)
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|offender
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|current_filename
expr_stmt|;
name|pop_insertion
argument_list|()
expr_stmt|;
block|}
block|}
name|line_number
operator|=
name|real_line_number
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Insertion (environment) commands.  */
end_comment

begin_function
name|void
name|cm_quotation
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|quotation
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_example
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|example
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_smallexample
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|smallexample
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_lisp
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|lisp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_smalllisp
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|smalllisp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* @cartouche/@end cartouche draws box with rounded corners in    TeX output.  Right now, just a no-op insertion. */
end_comment

begin_function
name|void
name|cm_cartouche
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|cartouche
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_format
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|format
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_smallformat
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|smallformat
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_display
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|display
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_smalldisplay
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|smalldisplay
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_direntry
parameter_list|()
block|{
if|if
condition|(
name|no_headers
operator|||
name|html
condition|)
name|command_name_condition
argument_list|()
expr_stmt|;
else|else
name|begin_insertion
argument_list|(
name|direntry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_itemize
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|itemize
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start an enumeration insertion of type TYPE.  If the user supplied    no argument on the line, then use DEFAULT_STRING as the initial string. */
end_comment

begin_function
specifier|static
name|void
name|do_enumeration
parameter_list|(
name|type
parameter_list|,
name|default_string
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|default_string
decl_stmt|;
block|{
name|get_until_in_line
argument_list|(
literal|0
argument_list|,
literal|"."
argument_list|,
operator|&
name|enumeration_arg
argument_list|)
expr_stmt|;
name|canon_white
argument_list|(
name|enumeration_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|enumeration_arg
condition|)
block|{
name|free
argument_list|(
name|enumeration_arg
argument_list|)
expr_stmt|;
name|enumeration_arg
operator|=
name|xstrdup
argument_list|(
name|default_string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|enumeration_arg
argument_list|)
operator|&&
operator|!
name|isletter
argument_list|(
operator|*
name|enumeration_arg
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|_
argument_list|(
literal|"%s requires letter or digit"
argument_list|)
argument_list|,
name|insertion_type_pname
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|enumerate
case|:
name|default_string
operator|=
literal|"1"
expr_stmt|;
break|break;
block|}
name|enumeration_arg
operator|=
name|xstrdup
argument_list|(
name|default_string
argument_list|)
expr_stmt|;
block|}
name|begin_insertion
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_enumerate
parameter_list|()
block|{
name|do_enumeration
argument_list|(
name|enumerate
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_table
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_multitable
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|multitable
argument_list|)
expr_stmt|;
comment|/* @@ */
block|}
end_function

begin_function
name|void
name|cm_ftable
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|ftable
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_vtable
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|vtable
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_group
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|cm_ifinfo
parameter_list|()
block|{
if|if
condition|(
name|process_info
condition|)
name|begin_insertion
argument_list|(
name|ifinfo
argument_list|)
expr_stmt|;
else|else
name|command_name_condition
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_ifnotinfo
parameter_list|()
block|{
if|if
condition|(
operator|!
name|process_info
condition|)
name|begin_insertion
argument_list|(
name|ifnotinfo
argument_list|)
expr_stmt|;
else|else
name|command_name_condition
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert raw HTML (no escaping of `<' etc.). */
end_comment

begin_function
name|void
name|cm_html
parameter_list|()
block|{
if|if
condition|(
name|process_html
condition|)
name|begin_insertion
argument_list|(
name|rawhtml
argument_list|)
expr_stmt|;
else|else
name|command_name_condition
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_ifhtml
parameter_list|()
block|{
if|if
condition|(
name|process_html
condition|)
name|begin_insertion
argument_list|(
name|ifhtml
argument_list|)
expr_stmt|;
else|else
name|command_name_condition
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_ifnothtml
parameter_list|()
block|{
if|if
condition|(
operator|!
name|process_html
condition|)
name|begin_insertion
argument_list|(
name|ifnothtml
argument_list|)
expr_stmt|;
else|else
name|command_name_condition
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_tex
parameter_list|()
block|{
if|if
condition|(
name|process_tex
condition|)
name|begin_insertion
argument_list|(
name|rawtex
argument_list|)
expr_stmt|;
else|else
name|command_name_condition
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_iftex
parameter_list|()
block|{
if|if
condition|(
name|process_tex
condition|)
name|begin_insertion
argument_list|(
name|iftex
argument_list|)
expr_stmt|;
else|else
name|command_name_condition
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_ifnottex
parameter_list|()
block|{
if|if
condition|(
operator|!
name|process_tex
condition|)
name|begin_insertion
argument_list|(
name|ifnottex
argument_list|)
expr_stmt|;
else|else
name|command_name_condition
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Begin an insertion where the lines are not filled or indented. */
end_comment

begin_function
name|void
name|cm_flushleft
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|flushleft
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin an insertion where the lines are not filled, and each line is    forced to the right-hand side of the page. */
end_comment

begin_function
name|void
name|cm_flushright
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|flushright
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_menu
parameter_list|()
block|{
if|if
condition|(
name|current_node
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
name|_
argument_list|(
literal|"@menu seen before first @node, creating `Top' node"
argument_list|)
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|_
argument_list|(
literal|"perhaps your @top node should be wrapped in @ifnottex rather than @ifinfo?"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Include @top command so we can construct the implicit node tree.  */
name|execute_string
argument_list|(
literal|"@node top\n@top Top\n"
argument_list|)
expr_stmt|;
block|}
name|begin_insertion
argument_list|(
name|menu
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_detailmenu
parameter_list|()
block|{
if|if
condition|(
name|current_node
operator|==
name|NULL
condition|)
block|{
comment|/* Problems anyway, @detailmenu should always be inside @menu.  */
name|warning
argument_list|(
name|_
argument_list|(
literal|"@detailmenu seen before first node, creating `Top' node"
argument_list|)
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"@node top\n@top Top\n"
argument_list|)
expr_stmt|;
block|}
name|begin_insertion
argument_list|(
name|detailmenu
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End existing insertion block. */
end_comment

begin_function
name|void
name|cm_end
parameter_list|()
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|enum
name|insertion_type
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|insertion_level
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Unmatched `%c%s'"
argument_list|)
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
return|return;
block|}
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|line_error
argument_list|(
name|_
argument_list|(
literal|"`%c%s' needs something after it"
argument_list|)
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|type
operator|=
name|find_type_from_name
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|bad_type
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Bad argument to `%s', `%s', using `%s'"
argument_list|)
argument_list|,
name|command
argument_list|,
name|temp
argument_list|,
name|insertion_type_pname
argument_list|(
name|current_insertion_type
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|end_insertion
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* @itemx, @item. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|itemx_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return whether CMD takes a brace-delimited {arg}.  */
end_comment

begin_function
specifier|static
name|int
name|command_needs_braces
parameter_list|(
name|cmd
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|command_table
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|command_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|cmd
argument_list|)
condition|)
return|return
name|command_table
index|[
name|i
index|]
operator|.
name|argument_in_braces
operator|==
name|BRACE_ARGS
return|;
block|}
return|return
literal|0
return|;
comment|/* macro or alias */
block|}
end_function

begin_function
name|void
name|cm_item
parameter_list|()
block|{
name|char
modifier|*
name|rest_of_line
decl_stmt|,
modifier|*
name|item_func
decl_stmt|;
comment|/* Can only hack "@item" while inside of an insertion. */
if|if
condition|(
name|insertion_level
condition|)
block|{
name|INSERTION_ELT
modifier|*
name|stack
init|=
name|insertion_stack
decl_stmt|;
name|int
name|original_input_text_offset
decl_stmt|;
name|skip_whitespace
argument_list|()
expr_stmt|;
name|original_input_text_offset
operator|=
name|input_text_offset
expr_stmt|;
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|rest_of_line
argument_list|)
expr_stmt|;
name|item_func
operator|=
name|current_item_function
argument_list|()
expr_stmt|;
comment|/* Do the right thing depending on which insertion function is active. */
name|switch_top
label|:
switch|switch
condition|(
name|stack
operator|->
name|insertion
condition|)
block|{
case|case
name|multitable
case|:
name|multitable_item
argument_list|()
expr_stmt|;
comment|/* Support text directly after the @item.  */
if|if
condition|(
operator|*
name|rest_of_line
condition|)
block|{
name|line_number
operator|--
expr_stmt|;
name|input_text_offset
operator|=
name|original_input_text_offset
expr_stmt|;
block|}
break|break;
case|case
name|ifclear
case|:
case|case
name|ifhtml
case|:
case|case
name|ifinfo
case|:
case|case
name|ifnothtml
case|:
case|case
name|ifnotinfo
case|:
case|case
name|ifnottex
case|:
case|case
name|ifset
case|:
case|case
name|iftex
case|:
case|case
name|rawhtml
case|:
case|case
name|rawtex
case|:
case|case
name|tex
case|:
case|case
name|cartouche
case|:
name|stack
operator|=
name|stack
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|stack
condition|)
goto|goto
name|no_insertion
goto|;
else|else
goto|goto
name|switch_top
goto|;
break|break;
case|case
name|menu
case|:
case|case
name|quotation
case|:
case|case
name|example
case|:
case|case
name|smallexample
case|:
case|case
name|lisp
case|:
case|case
name|smalllisp
case|:
case|case
name|format
case|:
case|case
name|smallformat
case|:
case|case
name|display
case|:
case|case
name|smalldisplay
case|:
case|case
name|group
case|:
name|line_error
argument_list|(
name|_
argument_list|(
literal|"@%s not meaningful inside `@%s' block"
argument_list|)
argument_list|,
name|command
argument_list|,
name|insertion_type_pname
argument_list|(
name|current_insertion_type
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|itemize
case|:
case|case
name|enumerate
case|:
if|if
condition|(
name|itemx_flag
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"@itemx not meaningful inside `%s' block"
argument_list|)
argument_list|,
name|insertion_type_pname
argument_list|(
name|current_insertion_type
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|html
condition|)
block|{
if|if
condition|(
name|in_paragraph
condition|)
block|{
name|add_word
argument_list|(
literal|"</p>"
argument_list|)
expr_stmt|;
name|in_paragraph
operator|=
literal|0
expr_stmt|;
block|}
name|add_word
argument_list|(
literal|"<li>"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|start_paragraph
argument_list|()
expr_stmt|;
name|kill_self_indent
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|current_item_function
argument_list|()
condition|)
block|{
name|output_column
operator|=
name|current_indent
operator|-
literal|2
expr_stmt|;
name|indent
argument_list|(
name|output_column
argument_list|)
expr_stmt|;
comment|/* The item marker can be given with or without                          braces -- @bullet and @bullet{} are both ok.                          Or it might be something that doesn't take                          braces at all, such as "o" or "#" or "@ ".                          Thus, only supply braces if the item marker is                          a command, they haven't supplied braces                          themselves, and we know it needs them.  */
if|if
condition|(
name|item_func
operator|&&
operator|*
name|item_func
condition|)
block|{
if|if
condition|(
operator|*
name|item_func
operator|==
name|COMMAND_PREFIX
operator|&&
name|item_func
index|[
name|strlen
argument_list|(
name|item_func
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'}'
operator|&&
name|command_needs_braces
argument_list|(
name|item_func
operator|+
literal|1
argument_list|)
condition|)
name|execute_string
argument_list|(
literal|"%s{}"
argument_list|,
name|item_func
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|item_func
argument_list|)
expr_stmt|;
block|}
name|insert
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|output_column
operator|++
expr_stmt|;
block|}
else|else
name|enumerate_item
argument_list|()
expr_stmt|;
comment|/* Special hack.  This makes `close_paragraph' a no-op until                      `start_paragraph' has been called. */
name|must_start_paragraph
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Handle text directly after the @item.  */
if|if
condition|(
operator|*
name|rest_of_line
condition|)
block|{
name|line_number
operator|--
expr_stmt|;
name|input_text_offset
operator|=
name|original_input_text_offset
expr_stmt|;
block|}
block|}
break|break;
case|case
name|table
case|:
case|case
name|ftable
case|:
case|case
name|vtable
case|:
if|if
condition|(
name|html
condition|)
block|{
specifier|static
name|int
name|last_html_output_position
init|=
literal|0
decl_stmt|;
comment|/* If nothing has been output since the last<dd>,                  remove the empty<dd> element.  Some browsers render                  an extra empty line for<dd><dt>, which makes @itemx                  conversion look ugly.  */
if|if
condition|(
name|last_html_output_position
operator|==
name|output_position
operator|&&
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|output_paragraph
argument_list|,
literal|"<dd>"
argument_list|,
name|output_paragraph_offset
argument_list|)
operator|==
literal|0
condition|)
name|output_paragraph_offset
operator|=
literal|0
expr_stmt|;
comment|/* Force the browser to render one blank line before                  each new @item in a table.  But don't do that unless                  this is the first<dt> after the<dl>, or if we are                  converting @itemx.                   Note that there are some browsers which ignore<br>                  in this context, but I cannot find any way to force                  them all render exactly one blank line.  */
if|if
condition|(
operator|!
name|itemx_flag
operator|&&
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|output_paragraph
operator|+
name|output_paragraph_offset
operator|-
sizeof|sizeof
argument_list|(
name|dl_tag
argument_list|)
operator|+
literal|1
argument_list|,
name|dl_tag
argument_list|,
sizeof|sizeof
argument_list|(
name|dl_tag
argument_list|)
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|add_word
argument_list|(
literal|"<br>"
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"<dt>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|item_func
operator|&&
operator|*
name|item_func
condition|)
name|execute_string
argument_list|(
literal|"%s{%s}"
argument_list|,
name|item_func
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_insertion_type
argument_list|()
operator|==
name|ftable
condition|)
name|execute_string
argument_list|(
literal|"%cfindex %s\n"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_insertion_type
argument_list|()
operator|==
name|vtable
condition|)
name|execute_string
argument_list|(
literal|"%cvindex %s\n"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
comment|/* Make sure output_position is updated, so we could                  remember it.  */
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|last_html_output_position
operator|=
name|output_position
expr_stmt|;
name|add_word
argument_list|(
literal|"<dd>"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We need this to determine if we have two @item's in a row                  (see test just below).  */
specifier|static
name|int
name|last_item_output_position
init|=
literal|0
decl_stmt|;
comment|/* Get rid of extra characters. */
name|kill_self_indent
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* If we have one @item followed directly by another @item,                  we need to insert a blank line.  This is not true for                  @itemx, though.  */
if|if
condition|(
operator|!
name|itemx_flag
operator|&&
name|last_item_output_position
operator|==
name|output_position
condition|)
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* `close_paragraph' almost does what we want.  The problem                  is when paragraph_is_open, and last_char_was_newline, and                  the last newline has been turned into a space, because                  filling_enabled. I handle it here. */
if|if
condition|(
name|last_char_was_newline
operator|&&
name|filling_enabled
operator|&&
name|paragraph_is_open
condition|)
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INDENT_PARAGRAPHS_IN_TABLE
argument_list|)
comment|/* Indent on a new line, but back up one indentation level. */
block|{
name|int
name|save
init|=
name|inhibit_paragraph_indentation
decl_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
comment|/* At this point, inserting any non-whitespace character will                    force the existing indentation to be output. */
name|add_char
argument_list|(
literal|'i'
argument_list|)
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
name|save
expr_stmt|;
block|}
else|#
directive|else
comment|/* !INDENT_PARAGRAPHS_IN_TABLE */
name|add_char
argument_list|(
literal|'i'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !INDENT_PARAGRAPHS_IN_TABLE */
name|output_paragraph_offset
operator|--
expr_stmt|;
name|kill_self_indent
argument_list|(
name|default_indentation_increment
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Add item's argument to the line. */
name|filling_enabled
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|item_func
operator|&&
operator|*
name|item_func
condition|)
name|execute_string
argument_list|(
literal|"%s{%s}"
argument_list|,
name|item_func
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_insertion_type
argument_list|()
operator|==
name|ftable
condition|)
name|execute_string
argument_list|(
literal|"%cfindex %s\n"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_insertion_type
argument_list|()
operator|==
name|vtable
condition|)
name|execute_string
argument_list|(
literal|"%cvindex %s\n"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
comment|/* Start a new line, and let start_paragraph ()                  do the indenting of it for you. */
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|indented_fill
operator|=
name|filling_enabled
operator|=
literal|1
expr_stmt|;
name|last_item_output_position
operator|=
name|output_position
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|rest_of_line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|no_insertion
label|:
name|line_error
argument_list|(
name|_
argument_list|(
literal|"%c%s found outside of an insertion block"
argument_list|)
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|cm_itemx
parameter_list|()
block|{
name|itemx_flag
operator|++
expr_stmt|;
name|cm_item
argument_list|()
expr_stmt|;
name|itemx_flag
operator|--
expr_stmt|;
block|}
end_function

end_unit

