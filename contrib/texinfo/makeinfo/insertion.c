begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* insertion.c -- insertions for Texinfo.    $Id: insertion.c,v 1.14 2003/01/02 23:46:29 karl Exp $     Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003 Free Software    Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cmds.h"
end_include

begin_include
include|#
directive|include
file|"defun.h"
end_include

begin_include
include|#
directive|include
file|"insertion.h"
end_include

begin_include
include|#
directive|include
file|"macro.h"
end_include

begin_include
include|#
directive|include
file|"makeinfo.h"
end_include

begin_include
include|#
directive|include
file|"xml.h"
end_include

begin_comment
comment|/* Must match list in insertion.h.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|insertion_type_names
index|[]
init|=
block|{
literal|"cartouche"
block|,
literal|"copying"
block|,
literal|"defcv"
block|,
literal|"deffn"
block|,
literal|"defivar"
block|,
literal|"defmac"
block|,
literal|"defmethod"
block|,
literal|"defop"
block|,
literal|"defopt"
block|,
literal|"defspec"
block|,
literal|"deftp"
block|,
literal|"deftypefn"
block|,
literal|"deftypefun"
block|,
literal|"deftypeivar"
block|,
literal|"deftypemethod"
block|,
literal|"deftypeop"
block|,
literal|"deftypevar"
block|,
literal|"deftypevr"
block|,
literal|"defun"
block|,
literal|"defvar"
block|,
literal|"defvr"
block|,
literal|"detailmenu"
block|,
literal|"direntry"
block|,
literal|"display"
block|,
literal|"documentdescription"
block|,
literal|"enumerate"
block|,
literal|"example"
block|,
literal|"flushleft"
block|,
literal|"flushright"
block|,
literal|"format"
block|,
literal|"ftable"
block|,
literal|"group"
block|,
literal|"ifclear"
block|,
literal|"ifhtml"
block|,
literal|"ifinfo"
block|,
literal|"ifnothtml"
block|,
literal|"ifnotinfo"
block|,
literal|"ifnotplaintext"
block|,
literal|"ifnottex"
block|,
literal|"ifnotxml"
block|,
literal|"ifplaintext"
block|,
literal|"ifset"
block|,
literal|"iftex"
block|,
literal|"ifxml"
block|,
literal|"itemize"
block|,
literal|"lisp"
block|,
literal|"menu"
block|,
literal|"multitable"
block|,
literal|"quotation"
block|,
literal|"rawhtml"
block|,
literal|"rawtex"
block|,
literal|"smalldisplay"
block|,
literal|"smallexample"
block|,
literal|"smallformat"
block|,
literal|"smalllisp"
block|,
literal|"verbatim"
block|,
literal|"table"
block|,
literal|"tex"
block|,
literal|"vtable"
block|,
literal|"bad_type"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All nested environments.  */
end_comment

begin_decl_stmt
name|INSERTION_ELT
modifier|*
name|insertion_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How deeply we're nested.  */
end_comment

begin_decl_stmt
name|int
name|insertion_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 1 if we've processed (commentary) text in a @menu that    wasn't part of a menu item.  */
end_comment

begin_decl_stmt
name|int
name|had_menu_commentary
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to examine menu lines.  */
end_comment

begin_decl_stmt
name|int
name|in_detailmenu
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to examine menu lines.  */
end_comment

begin_decl_stmt
name|int
name|in_menu
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 1 if<p> is written in normal context.     Used for menu and itemize. */
end_comment

begin_decl_stmt
name|int
name|in_paragraph
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|dl_tag
index|[]
init|=
literal|"<dl>\n"
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|cm_insert_copying
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_function
name|void
name|init_insertion_stack
parameter_list|()
block|{
name|insertion_stack
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the type of the current insertion. */
end_comment

begin_function
specifier|static
name|enum
name|insertion_type
name|current_insertion_type
parameter_list|()
block|{
return|return
name|insertion_level
condition|?
name|insertion_stack
operator|->
name|insertion
else|:
name|bad_type
return|;
block|}
end_function

begin_comment
comment|/* Return the string which is the function to wrap around items, or NULL    if we're not in an environment where @item is ok.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|current_item_function
parameter_list|()
block|{
name|int
name|done
init|=
literal|0
decl_stmt|;
name|INSERTION_ELT
modifier|*
name|elt
init|=
name|insertion_stack
decl_stmt|;
comment|/* Skip down through the stack until we find an insertion with an      itemize function defined, i.e., skip conditionals, @cartouche, etc.  */
while|while
condition|(
operator|!
name|done
operator|&&
name|elt
condition|)
block|{
switch|switch
condition|(
name|elt
operator|->
name|insertion
condition|)
block|{
comment|/* This list should match the one in cm_item.  */
case|case
name|ifclear
case|:
case|case
name|ifhtml
case|:
case|case
name|ifinfo
case|:
case|case
name|ifnothtml
case|:
case|case
name|ifnotinfo
case|:
case|case
name|ifnotplaintext
case|:
case|case
name|ifnottex
case|:
case|case
name|ifnotxml
case|:
case|case
name|ifplaintext
case|:
case|case
name|ifset
case|:
case|case
name|iftex
case|:
case|case
name|ifxml
case|:
case|case
name|rawhtml
case|:
case|case
name|rawtex
case|:
case|case
name|tex
case|:
case|case
name|cartouche
case|:
name|elt
operator|=
name|elt
operator|->
name|next
expr_stmt|;
break|break;
default|default:
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* item_function usually gets assigned the empty string.  */
return|return
name|done
operator|&&
operator|(
operator|*
name|elt
operator|->
name|item_function
operator|)
condition|?
name|elt
operator|->
name|item_function
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Parse the item marker function off the input.  If result is just "@",    change it to "@ ", since "@" by itself is not a command.  This makes    "@ ", "@\t", and "@\n" all the same, but their default meanings are    the same anyway, and let's not worry about supporting redefining them.  */
end_comment

begin_function
name|char
modifier|*
name|get_item_function
parameter_list|()
block|{
name|char
modifier|*
name|item_function
decl_stmt|;
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|item_function
argument_list|)
expr_stmt|;
comment|/* If we hit the end of text in get_rest_of_line, backing up      input pointer will cause the last character of the last line      be pushed back onto the input, which is wrong.  */
if|if
condition|(
name|input_text_offset
operator|<
name|input_text_length
condition|)
name|backup_input_pointer
argument_list|()
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|item_function
argument_list|,
literal|"@"
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|item_function
argument_list|)
expr_stmt|;
name|item_function
operator|=
name|xstrdup
argument_list|(
literal|"@ "
argument_list|)
expr_stmt|;
block|}
return|return
name|item_function
return|;
block|}
end_function

begin_comment
comment|/* Push the state of the current insertion on the stack. */
end_comment

begin_function
name|void
name|push_insertion
parameter_list|(
name|type
parameter_list|,
name|item_function
parameter_list|)
name|enum
name|insertion_type
name|type
decl_stmt|;
name|char
modifier|*
name|item_function
decl_stmt|;
block|{
name|INSERTION_ELT
modifier|*
name|new
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|INSERTION_ELT
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|item_function
operator|=
name|item_function
expr_stmt|;
name|new
operator|->
name|filling_enabled
operator|=
name|filling_enabled
expr_stmt|;
name|new
operator|->
name|indented_fill
operator|=
name|indented_fill
expr_stmt|;
name|new
operator|->
name|insertion
operator|=
name|type
expr_stmt|;
name|new
operator|->
name|line_number
operator|=
name|line_number
expr_stmt|;
name|new
operator|->
name|filename
operator|=
name|xstrdup
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|new
operator|->
name|inhibited
operator|=
name|inhibit_paragraph_indentation
expr_stmt|;
name|new
operator|->
name|in_fixed_width_font
operator|=
name|in_fixed_width_font
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|insertion_stack
expr_stmt|;
name|insertion_stack
operator|=
name|new
expr_stmt|;
name|insertion_level
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop the value on top of the insertion stack into the     global variables. */
end_comment

begin_function
name|void
name|pop_insertion
parameter_list|()
block|{
name|INSERTION_ELT
modifier|*
name|temp
init|=
name|insertion_stack
decl_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
return|return;
name|in_fixed_width_font
operator|=
name|temp
operator|->
name|in_fixed_width_font
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
name|temp
operator|->
name|inhibited
expr_stmt|;
name|filling_enabled
operator|=
name|temp
operator|->
name|filling_enabled
expr_stmt|;
name|indented_fill
operator|=
name|temp
operator|->
name|indented_fill
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
operator|(
name|temp
operator|->
name|item_function
operator|)
argument_list|)
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
operator|(
name|temp
operator|->
name|filename
operator|)
argument_list|)
expr_stmt|;
name|insertion_stack
operator|=
name|insertion_stack
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|insertion_level
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the print name of this     enumerated type. */
end_comment

begin_function
name|char
modifier|*
name|insertion_type_pname
parameter_list|(
name|type
parameter_list|)
name|enum
name|insertion_type
name|type
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|type
operator|<
operator|(
name|int
operator|)
name|bad_type
condition|)
return|return
name|insertion_type_names
index|[
operator|(
name|int
operator|)
name|type
index|]
return|;
else|else
return|return
name|_
argument_list|(
literal|"Broken-Type in insertion_type_pname"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the insertion_type associated with NAME.    If the type is not one of the known ones, return BAD_TYPE. */
end_comment

begin_function
name|enum
name|insertion_type
name|find_type_from_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|index
operator|<
operator|(
name|int
operator|)
name|bad_type
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
name|insertion_type_names
index|[
name|index
index|]
argument_list|)
condition|)
return|return
operator|(
expr|enum
name|insertion_type
operator|)
name|index
return|;
if|if
condition|(
name|index
operator|==
name|rawhtml
operator|&&
name|STREQ
argument_list|(
name|name
argument_list|,
literal|"html"
argument_list|)
condition|)
return|return
name|rawhtml
return|;
if|if
condition|(
name|index
operator|==
name|rawhtml
operator|&&
name|STREQ
argument_list|(
name|name
argument_list|,
literal|"xml"
argument_list|)
condition|)
return|return
name|rawhtml
return|;
if|if
condition|(
name|index
operator|==
name|rawtex
operator|&&
name|STREQ
argument_list|(
name|name
argument_list|,
literal|"tex"
argument_list|)
condition|)
return|return
name|rawtex
return|;
name|index
operator|++
expr_stmt|;
block|}
return|return
name|bad_type
return|;
block|}
end_function

begin_function
name|int
name|defun_insertion
parameter_list|(
name|type
parameter_list|)
name|enum
name|insertion_type
name|type
decl_stmt|;
block|{
return|return
literal|0
operator|||
operator|(
name|type
operator|==
name|defcv
operator|)
operator|||
operator|(
name|type
operator|==
name|deffn
operator|)
operator|||
operator|(
name|type
operator|==
name|defivar
operator|)
operator|||
operator|(
name|type
operator|==
name|defmac
operator|)
operator|||
operator|(
name|type
operator|==
name|defmethod
operator|)
operator|||
operator|(
name|type
operator|==
name|defop
operator|)
operator|||
operator|(
name|type
operator|==
name|defopt
operator|)
operator|||
operator|(
name|type
operator|==
name|defspec
operator|)
operator|||
operator|(
name|type
operator|==
name|deftp
operator|)
operator|||
operator|(
name|type
operator|==
name|deftypefn
operator|)
operator|||
operator|(
name|type
operator|==
name|deftypefun
operator|)
operator|||
operator|(
name|type
operator|==
name|deftypeivar
operator|)
operator|||
operator|(
name|type
operator|==
name|deftypemethod
operator|)
operator|||
operator|(
name|type
operator|==
name|deftypeop
operator|)
operator|||
operator|(
name|type
operator|==
name|deftypevar
operator|)
operator|||
operator|(
name|type
operator|==
name|deftypevr
operator|)
operator|||
operator|(
name|type
operator|==
name|defun
operator|)
operator|||
operator|(
name|type
operator|==
name|defvar
operator|)
operator|||
operator|(
name|type
operator|==
name|defvr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* MAX_NS is the maximum nesting level for enumerations.  I picked 100    which seemed reasonable.  This doesn't control the number of items,    just the number of nested lists. */
end_comment

begin_define
define|#
directive|define
name|max_stack_depth
value|100
end_define

begin_define
define|#
directive|define
name|ENUM_DIGITS
value|1
end_define

begin_define
define|#
directive|define
name|ENUM_ALPHA
value|2
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|enumtype
decl_stmt|;
name|int
name|enumval
decl_stmt|;
block|}
name|DIGIT_ALPHA
typedef|;
end_typedef

begin_decl_stmt
name|DIGIT_ALPHA
name|enumstack
index|[
name|max_stack_depth
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|enumstack_offset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_enumval
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_enumtype
init|=
name|ENUM_DIGITS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|enumeration_arg
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|start_enumerating
parameter_list|(
name|at
parameter_list|,
name|type
parameter_list|)
name|int
name|at
decl_stmt|,
name|type
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|enumstack_offset
operator|+
literal|1
operator|)
operator|==
name|max_stack_depth
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Enumeration stack overflow"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|enumstack
index|[
name|enumstack_offset
index|]
operator|.
name|enumtype
operator|=
name|current_enumtype
expr_stmt|;
name|enumstack
index|[
name|enumstack_offset
index|]
operator|.
name|enumval
operator|=
name|current_enumval
expr_stmt|;
name|enumstack_offset
operator|++
expr_stmt|;
name|current_enumval
operator|=
name|at
expr_stmt|;
name|current_enumtype
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_function
name|void
name|stop_enumerating
parameter_list|()
block|{
operator|--
name|enumstack_offset
expr_stmt|;
if|if
condition|(
name|enumstack_offset
operator|<
literal|0
condition|)
name|enumstack_offset
operator|=
literal|0
expr_stmt|;
name|current_enumval
operator|=
name|enumstack
index|[
name|enumstack_offset
index|]
operator|.
name|enumval
expr_stmt|;
name|current_enumtype
operator|=
name|enumstack
index|[
name|enumstack_offset
index|]
operator|.
name|enumtype
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Place a letter or digits into the output stream. */
end_comment

begin_function
name|void
name|enumerate_item
parameter_list|()
block|{
name|char
name|temp
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|current_enumtype
operator|==
name|ENUM_ALPHA
condition|)
block|{
if|if
condition|(
name|current_enumval
operator|==
operator|(
literal|'z'
operator|+
literal|1
operator|)
operator|||
name|current_enumval
operator|==
operator|(
literal|'Z'
operator|+
literal|1
operator|)
condition|)
block|{
name|current_enumval
operator|=
operator|(
operator|(
name|current_enumval
operator|-
literal|1
operator|)
operator|==
literal|'z'
condition|?
literal|'a'
else|:
literal|'A'
operator|)
expr_stmt|;
name|warning
argument_list|(
name|_
argument_list|(
literal|"lettering overflow, restarting at %c"
argument_list|)
argument_list|,
name|current_enumval
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%c. "
argument_list|,
name|current_enumval
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%d. "
argument_list|,
name|current_enumval
argument_list|)
expr_stmt|;
name|indent
argument_list|(
name|output_column
operator|+=
operator|(
name|current_indent
operator|-
name|strlen
argument_list|(
name|temp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|current_enumval
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|enum_html
parameter_list|()
block|{
name|char
name|type
decl_stmt|;
name|int
name|start
decl_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|enumeration_arg
argument_list|)
condition|)
block|{
name|type
operator|=
literal|'1'
expr_stmt|;
name|start
operator|=
name|atoi
argument_list|(
name|enumeration_arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|enumeration_arg
argument_list|)
condition|)
block|{
name|type
operator|=
literal|'A'
expr_stmt|;
name|start
operator|=
operator|*
name|enumeration_arg
operator|-
literal|'A'
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
literal|'a'
expr_stmt|;
name|start
operator|=
operator|*
name|enumeration_arg
operator|-
literal|'a'
operator|+
literal|1
expr_stmt|;
block|}
name|add_word_args
argument_list|(
literal|"<ol type=%c start=%d>\n"
argument_list|,
name|type
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Conditionally parse based on the current command name. */
end_comment

begin_function
name|void
name|command_name_condition
parameter_list|()
block|{
name|char
modifier|*
name|discarder
init|=
name|xmalloc
argument_list|(
literal|8
operator|+
name|strlen
argument_list|(
name|command
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|discarder
argument_list|,
literal|"\n%cend %s"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|discard_until
argument_list|(
name|discarder
argument_list|)
expr_stmt|;
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|discarder
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is where the work for all the "insertion" style    commands is done.  A huge switch statement handles the    various setups, and generic code is on both sides. */
end_comment

begin_function
name|void
name|begin_insertion
parameter_list|(
name|type
parameter_list|)
name|enum
name|insertion_type
name|type
decl_stmt|;
block|{
name|int
name|no_discard
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|defun_insertion
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|push_insertion
argument_list|(
name|type
argument_list|,
name|xstrdup
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|no_discard
operator|++
expr_stmt|;
block|}
else|else
block|{
name|push_insertion
argument_list|(
name|type
argument_list|,
name|get_item_function
argument_list|()
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|menu
case|:
if|if
condition|(
operator|!
name|no_headers
condition|)
name|close_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|no_indent
operator|=
literal|0
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|html
condition|)
block|{
name|had_menu_commentary
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|no_headers
operator|&&
operator|!
name|xml
condition|)
name|add_word
argument_list|(
literal|"* Menu:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|MENU
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|next_menu_item_number
operator|=
literal|1
expr_stmt|;
name|in_menu
operator|++
expr_stmt|;
name|in_fixed_width_font
operator|++
expr_stmt|;
name|no_discard
operator|++
expr_stmt|;
break|break;
case|case
name|detailmenu
case|:
if|if
condition|(
operator|!
name|in_menu
condition|)
block|{
if|if
condition|(
operator|!
name|no_headers
condition|)
name|close_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|no_indent
operator|=
literal|0
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|no_discard
operator|++
expr_stmt|;
block|}
name|in_fixed_width_font
operator|++
expr_stmt|;
name|in_detailmenu
operator|++
expr_stmt|;
break|break;
case|case
name|direntry
case|:
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|no_indent
operator|=
literal|0
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|insert_string
argument_list|(
literal|"START-INFO-DIR-ENTRY\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|documentdescription
case|:
block|{
name|char
modifier|*
name|desc
decl_stmt|;
name|int
name|start_of_end
decl_stmt|;
name|int
name|save_fixed_width
decl_stmt|;
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* ignore the @documentdescription line */
name|start_of_end
operator|=
name|get_until
argument_list|(
literal|"\n@end documentdescription"
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
name|save_fixed_width
operator|=
name|in_fixed_width_font
expr_stmt|;
name|in_fixed_width_font
operator|=
literal|0
expr_stmt|;
name|document_description
operator|=
name|expansion
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|=
name|save_fixed_width
expr_stmt|;
name|input_text_offset
operator|=
name|start_of_end
expr_stmt|;
comment|/* go back to the @end to match */
block|}
break|break;
case|case
name|copying
case|:
block|{
comment|/* Save the copying text away for @insertcopying,            typically used on the back of the @titlepage (for TeX) and            the Top node (for info/html).  */
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|start_of_end
decl_stmt|;
name|int
name|save_paragraph_indentation
decl_stmt|;
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* ignore remainder of @copying line */
name|start_of_end
operator|=
name|get_until
argument_list|(
literal|"\n@end copying"
argument_list|,
operator|&
name|text
argument_list|)
expr_stmt|;
comment|/* include all the output-format-specific markup.  */
if|if
condition|(
name|docbook
condition|)
block|{
name|save_paragraph_indentation
operator|=
name|inhibit_paragraph_indentation
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
block|}
name|copying_text
operator|=
name|full_expansion
argument_list|(
name|text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|docbook
condition|)
name|inhibit_paragraph_indentation
operator|=
name|save_paragraph_indentation
expr_stmt|;
name|input_text_offset
operator|=
name|start_of_end
expr_stmt|;
comment|/* go back to the @end to match */
block|}
comment|/* For info, output the copying text right away, so it will end up          in the header of the Info file, before the first node, and thus          get copied automatically to all the split files.  For xml, also          output it right away since xml output is never split.          For html, we output it specifically in html_output_head.           For plain text, there's no way to hide it, so the author must           use @insertcopying in the desired location.  */
if|if
condition|(
name|docbook
condition|)
block|{
if|if
condition|(
operator|!
name|xml_in_bookinfo
condition|)
block|{
name|xml_insert_element
argument_list|(
name|BOOKINFO
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_in_bookinfo
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|xml_in_abstract
condition|)
block|{
name|xml_insert_element
argument_list|(
name|ABSTRACT
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_in_abstract
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|html
operator|&&
operator|!
name|no_headers
condition|)
name|cm_insert_copying
argument_list|()
expr_stmt|;
if|if
condition|(
name|docbook
operator|&&
name|xml_in_abstract
condition|)
block|{
name|xml_insert_element
argument_list|(
name|ABSTRACT
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_in_abstract
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|quotation
case|:
comment|/* @quotation does filling (@display doesn't).  */
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"<blockquote>\n"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* with close_single_paragraph, we get no blank line above              within @copying.  */
name|close_paragraph
argument_list|()
expr_stmt|;
name|last_char_was_newline
operator|=
name|no_indent
operator|=
literal|0
expr_stmt|;
name|indented_fill
operator|=
name|filling_enabled
operator|=
literal|1
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
block|}
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
break|break;
case|case
name|display
case|:
case|case
name|smalldisplay
case|:
case|case
name|example
case|:
case|case
name|smallexample
case|:
case|case
name|lisp
case|:
case|case
name|smalllisp
case|:
comment|/* Like @display but without indentation. */
case|case
name|smallformat
case|:
case|case
name|format
case|:
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|in_fixed_width_font
operator|++
expr_stmt|;
name|filling_enabled
operator|=
literal|0
expr_stmt|;
name|last_char_was_newline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|html
condition|)
comment|/* Kludge alert: if<pre> is followed by a newline, IE3            renders an extra blank line before the pre-formatted block.            Other browsers seem to not mind one way or the other.  */
name|add_word_args
argument_list|(
literal|"<pre class=\"%s\">"
argument_list|,
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|format
operator|&&
name|type
operator|!=
name|smallformat
condition|)
block|{
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
if|if
condition|(
name|html
condition|)
block|{
comment|/* Since we didn't put \n after<pre>, we need to insert                  the indentation by hand.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|current_indent
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|add_char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|multitable
case|:
name|do_multitable
argument_list|()
expr_stmt|;
break|break;
case|case
name|table
case|:
case|case
name|ftable
case|:
case|case
name|vtable
case|:
case|case
name|itemize
case|:
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INDENT_PARAGRAPHS_IN_TABLE
argument_list|)
name|inhibit_paragraph_indentation
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* !INDENT_PARAGRAPHS_IN_TABLE */
comment|/* Make things work for losers who forget the itemize syntax. */
if|if
condition|(
name|type
operator|==
name|itemize
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|insertion_stack
operator|->
name|item_function
operator|)
condition|)
block|{
name|free
argument_list|(
name|insertion_stack
operator|->
name|item_function
argument_list|)
expr_stmt|;
name|insertion_stack
operator|->
name|item_function
operator|=
name|xstrdup
argument_list|(
literal|"@bullet"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|insertion_stack
operator|->
name|item_function
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"%s requires an argument: the formatter for %citem"
argument_list|)
argument_list|,
name|insertion_type_pname
argument_list|(
name|type
argument_list|)
argument_list|,
name|COMMAND_PREFIX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|html
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|itemize
condition|)
block|{
name|add_word
argument_list|(
literal|"<ul>\n"
argument_list|)
expr_stmt|;
name|in_paragraph
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|add_word
argument_list|(
name|dl_tag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xml
condition|)
name|xml_begin_table
argument_list|(
name|type
argument_list|,
name|insertion_stack
operator|->
name|item_function
argument_list|)
expr_stmt|;
break|break;
case|case
name|enumerate
case|:
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|no_indent
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INDENT_PARAGRAPHS_IN_TABLE
argument_list|)
name|inhibit_paragraph_indentation
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* !INDENT_PARAGRAPHS_IN_TABLE */
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|html
condition|)
block|{
name|enum_html
argument_list|()
expr_stmt|;
name|in_paragraph
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|xml
condition|)
name|xml_begin_enumerate
argument_list|(
name|enumeration_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|enumeration_arg
argument_list|)
condition|)
name|start_enumerating
argument_list|(
name|atoi
argument_list|(
name|enumeration_arg
argument_list|)
argument_list|,
name|ENUM_DIGITS
argument_list|)
expr_stmt|;
else|else
name|start_enumerating
argument_list|(
operator|*
name|enumeration_arg
argument_list|,
name|ENUM_ALPHA
argument_list|)
expr_stmt|;
break|break;
comment|/* @group does nothing special in makeinfo. */
case|case
name|group
case|:
comment|/* Only close the paragraph if we are not inside of an          @example-like environment. */
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|GROUP
argument_list|,
name|START
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|insertion_stack
operator|->
name|next
operator|||
operator|(
name|insertion_stack
operator|->
name|next
operator|->
name|insertion
operator|!=
name|display
operator|&&
name|insertion_stack
operator|->
name|next
operator|->
name|insertion
operator|!=
name|smalldisplay
operator|&&
name|insertion_stack
operator|->
name|next
operator|->
name|insertion
operator|!=
name|example
operator|&&
name|insertion_stack
operator|->
name|next
operator|->
name|insertion
operator|!=
name|smallexample
operator|&&
name|insertion_stack
operator|->
name|next
operator|->
name|insertion
operator|!=
name|lisp
operator|&&
name|insertion_stack
operator|->
name|next
operator|->
name|insertion
operator|!=
name|smalllisp
operator|&&
name|insertion_stack
operator|->
name|next
operator|->
name|insertion
operator|!=
name|format
operator|&&
name|insertion_stack
operator|->
name|next
operator|->
name|insertion
operator|!=
name|smallformat
operator|&&
name|insertion_stack
operator|->
name|next
operator|->
name|insertion
operator|!=
name|flushleft
operator|&&
name|insertion_stack
operator|->
name|next
operator|->
name|insertion
operator|!=
name|flushright
operator|)
condition|)
name|close_single_paragraph
argument_list|()
expr_stmt|;
break|break;
comment|/* Insertions that are no-ops in info, but do something in TeX. */
case|case
name|cartouche
case|:
case|case
name|ifclear
case|:
case|case
name|ifhtml
case|:
case|case
name|ifinfo
case|:
case|case
name|ifnothtml
case|:
case|case
name|ifnotinfo
case|:
case|case
name|ifnotplaintext
case|:
case|case
name|ifnottex
case|:
case|case
name|ifnotxml
case|:
case|case
name|ifplaintext
case|:
case|case
name|ifset
case|:
case|case
name|iftex
case|:
case|case
name|ifxml
case|:
case|case
name|rawtex
case|:
if|if
condition|(
name|in_menu
condition|)
name|no_discard
operator|++
expr_stmt|;
break|break;
case|case
name|rawhtml
case|:
name|escape_html
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|defcv
case|:
case|case
name|deffn
case|:
case|case
name|defivar
case|:
case|case
name|defmac
case|:
case|case
name|defmethod
case|:
case|case
name|defop
case|:
case|case
name|defopt
case|:
case|case
name|defspec
case|:
case|case
name|deftp
case|:
case|case
name|deftypefn
case|:
case|case
name|deftypefun
case|:
case|case
name|deftypeivar
case|:
case|case
name|deftypemethod
case|:
case|case
name|deftypeop
case|:
case|case
name|deftypevar
case|:
case|case
name|deftypevr
case|:
case|case
name|defun
case|:
case|case
name|defvar
case|:
case|case
name|defvr
case|:
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|1
expr_stmt|;
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
name|no_indent
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|flushleft
case|:
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
name|no_indent
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"<div align=\"left\">"
argument_list|)
expr_stmt|;
break|break;
case|case
name|flushright
case|:
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
name|no_indent
operator|=
literal|0
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|force_flush_right
operator|++
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"<div align=\"right\">"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|line_error
argument_list|(
literal|"begin_insertion internal error: type=%d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|no_discard
condition|)
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try to end the insertion with the specified TYPE.  With a value of    `bad_type', TYPE gets translated to match the value currently on top    of the stack.  Otherwise, if TYPE doesn't match the top of the    insertion stack, give error. */
end_comment

begin_function
name|void
name|end_insertion
parameter_list|(
name|type
parameter_list|)
name|enum
name|insertion_type
name|type
decl_stmt|;
block|{
name|enum
name|insertion_type
name|temp_type
decl_stmt|;
if|if
condition|(
operator|!
name|insertion_level
condition|)
return|return;
name|temp_type
operator|=
name|current_insertion_type
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|bad_type
condition|)
name|type
operator|=
name|temp_type
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|temp_type
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"`@end' expected `%s', but saw `%s'"
argument_list|)
argument_list|,
name|insertion_type_pname
argument_list|(
name|temp_type
argument_list|)
argument_list|,
name|insertion_type_pname
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|pop_insertion
argument_list|()
expr_stmt|;
if|if
condition|(
name|xml
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ifinfo
case|:
case|case
name|documentdescription
case|:
break|break;
case|case
name|copying
case|:
name|xml_insert_element
argument_list|(
name|COPYING
argument_list|,
name|END
argument_list|)
expr_stmt|;
break|break;
case|case
name|quotation
case|:
name|xml_insert_element
argument_list|(
name|QUOTATION
argument_list|,
name|END
argument_list|)
expr_stmt|;
break|break;
case|case
name|example
case|:
name|xml_insert_element
argument_list|(
name|EXAMPLE
argument_list|,
name|END
argument_list|)
expr_stmt|;
break|break;
case|case
name|smallexample
case|:
name|xml_insert_element
argument_list|(
name|SMALLEXAMPLE
argument_list|,
name|END
argument_list|)
expr_stmt|;
break|break;
case|case
name|lisp
case|:
name|xml_insert_element
argument_list|(
name|LISP
argument_list|,
name|END
argument_list|)
expr_stmt|;
break|break;
case|case
name|smalllisp
case|:
name|xml_insert_element
argument_list|(
name|SMALLLISP
argument_list|,
name|END
argument_list|)
expr_stmt|;
break|break;
case|case
name|cartouche
case|:
name|xml_insert_element
argument_list|(
name|CARTOUCHE
argument_list|,
name|END
argument_list|)
expr_stmt|;
break|break;
case|case
name|format
case|:
if|if
condition|(
name|docbook
operator|&&
name|xml_in_bookinfo
operator|&&
name|xml_in_abstract
condition|)
block|{
name|xml_insert_element
argument_list|(
name|ABSTRACT
argument_list|,
name|END
argument_list|)
expr_stmt|;
name|xml_in_abstract
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|xml_insert_element
argument_list|(
name|FORMAT
argument_list|,
name|END
argument_list|)
expr_stmt|;
break|break;
case|case
name|smallformat
case|:
name|xml_insert_element
argument_list|(
name|SMALLFORMAT
argument_list|,
name|END
argument_list|)
expr_stmt|;
break|break;
case|case
name|display
case|:
name|xml_insert_element
argument_list|(
name|DISPLAY
argument_list|,
name|END
argument_list|)
expr_stmt|;
break|break;
case|case
name|smalldisplay
case|:
name|xml_insert_element
argument_list|(
name|SMALLDISPLAY
argument_list|,
name|END
argument_list|)
expr_stmt|;
break|break;
case|case
name|table
case|:
case|case
name|ftable
case|:
case|case
name|vtable
case|:
case|case
name|itemize
case|:
name|xml_end_table
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|enumerate
case|:
name|xml_end_enumerate
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|group
case|:
name|xml_insert_element
argument_list|(
name|GROUP
argument_list|,
name|END
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
name|type
condition|)
block|{
comment|/* Insertions which have no effect on paragraph formatting. */
case|case
name|copying
case|:
case|case
name|documentdescription
case|:
case|case
name|ifclear
case|:
case|case
name|ifinfo
case|:
case|case
name|ifhtml
case|:
case|case
name|ifnothtml
case|:
case|case
name|ifnotinfo
case|:
case|case
name|ifnotplaintext
case|:
case|case
name|ifnottex
case|:
case|case
name|ifnotxml
case|:
case|case
name|ifplaintext
case|:
case|case
name|ifset
case|:
case|case
name|iftex
case|:
case|case
name|ifxml
case|:
case|case
name|rawtex
case|:
break|break;
case|case
name|rawhtml
case|:
name|escape_html
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|detailmenu
case|:
name|in_detailmenu
operator|--
expr_stmt|;
comment|/* No longer hacking menus. */
if|if
condition|(
operator|!
name|in_menu
condition|)
block|{
if|if
condition|(
operator|!
name|no_headers
condition|)
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|direntry
case|:
comment|/* Eaten if html. */
name|insert_string
argument_list|(
literal|"END-INFO-DIR-ENTRY\n\n"
argument_list|)
expr_stmt|;
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
break|break;
case|case
name|menu
case|:
name|in_menu
operator|--
expr_stmt|;
comment|/* No longer hacking menus. */
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"</ul>\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|no_headers
condition|)
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
break|break;
case|case
name|multitable
case|:
name|end_multitable
argument_list|()
expr_stmt|;
break|break;
case|case
name|enumerate
case|:
name|stop_enumerating
argument_list|()
expr_stmt|;
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"</ol>\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|flushleft
case|:
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"</div>\n"
argument_list|)
expr_stmt|;
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
break|break;
case|case
name|group
case|:
case|case
name|cartouche
case|:
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
break|break;
case|case
name|format
case|:
case|case
name|smallformat
case|:
case|case
name|display
case|:
case|case
name|smalldisplay
case|:
case|case
name|example
case|:
case|case
name|smallexample
case|:
case|case
name|lisp
case|:
case|case
name|smalllisp
case|:
case|case
name|quotation
case|:
comment|/* @format and @smallformat are the only fixed_width insertion          without a change in indentation. */
if|if
condition|(
name|type
operator|!=
name|format
operator|&&
name|type
operator|!=
name|smallformat
condition|)
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
name|type
operator|==
name|quotation
condition|?
literal|"</blockquote>\n"
else|:
literal|"</pre>\n"
argument_list|)
expr_stmt|;
comment|/* The ending of one of these insertions always marks the          start of a new paragraph. */
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
break|break;
case|case
name|table
case|:
case|case
name|ftable
case|:
case|case
name|vtable
case|:
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"</dl>\n"
argument_list|)
expr_stmt|;
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
break|break;
case|case
name|itemize
case|:
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"</ul>\n"
argument_list|)
expr_stmt|;
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
break|break;
case|case
name|flushright
case|:
name|force_flush_right
operator|--
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"</div>\n"
argument_list|)
expr_stmt|;
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
break|break;
comment|/* Handle the @defun insertions with this default clause. */
default|default:
block|{
name|enum
name|insertion_type
name|base_type
decl_stmt|;
if|if
condition|(
name|type
operator|<
name|defcv
operator|||
name|type
operator|>
name|defvr
condition|)
name|line_error
argument_list|(
literal|"end_insertion internal error: type=%d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|base_type
operator|=
name|get_base_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|deffn
case|:
case|case
name|defvr
case|:
case|case
name|deftp
case|:
case|case
name|deftypefn
case|:
case|case
name|deftypevr
case|:
case|case
name|defcv
case|:
case|case
name|defop
case|:
case|case
name|deftypemethod
case|:
case|case
name|deftypeop
case|:
case|case
name|deftypeivar
case|:
if|if
condition|(
name|html
condition|)
comment|/* close the tables which has been opened in defun.c */
name|add_word
argument_list|(
literal|"</td></tr>\n</table>\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch (base_type)... */
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|current_indent
operator|<
literal|0
condition|)
name|line_error
argument_list|(
literal|"end_insertion internal error: current indent=%d"
argument_list|,
name|current_indent
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insertions cannot cross certain boundaries, such as node beginnings.  In    code that creates such boundaries, you should call `discard_insertions'    before doing anything else.  It prints the errors for you, and cleans up    the insertion stack.     With nonzero SPECIALS_OK argument, allows unmatched    @if... conditionals, otherwise not.  This is because conditionals can    cross node boundaries.  Always happens with the @top node, for example.  */
end_comment

begin_function
name|void
name|discard_insertions
parameter_list|(
name|specials_ok
parameter_list|)
name|int
name|specials_ok
decl_stmt|;
block|{
name|int
name|real_line_number
init|=
name|line_number
decl_stmt|;
while|while
condition|(
name|insertion_stack
condition|)
block|{
if|if
condition|(
name|specials_ok
operator|&&
operator|(
operator|(
name|ifclear
operator|<=
name|insertion_stack
operator|->
name|insertion
operator|&&
name|insertion_stack
operator|->
name|insertion
operator|<=
name|iftex
operator|)
operator|||
name|insertion_stack
operator|->
name|insertion
operator|==
name|rawhtml
operator|||
name|insertion_stack
operator|->
name|insertion
operator|==
name|rawtex
operator|)
condition|)
break|break;
else|else
block|{
name|char
modifier|*
name|offender
init|=
name|insertion_type_pname
argument_list|(
name|insertion_stack
operator|->
name|insertion
argument_list|)
decl_stmt|;
name|file_line_error
argument_list|(
name|insertion_stack
operator|->
name|filename
argument_list|,
name|insertion_stack
operator|->
name|line_number
argument_list|,
name|_
argument_list|(
literal|"No matching `%cend %s'"
argument_list|)
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|offender
argument_list|)
expr_stmt|;
name|pop_insertion
argument_list|()
expr_stmt|;
block|}
block|}
name|line_number
operator|=
name|real_line_number
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Insertion (environment) commands.  */
end_comment

begin_function
name|void
name|cm_quotation
parameter_list|()
block|{
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|QUOTATION
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|begin_insertion
argument_list|(
name|quotation
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_example
parameter_list|()
block|{
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|EXAMPLE
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|begin_insertion
argument_list|(
name|example
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_smallexample
parameter_list|()
block|{
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|SMALLEXAMPLE
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|begin_insertion
argument_list|(
name|smallexample
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_lisp
parameter_list|()
block|{
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|LISP
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|begin_insertion
argument_list|(
name|lisp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_smalllisp
parameter_list|()
block|{
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|SMALLLISP
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|begin_insertion
argument_list|(
name|smalllisp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_cartouche
parameter_list|()
block|{
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|CARTOUCHE
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|begin_insertion
argument_list|(
name|cartouche
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_copying
parameter_list|()
block|{
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|COPYING
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|begin_insertion
argument_list|(
name|copying
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Not an insertion, despite the name, but it goes with cm_copying.  */
end_comment

begin_function
name|void
name|cm_insert_copying
parameter_list|()
block|{
if|if
condition|(
name|copying_text
condition|)
block|{
comment|/* insert_string rather than add_word because we've already done          full expansion on copying_text when we saved it.  */
name|insert_string
argument_list|(
name|copying_text
argument_list|)
expr_stmt|;
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* Update output_position so that the node positions in the tag          tables will take account of the copying text.  */
name|flush_output
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|cm_format
parameter_list|()
block|{
if|if
condition|(
name|xml
condition|)
block|{
if|if
condition|(
name|docbook
operator|&&
name|xml_in_bookinfo
condition|)
block|{
name|xml_insert_element
argument_list|(
name|ABSTRACT
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|xml_in_abstract
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|xml_insert_element
argument_list|(
name|FORMAT
argument_list|,
name|START
argument_list|)
expr_stmt|;
block|}
name|begin_insertion
argument_list|(
name|format
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_smallformat
parameter_list|()
block|{
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|SMALLFORMAT
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|begin_insertion
argument_list|(
name|smallformat
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_display
parameter_list|()
block|{
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|DISPLAY
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|begin_insertion
argument_list|(
name|display
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_smalldisplay
parameter_list|()
block|{
if|if
condition|(
name|xml
condition|)
name|xml_insert_element
argument_list|(
name|SMALLDISPLAY
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|begin_insertion
argument_list|(
name|smalldisplay
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_direntry
parameter_list|()
block|{
if|if
condition|(
name|html
operator|||
name|xml
condition|)
name|command_name_condition
argument_list|()
expr_stmt|;
else|else
name|begin_insertion
argument_list|(
name|direntry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_documentdescription
parameter_list|()
block|{
if|if
condition|(
name|html
operator|||
name|xml
condition|)
name|begin_insertion
argument_list|(
name|documentdescription
argument_list|)
expr_stmt|;
else|else
name|command_name_condition
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_itemize
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|itemize
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start an enumeration insertion of type TYPE.  If the user supplied    no argument on the line, then use DEFAULT_STRING as the initial string. */
end_comment

begin_function
specifier|static
name|void
name|do_enumeration
parameter_list|(
name|type
parameter_list|,
name|default_string
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|default_string
decl_stmt|;
block|{
name|get_until_in_line
argument_list|(
literal|0
argument_list|,
literal|"."
argument_list|,
operator|&
name|enumeration_arg
argument_list|)
expr_stmt|;
name|canon_white
argument_list|(
name|enumeration_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|enumeration_arg
condition|)
block|{
name|free
argument_list|(
name|enumeration_arg
argument_list|)
expr_stmt|;
name|enumeration_arg
operator|=
name|xstrdup
argument_list|(
name|default_string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|enumeration_arg
argument_list|)
operator|&&
operator|!
name|isletter
argument_list|(
operator|*
name|enumeration_arg
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|_
argument_list|(
literal|"%s requires letter or digit"
argument_list|)
argument_list|,
name|insertion_type_pname
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|enumerate
case|:
name|default_string
operator|=
literal|"1"
expr_stmt|;
break|break;
block|}
name|enumeration_arg
operator|=
name|xstrdup
argument_list|(
name|default_string
argument_list|)
expr_stmt|;
block|}
name|begin_insertion
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_enumerate
parameter_list|()
block|{
name|do_enumeration
argument_list|(
name|enumerate
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Handle verbatim environment:     find_end_verbatim == 0:  process until end of file     find_end_verbatim != 0:  process until 'COMMAND_PREFIXend verbatim'                              or end of file    We cannot simply copy input stream onto output stream; as the   verbatim environment may be encapsulated in an @example environment,   for example. */
end_comment

begin_function
name|void
name|handle_verbatim_environment
parameter_list|(
name|find_end_verbatim
parameter_list|)
name|int
name|find_end_verbatim
decl_stmt|;
block|{
name|int
name|character
decl_stmt|;
name|int
name|seen_end
init|=
literal|0
decl_stmt|;
name|int
name|save_filling_enabled
init|=
name|filling_enabled
decl_stmt|;
name|int
name|save_inhibit_paragraph_indentation
init|=
name|inhibit_paragraph_indentation
decl_stmt|;
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|filling_enabled
operator|=
literal|0
expr_stmt|;
name|in_fixed_width_font
operator|++
expr_stmt|;
name|last_char_was_newline
operator|=
literal|0
expr_stmt|;
comment|/* No indentation: this is verbatim after all      If you want indent, enclose @verbatim in @example        current_indent += default_indentation_increment;    */
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"<pre class=\"verbatim\">"
argument_list|)
expr_stmt|;
while|while
condition|(
name|input_text_offset
operator|<
name|input_text_length
condition|)
block|{
name|character
operator|=
name|curchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|character
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
comment|/*         Assume no newlines in END_VERBATIM       */
elseif|else
if|if
condition|(
name|find_end_verbatim
operator|&&
operator|(
name|character
operator|==
name|COMMAND_PREFIX
operator|)
comment|/* @ */
operator|&&
operator|(
name|input_text_length
operator|-
name|input_text_offset
operator|>
sizeof|sizeof
argument_list|(
name|END_VERBATIM
argument_list|)
operator|)
operator|&&
operator|!
name|strncmp
argument_list|(
operator|&
name|input_text
index|[
name|input_text_offset
operator|+
literal|1
index|]
argument_list|,
name|END_VERBATIM
argument_list|,
sizeof|sizeof
argument_list|(
name|END_VERBATIM
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
name|input_text_offset
operator|+=
sizeof|sizeof
argument_list|(
name|END_VERBATIM
argument_list|)
expr_stmt|;
name|seen_end
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|html
operator|&&
name|character
operator|==
literal|'&'
operator|&&
name|escape_html
condition|)
name|add_word
argument_list|(
literal|"&amp;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|html
operator|&&
name|character
operator|==
literal|'<'
operator|&&
name|escape_html
condition|)
name|add_word
argument_list|(
literal|"&lt;"
argument_list|)
expr_stmt|;
else|else
name|add_char
argument_list|(
name|character
argument_list|)
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|find_end_verbatim
operator|&&
operator|!
name|seen_end
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"end of file inside verbatim block"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"</pre>"
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|--
expr_stmt|;
name|filling_enabled
operator|=
name|save_filling_enabled
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
name|save_inhibit_paragraph_indentation
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_verbatim
parameter_list|()
block|{
name|handle_verbatim_environment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_table
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_multitable
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|multitable
argument_list|)
expr_stmt|;
comment|/* @@ */
block|}
end_function

begin_function
name|void
name|cm_ftable
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|ftable
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_vtable
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|vtable
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_group
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Insert raw HTML (no escaping of `<' etc.). */
end_comment

begin_function
name|void
name|cm_html
parameter_list|()
block|{
if|if
condition|(
name|process_html
operator|||
name|process_xml
condition|)
name|begin_insertion
argument_list|(
name|rawhtml
argument_list|)
expr_stmt|;
else|else
name|command_name_condition
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_ifhtml
parameter_list|()
block|{
if|if
condition|(
name|process_html
condition|)
name|begin_insertion
argument_list|(
name|ifhtml
argument_list|)
expr_stmt|;
else|else
name|command_name_condition
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_ifnothtml
parameter_list|()
block|{
if|if
condition|(
operator|!
name|process_html
condition|)
name|begin_insertion
argument_list|(
name|ifnothtml
argument_list|)
expr_stmt|;
else|else
name|command_name_condition
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_ifinfo
parameter_list|()
block|{
if|if
condition|(
name|process_info
condition|)
name|begin_insertion
argument_list|(
name|ifinfo
argument_list|)
expr_stmt|;
else|else
name|command_name_condition
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_ifnotinfo
parameter_list|()
block|{
if|if
condition|(
operator|!
name|process_info
condition|)
name|begin_insertion
argument_list|(
name|ifnotinfo
argument_list|)
expr_stmt|;
else|else
name|command_name_condition
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_ifplaintext
parameter_list|()
block|{
if|if
condition|(
name|process_plaintext
condition|)
name|begin_insertion
argument_list|(
name|ifplaintext
argument_list|)
expr_stmt|;
else|else
name|command_name_condition
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_ifnotplaintext
parameter_list|()
block|{
if|if
condition|(
operator|!
name|process_plaintext
condition|)
name|begin_insertion
argument_list|(
name|ifnotplaintext
argument_list|)
expr_stmt|;
else|else
name|command_name_condition
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_tex
parameter_list|()
block|{
if|if
condition|(
name|process_tex
condition|)
name|begin_insertion
argument_list|(
name|rawtex
argument_list|)
expr_stmt|;
else|else
name|command_name_condition
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_iftex
parameter_list|()
block|{
if|if
condition|(
name|process_tex
condition|)
name|begin_insertion
argument_list|(
name|iftex
argument_list|)
expr_stmt|;
else|else
name|command_name_condition
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_ifnottex
parameter_list|()
block|{
if|if
condition|(
operator|!
name|process_tex
condition|)
name|begin_insertion
argument_list|(
name|ifnottex
argument_list|)
expr_stmt|;
else|else
name|command_name_condition
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_ifxml
parameter_list|()
block|{
if|if
condition|(
name|process_xml
condition|)
name|begin_insertion
argument_list|(
name|ifxml
argument_list|)
expr_stmt|;
else|else
name|command_name_condition
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_ifnotxml
parameter_list|()
block|{
if|if
condition|(
operator|!
name|process_xml
condition|)
name|begin_insertion
argument_list|(
name|ifnotxml
argument_list|)
expr_stmt|;
else|else
name|command_name_condition
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Begin an insertion where the lines are not filled or indented. */
end_comment

begin_function
name|void
name|cm_flushleft
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|flushleft
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin an insertion where the lines are not filled, and each line is    forced to the right-hand side of the page. */
end_comment

begin_function
name|void
name|cm_flushright
parameter_list|()
block|{
name|begin_insertion
argument_list|(
name|flushright
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_menu
parameter_list|()
block|{
if|if
condition|(
name|current_node
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
name|_
argument_list|(
literal|"@menu seen before first @node, creating `Top' node"
argument_list|)
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|_
argument_list|(
literal|"perhaps your @top node should be wrapped in @ifnottex rather than @ifinfo?"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Include @top command so we can construct the implicit node tree.  */
name|execute_string
argument_list|(
literal|"@node top\n@top Top\n"
argument_list|)
expr_stmt|;
block|}
name|begin_insertion
argument_list|(
name|menu
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_detailmenu
parameter_list|()
block|{
if|if
condition|(
name|current_node
operator|==
name|NULL
condition|)
block|{
comment|/* Problems anyway, @detailmenu should always be inside @menu.  */
name|warning
argument_list|(
name|_
argument_list|(
literal|"@detailmenu seen before first node, creating `Top' node"
argument_list|)
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"@node top\n@top Top\n"
argument_list|)
expr_stmt|;
block|}
name|begin_insertion
argument_list|(
name|detailmenu
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* End existing insertion block. */
end_comment

begin_function
name|void
name|cm_end
parameter_list|()
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|enum
name|insertion_type
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|insertion_level
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Unmatched `%c%s'"
argument_list|)
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
return|return;
block|}
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|line_error
argument_list|(
name|_
argument_list|(
literal|"`%c%s' needs something after it"
argument_list|)
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|type
operator|=
name|find_type_from_name
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|bad_type
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Bad argument to `%s', `%s', using `%s'"
argument_list|)
argument_list|,
name|command
argument_list|,
name|temp
argument_list|,
name|insertion_type_pname
argument_list|(
name|current_insertion_type
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xml
operator|&&
name|type
operator|==
name|menu
condition|)
comment|/* fixme */
block|{
name|xml_end_menu
argument_list|()
expr_stmt|;
block|}
name|end_insertion
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* @itemx, @item. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|itemx_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return whether CMD takes a brace-delimited {arg}.  */
end_comment

begin_comment
comment|/*static */
end_comment

begin_function
name|int
name|command_needs_braces
parameter_list|(
name|cmd
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|command_table
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|command_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|cmd
argument_list|)
condition|)
return|return
name|command_table
index|[
name|i
index|]
operator|.
name|argument_in_braces
operator|==
name|BRACE_ARGS
return|;
block|}
return|return
literal|0
return|;
comment|/* macro or alias */
block|}
end_function

begin_function
name|void
name|cm_item
parameter_list|()
block|{
name|char
modifier|*
name|rest_of_line
decl_stmt|,
modifier|*
name|item_func
decl_stmt|;
comment|/* Can only hack "@item" while inside of an insertion. */
if|if
condition|(
name|insertion_level
condition|)
block|{
name|INSERTION_ELT
modifier|*
name|stack
init|=
name|insertion_stack
decl_stmt|;
name|int
name|original_input_text_offset
decl_stmt|;
name|skip_whitespace
argument_list|()
expr_stmt|;
name|original_input_text_offset
operator|=
name|input_text_offset
expr_stmt|;
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|rest_of_line
argument_list|)
expr_stmt|;
name|item_func
operator|=
name|current_item_function
argument_list|()
expr_stmt|;
comment|/* Do the right thing depending on which insertion function is active. */
name|switch_top
label|:
switch|switch
condition|(
name|stack
operator|->
name|insertion
condition|)
block|{
case|case
name|multitable
case|:
name|multitable_item
argument_list|()
expr_stmt|;
comment|/* Support text directly after the @item.  */
if|if
condition|(
operator|*
name|rest_of_line
condition|)
block|{
name|line_number
operator|--
expr_stmt|;
name|input_text_offset
operator|=
name|original_input_text_offset
expr_stmt|;
block|}
break|break;
case|case
name|ifclear
case|:
case|case
name|ifhtml
case|:
case|case
name|ifinfo
case|:
case|case
name|ifnothtml
case|:
case|case
name|ifnotinfo
case|:
case|case
name|ifnotplaintext
case|:
case|case
name|ifnottex
case|:
case|case
name|ifnotxml
case|:
case|case
name|ifplaintext
case|:
case|case
name|ifset
case|:
case|case
name|iftex
case|:
case|case
name|ifxml
case|:
case|case
name|rawhtml
case|:
case|case
name|rawtex
case|:
case|case
name|tex
case|:
case|case
name|cartouche
case|:
name|stack
operator|=
name|stack
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|stack
condition|)
goto|goto
name|no_insertion
goto|;
else|else
goto|goto
name|switch_top
goto|;
break|break;
case|case
name|menu
case|:
case|case
name|quotation
case|:
case|case
name|example
case|:
case|case
name|smallexample
case|:
case|case
name|lisp
case|:
case|case
name|smalllisp
case|:
case|case
name|format
case|:
case|case
name|smallformat
case|:
case|case
name|display
case|:
case|case
name|smalldisplay
case|:
case|case
name|group
case|:
name|line_error
argument_list|(
name|_
argument_list|(
literal|"@%s not meaningful inside `@%s' block"
argument_list|)
argument_list|,
name|command
argument_list|,
name|insertion_type_pname
argument_list|(
name|current_insertion_type
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|itemize
case|:
case|case
name|enumerate
case|:
if|if
condition|(
name|itemx_flag
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"@itemx not meaningful inside `%s' block"
argument_list|)
argument_list|,
name|insertion_type_pname
argument_list|(
name|current_insertion_type
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|html
condition|)
block|{
if|if
condition|(
name|in_paragraph
condition|)
block|{
name|add_word
argument_list|(
literal|"</p>"
argument_list|)
expr_stmt|;
name|in_paragraph
operator|=
literal|0
expr_stmt|;
block|}
name|add_word
argument_list|(
literal|"<li>"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xml
condition|)
name|xml_begin_item
argument_list|()
expr_stmt|;
else|else
block|{
name|start_paragraph
argument_list|()
expr_stmt|;
name|kill_self_indent
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|current_item_function
argument_list|()
condition|)
block|{
name|output_column
operator|=
name|current_indent
operator|-
literal|2
expr_stmt|;
name|indent
argument_list|(
name|output_column
argument_list|)
expr_stmt|;
comment|/* The item marker can be given with or without                          braces -- @bullet and @bullet{} are both ok.                          Or it might be something that doesn't take                          braces at all, such as "o" or "#" or "@ ".                          Thus, only supply braces if the item marker is                          a command, they haven't supplied braces                          themselves, and we know it needs them.  */
if|if
condition|(
name|item_func
operator|&&
operator|*
name|item_func
condition|)
block|{
if|if
condition|(
operator|*
name|item_func
operator|==
name|COMMAND_PREFIX
operator|&&
name|item_func
index|[
name|strlen
argument_list|(
name|item_func
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'}'
operator|&&
name|command_needs_braces
argument_list|(
name|item_func
operator|+
literal|1
argument_list|)
condition|)
name|execute_string
argument_list|(
literal|"%s{}"
argument_list|,
name|item_func
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|item_func
argument_list|)
expr_stmt|;
block|}
name|insert
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|output_column
operator|++
expr_stmt|;
block|}
else|else
name|enumerate_item
argument_list|()
expr_stmt|;
comment|/* Special hack.  This makes `close_paragraph' a no-op until                      `start_paragraph' has been called. */
name|must_start_paragraph
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Handle text directly after the @item.  */
if|if
condition|(
operator|*
name|rest_of_line
condition|)
block|{
name|line_number
operator|--
expr_stmt|;
name|input_text_offset
operator|=
name|original_input_text_offset
expr_stmt|;
block|}
block|}
break|break;
case|case
name|table
case|:
case|case
name|ftable
case|:
case|case
name|vtable
case|:
if|if
condition|(
name|html
condition|)
block|{
specifier|static
name|int
name|last_html_output_position
init|=
literal|0
decl_stmt|;
comment|/* If nothing has been output since the last<dd>,                  remove the empty<dd> element.  Some browsers render                  an extra empty line for<dd><dt>, which makes @itemx                  conversion look ugly.  */
if|if
condition|(
name|last_html_output_position
operator|==
name|output_position
operator|&&
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|output_paragraph
argument_list|,
literal|"<dd>"
argument_list|,
name|output_paragraph_offset
argument_list|)
operator|==
literal|0
condition|)
name|output_paragraph_offset
operator|=
literal|0
expr_stmt|;
comment|/* Force the browser to render one blank line before                  each new @item in a table.  But don't do that if                  this is the first<dt> after the<dl>, or if we are                  converting @itemx.                   Note that there are some browsers which ignore<br>                  in this context, but I cannot find any way to force                  them all render exactly one blank line.  */
if|if
condition|(
operator|!
name|itemx_flag
operator|&&
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|output_paragraph
operator|+
name|output_paragraph_offset
operator|-
sizeof|sizeof
argument_list|(
name|dl_tag
argument_list|)
operator|+
literal|1
argument_list|,
name|dl_tag
argument_list|,
sizeof|sizeof
argument_list|(
name|dl_tag
argument_list|)
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|add_word
argument_list|(
literal|"<br>"
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"<dt>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|item_func
operator|&&
operator|*
name|item_func
condition|)
name|execute_string
argument_list|(
literal|"%s{%s}"
argument_list|,
name|item_func
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_insertion_type
argument_list|()
operator|==
name|ftable
condition|)
name|execute_string
argument_list|(
literal|"%cfindex %s\n"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_insertion_type
argument_list|()
operator|==
name|vtable
condition|)
name|execute_string
argument_list|(
literal|"%cvindex %s\n"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
comment|/* Make sure output_position is updated, so we could                  remember it.  */
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|last_html_output_position
operator|=
name|output_position
expr_stmt|;
name|add_word
argument_list|(
literal|"<dd>"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xml
condition|)
comment|/*&& docbook)*/
comment|/* 05-08 */
block|{
name|xml_begin_table_item
argument_list|()
expr_stmt|;
if|if
condition|(
name|item_func
operator|&&
operator|*
name|item_func
condition|)
name|execute_string
argument_list|(
literal|"%s{%s}"
argument_list|,
name|item_func
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
name|xml_continue_table_item
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* We need this to determine if we have two @item's in a row                  (see test just below).  */
specifier|static
name|int
name|last_item_output_position
init|=
literal|0
decl_stmt|;
comment|/* Get rid of extra characters. */
name|kill_self_indent
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* If we have one @item followed directly by another @item,                  we need to insert a blank line.  This is not true for                  @itemx, though.  */
if|if
condition|(
operator|!
name|itemx_flag
operator|&&
name|last_item_output_position
operator|==
name|output_position
condition|)
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* `close_paragraph' almost does what we want.  The problem                  is when paragraph_is_open, and last_char_was_newline, and                  the last newline has been turned into a space, because                  filling_enabled. I handle it here. */
if|if
condition|(
name|last_char_was_newline
operator|&&
name|filling_enabled
operator|&&
name|paragraph_is_open
condition|)
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INDENT_PARAGRAPHS_IN_TABLE
argument_list|)
comment|/* Indent on a new line, but back up one indentation level. */
block|{
name|int
name|save
init|=
name|inhibit_paragraph_indentation
decl_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
comment|/* At this point, inserting any non-whitespace character will                    force the existing indentation to be output. */
name|add_char
argument_list|(
literal|'i'
argument_list|)
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
name|save
expr_stmt|;
block|}
else|#
directive|else
comment|/* !INDENT_PARAGRAPHS_IN_TABLE */
name|add_char
argument_list|(
literal|'i'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !INDENT_PARAGRAPHS_IN_TABLE */
name|output_paragraph_offset
operator|--
expr_stmt|;
name|kill_self_indent
argument_list|(
name|default_indentation_increment
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Add item's argument to the line. */
name|filling_enabled
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|item_func
operator|&&
operator|*
name|item_func
condition|)
name|execute_string
argument_list|(
literal|"%s{%s}"
argument_list|,
name|item_func
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_insertion_type
argument_list|()
operator|==
name|ftable
condition|)
name|execute_string
argument_list|(
literal|"%cfindex %s\n"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_insertion_type
argument_list|()
operator|==
name|vtable
condition|)
name|execute_string
argument_list|(
literal|"%cvindex %s\n"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
comment|/* Start a new line, and let start_paragraph ()                  do the indenting of it for you. */
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|indented_fill
operator|=
name|filling_enabled
operator|=
literal|1
expr_stmt|;
name|last_item_output_position
operator|=
name|output_position
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|rest_of_line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|no_insertion
label|:
name|line_error
argument_list|(
name|_
argument_list|(
literal|"%c%s found outside of an insertion block"
argument_list|)
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|cm_itemx
parameter_list|()
block|{
name|itemx_flag
operator|++
expr_stmt|;
name|cm_item
argument_list|()
expr_stmt|;
name|itemx_flag
operator|--
expr_stmt|;
block|}
end_function

end_unit

