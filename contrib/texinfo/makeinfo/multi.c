begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* multi.c -- Multitable stuff for makeinfo.    $Id: multi.c,v 1.7 1996/10/01 21:42:20 karl Exp $     Copyright (C) 1996 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"makeinfo.h"
end_include

begin_define
define|#
directive|define
name|MAXCOLS
value|100
end_define

begin_comment
comment|/* remove this limit later @@ */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * Output environments.  This is a hack grafted onto existing  * structure.  The "output environment" used to consist of the  * global variables `output_paragraph', `fill_column', etc.  * Routines like add_char would manipulate these variables.  *  * Now, when formatting a multitable, we maintain separate environments  * for each column.  That way we can build up the columns separately  * and write them all out at once.  The "current" output environment"  * is still kept in those global variables, so that the old output  * routines don't have to change.  But we provide routines to save  * and restore these variables in an "environment table".  The  * `select_output_environment' function switches from one output  * environment to another.  *  * Environment #0 (i.e. element #0 of the table) is the regular  * environment that is used when we're not formatting a multitable.  *  * Environment #N (where N = 1,2,3,...) is the env. for column #N of  * the table, when a multitable is active.  */
end_comment

begin_comment
comment|/* contents of an output environment */
end_comment

begin_comment
comment|/* some more vars may end up being needed here later @@ */
end_comment

begin_struct
struct|struct
name|env
block|{
name|unsigned
name|char
modifier|*
name|output_paragraph
decl_stmt|;
name|int
name|output_paragraph_offset
decl_stmt|;
name|int
name|output_column
decl_stmt|;
name|int
name|paragraph_is_open
decl_stmt|;
name|int
name|current_indent
decl_stmt|;
name|int
name|fill_column
decl_stmt|;
block|}
name|envs
index|[
name|MAXCOLS
index|]
struct|;
end_struct

begin_comment
comment|/* the environment table */
end_comment

begin_comment
comment|/* index in environment table of currently selected environment */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_env_no
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* column number of last column in current multitable */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_column
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flags indicating whether horizontal and vertical separators need    to be drawn, separating rows and columns in the current multitable. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hsep
decl_stmt|,
name|vsep
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|do_multitable
parameter_list|()
block|{
name|int
name|ncolumns
decl_stmt|;
comment|/*    *  multitable strategy:    *  for each item {    *     for each column in an item {    *      initialize a new paragraph    *      do ordinary formatting into the new paragraph    *      save the paragraph away    *      repeat if there are more paragraphs in the column    *    }    *    dump out the saved paragraphs and free the storage    *  }    */
if|if
condition|(
name|multitable_active
condition|)
block|{
name|line_error
argument_list|(
literal|"Multitables cannot be nested"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* scan the current item function to get the field widths      and number of columns, and set up the output environment list      accordingly. */
name|ncolumns
operator|=
name|setup_multitable_parameters
argument_list|()
expr_stmt|;
if|if
condition|(
name|hsep
condition|)
name|draw_horizontal_separator
argument_list|()
expr_stmt|;
comment|/* The next @item command will direct stdout into the first column      and start processing.  @tab will then switch to the next column,      and @item will flush out the saved output and return to the first      column.  Environment #1 is the first column.  (Environment #0 is      the normal output) */
operator|++
name|multitable_active
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read the parameters for a multitable from the current command    line, save the parameters away, and return the    number of columns. */
end_comment

begin_function
name|int
name|setup_multitable_parameters
parameter_list|()
block|{
name|char
modifier|*
name|params
init|=
name|insertion_stack
operator|->
name|item_function
decl_stmt|;
name|int
name|nchars
decl_stmt|;
name|float
name|columnfrac
decl_stmt|;
name|char
name|command
index|[
literal|200
index|]
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
comment|/* We implement @hsep and @vsep even though TeX doesn't.      We don't get mixing of @columnfractions and templates right,      but TeX doesn't either.  */
name|hsep
operator|=
name|vsep
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|params
condition|)
block|{
while|while
condition|(
name|whitespace
argument_list|(
operator|*
name|params
argument_list|)
condition|)
name|params
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|params
operator|==
literal|'@'
condition|)
block|{
name|sscanf
argument_list|(
name|params
argument_list|,
literal|"%s%n"
argument_list|,
name|command
argument_list|,
operator|&
name|nchars
argument_list|)
expr_stmt|;
name|params
operator|+=
name|nchars
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
literal|"@hsep"
argument_list|)
operator|==
literal|0
condition|)
name|hsep
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
literal|"@vsep"
argument_list|)
operator|==
literal|0
condition|)
name|vsep
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
literal|"@columnfractions"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Clobber old environments and create new ones, 	   starting at #1.  Environment #0 is the normal standard output, 	   so we don't mess with it. */
for|for
control|(
init|;
name|i
operator|<=
name|MAXCOLS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|params
argument_list|,
literal|"%f%n"
argument_list|,
operator|&
name|columnfrac
argument_list|,
operator|&
name|nchars
argument_list|)
operator|<
literal|1
condition|)
goto|goto
name|done
goto|;
name|params
operator|+=
name|nchars
expr_stmt|;
name|setup_output_environment
argument_list|(
name|i
argument_list|,
call|(
name|int
call|)
argument_list|(
name|columnfrac
operator|*
name|fill_column
operator|+
literal|.5
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|params
operator|==
literal|'{'
condition|)
block|{
name|char
modifier|*
name|start
init|=
name|params
decl_stmt|;
while|while
condition|(
operator|(
operator|*
name|params
operator|!=
literal|'}'
operator|||
name|params
index|[
operator|-
literal|1
index|]
operator|==
literal|'@'
operator|)
operator|&&
operator|*
name|params
condition|)
block|{
name|params
operator|++
expr_stmt|;
block|}
comment|/* This gives us two spaces between columns.  Seems reasonable.          Really should expand the text, though, so a template of          `@code{foo}' has a width of three, not ten.  Also have to match          braces, then.  */
name|setup_output_environment
argument_list|(
name|i
operator|++
argument_list|,
name|params
operator|++
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"ignoring stray text `%s' after @multitable"
argument_list|,
name|params
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|done
label|:
name|flush_output
argument_list|()
expr_stmt|;
name|inhibit_output_flushing
argument_list|()
expr_stmt|;
name|last_column
operator|=
name|i
operator|-
literal|1
expr_stmt|;
return|return
name|last_column
return|;
block|}
end_function

begin_comment
comment|/* Initialize environment number ENV_NO, of width WIDTH.    The idea is that we're going to use one environment for each column of    a multitable, so we can build them up separately and print them    all out at the end. */
end_comment

begin_function
name|int
name|setup_output_environment
parameter_list|(
name|env_no
parameter_list|,
name|width
parameter_list|)
name|int
name|env_no
decl_stmt|;
name|int
name|width
decl_stmt|;
block|{
name|int
name|old_env
init|=
name|select_output_environment
argument_list|(
name|env_no
argument_list|)
decl_stmt|;
comment|/* clobber old environment and set width of new one */
name|init_paragraph
argument_list|()
expr_stmt|;
comment|/* make our change */
name|fill_column
operator|=
name|width
expr_stmt|;
comment|/* Save new environment and restore previous one. */
name|select_output_environment
argument_list|(
name|old_env
argument_list|)
expr_stmt|;
return|return
name|env_no
return|;
block|}
end_function

begin_comment
comment|/* Direct current output to environment number N.  Used when    switching work from one column of a multitable to the next.    Returns previous environment number. */
end_comment

begin_function
name|int
name|select_output_environment
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|struct
name|env
modifier|*
name|e
init|=
operator|&
name|envs
index|[
name|current_env_no
index|]
decl_stmt|;
name|int
name|old_env_no
init|=
name|current_env_no
decl_stmt|;
comment|/* stash current env info from global vars into the old environment */
name|e
operator|->
name|output_paragraph
operator|=
name|output_paragraph
expr_stmt|;
name|e
operator|->
name|output_paragraph_offset
operator|=
name|output_paragraph_offset
expr_stmt|;
name|e
operator|->
name|output_column
operator|=
name|output_column
expr_stmt|;
name|e
operator|->
name|paragraph_is_open
operator|=
name|paragraph_is_open
expr_stmt|;
name|e
operator|->
name|current_indent
operator|=
name|current_indent
expr_stmt|;
name|e
operator|->
name|fill_column
operator|=
name|fill_column
expr_stmt|;
comment|/* now copy new environment into global vars */
name|current_env_no
operator|=
name|n
expr_stmt|;
name|e
operator|=
operator|&
name|envs
index|[
name|current_env_no
index|]
expr_stmt|;
name|output_paragraph
operator|=
name|e
operator|->
name|output_paragraph
expr_stmt|;
name|output_paragraph_offset
operator|=
name|e
operator|->
name|output_paragraph_offset
expr_stmt|;
name|output_column
operator|=
name|e
operator|->
name|output_column
expr_stmt|;
name|paragraph_is_open
operator|=
name|e
operator|->
name|paragraph_is_open
expr_stmt|;
name|current_indent
operator|=
name|e
operator|->
name|current_indent
expr_stmt|;
name|fill_column
operator|=
name|e
operator|->
name|fill_column
expr_stmt|;
return|return
name|old_env_no
return|;
block|}
end_function

begin_comment
comment|/* advance to the next environment number */
end_comment

begin_function
name|int
name|nselect_next_environment
parameter_list|()
block|{
if|if
condition|(
name|current_env_no
operator|>=
name|last_column
condition|)
block|{
name|line_error
argument_list|(
literal|"Too many columns in multitable item (max %d)"
argument_list|,
name|last_column
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|select_output_environment
argument_list|(
name|current_env_no
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function_decl
specifier|static
name|void
name|output_multitable_row
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* start a new item (row) of a multitable */
end_comment

begin_macro
name|multitable_item
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|multitable_active
condition|)
block|{
comment|/* impossible, I think. */
name|error
argument_list|(
literal|"multitable item not in active multitable"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_env_no
operator|>
literal|0
condition|)
block|{
name|output_multitable_row
argument_list|()
expr_stmt|;
block|}
comment|/* start at column 1 */
name|select_output_environment
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|output_paragraph
condition|)
block|{
name|line_error
argument_list|(
literal|"Cannot select column #%d in multitable"
argument_list|,
name|current_env_no
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL
argument_list|)
expr_stmt|;
block|}
name|init_column
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* do anything needed at the beginning of processing a    multitable column. */
end_comment

begin_macro
name|init_column
argument_list|()
end_macro

begin_block
block|{
comment|/* don't indent 1st paragraph in the item */
name|cm_noindent
argument_list|()
expr_stmt|;
comment|/* throw away possible whitespace after @item or @tab command */
name|skip_whitespace
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Output a row.  Have to keep `output_position' up-to-date for each    character we output, or the tags table will be off, leading to    chopped-off output files and undefined nodes (because they're in the    wrong file, etc.).  Perhaps it would be better to accumulate this    value somewhere and add it once at the end of the table, or return it    as the value, but this seems simplest.  */
end_comment

begin_function
specifier|static
name|void
name|out_char
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
specifier|extern
name|int
name|output_position
decl_stmt|;
name|putc
argument_list|(
name|ch
argument_list|,
name|output_stream
argument_list|)
expr_stmt|;
name|output_position
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_multitable_row
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|remaining
decl_stmt|;
comment|/* offset in the output paragraph of the next char needing      to be output for that column. */
name|int
name|offset
index|[
name|MAXCOLS
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|last_column
condition|;
name|i
operator|++
control|)
name|offset
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* select the current environment, to make sure the env variables      get updated */
name|select_output_environment
argument_list|(
name|current_env_no
argument_list|)
expr_stmt|;
define|#
directive|define
name|CHAR_ADDR
parameter_list|(
name|n
parameter_list|)
value|(offset[i] + (n))
define|#
directive|define
name|CHAR_AT
parameter_list|(
name|n
parameter_list|)
value|(envs[i].output_paragraph[CHAR_ADDR(n)])
comment|/* remove trailing whitespace from each column */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|last_column
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|cr_or_whitespace
argument_list|(
name|CHAR_AT
argument_list|(
name|envs
index|[
name|i
index|]
operator|.
name|output_paragraph_offset
operator|-
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|envs
index|[
name|i
index|]
operator|.
name|output_paragraph_offset
operator|--
expr_stmt|;
block|}
block|}
comment|/* read the current line from each column, outputting them all      pasted together.  Do this til all lines are output from all      columns.  */
for|for
control|(
init|;
condition|;
control|)
block|{
name|remaining
operator|=
literal|0
expr_stmt|;
comment|/* first, see if there is any work to do */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|last_column
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CHAR_ADDR
argument_list|(
literal|0
argument_list|)
operator|<
name|envs
index|[
name|i
index|]
operator|.
name|output_paragraph_offset
condition|)
block|{
name|remaining
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|remaining
condition|)
break|break;
if|if
condition|(
name|vsep
condition|)
name|out_char
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|last_column
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|CHAR_ADDR
argument_list|(
name|j
argument_list|)
operator|<
name|envs
index|[
name|i
index|]
operator|.
name|output_paragraph_offset
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|CHAR_AT
argument_list|(
name|j
argument_list|)
operator|==
literal|'\n'
condition|)
break|break;
name|out_char
argument_list|(
name|CHAR_AT
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|offset
index|[
name|i
index|]
operator|+=
name|j
operator|+
literal|1
expr_stmt|;
comment|/* skip last text plus skip the newline */
for|for
control|(
init|;
name|j
operator|<=
name|envs
index|[
name|i
index|]
operator|.
name|fill_column
condition|;
name|j
operator|++
control|)
name|out_char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsep
condition|)
name|out_char
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
comment|/* draw column separator */
block|}
name|out_char
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* end of line */
block|}
if|if
condition|(
name|hsep
condition|)
name|draw_horizontal_separator
argument_list|()
expr_stmt|;
comment|/* Now dispose of the buffered output. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|last_column
condition|;
name|i
operator|++
control|)
block|{
name|select_output_environment
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|init_paragraph
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_undef
undef|#
directive|undef
name|CHAR_AT
end_undef

begin_undef
undef|#
directive|undef
name|CHAR_ADDR
end_undef

begin_function
name|int
name|draw_horizontal_separator
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|vsep
condition|)
name|out_char
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|last_column
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|envs
index|[
name|i
index|]
operator|.
name|fill_column
condition|;
name|j
operator|++
control|)
name|out_char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsep
condition|)
name|out_char
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
block|}
name|out_char
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* select a new column in current row of multitable */
end_comment

begin_function
name|void
name|cm_tab
parameter_list|()
block|{
if|if
condition|(
operator|!
name|multitable_active
condition|)
name|error
argument_list|(
literal|"ignoring @tab outside of multitable"
argument_list|)
expr_stmt|;
name|nselect_next_environment
argument_list|()
expr_stmt|;
name|init_column
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* close a multitable, flushing its output and resetting    whatever needs resetting */
end_comment

begin_function
name|void
name|end_multitable
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|output_multitable_row
argument_list|()
expr_stmt|;
comment|/* Multitables cannot be nested.  Otherwise, we'd have to save the      previous output environment number on a stack somewhere, and then      restore to that environment.  */
name|select_output_environment
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* we swallow newlines, so insert one of our own */
name|multitable_active
operator|=
literal|0
expr_stmt|;
name|uninhibit_output_flushing
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|printf ("** Multicolumn output from last row:\n");   for (i = 1; i<= last_column; i++) {     select_output_environment (i);     printf ("* column #%d: output = %s\n", i, output_paragraph);   }
endif|#
directive|endif
block|}
end_function

end_unit

