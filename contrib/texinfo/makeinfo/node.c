begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* node.c -- nodes for Texinfo.    $Id: node.c,v 1.12 2003/05/01 00:30:07 karl Exp $     Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003 Free Software    Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cmds.h"
end_include

begin_include
include|#
directive|include
file|"files.h"
end_include

begin_include
include|#
directive|include
file|"footnote.h"
end_include

begin_include
include|#
directive|include
file|"macro.h"
end_include

begin_include
include|#
directive|include
file|"makeinfo.h"
end_include

begin_include
include|#
directive|include
file|"node.h"
end_include

begin_include
include|#
directive|include
file|"html.h"
end_include

begin_include
include|#
directive|include
file|"sectioning.h"
end_include

begin_include
include|#
directive|include
file|"insertion.h"
end_include

begin_include
include|#
directive|include
file|"xml.h"
end_include

begin_comment
comment|/* See comments in node.h.  */
end_comment

begin_decl_stmt
name|NODE_REF
modifier|*
name|node_references
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NODE_REF
modifier|*
name|node_node_references
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TAG_ENTRY
modifier|*
name|tag_table
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|node_number
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_section
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|outstanding_node
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Adding nodes, and making tags.  */
end_comment

begin_comment
comment|/* Start a new tag table. */
end_comment

begin_function
name|void
name|init_tag_table
parameter_list|()
block|{
while|while
condition|(
name|tag_table
condition|)
block|{
name|TAG_ENTRY
modifier|*
name|temp
init|=
name|tag_table
decl_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|prev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|up
argument_list|)
expr_stmt|;
name|tag_table
operator|=
name|tag_table
operator|->
name|next_ent
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write out the contents of the existing tag table.    INDIRECT_P says how to format the output (it depends on whether the    table is direct or indirect).  */
end_comment

begin_function
specifier|static
name|void
name|write_tag_table_internal
parameter_list|(
name|indirect_p
parameter_list|)
name|int
name|indirect_p
decl_stmt|;
block|{
name|TAG_ENTRY
modifier|*
name|node
decl_stmt|;
name|int
name|old_indent
init|=
name|no_indent
decl_stmt|;
if|if
condition|(
name|xml
condition|)
block|{
name|flush_output
argument_list|()
expr_stmt|;
return|return;
block|}
name|no_indent
operator|=
literal|1
expr_stmt|;
name|filling_enabled
operator|=
literal|0
expr_stmt|;
name|must_start_paragraph
operator|=
literal|0
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|indirect_p
condition|)
block|{
name|no_indent
operator|=
literal|1
expr_stmt|;
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|add_word_args
argument_list|(
literal|"\037\nTag Table:\n%s"
argument_list|,
name|indirect_p
condition|?
literal|"(Indirect)\n"
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* Do not collapse -- to -, etc., in node names.  */
name|in_fixed_width_font
operator|++
expr_stmt|;
for|for
control|(
name|node
operator|=
name|tag_table
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next_ent
control|)
block|{
if|if
condition|(
name|node
operator|->
name|flags
operator|&
name|TAG_FLAG_ANCHOR
condition|)
block|{
comment|/* This reference is to an anchor.  */
name|execute_string
argument_list|(
literal|"Ref: %s"
argument_list|,
name|node
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This reference is to a node.  */
name|execute_string
argument_list|(
literal|"Node: %s"
argument_list|,
name|node
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
name|add_word_args
argument_list|(
literal|"\177%d\n"
argument_list|,
name|node
operator|->
name|position
argument_list|)
expr_stmt|;
block|}
name|add_word
argument_list|(
literal|"\037\nEnd Tag Table\n"
argument_list|)
expr_stmt|;
comment|/* Do not collapse -- to -, etc., in node names.  */
name|in_fixed_width_font
operator|--
expr_stmt|;
name|flush_output
argument_list|()
expr_stmt|;
name|no_indent
operator|=
name|old_indent
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_tag_table
parameter_list|()
block|{
name|write_tag_table_internal
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Not indirect. */
block|}
end_function

begin_function
name|void
name|write_tag_table_indirect
parameter_list|()
block|{
name|write_tag_table_internal
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert "top" and friends into "Top". */
end_comment

begin_function
specifier|static
name|void
name|normalize_node_name
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|string
argument_list|,
literal|"Top"
argument_list|)
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"Top"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|get_node_token
parameter_list|(
name|expand
parameter_list|)
name|int
name|expand
decl_stmt|;
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|get_until_in_line
argument_list|(
name|expand
argument_list|,
literal|","
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|','
condition|)
name|input_text_offset
operator|++
expr_stmt|;
name|fix_whitespace
argument_list|(
name|string
argument_list|)
expr_stmt|;
comment|/* Force all versions of "top" to be "Top". */
name|normalize_node_name
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/* Expand any macros and other directives in a node name, and    return the expanded name as an malloc'ed string.  */
end_comment

begin_function
name|char
modifier|*
name|expand_node_name
parameter_list|(
name|node
parameter_list|)
name|char
modifier|*
name|node
decl_stmt|;
block|{
name|char
modifier|*
name|result
init|=
name|node
decl_stmt|;
if|if
condition|(
name|node
condition|)
block|{
comment|/* Don't expand --, `` etc., in case somebody will want          to print the result.  */
name|in_fixed_width_font
operator|++
expr_stmt|;
name|result
operator|=
name|expansion
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|--
expr_stmt|;
name|fix_whitespace
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|normalize_node_name
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Look up NAME in the tag table, and return the associated    tag_entry.  If the node is not in the table return NULL. */
end_comment

begin_function
name|TAG_ENTRY
modifier|*
name|find_node
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|TAG_ENTRY
modifier|*
name|tag
init|=
name|tag_table
decl_stmt|;
name|char
modifier|*
name|expanded_name
decl_stmt|;
name|char
name|n1
init|=
name|name
index|[
literal|0
index|]
decl_stmt|;
while|while
condition|(
name|tag
condition|)
block|{
if|if
condition|(
name|tag
operator|->
name|node
index|[
literal|0
index|]
operator|==
name|n1
operator|&&
name|strcmp
argument_list|(
name|tag
operator|->
name|node
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|tag
return|;
name|tag
operator|=
name|tag
operator|->
name|next_ent
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|expensive_validation
condition|)
return|return
name|NULL
return|;
comment|/* Try harder.  Maybe TAG_TABLE has the expanded NAME, or maybe NAME      is expanded while TAG_TABLE has its unexpanded form.  This may      slow down the search, but if they want this feature, let them      pay!  If they want it fast, they should write every node name      consistently (either always expanded or always unexpaned).  */
name|expanded_name
operator|=
name|expand_node_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|tag
operator|=
name|tag_table
init|;
name|tag
condition|;
name|tag
operator|=
name|tag
operator|->
name|next_ent
control|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|tag
operator|->
name|node
argument_list|,
name|expanded_name
argument_list|)
condition|)
break|break;
comment|/* If the tag name doesn't have the command prefix, there's no          chance it could expand into anything but itself.  */
if|if
condition|(
name|strchr
argument_list|(
name|tag
operator|->
name|node
argument_list|,
name|COMMAND_PREFIX
argument_list|)
condition|)
block|{
name|char
modifier|*
name|expanded_node
init|=
name|expand_node_name
argument_list|(
name|tag
operator|->
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|expanded_node
argument_list|,
name|expanded_name
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|expanded_node
argument_list|)
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|expanded_node
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|expanded_name
argument_list|)
expr_stmt|;
return|return
name|tag
return|;
block|}
end_function

begin_comment
comment|/* Look in the tag table for a node whose file name is FNAME, and    return the associated tag_entry.  If there's no such node in the    table, return NULL. */
end_comment

begin_function
name|TAG_ENTRY
modifier|*
name|find_node_by_fname
parameter_list|(
name|fname
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|TAG_ENTRY
modifier|*
name|tag
init|=
name|tag_table
decl_stmt|;
while|while
condition|(
name|tag
condition|)
block|{
if|if
condition|(
name|tag
operator|->
name|html_fname
operator|&&
name|FILENAME_CMP
argument_list|(
name|tag
operator|->
name|html_fname
argument_list|,
name|fname
argument_list|)
operator|==
literal|0
condition|)
return|return
name|tag
return|;
name|tag
operator|=
name|tag
operator|->
name|next_ent
expr_stmt|;
block|}
return|return
name|tag
return|;
block|}
end_function

begin_comment
comment|/* Remember next, prev, etc. references in a @node command, where we    don't care about most of the entries. */
end_comment

begin_function
specifier|static
name|void
name|remember_node_node_reference
parameter_list|(
name|node
parameter_list|)
name|char
modifier|*
name|node
decl_stmt|;
block|{
name|NODE_REF
modifier|*
name|temp
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NODE_REF
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|number
decl_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
return|return;
name|temp
operator|->
name|next
operator|=
name|node_node_references
expr_stmt|;
name|temp
operator|->
name|node
operator|=
name|xstrdup
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|temp
operator|->
name|type
operator|=
name|followed_reference
expr_stmt|;
name|number
operator|=
name|number_of_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|number
condition|)
name|temp
operator|->
name|number
operator|=
name|number
expr_stmt|;
comment|/* Already assigned. */
else|else
block|{
name|node_number
operator|++
expr_stmt|;
name|temp
operator|->
name|number
operator|=
name|node_number
expr_stmt|;
block|}
name|node_node_references
operator|=
name|temp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remember NODE and associates. */
end_comment

begin_function
name|void
name|remember_node
parameter_list|(
name|node
parameter_list|,
name|prev
parameter_list|,
name|next
parameter_list|,
name|up
parameter_list|,
name|position
parameter_list|,
name|line_no
parameter_list|,
name|fname
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|node
decl_stmt|,
decl|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|up
decl_stmt|,
modifier|*
name|fname
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|position
decl_stmt|,
name|line_no
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Check for existence of this tag already. */
if|if
condition|(
name|validating
condition|)
block|{
name|TAG_ENTRY
modifier|*
name|tag
init|=
name|find_node
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|tag
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Node `%s' previously defined at line %d"
argument_list|)
argument_list|,
name|node
argument_list|,
name|tag
operator|->
name|line_no
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|TAG_FLAG_ANCHOR
operator|)
condition|)
block|{
comment|/* Make this the current node. */
name|current_node
operator|=
name|node
expr_stmt|;
block|}
comment|/* Add it to the list. */
block|{
name|int
name|number
init|=
name|number_of_node
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|TAG_ENTRY
modifier|*
name|new
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TAG_ENTRY
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|node
operator|=
name|node
expr_stmt|;
name|new
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|new
operator|->
name|up
operator|=
name|up
expr_stmt|;
name|new
operator|->
name|position
operator|=
name|position
expr_stmt|;
name|new
operator|->
name|line_no
operator|=
name|line_no
expr_stmt|;
name|new
operator|->
name|filename
operator|=
name|node_filename
expr_stmt|;
name|new
operator|->
name|touched
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|number
condition|)
name|new
operator|->
name|number
operator|=
name|number
expr_stmt|;
comment|/* Already assigned. */
else|else
block|{
name|node_number
operator|++
expr_stmt|;
name|new
operator|->
name|number
operator|=
name|node_number
expr_stmt|;
block|}
if|if
condition|(
name|fname
condition|)
name|new
operator|->
name|html_fname
operator|=
name|fname
expr_stmt|;
else|else
comment|/* This happens for Top node under split-HTML, for example.  */
name|new
operator|->
name|html_fname
operator|=
name|normalize_filename
argument_list|(
name|filename_part
argument_list|(
name|current_output_filename
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next_ent
operator|=
name|tag_table
expr_stmt|;
name|tag_table
operator|=
name|new
expr_stmt|;
block|}
if|if
condition|(
name|html
condition|)
block|{
comment|/* Note the references to the next etc. nodes too.  */
name|remember_node_node_reference
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|remember_node_node_reference
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|remember_node_node_reference
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Remember this node name for later validation use.  This is used to    remember menu references while reading the input file.  After the    output file has been written, if validation is on, then we use the    contents of `node_references' as a list of nodes to validate.  */
end_comment

begin_function
name|void
name|remember_node_reference
parameter_list|(
name|node
parameter_list|,
name|line
parameter_list|,
name|type
parameter_list|)
name|char
modifier|*
name|node
decl_stmt|;
name|int
name|line
decl_stmt|;
name|enum
name|reftype
name|type
decl_stmt|;
block|{
name|NODE_REF
modifier|*
name|temp
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NODE_REF
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|number
init|=
name|number_of_node
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|temp
operator|->
name|next
operator|=
name|node_references
expr_stmt|;
name|temp
operator|->
name|node
operator|=
name|xstrdup
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|temp
operator|->
name|line_no
operator|=
name|line
expr_stmt|;
name|temp
operator|->
name|section
operator|=
name|current_section
expr_stmt|;
name|temp
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|temp
operator|->
name|containing_node
operator|=
name|xstrdup
argument_list|(
name|current_node
condition|?
name|current_node
else|:
literal|""
argument_list|)
expr_stmt|;
name|temp
operator|->
name|filename
operator|=
name|node_filename
expr_stmt|;
if|if
condition|(
name|number
condition|)
name|temp
operator|->
name|number
operator|=
name|number
expr_stmt|;
comment|/* Already assigned. */
else|else
block|{
name|node_number
operator|++
expr_stmt|;
name|temp
operator|->
name|number
operator|=
name|node_number
expr_stmt|;
block|}
name|node_references
operator|=
name|temp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|isolate_nodename
parameter_list|(
name|nodename
parameter_list|)
name|char
modifier|*
name|nodename
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|int
name|paren_seen
decl_stmt|,
name|paren
decl_stmt|;
if|if
condition|(
operator|!
name|nodename
condition|)
return|return;
name|canon_white
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
name|paren_seen
operator|=
name|paren
operator|=
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|nodename
operator|==
literal|'.'
operator|||
operator|!
operator|*
name|nodename
condition|)
block|{
operator|*
name|nodename
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|nodename
operator|==
literal|'('
condition|)
block|{
name|paren
operator|++
expr_stmt|;
name|paren_seen
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
operator|(
name|c
operator|=
name|nodename
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|paren
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
name|paren
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
name|paren
operator|--
expr_stmt|;
continue|continue;
block|}
comment|/* If the character following the close paren is a space, then this          node has no more characters associated with it. */
if|if
condition|(
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|','
operator|||
operator|(
operator|(
name|paren_seen
operator|&&
name|nodename
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|')'
operator|)
operator|&&
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'.'
operator|)
operator|)
operator|||
operator|(
name|c
operator|==
literal|'.'
operator|&&
operator|(
operator|(
operator|!
name|nodename
index|[
name|i
operator|+
literal|1
index|]
operator|||
operator|(
name|cr_or_whitespace
argument_list|(
name|nodename
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|)
operator|||
operator|(
name|nodename
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|')'
operator|)
operator|)
operator|)
operator|)
condition|)
break|break;
block|}
name|nodename
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function gets called at the start of every line while inside a    menu.  It checks to see if the line starts with "* ", and if so and    REMEMBER_REF is nonzero, remembers the node reference as type    REF_TYPE that this menu refers to.  input_text_offset is at the \n    just before the menu line.  If REMEMBER_REF is zero, REF_TYPE is unused.  */
end_comment

begin_define
define|#
directive|define
name|MENU_STARTER
value|"* "
end_define

begin_function
name|char
modifier|*
name|glean_node_from_menu
parameter_list|(
name|remember_ref
parameter_list|,
name|ref_type
parameter_list|)
name|int
name|remember_ref
decl_stmt|;
name|enum
name|reftype
name|ref_type
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|orig_offset
init|=
name|input_text_offset
decl_stmt|;
name|char
modifier|*
name|nodename
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|expanded_line
decl_stmt|;
name|char
modifier|*
name|old_input
init|=
name|input_text
decl_stmt|;
name|int
name|old_size
init|=
name|input_text_length
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|input_text
index|[
name|input_text_offset
operator|+
literal|1
index|]
argument_list|,
name|MENU_STARTER
argument_list|,
name|strlen
argument_list|(
name|MENU_STARTER
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
else|else
name|input_text_offset
operator|+=
name|strlen
argument_list|(
name|MENU_STARTER
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* The menu entry might include macro calls, so we need to expand them.  */
name|get_until
argument_list|(
literal|"\n"
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
name|only_macro_expansion
operator|++
expr_stmt|;
comment|/* only expand macros in menu entries */
name|expanded_line
operator|=
name|expansion
argument_list|(
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|only_macro_expansion
operator|--
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|input_text
operator|=
name|expanded_line
expr_stmt|;
name|input_text_offset
operator|=
literal|0
expr_stmt|;
name|input_text_length
operator|=
name|strlen
argument_list|(
name|expanded_line
argument_list|)
expr_stmt|;
name|get_until_in_line
argument_list|(
literal|0
argument_list|,
literal|":"
argument_list|,
operator|&
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|':'
condition|)
name|input_text_offset
operator|++
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|!=
literal|':'
condition|)
block|{
name|free
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
name|get_until_in_line
argument_list|(
literal|0
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|nodename
argument_list|)
expr_stmt|;
name|isolate_nodename
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
block|}
name|input_text
operator|=
name|old_input
expr_stmt|;
name|input_text_offset
operator|=
name|orig_offset
expr_stmt|;
name|input_text_length
operator|=
name|old_size
expr_stmt|;
name|free
argument_list|(
name|expanded_line
argument_list|)
expr_stmt|;
name|fix_whitespace
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
name|normalize_node_name
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&&
name|nodename
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|':'
condition|)
name|nodename
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|remember_ref
condition|)
name|remember_node_reference
argument_list|(
name|nodename
argument_list|,
name|line_number
argument_list|,
name|ref_type
argument_list|)
expr_stmt|;
return|return
name|nodename
return|;
block|}
end_function

begin_comment
comment|/* Set the name of the current output file.  */
end_comment

begin_function
name|void
name|set_current_output_filename
parameter_list|(
name|fname
parameter_list|)
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
block|{
if|if
condition|(
name|current_output_filename
condition|)
name|free
argument_list|(
name|current_output_filename
argument_list|)
expr_stmt|;
name|current_output_filename
operator|=
name|xstrdup
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The order is: nodename, nextnode, prevnode, upnode.    If all of the NEXT, PREV, and UP fields are empty, they are defaulted.    You must follow a node command which has those fields defaulted    with a sectioning command (e.g., @chapter) giving the "level" of that node.    It is an error not to do so.    The defaults come from the menu in this node's parent. */
end_comment

begin_function
name|void
name|cm_node
parameter_list|()
block|{
specifier|static
name|long
name|epilogue_len
init|=
literal|0L
decl_stmt|;
name|char
modifier|*
name|node
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|up
decl_stmt|;
name|int
name|new_node_pos
decl_stmt|,
name|defaulting
decl_stmt|,
name|this_section
decl_stmt|;
name|int
name|no_warn
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|fname_for_this_node
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tem
decl_stmt|;
name|TAG_ENTRY
modifier|*
name|tag
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
literal|"nwnode"
argument_list|)
operator|==
literal|0
condition|)
name|no_warn
operator|=
name|TAG_FLAG_NO_WARN
expr_stmt|;
comment|/* Get rid of unmatched brace arguments from previous commands. */
name|discard_braces
argument_list|()
expr_stmt|;
comment|/* There also might be insertions left lying around that haven't been      ended yet.  Do that also. */
name|discard_insertions
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|html
operator|&&
operator|!
name|already_outputting_pending_notes
condition|)
block|{
if|if
condition|(
operator|!
name|xml
condition|)
name|close_paragraph
argument_list|()
expr_stmt|;
name|output_pending_notes
argument_list|()
expr_stmt|;
block|}
name|new_node_pos
operator|=
name|output_position
expr_stmt|;
if|if
condition|(
name|macro_expansion_output_stream
operator|&&
operator|!
name|executing_string
condition|)
name|append_to_expansion_output
argument_list|(
name|input_text_offset
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Do not collapse -- to -, etc., in node names.  */
name|in_fixed_width_font
operator|++
expr_stmt|;
comment|/* While expanding the @node line, leave any non-macros      intact, so that the macro-expanded output includes them.  */
name|only_macro_expansion
operator|++
expr_stmt|;
name|node
operator|=
name|get_node_token
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|only_macro_expansion
operator|--
expr_stmt|;
name|next
operator|=
name|get_node_token
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|prev
operator|=
name|get_node_token
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|up
operator|=
name|get_node_token
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|html
operator|&&
name|splitting
comment|/* If there is a Top node, it always goes into index.html.  So 	 don't start a new HTML file for Top.  */
operator|&&
operator|(
name|top_node_seen
operator|||
name|strcasecmp
argument_list|(
name|node
argument_list|,
literal|"Top"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* We test *node here so that @node without a valid name won't 	 start a new file name with a bogus name such as ".html". 	 This could happen if we run under "--force", where we cannot 	 simply bail out.  Continuing to use the same file sounds like 	 the best we can do in such cases.  */
if|if
condition|(
name|current_output_filename
operator|&&
name|output_stream
operator|&&
operator|*
name|node
condition|)
block|{
name|char
modifier|*
name|fname_for_prev_node
decl_stmt|;
if|if
condition|(
name|current_node
condition|)
block|{
comment|/* NOTE: current_node at this point still holds the name 		 of the previous node.  */
name|tem
operator|=
name|expand_node_name
argument_list|(
name|current_node
argument_list|)
expr_stmt|;
name|fname_for_prev_node
operator|=
name|nodename_to_filename
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* could happen if their top node isn't named "Top" */
name|fname_for_prev_node
operator|=
name|filename_part
argument_list|(
name|current_output_filename
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_node_name
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|fname_for_this_node
operator|=
name|nodename_to_filename
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tem
argument_list|)
expr_stmt|;
comment|/* Don't close current output file, if next output file is              to have the same name.  This may happen at top level, or              if two nodes produce the same file name under --split.  */
if|if
condition|(
name|FILENAME_CMP
argument_list|(
name|fname_for_this_node
argument_list|,
name|fname_for_prev_node
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|long
name|pos1
init|=
literal|0
decl_stmt|;
comment|/* End the current split output file. */
name|close_paragraph
argument_list|()
expr_stmt|;
name|output_pending_notes
argument_list|()
expr_stmt|;
name|start_paragraph
argument_list|()
expr_stmt|;
comment|/* Compute the length of the HTML file's epilogue.  We 		 cannot know the value until run time, due to the 		 text/binary nuisance on DOS/Windows platforms, where 		 2 `\r' characters could be added to the epilogue when 		 it is written in text mode.  */
if|if
condition|(
name|epilogue_len
operator|==
literal|0
condition|)
block|{
name|flush_output
argument_list|()
expr_stmt|;
name|pos1
operator|=
name|ftell
argument_list|(
name|output_stream
argument_list|)
expr_stmt|;
block|}
name|add_word
argument_list|(
literal|"</body></html>\n"
argument_list|)
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
if|if
condition|(
name|epilogue_len
operator|==
literal|0
condition|)
name|epilogue_len
operator|=
name|ftell
argument_list|(
name|output_stream
argument_list|)
operator|-
name|pos1
expr_stmt|;
name|fclose
argument_list|(
name|output_stream
argument_list|)
expr_stmt|;
name|output_stream
operator|=
name|NULL
expr_stmt|;
name|tag
operator|=
name|find_node_by_fname
argument_list|(
name|fname_for_this_node
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|fname_for_prev_node
argument_list|)
expr_stmt|;
block|}
block|}
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|html
operator|||
operator|(
name|html
operator|&&
name|splitting
operator|)
condition|)
name|current_footnote_number
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|verbose_mode
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"Formatting node %s...\n"
argument_list|)
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|macro_expansion_output_stream
operator|&&
operator|!
name|executing_string
condition|)
name|remember_itext
argument_list|(
name|input_text
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
name|no_indent
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|xml
condition|)
block|{
name|xml_begin_document
argument_list|(
name|current_output_filename
argument_list|)
expr_stmt|;
name|xml_begin_node
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|docbook
condition|)
block|{
name|xml_insert_element
argument_list|(
name|NODENAME
argument_list|,
name|START
argument_list|)
expr_stmt|;
if|if
condition|(
name|macro_expansion_output_stream
operator|&&
operator|!
name|executing_string
condition|)
name|me_execute_string
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|NODENAME
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
else|else
name|xml_node_id
operator|=
name|xml_id
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|no_headers
operator|&&
operator|!
name|html
condition|)
block|{
name|add_word_args
argument_list|(
literal|"\037\nFile: %s,  Node: "
argument_list|,
name|pretty_output_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|macro_expansion_output_stream
operator|&&
operator|!
name|executing_string
condition|)
name|me_execute_string
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Check for defaulting of this node's next, prev, and up fields. */
name|defaulting
operator|=
operator|(
operator|*
name|next
operator|==
literal|0
operator|&&
operator|*
name|prev
operator|==
literal|0
operator|&&
operator|*
name|up
operator|==
literal|0
operator|)
expr_stmt|;
name|this_section
operator|=
name|what_section
argument_list|(
name|input_text
operator|+
name|input_text_offset
argument_list|)
expr_stmt|;
comment|/* If we are defaulting, then look at the immediately following      sectioning command (error if none) to determine the node's      level.  Find the node that contains the menu mentioning this node      that is one level up (error if not found).  That node is the "Up"      of this node.  Default the "Next" and "Prev" from the menu. */
if|if
condition|(
name|defaulting
condition|)
block|{
name|NODE_REF
modifier|*
name|last_ref
init|=
name|NULL
decl_stmt|;
name|NODE_REF
modifier|*
name|ref
init|=
name|node_references
decl_stmt|;
if|if
condition|(
name|this_section
operator|<
literal|0
operator|&&
operator|!
name|STREQ
argument_list|(
name|node
argument_list|,
literal|"Top"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|polite_section_name
init|=
literal|"top"
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|section_alist
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|section_alist
index|[
name|i
index|]
operator|.
name|level
operator|==
name|current_section
operator|+
literal|1
condition|)
block|{
name|polite_section_name
operator|=
name|section_alist
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
break|break;
block|}
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Node `%s' requires a sectioning command (e.g., %c%s)"
argument_list|)
argument_list|,
name|node
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|polite_section_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|node
argument_list|,
literal|"Top"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Default the NEXT pointer to be the first menu item in                  this node, if there is a menu in this node.  We have to                  try very hard to find the menu, as it may be obscured                  by execution_strings which are on the filestack.  For                  every member of the filestack which has a FILENAME                  member which is identical to the current INPUT_FILENAME,                  search forward from that offset. */
name|int
name|saved_input_text_offset
init|=
name|input_text_offset
decl_stmt|;
name|int
name|saved_input_text_length
init|=
name|input_text_length
decl_stmt|;
name|char
modifier|*
name|saved_input_text
init|=
name|input_text
decl_stmt|;
name|FSTACK
modifier|*
name|next_file
init|=
name|filestack
decl_stmt|;
name|int
name|orig_offset
decl_stmt|,
name|orig_size
decl_stmt|;
comment|/* No matter what, make this file point back at `(dir)'. */
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
name|up
operator|=
name|xstrdup
argument_list|(
literal|"(dir)"
argument_list|)
expr_stmt|;
comment|/* html fixxme */
while|while
condition|(
literal|1
condition|)
block|{
name|orig_offset
operator|=
name|input_text_offset
expr_stmt|;
name|orig_size
operator|=
name|search_forward
argument_list|(
name|node_search_string
argument_list|,
name|orig_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_size
operator|<
literal|0
condition|)
name|orig_size
operator|=
name|input_text_length
expr_stmt|;
name|input_text_offset
operator|=
name|search_forward
argument_list|(
literal|"\n@menu"
argument_list|,
name|orig_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_text_offset
operator|>
operator|-
literal|1
operator|&&
name|cr_or_whitespace
argument_list|(
name|input_text
index|[
name|input_text_offset
operator|+
literal|6
index|]
argument_list|)
condition|)
block|{
name|char
modifier|*
name|nodename_from_menu
init|=
name|NULL
decl_stmt|;
name|input_text_offset
operator|=
name|search_forward
argument_list|(
literal|"\n* "
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_text_offset
operator|!=
operator|-
literal|1
condition|)
name|nodename_from_menu
operator|=
name|glean_node_from_menu
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodename_from_menu
condition|)
block|{
name|free
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
name|nodename_from_menu
expr_stmt|;
break|break;
block|}
block|}
comment|/* We got here, so it hasn't been found yet.  Try                      the next file on the filestack if there is one. */
if|if
condition|(
name|next_file
operator|&&
name|FILENAME_CMP
argument_list|(
name|next_file
operator|->
name|filename
argument_list|,
name|input_filename
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_text
operator|=
name|next_file
operator|->
name|text
expr_stmt|;
name|input_text_offset
operator|=
name|next_file
operator|->
name|offset
expr_stmt|;
name|input_text_length
operator|=
name|next_file
operator|->
name|size
expr_stmt|;
name|next_file
operator|=
name|next_file
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
comment|/* No more input files to check. */
break|break;
block|}
block|}
name|input_text
operator|=
name|saved_input_text
expr_stmt|;
name|input_text_offset
operator|=
name|saved_input_text_offset
expr_stmt|;
name|input_text_length
operator|=
name|saved_input_text_length
expr_stmt|;
block|}
block|}
comment|/* Fix the level of the menu references in the Top node, iff it          was declared with @top, and no subsequent reference was found. */
if|if
condition|(
name|top_node_seen
operator|&&
operator|!
name|non_top_node_seen
condition|)
block|{
comment|/* Then this is the first non-@top node seen. */
name|int
name|level
decl_stmt|;
name|level
operator|=
name|set_top_section_level
argument_list|(
name|this_section
operator|-
literal|1
argument_list|)
expr_stmt|;
name|non_top_node_seen
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|ref
condition|)
block|{
if|if
condition|(
name|ref
operator|->
name|section
operator|==
name|level
condition|)
name|ref
operator|->
name|section
operator|=
name|this_section
operator|-
literal|1
expr_stmt|;
name|ref
operator|=
name|ref
operator|->
name|next
expr_stmt|;
block|}
name|ref
operator|=
name|node_references
expr_stmt|;
block|}
while|while
condition|(
name|ref
condition|)
block|{
if|if
condition|(
name|ref
operator|->
name|section
operator|==
operator|(
name|this_section
operator|-
literal|1
operator|)
operator|&&
name|ref
operator|->
name|type
operator|==
name|menu_reference
operator|&&
name|strcmp
argument_list|(
name|ref
operator|->
name|node
argument_list|,
name|node
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|containing_node
init|=
name|ref
operator|->
name|containing_node
decl_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
name|up
operator|=
name|xstrdup
argument_list|(
name|containing_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_ref
operator|&&
name|last_ref
operator|->
name|type
operator|==
name|menu_reference
operator|&&
name|strcmp
argument_list|(
name|last_ref
operator|->
name|containing_node
argument_list|,
name|containing_node
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
name|xstrdup
argument_list|(
name|last_ref
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|ref
operator|->
name|section
operator|==
name|this_section
operator|-
literal|1
operator|&&
name|ref
operator|->
name|next
operator|&&
name|ref
operator|->
name|next
operator|->
name|type
operator|!=
name|menu_reference
condition|)
name|ref
operator|=
name|ref
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ref
operator|->
name|next
operator|&&
name|ref
operator|->
name|type
operator|==
name|menu_reference
operator|&&
name|strcmp
argument_list|(
name|ref
operator|->
name|next
operator|->
name|containing_node
argument_list|,
name|containing_node
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|prev
operator|=
name|xstrdup
argument_list|(
name|ref
operator|->
name|next
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ref
operator|->
name|next
operator|&&
name|strcasecmp
argument_list|(
name|ref
operator|->
name|containing_node
argument_list|,
literal|"Top"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|prev
operator|=
name|xstrdup
argument_list|(
name|ref
operator|->
name|containing_node
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|last_ref
operator|=
name|ref
expr_stmt|;
name|ref
operator|=
name|ref
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Insert the correct args if we are expanding macros, and the node's      pointers weren't defaulted. */
if|if
condition|(
name|macro_expansion_output_stream
operator|&&
operator|!
name|executing_string
operator|&&
operator|!
name|defaulting
condition|)
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|op_orig
init|=
name|output_paragraph_offset
decl_stmt|;
name|int
name|meta_pos_orig
init|=
name|meta_char_pos
decl_stmt|;
name|int
name|extra
init|=
name|html
condition|?
name|strlen
argument_list|(
name|node
argument_list|)
else|:
literal|0
decl_stmt|;
name|temp
operator|=
name|xmalloc
argument_list|(
literal|7
operator|+
name|extra
operator|+
name|strlen
argument_list|(
name|next
argument_list|)
operator|+
name|strlen
argument_list|(
name|prev
argument_list|)
operator|+
name|strlen
argument_list|(
name|up
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s, %s, %s, %s"
argument_list|,
name|html
condition|?
name|node
else|:
literal|""
argument_list|,
name|next
argument_list|,
name|prev
argument_list|,
name|up
argument_list|)
expr_stmt|;
name|me_execute_string
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|output_paragraph_offset
operator|=
name|op_orig
expr_stmt|;
name|meta_char_pos
operator|=
name|meta_pos_orig
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|node
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"No node name specified for `%c%s' command"
argument_list|)
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
name|up
operator|=
name|NULL
expr_stmt|;
name|node_number
operator|++
expr_stmt|;
comment|/* else it doesn't get bumped */
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|*
name|next
condition|)
block|{
name|free
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|prev
condition|)
block|{
name|free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|up
condition|)
block|{
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
name|up
operator|=
name|NULL
expr_stmt|;
block|}
name|remember_node
argument_list|(
name|node
argument_list|,
name|prev
argument_list|,
name|next
argument_list|,
name|up
argument_list|,
name|new_node_pos
argument_list|,
name|line_number
argument_list|,
name|fname_for_this_node
argument_list|,
name|no_warn
argument_list|)
expr_stmt|;
name|outstanding_node
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|html
condition|)
block|{
if|if
condition|(
name|splitting
operator|&&
operator|*
name|node
operator|&&
name|output_stream
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|dirname
decl_stmt|;
name|char
name|filename
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|dirname
operator|=
name|pathname_part
argument_list|(
name|current_output_filename
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|filename
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|filename
argument_list|,
name|fname_for_this_node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
comment|/* See if the node name converted to a file name clashes 	     with other nodes or anchors.  If it clashes with an 	     anchor, we complain and nuke that anchor's file.  */
if|if
condition|(
operator|!
name|tag
condition|)
block|{
name|output_stream
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|html_output_head_p
operator|=
literal|0
expr_stmt|;
comment|/* so that we generate HTML preamble */
name|html_output_head
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tag
operator|->
name|flags
operator|&
name|TAG_FLAG_ANCHOR
operator|)
operator|!=
literal|0
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Anchor `%s' and node `%s' map to the same file name"
argument_list|)
argument_list|,
name|tag
operator|->
name|node
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|file_line_error
argument_list|(
name|tag
operator|->
name|filename
argument_list|,
name|tag
operator|->
name|line_no
argument_list|,
name|_
argument_list|(
literal|"This @anchor command ignored; references to it will not work"
argument_list|)
argument_list|)
expr_stmt|;
name|file_line_error
argument_list|(
name|tag
operator|->
name|filename
argument_list|,
name|tag
operator|->
name|line_no
argument_list|,
name|_
argument_list|(
literal|"Rename this anchor or use the `--no-split' option"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Nuke the file name recorded in anchor's tag. 		 Since we are about to nuke the file itself, we 		 don't want find_node_by_fname to consider this 		 anchor anymore.  */
name|free
argument_list|(
name|tag
operator|->
name|html_fname
argument_list|)
expr_stmt|;
name|tag
operator|->
name|html_fname
operator|=
name|NULL
expr_stmt|;
name|output_stream
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|html_output_head_p
operator|=
literal|0
expr_stmt|;
comment|/* so that we generate HTML preamble */
name|html_output_head
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* This node's file name clashes with another node. 		 We put them both on the same file.  */
name|output_stream
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_stream
condition|)
block|{
specifier|static
name|char
name|html_end
index|[]
init|=
literal|"</body></html>\n"
decl_stmt|;
name|char
name|end_line
index|[
sizeof|sizeof
argument_list|(
name|html_end
argument_list|)
index|]
decl_stmt|;
name|int
name|fpos
init|=
name|fseek
argument_list|(
name|output_stream
argument_list|,
operator|-
name|epilogue_len
argument_list|,
name|SEEK_END
argument_list|)
decl_stmt|;
if|if
condition|(
name|fpos
operator|<
literal|0
operator|||
name|fgets
argument_list|(
name|end_line
argument_list|,
sizeof|sizeof
argument_list|(
name|html_end
argument_list|)
argument_list|,
name|output_stream
argument_list|)
operator|==
name|NULL
comment|/* Paranoia: did someone change the way HTML 			 files are finished up?  */
operator|||
name|strcasecmp
argument_list|(
name|end_line
argument_list|,
name|html_end
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Unexpected string at end of split-HTML file `%s'"
argument_list|)
argument_list|,
name|fname_for_this_node
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|output_stream
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fseek
argument_list|(
name|output_stream
argument_list|,
operator|-
name|epilogue_len
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|output_stream
operator|==
name|NULL
condition|)
block|{
name|fs_error
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|set_current_output_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|splitting
operator|&&
name|no_headers
condition|)
block|{
comment|/* cross refs need a name="#anchor" even if we're not writing headers*/
name|add_word
argument_list|(
literal|"<a name=\""
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_node_name
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|add_anchor_name
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"\"></a>"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|splitting
operator|||
operator|!
name|no_headers
condition|)
block|{
comment|/* Navigation bar. */
name|add_word
argument_list|(
literal|"<div class=\"node\">\n"
argument_list|)
expr_stmt|;
comment|/* The<p> avoids the links area running on with old Lynxen. */
name|add_word_args
argument_list|(
literal|"<p>%s\n"
argument_list|,
name|splitting
condition|?
literal|""
else|:
literal|"<hr>"
argument_list|)
expr_stmt|;
name|add_word_args
argument_list|(
literal|"%s%s<a name=\""
argument_list|,
name|_
argument_list|(
literal|"Node:"
argument_list|)
argument_list|,
literal|"&nbsp;"
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_node_name
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|add_anchor_name
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_word_args
argument_list|(
literal|"\">%s</a>"
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
block|{
name|tem
operator|=
name|expansion
argument_list|(
name|next
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|",\n"
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
name|_
argument_list|(
literal|"Next:"
argument_list|)
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"&nbsp;"
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"<a rel=\"next\" accesskey=\"n\" href=\""
argument_list|)
expr_stmt|;
name|add_anchor_name
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_word_args
argument_list|(
literal|"\">%s</a>"
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prev
condition|)
block|{
name|tem
operator|=
name|expansion
argument_list|(
name|prev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|",\n"
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
name|_
argument_list|(
literal|"Previous:"
argument_list|)
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"&nbsp;"
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"<a rel=\"previous\" accesskey=\"p\" href=\""
argument_list|)
expr_stmt|;
name|add_anchor_name
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_word_args
argument_list|(
literal|"\">%s</a>"
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|up
condition|)
block|{
name|tem
operator|=
name|expansion
argument_list|(
name|up
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|",\n"
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
name|_
argument_list|(
literal|"Up:"
argument_list|)
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"&nbsp;"
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"<a rel=\"up\" accesskey=\"u\" href=\""
argument_list|)
expr_stmt|;
name|add_anchor_name
argument_list|(
name|tem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_word_args
argument_list|(
literal|"\">%s</a>"
argument_list|,
name|tem
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
comment|/* html fixxme: we want a `top' or `contents' link here.  */
name|add_word_args
argument_list|(
literal|"\n%s<br>\n"
argument_list|,
name|splitting
condition|?
literal|"<hr>"
else|:
literal|""
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"</div>\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|docbook
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|xml
condition|)
block|{
if|if
condition|(
name|next
condition|)
block|{
name|xml_insert_element
argument_list|(
name|NODENEXT
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|NODENEXT
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prev
condition|)
block|{
name|xml_insert_element
argument_list|(
name|NODEPREV
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|NODEPREV
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|up
condition|)
block|{
name|xml_insert_element
argument_list|(
name|NODEUP
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|up
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|NODEUP
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|no_headers
condition|)
block|{
if|if
condition|(
name|macro_expansion_output_stream
condition|)
name|me_inhibit_expansion
operator|++
expr_stmt|;
comment|/* These strings are not translatable.  */
if|if
condition|(
name|next
condition|)
block|{
name|execute_string
argument_list|(
literal|",  Next: %s"
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|prev
condition|)
block|{
name|execute_string
argument_list|(
literal|",  Prev: %s"
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|up
condition|)
block|{
name|execute_string
argument_list|(
literal|",  Up: %s"
argument_list|,
name|up
argument_list|)
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|macro_expansion_output_stream
condition|)
name|me_inhibit_expansion
operator|--
expr_stmt|;
block|}
name|close_paragraph
argument_list|()
expr_stmt|;
name|no_indent
operator|=
literal|0
expr_stmt|;
comment|/* Change the section only if there was a sectioning command. */
if|if
condition|(
name|this_section
operator|>=
literal|0
condition|)
name|current_section
operator|=
name|this_section
expr_stmt|;
if|if
condition|(
name|current_node
operator|&&
name|STREQ
argument_list|(
name|current_node
argument_list|,
literal|"Top"
argument_list|)
condition|)
name|top_node_seen
operator|=
literal|1
expr_stmt|;
name|filling_enabled
operator|=
literal|1
expr_stmt|;
name|in_fixed_width_font
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cross-reference target at an arbitrary spot.  */
end_comment

begin_function
name|void
name|cm_anchor
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|anchor
decl_stmt|;
name|char
modifier|*
name|fname_for_anchor
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|END
condition|)
return|return;
comment|/* Parse the anchor text.  */
name|anchor
operator|=
name|get_xref_token
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Force all versions of "top" to be "Top". */
name|normalize_node_name
argument_list|(
name|anchor
argument_list|)
expr_stmt|;
comment|/* In HTML mode, need to actually produce some output.  */
if|if
condition|(
name|html
condition|)
block|{
comment|/* If this anchor is at the beginning of a new paragraph, make 	 sure a new paragraph is indeed started.  */
if|if
condition|(
operator|!
name|paragraph_is_open
condition|)
block|{
if|if
condition|(
operator|!
name|executing_string
operator|&&
name|html
condition|)
name|html_output_head
argument_list|()
expr_stmt|;
name|start_paragraph
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|in_fixed_width_font
operator|||
name|in_menu
operator|||
name|in_detailmenu
condition|)
block|{
name|insert_string
argument_list|(
literal|"<p>"
argument_list|)
expr_stmt|;
name|in_paragraph
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|add_word
argument_list|(
literal|"<a name=\""
argument_list|)
expr_stmt|;
name|add_anchor_name
argument_list|(
name|anchor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"\"></a>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|splitting
condition|)
block|{
comment|/* If we are splitting, cm_xref will produce a reference to 	     a file whose name is derived from the anchor name.  So we 	     must create a file when we see an @anchor, otherwise 	     xref's to anchors won't work.  The file we create simply 	     redirects to the file of this anchor's node.  */
name|TAG_ENTRY
modifier|*
name|tag
decl_stmt|;
name|fname_for_anchor
operator|=
name|nodename_to_filename
argument_list|(
name|anchor
argument_list|)
expr_stmt|;
comment|/* See if the anchor name converted to a file name clashes 	     with other anchors or nodes.  */
name|tag
operator|=
name|find_node_by_fname
argument_list|(
name|fname_for_anchor
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
condition|)
block|{
if|if
condition|(
operator|(
name|tag
operator|->
name|flags
operator|&
name|TAG_FLAG_ANCHOR
operator|)
operator|!=
literal|0
condition|)
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Anchors `%s' and `%s' map to the same file name"
argument_list|)
argument_list|,
name|anchor
argument_list|,
name|tag
operator|->
name|node
argument_list|)
expr_stmt|;
else|else
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Anchor `%s' and node `%s' map to the same file name"
argument_list|)
argument_list|,
name|anchor
argument_list|,
name|tag
operator|->
name|node
argument_list|)
expr_stmt|;
name|line_error
argument_list|(
name|_
argument_list|(
literal|"@anchor command ignored; references to it will not work"
argument_list|)
argument_list|)
expr_stmt|;
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Rename this anchor or use the `--no-split' option"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fname_for_anchor
argument_list|)
expr_stmt|;
comment|/* We will not be creating a file for this anchor, so 		 set its name to NULL, so that remember_node stores a 		 NULL and find_node_by_fname won't consider this 		 anchor for clashes.  */
name|fname_for_anchor
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|dirname
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
name|filename
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|FILE
modifier|*
name|anchor_stream
decl_stmt|;
name|dirname
operator|=
name|pathname_part
argument_list|(
name|current_output_filename
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|filename
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|filename
argument_list|,
name|fname_for_anchor
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|anchor_stream
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|anchor_stream
operator|==
name|NULL
condition|)
block|{
name|fs_error
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* The HTML magic below will cause the browser to 		 immediately go to the anchor's node's file.  Lynx 		 seems not to support this redirection, but it looks 		 like a bug in Lynx, and they can work around it by 		 clicking on the link once more.  */
name|fputs
argument_list|(
literal|"<meta http-equiv=\"refresh\" content=\"0; url="
argument_list|,
name|anchor_stream
argument_list|)
expr_stmt|;
comment|/* Make the indirect link point to the current node's 		 file and anchor's "<a name" label.  If we don't have 		 a valid node name, refer to the current output file 		 instead.  */
if|if
condition|(
name|current_node
operator|&&
operator|*
name|current_node
condition|)
block|{
name|char
modifier|*
name|fn
decl_stmt|,
modifier|*
name|tem
decl_stmt|;
name|tem
operator|=
name|expand_node_name
argument_list|(
name|current_node
argument_list|)
expr_stmt|;
name|fn
operator|=
name|nodename_to_filename
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|fn
argument_list|,
name|anchor_stream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|base
init|=
name|filename_part
argument_list|(
name|current_output_filename
argument_list|)
decl_stmt|;
name|fputs
argument_list|(
name|base
argument_list|,
name|anchor_stream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"#"
argument_list|,
name|anchor_stream
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|anchor
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'&'
condition|)
name|fputs
argument_list|(
literal|"&amp;"
argument_list|,
name|anchor_stream
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|URL_SAFE_CHAR
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|fprintf
argument_list|(
name|anchor_stream
argument_list|,
literal|"%%%x"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
expr_stmt|;
else|else
name|fputc
argument_list|(
operator|*
name|p
argument_list|,
name|anchor_stream
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"\">\n"
argument_list|,
name|anchor_stream
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|anchor_stream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|xml
condition|)
block|{
name|xml_insert_element_with_attribute
argument_list|(
name|ANCHOR
argument_list|,
name|START
argument_list|,
literal|"name=\"%s\""
argument_list|,
name|anchor
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|ANCHOR
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
comment|/* Save it in the tag table.  */
name|remember_node
argument_list|(
name|anchor
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|output_position
operator|+
name|output_paragraph_offset
argument_list|,
name|line_number
argument_list|,
name|fname_for_anchor
argument_list|,
name|TAG_FLAG_ANCHOR
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find NODE in REF_LIST. */
end_comment

begin_function
specifier|static
name|NODE_REF
modifier|*
name|find_node_reference
parameter_list|(
name|node
parameter_list|,
name|ref_list
parameter_list|)
name|char
modifier|*
name|node
decl_stmt|;
name|NODE_REF
modifier|*
name|ref_list
decl_stmt|;
block|{
name|NODE_REF
modifier|*
name|orig_ref_list
init|=
name|ref_list
decl_stmt|;
name|char
modifier|*
name|expanded_node
decl_stmt|;
while|while
condition|(
name|ref_list
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|node
argument_list|,
name|ref_list
operator|->
name|node
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|ref_list
operator|=
name|ref_list
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|ref_list
operator|||
operator|!
name|expensive_validation
condition|)
return|return
name|ref_list
return|;
comment|/* Maybe NODE is not expanded yet.  This may be SLOW.  */
name|expanded_node
operator|=
name|expand_node_name
argument_list|(
name|node
argument_list|)
expr_stmt|;
for|for
control|(
name|ref_list
operator|=
name|orig_ref_list
init|;
name|ref_list
condition|;
name|ref_list
operator|=
name|ref_list
operator|->
name|next
control|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|expanded_node
argument_list|,
name|ref_list
operator|->
name|node
argument_list|)
condition|)
break|break;
if|if
condition|(
name|strchr
argument_list|(
name|ref_list
operator|->
name|node
argument_list|,
name|COMMAND_PREFIX
argument_list|)
condition|)
block|{
name|char
modifier|*
name|expanded_ref
init|=
name|expand_node_name
argument_list|(
name|ref_list
operator|->
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|expanded_node
argument_list|,
name|expanded_ref
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|expanded_ref
argument_list|)
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|expanded_ref
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|expanded_node
argument_list|)
expr_stmt|;
return|return
name|ref_list
return|;
block|}
end_function

begin_function
name|void
name|free_node_references
parameter_list|()
block|{
name|NODE_REF
modifier|*
name|list
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|list
operator|=
name|node_references
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|temp
operator|=
name|list
expr_stmt|;
name|free
argument_list|(
name|list
operator|->
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
operator|->
name|containing_node
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|node_references
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|free_node_node_references
parameter_list|()
block|{
name|NODE_REF
modifier|*
name|list
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|list
operator|=
name|node_references
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|temp
operator|=
name|list
expr_stmt|;
name|free
argument_list|(
name|list
operator|->
name|node
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|node_node_references
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number assigned to a named node in either the tag_table    or node_references list or zero if no number has been assigned. */
end_comment

begin_function
name|int
name|number_of_node
parameter_list|(
name|node
parameter_list|)
name|char
modifier|*
name|node
decl_stmt|;
block|{
name|NODE_REF
modifier|*
name|temp_ref
decl_stmt|;
name|TAG_ENTRY
modifier|*
name|temp_node
init|=
name|find_node
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp_node
condition|)
return|return
name|temp_node
operator|->
name|number
return|;
elseif|else
if|if
condition|(
operator|(
name|temp_ref
operator|=
name|find_node_reference
argument_list|(
name|node
argument_list|,
name|node_references
argument_list|)
operator|)
condition|)
return|return
name|temp_ref
operator|->
name|number
return|;
elseif|else
if|if
condition|(
operator|(
name|temp_ref
operator|=
name|find_node_reference
argument_list|(
name|node
argument_list|,
name|node_node_references
argument_list|)
operator|)
condition|)
return|return
name|temp_ref
operator|->
name|number
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* validation */
end_comment

begin_comment
comment|/* Return 1 if TAG (at LINE) correctly validated, or 0 if not.    LABEL is the (translated) description of the type of reference --    Menu, Cross, Next, etc.  */
end_comment

begin_function
specifier|static
name|int
name|validate
parameter_list|(
name|tag
parameter_list|,
name|line
parameter_list|,
name|label
parameter_list|)
name|char
modifier|*
name|tag
decl_stmt|;
name|int
name|line
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
block|{
name|TAG_ENTRY
modifier|*
name|result
decl_stmt|;
comment|/* If there isn't a tag to verify, or if the tag is in another file,      then it must be okay. */
if|if
condition|(
operator|!
name|tag
operator|||
operator|!
operator|*
name|tag
operator|||
operator|*
name|tag
operator|==
literal|'('
condition|)
return|return
literal|1
return|;
comment|/* Otherwise, the tag must exist. */
name|result
operator|=
name|find_node
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|line_number
operator|=
name|line
expr_stmt|;
name|line_error
argument_list|(
name|_
argument_list|(
literal|"%s reference to nonexistent node `%s' (perhaps incorrect sectioning?)"
argument_list|)
argument_list|,
name|label
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|result
operator|->
name|touched
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The strings here are followed in the message by `reference to...' in    the `validate' routine.  They are only used in messages, thus are    translated.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|reftype_type_string
parameter_list|(
name|type
parameter_list|)
name|enum
name|reftype
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|menu_reference
case|:
return|return
name|_
argument_list|(
literal|"Menu"
argument_list|)
return|;
case|case
name|followed_reference
case|:
return|return
name|_
argument_list|(
literal|"Cross"
argument_list|)
return|;
default|default:
return|return
literal|"Internal-bad-reference-type"
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|validate_other_references
parameter_list|(
name|ref_list
parameter_list|)
name|NODE_REF
modifier|*
name|ref_list
decl_stmt|;
block|{
name|char
modifier|*
name|old_input_filename
init|=
name|input_filename
decl_stmt|;
while|while
condition|(
name|ref_list
condition|)
block|{
name|input_filename
operator|=
name|ref_list
operator|->
name|filename
expr_stmt|;
name|validate
argument_list|(
name|ref_list
operator|->
name|node
argument_list|,
name|ref_list
operator|->
name|line_no
argument_list|,
name|reftype_type_string
argument_list|(
name|ref_list
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|ref_list
operator|=
name|ref_list
operator|->
name|next
expr_stmt|;
block|}
name|input_filename
operator|=
name|old_input_filename
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Validation of an info file.    Scan through the list of tag entries touching the Prev, Next, and Up    elements of each.  It is an error not to be able to touch one of them,    except in the case of external node references, such as "(DIR)".     If the Prev is different from the Up,    then the Prev node must have a Next pointing at this node.     Every node except Top must have an Up.    The Up node must contain some sort of reference, other than a Next,    to this node.     If the Next is different from the Next of the Up,    then the Next node must have a Prev pointing at this node. */
end_comment

begin_function
name|void
name|validate_file
parameter_list|(
name|tag_table
parameter_list|)
name|TAG_ENTRY
modifier|*
name|tag_table
decl_stmt|;
block|{
name|char
modifier|*
name|old_input_filename
init|=
name|input_filename
decl_stmt|;
name|TAG_ENTRY
modifier|*
name|tags
init|=
name|tag_table
decl_stmt|;
while|while
condition|(
name|tags
condition|)
block|{
name|TAG_ENTRY
modifier|*
name|temp_tag
decl_stmt|;
name|char
modifier|*
name|tem1
decl_stmt|,
modifier|*
name|tem2
decl_stmt|;
name|input_filename
operator|=
name|tags
operator|->
name|filename
expr_stmt|;
name|line_number
operator|=
name|tags
operator|->
name|line_no
expr_stmt|;
comment|/* If this is a "no warn" node, don't validate it in any way. */
if|if
condition|(
name|tags
operator|->
name|flags
operator|&
name|TAG_FLAG_NO_WARN
condition|)
block|{
name|tags
operator|=
name|tags
operator|->
name|next_ent
expr_stmt|;
continue|continue;
block|}
comment|/* If this node has a Next, then make sure that the Next exists. */
if|if
condition|(
name|tags
operator|->
name|next
condition|)
block|{
name|validate
argument_list|(
name|tags
operator|->
name|next
argument_list|,
name|tags
operator|->
name|line_no
argument_list|,
name|_
argument_list|(
literal|"Next"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the Next node exists, and there is no Up, then make sure              that the Prev of the Next points back.  But do nothing if              we aren't supposed to issue warnings about this node. */
name|temp_tag
operator|=
name|find_node
argument_list|(
name|tags
operator|->
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_tag
operator|&&
operator|!
operator|(
name|temp_tag
operator|->
name|flags
operator|&
name|TAG_FLAG_NO_WARN
operator|)
condition|)
block|{
name|char
modifier|*
name|prev
init|=
name|temp_tag
operator|->
name|prev
decl_stmt|;
name|int
name|you_lose
init|=
operator|!
name|prev
operator|||
operator|!
name|STREQ
argument_list|(
name|prev
argument_list|,
name|tags
operator|->
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|you_lose
operator|&&
name|expensive_validation
condition|)
block|{
name|tem1
operator|=
name|expand_node_name
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|tem2
operator|=
name|expand_node_name
argument_list|(
name|tags
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|tem1
argument_list|,
name|tem2
argument_list|)
condition|)
name|you_lose
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|tem1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tem2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|you_lose
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Next field of node `%s' not pointed to (perhaps incorrect sectioning?)"
argument_list|)
argument_list|,
name|tags
operator|->
name|node
argument_list|)
expr_stmt|;
name|file_line_error
argument_list|(
name|temp_tag
operator|->
name|filename
argument_list|,
name|temp_tag
operator|->
name|line_no
argument_list|,
name|_
argument_list|(
literal|"This node (%s) has the bad Prev"
argument_list|)
argument_list|,
name|temp_tag
operator|->
name|node
argument_list|)
expr_stmt|;
name|temp_tag
operator|->
name|flags
operator||=
name|TAG_FLAG_PREV_ERROR
expr_stmt|;
block|}
block|}
block|}
comment|/* Validate the Prev field if there is one, and we haven't already          complained about it in some way.  You don't have to have a Prev          field at this stage. */
if|if
condition|(
operator|!
operator|(
name|tags
operator|->
name|flags
operator|&
name|TAG_FLAG_PREV_ERROR
operator|)
operator|&&
name|tags
operator|->
name|prev
condition|)
block|{
name|int
name|valid_p
init|=
name|validate
argument_list|(
name|tags
operator|->
name|prev
argument_list|,
name|tags
operator|->
name|line_no
argument_list|,
name|_
argument_list|(
literal|"Prev"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|valid_p
condition|)
name|tags
operator|->
name|flags
operator||=
name|TAG_FLAG_PREV_ERROR
expr_stmt|;
else|else
block|{
comment|/* If the Prev field is not the same as the Up field,                  then the node pointed to by the Prev field must have                  a Next field which points to this node. */
name|int
name|prev_equals_up
init|=
operator|!
name|tags
operator|->
name|up
operator|||
name|STREQ
argument_list|(
name|tags
operator|->
name|prev
argument_list|,
name|tags
operator|->
name|up
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|prev_equals_up
operator|&&
name|expensive_validation
condition|)
block|{
name|tem1
operator|=
name|expand_node_name
argument_list|(
name|tags
operator|->
name|prev
argument_list|)
expr_stmt|;
name|tem2
operator|=
name|expand_node_name
argument_list|(
name|tags
operator|->
name|up
argument_list|)
expr_stmt|;
name|prev_equals_up
operator|=
name|STREQ
argument_list|(
name|tem1
argument_list|,
name|tem2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tem1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tem2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|prev_equals_up
condition|)
block|{
name|temp_tag
operator|=
name|find_node
argument_list|(
name|tags
operator|->
name|prev
argument_list|)
expr_stmt|;
comment|/* If we aren't supposed to issue warnings about the                      target node, do nothing. */
if|if
condition|(
operator|!
name|temp_tag
operator|||
operator|(
name|temp_tag
operator|->
name|flags
operator|&
name|TAG_FLAG_NO_WARN
operator|)
condition|)
comment|/* Do nothing. */
empty_stmt|;
else|else
block|{
name|int
name|you_lose
init|=
operator|!
name|temp_tag
operator|->
name|next
operator|||
operator|!
name|STREQ
argument_list|(
name|temp_tag
operator|->
name|next
argument_list|,
name|tags
operator|->
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp_tag
operator|->
name|next
operator|&&
name|you_lose
operator|&&
name|expensive_validation
condition|)
block|{
name|tem1
operator|=
name|expand_node_name
argument_list|(
name|temp_tag
operator|->
name|next
argument_list|)
expr_stmt|;
name|tem2
operator|=
name|expand_node_name
argument_list|(
name|tags
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|tem1
argument_list|,
name|tem2
argument_list|)
condition|)
name|you_lose
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|tem1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tem2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|you_lose
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Prev field of node `%s' not pointed to"
argument_list|)
argument_list|,
name|tags
operator|->
name|node
argument_list|)
expr_stmt|;
name|file_line_error
argument_list|(
name|temp_tag
operator|->
name|filename
argument_list|,
name|temp_tag
operator|->
name|line_no
argument_list|,
name|_
argument_list|(
literal|"This node (%s) has the bad Next"
argument_list|)
argument_list|,
name|temp_tag
operator|->
name|node
argument_list|)
expr_stmt|;
name|temp_tag
operator|->
name|flags
operator||=
name|TAG_FLAG_NEXT_ERROR
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|tags
operator|->
name|up
operator|&&
operator|!
operator|(
name|tags
operator|->
name|flags
operator|&
name|TAG_FLAG_ANCHOR
operator|)
operator|&&
name|strcasecmp
argument_list|(
name|tags
operator|->
name|node
argument_list|,
literal|"Top"
argument_list|)
operator|!=
literal|0
condition|)
name|line_error
argument_list|(
name|_
argument_list|(
literal|"`%s' has no Up field (perhaps incorrect sectioning?)"
argument_list|)
argument_list|,
name|tags
operator|->
name|node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tags
operator|->
name|up
condition|)
block|{
name|int
name|valid_p
init|=
name|validate
argument_list|(
name|tags
operator|->
name|up
argument_list|,
name|tags
operator|->
name|line_no
argument_list|,
name|_
argument_list|(
literal|"Up"
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If node X has Up: Y, then warn if Y fails to have a menu item              or note pointing at X, if Y isn't of the form "(Y)". */
if|if
condition|(
name|valid_p
operator|&&
operator|*
name|tags
operator|->
name|up
operator|!=
literal|'('
condition|)
block|{
name|NODE_REF
modifier|*
name|nref
decl_stmt|;
name|NODE_REF
modifier|*
name|tref
init|=
name|NULL
decl_stmt|;
name|NODE_REF
modifier|*
name|list
init|=
name|node_references
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|nref
operator|=
name|find_node_reference
argument_list|(
name|tags
operator|->
name|node
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nref
condition|)
break|break;
if|if
condition|(
name|strcmp
argument_list|(
name|nref
operator|->
name|containing_node
argument_list|,
name|tags
operator|->
name|up
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nref
operator|->
name|type
operator|!=
name|menu_reference
condition|)
block|{
name|tref
operator|=
name|nref
expr_stmt|;
name|list
operator|=
name|nref
operator|->
name|next
expr_stmt|;
block|}
else|else
break|break;
block|}
name|list
operator|=
name|nref
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nref
condition|)
block|{
if|if
condition|(
operator|!
name|tref
operator|&&
name|expensive_validation
condition|)
block|{
comment|/* Sigh...  This might be AWFULLY slow, but if 		         they want this feature, they'll have to pay! 		         We do all the loop again expanding each 		         containing_node reference as we go.  */
name|char
modifier|*
name|tags_up
init|=
name|expand_node_name
argument_list|(
name|tags
operator|->
name|up
argument_list|)
decl_stmt|;
name|char
modifier|*
name|tem
decl_stmt|;
name|list
operator|=
name|node_references
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|nref
operator|=
name|find_node_reference
argument_list|(
name|tags
operator|->
name|node
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nref
condition|)
break|break;
name|tem
operator|=
name|expand_node_name
argument_list|(
name|nref
operator|->
name|containing_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|tem
argument_list|,
name|tags_up
argument_list|)
condition|)
block|{
if|if
condition|(
name|nref
operator|->
name|type
operator|!=
name|menu_reference
condition|)
name|tref
operator|=
name|nref
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|tem
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|free
argument_list|(
name|tem
argument_list|)
expr_stmt|;
name|list
operator|=
name|nref
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|nref
operator|&&
operator|!
name|tref
condition|)
block|{
name|temp_tag
operator|=
name|find_node
argument_list|(
name|tags
operator|->
name|up
argument_list|)
expr_stmt|;
name|file_line_error
argument_list|(
name|temp_tag
operator|->
name|filename
argument_list|,
name|temp_tag
operator|->
name|line_no
argument_list|,
name|_
argument_list|(
literal|"Node `%s' lacks menu item for `%s' despite being its Up target"
argument_list|)
argument_list|,
name|tags
operator|->
name|up
argument_list|,
name|tags
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|tags
operator|=
name|tags
operator|->
name|next_ent
expr_stmt|;
block|}
name|validate_other_references
argument_list|(
name|node_references
argument_list|)
expr_stmt|;
comment|/* We have told the user about the references which didn't exist.      Now tell him about the nodes which aren't referenced. */
for|for
control|(
name|tags
operator|=
name|tag_table
init|;
name|tags
condition|;
name|tags
operator|=
name|tags
operator|->
name|next_ent
control|)
block|{
comment|/* If this node is a "no warn" node, do nothing. */
if|if
condition|(
name|tags
operator|->
name|flags
operator|&
name|TAG_FLAG_NO_WARN
condition|)
block|{
name|tags
operator|=
name|tags
operator|->
name|next_ent
expr_stmt|;
continue|continue;
block|}
comment|/* Special hack.  If the node in question appears to have          been referenced more than REFERENCE_WARNING_LIMIT times,          give a warning. */
if|if
condition|(
name|tags
operator|->
name|touched
operator|>
name|reference_warning_limit
condition|)
block|{
name|input_filename
operator|=
name|tags
operator|->
name|filename
expr_stmt|;
name|line_number
operator|=
name|tags
operator|->
name|line_no
expr_stmt|;
name|warning
argument_list|(
name|_
argument_list|(
literal|"node `%s' has been referenced %d times"
argument_list|)
argument_list|,
name|tags
operator|->
name|node
argument_list|,
name|tags
operator|->
name|touched
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tags
operator|->
name|touched
operator|==
literal|0
condition|)
block|{
name|input_filename
operator|=
name|tags
operator|->
name|filename
expr_stmt|;
name|line_number
operator|=
name|tags
operator|->
name|line_no
expr_stmt|;
comment|/* Notice that the node "Top" is special, and doesn't have to              be referenced.   Anchors don't have to be referenced              either, you might define them for another document.  */
if|if
condition|(
name|strcasecmp
argument_list|(
name|tags
operator|->
name|node
argument_list|,
literal|"Top"
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|tags
operator|->
name|flags
operator|&
name|TAG_FLAG_ANCHOR
operator|)
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"unreferenced node `%s'"
argument_list|)
argument_list|,
name|tags
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
block|}
name|input_filename
operator|=
name|old_input_filename
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Splitting */
end_comment

begin_comment
comment|/* Return true if the tag entry pointed to by TAGS is the last node.    This means only anchors follow.  */
end_comment

begin_function
specifier|static
name|int
name|last_node_p
parameter_list|(
name|tags
parameter_list|)
name|TAG_ENTRY
modifier|*
name|tags
decl_stmt|;
block|{
name|int
name|last
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|tags
operator|->
name|next_ent
condition|)
block|{
name|tags
operator|=
name|tags
operator|->
name|next_ent
expr_stmt|;
if|if
condition|(
name|tags
operator|->
name|flags
operator|&
name|TAG_FLAG_ANCHOR
condition|)
empty_stmt|;
else|else
block|{
name|last
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
return|return
name|last
return|;
block|}
end_function

begin_comment
comment|/* Split large output files into a series of smaller files.  Each file    is pointed to in the tag table, which then gets written out as the    original file.  The new files have the same name as the original file    with a "-num" attached.  SIZE is the largest number of bytes to allow    in any single split file. */
end_comment

begin_function
name|void
name|split_file
parameter_list|(
name|filename
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|root_filename
decl_stmt|,
modifier|*
name|root_pathname
decl_stmt|;
name|char
modifier|*
name|the_file
decl_stmt|,
modifier|*
name|filename_part
argument_list|()
decl_stmt|;
name|struct
name|stat
name|fileinfo
decl_stmt|;
name|long
name|file_size
decl_stmt|;
name|char
modifier|*
name|the_header
decl_stmt|;
name|int
name|header_size
decl_stmt|;
name|int
name|dos_file_names
init|=
literal|0
decl_stmt|;
comment|/* if nonzero, don't exceed 8+3 limits */
comment|/* Can only do this to files with tag tables. */
if|if
condition|(
operator|!
name|tag_table
condition|)
return|return;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
name|DEFAULT_SPLIT_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|fileinfo
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
operator|(
name|long
operator|)
name|fileinfo
operator|.
name|st_size
operator|)
operator|<
name|size
operator|)
condition|)
return|return;
name|file_size
operator|=
operator|(
name|long
operator|)
name|fileinfo
operator|.
name|st_size
expr_stmt|;
name|the_file
operator|=
name|find_and_load
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|the_file
condition|)
return|return;
name|root_filename
operator|=
name|filename_part
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|root_pathname
operator|=
name|pathname_part
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Do we need to generate names of subfiles which don't exceed 8+3 limits? */
name|dos_file_names
operator|=
operator|!
name|HAVE_LONG_FILENAMES
argument_list|(
name|root_pathname
condition|?
name|root_pathname
else|:
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|root_pathname
condition|)
name|root_pathname
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Start splitting the file.  Walk along the tag table      outputting sections of the file.  When we have written      all of the nodes in the tag table, make the top-level      pointer file, which contains indirect pointers and      tags for the nodes. */
block|{
name|int
name|which_file
init|=
literal|1
decl_stmt|;
name|TAG_ENTRY
modifier|*
name|tags
init|=
name|tag_table
decl_stmt|;
name|char
modifier|*
name|indirect_info
init|=
name|NULL
decl_stmt|;
comment|/* Maybe we want a Local Variables section.  */
name|char
modifier|*
name|trailer
init|=
name|info_trailer
argument_list|()
decl_stmt|;
name|int
name|trailer_len
init|=
name|trailer
condition|?
name|strlen
argument_list|(
name|trailer
argument_list|)
else|:
literal|0
decl_stmt|;
comment|/* Remember the `header' of this file.  The first tag in the file is        the bottom of the header; the top of the file is the start. */
name|the_header
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
operator|(
name|header_size
operator|=
name|tags
operator|->
name|position
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|the_header
argument_list|,
name|the_file
argument_list|,
name|header_size
argument_list|)
expr_stmt|;
while|while
condition|(
name|tags
condition|)
block|{
name|int
name|file_top
decl_stmt|,
name|file_bot
decl_stmt|,
name|limit
decl_stmt|;
comment|/* Have to include the Control-_. */
name|file_top
operator|=
name|file_bot
operator|=
name|tags
operator|->
name|position
expr_stmt|;
name|limit
operator|=
name|file_top
operator|+
name|size
expr_stmt|;
comment|/* If the rest of this file is only one node, then            that is the entire subfile. */
if|if
condition|(
name|last_node_p
argument_list|(
name|tags
argument_list|)
condition|)
block|{
name|int
name|i
init|=
name|tags
operator|->
name|position
operator|+
literal|1
decl_stmt|;
name|char
name|last_char
init|=
name|the_file
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|file_size
condition|)
block|{
if|if
condition|(
operator|(
name|the_file
index|[
name|i
index|]
operator|==
literal|'\037'
operator|)
operator|&&
operator|(
operator|(
name|last_char
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|last_char
operator|==
literal|'\014'
operator|)
operator|)
condition|)
break|break;
else|else
name|last_char
operator|=
name|the_file
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|file_bot
operator|=
name|i
expr_stmt|;
name|tags
operator|=
name|tags
operator|->
name|next_ent
expr_stmt|;
goto|goto
name|write_region
goto|;
block|}
comment|/* Otherwise, find the largest number of nodes that can fit in            this subfile. */
for|for
control|(
init|;
name|tags
condition|;
name|tags
operator|=
name|tags
operator|->
name|next_ent
control|)
block|{
if|if
condition|(
name|last_node_p
argument_list|(
name|tags
argument_list|)
condition|)
block|{
comment|/* This entry is the last node.  Search forward for the end                    of this node, and that is the end of this file. */
name|int
name|i
init|=
name|tags
operator|->
name|position
operator|+
literal|1
decl_stmt|;
name|char
name|last_char
init|=
name|the_file
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|file_size
condition|)
block|{
if|if
condition|(
operator|(
name|the_file
index|[
name|i
index|]
operator|==
literal|'\037'
operator|)
operator|&&
operator|(
operator|(
name|last_char
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|last_char
operator|==
literal|'\014'
operator|)
operator|)
condition|)
break|break;
else|else
name|last_char
operator|=
name|the_file
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|file_bot
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|file_bot
operator|<
name|limit
condition|)
block|{
name|tags
operator|=
name|tags
operator|->
name|next_ent
expr_stmt|;
goto|goto
name|write_region
goto|;
block|}
else|else
block|{
comment|/* Here we want to write out everything before the last                        node, and then write the last node out in a file                        by itself. */
name|file_bot
operator|=
name|tags
operator|->
name|position
expr_stmt|;
goto|goto
name|write_region
goto|;
block|}
block|}
comment|/* Write region only if this was a node, not an anchor.  */
if|if
condition|(
name|tags
operator|->
name|next_ent
operator|->
name|position
operator|>
name|limit
operator|&&
operator|!
operator|(
name|tags
operator|->
name|flags
operator|&
name|TAG_FLAG_ANCHOR
operator|)
condition|)
block|{
if|if
condition|(
name|tags
operator|->
name|position
operator|==
name|file_top
condition|)
name|tags
operator|=
name|tags
operator|->
name|next_ent
expr_stmt|;
name|file_bot
operator|=
name|tags
operator|->
name|position
expr_stmt|;
name|write_region
label|:
block|{
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|split_filename
decl_stmt|,
modifier|*
name|split_basename
decl_stmt|;
name|unsigned
name|root_len
init|=
name|strlen
argument_list|(
name|root_filename
argument_list|)
decl_stmt|;
name|split_filename
operator|=
name|xmalloc
argument_list|(
literal|10
operator|+
name|strlen
argument_list|(
name|root_pathname
argument_list|)
operator|+
name|root_len
argument_list|)
expr_stmt|;
name|split_basename
operator|=
name|xmalloc
argument_list|(
literal|10
operator|+
name|root_len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|split_basename
argument_list|,
literal|"%s-%d"
argument_list|,
name|root_filename
argument_list|,
name|which_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|dos_file_names
condition|)
block|{
name|char
modifier|*
name|dot
init|=
name|strchr
argument_list|(
name|split_basename
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
name|unsigned
name|base_len
init|=
name|strlen
argument_list|(
name|split_basename
argument_list|)
decl_stmt|;
if|if
condition|(
name|dot
condition|)
block|{
comment|/* Make foobar.i1, .., foobar.i99, foobar.100, ... */
name|dot
index|[
literal|1
index|]
operator|=
literal|'i'
expr_stmt|;
name|memmove
argument_list|(
name|which_file
operator|<=
literal|99
condition|?
name|dot
operator|+
literal|2
else|:
name|dot
operator|+
literal|1
argument_list|,
name|split_basename
operator|+
name|root_len
operator|+
literal|1
argument_list|,
name|strlen
argument_list|(
name|split_basename
operator|+
name|root_len
operator|+
literal|1
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|base_len
operator|>
literal|8
condition|)
block|{
comment|/* Make foobar-1, .., fooba-10, .., foob-100, ... */
name|unsigned
name|numlen
init|=
name|base_len
operator|-
name|root_len
decl_stmt|;
name|memmove
argument_list|(
name|split_basename
operator|+
literal|8
operator|-
name|numlen
argument_list|,
name|split_basename
operator|+
name|root_len
argument_list|,
name|numlen
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|sprintf
argument_list|(
name|split_filename
argument_list|,
literal|"%s%s"
argument_list|,
name|root_pathname
argument_list|,
name|split_basename
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|split_filename
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
operator|||
name|write
argument_list|(
name|fd
argument_list|,
name|the_header
argument_list|,
name|header_size
argument_list|)
operator|!=
name|header_size
operator|||
name|write
argument_list|(
name|fd
argument_list|,
name|the_file
operator|+
name|file_top
argument_list|,
name|file_bot
operator|-
name|file_top
argument_list|)
operator|!=
operator|(
name|file_bot
operator|-
name|file_top
operator|)
operator|||
operator|(
name|trailer_len
operator|&&
name|write
argument_list|(
name|fd
argument_list|,
name|trailer
argument_list|,
name|trailer_len
argument_list|)
operator|!=
name|trailer_len
operator|)
operator|||
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|split_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|indirect_info
condition|)
block|{
name|indirect_info
operator|=
name|the_file
operator|+
name|file_top
expr_stmt|;
name|sprintf
argument_list|(
name|indirect_info
argument_list|,
literal|"\037\nIndirect:\n"
argument_list|)
expr_stmt|;
name|indirect_info
operator|+=
name|strlen
argument_list|(
name|indirect_info
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|indirect_info
argument_list|,
literal|"%s: %d\n"
argument_list|,
name|split_basename
argument_list|,
name|file_top
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|split_basename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|split_filename
argument_list|)
expr_stmt|;
name|indirect_info
operator|+=
name|strlen
argument_list|(
name|indirect_info
argument_list|)
expr_stmt|;
name|which_file
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* We have sucessfully created the subfiles.  Now write out the        original again.  We must use `output_stream', or        write_tag_table_indirect () won't know where to place the output. */
name|output_stream
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|output_stream
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|{
name|int
name|distance
init|=
name|indirect_info
operator|-
name|the_file
decl_stmt|;
name|fwrite
argument_list|(
name|the_file
argument_list|,
literal|1
argument_list|,
name|distance
argument_list|,
name|output_stream
argument_list|)
expr_stmt|;
comment|/* Inhibit newlines. */
name|paragraph_is_open
operator|=
literal|0
expr_stmt|;
comment|/* Write the indirect tag table.  */
name|write_tag_table_indirect
argument_list|()
expr_stmt|;
comment|/* preserve local variables in info output.  */
if|if
condition|(
name|trailer
condition|)
block|{
name|insert_string
argument_list|(
name|trailer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|trailer
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|output_stream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|the_header
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|the_file
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

end_unit

