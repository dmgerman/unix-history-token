begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* index.c -- indexing for Texinfo.    $Id: index.c,v 1.17 2004/11/30 02:03:23 karl Exp $     Copyright (C) 1998, 1999, 2002, 2003, 2004 Free Software Foundation,    Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"files.h"
end_include

begin_include
include|#
directive|include
file|"footnote.h"
end_include

begin_include
include|#
directive|include
file|"html.h"
end_include

begin_include
include|#
directive|include
file|"index.h"
end_include

begin_include
include|#
directive|include
file|"lang.h"
end_include

begin_include
include|#
directive|include
file|"macro.h"
end_include

begin_include
include|#
directive|include
file|"sectioning.h"
end_include

begin_include
include|#
directive|include
file|"toc.h"
end_include

begin_include
include|#
directive|include
file|"xml.h"
end_include

begin_decl_stmt
name|INDEX_ALIST
modifier|*
modifier|*
name|name_index_alist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An array of pointers.  Each one is for a different index.  The    "synindex" command changes which array slot is pointed to by a    given "index". */
end_comment

begin_decl_stmt
name|INDEX_ELT
modifier|*
modifier|*
name|the_indices
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of defined indices. */
end_comment

begin_decl_stmt
name|int
name|defined_indices
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the order of the index.  */
end_comment

begin_decl_stmt
name|int
name|index_counter
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stuff for defining commands on the fly. */
end_comment

begin_decl_stmt
name|COMMAND
modifier|*
modifier|*
name|user_command_array
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|user_command_array_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to compare index entries for sorting.  May be set to strcoll.  */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|index_compare_fn
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|b
parameter_list|)
init|=
name|strcasecmp
function_decl|;
end_function_decl

begin_comment
comment|/* Function to compare index entries for sorting.  (Calls    `index_compare_fn' above.)  */
end_comment

begin_function_decl
name|int
name|index_element_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|element1
parameter_list|,
specifier|const
name|void
modifier|*
name|element2
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Find which element in the known list of indices has this name.    Returns -1 if NAME isn't found. */
end_comment

begin_function
specifier|static
name|int
name|find_index_offset
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|defined_indices
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name_index_alist
index|[
name|i
index|]
operator|&&
name|STREQ
argument_list|(
name|name
argument_list|,
name|name_index_alist
index|[
name|i
index|]
operator|->
name|name
argument_list|)
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the entry of (name . index) for this name.    Return NULL if the index doesn't exist. */
end_comment

begin_function
specifier|static
name|INDEX_ALIST
modifier|*
name|find_index
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|offset
init|=
name|find_index_offset
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|>
operator|-
literal|1
condition|)
return|return
name|name_index_alist
index|[
name|offset
index|]
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* User-defined commands, which happens only from user-defined indexes.    Used to initialize the builtin indices, too.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|define_user_command
argument_list|(
name|char
operator|*
name|name
argument_list|,
name|COMMAND_FUNCTION
argument_list|(
operator|*
name|proc
argument_list|)
argument_list|,
name|int
name|needs_braces_p
argument_list|)
block|{
name|int
name|slot
init|=
name|user_command_array_len
decl_stmt|;
name|user_command_array_len
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|user_command_array
condition|)
name|user_command_array
operator|=
name|xmalloc
argument_list|(
literal|1
operator|*
sizeof|sizeof
argument_list|(
name|COMMAND
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|user_command_array
operator|=
name|xrealloc
argument_list|(
name|user_command_array
argument_list|,
operator|(
literal|1
operator|+
name|user_command_array_len
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|COMMAND
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|user_command_array
index|[
name|slot
index|]
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|COMMAND
argument_list|)
argument_list|)
expr_stmt|;
name|user_command_array
index|[
name|slot
index|]
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|user_command_array
index|[
name|slot
index|]
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|user_command_array
index|[
name|slot
index|]
operator|->
name|argument_in_braces
operator|=
name|needs_braces_p
expr_stmt|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Please release me, let me go... */
end_comment

begin_function
specifier|static
name|void
name|free_index
parameter_list|(
name|INDEX_ELT
modifier|*
name|index
parameter_list|)
block|{
name|INDEX_ELT
modifier|*
name|temp
decl_stmt|;
while|while
condition|(
operator|(
name|temp
operator|=
name|index
operator|)
condition|)
block|{
name|free
argument_list|(
name|temp
operator|->
name|entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|entry_text
argument_list|)
expr_stmt|;
comment|/* Do not free the node, because we already freed the tag table,          which freed all the node names.  */
comment|/* free (temp->node); */
name|index
operator|=
name|index
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Flush an index by name.  This will delete the list of entries that    would be written by a @printindex command for this index. */
end_comment

begin_function
specifier|static
name|void
name|undefindex
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|which
init|=
name|find_index_offset
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|/* The index might have already been freed if this was the target of      an @synindex.  */
if|if
condition|(
name|which
operator|<
literal|0
operator|||
operator|!
name|name_index_alist
index|[
name|which
index|]
condition|)
return|return;
name|i
operator|=
name|name_index_alist
index|[
name|which
index|]
operator|->
name|read_index
expr_stmt|;
name|free_index
argument_list|(
name|the_indices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|the_indices
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|name_index_alist
index|[
name|which
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name_index_alist
index|[
name|which
index|]
argument_list|)
expr_stmt|;
name|name_index_alist
index|[
name|which
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add the arguments to the current index command to the index NAME.  */
end_comment

begin_function
specifier|static
name|void
name|index_add_arg
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|which
decl_stmt|;
name|char
modifier|*
name|index_entry
decl_stmt|;
name|INDEX_ALIST
modifier|*
name|tem
decl_stmt|;
name|tem
operator|=
name|find_index
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|which
operator|=
name|tem
condition|?
name|tem
operator|->
name|write_index
else|:
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|macro_expansion_output_stream
operator|&&
operator|!
name|executing_string
condition|)
name|append_to_expansion_output
argument_list|(
name|input_text_offset
operator|+
literal|1
argument_list|)
expr_stmt|;
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|index_entry
argument_list|)
expr_stmt|;
name|ignore_blank_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|macro_expansion_output_stream
operator|&&
operator|!
name|executing_string
condition|)
block|{
name|char
modifier|*
name|index_line
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|index_entry
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|index_line
argument_list|,
literal|"%s\n"
argument_list|,
name|index_entry
argument_list|)
expr_stmt|;
name|me_execute_string_keep_state
argument_list|(
name|index_line
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|index_line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|which
operator|<
literal|0
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Unknown index `%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|index_entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|INDEX_ELT
modifier|*
name|new
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|INDEX_ELT
argument_list|)
argument_list|)
decl_stmt|;
name|index_counter
operator|++
expr_stmt|;
comment|/* Get output line number updated before doing anything.  */
if|if
condition|(
operator|!
name|html
operator|&&
operator|!
name|xml
condition|)
name|flush_output
argument_list|()
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|the_indices
index|[
name|which
index|]
expr_stmt|;
name|new
operator|->
name|entry
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|entry_text
operator|=
name|index_entry
expr_stmt|;
comment|/* Since footnotes are handled at the very end of the document,          node name in the non-split HTML outputs always show the last          node.  We artificially make it ``Footnotes''.  */
if|if
condition|(
name|html
operator|&&
operator|!
name|splitting
operator|&&
name|already_outputting_pending_notes
condition|)
name|new
operator|->
name|node
operator|=
name|xstrdup
argument_list|(
name|_
argument_list|(
literal|"Footnotes"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|new
operator|->
name|node
operator|=
name|current_node
condition|?
name|current_node
else|:
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|html
operator|&&
operator|!
name|xml
operator|&&
name|no_headers
condition|)
block|{
name|new
operator|->
name|section
operator|=
name|current_sectioning_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|new
operator|->
name|section
argument_list|)
operator|==
literal|0
condition|)
name|new
operator|->
name|section_name
operator|=
name|current_sectioning_name
argument_list|()
expr_stmt|;
else|else
name|new
operator|->
name|section_name
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|new
operator|->
name|section
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|section_name
operator|=
name|NULL
expr_stmt|;
block|}
name|new
operator|->
name|code
operator|=
name|tem
operator|->
name|code
expr_stmt|;
name|new
operator|->
name|defining_line
operator|=
name|line_number
operator|-
literal|1
expr_stmt|;
name|new
operator|->
name|output_line
operator|=
name|no_headers
condition|?
name|output_line_number
else|:
name|node_line_number
expr_stmt|;
comment|/* We need to make a copy since input_filename may point to          something that goes away, for example, inside a macro.          (see the findexerr test).  */
name|new
operator|->
name|defining_file
operator|=
name|xstrdup
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|html
operator|&&
name|splitting
condition|)
block|{
if|if
condition|(
name|current_output_filename
operator|&&
operator|*
name|current_output_filename
condition|)
name|new
operator|->
name|output_file
operator|=
name|filename_part
argument_list|(
name|current_output_filename
argument_list|)
expr_stmt|;
else|else
name|new
operator|->
name|output_file
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
name|new
operator|->
name|output_file
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|entry_number
operator|=
name|index_counter
expr_stmt|;
name|the_indices
index|[
name|which
index|]
operator|=
name|new
expr_stmt|;
if|#
directive|if
literal|0
comment|/* The index breaks if there are colons in the entry.          -- This is true, but it's too painful to force changing index          entries to use `colon', and too confusing for users.  The real          fix is to change Info support to support arbitrary characters          in node names, and we're not ready to do that.  --karl,          19mar02.  */
block|if (strchr (new->entry_text, ':'))         warning (_("Info cannot handle `:' in index entry `%s'"),                  new->entry_text);
endif|#
directive|endif
if|if
condition|(
name|html
condition|)
block|{
comment|/* Anchor.  */
name|int
name|removed_empty_elt
init|=
literal|0
decl_stmt|;
comment|/* We must put the anchor outside the<dl> and<ul> blocks.  */
if|if
condition|(
name|rollback_empty_tag
argument_list|(
literal|"dl"
argument_list|)
condition|)
name|removed_empty_elt
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|rollback_empty_tag
argument_list|(
literal|"ul"
argument_list|)
condition|)
name|removed_empty_elt
operator|=
literal|2
expr_stmt|;
name|add_word
argument_list|(
literal|"<a name=\"index-"
argument_list|)
expr_stmt|;
name|add_escaped_anchor_name
argument_list|(
name|index_entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_word_args
argument_list|(
literal|"-%d\"></a>"
argument_list|,
name|index_counter
argument_list|)
expr_stmt|;
if|if
condition|(
name|removed_empty_elt
operator|==
literal|1
condition|)
name|add_html_block_elt_args
argument_list|(
literal|"\n<dl>"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|removed_empty_elt
operator|==
literal|2
condition|)
name|add_html_block_elt_args
argument_list|(
literal|"\n<ul>"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|xml
condition|)
name|xml_insert_indexterm
argument_list|(
name|index_entry
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function which user defined index commands call. */
end_comment

begin_function
specifier|static
name|void
name|gen_index
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|xstrdup
argument_list|(
name|command
argument_list|)
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|>=
name|strlen
argument_list|(
literal|"index"
argument_list|)
condition|)
name|name
index|[
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
name|strlen
argument_list|(
literal|"index"
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|index_add_arg
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Define an index known as NAME.  We assign the slot number.    If CODE is nonzero, make this a code index. */
end_comment

begin_function
specifier|static
name|void
name|defindex
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|code
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|slot
decl_stmt|;
comment|/* If it already exists, flush it. */
name|undefindex
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Try to find an empty slot. */
name|slot
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|defined_indices
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|name_index_alist
index|[
name|i
index|]
condition|)
block|{
name|slot
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|slot
operator|<
literal|0
condition|)
block|{
comment|/* No such luck.  Make space for another index. */
name|slot
operator|=
name|defined_indices
expr_stmt|;
name|defined_indices
operator|++
expr_stmt|;
name|name_index_alist
operator|=
operator|(
name|INDEX_ALIST
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|name_index_alist
argument_list|,
operator|(
literal|1
operator|+
name|defined_indices
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ALIST
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|the_indices
operator|=
operator|(
name|INDEX_ELT
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|the_indices
argument_list|,
operator|(
literal|1
operator|+
name|defined_indices
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ELT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We have a slot.  Start assigning. */
name|name_index_alist
index|[
name|slot
index|]
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|INDEX_ALIST
argument_list|)
argument_list|)
expr_stmt|;
name|name_index_alist
index|[
name|slot
index|]
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name_index_alist
index|[
name|slot
index|]
operator|->
name|read_index
operator|=
name|slot
expr_stmt|;
name|name_index_alist
index|[
name|slot
index|]
operator|->
name|write_index
operator|=
name|slot
expr_stmt|;
name|name_index_alist
index|[
name|slot
index|]
operator|->
name|code
operator|=
name|code
expr_stmt|;
name|the_indices
index|[
name|slot
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define an index NAME, implicitly @code if CODE is nonzero.  */
end_comment

begin_function
specifier|static
name|void
name|top_defindex
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|code
parameter_list|)
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
literal|"index"
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%sindex"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|define_user_command
argument_list|(
name|temp
argument_list|,
name|gen_index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|defindex
argument_list|(
name|name
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set up predefined indices.  */
end_comment

begin_function
name|void
name|init_indices
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Create the default data structures. */
comment|/* Initialize data space. */
if|if
condition|(
operator|!
name|the_indices
condition|)
block|{
name|the_indices
operator|=
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
name|defined_indices
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ELT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|the_indices
index|[
name|defined_indices
index|]
operator|=
name|NULL
expr_stmt|;
name|name_index_alist
operator|=
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
name|defined_indices
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ALIST
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|name_index_alist
index|[
name|defined_indices
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* If there were existing indices, get rid of them now. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|defined_indices
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|name_index_alist
index|[
name|i
index|]
condition|)
block|{
comment|/* Suppose we're called with two input files, and the first              does a @synindex pg cp.  Then, when we get here to start              the second file, the "pg" element won't get freed by              undefindex (because it's pointing to "cp").  So free it              here; otherwise, when we try to define the pg index again              just below, it will still point to cp.  */
name|undefindex
argument_list|(
name|name_index_alist
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* undefindex sets all this to null in some cases.  */
if|if
condition|(
name|name_index_alist
index|[
name|i
index|]
condition|)
block|{
name|free
argument_list|(
name|name_index_alist
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name_index_alist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|name_index_alist
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|/* Add the default indices. */
name|top_defindex
argument_list|(
literal|"cp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* cp is the only non-code index.  */
name|top_defindex
argument_list|(
literal|"fn"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|top_defindex
argument_list|(
literal|"ky"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|top_defindex
argument_list|(
literal|"pg"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|top_defindex
argument_list|(
literal|"tp"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|top_defindex
argument_list|(
literal|"vr"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given an index name, return the offset in the_indices of this index,    or -1 if there is no such index. */
end_comment

begin_function
specifier|static
name|int
name|translate_index
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|INDEX_ALIST
modifier|*
name|which
init|=
name|find_index
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|which
condition|)
return|return
name|which
operator|->
name|read_index
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return the index list which belongs to NAME. */
end_comment

begin_function
name|INDEX_ELT
modifier|*
name|index_list
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|which
init|=
name|translate_index
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|which
operator|<
literal|0
condition|)
return|return
operator|(
name|INDEX_ELT
operator|*
operator|)
operator|-
literal|1
return|;
else|else
return|return
name|the_indices
index|[
name|which
index|]
return|;
block|}
end_function

begin_comment
comment|/* Define a new index command.  Arg is name of index. */
end_comment

begin_function
specifier|static
name|void
name|gen_defindex
parameter_list|(
name|int
name|code
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_index
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Index `%s' already exists"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|temp
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|"index"
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%sindex"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|define_user_command
argument_list|(
name|temp
argument_list|,
name|gen_index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|defindex
argument_list|(
name|name
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_defindex
parameter_list|(
name|void
parameter_list|)
block|{
name|gen_defindex
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_defcodeindex
parameter_list|(
name|void
parameter_list|)
block|{
name|gen_defindex
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expects 2 args, on the same line.  Both are index abbreviations.    Make the first one be a synonym for the second one, i.e. make the    first one have the same index as the second one. */
end_comment

begin_function
name|void
name|cm_synindex
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|source
decl_stmt|,
name|target
decl_stmt|;
name|char
modifier|*
name|abbrev1
decl_stmt|,
modifier|*
name|abbrev2
decl_stmt|;
name|skip_whitespace
argument_list|()
expr_stmt|;
name|get_until_in_line
argument_list|(
literal|0
argument_list|,
literal|" "
argument_list|,
operator|&
name|abbrev1
argument_list|)
expr_stmt|;
name|target
operator|=
name|find_index_offset
argument_list|(
name|abbrev1
argument_list|)
expr_stmt|;
name|skip_whitespace
argument_list|()
expr_stmt|;
name|get_until_in_line
argument_list|(
literal|0
argument_list|,
literal|" "
argument_list|,
operator|&
name|abbrev2
argument_list|)
expr_stmt|;
name|source
operator|=
name|find_index_offset
argument_list|(
name|abbrev2
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
operator|<
literal|0
operator|||
name|target
operator|<
literal|0
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Unknown index `%s' and/or `%s' in @synindex"
argument_list|)
argument_list|,
name|abbrev1
argument_list|,
name|abbrev2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|xml
operator|&&
operator|!
name|docbook
condition|)
name|xml_synindex
argument_list|(
name|abbrev1
argument_list|,
name|abbrev2
argument_list|)
expr_stmt|;
else|else
name|name_index_alist
index|[
name|target
index|]
operator|->
name|write_index
operator|=
name|name_index_alist
index|[
name|source
index|]
operator|->
name|write_index
expr_stmt|;
block|}
name|free
argument_list|(
name|abbrev1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|abbrev2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_pindex
parameter_list|(
name|void
parameter_list|)
comment|/* Pinhead index. */
block|{
name|index_add_arg
argument_list|(
literal|"pg"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_vindex
parameter_list|(
name|void
parameter_list|)
comment|/* Variable index. */
block|{
name|index_add_arg
argument_list|(
literal|"vr"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_kindex
parameter_list|(
name|void
parameter_list|)
comment|/* Key index. */
block|{
name|index_add_arg
argument_list|(
literal|"ky"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_cindex
parameter_list|(
name|void
parameter_list|)
comment|/* Concept index. */
block|{
name|index_add_arg
argument_list|(
literal|"cp"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_findex
parameter_list|(
name|void
parameter_list|)
comment|/* Function index. */
block|{
name|index_add_arg
argument_list|(
literal|"fn"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_tindex
parameter_list|(
name|void
parameter_list|)
comment|/* Data Type index. */
block|{
name|index_add_arg
argument_list|(
literal|"tp"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|index_element_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|element1
parameter_list|,
specifier|const
name|void
modifier|*
name|element2
parameter_list|)
block|{
name|INDEX_ELT
modifier|*
modifier|*
name|elt1
init|=
operator|(
name|INDEX_ELT
operator|*
operator|*
operator|)
name|element1
decl_stmt|;
name|INDEX_ELT
modifier|*
modifier|*
name|elt2
init|=
operator|(
name|INDEX_ELT
operator|*
operator|*
operator|)
name|element2
decl_stmt|;
return|return
name|index_compare_fn
argument_list|(
operator|(
operator|*
name|elt1
operator|)
operator|->
name|entry
argument_list|,
operator|(
operator|*
name|elt2
operator|)
operator|->
name|entry
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Force all index entries to be unique. */
end_comment

begin_function
specifier|static
name|void
name|make_index_entries_unique
parameter_list|(
name|INDEX_ELT
modifier|*
modifier|*
name|array
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|INDEX_ELT
modifier|*
modifier|*
name|copy
decl_stmt|;
name|int
name|counter
init|=
literal|1
decl_stmt|;
name|copy
operator|=
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
name|count
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ELT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
operator|(
name|count
operator|-
literal|1
operator|)
operator|||
name|array
index|[
name|i
index|]
operator|->
name|node
operator|!=
name|array
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|node
operator|||
operator|!
name|STREQ
argument_list|(
name|array
index|[
name|i
index|]
operator|->
name|entry
argument_list|,
name|array
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|entry
argument_list|)
condition|)
name|copy
index|[
name|j
operator|++
index|]
operator|=
name|array
index|[
name|i
index|]
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|array
index|[
name|i
index|]
operator|->
name|entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|array
index|[
name|i
index|]
operator|->
name|entry_text
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|copy
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Now COPY contains only unique entries.  Duplicated entries in the      original array have been freed.  Replace the current array with      the copy, fixing the NEXT pointers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|copy
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|copy
index|[
name|i
index|]
operator|->
name|next
operator|=
name|copy
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
comment|/* Fix entry names which are the same.  They point to different nodes,          so we make the entry name unique. */
if|if
condition|(
name|copy
index|[
name|i
operator|+
literal|1
index|]
operator|&&
name|STREQ
argument_list|(
name|copy
index|[
name|i
index|]
operator|->
name|entry
argument_list|,
name|copy
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|entry
argument_list|)
operator|&&
operator|!
name|html
condition|)
block|{
name|char
modifier|*
name|new_entry_name
decl_stmt|;
name|new_entry_name
operator|=
name|xmalloc
argument_list|(
literal|10
operator|+
name|strlen
argument_list|(
name|copy
index|[
name|i
index|]
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new_entry_name
argument_list|,
literal|"%s<%d>"
argument_list|,
name|copy
index|[
name|i
index|]
operator|->
name|entry
argument_list|,
name|counter
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|copy
index|[
name|i
index|]
operator|->
name|entry
argument_list|)
expr_stmt|;
name|copy
index|[
name|i
index|]
operator|->
name|entry
operator|=
name|new_entry_name
expr_stmt|;
name|counter
operator|++
expr_stmt|;
block|}
else|else
name|counter
operator|=
literal|1
expr_stmt|;
name|array
index|[
name|i
index|]
operator|=
name|copy
index|[
name|i
index|]
expr_stmt|;
block|}
name|array
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Free the storage used only by COPY. */
name|free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sort the index passed in INDEX, returning an array of pointers to    elements.  The array is terminated with a NULL pointer.  */
end_comment

begin_function
specifier|static
name|INDEX_ELT
modifier|*
modifier|*
name|sort_index
parameter_list|(
name|INDEX_ELT
modifier|*
name|index
parameter_list|)
block|{
name|INDEX_ELT
modifier|*
modifier|*
name|array
decl_stmt|;
name|INDEX_ELT
modifier|*
name|temp
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|save_line_number
init|=
name|line_number
decl_stmt|;
name|char
modifier|*
name|save_input_filename
init|=
name|input_filename
decl_stmt|;
name|int
name|save_html
init|=
name|html
decl_stmt|;
comment|/* Pretend we are in non-HTML mode, for the purpose of getting the      expanded index entry that lacks any markup and other HTML escape      characters which could produce a wrong sort order.  */
comment|/* fixme: html: this still causes some markup, such as non-ASCII      characters @AE{} etc., to sort incorrectly.  */
name|html
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|index
operator|,
name|count
operator|=
literal|0
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
operator|,
name|count
operator|++
control|)
empty_stmt|;
comment|/* We have the length, now we can allocate an array. */
name|array
operator|=
name|xmalloc
argument_list|(
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ELT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|index
operator|,
name|count
operator|=
literal|0
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
operator|,
name|count
operator|++
control|)
block|{
comment|/* Allocate new memory for the return array, since parts of the          original INDEX get freed.  Otherwise, if the document calls          @printindex twice on the same index, with duplicate entries,          we'll have garbage the second time.  There are cleaner ways to          deal, but this will suffice for now.  */
name|array
index|[
name|count
index|]
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|INDEX_ELT
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|array
index|[
name|count
index|]
operator|)
operator|=
operator|*
operator|(
name|temp
operator|)
expr_stmt|;
comment|/* struct assignment, hope it's ok */
comment|/* Adjust next pointers to use the new memory.  */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|array
index|[
name|count
operator|-
literal|1
index|]
operator|->
name|next
operator|=
name|array
index|[
name|count
index|]
expr_stmt|;
comment|/* Set line number and input filename to the source line for this          index entry, as this expansion finds any errors.  */
name|line_number
operator|=
name|array
index|[
name|count
index|]
operator|->
name|defining_line
expr_stmt|;
name|input_filename
operator|=
name|array
index|[
name|count
index|]
operator|->
name|defining_file
expr_stmt|;
comment|/* If this particular entry should be printed as a "code" index,          then expand it as @code{entry}, i.e., as in fixed-width font.  */
name|array
index|[
name|count
index|]
operator|->
name|entry
operator|=
name|expansion
argument_list|(
name|temp
operator|->
name|entry_text
argument_list|,
name|array
index|[
name|count
index|]
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
name|array
index|[
name|count
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* terminate the array. */
name|line_number
operator|=
name|save_line_number
expr_stmt|;
name|input_filename
operator|=
name|save_input_filename
expr_stmt|;
name|html
operator|=
name|save_html
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRCOLL
comment|/* This is not perfect.  We should set (then restore) the locale to the      documentlanguage, so strcoll operates according to the document's      locale, not the user's.  For now, I'm just going to assume that      those few new documents which use @documentlanguage will be      processed in the appropriate locale.  In any case, don't use      strcoll in the C (aka POSIX) locale, that is the ASCII ordering.  */
if|if
condition|(
name|language_code
operator|!=
name|en
condition|)
block|{
name|char
modifier|*
name|lang_env
init|=
name|getenv
argument_list|(
literal|"LANG"
argument_list|)
decl_stmt|;
if|if
condition|(
name|lang_env
operator|&&
operator|!
name|STREQ
argument_list|(
name|lang_env
argument_list|,
literal|"C"
argument_list|)
operator|&&
operator|!
name|STREQ
argument_list|(
name|lang_env
argument_list|,
literal|"POSIX"
argument_list|)
condition|)
name|index_compare_fn
operator|=
name|strcoll
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_STRCOLL */
comment|/* Sort the array. */
name|qsort
argument_list|(
name|array
argument_list|,
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|INDEX_ELT
operator|*
argument_list|)
argument_list|,
name|index_element_compare
argument_list|)
expr_stmt|;
comment|/* Remove duplicate entries.  */
name|make_index_entries_unique
argument_list|(
name|array
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* Replace the original index with the sorted one, in case the      document wants to print it again.  If the index wasn't empty.  */
if|if
condition|(
name|index
condition|)
operator|*
name|index
operator|=
operator|*
operator|*
name|array
expr_stmt|;
return|return
name|array
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_index_output_line_no
parameter_list|(
name|int
name|line_number
parameter_list|,
name|int
name|output_line_number_len
parameter_list|)
block|{
name|int
name|last_column
decl_stmt|;
name|int
name|str_size
init|=
name|output_line_number_len
operator|+
name|strlen
argument_list|(
name|_
argument_list|(
literal|"(line )"
argument_list|)
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|char
modifier|*
name|out_line_no_str
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|str_size
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* Do not translate ``(line NNN)'' below for !no_headers case (Info output),      because it's something like the ``* Menu'' strings.  For plaintext output      it should be translated though.  */
name|sprintf
argument_list|(
name|out_line_no_str
argument_list|,
name|no_headers
condition|?
name|_
argument_list|(
literal|"(line %*d)"
argument_list|)
else|:
literal|"(line %*d)"
argument_list|,
name|output_line_number_len
argument_list|,
name|line_number
argument_list|)
expr_stmt|;
block|{
name|int
name|i
init|=
name|output_paragraph_offset
decl_stmt|;
while|while
condition|(
literal|0
operator|<
name|i
operator|&&
name|output_paragraph
index|[
name|i
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|i
operator|--
expr_stmt|;
name|last_column
operator|=
name|output_paragraph_offset
operator|-
name|i
expr_stmt|;
block|}
if|if
condition|(
name|last_column
operator|+
name|strlen
argument_list|(
name|out_line_no_str
argument_list|)
operator|>
name|fill_column
condition|)
block|{
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|last_column
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|last_column
operator|+
name|strlen
argument_list|(
name|out_line_no_str
argument_list|)
operator|<
name|fill_column
condition|)
block|{
name|insert
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|last_column
operator|++
expr_stmt|;
block|}
name|insert_string
argument_list|(
name|out_line_no_str
argument_list|)
expr_stmt|;
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|out_line_no_str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Nonzero means that we are in the middle of printing an index. */
end_comment

begin_decl_stmt
name|int
name|printing_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Takes one arg, a short name of an index to print.    Outputs a menu of the sorted elements of the index. */
end_comment

begin_function
name|void
name|cm_printindex
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|index_name
decl_stmt|;
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|index_name
argument_list|)
expr_stmt|;
comment|/* get_rest_of_line increments the line number by one,      so to make warnings/errors point to the correct line,      we decrement the line_number again.  */
if|if
condition|(
operator|!
name|handling_delayed_writes
condition|)
name|line_number
operator|--
expr_stmt|;
if|if
condition|(
name|xml
operator|&&
operator|!
name|docbook
condition|)
block|{
name|xml_insert_element
argument_list|(
name|PRINTINDEX
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
name|index_name
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|PRINTINDEX
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|handling_delayed_writes
condition|)
block|{
name|int
name|command_len
init|=
sizeof|sizeof
argument_list|(
literal|"@ "
argument_list|)
operator|+
name|strlen
argument_list|(
name|command
argument_list|)
operator|+
name|strlen
argument_list|(
name|index_name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|index_command
init|=
name|xmalloc
argument_list|(
name|command_len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
if|if
condition|(
name|docbook
condition|)
name|xml_begin_index
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|index_command
argument_list|,
literal|"@%s %s"
argument_list|,
name|command
argument_list|,
name|index_name
argument_list|)
expr_stmt|;
name|register_delayed_write
argument_list|(
name|index_command
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|index_command
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|item
decl_stmt|;
name|INDEX_ELT
modifier|*
name|index
decl_stmt|;
name|INDEX_ELT
modifier|*
name|last_index
init|=
literal|0
decl_stmt|;
name|INDEX_ELT
modifier|*
modifier|*
name|array
decl_stmt|;
name|unsigned
name|line_length
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|saved_inhibit_paragraph_indentation
init|=
name|inhibit_paragraph_indentation
decl_stmt|;
name|int
name|saved_filling_enabled
init|=
name|filling_enabled
decl_stmt|;
name|int
name|saved_line_number
init|=
name|line_number
decl_stmt|;
name|char
modifier|*
name|saved_input_filename
init|=
name|input_filename
decl_stmt|;
name|unsigned
name|output_line_number_len
decl_stmt|;
name|index
operator|=
name|index_list
argument_list|(
name|index_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
operator|(
name|INDEX_ELT
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Unknown index `%s' in @printindex"
argument_list|)
argument_list|,
name|index_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|index_name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Do this before sorting, so execute_string is in the good environment */
if|if
condition|(
name|xml
operator|&&
name|docbook
condition|)
name|xml_begin_index
argument_list|()
expr_stmt|;
comment|/* Do this before sorting, so execute_string in index_element_compare          will give the same results as when we actually print.  */
name|printing_index
operator|=
literal|1
expr_stmt|;
name|filling_enabled
operator|=
literal|0
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|xml_sort_index
operator|=
literal|1
expr_stmt|;
name|array
operator|=
name|sort_index
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|xml_sort_index
operator|=
literal|0
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|add_html_block_elt_args
argument_list|(
literal|"<ul class=\"index-%s\" compact>"
argument_list|,
name|index_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|no_headers
operator|&&
operator|!
name|docbook
condition|)
block|{
comment|/* Info.  Add magic cookie for info readers (to treat this              menu differently), and the usual start-of-menu.  */
name|add_char
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"\010[index"
argument_list|)
expr_stmt|;
name|add_char
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"\010]\n"
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"* Menu:\n\n"
argument_list|)
expr_stmt|;
block|}
name|me_inhibit_expansion
operator|++
expr_stmt|;
comment|/* This will probably be enough.  */
name|line_length
operator|=
literal|100
expr_stmt|;
name|line
operator|=
name|xmalloc
argument_list|(
name|line_length
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|max_output_line_number
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|25
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|no_headers
condition|)
name|sprintf
argument_list|(
name|max_output_line_number
argument_list|,
literal|"%d"
argument_list|,
name|output_line_number
argument_list|)
expr_stmt|;
else|else
block|{
name|INDEX_ELT
modifier|*
name|tmp_entry
init|=
name|index
decl_stmt|;
name|unsigned
name|tmp
init|=
literal|0
decl_stmt|;
for|for
control|(
name|tmp_entry
operator|=
name|index
init|;
name|tmp_entry
condition|;
name|tmp_entry
operator|=
name|tmp_entry
operator|->
name|next
control|)
name|tmp
operator|=
name|tmp_entry
operator|->
name|output_line
operator|>
name|tmp
condition|?
name|tmp_entry
operator|->
name|output_line
else|:
name|tmp
expr_stmt|;
name|sprintf
argument_list|(
name|max_output_line_number
argument_list|,
literal|"%d"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|output_line_number_len
operator|=
name|strlen
argument_list|(
name|max_output_line_number
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|max_output_line_number
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|item
operator|=
literal|0
init|;
operator|(
name|index
operator|=
name|array
index|[
name|item
index|]
operator|)
condition|;
name|item
operator|++
control|)
block|{
comment|/* A pathological document might have an index entry outside of any              node.  Don't crash; try using the section name instead.  */
name|char
modifier|*
name|index_node
init|=
name|index
operator|->
name|node
decl_stmt|;
name|line_number
operator|=
name|index
operator|->
name|defining_line
expr_stmt|;
name|input_filename
operator|=
name|index
operator|->
name|defining_file
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|index_node
operator|||
operator|!
operator|*
name|index_node
operator|)
operator|&&
name|html
condition|)
name|index_node
operator|=
name|toc_find_section_of_node
argument_list|(
name|index_node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index_node
operator|||
operator|!
operator|*
name|index_node
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Entry for index `%s' outside of any node"
argument_list|)
argument_list|,
name|index_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|html
operator|||
operator|!
name|no_headers
condition|)
name|index_node
operator|=
operator|(
name|char
operator|*
operator|)
name|_
argument_list|(
literal|"(outside of any node)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|html
condition|)
block|{
comment|/* For HTML, we need to expand and HTML-escape the                  original entry text, at the same time.  Consider                  @cindex J@"urgen.  We want J&uuml;urgen.  We can't                  expand and then escape since we'll end up with                  J&amp;uuml;rgen.  We can't escape and then expand                  because then `expansion' will see J@&quot;urgen, and                  @&quot;urgen is not a command.  */
name|char
modifier|*
name|html_entry
init|=
name|maybe_escaped_expansion
argument_list|(
name|index
operator|->
name|entry_text
argument_list|,
name|index
operator|->
name|code
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|add_html_block_elt_args
argument_list|(
literal|"\n<li><a href=\"%s#index-"
argument_list|,
operator|(
name|splitting
operator|&&
name|index
operator|->
name|output_file
operator|)
condition|?
name|index
operator|->
name|output_file
else|:
literal|""
argument_list|)
expr_stmt|;
name|add_escaped_anchor_name
argument_list|(
name|index
operator|->
name|entry_text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_word_args
argument_list|(
literal|"-%d\">%s</a>: "
argument_list|,
name|index
operator|->
name|entry_number
argument_list|,
name|html_entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|html_entry
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"<a href=\""
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|->
name|node
operator|&&
operator|*
name|index
operator|->
name|node
condition|)
block|{
comment|/* Ensure any non-macros in the node name are expanded.  */
name|char
modifier|*
name|expanded_index
decl_stmt|;
name|in_fixed_width_font
operator|++
expr_stmt|;
name|expanded_index
operator|=
name|expansion
argument_list|(
name|index_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|--
expr_stmt|;
name|add_anchor_name
argument_list|(
name|expanded_index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expanded_index
operator|=
name|escape_string
argument_list|(
name|expanded_index
argument_list|)
expr_stmt|;
name|add_word_args
argument_list|(
literal|"\">%s</a>"
argument_list|,
name|expanded_index
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expanded_index
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|index_node
argument_list|,
name|_
argument_list|(
literal|"(outside of any node)"
argument_list|)
argument_list|)
condition|)
block|{
name|add_anchor_name
argument_list|(
name|index_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_word_args
argument_list|(
literal|"\">%s</a>"
argument_list|,
name|index_node
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* If we use the section instead of the (missing) node, then                    index_node already includes all we need except the #.  */
name|add_word_args
argument_list|(
literal|"#%s</a>"
argument_list|,
name|index_node
argument_list|)
expr_stmt|;
name|add_html_block_elt
argument_list|(
literal|"</li>"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xml
operator|&&
name|docbook
condition|)
block|{
comment|/* In the DocBook case, the expanded index entry is not                  good for us, since it was expanded for non-DocBook mode                  inside sort_index.  So we send the original entry text                  to be used with execute_string.  */
name|xml_insert_indexentry
argument_list|(
name|index
operator|->
name|entry_text
argument_list|,
name|index_node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|new_length
init|=
name|strlen
argument_list|(
name|index
operator|->
name|entry
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_length
operator|<
literal|50
condition|)
comment|/* minimum length used below */
name|new_length
operator|=
literal|50
expr_stmt|;
name|new_length
operator|+=
name|strlen
argument_list|(
name|index_node
argument_list|)
operator|+
literal|7
expr_stmt|;
comment|/* * : .\n\0 */
if|if
condition|(
name|new_length
operator|>
name|line_length
condition|)
block|{
name|line_length
operator|=
name|new_length
expr_stmt|;
name|line
operator|=
name|xrealloc
argument_list|(
name|line
argument_list|,
name|line_length
argument_list|)
expr_stmt|;
block|}
comment|/* Print the entry, nicely formatted.  We've already                  expanded any commands in index->entry, including any                  implicit @code.  Thus, can't call execute_string, since                  @@ has turned into @. */
if|if
condition|(
operator|!
name|no_headers
condition|)
block|{
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"* %-37s  "
argument_list|,
name|index
operator|->
name|entry
argument_list|)
expr_stmt|;
name|line
index|[
literal|2
operator|+
name|strlen
argument_list|(
name|index
operator|->
name|entry
argument_list|)
index|]
operator|=
literal|':'
expr_stmt|;
name|insert_string
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* Make sure any non-macros in the node name are expanded.  */
name|in_fixed_width_font
operator|++
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s. "
argument_list|,
name|index_node
argument_list|)
expr_stmt|;
name|insert_index_output_line_no
argument_list|(
name|index
operator|->
name|output_line
argument_list|,
name|output_line_number_len
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* With --no-headers, the @node lines are gone, so                      there's little sense in referring to them in the                      index.  Instead, output the number or name of the                      section that corresponds to that node.  */
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%-*s "
argument_list|,
name|number_sections
condition|?
literal|46
else|:
literal|1
argument_list|,
name|index
operator|->
name|entry
argument_list|)
expr_stmt|;
name|line
index|[
name|strlen
argument_list|(
name|index
operator|->
name|entry
argument_list|)
index|]
operator|=
literal|':'
expr_stmt|;
name|insert_string
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|index
operator|->
name|section
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* We got your number.  */
name|insert_string
argument_list|(
operator|(
name|char
operator|*
operator|)
name|_
argument_list|(
literal|"See "
argument_list|)
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
name|index
operator|->
name|section
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Sigh, index in an @unnumbered. :-\  */
name|insert_string
argument_list|(
literal|"\n          "
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
operator|(
name|char
operator|*
operator|)
name|_
argument_list|(
literal|"See "
argument_list|)
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
literal|"``"
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
name|expansion
argument_list|(
name|index
operator|->
name|section_name
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
literal|"''"
argument_list|)
expr_stmt|;
block|}
name|insert_string
argument_list|(
literal|". "
argument_list|)
expr_stmt|;
name|insert_index_output_line_no
argument_list|(
name|index
operator|->
name|output_line
argument_list|,
name|output_line_number_len
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Prevent `output_paragraph' from growing to the size of the              whole index.  */
name|flush_output
argument_list|()
expr_stmt|;
name|last_index
operator|=
name|index
expr_stmt|;
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|me_inhibit_expansion
operator|--
expr_stmt|;
name|printing_index
operator|=
literal|0
expr_stmt|;
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|saved_filling_enabled
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
name|saved_inhibit_paragraph_indentation
expr_stmt|;
name|input_filename
operator|=
name|saved_input_filename
expr_stmt|;
name|line_number
operator|=
name|saved_line_number
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|add_html_block_elt
argument_list|(
literal|"</ul>"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xml
operator|&&
name|docbook
condition|)
name|xml_end_index
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|index_name
argument_list|)
expr_stmt|;
comment|/* Re-increment the line number, because get_rest_of_line      left us looking at the next line after the command.  */
name|line_number
operator|++
expr_stmt|;
block|}
end_function

end_unit

