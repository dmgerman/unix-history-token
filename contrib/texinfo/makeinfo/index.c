begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* index.c -- indexing for Texinfo.    $Id: index.c,v 1.25 2002/03/19 14:43:04 karl Exp $     Copyright (C) 1998, 99, 2002 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"index.h"
end_include

begin_include
include|#
directive|include
file|"lang.h"
end_include

begin_include
include|#
directive|include
file|"macro.h"
end_include

begin_include
include|#
directive|include
file|"toc.h"
end_include

begin_include
include|#
directive|include
file|"xml.h"
end_include

begin_comment
comment|/* An index element... */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|index_elt
block|{
name|struct
name|index_elt
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|entry
decl_stmt|;
comment|/* The index entry itself, after expansion. */
name|char
modifier|*
name|entry_text
decl_stmt|;
comment|/* The original, non-expanded entry text. */
name|char
modifier|*
name|node
decl_stmt|;
comment|/* The node from whence it came. */
name|int
name|code
decl_stmt|;
comment|/* Nonzero means add `@code{...}' when                                    printing this element. */
name|int
name|defining_line
decl_stmt|;
comment|/* Line number where this entry was written. */
name|char
modifier|*
name|defining_file
decl_stmt|;
comment|/* Source file for defining_line. */
block|}
name|INDEX_ELT
typedef|;
end_typedef

begin_comment
comment|/* A list of short-names for each index.    There are two indices into the the_indices array.    * read_index is the index that points to the list of index      entries that we will find if we ask for the list of entries for      this name.    * write_index is the index that points to the list of index entries      that we will add new entries to.     Initially, read_index and write_index are the same, but the    @syncodeindex and @synindex commands can change the list we add    entries to.     For example, after the commands      @cindex foo      @defindex ii      @synindex cp ii      @cindex bar     the cp index will contain the entry `foo', and the new ii    index will contain the entry `bar'.  This is consistent with the    way texinfo.tex handles the same situation.     In addition, for each index, it is remembered whether that index is    a code index or not.  Code indices have @code{} inserted around the    first word when they are printed with printindex. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|read_index
decl_stmt|;
comment|/* index entries for `name' */
name|int
name|write_index
decl_stmt|;
comment|/* store index entries here, @synindex can change it */
name|int
name|code
decl_stmt|;
block|}
name|INDEX_ALIST
typedef|;
end_typedef

begin_decl_stmt
name|INDEX_ALIST
modifier|*
modifier|*
name|name_index_alist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An array of pointers.  Each one is for a different index.  The    "synindex" command changes which array slot is pointed to by a    given "index". */
end_comment

begin_decl_stmt
name|INDEX_ELT
modifier|*
modifier|*
name|the_indices
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of defined indices. */
end_comment

begin_decl_stmt
name|int
name|defined_indices
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stuff for defining commands on the fly. */
end_comment

begin_decl_stmt
name|COMMAND
modifier|*
modifier|*
name|user_command_array
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|user_command_array_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to compare index entries for sorting.  May be set to strcoll.  */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|index_compare_fn
function_decl|)
parameter_list|()
init|=
name|strcasecmp
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Find which element in the known list of indices has this name.    Returns -1 if NAME isn't found. */
end_comment

begin_function
specifier|static
name|int
name|find_index_offset
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|defined_indices
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name_index_alist
index|[
name|i
index|]
operator|&&
name|STREQ
argument_list|(
name|name
argument_list|,
name|name_index_alist
index|[
name|i
index|]
operator|->
name|name
argument_list|)
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the entry of (name . index) for this name.    Return NULL if the index doesn't exist. */
end_comment

begin_function
name|INDEX_ALIST
modifier|*
name|find_index
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|offset
init|=
name|find_index_offset
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|>
operator|-
literal|1
condition|)
return|return
name|name_index_alist
index|[
name|offset
index|]
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* User-defined commands, which happens only from user-defined indexes.    Used to initialize the builtin indices, too.  */
end_comment

begin_function
name|void
name|define_user_command
parameter_list|(
name|name
parameter_list|,
name|proc
parameter_list|,
name|needs_braces_p
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|COMMAND_FUNCTION
modifier|*
name|proc
decl_stmt|;
name|int
name|needs_braces_p
decl_stmt|;
block|{
name|int
name|slot
init|=
name|user_command_array_len
decl_stmt|;
name|user_command_array_len
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|user_command_array
condition|)
name|user_command_array
operator|=
name|xmalloc
argument_list|(
literal|1
operator|*
sizeof|sizeof
argument_list|(
name|COMMAND
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|user_command_array
operator|=
name|xrealloc
argument_list|(
name|user_command_array
argument_list|,
operator|(
literal|1
operator|+
name|user_command_array_len
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|COMMAND
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|user_command_array
index|[
name|slot
index|]
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|COMMAND
argument_list|)
argument_list|)
expr_stmt|;
name|user_command_array
index|[
name|slot
index|]
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|user_command_array
index|[
name|slot
index|]
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|user_command_array
index|[
name|slot
index|]
operator|->
name|argument_in_braces
operator|=
name|needs_braces_p
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Please release me, let me go... */
end_comment

begin_function
specifier|static
name|void
name|free_index
parameter_list|(
name|index
parameter_list|)
name|INDEX_ELT
modifier|*
name|index
decl_stmt|;
block|{
name|INDEX_ELT
modifier|*
name|temp
decl_stmt|;
while|while
condition|(
operator|(
name|temp
operator|=
name|index
operator|)
condition|)
block|{
name|free
argument_list|(
name|temp
operator|->
name|entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|entry_text
argument_list|)
expr_stmt|;
comment|/* Do not free the node, because we already freed the tag table,          which freed all the node names.  */
comment|/* free (temp->node); */
name|index
operator|=
name|index
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Flush an index by name.  This will delete the list of entries that    would be written by a @printindex command for this index. */
end_comment

begin_function
specifier|static
name|void
name|undefindex
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|which
init|=
name|find_index_offset
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|/* The index might have already been freed if this was the target of      an @synindex.  */
if|if
condition|(
name|which
operator|<
literal|0
operator|||
operator|!
name|name_index_alist
index|[
name|which
index|]
condition|)
return|return;
name|i
operator|=
name|name_index_alist
index|[
name|which
index|]
operator|->
name|read_index
expr_stmt|;
name|free_index
argument_list|(
name|the_indices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|the_indices
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|name_index_alist
index|[
name|which
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name_index_alist
index|[
name|which
index|]
argument_list|)
expr_stmt|;
name|name_index_alist
index|[
name|which
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add the arguments to the current index command to the index NAME.    html fixxme generate specific html anchor */
end_comment

begin_function
specifier|static
name|void
name|index_add_arg
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|which
decl_stmt|;
name|char
modifier|*
name|index_entry
decl_stmt|;
name|INDEX_ALIST
modifier|*
name|tem
decl_stmt|;
name|tem
operator|=
name|find_index
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|which
operator|=
name|tem
condition|?
name|tem
operator|->
name|write_index
else|:
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|macro_expansion_output_stream
operator|&&
operator|!
name|executing_string
condition|)
name|append_to_expansion_output
argument_list|(
name|input_text_offset
operator|+
literal|1
argument_list|)
expr_stmt|;
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|index_entry
argument_list|)
expr_stmt|;
name|ignore_blank_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|macro_expansion_output_stream
operator|&&
operator|!
name|executing_string
condition|)
block|{
name|char
modifier|*
name|index_line
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|index_entry
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|index_line
argument_list|,
literal|"%s\n"
argument_list|,
name|index_entry
argument_list|)
expr_stmt|;
name|me_execute_string_keep_state
argument_list|(
name|index_line
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|index_line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|which
operator|<
literal|0
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Unknown index `%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|index_entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|INDEX_ELT
modifier|*
name|new
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|INDEX_ELT
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|next
operator|=
name|the_indices
index|[
name|which
index|]
expr_stmt|;
name|new
operator|->
name|entry_text
operator|=
name|index_entry
expr_stmt|;
name|new
operator|->
name|entry
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|node
operator|=
name|current_node
condition|?
name|current_node
else|:
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|new
operator|->
name|code
operator|=
name|tem
operator|->
name|code
expr_stmt|;
name|new
operator|->
name|defining_line
operator|=
name|line_number
operator|-
literal|1
expr_stmt|;
comment|/* We need to make a copy since input_filename may point to          something that goes away, for example, inside a macro.          (see the findexerr test).  */
name|new
operator|->
name|defining_file
operator|=
name|xstrdup
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|the_indices
index|[
name|which
index|]
operator|=
name|new
expr_stmt|;
if|#
directive|if
literal|0
comment|/* The index breaks if there are colons in the entry.          -- This is true, but it's too painful to force changing index          entries to use `colon', and too confusing for users.  The real          fix is to change Info support to support arbitrary characters          in node names, and we're not ready to do that.  --karl,          19mar02.  */
block|if (strchr (new->entry_text, ':'))         warning (_("Info cannot handle `:' in index entry `%s'"),                  new->entry_text);
endif|#
directive|endif
block|}
if|if
condition|(
name|xml
condition|)
name|xml_insert_indexterm
argument_list|(
name|index_entry
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function which user defined index commands call. */
end_comment

begin_function
specifier|static
name|void
name|gen_index
parameter_list|()
block|{
name|char
modifier|*
name|name
init|=
name|xstrdup
argument_list|(
name|command
argument_list|)
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|>=
name|strlen
argument_list|(
literal|"index"
argument_list|)
condition|)
name|name
index|[
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
name|strlen
argument_list|(
literal|"index"
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|index_add_arg
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Define an index known as NAME.  We assign the slot number.    If CODE is nonzero, make this a code index. */
end_comment

begin_function
specifier|static
name|void
name|defindex
parameter_list|(
name|name
parameter_list|,
name|code
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|slot
decl_stmt|;
comment|/* If it already exists, flush it. */
name|undefindex
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Try to find an empty slot. */
name|slot
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|defined_indices
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|name_index_alist
index|[
name|i
index|]
condition|)
block|{
name|slot
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|slot
operator|<
literal|0
condition|)
block|{
comment|/* No such luck.  Make space for another index. */
name|slot
operator|=
name|defined_indices
expr_stmt|;
name|defined_indices
operator|++
expr_stmt|;
name|name_index_alist
operator|=
operator|(
name|INDEX_ALIST
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|name_index_alist
argument_list|,
operator|(
literal|1
operator|+
name|defined_indices
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ALIST
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|the_indices
operator|=
operator|(
name|INDEX_ELT
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|the_indices
argument_list|,
operator|(
literal|1
operator|+
name|defined_indices
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ELT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We have a slot.  Start assigning. */
name|name_index_alist
index|[
name|slot
index|]
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|INDEX_ALIST
argument_list|)
argument_list|)
expr_stmt|;
name|name_index_alist
index|[
name|slot
index|]
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name_index_alist
index|[
name|slot
index|]
operator|->
name|read_index
operator|=
name|slot
expr_stmt|;
name|name_index_alist
index|[
name|slot
index|]
operator|->
name|write_index
operator|=
name|slot
expr_stmt|;
name|name_index_alist
index|[
name|slot
index|]
operator|->
name|code
operator|=
name|code
expr_stmt|;
name|the_indices
index|[
name|slot
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define an index NAME, implicitly @code if CODE is nonzero.  */
end_comment

begin_function
specifier|static
name|void
name|top_defindex
parameter_list|(
name|name
parameter_list|,
name|code
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
literal|"index"
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%sindex"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|define_user_command
argument_list|(
name|temp
argument_list|,
name|gen_index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|defindex
argument_list|(
name|name
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set up predefined indices.  */
end_comment

begin_function
name|void
name|init_indices
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* Create the default data structures. */
comment|/* Initialize data space. */
if|if
condition|(
operator|!
name|the_indices
condition|)
block|{
name|the_indices
operator|=
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
name|defined_indices
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ELT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|the_indices
index|[
name|defined_indices
index|]
operator|=
name|NULL
expr_stmt|;
name|name_index_alist
operator|=
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
name|defined_indices
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ALIST
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|name_index_alist
index|[
name|defined_indices
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* If there were existing indices, get rid of them now. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|defined_indices
condition|;
name|i
operator|++
control|)
block|{
name|undefindex
argument_list|(
name|name_index_alist
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_index_alist
index|[
name|i
index|]
condition|)
block|{
comment|/* Suppose we're called with two input files, and the first              does a @synindex pg cp.  Then, when we get here to start              the second file, the "pg" element won't get freed by              undefindex (because it's pointing to "cp").  So free it              here; otherwise, when we try to define the pg index again              just below, it will still point to cp.  */
name|free
argument_list|(
name|name_index_alist
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name_index_alist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|name_index_alist
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Add the default indices. */
name|top_defindex
argument_list|(
literal|"cp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* cp is the only non-code index.  */
name|top_defindex
argument_list|(
literal|"fn"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|top_defindex
argument_list|(
literal|"ky"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|top_defindex
argument_list|(
literal|"pg"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|top_defindex
argument_list|(
literal|"tp"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|top_defindex
argument_list|(
literal|"vr"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given an index name, return the offset in the_indices of this index,    or -1 if there is no such index. */
end_comment

begin_function
name|int
name|translate_index
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|INDEX_ALIST
modifier|*
name|which
init|=
name|find_index
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|which
condition|)
return|return
name|which
operator|->
name|read_index
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return the index list which belongs to NAME. */
end_comment

begin_function
name|INDEX_ELT
modifier|*
name|index_list
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|which
init|=
name|translate_index
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|which
operator|<
literal|0
condition|)
return|return
operator|(
name|INDEX_ELT
operator|*
operator|)
operator|-
literal|1
return|;
else|else
return|return
name|the_indices
index|[
name|which
index|]
return|;
block|}
end_function

begin_comment
comment|/* Define a new index command.  Arg is name of index. */
end_comment

begin_function
specifier|static
name|void
name|gen_defindex
parameter_list|(
name|code
parameter_list|)
name|int
name|code
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_index
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Index `%s' already exists"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|temp
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|"index"
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%sindex"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|define_user_command
argument_list|(
name|temp
argument_list|,
name|gen_index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|defindex
argument_list|(
name|name
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_defindex
parameter_list|()
block|{
name|gen_defindex
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_defcodeindex
parameter_list|()
block|{
name|gen_defindex
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expects 2 args, on the same line.  Both are index abbreviations.    Make the first one be a synonym for the second one, i.e. make the    first one have the same index as the second one. */
end_comment

begin_function
name|void
name|cm_synindex
parameter_list|()
block|{
name|int
name|source
decl_stmt|,
name|target
decl_stmt|;
name|char
modifier|*
name|abbrev1
decl_stmt|,
modifier|*
name|abbrev2
decl_stmt|;
name|skip_whitespace
argument_list|()
expr_stmt|;
name|get_until_in_line
argument_list|(
literal|0
argument_list|,
literal|" "
argument_list|,
operator|&
name|abbrev1
argument_list|)
expr_stmt|;
name|target
operator|=
name|find_index_offset
argument_list|(
name|abbrev1
argument_list|)
expr_stmt|;
name|skip_whitespace
argument_list|()
expr_stmt|;
name|get_until_in_line
argument_list|(
literal|0
argument_list|,
literal|" "
argument_list|,
operator|&
name|abbrev2
argument_list|)
expr_stmt|;
name|source
operator|=
name|find_index_offset
argument_list|(
name|abbrev2
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
operator|<
literal|0
operator|||
name|target
operator|<
literal|0
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Unknown index `%s' and/or `%s' in @synindex"
argument_list|)
argument_list|,
name|abbrev1
argument_list|,
name|abbrev2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|name_index_alist
index|[
name|target
index|]
operator|->
name|write_index
operator|=
name|name_index_alist
index|[
name|source
index|]
operator|->
name|write_index
expr_stmt|;
block|}
name|free
argument_list|(
name|abbrev1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|abbrev2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_pindex
parameter_list|()
comment|/* Pinhead index. */
block|{
name|index_add_arg
argument_list|(
literal|"pg"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_vindex
parameter_list|()
comment|/* Variable index. */
block|{
name|index_add_arg
argument_list|(
literal|"vr"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_kindex
parameter_list|()
comment|/* Key index. */
block|{
name|index_add_arg
argument_list|(
literal|"ky"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_cindex
parameter_list|()
comment|/* Concept index. */
block|{
name|index_add_arg
argument_list|(
literal|"cp"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_findex
parameter_list|()
comment|/* Function index. */
block|{
name|index_add_arg
argument_list|(
literal|"fn"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_tindex
parameter_list|()
comment|/* Data Type index. */
block|{
name|index_add_arg
argument_list|(
literal|"tp"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|index_element_compare
parameter_list|(
name|element1
parameter_list|,
name|element2
parameter_list|)
name|INDEX_ELT
modifier|*
modifier|*
name|element1
decl_stmt|,
decl|*
modifier|*
name|element2
decl_stmt|;
end_function

begin_block
block|{
return|return
name|index_compare_fn
argument_list|(
operator|(
operator|*
name|element1
operator|)
operator|->
name|entry
argument_list|,
operator|(
operator|*
name|element2
operator|)
operator|->
name|entry
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Force all index entries to be unique. */
end_comment

begin_function
name|void
name|make_index_entries_unique
parameter_list|(
name|array
parameter_list|,
name|count
parameter_list|)
name|INDEX_ELT
modifier|*
modifier|*
name|array
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|INDEX_ELT
modifier|*
modifier|*
name|copy
decl_stmt|;
name|int
name|counter
init|=
literal|1
decl_stmt|;
name|copy
operator|=
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
name|count
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ELT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
operator|(
name|count
operator|-
literal|1
operator|)
operator|||
name|array
index|[
name|i
index|]
operator|->
name|node
operator|!=
name|array
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|node
operator|||
operator|!
name|STREQ
argument_list|(
name|array
index|[
name|i
index|]
operator|->
name|entry
argument_list|,
name|array
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|entry
argument_list|)
condition|)
name|copy
index|[
name|j
operator|++
index|]
operator|=
name|array
index|[
name|i
index|]
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|array
index|[
name|i
index|]
operator|->
name|entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|array
index|[
name|i
index|]
operator|->
name|entry_text
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|copy
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Now COPY contains only unique entries.  Duplicated entries in the      original array have been freed.  Replace the current array with      the copy, fixing the NEXT pointers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|copy
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|copy
index|[
name|i
index|]
operator|->
name|next
operator|=
name|copy
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
comment|/* Fix entry names which are the same.  They point to different nodes,          so we make the entry name unique. */
if|if
condition|(
name|copy
index|[
name|i
operator|+
literal|1
index|]
operator|&&
name|STREQ
argument_list|(
name|copy
index|[
name|i
index|]
operator|->
name|entry
argument_list|,
name|copy
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|entry
argument_list|)
operator|&&
operator|!
name|html
condition|)
block|{
name|char
modifier|*
name|new_entry_name
decl_stmt|;
name|new_entry_name
operator|=
name|xmalloc
argument_list|(
literal|10
operator|+
name|strlen
argument_list|(
name|copy
index|[
name|i
index|]
operator|->
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new_entry_name
argument_list|,
literal|"%s<%d>"
argument_list|,
name|copy
index|[
name|i
index|]
operator|->
name|entry
argument_list|,
name|counter
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|copy
index|[
name|i
index|]
operator|->
name|entry
argument_list|)
expr_stmt|;
name|copy
index|[
name|i
index|]
operator|->
name|entry
operator|=
name|new_entry_name
expr_stmt|;
name|counter
operator|++
expr_stmt|;
block|}
else|else
name|counter
operator|=
literal|1
expr_stmt|;
name|array
index|[
name|i
index|]
operator|=
name|copy
index|[
name|i
index|]
expr_stmt|;
block|}
name|array
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Free the storage used only by COPY. */
name|free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sort the index passed in INDEX, returning an array of    pointers to elements.  The array is terminated with a NULL    pointer.  We call qsort because it's supposed to be fast.    I think this looks bad. */
end_comment

begin_function
name|INDEX_ELT
modifier|*
modifier|*
name|sort_index
parameter_list|(
name|index
parameter_list|)
name|INDEX_ELT
modifier|*
name|index
decl_stmt|;
block|{
name|INDEX_ELT
modifier|*
modifier|*
name|array
decl_stmt|;
name|INDEX_ELT
modifier|*
name|temp
init|=
name|index
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|save_line_number
init|=
name|line_number
decl_stmt|;
name|char
modifier|*
name|save_input_filename
init|=
name|input_filename
decl_stmt|;
name|int
name|save_html
init|=
name|html
decl_stmt|;
comment|/* Pretend we are in non-HTML mode, for the purpose of getting the      expanded index entry that lacks any markup and other HTML escape      characters which could produce a wrong sort order.  */
comment|/* fixme: html: this still causes some markup, such as non-ASCII      characters @AE{} etc., to sort incorrectly.  */
name|html
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|temp
operator|=
name|temp
operator|->
name|next
expr_stmt|;
block|}
comment|/* We have the length.  Make an array. */
name|array
operator|=
name|xmalloc
argument_list|(
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ELT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|index
expr_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
name|array
index|[
name|count
operator|++
index|]
operator|=
name|temp
expr_stmt|;
comment|/* Set line number and input filename to the source line for this          index entry, as this expansion finds any errors.  */
name|line_number
operator|=
name|array
index|[
name|count
operator|-
literal|1
index|]
operator|->
name|defining_line
expr_stmt|;
name|input_filename
operator|=
name|array
index|[
name|count
operator|-
literal|1
index|]
operator|->
name|defining_file
expr_stmt|;
comment|/* If this particular entry should be printed as a "code" index,          then expand it as @code{entry}, i.e. as in fixed-width font.  */
name|array
index|[
name|count
operator|-
literal|1
index|]
operator|->
name|entry
operator|=
name|expansion
argument_list|(
name|temp
operator|->
name|entry_text
argument_list|,
name|array
index|[
name|count
operator|-
literal|1
index|]
operator|->
name|code
argument_list|)
expr_stmt|;
name|temp
operator|=
name|temp
operator|->
name|next
expr_stmt|;
block|}
name|array
index|[
name|count
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* terminate the array. */
name|line_number
operator|=
name|save_line_number
expr_stmt|;
name|input_filename
operator|=
name|save_input_filename
expr_stmt|;
name|html
operator|=
name|save_html
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_STRCOLL
comment|/* This is not perfect.  We should set (then restore) the locale to the      documentlanguage, so strcoll operates according to the document's      locale, not the user's.  For now, I'm just going to assume that      those few new documents which use @documentlanguage will be      processed in the appropriate locale.  In any case, don't use      strcoll in the C (aka POSIX) locale, that is the ASCII ordering.  */
if|if
condition|(
name|language_code
operator|!=
name|en
condition|)
block|{
name|char
modifier|*
name|lang_env
init|=
name|getenv
argument_list|(
literal|"LANG"
argument_list|)
decl_stmt|;
if|if
condition|(
name|lang_env
operator|&&
operator|!
name|STREQ
argument_list|(
name|lang_env
argument_list|,
literal|"C"
argument_list|)
operator|&&
operator|!
name|STREQ
argument_list|(
name|lang_env
argument_list|,
literal|"POSIX"
argument_list|)
condition|)
name|index_compare_fn
operator|=
name|strcoll
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_STRCOLL */
comment|/* Sort the array. */
name|qsort
argument_list|(
name|array
argument_list|,
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|INDEX_ELT
operator|*
argument_list|)
argument_list|,
name|index_element_compare
argument_list|)
expr_stmt|;
name|make_index_entries_unique
argument_list|(
name|array
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|array
return|;
block|}
end_function

begin_comment
comment|/* Nonzero means that we are in the middle of printing an index. */
end_comment

begin_decl_stmt
name|int
name|printing_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Takes one arg, a short name of an index to print.    Outputs a menu of the sorted elements of the index. */
end_comment

begin_function
name|void
name|cm_printindex
parameter_list|()
block|{
if|if
condition|(
name|xml
operator|&&
operator|!
name|docbook
condition|)
block|{
name|char
modifier|*
name|index_name
decl_stmt|;
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|index_name
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|PRINTINDEX
argument_list|,
name|START
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
name|index_name
argument_list|)
expr_stmt|;
name|xml_insert_element
argument_list|(
name|PRINTINDEX
argument_list|,
name|END
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|item
decl_stmt|;
name|INDEX_ELT
modifier|*
name|index
decl_stmt|;
name|INDEX_ELT
modifier|*
name|last_index
init|=
literal|0
decl_stmt|;
name|INDEX_ELT
modifier|*
modifier|*
name|array
decl_stmt|;
name|char
modifier|*
name|index_name
decl_stmt|;
name|unsigned
name|line_length
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|saved_inhibit_paragraph_indentation
init|=
name|inhibit_paragraph_indentation
decl_stmt|;
name|int
name|saved_filling_enabled
init|=
name|filling_enabled
decl_stmt|;
name|int
name|saved_line_number
init|=
name|line_number
decl_stmt|;
name|char
modifier|*
name|saved_input_filename
init|=
name|input_filename
decl_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|index_name
argument_list|)
expr_stmt|;
name|index
operator|=
name|index_list
argument_list|(
name|index_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
operator|(
name|INDEX_ELT
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Unknown index `%s' in @printindex"
argument_list|)
argument_list|,
name|index_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|index_name
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Do this before sorting, so execute_string is in the good environment */
if|if
condition|(
name|xml
operator|&&
name|docbook
condition|)
name|xml_begin_index
argument_list|()
expr_stmt|;
comment|/* Do this before sorting, so execute_string in index_element_compare 	 will give the same results as when we actually print.  */
name|printing_index
operator|=
literal|1
expr_stmt|;
name|filling_enabled
operator|=
literal|0
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|xml_sort_index
operator|=
literal|1
expr_stmt|;
name|array
operator|=
name|sort_index
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|xml_sort_index
operator|=
literal|0
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"<ul compact>"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|no_headers
operator|&&
operator|!
name|docbook
condition|)
name|add_word
argument_list|(
literal|"* Menu:\n\n"
argument_list|)
expr_stmt|;
name|me_inhibit_expansion
operator|++
expr_stmt|;
comment|/* This will probably be enough.  */
name|line_length
operator|=
literal|100
expr_stmt|;
name|line
operator|=
name|xmalloc
argument_list|(
name|line_length
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
literal|0
init|;
operator|(
name|index
operator|=
name|array
index|[
name|item
index|]
operator|)
condition|;
name|item
operator|++
control|)
block|{
comment|/* A pathological document might have an index entry outside of any 	     node.  Don't crash; try using the section name instead.  */
name|char
modifier|*
name|index_node
init|=
name|index
operator|->
name|node
decl_stmt|;
name|line_number
operator|=
name|index
operator|->
name|defining_line
expr_stmt|;
name|input_filename
operator|=
name|index
operator|->
name|defining_file
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|index_node
operator|||
operator|!
operator|*
name|index_node
operator|)
operator|&&
name|html
condition|)
name|index_node
operator|=
name|toc_find_section_of_node
argument_list|(
name|index_node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index_node
operator|||
operator|!
operator|*
name|index_node
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Entry for index `%s' outside of any node"
argument_list|)
argument_list|,
name|index_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|html
operator|||
operator|!
name|no_headers
condition|)
name|index_node
operator|=
name|_
argument_list|(
literal|"(outside of any node)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|html
condition|)
comment|/* fixme: html: we should use specific index anchors pointing            to the actual location of the indexed position (but then we            have to find something to wrap the anchor around). */
block|{
if|if
condition|(
name|last_index
operator|&&
name|STREQ
argument_list|(
name|last_index
operator|->
name|entry_text
argument_list|,
name|index
operator|->
name|entry_text
argument_list|)
condition|)
name|add_word
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
comment|/* Don't repeat the previous entry. */
else|else
block|{
comment|/* In the HTML case, the expanded index entry is not 		     good for us, since it was expanded for non-HTML mode 		     inside sort_index.  So we need to HTML-escape and 		     expand the original entry text here.  */
name|char
modifier|*
name|escaped_entry
init|=
name|xstrdup
argument_list|(
name|index
operator|->
name|entry_text
argument_list|)
decl_stmt|;
name|char
modifier|*
name|expanded_entry
decl_stmt|;
comment|/* expansion() doesn't HTML-escape the argument, so need 		     to do it separately.  */
name|escaped_entry
operator|=
name|escape_string
argument_list|(
name|escaped_entry
argument_list|)
expr_stmt|;
name|expanded_entry
operator|=
name|expansion
argument_list|(
name|escaped_entry
argument_list|,
name|index
operator|->
name|code
argument_list|)
expr_stmt|;
name|add_word_args
argument_list|(
literal|"\n<li>%s: "
argument_list|,
name|expanded_entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|escaped_entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expanded_entry
argument_list|)
expr_stmt|;
block|}
name|add_word
argument_list|(
literal|"<a href=\""
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|->
name|node
operator|&&
operator|*
name|index
operator|->
name|node
condition|)
block|{
comment|/* Make sure any non-macros in the node name are expanded.  */
name|in_fixed_width_font
operator|++
expr_stmt|;
name|index_node
operator|=
name|expansion
argument_list|(
name|index_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|--
expr_stmt|;
name|add_anchor_name
argument_list|(
name|index_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_word_args
argument_list|(
literal|"\">%s</a>"
argument_list|,
name|index_node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|index_node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|index_node
argument_list|,
name|_
argument_list|(
literal|"(outside of any node)"
argument_list|)
argument_list|)
condition|)
block|{
name|add_anchor_name
argument_list|(
name|index_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_word_args
argument_list|(
literal|"\">%s</a>"
argument_list|,
name|index_node
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* If we use the section instead of the (missing) node, then 		   index_node already includes all we need except the #.  */
name|add_word_args
argument_list|(
literal|"#%s</a>"
argument_list|,
name|index_node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xml
operator|&&
name|docbook
condition|)
block|{
name|xml_insert_indexentry
argument_list|(
name|index
operator|->
name|entry
argument_list|,
name|index_node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|new_length
init|=
name|strlen
argument_list|(
name|index
operator|->
name|entry
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_length
operator|<
literal|50
condition|)
comment|/* minimum length used below */
name|new_length
operator|=
literal|50
expr_stmt|;
name|new_length
operator|+=
name|strlen
argument_list|(
name|index_node
argument_list|)
operator|+
literal|7
expr_stmt|;
comment|/* * : .\n\0 */
if|if
condition|(
name|new_length
operator|>
name|line_length
condition|)
block|{
name|line_length
operator|=
name|new_length
expr_stmt|;
name|line
operator|=
name|xrealloc
argument_list|(
name|line
argument_list|,
name|line_length
argument_list|)
expr_stmt|;
block|}
comment|/* Print the entry, nicely formatted.  We've already 		 expanded any commands in index->entry, including any 		 implicit @code.  Thus, can't call execute_string, since 		 @@ has turned into @. */
if|if
condition|(
operator|!
name|no_headers
condition|)
block|{
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"* %-37s  "
argument_list|,
name|index
operator|->
name|entry
argument_list|)
expr_stmt|;
name|line
index|[
literal|2
operator|+
name|strlen
argument_list|(
name|index
operator|->
name|entry
argument_list|)
index|]
operator|=
literal|':'
expr_stmt|;
name|insert_string
argument_list|(
name|line
argument_list|)
expr_stmt|;
comment|/* Make sure any non-macros in the node name are expanded.  */
name|in_fixed_width_font
operator|++
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s.\n"
argument_list|,
name|index_node
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* With --no-headers, the @node lines are gone, so 		     there's little sense in referring to them in the 		     index.  Instead, output the number or name of the 		     section that corresponds to that node.  */
name|char
modifier|*
name|section_name
init|=
name|toc_find_section_of_node
argument_list|(
name|index_node
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%-*s "
argument_list|,
name|number_sections
condition|?
literal|50
else|:
literal|1
argument_list|,
name|index
operator|->
name|entry
argument_list|)
expr_stmt|;
name|line
index|[
name|strlen
argument_list|(
name|index
operator|->
name|entry
argument_list|)
index|]
operator|=
literal|':'
expr_stmt|;
name|insert_string
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|section_name
condition|)
block|{
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|unsigned
name|ref_len
init|=
name|strlen
argument_list|(
name|section_name
argument_list|)
operator|+
literal|30
decl_stmt|;
if|if
condition|(
name|ref_len
operator|>
name|line_length
condition|)
block|{
name|line_length
operator|=
name|ref_len
expr_stmt|;
name|line
operator|=
name|xrealloc
argument_list|(
name|line
argument_list|,
name|line_length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|number_sections
condition|)
block|{
while|while
condition|(
name|section_name
index|[
name|idx
index|]
operator|&&
operator|(
name|isdigit
argument_list|(
name|section_name
index|[
name|idx
index|]
argument_list|)
operator|||
operator|(
name|idx
operator|&&
name|section_name
index|[
name|idx
index|]
operator|==
literal|'.'
operator|)
operator|)
condition|)
name|idx
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|idx
condition|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|" See %.*s.\n"
argument_list|,
name|idx
argument_list|,
name|section_name
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"\n          See ``%s''.\n"
argument_list|,
name|section_name
argument_list|)
expr_stmt|;
name|insert_string
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|insert_string
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
comment|/* force a blank */
name|execute_string
argument_list|(
literal|"See node %s.\n"
argument_list|,
name|index_node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Prevent `output_paragraph' from growing to the size of the 	     whole index.  */
name|flush_output
argument_list|()
expr_stmt|;
name|last_index
operator|=
name|index
expr_stmt|;
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|index_name
argument_list|)
expr_stmt|;
name|me_inhibit_expansion
operator|--
expr_stmt|;
name|printing_index
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|saved_filling_enabled
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
name|saved_inhibit_paragraph_indentation
expr_stmt|;
name|input_filename
operator|=
name|saved_input_filename
expr_stmt|;
name|line_number
operator|=
name|saved_line_number
expr_stmt|;
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"</ul>"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|xml
operator|&&
name|docbook
condition|)
name|xml_end_index
argument_list|()
expr_stmt|;
block|}
block|}
end_function

end_unit

