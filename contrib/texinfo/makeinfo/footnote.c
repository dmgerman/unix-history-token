begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* footnote.c -- footnotes for Texinfo.    $Id: footnote.c,v 1.10 1999/09/20 12:20:52 karl Exp $     Copyright (C) 1998, 99 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"footnote.h"
end_include

begin_include
include|#
directive|include
file|"macro.h"
end_include

begin_include
include|#
directive|include
file|"makeinfo.h"
end_include

begin_comment
comment|/* Nonzero means that the footnote style for this document was set on    the command line, which overrides any other settings. */
end_comment

begin_decl_stmt
name|int
name|footnote_style_preset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current footnote number in this node.  Each time a new node is    started this is reset to 1. */
end_comment

begin_decl_stmt
name|int
name|current_footnote_number
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means we automatically number footnotes with no specified marker. */
end_comment

begin_decl_stmt
name|int
name|number_footnotes
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means we are currently outputting footnotes. */
end_comment

begin_decl_stmt
name|int
name|already_outputting_pending_notes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Footnotes can be handled in one of two ways:     separate_node:         Make them look like followed references, with the reference         destinations in a makeinfo manufactured node or,    end_node:         Make them appear at the bottom of the node that they originally         appeared in. */
end_comment

begin_define
define|#
directive|define
name|separate_node
value|0
end_define

begin_define
define|#
directive|define
name|end_node
value|1
end_define

begin_decl_stmt
name|int
name|footnote_style
init|=
name|end_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|first_footnote_this_node
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|footnote_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set the footnote style based on the style identifier in STRING. */
end_comment

begin_function
name|int
name|set_footnote_style
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|string
argument_list|,
literal|"separate"
argument_list|)
operator|==
literal|0
condition|)
name|footnote_style
operator|=
name|separate_node
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|string
argument_list|,
literal|"end"
argument_list|)
operator|==
literal|0
condition|)
name|footnote_style
operator|=
name|end_node
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|cm_footnotestyle
parameter_list|()
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|get_rest_of_line
argument_list|(
literal|1
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
comment|/* If set on command line, do not change the footnote style.  */
if|if
condition|(
operator|!
name|footnote_style_preset
operator|&&
name|set_footnote_style
argument_list|(
name|arg
argument_list|)
operator|!=
literal|0
condition|)
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Bad argument to %c%s"
argument_list|)
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|fn
block|{
name|struct
name|fn
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|marker
decl_stmt|;
name|char
modifier|*
name|note
decl_stmt|;
name|int
name|number
decl_stmt|;
block|}
name|FN
typedef|;
end_typedef

begin_decl_stmt
name|FN
modifier|*
name|pending_notes
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A method for remembering footnotes.  Note that this list gets output    at the end of the current node. */
end_comment

begin_function
name|void
name|remember_note
parameter_list|(
name|marker
parameter_list|,
name|note
parameter_list|)
name|char
modifier|*
name|marker
decl_stmt|,
decl|*
name|note
decl_stmt|;
end_function

begin_block
block|{
name|FN
modifier|*
name|temp
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FN
argument_list|)
argument_list|)
decl_stmt|;
name|temp
operator|->
name|marker
operator|=
name|xstrdup
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|temp
operator|->
name|note
operator|=
name|xstrdup
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|pending_notes
expr_stmt|;
name|temp
operator|->
name|number
operator|=
name|current_footnote_number
expr_stmt|;
name|pending_notes
operator|=
name|temp
expr_stmt|;
name|footnote_count
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* How to get rid of existing footnotes. */
end_comment

begin_function
specifier|static
name|void
name|free_pending_notes
parameter_list|()
block|{
name|FN
modifier|*
name|temp
decl_stmt|;
while|while
condition|(
operator|(
name|temp
operator|=
name|pending_notes
operator|)
condition|)
block|{
name|free
argument_list|(
name|temp
operator|->
name|marker
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|note
argument_list|)
expr_stmt|;
name|pending_notes
operator|=
name|pending_notes
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|first_footnote_this_node
operator|=
literal|1
expr_stmt|;
name|footnote_count
operator|=
literal|0
expr_stmt|;
name|current_footnote_number
operator|=
literal|1
expr_stmt|;
comment|/* for html */
block|}
end_function

begin_comment
comment|/* What to do when you see a @footnote construct. */
end_comment

begin_comment
comment|/* Handle a "footnote".     footnote *{this is a footnote}     where "*" is the (optional) marker character for this note. */
end_comment

begin_function
name|void
name|cm_footnote
parameter_list|()
block|{
name|char
modifier|*
name|marker
decl_stmt|;
name|char
modifier|*
name|note
decl_stmt|;
name|get_until
argument_list|(
literal|"{"
argument_list|,
operator|&
name|marker
argument_list|)
expr_stmt|;
name|canon_white
argument_list|(
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|macro_expansion_output_stream
operator|&&
operator|!
name|executing_string
condition|)
name|append_to_expansion_output
argument_list|(
name|input_text_offset
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* include the { */
comment|/* Read the argument in braces. */
if|if
condition|(
name|curchar
argument_list|()
operator|!=
literal|'{'
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"`%c%s' needs an argument `{...}', not just `%s'"
argument_list|)
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|marker
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|int
name|len
decl_stmt|;
name|int
name|braces
init|=
literal|1
decl_stmt|;
name|int
name|loc
init|=
operator|++
name|input_text_offset
decl_stmt|;
while|while
condition|(
name|braces
condition|)
block|{
if|if
condition|(
name|loc
operator|==
name|input_text_length
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"No closing brace for footnote `%s'"
argument_list|)
argument_list|,
name|marker
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|input_text
index|[
name|loc
index|]
operator|==
literal|'{'
condition|)
name|braces
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|input_text
index|[
name|loc
index|]
operator|==
literal|'}'
condition|)
name|braces
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|input_text
index|[
name|loc
index|]
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
name|loc
operator|++
expr_stmt|;
block|}
name|len
operator|=
operator|(
name|loc
operator|-
name|input_text_offset
operator|)
operator|-
literal|1
expr_stmt|;
name|note
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|note
argument_list|,
operator|&
name|input_text
index|[
name|input_text_offset
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|note
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|input_text_offset
operator|=
name|loc
expr_stmt|;
block|}
comment|/* Must write the macro-expanded argument to the macro expansion      output stream.  This is like the case in index_add_arg.  */
if|if
condition|(
name|macro_expansion_output_stream
operator|&&
operator|!
name|executing_string
condition|)
block|{
comment|/* Calling me_execute_string on a lone } provokes an error, since          as far as the reader knows there is no matching {.  We wrote          the { above in the call to append_to_expansion_output. */
name|me_execute_string_keep_state
argument_list|(
name|note
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|current_node
operator|||
operator|!
operator|*
name|current_node
condition|)
block|{
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Footnote defined without parent node"
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|note
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|*
name|marker
condition|)
block|{
name|free
argument_list|(
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|number_footnotes
condition|)
block|{
name|marker
operator|=
name|xmalloc
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|marker
argument_list|,
literal|"%d"
argument_list|,
name|current_footnote_number
argument_list|)
expr_stmt|;
block|}
else|else
name|marker
operator|=
name|xstrdup
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
block|}
name|remember_note
argument_list|(
name|marker
argument_list|,
name|note
argument_list|)
expr_stmt|;
comment|/* fixme: html: footnote processing needs work; we currently ignore      the style requested; we could clash with a node name of the form      `fn-<n>', though that's unlikely. */
if|if
condition|(
name|html
condition|)
name|add_word_args
argument_list|(
literal|"<a rel=footnote href=\"#fn-%d\"><sup>%s</sup></a>"
argument_list|,
name|current_footnote_number
argument_list|,
name|marker
argument_list|)
expr_stmt|;
else|else
comment|/* Your method should at least insert MARKER. */
switch|switch
condition|(
name|footnote_style
condition|)
block|{
case|case
name|separate_node
case|:
name|add_word_args
argument_list|(
literal|"(%s)"
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|" (*note %s-Footnote-%d::)"
argument_list|,
name|current_node
argument_list|,
name|current_footnote_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_footnote_this_node
condition|)
block|{
name|char
modifier|*
name|temp_string
decl_stmt|,
modifier|*
name|expanded_ref
decl_stmt|;
name|temp_string
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|current_node
argument_list|)
operator|+
name|strlen
argument_list|(
literal|"-Footnotes"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp_string
argument_list|,
name|current_node
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp_string
argument_list|,
literal|"-Footnotes"
argument_list|)
expr_stmt|;
name|expanded_ref
operator|=
name|expansion
argument_list|(
name|temp_string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|remember_node_reference
argument_list|(
name|expanded_ref
argument_list|,
name|line_number
argument_list|,
name|followed_reference
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expanded_ref
argument_list|)
expr_stmt|;
name|first_footnote_this_node
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|end_node
case|:
name|add_word_args
argument_list|(
literal|"(%s)"
argument_list|,
name|marker
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|current_footnote_number
operator|++
expr_stmt|;
name|free
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|note
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the footnotes.  We are at the end of the current node. */
end_comment

begin_function
name|void
name|output_pending_notes
parameter_list|()
block|{
name|FN
modifier|*
name|footnote
init|=
name|pending_notes
decl_stmt|;
if|if
condition|(
operator|!
name|pending_notes
condition|)
return|return;
if|if
condition|(
name|html
condition|)
block|{
comment|/* The type= attribute is used just in case some weirdo browser          out there doesn't use numbers by default.  Since we rely on the          browser to produce the footnote numbers, we need to make sure          they ARE indeed numbers.  Pre-HTML4 browsers seem to not care.  */
name|add_word
argument_list|(
literal|"<hr><h4>"
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
name|_
argument_list|(
literal|"Footnotes"
argument_list|)
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"</h4>\n<ol type=\"1\">\n"
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|footnote_style
condition|)
block|{
case|case
name|separate_node
case|:
block|{
name|char
modifier|*
name|old_current_node
init|=
name|current_node
decl_stmt|;
name|char
modifier|*
name|old_command
init|=
name|xstrdup
argument_list|(
name|command
argument_list|)
decl_stmt|;
name|already_outputting_pending_notes
operator|++
expr_stmt|;
name|execute_string
argument_list|(
literal|"%cnode %s-Footnotes,,,%s\n"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|current_node
argument_list|,
name|current_node
argument_list|)
expr_stmt|;
name|already_outputting_pending_notes
operator|--
expr_stmt|;
name|current_node
operator|=
name|old_current_node
expr_stmt|;
name|free
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|command
operator|=
name|old_command
expr_stmt|;
block|}
break|break;
case|case
name|end_node
case|:
name|close_paragraph
argument_list|()
expr_stmt|;
name|in_fixed_width_font
operator|++
expr_stmt|;
comment|/* This string should be translated according to the            @documentlanguage, not the current LANG.  We can't do that            yet, so leave it in English.  */
name|execute_string
argument_list|(
literal|"---------- Footnotes ----------\n\n"
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|--
expr_stmt|;
break|break;
block|}
comment|/* Handle the footnotes in reverse order. */
block|{
name|FN
modifier|*
modifier|*
name|array
init|=
name|xmalloc
argument_list|(
operator|(
name|footnote_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|FN
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|array
index|[
name|footnote_count
index|]
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|--
name|footnote_count
operator|>
operator|-
literal|1
condition|)
block|{
name|array
index|[
name|footnote_count
index|]
operator|=
name|footnote
expr_stmt|;
name|footnote
operator|=
name|footnote
operator|->
name|next
expr_stmt|;
block|}
name|filling_enabled
operator|=
literal|1
expr_stmt|;
name|indented_fill
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|footnote
operator|=
name|array
index|[
operator|++
name|footnote_count
index|]
operator|)
condition|)
block|{
if|if
condition|(
name|html
condition|)
block|{
comment|/* Make the text of every footnote begin a separate paragraph.  */
name|add_word_args
argument_list|(
literal|"<li><a name=\"fn-%d\"></a>\n<p>"
argument_list|,
name|footnote
operator|->
name|number
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|footnote
operator|->
name|note
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
literal|"</p>\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|old_current_node
init|=
name|current_node
decl_stmt|;
name|char
modifier|*
name|old_command
init|=
name|xstrdup
argument_list|(
name|command
argument_list|)
decl_stmt|;
name|already_outputting_pending_notes
operator|++
expr_stmt|;
name|execute_string
argument_list|(
literal|"%canchor{%s-Footnote-%d}(%s) %s"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|current_node
argument_list|,
name|footnote
operator|->
name|number
argument_list|,
name|footnote
operator|->
name|marker
argument_list|,
name|footnote
operator|->
name|note
argument_list|)
expr_stmt|;
name|already_outputting_pending_notes
operator|--
expr_stmt|;
name|current_node
operator|=
name|old_current_node
expr_stmt|;
name|free
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|command
operator|=
name|old_command
expr_stmt|;
block|}
name|close_paragraph
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|html
condition|)
name|add_word
argument_list|(
literal|"</ol><hr>"
argument_list|)
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
name|free_pending_notes
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

