begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* files.c -- file-related functions for Texinfo.    $Id: files.c,v 1.5 1999/03/23 21:42:44 karl Exp $     Copyright (C) 1998, 99 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"files.h"
end_include

begin_include
include|#
directive|include
file|"macro.h"
end_include

begin_include
include|#
directive|include
file|"makeinfo.h"
end_include

begin_decl_stmt
name|FSTACK
modifier|*
name|filestack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|node_filename_stack_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|node_filename_stack_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|node_filename_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Looking for include files.  */
end_comment

begin_comment
comment|/* Given a string containing units of information separated by colons,    return the next one pointed to by INDEX, or NULL if there are no more.    Advance INDEX to the character after the colon. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|extract_colon_unit
parameter_list|(
name|string
parameter_list|,
name|index
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|index
decl_stmt|;
block|{
name|int
name|start
decl_stmt|;
name|int
name|path_sep_char
init|=
name|PATH_SEP
index|[
literal|0
index|]
decl_stmt|;
name|int
name|i
init|=
operator|*
name|index
decl_stmt|;
if|if
condition|(
operator|!
name|string
operator|||
operator|(
name|i
operator|>=
name|strlen
argument_list|(
name|string
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* Each call to this routine leaves the index pointing at a colon if      there is more to the path.  If i> 0, then increment past the      `:'.  If i == 0, then the path has a leading colon.  Trailing colons      are handled OK by the `else' part of the if statement; an empty      string is returned in that case. */
if|if
condition|(
name|i
operator|&&
name|string
index|[
name|i
index|]
operator|==
name|path_sep_char
condition|)
name|i
operator|++
expr_stmt|;
name|start
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|string
index|[
name|i
index|]
operator|&&
name|string
index|[
name|i
index|]
operator|!=
name|path_sep_char
condition|)
name|i
operator|++
expr_stmt|;
operator|*
name|index
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|start
condition|)
block|{
if|if
condition|(
name|string
index|[
name|i
index|]
condition|)
operator|(
operator|*
name|index
operator|)
operator|++
expr_stmt|;
comment|/* Return "" in the case of a trailing `:'. */
return|return
name|xstrdup
argument_list|(
literal|""
argument_list|)
return|;
block|}
else|else
block|{
name|char
modifier|*
name|value
decl_stmt|;
name|value
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
operator|(
name|i
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|value
argument_list|,
operator|&
name|string
index|[
name|start
index|]
argument_list|,
operator|(
name|i
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
name|value
index|[
name|i
operator|-
name|start
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|value
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the full pathname for FILENAME by searching along PATH.    When found, return the stat () info for FILENAME in FINFO.    If PATH is NULL, only the current directory is searched.    If the file could not be found, return a NULL pointer. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_file_info_in_path
parameter_list|(
name|filename
parameter_list|,
name|path
parameter_list|,
name|finfo
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|,
decl|*
name|path
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|stat
modifier|*
name|finfo
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|result
decl_stmt|,
name|index
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
name|path
operator|=
literal|"."
expr_stmt|;
comment|/* Handle absolute pathnames.  */
if|if
condition|(
name|IS_ABSOLUTE
argument_list|(
name|filename
argument_list|)
operator|||
operator|(
operator|*
name|filename
operator|==
literal|'.'
operator|&&
operator|(
name|IS_SLASH
argument_list|(
name|filename
index|[
literal|1
index|]
argument_list|)
operator|||
operator|(
name|filename
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|IS_SLASH
argument_list|(
name|filename
index|[
literal|2
index|]
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
name|finfo
argument_list|)
operator|==
literal|0
condition|)
return|return
name|xstrdup
argument_list|(
name|filename
argument_list|)
return|;
else|else
return|return
name|NULL
return|;
block|}
while|while
condition|(
operator|(
name|dir
operator|=
name|extract_colon_unit
argument_list|(
name|path
argument_list|,
operator|&
name|index
argument_list|)
operator|)
condition|)
block|{
name|char
modifier|*
name|fullpath
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|dir
condition|)
block|{
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|dir
operator|=
name|xstrdup
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
name|fullpath
operator|=
name|xmalloc
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fullpath
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|result
operator|=
name|stat
argument_list|(
name|fullpath
argument_list|,
name|finfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
return|return
name|fullpath
return|;
else|else
name|free
argument_list|(
name|fullpath
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Find and load the file named FILENAME.  Return a pointer to    the loaded file, or NULL if it can't be loaded. */
end_comment

begin_function
name|char
modifier|*
name|find_and_load
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|struct
name|stat
name|fileinfo
decl_stmt|;
name|long
name|file_size
decl_stmt|;
name|int
name|file
init|=
operator|-
literal|1
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|fullpath
decl_stmt|,
modifier|*
name|result
decl_stmt|;
if|#
directive|if
name|O_BINARY
operator|||
name|defined
argument_list|(
name|VMS
argument_list|)
name|int
name|n
decl_stmt|;
endif|#
directive|endif
name|result
operator|=
name|fullpath
operator|=
name|NULL
expr_stmt|;
name|fullpath
operator|=
name|get_file_info_in_path
argument_list|(
name|filename
argument_list|,
name|include_files_path
argument_list|,
operator|&
name|fileinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fullpath
condition|)
goto|goto
name|error_exit
goto|;
name|filename
operator|=
name|fullpath
expr_stmt|;
name|file_size
operator|=
operator|(
name|long
operator|)
name|fileinfo
operator|.
name|st_size
expr_stmt|;
name|file
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|<
literal|0
condition|)
goto|goto
name|error_exit
goto|;
comment|/* Load the file, with enough room for a newline and a null. */
name|result
operator|=
name|xmalloc
argument_list|(
name|file_size
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* VMS stat lies about the st_size value.  The actual number of      readable bytes is always less than this value.  The arcane      mysteries of VMS/RMS are too much to probe, so this hack     suffices to make things work. */
if|#
directive|if
name|O_BINARY
operator|||
name|defined
argument_list|(
name|VMS
argument_list|)
ifdef|#
directive|ifdef
name|VMS
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|file
argument_list|,
name|result
operator|+
name|count
argument_list|,
name|file_size
argument_list|)
operator|)
operator|>
literal|0
condition|)
else|#
directive|else
comment|/* !VMS */
ifndef|#
directive|ifndef
name|WIN32
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|file
argument_list|,
name|result
operator|+
name|count
argument_list|,
name|file_size
argument_list|)
operator|)
operator|>
literal|0
condition|)
else|#
directive|else
comment|/* WIN32 */
comment|/* Does WIN32 really need reading 1 character at a time??  */
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|file
argument_list|,
name|result
operator|+
name|count
argument_list|,
literal|1
argument_list|)
operator|)
operator|>
literal|0
condition|)
endif|#
directive|endif
comment|/* WIN32 */
endif|#
directive|endif
comment|/* !VMS */
name|count
operator|+=
name|n
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|count
operator|&&
name|count
operator|<
name|file_size
condition|)
name|result
operator|=
name|xrealloc
argument_list|(
name|result
argument_list|,
name|count
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* why waste the slack? */
elseif|else
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
else|#
directive|else
comment|/* !VMS&& !O_BINARY */
name|count
operator|=
name|file_size
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|file
argument_list|,
name|result
argument_list|,
name|file_size
argument_list|)
operator|!=
name|file_size
condition|)
endif|#
directive|endif
comment|/* !VMS&& !WIN32 */
name|error_exit
label|:
block|{
if|if
condition|(
name|result
condition|)
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullpath
condition|)
name|free
argument_list|(
name|fullpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* Set the globals to the new file. */
name|input_text
operator|=
name|result
expr_stmt|;
name|input_text_length
operator|=
name|count
expr_stmt|;
name|input_filename
operator|=
name|fullpath
expr_stmt|;
name|node_filename
operator|=
name|xstrdup
argument_list|(
name|fullpath
argument_list|)
expr_stmt|;
name|input_text_offset
operator|=
literal|0
expr_stmt|;
name|line_number
operator|=
literal|1
expr_stmt|;
comment|/* Not strictly necessary.  This magic prevents read_token () from doing      extra unnecessary work each time it is called (that is a lot of times).      INPUT_TEXT_LENGTH is one past the actual end of the text. */
name|input_text
index|[
name|input_text_length
index|]
operator|=
literal|'\n'
expr_stmt|;
comment|/* This, on the other hand, is always necessary.  */
name|input_text
index|[
name|input_text_length
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Pushing and popping files.  */
end_comment

begin_function
name|void
name|push_node_filename
parameter_list|()
block|{
if|if
condition|(
name|node_filename_stack_index
operator|+
literal|1
operator|>
name|node_filename_stack_size
condition|)
name|node_filename_stack
operator|=
name|xrealloc
argument_list|(
name|node_filename_stack
argument_list|,
operator|(
name|node_filename_stack_size
operator|+=
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|node_filename_stack
index|[
name|node_filename_stack_index
index|]
operator|=
name|node_filename
expr_stmt|;
name|node_filename_stack_index
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_node_filename
parameter_list|()
block|{
name|node_filename
operator|=
name|node_filename_stack
index|[
operator|--
name|node_filename_stack_index
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save the state of the current input file. */
end_comment

begin_function
name|void
name|pushfile
parameter_list|()
block|{
name|FSTACK
modifier|*
name|newstack
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FSTACK
argument_list|)
argument_list|)
decl_stmt|;
name|newstack
operator|->
name|filename
operator|=
name|input_filename
expr_stmt|;
name|newstack
operator|->
name|text
operator|=
name|input_text
expr_stmt|;
name|newstack
operator|->
name|size
operator|=
name|input_text_length
expr_stmt|;
name|newstack
operator|->
name|offset
operator|=
name|input_text_offset
expr_stmt|;
name|newstack
operator|->
name|line_number
operator|=
name|line_number
expr_stmt|;
name|newstack
operator|->
name|next
operator|=
name|filestack
expr_stmt|;
name|filestack
operator|=
name|newstack
expr_stmt|;
name|push_node_filename
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make the current file globals be what is on top of the file stack. */
end_comment

begin_function
name|void
name|popfile
parameter_list|()
block|{
name|FSTACK
modifier|*
name|tos
init|=
name|filestack
decl_stmt|;
if|if
condition|(
operator|!
name|tos
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* My fault.  I wonder what I did? */
if|if
condition|(
name|macro_expansion_output_stream
condition|)
block|{
name|maybe_write_itext
argument_list|(
name|input_text
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
name|forget_itext
argument_list|(
name|input_text
argument_list|)
expr_stmt|;
block|}
comment|/* Pop the stack. */
name|filestack
operator|=
name|filestack
operator|->
name|next
expr_stmt|;
comment|/* Make sure that commands with braces have been satisfied. */
if|if
condition|(
operator|!
name|executing_string
operator|&&
operator|!
name|me_executing_string
condition|)
name|discard_braces
argument_list|()
expr_stmt|;
comment|/* Get the top of the stack into the globals. */
name|input_filename
operator|=
name|tos
operator|->
name|filename
expr_stmt|;
name|input_text
operator|=
name|tos
operator|->
name|text
expr_stmt|;
name|input_text_length
operator|=
name|tos
operator|->
name|size
expr_stmt|;
name|input_text_offset
operator|=
name|tos
operator|->
name|offset
expr_stmt|;
name|line_number
operator|=
name|tos
operator|->
name|line_number
expr_stmt|;
name|free
argument_list|(
name|tos
argument_list|)
expr_stmt|;
comment|/* Go back to the (now) current node. */
name|pop_node_filename
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flush all open files on the file stack. */
end_comment

begin_function
name|void
name|flush_file_stack
parameter_list|()
block|{
while|while
condition|(
name|filestack
condition|)
block|{
name|char
modifier|*
name|fname
init|=
name|input_filename
decl_stmt|;
name|char
modifier|*
name|text
init|=
name|input_text
decl_stmt|;
name|popfile
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the index of the first character in the filename    which is past all the leading directory characters.  */
end_comment

begin_function
specifier|static
name|int
name|skip_directory_part
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|i
init|=
name|strlen
argument_list|(
name|filename
argument_list|)
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|&&
operator|!
name|IS_SLASH
argument_list|(
name|filename
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|IS_SLASH
argument_list|(
name|filename
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|filename
index|[
name|i
index|]
operator|&&
name|HAVE_DRIVE
argument_list|(
name|filename
argument_list|)
condition|)
name|i
operator|=
literal|2
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|filename_non_directory
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
name|xstrdup
argument_list|(
name|name
operator|+
name|skip_directory_part
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return just the simple part of the filename; i.e. the    filename without the path information, or extensions.    This conses up a new string. */
end_comment

begin_function
name|char
modifier|*
name|filename_part
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|basename
init|=
name|filename_non_directory
argument_list|(
name|filename
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|REMOVE_OUTPUT_EXTENSIONS
comment|/* See if there is an extension to remove.  If so, remove it. */
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|strrchr
argument_list|(
name|basename
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
operator|*
name|temp
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* REMOVE_OUTPUT_EXTENSIONS */
return|return
name|basename
return|;
block|}
end_function

begin_comment
comment|/* Return the pathname part of filename.  This can be NULL. */
end_comment

begin_function
name|char
modifier|*
name|pathname_part
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|expand_filename
parameter_list|()
function_decl|;
name|char
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|filename
operator|=
name|expand_filename
argument_list|(
name|filename
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|i
operator|=
name|skip_directory_part
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|result
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|i
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|result
argument_list|,
name|filename
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|result
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return the expansion of FILENAME. */
end_comment

begin_function
name|char
modifier|*
name|expand_filename
parameter_list|(
name|filename
parameter_list|,
name|input_name
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|,
decl|*
name|input_name
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|full_pathname
parameter_list|()
function_decl|;
if|if
condition|(
name|filename
condition|)
block|{
name|filename
operator|=
name|full_pathname
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ABSOLUTE
argument_list|(
name|filename
argument_list|)
operator|||
operator|(
operator|*
name|filename
operator|==
literal|'.'
operator|&&
operator|(
name|IS_SLASH
argument_list|(
name|filename
index|[
literal|1
index|]
argument_list|)
operator|||
operator|(
name|filename
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|IS_SLASH
argument_list|(
name|filename
index|[
literal|2
index|]
argument_list|)
operator|)
operator|)
operator|)
condition|)
return|return
name|filename
return|;
block|}
else|else
block|{
name|filename
operator|=
name|filename_non_directory
argument_list|(
name|input_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|filename
condition|)
block|{
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|filename
operator|=
name|xstrdup
argument_list|(
literal|"noname.texi"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
operator|-
literal|1
init|;
name|i
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|filename
index|[
name|i
index|]
operator|==
literal|'.'
condition|)
break|break;
if|if
condition|(
operator|!
name|i
condition|)
name|i
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|6
operator|>
operator|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|)
condition|)
name|filename
operator|=
name|xrealloc
argument_list|(
name|filename
argument_list|,
name|i
operator|+
literal|6
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|filename
operator|+
name|i
argument_list|,
name|html
condition|?
literal|".html"
else|:
literal|".info"
argument_list|)
expr_stmt|;
return|return
name|filename
return|;
block|}
if|if
condition|(
name|IS_ABSOLUTE
argument_list|(
name|input_name
argument_list|)
condition|)
block|{
comment|/* Make it so that relative names work. */
name|char
modifier|*
name|result
decl_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|input_name
argument_list|)
operator|-
literal|1
expr_stmt|;
name|result
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|input_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|input_name
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|IS_SLASH
argument_list|(
name|result
index|[
name|i
index|]
argument_list|)
operator|&&
name|i
condition|)
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|IS_SLASH
argument_list|(
name|result
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|result
index|[
name|i
index|]
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
return|return
name|filename
return|;
block|}
end_block

begin_comment
comment|/* Return the full path to FILENAME. */
end_comment

begin_function
name|char
modifier|*
name|full_pathname
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|initial_character
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
comment|/* No filename given? */
if|if
condition|(
operator|!
name|filename
operator|||
operator|!
operator|*
name|filename
condition|)
return|return
name|xstrdup
argument_list|(
literal|""
argument_list|)
return|;
comment|/* Already absolute? */
if|if
condition|(
name|IS_ABSOLUTE
argument_list|(
name|filename
argument_list|)
operator|||
operator|(
operator|*
name|filename
operator|==
literal|'.'
operator|&&
operator|(
name|IS_SLASH
argument_list|(
name|filename
index|[
literal|1
index|]
argument_list|)
operator|||
operator|(
name|filename
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|IS_SLASH
argument_list|(
name|filename
index|[
literal|2
index|]
argument_list|)
operator|)
operator|)
operator|)
condition|)
return|return
name|xstrdup
argument_list|(
name|filename
argument_list|)
return|;
name|initial_character
operator|=
operator|*
name|filename
expr_stmt|;
if|if
condition|(
name|initial_character
operator|!=
literal|'~'
condition|)
block|{
name|char
modifier|*
name|localdir
init|=
name|xmalloc
argument_list|(
literal|1025
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GETCWD
if|if
condition|(
operator|!
name|getcwd
argument_list|(
name|localdir
argument_list|,
literal|1024
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|getwd
argument_list|(
name|localdir
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: getwd: %s, %s\n"
argument_list|)
argument_list|,
name|progname
argument_list|,
name|filename
argument_list|,
name|localdir
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|localdir
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|localdir
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|result
operator|=
name|xstrdup
argument_list|(
name|localdir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|localdir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Does anybody know why WIN32 doesn't want to support $HOME?          If the reason is they don't have getpwnam, they should          only disable the else clause below.  */
ifndef|#
directive|ifndef
name|WIN32
if|if
condition|(
name|IS_SLASH
argument_list|(
name|filename
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* Return the concatenation of the environment variable HOME              and the rest of the string. */
name|char
modifier|*
name|temp_home
decl_stmt|;
name|temp_home
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
name|result
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
operator|&
name|filename
index|[
literal|1
index|]
argument_list|)
operator|+
literal|1
operator|+
name|temp_home
condition|?
name|strlen
argument_list|(
name|temp_home
argument_list|)
else|:
literal|0
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|temp_home
condition|)
name|strcpy
argument_list|(
name|result
argument_list|,
name|temp_home
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|result
argument_list|,
operator|&
name|filename
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|passwd
modifier|*
name|user_entry
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|char
modifier|*
name|username
init|=
name|xmalloc
argument_list|(
literal|257
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|(
name|c
operator|=
name|filename
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IS_SLASH
argument_list|(
name|c
argument_list|)
condition|)
break|break;
else|else
name|username
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|c
condition|)
name|username
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|user_entry
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|user_entry
condition|)
return|return
name|xstrdup
argument_list|(
name|filename
argument_list|)
return|;
name|result
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|user_entry
operator|->
name|pw_dir
argument_list|)
operator|+
name|strlen
argument_list|(
operator|&
name|filename
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|user_entry
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|result
argument_list|,
operator|&
name|filename
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not WIN32 */
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|output_name_from_input_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
name|expand_filename
argument_list|(
name|NULL
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

end_unit

