begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* macro.c -- user-defined macros for Texinfo.    $Id: macro.c,v 1.10 1999/08/17 21:06:35 karl Exp $     Copyright (C) 1998, 99 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cmds.h"
end_include

begin_include
include|#
directive|include
file|"macro.h"
end_include

begin_include
include|#
directive|include
file|"makeinfo.h"
end_include

begin_include
include|#
directive|include
file|"insertion.h"
end_include

begin_comment
comment|/* If non-NULL, this is an output stream to write the full macro expansion    of the input text to.  The result is another texinfo file, but    missing @include, @infoinclude, @macro, and macro invocations.  Instead,    all of the text is placed within the file. */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|macro_expansion_output_stream
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output file for -E.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|macro_expansion_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means a macro string is in execution, as opposed to a file. */
end_comment

begin_decl_stmt
name|int
name|me_executing_string
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means we want only to expand macros and    leave everything else intact.  */
end_comment

begin_decl_stmt
name|int
name|only_macro_expansion
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ITEXT
modifier|*
modifier|*
name|itext_info
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|itext_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the arglist on the current line.  This can behave in two different    ways, depending on the variable BRACES_REQUIRED_FOR_MACRO_ARGS. */
end_comment

begin_decl_stmt
name|int
name|braces_required_for_macro_args
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of macros and definitions. */
end_comment

begin_decl_stmt
name|MACRO_DEF
modifier|*
modifier|*
name|macro_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|macro_list_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements. */
end_comment

begin_decl_stmt
name|int
name|macro_list_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of slots in total. */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Return the length of the array in ARRAY. */
end_comment

begin_function
name|int
name|array_len
parameter_list|(
name|array
parameter_list|)
name|char
modifier|*
modifier|*
name|array
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|array
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|array
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
name|void
name|free_array
parameter_list|(
name|array
parameter_list|)
name|char
modifier|*
modifier|*
name|array
decl_stmt|;
block|{
if|if
condition|(
name|array
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|array
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the macro definition of NAME or NULL if NAME is not defined. */
end_comment

begin_function
name|MACRO_DEF
modifier|*
name|find_macro
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|MACRO_DEF
modifier|*
name|def
decl_stmt|;
name|def
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|macro_list
operator|&&
operator|(
name|def
operator|=
name|macro_list
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|!
name|def
operator|->
name|inhibited
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|def
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
return|return
name|def
return|;
block|}
end_function

begin_comment
comment|/* Add the macro NAME with ARGLIST and BODY to the list of defined macros.    SOURCE_FILE is the name of the file where this definition can be found,    and SOURCE_LINENO is the line number within that file.  If a macro already    exists with NAME, then a warning is produced, and that previous    definition is overwritten. */
end_comment

begin_function
name|void
name|add_macro
parameter_list|(
name|name
parameter_list|,
name|arglist
parameter_list|,
name|body
parameter_list|,
name|source_file
parameter_list|,
name|source_lineno
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|arglist
decl_stmt|;
name|char
modifier|*
name|body
decl_stmt|;
name|char
modifier|*
name|source_file
decl_stmt|;
name|int
name|source_lineno
decl_stmt|,
name|flags
decl_stmt|;
block|{
name|MACRO_DEF
modifier|*
name|def
decl_stmt|;
name|def
operator|=
name|find_macro
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|def
condition|)
block|{
if|if
condition|(
name|macro_list_len
operator|+
literal|2
operator|>=
name|macro_list_size
condition|)
name|macro_list
operator|=
name|xrealloc
argument_list|(
name|macro_list
argument_list|,
operator|(
operator|(
name|macro_list_size
operator|+=
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|MACRO_DEF
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|macro_list
index|[
name|macro_list_len
index|]
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|MACRO_DEF
argument_list|)
argument_list|)
expr_stmt|;
name|macro_list
index|[
name|macro_list_len
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|def
operator|=
name|macro_list
index|[
name|macro_list_len
index|]
expr_stmt|;
name|macro_list_len
operator|+=
literal|1
expr_stmt|;
name|def
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|temp_filename
init|=
name|input_filename
decl_stmt|;
name|int
name|temp_line
init|=
name|line_number
decl_stmt|;
name|warning
argument_list|(
name|_
argument_list|(
literal|"macro `%s' previously defined"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|def
operator|->
name|source_file
expr_stmt|;
name|line_number
operator|=
name|def
operator|->
name|source_lineno
expr_stmt|;
name|warning
argument_list|(
name|_
argument_list|(
literal|"here is the previous definition of `%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|temp_filename
expr_stmt|;
name|line_number
operator|=
name|temp_line
expr_stmt|;
if|if
condition|(
name|def
operator|->
name|arglist
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|def
operator|->
name|arglist
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|def
operator|->
name|arglist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|def
operator|->
name|arglist
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|def
operator|->
name|source_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|def
operator|->
name|body
argument_list|)
expr_stmt|;
block|}
name|def
operator|->
name|source_file
operator|=
name|xstrdup
argument_list|(
name|source_file
argument_list|)
expr_stmt|;
name|def
operator|->
name|source_lineno
operator|=
name|source_lineno
expr_stmt|;
name|def
operator|->
name|body
operator|=
name|body
expr_stmt|;
name|def
operator|->
name|arglist
operator|=
name|arglist
expr_stmt|;
name|def
operator|->
name|inhibited
operator|=
literal|0
expr_stmt|;
name|def
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
modifier|*
name|get_brace_args
parameter_list|(
name|quote_single
parameter_list|)
name|int
name|quote_single
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|arglist
decl_stmt|,
modifier|*
name|word
decl_stmt|;
name|int
name|arglist_index
decl_stmt|,
name|arglist_size
decl_stmt|;
name|int
name|character
decl_stmt|,
name|escape_seen
decl_stmt|,
name|start
decl_stmt|;
name|int
name|depth
init|=
literal|1
decl_stmt|;
comment|/* There is an arglist in braces here, so gather the args inside of it. */
name|skip_whitespace_and_newlines
argument_list|()
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
name|arglist
operator|=
name|NULL
expr_stmt|;
name|arglist_index
operator|=
name|arglist_size
operator|=
literal|0
expr_stmt|;
name|get_arg
label|:
name|skip_whitespace_and_newlines
argument_list|()
expr_stmt|;
name|start
operator|=
name|input_text_offset
expr_stmt|;
name|escape_seen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|character
operator|=
name|curchar
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|character
operator|==
literal|'\\'
condition|)
block|{
name|input_text_offset
operator|+=
literal|2
expr_stmt|;
name|escape_seen
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|character
operator|==
literal|'{'
condition|)
block|{
name|depth
operator|++
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|character
operator|==
literal|','
operator|&&
operator|!
name|quote_single
operator|)
operator|||
operator|(
operator|(
name|character
operator|==
literal|'}'
operator|)
operator|&&
name|depth
operator|==
literal|1
operator|)
condition|)
block|{
name|int
name|len
init|=
name|input_text_offset
operator|-
name|start
decl_stmt|;
if|if
condition|(
name|len
operator|||
operator|(
name|character
operator|!=
literal|'}'
operator|)
condition|)
block|{
name|word
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|word
argument_list|,
name|input_text
operator|+
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|word
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Clean up escaped characters. */
if|if
condition|(
name|escape_seen
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|word
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|word
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
name|memmove
argument_list|(
name|word
operator|+
name|i
argument_list|,
name|word
operator|+
name|i
operator|+
literal|1
argument_list|,
literal|1
operator|+
name|strlen
argument_list|(
name|word
operator|+
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arglist_index
operator|+
literal|2
operator|>=
name|arglist_size
condition|)
name|arglist
operator|=
name|xrealloc
argument_list|(
name|arglist
argument_list|,
operator|(
name|arglist_size
operator|+=
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
index|[
name|arglist_index
operator|++
index|]
operator|=
name|word
expr_stmt|;
name|arglist
index|[
name|arglist_index
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|input_text_offset
operator|++
expr_stmt|;
if|if
condition|(
name|character
operator|==
literal|'}'
condition|)
break|break;
else|else
goto|goto
name|get_arg
goto|;
block|}
elseif|else
if|if
condition|(
name|character
operator|==
literal|'}'
condition|)
block|{
name|depth
operator|--
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
block|}
else|else
block|{
name|input_text_offset
operator|++
expr_stmt|;
if|if
condition|(
name|character
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
block|}
block|}
return|return
name|arglist
return|;
block|}
end_function

begin_function
name|char
modifier|*
modifier|*
name|get_macro_args
parameter_list|(
name|def
parameter_list|)
name|MACRO_DEF
modifier|*
name|def
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|word
decl_stmt|;
comment|/* Quickly check to see if this macro has been invoked with any arguments.      If not, then don't skip any of the following whitespace. */
for|for
control|(
name|i
operator|=
name|input_text_offset
init|;
name|i
operator|<
name|input_text_length
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|cr_or_whitespace
argument_list|(
name|input_text
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|input_text
index|[
name|i
index|]
operator|!=
literal|'{'
condition|)
block|{
if|if
condition|(
name|braces_required_for_macro_args
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
comment|/* Braces are not required to fill out the macro arguments.  If              this macro takes one argument, it is considered to be the              remainder of the line, sans whitespace. */
if|if
condition|(
name|def
operator|->
name|arglist
operator|&&
name|def
operator|->
name|arglist
index|[
literal|0
index|]
operator|&&
operator|!
name|def
operator|->
name|arglist
index|[
literal|1
index|]
condition|)
block|{
name|char
modifier|*
modifier|*
name|arglist
decl_stmt|;
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_text
index|[
name|input_text_offset
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|input_text_offset
operator|--
expr_stmt|;
name|line_number
operator|--
expr_stmt|;
block|}
comment|/* canon_white (word); */
name|arglist
operator|=
name|xmalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
index|[
literal|0
index|]
operator|=
name|word
expr_stmt|;
name|arglist
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|arglist
return|;
block|}
else|else
block|{
comment|/* The macro either took no arguments, or took more than                  one argument.  In that case, it must be invoked with                  arguments surrounded by braces. */
return|return
name|NULL
return|;
block|}
block|}
block|}
return|return
name|get_brace_args
argument_list|(
name|def
operator|->
name|flags
operator|&
name|ME_QUOTE_ARG
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Substitute actual parameters for named parameters in body.    The named parameters which appear in BODY must by surrounded    reverse slashes, as in \foo\. */
end_comment

begin_function
name|char
modifier|*
name|apply
parameter_list|(
name|named
parameter_list|,
name|actuals
parameter_list|,
name|body
parameter_list|)
name|char
modifier|*
modifier|*
name|named
decl_stmt|,
decl|*
modifier|*
name|actuals
decl_stmt|,
modifier|*
name|body
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|new_body_index
decl_stmt|,
name|new_body_size
decl_stmt|;
name|char
modifier|*
name|new_body
decl_stmt|,
modifier|*
name|text
decl_stmt|;
name|int
name|length_of_actuals
decl_stmt|;
name|length_of_actuals
operator|=
name|array_len
argument_list|(
name|actuals
argument_list|)
expr_stmt|;
name|new_body_size
operator|=
name|strlen
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|new_body
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|new_body_size
argument_list|)
expr_stmt|;
comment|/* Copy chars from BODY into NEW_BODY. */
name|i
operator|=
literal|0
expr_stmt|;
name|new_body_index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|body
index|[
name|i
index|]
condition|)
block|{
comment|/* Anything but a \ is easy.  */
if|if
condition|(
name|body
index|[
name|i
index|]
operator|!=
literal|'\\'
condition|)
name|new_body
index|[
name|new_body_index
operator|++
index|]
operator|=
name|body
index|[
name|i
operator|++
index|]
expr_stmt|;
else|else
block|{
comment|/* Snarf parameter name, check against named parameters. */
name|char
modifier|*
name|param
decl_stmt|;
name|int
name|param_start
decl_stmt|,
name|which
decl_stmt|,
name|len
decl_stmt|;
name|param_start
operator|=
operator|++
name|i
expr_stmt|;
while|while
condition|(
name|body
index|[
name|i
index|]
operator|&&
name|body
index|[
name|i
index|]
operator|!=
literal|'\\'
condition|)
name|i
operator|++
expr_stmt|;
name|len
operator|=
name|i
operator|-
name|param_start
expr_stmt|;
name|param
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|param
argument_list|,
name|body
operator|+
name|param_start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|param
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|body
index|[
name|i
index|]
condition|)
comment|/* move past \ */
name|i
operator|++
expr_stmt|;
comment|/* Now check against named parameters. */
for|for
control|(
name|which
operator|=
literal|0
init|;
name|named
operator|&&
name|named
index|[
name|which
index|]
condition|;
name|which
operator|++
control|)
if|if
condition|(
name|STREQ
argument_list|(
name|named
index|[
name|which
index|]
argument_list|,
name|param
argument_list|)
condition|)
break|break;
if|if
condition|(
name|named
operator|&&
name|named
index|[
name|which
index|]
condition|)
block|{
name|text
operator|=
name|which
operator|<
name|length_of_actuals
condition|?
name|actuals
index|[
name|which
index|]
else|:
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|text
condition|)
name|text
operator|=
literal|""
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* not a parameter, either it's \\ (if len==0) or an                  error.  In either case, restore one \ at least.  */
if|if
condition|(
name|len
condition|)
block|{
name|warning
argument_list|(
name|_
argument_list|(
literal|"\\ in macro expansion followed by `%s' instead of \\ or parameter name"
argument_list|)
argument_list|,
name|param
argument_list|)
expr_stmt|;
block|}
name|len
operator|++
expr_stmt|;
name|text
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|text
argument_list|,
literal|"\\%s"
argument_list|,
name|param
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|param
argument_list|)
operator|+
literal|2
operator|<
name|len
condition|)
block|{
name|new_body_size
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|new_body
operator|=
name|xrealloc
argument_list|(
name|new_body
argument_list|,
name|new_body_size
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new_body
operator|+
name|new_body_index
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|new_body_index
operator|+=
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|named
operator|||
operator|!
name|named
index|[
name|which
index|]
condition|)
name|free
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
block|}
name|new_body
index|[
name|new_body_index
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|new_body
return|;
block|}
end_block

begin_comment
comment|/* Expand macro passed in DEF, a pointer to a MACRO_DEF, and    return its expansion as a string.  */
end_comment

begin_function
name|char
modifier|*
name|expand_macro
parameter_list|(
name|def
parameter_list|)
name|MACRO_DEF
modifier|*
name|def
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|arglist
decl_stmt|;
name|int
name|num_args
decl_stmt|;
name|char
modifier|*
name|execution_string
init|=
name|NULL
decl_stmt|;
name|int
name|start_line
init|=
name|line_number
decl_stmt|;
comment|/* Find out how many arguments this macro definition takes. */
name|num_args
operator|=
name|array_len
argument_list|(
name|def
operator|->
name|arglist
argument_list|)
expr_stmt|;
comment|/* Gather the arguments present on the line if there are any. */
name|arglist
operator|=
name|get_macro_args
argument_list|(
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_args
operator|<
name|array_len
argument_list|(
name|arglist
argument_list|)
condition|)
block|{
name|free_array
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|line_error
argument_list|(
name|_
argument_list|(
literal|"Macro `%s' called on line %d with too many args"
argument_list|)
argument_list|,
name|def
operator|->
name|name
argument_list|,
name|start_line
argument_list|)
expr_stmt|;
return|return
name|execution_string
return|;
block|}
if|if
condition|(
name|def
operator|->
name|body
condition|)
name|execution_string
operator|=
name|apply
argument_list|(
name|def
operator|->
name|arglist
argument_list|,
name|arglist
argument_list|,
name|def
operator|->
name|body
argument_list|)
expr_stmt|;
name|free_array
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
return|return
name|execution_string
return|;
block|}
end_function

begin_comment
comment|/* Execute the macro passed in DEF, a pointer to a MACRO_DEF.  */
end_comment

begin_function
name|void
name|execute_macro
parameter_list|(
name|def
parameter_list|)
name|MACRO_DEF
modifier|*
name|def
decl_stmt|;
block|{
name|char
modifier|*
name|execution_string
decl_stmt|;
name|int
name|start_line
init|=
name|line_number
decl_stmt|,
name|end_line
decl_stmt|;
if|if
condition|(
name|macro_expansion_output_stream
operator|&&
operator|!
name|executing_string
operator|&&
operator|!
name|me_inhibit_expansion
condition|)
name|me_append_before_this_command
argument_list|()
expr_stmt|;
name|execution_string
operator|=
name|expand_macro
argument_list|(
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|execution_string
condition|)
return|return;
if|if
condition|(
name|def
operator|->
name|body
condition|)
block|{
comment|/* Reset the line number to where the macro arguments began.          This makes line numbers reported in error messages correct in          case the macro arguments span several lines and the expanded          arguments invoke other commands.  */
name|end_line
operator|=
name|line_number
expr_stmt|;
name|line_number
operator|=
name|start_line
expr_stmt|;
if|if
condition|(
name|macro_expansion_output_stream
operator|&&
operator|!
name|executing_string
operator|&&
operator|!
name|me_inhibit_expansion
condition|)
block|{
name|remember_itext
argument_list|(
name|input_text
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
name|me_execute_string
argument_list|(
name|execution_string
argument_list|)
expr_stmt|;
block|}
else|else
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|execution_string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|execution_string
argument_list|)
expr_stmt|;
name|line_number
operator|=
name|end_line
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read and remember the definition of a macro.  If RECURSIVE is set,    set the ME_RECURSE flag.  MACTYPE is either "macro" or "rmacro", and    tells us what the matching @end should be.  */
end_comment

begin_function
specifier|static
name|void
name|define_macro
parameter_list|(
name|mactype
parameter_list|,
name|recursive
parameter_list|)
name|char
modifier|*
name|mactype
decl_stmt|;
name|int
name|recursive
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
modifier|*
name|arglist
decl_stmt|,
modifier|*
name|body
decl_stmt|,
modifier|*
name|line
decl_stmt|,
modifier|*
name|last_end
decl_stmt|;
name|int
name|body_size
decl_stmt|,
name|body_index
decl_stmt|;
name|int
name|depth
init|=
literal|1
decl_stmt|;
name|int
name|defining_line
init|=
name|line_number
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|arglist
operator|=
name|NULL
expr_stmt|;
name|body
operator|=
name|NULL
expr_stmt|;
name|body_size
operator|=
literal|0
expr_stmt|;
name|body_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|macro_expansion_output_stream
operator|&&
operator|!
name|executing_string
condition|)
name|me_append_before_this_command
argument_list|()
expr_stmt|;
name|skip_whitespace
argument_list|()
expr_stmt|;
comment|/* Get the name of the macro.  This is the set of characters which are      not whitespace and are not `{' immediately following the @macro. */
block|{
name|int
name|start
init|=
name|input_text_offset
decl_stmt|;
name|int
name|len
decl_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
operator|(
name|i
operator|<
name|input_text_length
operator|)
operator|&&
operator|(
name|input_text
index|[
name|i
index|]
operator|!=
literal|'{'
operator|)
operator|&&
operator|(
operator|!
name|cr_or_whitespace
argument_list|(
name|input_text
index|[
name|i
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|len
operator|=
name|i
operator|-
name|start
expr_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|input_text
operator|+
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|input_text_offset
operator|=
name|i
expr_stmt|;
block|}
name|skip_whitespace
argument_list|()
expr_stmt|;
comment|/* It is not required that the definition of a macro includes an arglist.      If not, don't try to get the named parameters, just use a null list. */
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|'{'
condition|)
block|{
name|int
name|character
decl_stmt|;
name|int
name|arglist_index
init|=
literal|0
decl_stmt|,
name|arglist_size
init|=
literal|0
decl_stmt|;
name|int
name|gathering_words
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|word
init|=
name|NULL
decl_stmt|;
comment|/* Read the words inside of the braces which determine the arglist.          These words will be replaced within the body of the macro at          execution time. */
name|input_text_offset
operator|++
expr_stmt|;
name|skip_whitespace_and_newlines
argument_list|()
expr_stmt|;
while|while
condition|(
name|gathering_words
condition|)
block|{
name|int
name|len
decl_stmt|;
for|for
control|(
name|i
operator|=
name|input_text_offset
init|;
operator|(
name|character
operator|=
name|input_text
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|character
condition|)
block|{
case|case
literal|'\n'
case|:
name|line_number
operator|++
expr_stmt|;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|','
case|:
case|case
literal|'}'
case|:
comment|/* Found the end of the current arglist word.  Save it. */
name|len
operator|=
name|i
operator|-
name|input_text_offset
expr_stmt|;
name|word
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|word
argument_list|,
name|input_text
operator|+
name|input_text_offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|word
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|input_text_offset
operator|=
name|i
expr_stmt|;
comment|/* Advance to the comma or close-brace that signified                      the end of the argument. */
while|while
condition|(
operator|(
name|character
operator|=
name|curchar
argument_list|()
operator|)
operator|&&
name|character
operator|!=
literal|','
operator|&&
name|character
operator|!=
literal|'}'
condition|)
block|{
name|input_text_offset
operator|++
expr_stmt|;
if|if
condition|(
name|character
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
block|}
comment|/* Add the word to our list of words. */
if|if
condition|(
name|arglist_index
operator|+
literal|2
operator|>=
name|arglist_size
condition|)
block|{
name|arglist_size
operator|+=
literal|10
expr_stmt|;
name|arglist
operator|=
name|xrealloc
argument_list|(
name|arglist
argument_list|,
name|arglist_size
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|arglist
index|[
name|arglist_index
operator|++
index|]
operator|=
name|word
expr_stmt|;
name|arglist
index|[
name|arglist_index
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|character
operator|==
literal|'}'
condition|)
block|{
name|input_text_offset
operator|++
expr_stmt|;
name|gathering_words
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|character
operator|==
literal|','
condition|)
block|{
name|input_text_offset
operator|++
expr_stmt|;
name|skip_whitespace_and_newlines
argument_list|()
expr_stmt|;
name|i
operator|=
name|input_text_offset
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* If we have exactly one argument, do @quote-arg implicitly.  Not          only does this match TeX's behavior (which can't feasibly be          changed), but it's a good idea.  */
if|if
condition|(
name|arglist_index
operator|==
literal|1
condition|)
name|flags
operator||=
name|ME_QUOTE_ARG
expr_stmt|;
block|}
comment|/* Read the text carefully until we find an "@end macro" which      matches this one.  The text in between is the body of the macro. */
name|skip_whitespace_and_newlines
argument_list|()
expr_stmt|;
while|while
condition|(
name|depth
condition|)
block|{
if|if
condition|(
operator|(
name|input_text_offset
operator|+
literal|9
operator|)
operator|>
name|input_text_length
condition|)
block|{
name|int
name|temp_line
init|=
name|line_number
decl_stmt|;
name|line_number
operator|=
name|defining_line
expr_stmt|;
name|line_error
argument_list|(
name|_
argument_list|(
literal|"%cend macro not found"
argument_list|)
argument_list|,
name|COMMAND_PREFIX
argument_list|)
expr_stmt|;
name|line_number
operator|=
name|temp_line
expr_stmt|;
return|return;
block|}
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
comment|/* Handle commands only meaningful within a macro. */
if|if
condition|(
operator|(
operator|*
name|line
operator|==
name|COMMAND_PREFIX
operator|)
operator|&&
operator|(
name|depth
operator|==
literal|1
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|line
operator|+
literal|1
argument_list|,
literal|"allow-recursion"
argument_list|,
literal|15
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|line
index|[
literal|16
index|]
operator|==
literal|0
operator|||
name|whitespace
argument_list|(
name|line
index|[
literal|16
index|]
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|16
init|;
name|whitespace
argument_list|(
name|line
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|strcpy
argument_list|(
name|line
argument_list|,
name|line
operator|+
name|i
argument_list|)
expr_stmt|;
name|flags
operator||=
name|ME_RECURSE
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|line
condition|)
block|{
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
operator|*
name|line
operator|==
name|COMMAND_PREFIX
operator|)
operator|&&
operator|(
name|depth
operator|==
literal|1
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|line
operator|+
literal|1
argument_list|,
literal|"quote-arg"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|line
index|[
literal|10
index|]
operator|==
literal|0
operator|||
name|whitespace
argument_list|(
name|line
index|[
literal|10
index|]
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|10
init|;
name|whitespace
argument_list|(
name|line
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|strcpy
argument_list|(
name|line
argument_list|,
name|line
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglist
operator|&&
name|arglist
index|[
literal|0
index|]
operator|&&
operator|!
name|arglist
index|[
literal|1
index|]
condition|)
block|{
name|flags
operator||=
name|ME_QUOTE_ARG
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|line
condition|)
block|{
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
name|line_error
argument_list|(
name|_
argument_list|(
literal|"@quote-arg only useful for single-argument macros"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|line
operator|==
name|COMMAND_PREFIX
operator|&&
operator|(
name|strncmp
argument_list|(
name|line
operator|+
literal|1
argument_list|,
literal|"macro "
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|line
operator|+
literal|1
argument_list|,
literal|"rmacro "
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|depth
operator|++
expr_stmt|;
comment|/* Incorrect implementation of nesting -- just check that the last          @end matches what we started with.  Since nested macros don't          work in TeX anyway, this isn't worth the trouble to get right.  */
if|if
condition|(
operator|*
name|line
operator|==
name|COMMAND_PREFIX
operator|&&
name|strncmp
argument_list|(
name|line
operator|+
literal|1
argument_list|,
literal|"end macro"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
name|depth
operator|--
expr_stmt|;
name|last_end
operator|=
literal|"macro"
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|line
operator|==
name|COMMAND_PREFIX
operator|&&
name|strncmp
argument_list|(
name|line
operator|+
literal|1
argument_list|,
literal|"end rmacro"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
condition|)
block|{
name|depth
operator|--
expr_stmt|;
name|last_end
operator|=
literal|"rmacro"
expr_stmt|;
block|}
if|if
condition|(
name|depth
condition|)
block|{
if|if
condition|(
operator|(
name|body_index
operator|+
name|strlen
argument_list|(
name|line
argument_list|)
operator|+
literal|3
operator|)
operator|>=
name|body_size
condition|)
name|body
operator|=
name|xrealloc
argument_list|(
name|body
argument_list|,
name|body_size
operator|+=
literal|3
operator|+
name|strlen
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|body
operator|+
name|body_index
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|body_index
operator|+=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|body
index|[
name|body_index
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|body
index|[
name|body_index
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
comment|/* Check that @end matched the macro command.  */
if|if
condition|(
operator|!
name|STREQ
argument_list|(
name|last_end
argument_list|,
name|mactype
argument_list|)
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"mismatched @end %s with @%s"
argument_list|)
argument_list|,
name|last_end
argument_list|,
name|mactype
argument_list|)
expr_stmt|;
comment|/* If it was an empty macro like      @macro foo      @end macro      create an empty body.  (Otherwise, the macro is not expanded.)  */
if|if
condition|(
operator|!
name|body
condition|)
block|{
name|body
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|body
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We now have the name, the arglist, and the body.  However, BODY      includes the final newline which preceded the `@end macro' text.      Delete it. */
if|if
condition|(
name|body
operator|&&
name|strlen
argument_list|(
name|body
argument_list|)
condition|)
name|body
index|[
name|strlen
argument_list|(
name|body
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|recursive
condition|)
name|flags
operator||=
name|ME_RECURSE
expr_stmt|;
name|add_macro
argument_list|(
name|name
argument_list|,
name|arglist
argument_list|,
name|body
argument_list|,
name|input_filename
argument_list|,
name|defining_line
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|macro_expansion_output_stream
operator|&&
operator|!
name|executing_string
condition|)
name|remember_itext
argument_list|(
name|input_text
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_macro
parameter_list|()
block|{
name|define_macro
argument_list|(
literal|"macro"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cm_rmacro
parameter_list|()
block|{
name|define_macro
argument_list|(
literal|"rmacro"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete the macro with name NAME.  The macro is deleted from the list,    but it is also returned.  If there was no macro defined, NULL is    returned. */
end_comment

begin_function
specifier|static
name|MACRO_DEF
modifier|*
name|delete_macro
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|MACRO_DEF
modifier|*
name|def
decl_stmt|;
name|def
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|macro_list
operator|&&
operator|(
name|def
operator|=
name|macro_list
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|def
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|memmove
argument_list|(
name|macro_list
operator|+
name|i
argument_list|,
name|macro_list
operator|+
name|i
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|macro_list_len
operator|+
literal|1
operator|)
operator|-
name|i
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|MACRO_DEF
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|macro_list_len
operator|--
expr_stmt|;
break|break;
block|}
return|return
name|def
return|;
block|}
end_function

begin_function
name|void
name|cm_unmacro
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|MACRO_DEF
modifier|*
name|def
decl_stmt|;
if|if
condition|(
name|macro_expansion_output_stream
operator|&&
operator|!
name|executing_string
condition|)
name|me_append_before_this_command
argument_list|()
expr_stmt|;
name|get_rest_of_line
argument_list|(
literal|0
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|line
index|[
name|i
index|]
operator|&&
operator|!
name|whitespace
argument_list|(
name|line
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|name
argument_list|,
name|line
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|name
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|def
operator|=
name|delete_macro
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
condition|)
block|{
name|free
argument_list|(
name|def
operator|->
name|source_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|def
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|def
operator|->
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|->
name|arglist
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|def
operator|->
name|arglist
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|def
operator|->
name|arglist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|def
operator|->
name|arglist
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|def
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|macro_expansion_output_stream
operator|&&
operator|!
name|executing_string
condition|)
name|remember_itext
argument_list|(
name|input_text
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* How to output sections of the input file verbatim. */
end_comment

begin_comment
comment|/* Set the value of POINTER's offset to OFFSET. */
end_comment

begin_function
name|ITEXT
modifier|*
name|remember_itext
parameter_list|(
name|pointer
parameter_list|,
name|offset
parameter_list|)
name|char
modifier|*
name|pointer
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|ITEXT
modifier|*
name|itext
init|=
name|NULL
decl_stmt|;
comment|/* If we have no info, initialize a blank list. */
if|if
condition|(
operator|!
name|itext_info
condition|)
block|{
name|itext_info
operator|=
name|xmalloc
argument_list|(
operator|(
name|itext_size
operator|=
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ITEXT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|itext_size
condition|;
name|i
operator|++
control|)
name|itext_info
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* If the pointer is already present in the list, then set the offset. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|itext_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|itext_info
index|[
name|i
index|]
operator|)
operator|&&
operator|(
name|itext_info
index|[
name|i
index|]
operator|->
name|pointer
operator|==
name|pointer
operator|)
condition|)
block|{
name|itext
operator|=
name|itext_info
index|[
name|i
index|]
expr_stmt|;
name|itext_info
index|[
name|i
index|]
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|itext_size
condition|)
block|{
comment|/* Find a blank slot (or create a new one), and remember the          pointer and offset. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|itext_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|itext_info
index|[
name|i
index|]
operator|==
name|NULL
condition|)
break|break;
comment|/* If not found, then add some slots. */
if|if
condition|(
name|i
operator|==
name|itext_size
condition|)
block|{
name|int
name|j
decl_stmt|;
name|itext_info
operator|=
name|xrealloc
argument_list|(
name|itext_info
argument_list|,
operator|(
name|itext_size
operator|+=
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|ITEXT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|itext_size
condition|;
name|j
operator|++
control|)
name|itext_info
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now add the pointer and the offset. */
name|itext_info
index|[
name|i
index|]
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ITEXT
argument_list|)
argument_list|)
expr_stmt|;
name|itext_info
index|[
name|i
index|]
operator|->
name|pointer
operator|=
name|pointer
expr_stmt|;
name|itext_info
index|[
name|i
index|]
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|itext
operator|=
name|itext_info
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|itext
return|;
block|}
end_function

begin_comment
comment|/* Forget the input text associated with POINTER. */
end_comment

begin_function
name|void
name|forget_itext
parameter_list|(
name|pointer
parameter_list|)
name|char
modifier|*
name|pointer
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|itext_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|itext_info
index|[
name|i
index|]
operator|&&
operator|(
name|itext_info
index|[
name|i
index|]
operator|->
name|pointer
operator|==
name|pointer
operator|)
condition|)
block|{
name|free
argument_list|(
name|itext_info
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|itext_info
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Append the text which appeared in input_text from the last offset to    the character just before the command that we are currently executing. */
end_comment

begin_function
name|void
name|me_append_before_this_command
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|input_text_offset
init|;
name|i
operator|&&
operator|(
name|input_text
index|[
name|i
index|]
operator|!=
name|COMMAND_PREFIX
operator|)
condition|;
name|i
operator|--
control|)
empty_stmt|;
name|maybe_write_itext
argument_list|(
name|input_text
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar to execute_string, but only takes a single string argument,    and remembers the input text location, etc. */
end_comment

begin_function
name|void
name|me_execute_string
parameter_list|(
name|execution_string
parameter_list|)
name|char
modifier|*
name|execution_string
decl_stmt|;
block|{
name|int
name|saved_escape_html
init|=
name|escape_html
decl_stmt|;
name|int
name|saved_in_paragraph
init|=
name|in_paragraph
decl_stmt|;
name|escape_html
operator|=
name|me_executing_string
operator|==
literal|0
expr_stmt|;
name|in_paragraph
operator|=
literal|0
expr_stmt|;
name|pushfile
argument_list|()
expr_stmt|;
name|input_text_offset
operator|=
literal|0
expr_stmt|;
comment|/* The following xstrdup is so we can relocate input_text at will.  */
name|input_text
operator|=
name|xstrdup
argument_list|(
name|execution_string
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|xstrdup
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|input_text_length
operator|=
name|strlen
argument_list|(
name|execution_string
argument_list|)
expr_stmt|;
name|remember_itext
argument_list|(
name|input_text
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|me_executing_string
operator|++
expr_stmt|;
name|reader_loop
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|input_text
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|popfile
argument_list|()
expr_stmt|;
name|me_executing_string
operator|--
expr_stmt|;
name|in_paragraph
operator|=
name|saved_in_paragraph
expr_stmt|;
name|escape_html
operator|=
name|saved_escape_html
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A wrapper around me_execute_string which saves and restores    variables important for output generation.  This is called    when we need to produce macro-expanded output for input which    leaves no traces in the Info output.  */
end_comment

begin_function
name|void
name|me_execute_string_keep_state
parameter_list|(
name|execution_string
parameter_list|,
name|append_string
parameter_list|)
name|char
modifier|*
name|execution_string
decl_stmt|,
decl|*
name|append_string
decl_stmt|;
end_function

begin_block
block|{
name|int
name|op_orig
decl_stmt|,
name|opcol_orig
decl_stmt|,
name|popen_orig
decl_stmt|;
name|int
name|fill_orig
decl_stmt|,
name|newline_orig
decl_stmt|,
name|indent_orig
decl_stmt|,
name|meta_pos_orig
decl_stmt|;
name|remember_itext
argument_list|(
name|input_text
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
name|op_orig
operator|=
name|output_paragraph_offset
expr_stmt|;
name|meta_pos_orig
operator|=
name|meta_char_pos
expr_stmt|;
name|opcol_orig
operator|=
name|output_column
expr_stmt|;
name|popen_orig
operator|=
name|paragraph_is_open
expr_stmt|;
name|fill_orig
operator|=
name|filling_enabled
expr_stmt|;
name|newline_orig
operator|=
name|last_char_was_newline
expr_stmt|;
name|filling_enabled
operator|=
literal|0
expr_stmt|;
name|indent_orig
operator|=
name|no_indent
expr_stmt|;
name|no_indent
operator|=
literal|1
expr_stmt|;
name|me_execute_string
argument_list|(
name|execution_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|append_string
condition|)
name|write_region_to_macro_output
argument_list|(
name|append_string
argument_list|,
literal|0
argument_list|,
name|strlen
argument_list|(
name|append_string
argument_list|)
argument_list|)
expr_stmt|;
name|output_paragraph_offset
operator|=
name|op_orig
expr_stmt|;
name|meta_char_pos
operator|=
name|meta_pos_orig
expr_stmt|;
name|output_column
operator|=
name|opcol_orig
expr_stmt|;
name|paragraph_is_open
operator|=
name|popen_orig
expr_stmt|;
name|filling_enabled
operator|=
name|fill_orig
expr_stmt|;
name|last_char_was_newline
operator|=
name|newline_orig
expr_stmt|;
name|no_indent
operator|=
name|indent_orig
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Append the text which appears in input_text from the last offset to    the current OFFSET. */
end_comment

begin_function
name|void
name|append_to_expansion_output
parameter_list|(
name|offset
parameter_list|)
name|int
name|offset
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|ITEXT
modifier|*
name|itext
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|itext_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|itext_info
index|[
name|i
index|]
operator|&&
name|itext_info
index|[
name|i
index|]
operator|->
name|pointer
operator|==
name|input_text
condition|)
block|{
name|itext
operator|=
name|itext_info
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|itext
condition|)
return|return;
if|if
condition|(
name|offset
operator|>
name|itext
operator|->
name|offset
condition|)
block|{
name|write_region_to_macro_output
argument_list|(
name|input_text
argument_list|,
name|itext
operator|->
name|offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|remember_itext
argument_list|(
name|input_text
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Only write this input text iff it appears in our itext list. */
end_comment

begin_function
name|void
name|maybe_write_itext
parameter_list|(
name|pointer
parameter_list|,
name|offset
parameter_list|)
name|char
modifier|*
name|pointer
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|ITEXT
modifier|*
name|itext
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|itext_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|itext_info
index|[
name|i
index|]
operator|&&
operator|(
name|itext_info
index|[
name|i
index|]
operator|->
name|pointer
operator|==
name|pointer
operator|)
condition|)
block|{
name|itext
operator|=
name|itext_info
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|itext
operator|&&
operator|(
name|itext
operator|->
name|offset
operator|<
name|offset
operator|)
condition|)
block|{
name|write_region_to_macro_output
argument_list|(
name|itext
operator|->
name|pointer
argument_list|,
name|itext
operator|->
name|offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|remember_itext
argument_list|(
name|pointer
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|write_region_to_macro_output
parameter_list|(
name|string
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
if|if
condition|(
name|macro_expansion_output_stream
condition|)
name|fwrite
argument_list|(
name|string
operator|+
name|start
argument_list|,
literal|1
argument_list|,
name|end
operator|-
name|start
argument_list|,
name|macro_expansion_output_stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Aliases. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|alias_struct
block|{
name|char
modifier|*
name|alias
decl_stmt|;
name|char
modifier|*
name|mapto
decl_stmt|;
name|struct
name|alias_struct
modifier|*
name|next
decl_stmt|;
block|}
name|alias_type
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|alias_type
modifier|*
name|aliases
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* @alias */
end_comment

begin_function
name|void
name|cm_alias
parameter_list|()
block|{
name|alias_type
modifier|*
name|a
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|alias_type
argument_list|)
argument_list|)
decl_stmt|;
name|skip_whitespace
argument_list|()
expr_stmt|;
name|get_until_in_line
argument_list|(
literal|1
argument_list|,
literal|"="
argument_list|,
operator|&
operator|(
name|a
operator|->
name|alias
operator|)
argument_list|)
expr_stmt|;
name|discard_until
argument_list|(
literal|"="
argument_list|)
expr_stmt|;
name|skip_whitespace
argument_list|()
expr_stmt|;
name|get_until_in_line
argument_list|(
literal|0
argument_list|,
literal|" "
argument_list|,
operator|&
operator|(
name|a
operator|->
name|mapto
operator|)
argument_list|)
expr_stmt|;
name|a
operator|->
name|next
operator|=
name|aliases
expr_stmt|;
name|aliases
operator|=
name|a
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform an alias expansion.  Called from read_command.  */
end_comment

begin_function
name|char
modifier|*
name|alias_expand
parameter_list|(
name|tok
parameter_list|)
name|char
modifier|*
name|tok
decl_stmt|;
block|{
name|alias_type
modifier|*
name|findit
init|=
name|aliases
decl_stmt|;
while|while
condition|(
name|findit
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|findit
operator|->
name|alias
argument_list|,
name|tok
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|tok
argument_list|)
expr_stmt|;
return|return
name|alias_expand
argument_list|(
name|xstrdup
argument_list|(
name|findit
operator|->
name|mapto
argument_list|)
argument_list|)
return|;
block|}
else|else
name|findit
operator|=
name|findit
operator|->
name|next
expr_stmt|;
return|return
name|tok
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* definfoenclose implementation.  */
end_comment

begin_comment
comment|/* This structure is used to track enclosure macros.  When an enclosure    macro is recognized, a pointer to the enclosure block corresponding     to its name is saved in the brace element for its argument. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|enclose_struct
block|{
name|char
modifier|*
name|enclose
decl_stmt|;
name|char
modifier|*
name|before
decl_stmt|;
name|char
modifier|*
name|after
decl_stmt|;
name|struct
name|enclose_struct
modifier|*
name|next
decl_stmt|;
block|}
name|enclosure_type
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|enclosure_type
modifier|*
name|enclosures
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|enclosure_stack_struct
block|{
name|enclosure_type
modifier|*
name|current
decl_stmt|;
name|struct
name|enclosure_stack_struct
modifier|*
name|next
decl_stmt|;
block|}
name|enclosure_stack_type
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|enclosure_stack_type
modifier|*
name|enclosure_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* @definfoenclose */
end_comment

begin_function
name|void
name|cm_definfoenclose
parameter_list|()
block|{
name|enclosure_type
modifier|*
name|e
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|enclosure_type
argument_list|)
argument_list|)
decl_stmt|;
name|skip_whitespace
argument_list|()
expr_stmt|;
name|get_until_in_line
argument_list|(
literal|1
argument_list|,
literal|","
argument_list|,
operator|&
operator|(
name|e
operator|->
name|enclose
operator|)
argument_list|)
expr_stmt|;
name|discard_until
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|get_until_in_line
argument_list|(
literal|0
argument_list|,
literal|","
argument_list|,
operator|&
operator|(
name|e
operator|->
name|before
operator|)
argument_list|)
expr_stmt|;
name|discard_until
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|get_until_in_line
argument_list|(
literal|0
argument_list|,
literal|"\n"
argument_list|,
operator|&
operator|(
name|e
operator|->
name|after
operator|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|next
operator|=
name|enclosures
expr_stmt|;
name|enclosures
operator|=
name|e
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If TOK is an enclosure command, push it on the enclosure stack and    return 1.  Else return 0.  */
end_comment

begin_function
name|int
name|enclosure_command
parameter_list|(
name|tok
parameter_list|)
name|char
modifier|*
name|tok
decl_stmt|;
block|{
name|enclosure_type
modifier|*
name|findit
init|=
name|enclosures
decl_stmt|;
while|while
condition|(
name|findit
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|findit
operator|->
name|enclose
argument_list|,
name|tok
argument_list|)
operator|==
literal|0
condition|)
block|{
name|enclosure_stack_type
modifier|*
name|new
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|enclosure_stack_type
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|current
operator|=
name|findit
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|enclosure_stack
expr_stmt|;
name|enclosure_stack
operator|=
name|new
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|findit
operator|=
name|findit
operator|->
name|next
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* actually perform the enclosure expansion */
end_comment

begin_function
name|void
name|enclosure_expand
parameter_list|(
name|arg
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|int
name|arg
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_word
argument_list|(
name|enclosure_stack
operator|->
name|current
operator|->
name|before
argument_list|)
expr_stmt|;
else|else
block|{
name|enclosure_stack_type
modifier|*
name|temp
decl_stmt|;
name|add_word
argument_list|(
name|enclosure_stack
operator|->
name|current
operator|->
name|after
argument_list|)
expr_stmt|;
name|temp
operator|=
name|enclosure_stack
expr_stmt|;
name|enclosure_stack
operator|=
name|enclosure_stack
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

