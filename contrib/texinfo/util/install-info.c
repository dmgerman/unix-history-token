begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* install-info -- create Info directory entry(ies) for an Info file.    $Id: install-info.c,v 1.21 1998/03/01 15:38:45 karl Exp $     Copyright (C) 1996, 97, 98 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.*/
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIBZ
end_ifdef

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Name this program was invoked with.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|readfile
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|line_data
modifier|*
name|findlines
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fatal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|insert_entry_here
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|compare_section_names
parameter_list|()
function_decl|;
end_function_decl

begin_struct_decl
struct_decl|struct
name|spec_entry
struct_decl|;
end_struct_decl

begin_escape
end_escape

begin_comment
comment|/* Data structures.  */
end_comment

begin_comment
comment|/* Record info about a single line from a file as read into core.  */
end_comment

begin_struct
struct|struct
name|line_data
block|{
comment|/* The start of the line.  */
name|char
modifier|*
name|start
decl_stmt|;
comment|/* The number of characters in the line,      excluding the terminating newline.  */
name|int
name|size
decl_stmt|;
comment|/* Vector containing pointers to the entries to add before this line.      The vector is null-terminated.  */
name|struct
name|spec_entry
modifier|*
modifier|*
name|add_entries_before
decl_stmt|;
comment|/* 1 means output any needed new sections before this line.  */
name|int
name|add_sections_before
decl_stmt|;
comment|/* 1 means don't output this line.  */
name|int
name|delete
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is used for a list of the specified menu section names    in which entries should be added.  */
end_comment

begin_struct
struct|struct
name|spec_section
block|{
name|struct
name|spec_section
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* 1 means we have not yet found an existing section with this name      in the dir file--so we will need to add a new section.  */
name|int
name|missing
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is used for a list of the entries specified to be added.  */
end_comment

begin_struct
struct|struct
name|spec_entry
block|{
name|struct
name|spec_entry
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is used for a list of nodes found by parsing the dir file.  */
end_comment

begin_struct
struct|struct
name|node
block|{
name|struct
name|node
modifier|*
name|next
decl_stmt|;
comment|/* The node name.  */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The line number of the line where the node starts.      This is the line that contains control-underscore.  */
name|int
name|start_line
decl_stmt|;
comment|/* The line number of the line where the node ends,      which is the end of the file or where the next line starts.  */
name|int
name|end_line
decl_stmt|;
comment|/* Start of first line in this node's menu      (the line after the * Menu: line).  */
name|char
modifier|*
name|menu_start
decl_stmt|;
comment|/* The start of the chain of sections in this node's menu.  */
name|struct
name|menu_section
modifier|*
name|sections
decl_stmt|;
comment|/* The last menu section in the chain.  */
name|struct
name|menu_section
modifier|*
name|last_section
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is used for a list of sections found in a node's menu.    Each  struct node  has such a list in the  sections  field.  */
end_comment

begin_struct
struct|struct
name|menu_section
block|{
name|struct
name|menu_section
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Line number of start of section.  */
name|int
name|start_line
decl_stmt|;
comment|/* Line number of end of section.  */
name|int
name|end_line
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Memory allocation and string operations.  */
end_comment

begin_comment
comment|/* Like malloc but get fatal error if memory is exhausted.  */
end_comment

begin_function
name|void
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|int
name|size
decl_stmt|;
block|{
specifier|extern
name|void
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|void
modifier|*
name|result
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Like realloc but get fatal error if memory is exhausted.  */
end_comment

begin_function
name|void
modifier|*
name|xrealloc
parameter_list|(
name|obj
parameter_list|,
name|size
parameter_list|)
name|void
modifier|*
name|obj
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
specifier|extern
name|void
modifier|*
name|realloc
parameter_list|()
function_decl|;
name|void
modifier|*
name|result
init|=
name|realloc
argument_list|(
name|obj
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return a newly-allocated string    whose contents concatenate those of S1, S2, S3.  */
end_comment

begin_function
name|char
modifier|*
name|concat
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
end_function

begin_block
block|{
name|int
name|len1
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
decl_stmt|,
name|len2
init|=
name|strlen
argument_list|(
name|s2
argument_list|)
decl_stmt|,
name|len3
init|=
name|strlen
argument_list|(
name|s3
argument_list|)
decl_stmt|;
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len1
operator|+
name|len2
operator|+
name|len3
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
operator|+
name|len2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
operator|*
operator|(
name|result
operator|+
name|len1
operator|+
name|len2
operator|+
name|len3
operator|)
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/* Return a string containing SIZE characters    copied from starting at STRING.  */
end_comment

begin_function
name|char
modifier|*
name|copy_string
parameter_list|(
name|string
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|copy
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|copy
index|[
name|i
index|]
operator|=
name|string
index|[
name|i
index|]
expr_stmt|;
name|copy
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Error message functions.  */
end_comment

begin_comment
comment|/* Print error message.  S1 is printf control string, S2 and S3 args for it. */
end_comment

begin_comment
comment|/* VARARGS1 */
end_comment

begin_function
name|void
name|error
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
end_function

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* VARARGS1 */
end_comment

begin_function
name|void
name|warning
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
end_function

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: warning: "
argument_list|)
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Print error message and exit.  */
end_comment

begin_function
name|void
name|fatal
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
end_function

begin_block
block|{
name|error
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Print fatal error message based on errno, with file name NAME.  */
end_comment

begin_function
name|void
name|pfatal_with_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|s
init|=
name|concat
argument_list|(
literal|""
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|_
argument_list|(
literal|" for %s"
argument_list|)
argument_list|)
decl_stmt|;
name|fatal
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given the full text of a menu entry, null terminated,    return just the menu item name (copied).  */
end_comment

begin_function
name|char
modifier|*
name|extract_menu_item_name
parameter_list|(
name|item_text
parameter_list|)
name|char
modifier|*
name|item_text
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|item_text
operator|==
literal|'*'
condition|)
name|item_text
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|item_text
operator|==
literal|' '
condition|)
name|item_text
operator|++
expr_stmt|;
name|p
operator|=
name|item_text
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
return|return
name|copy_string
argument_list|(
name|item_text
argument_list|,
name|p
operator|-
name|item_text
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given the full text of a menu entry, terminated by null or newline,    return just the menu item file (copied).  */
end_comment

begin_function
name|char
modifier|*
name|extract_menu_file_name
parameter_list|(
name|item_text
parameter_list|)
name|char
modifier|*
name|item_text
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|item_text
decl_stmt|;
comment|/* If we have text that looks like * ITEM: (FILE)NODE...,      extract just FILE.  Otherwise return "(none)".  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Skip to and past the colon.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Skip past the open-paren.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
break|break;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
else|else
return|return
literal|"(none)"
return|;
block|}
name|p
operator|++
expr_stmt|;
name|item_text
operator|=
name|p
expr_stmt|;
comment|/* File name ends just before the close-paren.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
operator|!=
literal|')'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|')'
condition|)
return|return
literal|"(none)"
return|;
return|return
name|copy_string
argument_list|(
name|item_text
argument_list|,
name|p
operator|-
name|item_text
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|suggest_asking_for_help
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"\tTry `%s --help' for a complete list of options.\n"
argument_list|)
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_help
parameter_list|()
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Usage: %s [OPTION]... [INFO-FILE [DIR-FILE]]\n\ \n\ Install INFO-FILE in the Info directory file DIR-FILE.\n\ \n\ Options:\n\ --delete          Delete existing entries in INFO-FILE;\n\                     don't insert any new entries.\n\ --defentry=TEXT   Like --entry, but only use TEXT if an entry\n\                     is not present in INFO-FILE.\n\ --defsection=TEXT Like --section, but only use TEXT if a section\n\                     is not present in INFO-FILE.\n\ --dir-file=NAME   Specify file name of Info directory file.\n\                     This is equivalent to using the DIR-FILE argument.\n\ --entry=TEXT      Insert TEXT as an Info directory entry.\n\                     TEXT should have the form of an Info menu item line\n\                     plus zero or more extra lines starting with whitespace.\n\                     If you specify more than one entry, they are all added.\n\                     If you don't specify any entries, they are determined\n\                     from information in the Info file itself.\n\ --forceentry=TEXT Like --entry, but ignore any entry in INFO-FILE.\n\ --help            Display this help and exit.\n\ --info-file=FILE  Specify Info file to install in the directory.\n\                     This is equivalent to using the INFO-FILE argument.\n\ --info-dir=DIR    Same as --dir-file=DIR/dir.\n\ --item=TEXT       Same as --entry TEXT.\n\                     An Info directory entry is actually a menu item.\n\ --quiet           Suppress warnings.\n\ --remove          Same as --delete.\n\ --section=SEC     Put this file's entries in section SEC of the directory.\n\                     If you specify more than one section, all the entries\n\                     are added in each of the sections.\n\                     If you don't specify any sections, they are determined\n\                     from information in the Info file itself.\n\ --version         Display version information and exit.\n\ \n\ Email bug reports to bug-texinfo@gnu.org.\n\ "
argument_list|)
argument_list|,
name|progname
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If DIRFILE does not exist, create a minimal one (or abort).  If it    already exists, do nothing.  */
end_comment

begin_function
name|void
name|ensure_dirfile_exists
parameter_list|(
name|dirfile
parameter_list|)
name|char
modifier|*
name|dirfile
decl_stmt|;
block|{
name|int
name|desc
init|=
name|open
argument_list|(
name|dirfile
argument_list|,
name|O_RDONLY
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|readerr
init|=
name|strerror
argument_list|(
name|errno
argument_list|)
decl_stmt|;
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|dirfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|fputs
argument_list|(
name|_
argument_list|(
literal|"This is the file .../info/dir, which contains the\n\ topmost node of the Info hierarchy, called (dir)Top.\n\ The first time you invoke Info you start off looking at this node.\n\
literal|\n\ File: dir,\tNode: Top,\tThis is the top of the INFO tree\n\ \n\   This (the Directory node) gives a menu of major topics.\n\   Typing \"q\" exits, \"?\" lists all Info commands, \"d\" returns here,\n\   \"h\" gives a primer for first-timers,\n\   \"mEmacs<Return>\" visits the Emacs manual, etc.\n\ \n\   In Emacs, you can click mouse button 2 on a menu item or cross reference\n\   to select it.\n\ \n\ * Menu:\n\ "
argument_list|)
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dirfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Didn't exist, but couldn't open for writing.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: could not read (%s) and could not create (%s)\n"
argument_list|)
argument_list|,
name|dirfile
argument_list|,
name|readerr
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
comment|/* It already existed, so fine.  */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This table defines all the long-named options, says whether they    use an argument, and maps them into equivalent single-letter options.  */
end_comment

begin_decl_stmt
name|struct
name|option
name|longopts
index|[]
init|=
block|{
block|{
literal|"delete"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'r'
block|}
block|,
block|{
literal|"defentry"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'E'
block|}
block|,
block|{
literal|"defsection"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'S'
block|}
block|,
block|{
literal|"dir-file"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
block|{
literal|"entry"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'e'
block|}
block|,
block|{
literal|"forceentry"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'f'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"info-dir"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'D'
block|}
block|,
block|{
literal|"info-file"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'i'
block|}
block|,
block|{
literal|"item"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'e'
block|}
block|,
block|{
literal|"quiet"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'q'
block|}
block|,
block|{
literal|"remove"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'r'
block|}
block|,
block|{
literal|"section"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'V'
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|infile
init|=
literal|0
decl_stmt|,
modifier|*
name|dirfile
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|infile_sans_info
decl_stmt|;
name|unsigned
name|infilelen_sans_info
decl_stmt|;
name|FILE
modifier|*
name|output
decl_stmt|;
comment|/* Record the text of the Info file, as a sequence of characters      and as a sequence of lines.  */
name|char
modifier|*
name|input_data
decl_stmt|;
name|int
name|input_size
decl_stmt|;
name|struct
name|line_data
modifier|*
name|input_lines
decl_stmt|;
name|int
name|input_nlines
decl_stmt|;
comment|/* Record here the specified section names and directory entries.  */
name|struct
name|spec_section
modifier|*
name|input_sections
init|=
name|NULL
decl_stmt|;
name|struct
name|spec_entry
modifier|*
name|entries_to_add
init|=
name|NULL
decl_stmt|;
name|int
name|n_entries_to_add
init|=
literal|0
decl_stmt|;
comment|/* Record the old text of the dir file, as plain characters,      as lines, and as nodes.  */
name|char
modifier|*
name|dir_data
decl_stmt|;
name|int
name|dir_size
decl_stmt|;
name|int
name|dir_nlines
decl_stmt|;
name|struct
name|line_data
modifier|*
name|dir_lines
decl_stmt|;
name|struct
name|node
modifier|*
name|dir_nodes
decl_stmt|;
comment|/* Nonzero means --delete was specified (just delete existing entries).  */
name|int
name|delete_flag
init|=
literal|0
decl_stmt|;
name|int
name|something_deleted
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means -q was specified.  */
name|int
name|quiet_flag
init|=
literal|0
decl_stmt|;
name|int
name|node_header_flag
decl_stmt|;
name|int
name|prefix_length
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Nonzero means only use if not present in info file. */
name|int
name|entry_default
init|=
literal|0
decl_stmt|;
name|int
name|entry_force
init|=
literal|0
decl_stmt|;
name|int
name|section_default
init|=
literal|0
decl_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SETLOCALE
comment|/* Set locale via LC_ALL.  */
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set the text message domain.  */
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|opt
init|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"i:d:e:s:hHr"
argument_list|,
name|longopts
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|opt
operator|==
name|EOF
condition|)
break|break;
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|0
case|:
comment|/* If getopt returns 0, then it has already processed a              long-named option.  We should do nothing.  */
break|break;
case|case
literal|1
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
literal|'d'
case|:
if|if
condition|(
name|dirfile
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: Specify the Info directory only once.\n"
argument_list|)
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|suggest_asking_for_help
argument_list|()
expr_stmt|;
block|}
name|dirfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|dirfile
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: Specify the Info directory only once.\n"
argument_list|)
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|suggest_asking_for_help
argument_list|()
expr_stmt|;
block|}
name|dirfile
operator|=
name|concat
argument_list|(
name|optarg
argument_list|,
literal|""
argument_list|,
literal|"/dir"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|entry_force
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|optarg
index|[
literal|0
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Must provide entry name.\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|suggest_asking_for_help
argument_list|()
expr_stmt|;
block|}
case|case
literal|'E'
case|:
name|entry_default
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|optarg
index|[
literal|0
index|]
condition|)
break|break;
case|case
literal|'e'
case|:
block|{
name|struct
name|spec_entry
modifier|*
name|next
init|=
operator|(
expr|struct
name|spec_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|spec_entry
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|optarg
operator|!=
literal|0
operator|&&
name|optarg
index|[
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
name|optarg
operator|=
name|concat
argument_list|(
name|optarg
argument_list|,
literal|"\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|next
operator|->
name|text
operator|=
name|optarg
expr_stmt|;
name|next
operator|->
name|next
operator|=
name|entries_to_add
expr_stmt|;
name|entries_to_add
operator|=
name|next
expr_stmt|;
name|n_entries_to_add
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
name|print_help
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'i'
case|:
if|if
condition|(
name|infile
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: Specify the Info file only once.\n"
argument_list|)
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|suggest_asking_for_help
argument_list|()
expr_stmt|;
block|}
name|infile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|delete_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|section_default
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|optarg
index|[
literal|0
index|]
condition|)
break|break;
case|case
literal|'s'
case|:
block|{
name|struct
name|spec_section
modifier|*
name|next
init|=
operator|(
expr|struct
name|spec_section
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|spec_section
argument_list|)
argument_list|)
decl_stmt|;
name|next
operator|->
name|name
operator|=
name|optarg
expr_stmt|;
name|next
operator|->
name|next
operator|=
name|input_sections
expr_stmt|;
name|next
operator|->
name|missing
operator|=
literal|1
expr_stmt|;
name|input_sections
operator|=
name|next
expr_stmt|;
block|}
break|break;
case|case
literal|'V'
case|:
name|printf
argument_list|(
literal|"install-info (GNU %s) %s\n"
argument_list|,
name|PACKAGE
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Copyright (C) %s Free Software Foundation, Inc.\n\ There is NO warranty.  You may redistribute this software\n\ under the terms of the GNU General Public License.\n\ For more information about these matters, see the files named COPYING.\n"
argument_list|)
argument_list|,
literal|"1998"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
default|default:
name|suggest_asking_for_help
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|entry_force
condition|)
name|entry_default
operator|=
literal|0
expr_stmt|;
comment|/* Interpret the non-option arguments as file names.  */
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
operator|++
name|optind
control|)
block|{
if|if
condition|(
name|infile
operator|==
literal|0
condition|)
name|infile
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|dirfile
operator|==
literal|0
condition|)
name|dirfile
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
else|else
name|error
argument_list|(
name|_
argument_list|(
literal|"excess command line argument `%s'"
argument_list|)
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|infile
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"No input file specified; try --help for more information."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dirfile
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"No dir file specified; try --help for more information."
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the Info file and parse it into lines.  */
name|input_data
operator|=
name|readfile
argument_list|(
name|infile
argument_list|,
operator|&
name|input_size
argument_list|)
expr_stmt|;
name|input_lines
operator|=
name|findlines
argument_list|(
name|input_data
argument_list|,
name|input_size
argument_list|,
operator|&
name|input_nlines
argument_list|)
expr_stmt|;
comment|/* Parse the input file to find the section names it specifies.  */
if|if
condition|(
name|input_sections
operator|==
literal|0
operator|||
name|section_default
condition|)
block|{
name|prefix_length
operator|=
name|strlen
argument_list|(
literal|"INFO-DIR-SECTION "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|input_nlines
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
literal|"INFO-DIR-SECTION "
argument_list|,
name|input_lines
index|[
name|i
index|]
operator|.
name|start
argument_list|,
name|prefix_length
argument_list|)
condition|)
block|{
name|struct
name|spec_section
modifier|*
name|next
init|=
operator|(
expr|struct
name|spec_section
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|spec_section
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|section_default
condition|)
block|{
name|input_sections
operator|=
name|NULL
expr_stmt|;
comment|/* This leaks. */
name|section_default
operator|=
literal|0
expr_stmt|;
block|}
name|next
operator|->
name|name
operator|=
name|copy_string
argument_list|(
name|input_lines
index|[
name|i
index|]
operator|.
name|start
operator|+
name|prefix_length
argument_list|,
name|input_lines
index|[
name|i
index|]
operator|.
name|size
operator|-
name|prefix_length
argument_list|)
expr_stmt|;
name|next
operator|->
name|next
operator|=
name|input_sections
expr_stmt|;
name|next
operator|->
name|missing
operator|=
literal|1
expr_stmt|;
name|input_sections
operator|=
name|next
expr_stmt|;
block|}
block|}
block|}
comment|/* Default to section "Miscellaneous" if no sections specified.  */
if|if
condition|(
name|input_sections
operator|==
literal|0
condition|)
block|{
name|input_sections
operator|=
operator|(
expr|struct
name|spec_section
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|spec_section
argument_list|)
argument_list|)
expr_stmt|;
name|input_sections
operator|->
name|name
operator|=
literal|"Miscellaneous"
expr_stmt|;
name|input_sections
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|input_sections
operator|->
name|missing
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Now find the directory entries specified in the file      and put them on entries_to_add.  But not if entries      were specified explicitly with command options.  */
if|if
condition|(
operator|!
name|entry_force
operator|&&
operator|(
name|entries_to_add
operator|==
literal|0
operator|||
name|entry_default
operator|)
condition|)
block|{
name|char
modifier|*
name|start_of_this_entry
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|input_nlines
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
literal|"START-INFO-DIR-ENTRY"
argument_list|,
name|input_lines
index|[
name|i
index|]
operator|.
name|start
argument_list|,
name|input_lines
index|[
name|i
index|]
operator|.
name|size
argument_list|)
operator|&&
sizeof|sizeof
argument_list|(
literal|"START-INFO-DIR-ENTRY"
argument_list|)
operator|-
literal|1
operator|==
name|input_lines
index|[
name|i
index|]
operator|.
name|size
condition|)
block|{
if|if
condition|(
name|start_of_this_entry
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"START-INFO-DIR-ENTRY without matching END-INFO-DIR-ENTRY"
argument_list|)
argument_list|)
expr_stmt|;
name|start_of_this_entry
operator|=
name|input_lines
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|start
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
literal|"END-INFO-DIR-ENTRY"
argument_list|,
name|input_lines
index|[
name|i
index|]
operator|.
name|start
argument_list|,
name|input_lines
index|[
name|i
index|]
operator|.
name|size
argument_list|)
operator|&&
sizeof|sizeof
argument_list|(
literal|"END-INFO-DIR-ENTRY"
argument_list|)
operator|-
literal|1
operator|==
name|input_lines
index|[
name|i
index|]
operator|.
name|size
condition|)
block|{
if|if
condition|(
name|start_of_this_entry
operator|!=
literal|0
condition|)
block|{
name|struct
name|spec_entry
modifier|*
name|next
init|=
operator|(
expr|struct
name|spec_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|spec_entry
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry_default
condition|)
block|{
name|entries_to_add
operator|=
name|NULL
expr_stmt|;
name|entry_default
operator|=
literal|0
expr_stmt|;
block|}
name|next
operator|->
name|text
operator|=
name|copy_string
argument_list|(
name|start_of_this_entry
argument_list|,
name|input_lines
index|[
name|i
index|]
operator|.
name|start
operator|-
name|start_of_this_entry
argument_list|)
expr_stmt|;
name|next
operator|->
name|next
operator|=
name|entries_to_add
expr_stmt|;
name|entries_to_add
operator|=
name|next
expr_stmt|;
name|n_entries_to_add
operator|++
expr_stmt|;
name|start_of_this_entry
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|fatal
argument_list|(
name|_
argument_list|(
literal|"END-INFO-DIR-ENTRY without matching START-INFO-DIR-ENTRY"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|start_of_this_entry
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"START-INFO-DIR-ENTRY without matching END-INFO-DIR-ENTRY"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|delete_flag
condition|)
if|if
condition|(
name|entries_to_add
operator|==
literal|0
condition|)
block|{
comment|/* No need to abort here, the original info file may not have            the requisite Texinfo commands.  This is not something an            installer should have to correct (it's a problem for the            maintainer), and there's no need to cause subsequent parts of            `make install' to fail.  */
name|warning
argument_list|(
name|_
argument_list|(
literal|"no info dir entry in `%s'"
argument_list|)
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Now read in the Info dir file.  */
name|ensure_dirfile_exists
argument_list|(
name|dirfile
argument_list|)
expr_stmt|;
name|dir_data
operator|=
name|readfile
argument_list|(
name|dirfile
argument_list|,
operator|&
name|dir_size
argument_list|)
expr_stmt|;
name|dir_lines
operator|=
name|findlines
argument_list|(
name|dir_data
argument_list|,
name|dir_size
argument_list|,
operator|&
name|dir_nlines
argument_list|)
expr_stmt|;
comment|/* We will be comparing the entries in the dir file against the      current filename, so need to strip off any directory prefix and any      .info suffix.  */
block|{
name|unsigned
name|basename_len
decl_stmt|;
name|char
modifier|*
name|infile_basename
init|=
name|strrchr
argument_list|(
name|infile
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|infile_basename
condition|)
name|infile_basename
operator|++
expr_stmt|;
else|else
name|infile_basename
operator|=
name|infile
expr_stmt|;
name|basename_len
operator|=
name|strlen
argument_list|(
name|infile_basename
argument_list|)
expr_stmt|;
name|infile_sans_info
operator|=
operator|(
name|strlen
argument_list|(
name|infile_basename
argument_list|)
operator|>
literal|5
operator|&&
name|strcmp
argument_list|(
name|infile_basename
operator|+
name|basename_len
operator|-
literal|5
argument_list|,
literal|".info"
argument_list|)
operator|==
literal|0
operator|)
condition|?
name|copy_string
argument_list|(
name|infile_basename
argument_list|,
name|basename_len
operator|-
literal|5
argument_list|)
else|:
name|infile_basename
expr_stmt|;
name|infilelen_sans_info
operator|=
name|strlen
argument_list|(
name|infile_sans_info
argument_list|)
expr_stmt|;
block|}
comment|/* Parse the dir file.  Find all the nodes, and their menus,      and the sections of their menus.  */
name|dir_nodes
operator|=
literal|0
expr_stmt|;
name|node_header_flag
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dir_nlines
condition|;
name|i
operator|++
control|)
block|{
comment|/* Parse node header lines.  */
if|if
condition|(
name|node_header_flag
condition|)
block|{
name|int
name|j
decl_stmt|,
name|end
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|dir_lines
index|[
name|i
index|]
operator|.
name|size
condition|;
name|j
operator|++
control|)
comment|/* Find the node name and store it in the `struct node'.  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
literal|"Node:"
argument_list|,
name|dir_lines
index|[
name|i
index|]
operator|.
name|start
operator|+
name|j
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|char
modifier|*
name|line
init|=
name|dir_lines
index|[
name|i
index|]
operator|.
name|start
decl_stmt|;
comment|/* Find the start of the node name.  */
name|j
operator|+=
literal|5
expr_stmt|;
while|while
condition|(
name|line
index|[
name|j
index|]
operator|==
literal|' '
operator|||
name|line
index|[
name|j
index|]
operator|==
literal|'\t'
condition|)
name|j
operator|++
expr_stmt|;
comment|/* Find the end of the node name.  */
name|end
operator|=
name|j
expr_stmt|;
while|while
condition|(
name|line
index|[
name|end
index|]
operator|!=
literal|0
operator|&&
name|line
index|[
name|end
index|]
operator|!=
literal|','
operator|&&
name|line
index|[
name|end
index|]
operator|!=
literal|'\n'
operator|&&
name|line
index|[
name|end
index|]
operator|!=
literal|'\t'
condition|)
name|end
operator|++
expr_stmt|;
name|dir_nodes
operator|->
name|name
operator|=
name|copy_string
argument_list|(
name|line
operator|+
name|j
argument_list|,
name|end
operator|-
name|j
argument_list|)
expr_stmt|;
block|}
name|node_header_flag
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Notice the start of a node.  */
if|if
condition|(
operator|*
name|dir_lines
index|[
name|i
index|]
operator|.
name|start
operator|==
literal|037
condition|)
block|{
name|struct
name|node
modifier|*
name|next
init|=
operator|(
expr|struct
name|node
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|node
argument_list|)
argument_list|)
decl_stmt|;
name|next
operator|->
name|next
operator|=
name|dir_nodes
expr_stmt|;
name|next
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|next
operator|->
name|start_line
operator|=
name|i
expr_stmt|;
name|next
operator|->
name|end_line
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|menu_start
operator|=
name|NULL
expr_stmt|;
name|next
operator|->
name|sections
operator|=
name|NULL
expr_stmt|;
name|next
operator|->
name|last_section
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dir_nodes
operator|!=
literal|0
condition|)
name|dir_nodes
operator|->
name|end_line
operator|=
name|i
expr_stmt|;
comment|/* Fill in the end of the last menu section              of the previous node.  */
if|if
condition|(
name|dir_nodes
operator|!=
literal|0
operator|&&
name|dir_nodes
operator|->
name|last_section
operator|!=
literal|0
condition|)
name|dir_nodes
operator|->
name|last_section
operator|->
name|end_line
operator|=
name|i
expr_stmt|;
name|dir_nodes
operator|=
name|next
expr_stmt|;
comment|/* The following line is the header of this node;              parse it.  */
name|node_header_flag
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Notice the lines that start menus.  */
if|if
condition|(
name|dir_nodes
operator|!=
literal|0
operator|&&
operator|!
name|strncmp
argument_list|(
literal|"* Menu:"
argument_list|,
name|dir_lines
index|[
name|i
index|]
operator|.
name|start
argument_list|,
literal|7
argument_list|)
condition|)
name|dir_nodes
operator|->
name|menu_start
operator|=
name|dir_lines
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|start
expr_stmt|;
comment|/* Notice sections in menus.  */
if|if
condition|(
name|dir_nodes
operator|!=
literal|0
operator|&&
name|dir_nodes
operator|->
name|menu_start
operator|!=
literal|0
operator|&&
operator|*
name|dir_lines
index|[
name|i
index|]
operator|.
name|start
operator|!=
literal|'\n'
operator|&&
operator|*
name|dir_lines
index|[
name|i
index|]
operator|.
name|start
operator|!=
literal|'*'
operator|&&
operator|*
name|dir_lines
index|[
name|i
index|]
operator|.
name|start
operator|!=
literal|' '
operator|&&
operator|*
name|dir_lines
index|[
name|i
index|]
operator|.
name|start
operator|!=
literal|'\t'
condition|)
block|{
comment|/* Add this menu section to the node's list.              This list grows in forward order.  */
name|struct
name|menu_section
modifier|*
name|next
init|=
operator|(
expr|struct
name|menu_section
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|menu_section
argument_list|)
argument_list|)
decl_stmt|;
name|next
operator|->
name|start_line
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|next
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|end_line
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|name
operator|=
name|copy_string
argument_list|(
name|dir_lines
index|[
name|i
index|]
operator|.
name|start
argument_list|,
name|dir_lines
index|[
name|i
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir_nodes
operator|->
name|sections
condition|)
block|{
name|dir_nodes
operator|->
name|last_section
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|dir_nodes
operator|->
name|last_section
operator|->
name|end_line
operator|=
name|i
expr_stmt|;
block|}
else|else
name|dir_nodes
operator|->
name|sections
operator|=
name|next
expr_stmt|;
name|dir_nodes
operator|->
name|last_section
operator|=
name|next
expr_stmt|;
block|}
comment|/* Check for an existing entry that should be deleted.          Delete all entries which specify this file name.  */
if|if
condition|(
operator|*
name|dir_lines
index|[
name|i
index|]
operator|.
name|start
operator|==
literal|'*'
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|dir_lines
index|[
name|i
index|]
operator|.
name|start
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|0
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|dir_lines
index|[
name|i
index|]
operator|.
name|size
operator|>
operator|(
name|p
operator|-
name|dir_lines
index|[
name|i
index|]
operator|.
name|start
operator|+
name|infilelen_sans_info
operator|)
operator|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
name|infile_sans_info
argument_list|,
name|infilelen_sans_info
argument_list|)
operator|&&
operator|(
name|p
index|[
name|infilelen_sans_info
index|]
operator|==
literal|')'
operator|||
operator|!
name|strncmp
argument_list|(
name|p
operator|+
name|infilelen_sans_info
argument_list|,
literal|".info)"
argument_list|,
literal|6
argument_list|)
operator|)
condition|)
block|{
name|dir_lines
index|[
name|i
index|]
operator|.
name|delete
operator|=
literal|1
expr_stmt|;
name|something_deleted
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Treat lines that start with whitespace          as continuations; if we are deleting an entry,          delete all its continuations as well.  */
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
operator|(
operator|*
name|dir_lines
index|[
name|i
index|]
operator|.
name|start
operator|==
literal|' '
operator|||
operator|*
name|dir_lines
index|[
name|i
index|]
operator|.
name|start
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|dir_lines
index|[
name|i
index|]
operator|.
name|delete
operator|=
name|dir_lines
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|delete
expr_stmt|;
name|something_deleted
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Finish the info about the end of the last node.  */
if|if
condition|(
name|dir_nodes
operator|!=
literal|0
condition|)
block|{
name|dir_nodes
operator|->
name|end_line
operator|=
name|dir_nlines
expr_stmt|;
if|if
condition|(
name|dir_nodes
operator|->
name|last_section
operator|!=
literal|0
condition|)
name|dir_nodes
operator|->
name|last_section
operator|->
name|end_line
operator|=
name|dir_nlines
expr_stmt|;
block|}
comment|/* Decide where to add the new entries (unless --delete was used).      Find the menu sections to add them in.      In each section, find the proper alphabetical place to add      each of the entries.  */
if|if
condition|(
operator|!
name|delete_flag
condition|)
block|{
name|struct
name|node
modifier|*
name|node
decl_stmt|;
name|struct
name|menu_section
modifier|*
name|section
decl_stmt|;
name|struct
name|spec_section
modifier|*
name|spec
decl_stmt|;
for|for
control|(
name|node
operator|=
name|dir_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
for|for
control|(
name|section
operator|=
name|node
operator|->
name|sections
init|;
name|section
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
name|section
operator|->
name|end_line
init|;
name|i
operator|>
name|section
operator|->
name|start_line
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|dir_lines
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|size
operator|!=
literal|0
condition|)
break|break;
name|section
operator|->
name|end_line
operator|=
name|i
expr_stmt|;
for|for
control|(
name|spec
operator|=
name|input_sections
init|;
name|spec
condition|;
name|spec
operator|=
name|spec
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|spec
operator|->
name|name
argument_list|,
name|section
operator|->
name|name
argument_list|)
condition|)
break|break;
if|if
condition|(
name|spec
condition|)
block|{
name|int
name|add_at_line
init|=
name|section
operator|->
name|end_line
decl_stmt|;
name|struct
name|spec_entry
modifier|*
name|entry
decl_stmt|;
comment|/* Say we have found at least one section with this name,                    so we need not add such a section.  */
name|spec
operator|->
name|missing
operator|=
literal|0
expr_stmt|;
comment|/* For each entry, find the right place in this section                    to add it.  */
for|for
control|(
name|entry
operator|=
name|entries_to_add
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
block|{
name|int
name|textlen
init|=
name|strlen
argument_list|(
name|entry
operator|->
name|text
argument_list|)
decl_stmt|;
comment|/* Subtract one because dir_lines is zero-based,                        but the `end_line' and `start_line' members are                        one-based.  */
for|for
control|(
name|i
operator|=
name|section
operator|->
name|end_line
operator|-
literal|1
init|;
name|i
operator|>=
name|section
operator|->
name|start_line
operator|-
literal|1
condition|;
name|i
operator|--
control|)
block|{
comment|/* If an entry exists with the same name,                            and was not marked for deletion                            (which means it is for some other file),                            we are in trouble.  */
if|if
condition|(
name|dir_lines
index|[
name|i
index|]
operator|.
name|start
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|menu_line_equal
argument_list|(
name|entry
operator|->
name|text
argument_list|,
name|textlen
argument_list|,
name|dir_lines
index|[
name|i
index|]
operator|.
name|start
argument_list|,
name|dir_lines
index|[
name|i
index|]
operator|.
name|size
argument_list|)
operator|&&
operator|!
name|dir_lines
index|[
name|i
index|]
operator|.
name|delete
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"menu item `%s' already exists, for file `%s'"
argument_list|)
argument_list|,
name|extract_menu_item_name
argument_list|(
name|entry
operator|->
name|text
argument_list|)
argument_list|,
name|extract_menu_file_name
argument_list|(
name|dir_lines
index|[
name|i
index|]
operator|.
name|start
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir_lines
index|[
name|i
index|]
operator|.
name|start
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|menu_line_lessp
argument_list|(
name|entry
operator|->
name|text
argument_list|,
name|textlen
argument_list|,
name|dir_lines
index|[
name|i
index|]
operator|.
name|start
argument_list|,
name|dir_lines
index|[
name|i
index|]
operator|.
name|size
argument_list|)
condition|)
name|add_at_line
operator|=
name|i
expr_stmt|;
block|}
name|insert_entry_here
argument_list|(
name|entry
argument_list|,
name|add_at_line
argument_list|,
name|dir_lines
argument_list|,
name|n_entries_to_add
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Mark the end of the Top node as the place to add any          new sections that are needed.  */
for|for
control|(
name|node
operator|=
name|dir_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
name|node
operator|->
name|name
operator|&&
name|strcmp
argument_list|(
name|node
operator|->
name|name
argument_list|,
literal|"Top"
argument_list|)
operator|==
literal|0
condition|)
name|dir_lines
index|[
name|node
operator|->
name|end_line
index|]
operator|.
name|add_sections_before
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|delete_flag
operator|&&
operator|!
name|something_deleted
operator|&&
operator|!
name|quiet_flag
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"no entries found for `%s'; nothing deleted"
argument_list|)
argument_list|,
name|infile
argument_list|)
expr_stmt|;
comment|/* Output the old dir file, interpolating the new sections      and/or new entries where appropriate.  */
name|output
operator|=
name|fopen
argument_list|(
name|dirfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|output
condition|)
block|{
name|perror
argument_list|(
name|dirfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|dir_nlines
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
comment|/* If we decided to output some new entries before this line,          output them now.  */
if|if
condition|(
name|dir_lines
index|[
name|i
index|]
operator|.
name|add_entries_before
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_entries_to_add
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|spec_entry
modifier|*
name|this
init|=
name|dir_lines
index|[
name|i
index|]
operator|.
name|add_entries_before
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|this
operator|==
literal|0
condition|)
break|break;
name|fputs
argument_list|(
name|this
operator|->
name|text
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
comment|/* If we decided to add some sections here          because there are no such sections in the file,          output them now.  */
if|if
condition|(
name|dir_lines
index|[
name|i
index|]
operator|.
name|add_sections_before
condition|)
block|{
name|struct
name|spec_section
modifier|*
name|spec
decl_stmt|;
name|struct
name|spec_section
modifier|*
modifier|*
name|sections
decl_stmt|;
name|int
name|n_sections
init|=
literal|0
decl_stmt|;
comment|/* Count the sections and allocate a vector for all of them.  */
for|for
control|(
name|spec
operator|=
name|input_sections
init|;
name|spec
condition|;
name|spec
operator|=
name|spec
operator|->
name|next
control|)
name|n_sections
operator|++
expr_stmt|;
name|sections
operator|=
operator|(
operator|(
expr|struct
name|spec_section
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_sections
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|spec_section
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* Fill the vector SECTIONS with pointers to all the sections,              and sort them.  */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|spec
operator|=
name|input_sections
init|;
name|spec
condition|;
name|spec
operator|=
name|spec
operator|->
name|next
control|)
name|sections
index|[
name|j
operator|++
index|]
operator|=
name|spec
expr_stmt|;
name|qsort
argument_list|(
name|sections
argument_list|,
name|n_sections
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|spec_section
operator|*
argument_list|)
argument_list|,
name|compare_section_names
argument_list|)
expr_stmt|;
comment|/* Generate the new sections in alphabetical order.              In each new section, output all of our entries.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_sections
condition|;
name|j
operator|++
control|)
block|{
name|spec
operator|=
name|sections
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|spec
operator|->
name|missing
condition|)
block|{
name|struct
name|spec_entry
modifier|*
name|entry
decl_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|spec
operator|->
name|name
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|output
argument_list|)
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|entries_to_add
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
name|fputs
argument_list|(
name|entry
operator|->
name|text
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
block|}
comment|/* Output the original dir lines unless marked for deletion.  */
if|if
condition|(
name|i
operator|<
name|dir_nlines
operator|&&
operator|!
name|dir_lines
index|[
name|i
index|]
operator|.
name|delete
condition|)
block|{
name|fwrite
argument_list|(
name|dir_lines
index|[
name|i
index|]
operator|.
name|start
argument_list|,
literal|1
argument_list|,
name|dir_lines
index|[
name|i
index|]
operator|.
name|size
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read all of file FILNAME into memory    and return the address of the data.    Store the size into SIZEP.    If there is trouble, do a fatal error.  */
end_comment

begin_function
name|char
modifier|*
name|readfile
parameter_list|(
name|filename
parameter_list|,
name|sizep
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
modifier|*
name|sizep
decl_stmt|;
block|{
name|int
name|desc
decl_stmt|;
name|int
name|data_size
init|=
literal|1024
decl_stmt|;
name|char
modifier|*
name|data
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|data_size
argument_list|)
decl_stmt|;
name|int
name|filled
init|=
literal|0
decl_stmt|;
name|int
name|nread
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LIBZ
name|int
name|isGZ
init|=
literal|0
decl_stmt|;
name|gzFile
name|zdesc
decl_stmt|;
endif|#
directive|endif
name|desc
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LIBZ
comment|/* The file should always be two bytes long.  */
if|if
condition|(
name|read
argument_list|(
name|desc
argument_list|,
name|data
argument_list|,
literal|2
argument_list|)
operator|!=
literal|2
condition|)
name|pfatal_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Undo that read.  */
name|lseek
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* If we see gzip magic, use gzdopen. */
if|if
condition|(
name|data
index|[
literal|0
index|]
operator|==
literal|'\x1f'
operator|&&
name|data
index|[
literal|1
index|]
operator|==
literal|'\x8b'
condition|)
block|{
name|isGZ
operator|=
literal|1
expr_stmt|;
name|zdesc
operator|=
name|gzdopen
argument_list|(
name|desc
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdesc
operator|==
name|NULL
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|pfatal_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_LIBZ */
while|while
condition|(
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_LIBZ
if|if
condition|(
name|isGZ
condition|)
name|nread
operator|=
name|gzread
argument_list|(
name|zdesc
argument_list|,
name|data
operator|+
name|filled
argument_list|,
name|data_size
operator|-
name|filled
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|nread
operator|=
name|read
argument_list|(
name|desc
argument_list|,
name|data
operator|+
name|filled
argument_list|,
name|data_size
operator|-
name|filled
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
break|break;
name|filled
operator|+=
name|nread
expr_stmt|;
if|if
condition|(
name|filled
operator|==
name|data_size
condition|)
block|{
name|data_size
operator|*=
literal|2
expr_stmt|;
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|data
argument_list|,
name|data_size
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|sizep
operator|=
name|filled
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LIBZ
if|if
condition|(
name|isGZ
condition|)
name|gzclose
argument_list|(
name|zdesc
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Divide the text at DATA (of SIZE bytes) into lines.    Return a vector of struct line_data describing the lines.    Store the length of that vector into *NLINESP.  */
end_comment

begin_function
name|struct
name|line_data
modifier|*
name|findlines
parameter_list|(
name|data
parameter_list|,
name|size
parameter_list|,
name|nlinesp
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
modifier|*
name|nlinesp
decl_stmt|;
block|{
name|struct
name|line_data
modifier|*
name|lines
decl_stmt|;
name|int
name|lines_allocated
init|=
literal|512
decl_stmt|;
name|int
name|filled
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|lineflag
decl_stmt|;
name|lines
operator|=
operator|(
expr|struct
name|line_data
operator|*
operator|)
name|xmalloc
argument_list|(
name|lines_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line_data
argument_list|)
argument_list|)
expr_stmt|;
name|lineflag
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lineflag
condition|)
block|{
if|if
condition|(
name|filled
operator|==
name|lines_allocated
condition|)
block|{
name|lines_allocated
operator|*=
literal|2
expr_stmt|;
name|lines
operator|=
operator|(
expr|struct
name|line_data
operator|*
operator|)
name|xrealloc
argument_list|(
name|lines
argument_list|,
name|lines_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line_data
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lines
index|[
name|filled
index|]
operator|.
name|start
operator|=
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|lines
index|[
name|filled
index|]
operator|.
name|add_entries_before
operator|=
literal|0
expr_stmt|;
name|lines
index|[
name|filled
index|]
operator|.
name|add_sections_before
operator|=
literal|0
expr_stmt|;
name|lines
index|[
name|filled
index|]
operator|.
name|delete
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|filled
operator|>
literal|0
condition|)
name|lines
index|[
name|filled
operator|-
literal|1
index|]
operator|.
name|size
operator|=
name|lines
index|[
name|filled
index|]
operator|.
name|start
operator|-
name|lines
index|[
name|filled
operator|-
literal|1
index|]
operator|.
name|start
operator|-
literal|1
expr_stmt|;
name|filled
operator|++
expr_stmt|;
block|}
name|lineflag
operator|=
operator|(
name|data
index|[
name|i
index|]
operator|==
literal|'\n'
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|filled
operator|>
literal|0
condition|)
name|lines
index|[
name|filled
operator|-
literal|1
index|]
operator|.
name|size
operator|=
operator|&
name|data
index|[
name|i
index|]
operator|-
name|lines
index|[
name|filled
operator|-
literal|1
index|]
operator|.
name|start
operator|-
name|lineflag
expr_stmt|;
comment|/* Do not leave garbage in the last element.  */
name|lines
index|[
name|filled
index|]
operator|.
name|start
operator|=
name|NULL
expr_stmt|;
name|lines
index|[
name|filled
index|]
operator|.
name|add_entries_before
operator|=
name|NULL
expr_stmt|;
name|lines
index|[
name|filled
index|]
operator|.
name|add_sections_before
operator|=
literal|0
expr_stmt|;
name|lines
index|[
name|filled
index|]
operator|.
name|delete
operator|=
literal|0
expr_stmt|;
name|lines
index|[
name|filled
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|nlinesp
operator|=
name|filled
expr_stmt|;
return|return
name|lines
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare the menu item names in LINE1 (line length LEN1)    and LINE2 (line length LEN2).  Return 1 if the item name    in LINE1 is less, 0 otherwise.  */
end_comment

begin_function
name|int
name|menu_line_lessp
parameter_list|(
name|line1
parameter_list|,
name|len1
parameter_list|,
name|line2
parameter_list|,
name|len2
parameter_list|)
name|char
modifier|*
name|line1
decl_stmt|;
name|int
name|len1
decl_stmt|;
name|char
modifier|*
name|line2
decl_stmt|;
name|int
name|len2
decl_stmt|;
block|{
name|int
name|minlen
init|=
operator|(
name|len1
operator|<
name|len2
condition|?
name|len1
else|:
name|len2
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|minlen
condition|;
name|i
operator|++
control|)
block|{
comment|/* If one item name is a prefix of the other,          the former one is less.  */
if|if
condition|(
name|line1
index|[
name|i
index|]
operator|==
literal|':'
operator|&&
name|line2
index|[
name|i
index|]
operator|!=
literal|':'
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|line2
index|[
name|i
index|]
operator|==
literal|':'
operator|&&
name|line1
index|[
name|i
index|]
operator|!=
literal|':'
condition|)
return|return
literal|0
return|;
comment|/* If they both continue and differ, one is less.  */
if|if
condition|(
name|line1
index|[
name|i
index|]
operator|<
name|line2
index|[
name|i
index|]
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|line1
index|[
name|i
index|]
operator|>
name|line2
index|[
name|i
index|]
condition|)
return|return
literal|0
return|;
block|}
comment|/* With a properly formatted dir file,      we can only get here if the item names are equal.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compare the menu item names in LINE1 (line length LEN1)    and LINE2 (line length LEN2).  Return 1 if the item names are equal,    0 otherwise.  */
end_comment

begin_function
name|int
name|menu_line_equal
parameter_list|(
name|line1
parameter_list|,
name|len1
parameter_list|,
name|line2
parameter_list|,
name|len2
parameter_list|)
name|char
modifier|*
name|line1
decl_stmt|;
name|int
name|len1
decl_stmt|;
name|char
modifier|*
name|line2
decl_stmt|;
name|int
name|len2
decl_stmt|;
block|{
name|int
name|minlen
init|=
operator|(
name|len1
operator|<
name|len2
condition|?
name|len1
else|:
name|len2
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|minlen
condition|;
name|i
operator|++
control|)
block|{
comment|/* If both item names end here, they are equal.  */
if|if
condition|(
name|line1
index|[
name|i
index|]
operator|==
literal|':'
operator|&&
name|line2
index|[
name|i
index|]
operator|==
literal|':'
condition|)
return|return
literal|1
return|;
comment|/* If they both continue and differ, one is less.  */
if|if
condition|(
name|line1
index|[
name|i
index|]
operator|!=
name|line2
index|[
name|i
index|]
condition|)
return|return
literal|0
return|;
block|}
comment|/* With a properly formatted dir file,      we can only get here if the item names are equal.  */
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is the comparison function for qsort    for a vector of pointers to struct spec_section.    Compare the section names.  */
end_comment

begin_function
name|int
name|compare_section_names
parameter_list|(
name|sec1
parameter_list|,
name|sec2
parameter_list|)
name|struct
name|spec_section
modifier|*
modifier|*
name|sec1
decl_stmt|,
decl|*
modifier|*
name|sec2
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|name1
init|=
operator|(
operator|*
name|sec1
operator|)
operator|->
name|name
decl_stmt|;
name|char
modifier|*
name|name2
init|=
operator|(
operator|*
name|sec2
operator|)
operator|->
name|name
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|name1
argument_list|,
name|name2
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Insert ENTRY into the add_entries_before vector    for line number LINE_NUMBER of the dir file.    DIR_LINES and N_ENTRIES carry information from like-named variables    in main.  */
end_comment

begin_function
name|void
name|insert_entry_here
parameter_list|(
name|entry
parameter_list|,
name|line_number
parameter_list|,
name|dir_lines
parameter_list|,
name|n_entries
parameter_list|)
name|struct
name|spec_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|line_number
decl_stmt|;
name|struct
name|line_data
modifier|*
name|dir_lines
decl_stmt|;
name|int
name|n_entries
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dir_lines
index|[
name|line_number
index|]
operator|.
name|add_entries_before
operator|==
literal|0
condition|)
block|{
name|dir_lines
index|[
name|line_number
index|]
operator|.
name|add_entries_before
operator|=
operator|(
expr|struct
name|spec_entry
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_entries
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|spec_entry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_entries
condition|;
name|i
operator|++
control|)
name|dir_lines
index|[
name|line_number
index|]
operator|.
name|add_entries_before
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_entries
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dir_lines
index|[
name|line_number
index|]
operator|.
name|add_entries_before
index|[
name|i
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|n_entries
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dir_lines
index|[
name|line_number
index|]
operator|.
name|add_entries_before
index|[
name|i
index|]
operator|=
name|entry
expr_stmt|;
block|}
end_function

end_unit

