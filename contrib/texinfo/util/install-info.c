begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* install-info -- create Info directory entry(ies) for an Info file.    $Id: install-info.c,v 1.48 1999/08/06 18:13:32 karl Exp $    $FreeBSD$     Copyright (C) 1996, 97, 98, 99 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.*/
end_comment

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|progname
init|=
literal|"install-info"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|default_section
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|line_data
modifier|*
name|findlines
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|insert_entry_here
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|compare_section_names
argument_list|()
decl_stmt|,
name|compare_entries_text
argument_list|()
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|spec_entry
struct_decl|;
end_struct_decl

begin_escape
end_escape

begin_comment
comment|/* Data structures.  */
end_comment

begin_comment
comment|/* Record info about a single line from a file as read into core.  */
end_comment

begin_struct
struct|struct
name|line_data
block|{
comment|/* The start of the line.  */
name|char
modifier|*
name|start
decl_stmt|;
comment|/* The number of characters in the line,      excluding the terminating newline.  */
name|int
name|size
decl_stmt|;
comment|/* Vector containing pointers to the entries to add before this line.      The vector is null-terminated.  */
name|struct
name|spec_entry
modifier|*
modifier|*
name|add_entries_before
decl_stmt|;
comment|/* 1 means output any needed new sections before this line.  */
name|int
name|add_sections_before
decl_stmt|;
comment|/* 1 means don't output this line.  */
name|int
name|delete
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is used for a list of the specified menu section names    in which entries should be added.  */
end_comment

begin_struct
struct|struct
name|spec_section
block|{
name|struct
name|spec_section
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* 1 means we have not yet found an existing section with this name      in the dir file--so we will need to add a new section.  */
name|int
name|missing
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is used for a list of the entries specified to be added.  */
end_comment

begin_struct
struct|struct
name|spec_entry
block|{
name|struct
name|spec_entry
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|text_len
decl_stmt|;
comment|/* A pointer to the list of sections to which this entry should be      added.  */
name|struct
name|spec_section
modifier|*
name|entry_sections
decl_stmt|;
comment|/* A pointer to a section that is beyond the end of the chain whose      head is pointed to by entry_sections.  */
name|struct
name|spec_section
modifier|*
name|entry_sections_tail
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is used for a list of nodes found by parsing the dir file.  */
end_comment

begin_struct
struct|struct
name|node
block|{
name|struct
name|node
modifier|*
name|next
decl_stmt|;
comment|/* The node name.  */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The line number of the line where the node starts.      This is the line that contains control-underscore.  */
name|int
name|start_line
decl_stmt|;
comment|/* The line number of the line where the node ends,      which is the end of the file or where the next line starts.  */
name|int
name|end_line
decl_stmt|;
comment|/* Start of first line in this node's menu      (the line after the * Menu: line).  */
name|char
modifier|*
name|menu_start
decl_stmt|;
comment|/* The start of the chain of sections in this node's menu.  */
name|struct
name|menu_section
modifier|*
name|sections
decl_stmt|;
comment|/* The last menu section in the chain.  */
name|struct
name|menu_section
modifier|*
name|last_section
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is used for a list of sections found in a node's menu.    Each  struct node  has such a list in the  sections  field.  */
end_comment

begin_struct
struct|struct
name|menu_section
block|{
name|struct
name|menu_section
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Line number of start of section.  */
name|int
name|start_line
decl_stmt|;
comment|/* Line number of end of section.  */
name|int
name|end_line
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* This table defines all the long-named options, says whether they    use an argument, and maps them into equivalent single-letter options.  */
end_comment

begin_decl_stmt
name|struct
name|option
name|longopts
index|[]
init|=
block|{
block|{
literal|"delete"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'r'
block|}
block|,
block|{
literal|"defentry"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'E'
block|}
block|,
block|{
literal|"defsection"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'S'
block|}
block|,
block|{
literal|"dir-file"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
block|{
literal|"entry"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'e'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"info-dir"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'D'
block|}
block|,
block|{
literal|"info-file"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'i'
block|}
block|,
block|{
literal|"item"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'e'
block|}
block|,
block|{
literal|"quiet"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'q'
block|}
block|,
block|{
literal|"remove"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'r'
block|}
block|,
block|{
literal|"section"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'V'
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Error message functions.  */
end_comment

begin_comment
comment|/* Print error message.  S1 is printf control string, S2 and S3 args for it. */
end_comment

begin_comment
comment|/* VARARGS1 */
end_comment

begin_function
name|void
name|error
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
end_function

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* VARARGS1 */
end_comment

begin_function
name|void
name|warning
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
end_function

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: warning: "
argument_list|)
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Print error message and exit.  */
end_comment

begin_function
name|void
name|fatal
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
end_function

begin_block
block|{
name|error
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Memory allocation and string operations.  */
end_comment

begin_comment
comment|/* Like malloc but get fatal error if memory is exhausted.  */
end_comment

begin_function
name|void
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|int
name|size
decl_stmt|;
block|{
specifier|extern
name|void
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|void
modifier|*
name|result
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Like realloc but get fatal error if memory is exhausted.  */
end_comment

begin_function
name|void
modifier|*
name|xrealloc
parameter_list|(
name|obj
parameter_list|,
name|size
parameter_list|)
name|void
modifier|*
name|obj
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
specifier|extern
name|void
modifier|*
name|realloc
parameter_list|()
function_decl|;
name|void
modifier|*
name|result
init|=
name|realloc
argument_list|(
name|obj
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return a newly-allocated string    whose contents concatenate those of S1, S2, S3.  */
end_comment

begin_function
name|char
modifier|*
name|concat
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
end_function

begin_block
block|{
name|int
name|len1
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
decl_stmt|,
name|len2
init|=
name|strlen
argument_list|(
name|s2
argument_list|)
decl_stmt|,
name|len3
init|=
name|strlen
argument_list|(
name|s3
argument_list|)
decl_stmt|;
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len1
operator|+
name|len2
operator|+
name|len3
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
operator|+
name|len2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
operator|*
operator|(
name|result
operator|+
name|len1
operator|+
name|len2
operator|+
name|len3
operator|)
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/* Return a string containing SIZE characters    copied from starting at STRING.  */
end_comment

begin_function
name|char
modifier|*
name|copy_string
parameter_list|(
name|string
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|copy
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|copy
index|[
name|i
index|]
operator|=
name|string
index|[
name|i
index|]
expr_stmt|;
name|copy
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function

begin_comment
comment|/* Print fatal error message based on errno, with file name NAME.  */
end_comment

begin_function
name|void
name|pfatal_with_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|s
init|=
name|concat
argument_list|(
literal|""
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|_
argument_list|(
literal|" for %s"
argument_list|)
argument_list|)
decl_stmt|;
name|fatal
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given the full text of a menu entry, null terminated,    return just the menu item name (copied).  */
end_comment

begin_function
name|char
modifier|*
name|extract_menu_item_name
parameter_list|(
name|item_text
parameter_list|)
name|char
modifier|*
name|item_text
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|item_text
operator|==
literal|'*'
condition|)
name|item_text
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|item_text
operator|==
literal|' '
condition|)
name|item_text
operator|++
expr_stmt|;
name|p
operator|=
name|item_text
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
return|return
name|copy_string
argument_list|(
name|item_text
argument_list|,
name|p
operator|-
name|item_text
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given the full text of a menu entry, terminated by null or newline,    return just the menu item file (copied).  */
end_comment

begin_function
name|char
modifier|*
name|extract_menu_file_name
parameter_list|(
name|item_text
parameter_list|)
name|char
modifier|*
name|item_text
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|item_text
decl_stmt|;
comment|/* If we have text that looks like * ITEM: (FILE)NODE...,      extract just FILE.  Otherwise return "(none)".  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Skip to and past the colon.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Skip past the open-paren.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
break|break;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
else|else
return|return
literal|"(none)"
return|;
block|}
name|p
operator|++
expr_stmt|;
name|item_text
operator|=
name|p
expr_stmt|;
comment|/* File name ends just before the close-paren.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
operator|!=
literal|')'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|')'
condition|)
return|return
literal|"(none)"
return|;
return|return
name|copy_string
argument_list|(
name|item_text
argument_list|,
name|p
operator|-
name|item_text
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return FNAME with any [.info][.gz] suffix removed.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|strip_info_suffix
parameter_list|(
name|fname
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|char
modifier|*
name|ret
init|=
name|xstrdup
argument_list|(
name|fname
argument_list|)
decl_stmt|;
name|unsigned
name|len
init|=
name|strlen
argument_list|(
name|ret
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|3
operator|&&
name|FILENAME_CMP
argument_list|(
name|ret
operator|+
name|len
operator|-
literal|3
argument_list|,
literal|".gz"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|len
operator|-=
literal|3
expr_stmt|;
name|ret
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|5
operator|&&
name|FILENAME_CMP
argument_list|(
name|ret
operator|+
name|len
operator|-
literal|5
argument_list|,
literal|".info"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|len
operator|-=
literal|5
expr_stmt|;
name|ret
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|>
literal|4
operator|&&
name|FILENAME_CMP
argument_list|(
name|ret
operator|+
name|len
operator|-
literal|4
argument_list|,
literal|".inf"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|len
operator|-=
literal|4
expr_stmt|;
name|ret
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__MSDOS__
elseif|else
if|if
condition|(
name|len
operator|>
literal|4
operator|&&
operator|(
name|FILENAME_CMP
argument_list|(
name|ret
operator|+
name|len
operator|-
literal|4
argument_list|,
literal|".inz"
argument_list|)
operator|==
literal|0
operator|||
name|FILENAME_CMP
argument_list|(
name|ret
operator|+
name|len
operator|-
literal|4
argument_list|,
literal|".igz"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|len
operator|-=
literal|4
expr_stmt|;
name|ret
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* __MSDOS__ */
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Return true if ITEM matches NAME and is followed by TERM_CHAR.  ITEM    can also be followed by `.gz', `.info.gz', or `.info' (and then    TERM_CHAR) and still match.  */
end_comment

begin_function
specifier|static
name|int
name|menu_item_equal
parameter_list|(
name|item
parameter_list|,
name|term_char
parameter_list|,
name|name
parameter_list|)
name|char
modifier|*
name|item
decl_stmt|;
name|char
name|term_char
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|unsigned
name|name_len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|/* First, ITEM must actually match NAME (usually it won't).  */
name|int
name|ret
init|=
name|strncasecmp
argument_list|(
name|item
argument_list|,
name|name
argument_list|,
name|name_len
argument_list|)
operator|==
literal|0
decl_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* Then, `foobar' doesn't match `foo', so be sure we've got all of          ITEM.  The various suffixes should never actually appear in the          dir file, but sometimes people put them in.  */
specifier|static
name|char
modifier|*
name|suffixes
index|[]
init|=
block|{
literal|""
block|,
literal|".info.gz"
block|,
literal|".info"
block|,
literal|".inf"
block|,
literal|".gz"
block|,
ifdef|#
directive|ifdef
name|__MSDOS__
literal|".inz"
block|,
literal|".igz"
block|,
endif|#
directive|endif
name|NULL
block|}
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|ret
operator|&&
name|suffixes
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|suffix
init|=
name|suffixes
index|[
name|i
index|]
decl_stmt|;
name|unsigned
name|suffix_len
init|=
name|strlen
argument_list|(
name|suffix
argument_list|)
decl_stmt|;
name|ret
operator|=
name|strncasecmp
argument_list|(
name|item
operator|+
name|name_len
argument_list|,
name|suffix
argument_list|,
name|suffix_len
argument_list|)
operator|==
literal|0
operator|&&
name|item
index|[
name|name_len
operator|+
name|suffix_len
index|]
operator|==
name|term_char
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|suggest_asking_for_help
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"\tTry `%s --help' for a complete list of options.\n"
argument_list|)
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_help
parameter_list|()
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Usage: %s [OPTION]... [INFO-FILE [DIR-FILE]]\n\ \n\ Install or delete dir entries from INFO-FILE in the Info directory file\n\ DIR-FILE.\n\ \n\ Options:\n\  --delete          delete existing entries for INFO-FILE from DIR-FILE;\n\                      don't insert any new entries.\n\  --defentry=TEXT   like --entry, but only use TEXT if an entry\n\                      is not present in INFO-FILE.\n\  --defsection=TEXT like --section, but only use TEXT if a section\n\                      is not present in INFO-FILE.\n\  --dir-file=NAME   specify file name of Info directory file.\n\                      This is equivalent to using the DIR-FILE argument.\n\  --entry=TEXT      insert TEXT as an Info directory entry.\n\                      TEXT should have the form of an Info menu item line\n\                      plus zero or more extra lines starting with whitespace.\n\                      If you specify more than one entry, they are all added.\n\                      If you don't specify any entries, they are determined\n\                      from information in the Info file itself.\n\  --help            display this help and exit.\n\  --info-file=FILE  specify Info file to install in the directory.\n\                      This is equivalent to using the INFO-FILE argument.\n\  --info-dir=DIR    same as --dir-file=DIR/dir.\n\  --item=TEXT       same as --entry TEXT.\n\                      An Info directory entry is actually a menu item.\n\  --quiet           suppress warnings.\n\  --remove          same as --delete.\n\  --section=SEC     put this file's entries in section SEC of the directory.\n\                      If you specify more than one section, all the entries\n\                      are added in each of the sections.\n\                      If you don't specify any sections, they are determined\n\                      from information in the Info file itself.\n\  --version         display version information and exit.\n\ \n\ Email bug reports to bug-texinfo@gnu.org,\n\ general questions and discussion to help-texinfo@gnu.org.\n\ "
argument_list|)
argument_list|,
name|progname
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If DIRFILE does not exist, create a minimal one (or abort).  If it    already exists, do nothing.  */
end_comment

begin_function
name|void
name|ensure_dirfile_exists
parameter_list|(
name|dirfile
parameter_list|)
name|char
modifier|*
name|dirfile
decl_stmt|;
block|{
name|int
name|desc
init|=
name|open
argument_list|(
name|dirfile
argument_list|,
name|O_RDONLY
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|readerr
init|=
name|strerror
argument_list|(
name|errno
argument_list|)
decl_stmt|;
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|dirfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"This is the file .../info/dir, which contains the\n\ topmost node of the Info hierarchy, called (dir)Top.\n\ The first time you invoke Info you start off looking at this node.\n\
literal|\n\ %s\tThis is the top of the INFO tree\n\ \n\   This (the Directory node) gives a menu of major topics.\n\   Typing \"q\" exits, \"?\" lists all Info commands, \"d\" returns here,\n\   \"h\" gives a primer for first-timers,\n\   \"mEmacs<Return>\" visits the Emacs manual, etc.\n\ \n\   In Emacs, you can click mouse button 2 on a menu item or cross reference\n\   to select it.\n\ \n\ * Menu:\n\ "
argument_list|)
argument_list|,
literal|"File: dir,\tNode: Top"
argument_list|)
expr_stmt|;
comment|/* This part must not be translated.  */
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|dirfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Didn't exist, but couldn't open for writing.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: could not read (%s) and could not create (%s)\n"
argument_list|)
argument_list|,
name|dirfile
argument_list|,
name|readerr
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
comment|/* It already existed, so fine.  */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Open FILENAME and return the resulting stream pointer.  If it doesn't    exist, try FILENAME.gz.  If that doesn't exist either, call    CREATE_CALLBACK (with FILENAME as arg) to create it, if that is    non-NULL.  If still no luck, fatal error.     If we do open it, return the actual name of the file opened in    OPENED_FILENAME and the compress program to use to (de)compress it in    COMPRESSION_PROGRAM.  The compression program is determined by the    magic number, not the filename.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|open_possibly_compressed_file
argument_list|(
name|filename
argument_list|,
name|create_callback
argument_list|,
name|opened_filename
argument_list|,
name|compression_program
argument_list|,
name|is_pipe
argument_list|)
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|create_callback
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
modifier|*
name|opened_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|compression_program
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|is_pipe
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|local_opened_filename
decl_stmt|,
modifier|*
name|local_compression_program
decl_stmt|;
name|int
name|nread
decl_stmt|;
name|char
name|data
index|[
literal|4
index|]
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
comment|/* We let them pass NULL if they don't want this info, but it's easier      to always determine it.  */
if|if
condition|(
operator|!
name|opened_filename
condition|)
name|opened_filename
operator|=
operator|&
name|local_opened_filename
expr_stmt|;
operator|*
name|opened_filename
operator|=
name|filename
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
operator|*
name|opened_filename
argument_list|,
name|FOPEN_RBIN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
operator|*
name|opened_filename
operator|=
name|concat
argument_list|(
name|filename
argument_list|,
literal|".gz"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
operator|*
name|opened_filename
argument_list|,
name|FOPEN_RBIN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__MSDOS__
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|free
argument_list|(
operator|*
name|opened_filename
argument_list|)
expr_stmt|;
operator|*
name|opened_filename
operator|=
name|concat
argument_list|(
name|filename
argument_list|,
literal|".igz"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
operator|*
name|opened_filename
argument_list|,
name|FOPEN_RBIN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|free
argument_list|(
operator|*
name|opened_filename
argument_list|)
expr_stmt|;
operator|*
name|opened_filename
operator|=
name|concat
argument_list|(
name|filename
argument_list|,
literal|".inz"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
operator|*
name|opened_filename
argument_list|,
name|FOPEN_RBIN
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|f
condition|)
block|{
if|if
condition|(
name|create_callback
condition|)
block|{
comment|/* That didn't work either.  Create the file if we can.  */
call|(
modifier|*
name|create_callback
call|)
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* And try opening it again.  */
name|free
argument_list|(
operator|*
name|opened_filename
argument_list|)
expr_stmt|;
operator|*
name|opened_filename
operator|=
name|filename
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
operator|*
name|opened_filename
argument_list|,
name|FOPEN_RBIN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
name|pfatal_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
name|pfatal_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Read first few bytes of file rather than relying on the filename.      If the file is shorter than this it can't be usable anyway.  */
name|nread
operator|=
name|fread
argument_list|(
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|,
literal|1
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|!=
literal|1
condition|)
block|{
comment|/* Empty files don't set errno, so we get something like          "install-info: No error for foo", which is confusing.  */
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"%s: empty file"
argument_list|)
argument_list|,
operator|*
name|opened_filename
argument_list|)
expr_stmt|;
name|pfatal_with_name
argument_list|(
operator|*
name|opened_filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|compression_program
condition|)
name|compression_program
operator|=
operator|&
name|local_compression_program
expr_stmt|;
if|if
condition|(
name|data
index|[
literal|0
index|]
operator|==
literal|'\x1f'
operator|&&
name|data
index|[
literal|1
index|]
operator|==
literal|'\x8b'
condition|)
if|#
directive|if
name|STRIP_DOT_EXE
comment|/* An explicit .exe yields a better diagnostics from popen below        if they don't have gzip installed.  */
operator|*
name|compression_program
operator|=
literal|"gzip.exe"
expr_stmt|;
else|#
directive|else
operator|*
name|compression_program
operator|=
literal|"gzip"
expr_stmt|;
endif|#
directive|endif
else|else
operator|*
name|compression_program
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|compression_program
condition|)
block|{
comment|/* It's compressed, so fclose the file and then open a pipe.  */
name|char
modifier|*
name|command
init|=
name|concat
argument_list|(
operator|*
name|compression_program
argument_list|,
literal|" -cd<"
argument_list|,
operator|*
name|opened_filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
operator|*
name|opened_filename
argument_list|)
expr_stmt|;
name|f
operator|=
name|popen
argument_list|(
name|command
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
operator|*
name|is_pipe
operator|=
literal|1
expr_stmt|;
else|else
name|pfatal_with_name
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It's a plain file, seek back over the magic bytes.  */
if|if
condition|(
name|fseek
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
operator|*
name|opened_filename
argument_list|)
expr_stmt|;
if|#
directive|if
name|O_BINARY
comment|/* Since this is a text file, and we opened it in binary mode,          switch back to text mode.  */
name|f
operator|=
name|freopen
argument_list|(
operator|*
name|opened_filename
argument_list|,
literal|"r"
argument_list|,
name|f
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|is_pipe
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Read all of file FILENAME into memory and return the address of the    data.  Store the size of the data into SIZEP.  If need be, uncompress    (i.e., try FILENAME.gz et al. if FILENAME does not exist) and store    the actual file name that was opened into OPENED_FILENAME (if it is    non-NULL), and the companion compression program (if any, else NULL)    into COMPRESSION_PROGRAM (if that is non-NULL).  If trouble, do    a fatal error.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|readfile
argument_list|(
name|filename
argument_list|,
name|sizep
argument_list|,
name|create_callback
argument_list|,
name|opened_filename
argument_list|,
name|compression_program
argument_list|)
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|sizep
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|create_callback
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
modifier|*
name|opened_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|compression_program
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|real_name
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|pipe_p
decl_stmt|;
name|int
name|filled
init|=
literal|0
decl_stmt|;
name|int
name|data_size
init|=
literal|8192
decl_stmt|;
name|char
modifier|*
name|data
init|=
name|xmalloc
argument_list|(
name|data_size
argument_list|)
decl_stmt|;
comment|/* If they passed the space for the file name to return, use it.  */
name|f
operator|=
name|open_possibly_compressed_file
argument_list|(
name|filename
argument_list|,
name|create_callback
argument_list|,
name|opened_filename
condition|?
name|opened_filename
else|:
operator|&
name|real_name
argument_list|,
name|compression_program
argument_list|,
operator|&
name|pipe_p
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|nread
init|=
name|fread
argument_list|(
name|data
operator|+
name|filled
argument_list|,
literal|1
argument_list|,
name|data_size
operator|-
name|filled
argument_list|,
name|f
argument_list|)
decl_stmt|;
if|if
condition|(
name|nread
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|real_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
break|break;
name|filled
operator|+=
name|nread
expr_stmt|;
if|if
condition|(
name|filled
operator|==
name|data_size
condition|)
block|{
name|data_size
operator|+=
literal|65536
expr_stmt|;
name|data
operator|=
name|xrealloc
argument_list|(
name|data
argument_list|,
name|data_size
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We'll end up wasting space if we're not passing the filename back      and it is not just FILENAME, but so what.  */
comment|/* We need to close the stream, since on some systems the pipe created      by popen is simulated by a temporary file which only gets removed      inside pclose.  */
if|if
condition|(
name|pipe_p
condition|)
name|pclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
else|else
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
operator|*
name|sizep
operator|=
name|filled
expr_stmt|;
return|return
name|data
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Output the old dir file, interpolating the new sections    and/or new entries where appropriate.  If COMPRESSION_PROGRAM is not    null, pipe to it to create DIRFILE.  Thus if we read dir.gz on input,    we'll write dir.gz on output.  */
end_comment

begin_function
specifier|static
name|void
name|output_dirfile
parameter_list|(
name|dirfile
parameter_list|,
name|dir_nlines
parameter_list|,
name|dir_lines
parameter_list|,
name|n_entries_to_add
parameter_list|,
name|entries_to_add
parameter_list|,
name|input_sections
parameter_list|,
name|compression_program
parameter_list|)
name|char
modifier|*
name|dirfile
decl_stmt|;
name|int
name|dir_nlines
decl_stmt|;
name|struct
name|line_data
modifier|*
name|dir_lines
decl_stmt|;
name|int
name|n_entries_to_add
decl_stmt|;
name|struct
name|spec_entry
modifier|*
name|entries_to_add
decl_stmt|;
name|struct
name|spec_section
modifier|*
name|input_sections
decl_stmt|;
name|char
modifier|*
name|compression_program
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|output
decl_stmt|;
if|if
condition|(
name|compression_program
condition|)
block|{
name|char
modifier|*
name|command
init|=
name|concat
argument_list|(
name|compression_program
argument_list|,
literal|">"
argument_list|,
name|dirfile
argument_list|)
decl_stmt|;
name|output
operator|=
name|popen
argument_list|(
name|command
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
else|else
name|output
operator|=
name|fopen
argument_list|(
name|dirfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|output
condition|)
block|{
name|perror
argument_list|(
name|dirfile
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|dir_nlines
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
comment|/* If we decided to output some new entries before this line,          output them now.  */
if|if
condition|(
name|dir_lines
index|[
name|i
index|]
operator|.
name|add_entries_before
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_entries_to_add
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|spec_entry
modifier|*
name|this
init|=
name|dir_lines
index|[
name|i
index|]
operator|.
name|add_entries_before
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|this
operator|==
literal|0
condition|)
break|break;
name|fputs
argument_list|(
name|this
operator|->
name|text
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
comment|/* If we decided to add some sections here          because there are no such sections in the file,          output them now.  */
if|if
condition|(
name|dir_lines
index|[
name|i
index|]
operator|.
name|add_sections_before
condition|)
block|{
name|struct
name|spec_section
modifier|*
name|spec
decl_stmt|;
name|struct
name|spec_section
modifier|*
modifier|*
name|sections
decl_stmt|;
name|int
name|n_sections
init|=
literal|0
decl_stmt|;
name|struct
name|spec_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|spec_entry
modifier|*
modifier|*
name|entries
decl_stmt|;
name|int
name|n_entries
init|=
literal|0
decl_stmt|;
comment|/* Count the sections and allocate a vector for all of them.  */
for|for
control|(
name|spec
operator|=
name|input_sections
init|;
name|spec
condition|;
name|spec
operator|=
name|spec
operator|->
name|next
control|)
name|n_sections
operator|++
expr_stmt|;
name|sections
operator|=
operator|(
operator|(
expr|struct
name|spec_section
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_sections
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|spec_section
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* Fill the vector SECTIONS with pointers to all the sections,              and sort them.  */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|spec
operator|=
name|input_sections
init|;
name|spec
condition|;
name|spec
operator|=
name|spec
operator|->
name|next
control|)
name|sections
index|[
name|j
operator|++
index|]
operator|=
name|spec
expr_stmt|;
name|qsort
argument_list|(
name|sections
argument_list|,
name|n_sections
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|spec_section
operator|*
argument_list|)
argument_list|,
name|compare_section_names
argument_list|)
expr_stmt|;
comment|/* Count the entries and allocate a vector for all of them.  */
for|for
control|(
name|entry
operator|=
name|entries_to_add
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
name|n_entries
operator|++
expr_stmt|;
name|entries
operator|=
operator|(
operator|(
expr|struct
name|spec_entry
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_entries
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|spec_entry
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
comment|/* Fill the vector ENTRIES with pointers to all the sections,              and sort them.  */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|entries_to_add
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
name|entries
index|[
name|j
operator|++
index|]
operator|=
name|entry
expr_stmt|;
name|qsort
argument_list|(
name|entries
argument_list|,
name|n_entries
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|spec_entry
operator|*
argument_list|)
argument_list|,
name|compare_entries_text
argument_list|)
expr_stmt|;
comment|/* Generate the new sections in alphabetical order.  In each              new section, output all of the entries that belong to that              section, in alphabetical order.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n_sections
condition|;
name|j
operator|++
control|)
block|{
name|spec
operator|=
name|sections
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|spec
operator|->
name|missing
condition|)
block|{
name|int
name|k
decl_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|spec
operator|->
name|name
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|output
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|n_entries
condition|;
name|k
operator|++
control|)
block|{
name|struct
name|spec_section
modifier|*
name|spec1
decl_stmt|;
comment|/* Did they at all want this entry to be put into                          this section?  */
name|entry
operator|=
name|entries
index|[
name|k
index|]
expr_stmt|;
for|for
control|(
name|spec1
operator|=
name|entry
operator|->
name|entry_sections
init|;
name|spec1
operator|&&
name|spec1
operator|!=
name|entry
operator|->
name|entry_sections_tail
condition|;
name|spec1
operator|=
name|spec1
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|spec1
operator|->
name|name
argument_list|,
name|spec
operator|->
name|name
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|spec1
operator|&&
name|spec1
operator|!=
name|entry
operator|->
name|entry_sections_tail
condition|)
name|fputs
argument_list|(
name|entry
operator|->
name|text
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
block|}
comment|/* Output the original dir lines unless marked for deletion.  */
if|if
condition|(
name|i
operator|<
name|dir_nlines
operator|&&
operator|!
name|dir_lines
index|[
name|i
index|]
operator|.
name|delete
condition|)
block|{
name|fwrite
argument_list|(
name|dir_lines
index|[
name|i
index|]
operator|.
name|start
argument_list|,
literal|1
argument_list|,
name|dir_lines
index|[
name|i
index|]
operator|.
name|size
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Some systems, such as MS-DOS, simulate pipes with temporary files.      On those systems, the compressor actually gets run inside pclose,      so we must call pclose.  */
if|if
condition|(
name|compression_program
condition|)
name|pclose
argument_list|(
name|output
argument_list|)
expr_stmt|;
else|else
name|fclose
argument_list|(
name|output
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse the input to find the section names and the entry names it    specifies.  Return the number of entries to add from this file.  */
end_comment

begin_function
name|int
name|parse_input
parameter_list|(
name|lines
parameter_list|,
name|nlines
parameter_list|,
name|sections
parameter_list|,
name|entries
parameter_list|)
specifier|const
name|struct
name|line_data
modifier|*
name|lines
decl_stmt|;
name|int
name|nlines
decl_stmt|;
name|struct
name|spec_section
modifier|*
modifier|*
name|sections
decl_stmt|;
name|struct
name|spec_entry
modifier|*
modifier|*
name|entries
decl_stmt|;
block|{
name|int
name|n_entries
init|=
literal|0
decl_stmt|;
name|int
name|prefix_length
init|=
name|strlen
argument_list|(
literal|"INFO-DIR-SECTION "
argument_list|)
decl_stmt|;
name|struct
name|spec_section
modifier|*
name|head
init|=
operator|*
name|sections
decl_stmt|,
modifier|*
name|tail
init|=
name|NULL
decl_stmt|;
name|int
name|reset_tail
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|start_of_this_entry
init|=
literal|0
decl_stmt|;
name|int
name|ignore_sections
init|=
operator|*
name|sections
operator|!=
literal|0
decl_stmt|;
name|int
name|ignore_entries
init|=
operator|*
name|entries
operator|!=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ignore_sections
operator|&&
name|ignore_entries
condition|)
return|return
literal|0
return|;
comment|/* Loop here processing lines from the input file.  Each      INFO-DIR-SECTION entry is added to the SECTIONS linked list.      Each START-INFO-DIR-ENTRY block is added to the ENTRIES linked      list, and all its entries inherit the chain of SECTION entries      defined by the last group of INFO-DIR-SECTION entries we have      seen until that point.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlines
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ignore_sections
operator|&&
operator|!
name|strncmp
argument_list|(
literal|"INFO-DIR-SECTION "
argument_list|,
name|lines
index|[
name|i
index|]
operator|.
name|start
argument_list|,
name|prefix_length
argument_list|)
condition|)
block|{
name|struct
name|spec_section
modifier|*
name|next
init|=
operator|(
expr|struct
name|spec_section
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|spec_section
argument_list|)
argument_list|)
decl_stmt|;
name|next
operator|->
name|name
operator|=
name|copy_string
argument_list|(
name|lines
index|[
name|i
index|]
operator|.
name|start
operator|+
name|prefix_length
argument_list|,
name|lines
index|[
name|i
index|]
operator|.
name|size
operator|-
name|prefix_length
argument_list|)
expr_stmt|;
name|next
operator|->
name|next
operator|=
operator|*
name|sections
expr_stmt|;
name|next
operator|->
name|missing
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|reset_tail
condition|)
block|{
name|tail
operator|=
operator|*
name|sections
expr_stmt|;
name|reset_tail
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|sections
operator|=
name|next
expr_stmt|;
name|head
operator|=
operator|*
name|sections
expr_stmt|;
block|}
comment|/* If entries were specified explicitly with command options,          ignore the entries in the input file.  */
elseif|else
if|if
condition|(
operator|!
name|ignore_entries
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
literal|"START-INFO-DIR-ENTRY"
argument_list|,
name|lines
index|[
name|i
index|]
operator|.
name|start
argument_list|,
name|lines
index|[
name|i
index|]
operator|.
name|size
argument_list|)
operator|&&
sizeof|sizeof
argument_list|(
literal|"START-INFO-DIR-ENTRY"
argument_list|)
operator|-
literal|1
operator|==
name|lines
index|[
name|i
index|]
operator|.
name|size
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|sections
condition|)
block|{
comment|/* We found an entry, but didn't yet see any sections                      specified.  Default to section "Miscellaneous".  */
operator|*
name|sections
operator|=
operator|(
expr|struct
name|spec_section
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|spec_section
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|sections
operator|)
operator|->
name|name
operator|=
name|default_section
condition|?
name|default_section
else|:
literal|"Miscellaneous"
expr_stmt|;
operator|(
operator|*
name|sections
operator|)
operator|->
name|next
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|sections
operator|)
operator|->
name|missing
operator|=
literal|1
expr_stmt|;
name|head
operator|=
operator|*
name|sections
expr_stmt|;
block|}
comment|/* Next time we see INFO-DIR-SECTION, we will reset the                  tail pointer.  */
name|reset_tail
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|start_of_this_entry
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"START-INFO-DIR-ENTRY without matching END-INFO-DIR-ENTRY"
argument_list|)
argument_list|)
expr_stmt|;
name|start_of_this_entry
operator|=
name|lines
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|start
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|start_of_this_entry
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|strncmp
argument_list|(
literal|"* "
argument_list|,
name|lines
index|[
name|i
index|]
operator|.
name|start
argument_list|,
literal|2
argument_list|)
operator|&&
name|lines
index|[
name|i
index|]
operator|.
name|start
operator|>
name|start_of_this_entry
operator|)
operator|||
operator|(
operator|!
name|strncmp
argument_list|(
literal|"END-INFO-DIR-ENTRY"
argument_list|,
name|lines
index|[
name|i
index|]
operator|.
name|start
argument_list|,
name|lines
index|[
name|i
index|]
operator|.
name|size
argument_list|)
operator|&&
sizeof|sizeof
argument_list|(
literal|"END-INFO-DIR-ENTRY"
argument_list|)
operator|-
literal|1
operator|==
name|lines
index|[
name|i
index|]
operator|.
name|size
operator|)
condition|)
block|{
comment|/* We found an end of this entry.  Allocate another                      entry, fill its data, and add it to the linked                      list.  */
name|struct
name|spec_entry
modifier|*
name|next
init|=
operator|(
expr|struct
name|spec_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|spec_entry
argument_list|)
argument_list|)
decl_stmt|;
name|next
operator|->
name|text
operator|=
name|copy_string
argument_list|(
name|start_of_this_entry
argument_list|,
name|lines
index|[
name|i
index|]
operator|.
name|start
operator|-
name|start_of_this_entry
argument_list|)
expr_stmt|;
name|next
operator|->
name|text_len
operator|=
name|lines
index|[
name|i
index|]
operator|.
name|start
operator|-
name|start_of_this_entry
expr_stmt|;
name|next
operator|->
name|entry_sections
operator|=
name|head
expr_stmt|;
name|next
operator|->
name|entry_sections_tail
operator|=
name|tail
expr_stmt|;
name|next
operator|->
name|next
operator|=
operator|*
name|entries
expr_stmt|;
operator|*
name|entries
operator|=
name|next
expr_stmt|;
name|n_entries
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
literal|"END-INFO-DIR-ENTRY"
argument_list|,
name|lines
index|[
name|i
index|]
operator|.
name|start
argument_list|,
name|lines
index|[
name|i
index|]
operator|.
name|size
argument_list|)
operator|&&
sizeof|sizeof
argument_list|(
literal|"END-INFO-DIR-ENTRY"
argument_list|)
operator|-
literal|1
operator|==
name|lines
index|[
name|i
index|]
operator|.
name|size
condition|)
name|start_of_this_entry
operator|=
literal|0
expr_stmt|;
else|else
name|start_of_this_entry
operator|=
name|lines
index|[
name|i
index|]
operator|.
name|start
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
literal|"END-INFO-DIR-ENTRY"
argument_list|,
name|lines
index|[
name|i
index|]
operator|.
name|start
argument_list|,
name|lines
index|[
name|i
index|]
operator|.
name|size
argument_list|)
operator|&&
sizeof|sizeof
argument_list|(
literal|"END-INFO-DIR-ENTRY"
argument_list|)
operator|-
literal|1
operator|==
name|lines
index|[
name|i
index|]
operator|.
name|size
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"END-INFO-DIR-ENTRY without matching START-INFO-DIR-ENTRY"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|start_of_this_entry
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"START-INFO-DIR-ENTRY without matching END-INFO-DIR-ENTRY"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we ignored the INFO-DIR-ENTRY directives, we need now go back      and plug the names of all the sections we found into every      element of the ENTRIES list.  */
if|if
condition|(
name|ignore_entries
operator|&&
operator|*
name|entries
condition|)
block|{
name|struct
name|spec_entry
modifier|*
name|entry
decl_stmt|;
for|for
control|(
name|entry
operator|=
operator|*
name|entries
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
block|{
name|entry
operator|->
name|entry_sections
operator|=
name|head
expr_stmt|;
name|entry
operator|->
name|entry_sections_tail
operator|=
name|tail
expr_stmt|;
block|}
block|}
return|return
name|n_entries
return|;
block|}
end_function

begin_comment
comment|/* Parse the dir file whose basename is BASE_NAME.  Find all the    nodes, and their menus, and the sections of their menus.  */
end_comment

begin_function
name|int
name|parse_dir_file
parameter_list|(
name|lines
parameter_list|,
name|nlines
parameter_list|,
name|nodes
parameter_list|,
name|base_name
parameter_list|)
name|struct
name|line_data
modifier|*
name|lines
decl_stmt|;
name|int
name|nlines
decl_stmt|;
name|struct
name|node
modifier|*
modifier|*
name|nodes
decl_stmt|;
specifier|const
name|char
modifier|*
name|base_name
decl_stmt|;
block|{
name|int
name|node_header_flag
init|=
literal|0
decl_stmt|;
name|int
name|something_deleted
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|*
name|nodes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlines
condition|;
name|i
operator|++
control|)
block|{
comment|/* Parse node header lines.  */
if|if
condition|(
name|node_header_flag
condition|)
block|{
name|int
name|j
decl_stmt|,
name|end
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|lines
index|[
name|i
index|]
operator|.
name|size
condition|;
name|j
operator|++
control|)
comment|/* Find the node name and store it in the `struct node'.  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
literal|"Node:"
argument_list|,
name|lines
index|[
name|i
index|]
operator|.
name|start
operator|+
name|j
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|char
modifier|*
name|line
init|=
name|lines
index|[
name|i
index|]
operator|.
name|start
decl_stmt|;
comment|/* Find the start of the node name.  */
name|j
operator|+=
literal|5
expr_stmt|;
while|while
condition|(
name|line
index|[
name|j
index|]
operator|==
literal|' '
operator|||
name|line
index|[
name|j
index|]
operator|==
literal|'\t'
condition|)
name|j
operator|++
expr_stmt|;
comment|/* Find the end of the node name.  */
name|end
operator|=
name|j
expr_stmt|;
while|while
condition|(
name|line
index|[
name|end
index|]
operator|!=
literal|0
operator|&&
name|line
index|[
name|end
index|]
operator|!=
literal|','
operator|&&
name|line
index|[
name|end
index|]
operator|!=
literal|'\n'
operator|&&
name|line
index|[
name|end
index|]
operator|!=
literal|'\t'
condition|)
name|end
operator|++
expr_stmt|;
operator|(
operator|*
name|nodes
operator|)
operator|->
name|name
operator|=
name|copy_string
argument_list|(
name|line
operator|+
name|j
argument_list|,
name|end
operator|-
name|j
argument_list|)
expr_stmt|;
block|}
name|node_header_flag
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Notice the start of a node.  */
if|if
condition|(
operator|*
name|lines
index|[
name|i
index|]
operator|.
name|start
operator|==
literal|037
condition|)
block|{
name|struct
name|node
modifier|*
name|next
init|=
operator|(
expr|struct
name|node
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|node
argument_list|)
argument_list|)
decl_stmt|;
name|next
operator|->
name|next
operator|=
operator|*
name|nodes
expr_stmt|;
name|next
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|next
operator|->
name|start_line
operator|=
name|i
expr_stmt|;
name|next
operator|->
name|end_line
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|menu_start
operator|=
name|NULL
expr_stmt|;
name|next
operator|->
name|sections
operator|=
name|NULL
expr_stmt|;
name|next
operator|->
name|last_section
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|nodes
operator|!=
literal|0
condition|)
operator|(
operator|*
name|nodes
operator|)
operator|->
name|end_line
operator|=
name|i
expr_stmt|;
comment|/* Fill in the end of the last menu section              of the previous node.  */
if|if
condition|(
operator|*
name|nodes
operator|!=
literal|0
operator|&&
operator|(
operator|*
name|nodes
operator|)
operator|->
name|last_section
operator|!=
literal|0
condition|)
operator|(
operator|*
name|nodes
operator|)
operator|->
name|last_section
operator|->
name|end_line
operator|=
name|i
expr_stmt|;
operator|*
name|nodes
operator|=
name|next
expr_stmt|;
comment|/* The following line is the header of this node;              parse it.  */
name|node_header_flag
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Notice the lines that start menus.  */
if|if
condition|(
operator|*
name|nodes
operator|!=
literal|0
operator|&&
operator|!
name|strncmp
argument_list|(
literal|"* Menu:"
argument_list|,
name|lines
index|[
name|i
index|]
operator|.
name|start
argument_list|,
literal|7
argument_list|)
condition|)
operator|(
operator|*
name|nodes
operator|)
operator|->
name|menu_start
operator|=
name|lines
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|start
expr_stmt|;
comment|/* Notice sections in menus.  */
if|if
condition|(
operator|*
name|nodes
operator|!=
literal|0
operator|&&
operator|(
operator|*
name|nodes
operator|)
operator|->
name|menu_start
operator|!=
literal|0
operator|&&
operator|*
name|lines
index|[
name|i
index|]
operator|.
name|start
operator|!=
literal|'\n'
operator|&&
operator|*
name|lines
index|[
name|i
index|]
operator|.
name|start
operator|!=
literal|'*'
operator|&&
operator|*
name|lines
index|[
name|i
index|]
operator|.
name|start
operator|!=
literal|' '
operator|&&
operator|*
name|lines
index|[
name|i
index|]
operator|.
name|start
operator|!=
literal|'\t'
condition|)
block|{
comment|/* Add this menu section to the node's list.              This list grows in forward order.  */
name|struct
name|menu_section
modifier|*
name|next
init|=
operator|(
expr|struct
name|menu_section
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|menu_section
argument_list|)
argument_list|)
decl_stmt|;
name|next
operator|->
name|start_line
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|next
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|end_line
operator|=
literal|0
expr_stmt|;
name|next
operator|->
name|name
operator|=
name|copy_string
argument_list|(
name|lines
index|[
name|i
index|]
operator|.
name|start
argument_list|,
name|lines
index|[
name|i
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|nodes
operator|)
operator|->
name|sections
condition|)
block|{
operator|(
operator|*
name|nodes
operator|)
operator|->
name|last_section
operator|->
name|next
operator|=
name|next
expr_stmt|;
operator|(
operator|*
name|nodes
operator|)
operator|->
name|last_section
operator|->
name|end_line
operator|=
name|i
expr_stmt|;
block|}
else|else
operator|(
operator|*
name|nodes
operator|)
operator|->
name|sections
operator|=
name|next
expr_stmt|;
operator|(
operator|*
name|nodes
operator|)
operator|->
name|last_section
operator|=
name|next
expr_stmt|;
block|}
comment|/* Check for an existing entry that should be deleted.          Delete all entries which specify this file name.  */
if|if
condition|(
operator|*
name|lines
index|[
name|i
index|]
operator|.
name|start
operator|==
literal|'*'
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|lines
index|[
name|i
index|]
operator|.
name|start
decl_stmt|;
name|p
operator|++
expr_stmt|;
comment|/* skip * */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
comment|/* ignore following spaces */
name|q
operator|=
name|p
expr_stmt|;
comment|/* remember this, it's the beginning of the menu item.  */
comment|/* Read menu item.  */
while|while
condition|(
operator|*
name|p
operator|!=
literal|0
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
comment|/* skip : */
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
comment|/* XEmacs-style entry, as in * Mew::Messaging.  */
if|if
condition|(
name|menu_item_equal
argument_list|(
name|q
argument_list|,
literal|':'
argument_list|,
name|base_name
argument_list|)
condition|)
block|{
name|lines
index|[
name|i
index|]
operator|.
name|delete
operator|=
literal|1
expr_stmt|;
name|something_deleted
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Emacs-style entry, as in * Emacs: (emacs).  */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
comment|/* skip spaces after : */
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
comment|/* if at parenthesized (FILENAME) */
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|menu_item_equal
argument_list|(
name|p
argument_list|,
literal|')'
argument_list|,
name|base_name
argument_list|)
condition|)
block|{
name|lines
index|[
name|i
index|]
operator|.
name|delete
operator|=
literal|1
expr_stmt|;
name|something_deleted
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Treat lines that start with whitespace          as continuations; if we are deleting an entry,          delete all its continuations as well.  */
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
operator|(
operator|*
name|lines
index|[
name|i
index|]
operator|.
name|start
operator|==
literal|' '
operator|||
operator|*
name|lines
index|[
name|i
index|]
operator|.
name|start
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|lines
index|[
name|i
index|]
operator|.
name|delete
operator|=
name|lines
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|delete
expr_stmt|;
block|}
block|}
comment|/* Finish the info about the end of the last node.  */
if|if
condition|(
operator|*
name|nodes
operator|!=
literal|0
condition|)
block|{
operator|(
operator|*
name|nodes
operator|)
operator|->
name|end_line
operator|=
name|nlines
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|nodes
operator|)
operator|->
name|last_section
operator|!=
literal|0
condition|)
operator|(
operator|*
name|nodes
operator|)
operator|->
name|last_section
operator|->
name|end_line
operator|=
name|nlines
expr_stmt|;
block|}
return|return
name|something_deleted
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|opened_dirfilename
decl_stmt|;
name|char
modifier|*
name|compression_program
decl_stmt|;
name|char
modifier|*
name|infile_sans_info
decl_stmt|;
name|char
modifier|*
name|infile
init|=
literal|0
decl_stmt|,
modifier|*
name|dirfile
init|=
literal|0
decl_stmt|;
name|unsigned
name|infilelen_sans_info
decl_stmt|;
comment|/* Record the text of the Info file, as a sequence of characters      and as a sequence of lines.  */
name|char
modifier|*
name|input_data
init|=
name|NULL
decl_stmt|;
name|int
name|input_size
init|=
literal|0
decl_stmt|;
name|struct
name|line_data
modifier|*
name|input_lines
init|=
name|NULL
decl_stmt|;
name|int
name|input_nlines
init|=
literal|0
decl_stmt|;
comment|/* Record here the specified section names and directory entries.  */
name|struct
name|spec_section
modifier|*
name|input_sections
init|=
name|NULL
decl_stmt|;
name|struct
name|spec_entry
modifier|*
name|entries_to_add
init|=
name|NULL
decl_stmt|;
name|int
name|n_entries_to_add
init|=
literal|0
decl_stmt|;
name|struct
name|spec_entry
modifier|*
name|default_entries_to_add
init|=
name|NULL
decl_stmt|;
name|int
name|n_default_entries_to_add
init|=
literal|0
decl_stmt|;
comment|/* Record the old text of the dir file, as plain characters,      as lines, and as nodes.  */
name|char
modifier|*
name|dir_data
decl_stmt|;
name|int
name|dir_size
decl_stmt|;
name|int
name|dir_nlines
decl_stmt|;
name|struct
name|line_data
modifier|*
name|dir_lines
decl_stmt|;
name|struct
name|node
modifier|*
name|dir_nodes
decl_stmt|;
comment|/* Nonzero means --delete was specified (just delete existing entries).  */
name|int
name|delete_flag
init|=
literal|0
decl_stmt|;
name|int
name|something_deleted
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means -q was specified.  */
name|int
name|quiet_flag
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SETLOCALE
comment|/* Set locale via LC_ALL.  */
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set the text message domain.  */
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|opt
init|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"i:d:e:s:hHr"
argument_list|,
name|longopts
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|opt
operator|==
name|EOF
condition|)
break|break;
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|0
case|:
comment|/* If getopt returns 0, then it has already processed a              long-named option.  We should do nothing.  */
break|break;
case|case
literal|1
case|:
name|abort
argument_list|()
expr_stmt|;
case|case
literal|'d'
case|:
if|if
condition|(
name|dirfile
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: Specify the Info directory only once.\n"
argument_list|)
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|suggest_asking_for_help
argument_list|()
expr_stmt|;
block|}
name|dirfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|dirfile
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: Specify the Info directory only once.\n"
argument_list|)
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|suggest_asking_for_help
argument_list|()
expr_stmt|;
block|}
name|dirfile
operator|=
name|concat
argument_list|(
name|optarg
argument_list|,
literal|""
argument_list|,
literal|"/dir"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
block|{
name|struct
name|spec_entry
modifier|*
name|next
init|=
operator|(
expr|struct
name|spec_entry
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|spec_entry
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|olen
init|=
name|strlen
argument_list|(
name|optarg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|optarg
operator|!=
literal|0
operator|&&
name|optarg
index|[
name|olen
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|optarg
operator|=
name|concat
argument_list|(
name|optarg
argument_list|,
literal|"\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|olen
operator|++
expr_stmt|;
block|}
name|next
operator|->
name|text
operator|=
name|optarg
expr_stmt|;
name|next
operator|->
name|text_len
operator|=
name|olen
expr_stmt|;
name|next
operator|->
name|entry_sections
operator|=
name|NULL
expr_stmt|;
name|next
operator|->
name|entry_sections_tail
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|opt
operator|==
literal|'e'
condition|)
block|{
name|next
operator|->
name|next
operator|=
name|entries_to_add
expr_stmt|;
name|entries_to_add
operator|=
name|next
expr_stmt|;
name|n_entries_to_add
operator|++
expr_stmt|;
block|}
else|else
block|{
name|next
operator|->
name|next
operator|=
name|default_entries_to_add
expr_stmt|;
name|default_entries_to_add
operator|=
name|next
expr_stmt|;
name|n_default_entries_to_add
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
name|print_help
argument_list|()
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'i'
case|:
if|if
condition|(
name|infile
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: Specify the Info file only once.\n"
argument_list|)
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|suggest_asking_for_help
argument_list|()
expr_stmt|;
block|}
name|infile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|delete_flag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
block|{
name|struct
name|spec_section
modifier|*
name|next
init|=
operator|(
expr|struct
name|spec_section
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|spec_section
argument_list|)
argument_list|)
decl_stmt|;
name|next
operator|->
name|name
operator|=
name|optarg
expr_stmt|;
name|next
operator|->
name|next
operator|=
name|input_sections
expr_stmt|;
name|next
operator|->
name|missing
operator|=
literal|1
expr_stmt|;
name|input_sections
operator|=
name|next
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
name|default_section
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|printf
argument_list|(
literal|"install-info (GNU %s) %s\n"
argument_list|,
name|PACKAGE
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Copyright (C) %s Free Software Foundation, Inc.\n\ There is NO warranty.  You may redistribute this software\n\ under the terms of the GNU General Public License.\n\ For more information about these matters, see the files named COPYING.\n"
argument_list|)
argument_list|,
literal|"1999"
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
default|default:
name|suggest_asking_for_help
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Interpret the non-option arguments as file names.  */
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
operator|++
name|optind
control|)
block|{
if|if
condition|(
name|infile
operator|==
literal|0
condition|)
name|infile
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|dirfile
operator|==
literal|0
condition|)
name|dirfile
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
else|else
name|error
argument_list|(
name|_
argument_list|(
literal|"excess command line argument `%s'"
argument_list|)
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|infile
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"No input file specified; try --help for more information."
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dirfile
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"No dir file specified; try --help for more information."
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the Info file and parse it into lines, unless we're deleting.  */
if|if
condition|(
operator|!
name|delete_flag
condition|)
block|{
name|input_data
operator|=
name|readfile
argument_list|(
name|infile
argument_list|,
operator|&
name|input_size
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|input_lines
operator|=
name|findlines
argument_list|(
name|input_data
argument_list|,
name|input_size
argument_list|,
operator|&
name|input_nlines
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|parse_input
argument_list|(
name|input_lines
argument_list|,
name|input_nlines
argument_list|,
operator|&
name|input_sections
argument_list|,
operator|&
name|entries_to_add
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|n_entries_to_add
condition|)
name|n_entries_to_add
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|n_entries_to_add
operator|==
literal|0
condition|)
block|{
name|entries_to_add
operator|=
name|default_entries_to_add
expr_stmt|;
name|n_entries_to_add
operator|=
name|n_default_entries_to_add
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|delete_flag
condition|)
block|{
if|if
condition|(
name|entries_to_add
operator|==
literal|0
condition|)
block|{
comment|/* No need to abort here, the original info file may not              have the requisite Texinfo commands.  This is not              something an installer should have to correct (it's a              problem for the maintainer), and there's no need to cause              subsequent parts of `make install' to fail.  */
name|warning
argument_list|(
name|_
argument_list|(
literal|"no info dir entry in `%s'"
argument_list|)
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If the entries came from the command-line arguments, their          entry_sections pointers are not yet set.  Walk the chain of          the entries and for each entry update entry_sections to point          to the head of the list of sections where this entry should          be put.  Note that all the entries specified on the command          line get put into ALL the sections we've got, either from the          Info file, or (under --section) from the command line,          because in the loop below every entry inherits the entire          chain of sections.  */
if|if
condition|(
name|n_entries_to_add
operator|>
literal|0
operator|&&
name|entries_to_add
operator|->
name|entry_sections
operator|==
name|NULL
condition|)
block|{
name|struct
name|spec_entry
modifier|*
name|ep
decl_stmt|;
comment|/* If we got no sections, default to "Miscellaneous".  */
if|if
condition|(
name|input_sections
operator|==
name|NULL
condition|)
block|{
name|input_sections
operator|=
operator|(
expr|struct
name|spec_section
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|spec_section
argument_list|)
argument_list|)
expr_stmt|;
name|input_sections
operator|->
name|name
operator|=
name|default_section
condition|?
name|default_section
else|:
literal|"Miscellaneous"
expr_stmt|;
name|input_sections
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|input_sections
operator|->
name|missing
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|ep
operator|=
name|entries_to_add
init|;
name|ep
condition|;
name|ep
operator|=
name|ep
operator|->
name|next
control|)
name|ep
operator|->
name|entry_sections
operator|=
name|input_sections
expr_stmt|;
block|}
block|}
comment|/* Now read in the Info dir file.  */
name|dir_data
operator|=
name|readfile
argument_list|(
name|dirfile
argument_list|,
operator|&
name|dir_size
argument_list|,
name|ensure_dirfile_exists
argument_list|,
operator|&
name|opened_dirfilename
argument_list|,
operator|&
name|compression_program
argument_list|)
expr_stmt|;
name|dir_lines
operator|=
name|findlines
argument_list|(
name|dir_data
argument_list|,
name|dir_size
argument_list|,
operator|&
name|dir_nlines
argument_list|)
expr_stmt|;
comment|/* We will be comparing the entries in the dir file against the      current filename, so need to strip off any directory prefix and/or      [.info][.gz] suffix.  */
block|{
name|char
modifier|*
name|infile_basename
init|=
name|infile
operator|+
name|strlen
argument_list|(
name|infile
argument_list|)
decl_stmt|;
if|if
condition|(
name|HAVE_DRIVE
argument_list|(
name|infile
argument_list|)
condition|)
name|infile
operator|+=
literal|2
expr_stmt|;
comment|/* get past the drive spec X: */
while|while
condition|(
name|infile_basename
operator|>
name|infile
operator|&&
operator|!
name|IS_SLASH
argument_list|(
name|infile_basename
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|infile_basename
operator|--
expr_stmt|;
name|infile_sans_info
operator|=
name|strip_info_suffix
argument_list|(
name|infile_basename
argument_list|)
expr_stmt|;
name|infilelen_sans_info
operator|=
name|strlen
argument_list|(
name|infile_sans_info
argument_list|)
expr_stmt|;
block|}
name|something_deleted
operator|=
name|parse_dir_file
argument_list|(
name|dir_lines
argument_list|,
name|dir_nlines
argument_list|,
operator|&
name|dir_nodes
argument_list|,
name|infile_sans_info
argument_list|)
expr_stmt|;
comment|/* Decide where to add the new entries (unless --delete was used).      Find the menu sections to add them in.      In each section, find the proper alphabetical place to add      each of the entries.  */
if|if
condition|(
operator|!
name|delete_flag
condition|)
block|{
name|struct
name|node
modifier|*
name|node
decl_stmt|;
name|struct
name|menu_section
modifier|*
name|section
decl_stmt|;
name|struct
name|spec_section
modifier|*
name|spec
decl_stmt|;
for|for
control|(
name|node
operator|=
name|dir_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
for|for
control|(
name|section
operator|=
name|node
operator|->
name|sections
init|;
name|section
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
name|section
operator|->
name|end_line
init|;
name|i
operator|>
name|section
operator|->
name|start_line
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|dir_lines
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|size
operator|!=
literal|0
condition|)
break|break;
name|section
operator|->
name|end_line
operator|=
name|i
expr_stmt|;
for|for
control|(
name|spec
operator|=
name|input_sections
init|;
name|spec
condition|;
name|spec
operator|=
name|spec
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|spec
operator|->
name|name
argument_list|,
name|section
operator|->
name|name
argument_list|)
condition|)
break|break;
if|if
condition|(
name|spec
condition|)
block|{
name|int
name|add_at_line
init|=
name|section
operator|->
name|end_line
decl_stmt|;
name|struct
name|spec_entry
modifier|*
name|entry
decl_stmt|;
comment|/* Say we have found at least one section with this name,                    so we need not add such a section.  */
name|spec
operator|->
name|missing
operator|=
literal|0
expr_stmt|;
comment|/* For each entry, find the right place in this section                    to add it.  */
for|for
control|(
name|entry
operator|=
name|entries_to_add
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
block|{
comment|/* Did they at all want this entry to be put into                        this section?  */
for|for
control|(
name|spec
operator|=
name|entry
operator|->
name|entry_sections
init|;
name|spec
operator|&&
name|spec
operator|!=
name|entry
operator|->
name|entry_sections_tail
condition|;
name|spec
operator|=
name|spec
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|spec
operator|->
name|name
argument_list|,
name|section
operator|->
name|name
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|spec
operator|||
name|spec
operator|==
name|entry
operator|->
name|entry_sections_tail
condition|)
continue|continue;
comment|/* Subtract one because dir_lines is zero-based,                        but the `end_line' and `start_line' members are                        one-based.  */
for|for
control|(
name|i
operator|=
name|section
operator|->
name|end_line
operator|-
literal|1
init|;
name|i
operator|>=
name|section
operator|->
name|start_line
operator|-
literal|1
condition|;
name|i
operator|--
control|)
block|{
comment|/* If an entry exists with the same name,                            and was not marked for deletion                            (which means it is for some other file),                            we are in trouble.  */
if|if
condition|(
name|dir_lines
index|[
name|i
index|]
operator|.
name|start
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|menu_line_equal
argument_list|(
name|entry
operator|->
name|text
argument_list|,
name|entry
operator|->
name|text_len
argument_list|,
name|dir_lines
index|[
name|i
index|]
operator|.
name|start
argument_list|,
name|dir_lines
index|[
name|i
index|]
operator|.
name|size
argument_list|)
operator|&&
operator|!
name|dir_lines
index|[
name|i
index|]
operator|.
name|delete
condition|)
block|{
if|if
condition|(
name|quiet_flag
condition|)
name|dir_lines
index|[
name|i
index|]
operator|.
name|delete
operator|=
literal|1
expr_stmt|;
else|else
name|fatal
argument_list|(
name|_
argument_list|(
literal|"menu item `%s' already exists, for file `%s'"
argument_list|)
argument_list|,
name|extract_menu_item_name
argument_list|(
name|entry
operator|->
name|text
argument_list|)
argument_list|,
name|extract_menu_file_name
argument_list|(
name|dir_lines
index|[
name|i
index|]
operator|.
name|start
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dir_lines
index|[
name|i
index|]
operator|.
name|start
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|menu_line_lessp
argument_list|(
name|entry
operator|->
name|text
argument_list|,
name|entry
operator|->
name|text_len
argument_list|,
name|dir_lines
index|[
name|i
index|]
operator|.
name|start
argument_list|,
name|dir_lines
index|[
name|i
index|]
operator|.
name|size
argument_list|)
condition|)
name|add_at_line
operator|=
name|i
expr_stmt|;
block|}
name|insert_entry_here
argument_list|(
name|entry
argument_list|,
name|add_at_line
argument_list|,
name|dir_lines
argument_list|,
name|n_entries_to_add
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Mark the end of the Top node as the place to add any          new sections that are needed.  */
for|for
control|(
name|node
operator|=
name|dir_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
name|node
operator|->
name|name
operator|&&
name|strcmp
argument_list|(
name|node
operator|->
name|name
argument_list|,
literal|"Top"
argument_list|)
operator|==
literal|0
condition|)
name|dir_lines
index|[
name|node
operator|->
name|end_line
index|]
operator|.
name|add_sections_before
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|delete_flag
operator|&&
operator|!
name|something_deleted
operator|&&
operator|!
name|quiet_flag
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"no entries found for `%s'; nothing deleted"
argument_list|)
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|output_dirfile
argument_list|(
name|opened_dirfilename
argument_list|,
name|dir_nlines
argument_list|,
name|dir_lines
argument_list|,
name|n_entries_to_add
argument_list|,
name|entries_to_add
argument_list|,
name|input_sections
argument_list|,
name|compression_program
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Divide the text at DATA (of SIZE bytes) into lines.    Return a vector of struct line_data describing the lines.    Store the length of that vector into *NLINESP.  */
end_comment

begin_function
name|struct
name|line_data
modifier|*
name|findlines
parameter_list|(
name|data
parameter_list|,
name|size
parameter_list|,
name|nlinesp
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
modifier|*
name|nlinesp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|lineflag
init|=
literal|1
decl_stmt|;
name|int
name|lines_allocated
init|=
literal|511
decl_stmt|;
name|int
name|filled
init|=
literal|0
decl_stmt|;
name|struct
name|line_data
modifier|*
name|lines
init|=
name|xmalloc
argument_list|(
operator|(
name|lines_allocated
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line_data
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lineflag
condition|)
block|{
if|if
condition|(
name|filled
operator|==
name|lines_allocated
condition|)
block|{
comment|/* try to keep things somewhat page-aligned */
name|lines_allocated
operator|=
operator|(
operator|(
name|lines_allocated
operator|+
literal|1
operator|)
operator|*
literal|2
operator|)
operator|-
literal|1
expr_stmt|;
name|lines
operator|=
name|xrealloc
argument_list|(
name|lines
argument_list|,
operator|(
name|lines_allocated
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line_data
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lines
index|[
name|filled
index|]
operator|.
name|start
operator|=
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|lines
index|[
name|filled
index|]
operator|.
name|add_entries_before
operator|=
literal|0
expr_stmt|;
name|lines
index|[
name|filled
index|]
operator|.
name|add_sections_before
operator|=
literal|0
expr_stmt|;
name|lines
index|[
name|filled
index|]
operator|.
name|delete
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|filled
operator|>
literal|0
condition|)
name|lines
index|[
name|filled
operator|-
literal|1
index|]
operator|.
name|size
operator|=
name|lines
index|[
name|filled
index|]
operator|.
name|start
operator|-
name|lines
index|[
name|filled
operator|-
literal|1
index|]
operator|.
name|start
operator|-
literal|1
expr_stmt|;
name|filled
operator|++
expr_stmt|;
block|}
name|lineflag
operator|=
operator|(
name|data
index|[
name|i
index|]
operator|==
literal|'\n'
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|filled
operator|>
literal|0
condition|)
name|lines
index|[
name|filled
operator|-
literal|1
index|]
operator|.
name|size
operator|=
operator|&
name|data
index|[
name|i
index|]
operator|-
name|lines
index|[
name|filled
operator|-
literal|1
index|]
operator|.
name|start
operator|-
name|lineflag
expr_stmt|;
comment|/* Do not leave garbage in the last element.  */
name|lines
index|[
name|filled
index|]
operator|.
name|start
operator|=
name|NULL
expr_stmt|;
name|lines
index|[
name|filled
index|]
operator|.
name|add_entries_before
operator|=
name|NULL
expr_stmt|;
name|lines
index|[
name|filled
index|]
operator|.
name|add_sections_before
operator|=
literal|0
expr_stmt|;
name|lines
index|[
name|filled
index|]
operator|.
name|delete
operator|=
literal|0
expr_stmt|;
name|lines
index|[
name|filled
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|nlinesp
operator|=
name|filled
expr_stmt|;
return|return
name|lines
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare the menu item names in LINE1 (line length LEN1)    and LINE2 (line length LEN2).  Return 1 if the item name    in LINE1 is less, 0 otherwise.  */
end_comment

begin_function
name|int
name|menu_line_lessp
parameter_list|(
name|line1
parameter_list|,
name|len1
parameter_list|,
name|line2
parameter_list|,
name|len2
parameter_list|)
name|char
modifier|*
name|line1
decl_stmt|;
name|int
name|len1
decl_stmt|;
name|char
modifier|*
name|line2
decl_stmt|;
name|int
name|len2
decl_stmt|;
block|{
name|int
name|minlen
init|=
operator|(
name|len1
operator|<
name|len2
condition|?
name|len1
else|:
name|len2
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|minlen
condition|;
name|i
operator|++
control|)
block|{
comment|/* If one item name is a prefix of the other,          the former one is less.  */
if|if
condition|(
name|line1
index|[
name|i
index|]
operator|==
literal|':'
operator|&&
name|line2
index|[
name|i
index|]
operator|!=
literal|':'
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|line2
index|[
name|i
index|]
operator|==
literal|':'
operator|&&
name|line1
index|[
name|i
index|]
operator|!=
literal|':'
condition|)
return|return
literal|0
return|;
comment|/* If they both continue and differ, one is less.  */
if|if
condition|(
name|line1
index|[
name|i
index|]
operator|<
name|line2
index|[
name|i
index|]
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|line1
index|[
name|i
index|]
operator|>
name|line2
index|[
name|i
index|]
condition|)
return|return
literal|0
return|;
block|}
comment|/* With a properly formatted dir file,      we can only get here if the item names are equal.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compare the menu item names in LINE1 (line length LEN1)    and LINE2 (line length LEN2).  Return 1 if the item names are equal,    0 otherwise.  */
end_comment

begin_function
name|int
name|menu_line_equal
parameter_list|(
name|line1
parameter_list|,
name|len1
parameter_list|,
name|line2
parameter_list|,
name|len2
parameter_list|)
name|char
modifier|*
name|line1
decl_stmt|;
name|int
name|len1
decl_stmt|;
name|char
modifier|*
name|line2
decl_stmt|;
name|int
name|len2
decl_stmt|;
block|{
name|int
name|minlen
init|=
operator|(
name|len1
operator|<
name|len2
condition|?
name|len1
else|:
name|len2
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|minlen
condition|;
name|i
operator|++
control|)
block|{
comment|/* If both item names end here, they are equal.  */
if|if
condition|(
name|line1
index|[
name|i
index|]
operator|==
literal|':'
operator|&&
name|line2
index|[
name|i
index|]
operator|==
literal|':'
condition|)
return|return
literal|1
return|;
comment|/* If they both continue and differ, one is less.  */
if|if
condition|(
name|line1
index|[
name|i
index|]
operator|!=
name|line2
index|[
name|i
index|]
condition|)
return|return
literal|0
return|;
block|}
comment|/* With a properly formatted dir file,      we can only get here if the item names are equal.  */
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is the comparison function for qsort    for a vector of pointers to struct spec_section.    Compare the section names.  */
end_comment

begin_function
name|int
name|compare_section_names
parameter_list|(
name|sec1
parameter_list|,
name|sec2
parameter_list|)
name|struct
name|spec_section
modifier|*
modifier|*
name|sec1
decl_stmt|,
decl|*
modifier|*
name|sec2
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|name1
init|=
operator|(
operator|*
name|sec1
operator|)
operator|->
name|name
decl_stmt|;
name|char
modifier|*
name|name2
init|=
operator|(
operator|*
name|sec2
operator|)
operator|->
name|name
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|name1
argument_list|,
name|name2
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* This is the comparison function for qsort    for a vector of pointers to struct spec_entry.    Compare the entries' text.  */
end_comment

begin_function
name|int
name|compare_entries_text
parameter_list|(
name|entry1
parameter_list|,
name|entry2
parameter_list|)
name|struct
name|spec_entry
modifier|*
modifier|*
name|entry1
decl_stmt|,
decl|*
modifier|*
name|entry2
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|text1
init|=
operator|(
operator|*
name|entry1
operator|)
operator|->
name|text
decl_stmt|;
name|char
modifier|*
name|text2
init|=
operator|(
operator|*
name|entry2
operator|)
operator|->
name|text
decl_stmt|;
name|char
modifier|*
name|colon1
init|=
name|strchr
argument_list|(
name|text1
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|colon2
init|=
name|strchr
argument_list|(
name|text2
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
name|int
name|len1
decl_stmt|,
name|len2
decl_stmt|;
if|if
condition|(
operator|!
name|colon1
condition|)
name|len1
operator|=
name|strlen
argument_list|(
name|text1
argument_list|)
expr_stmt|;
else|else
name|len1
operator|=
name|colon1
operator|-
name|text1
expr_stmt|;
if|if
condition|(
operator|!
name|colon2
condition|)
name|len2
operator|=
name|strlen
argument_list|(
name|text2
argument_list|)
expr_stmt|;
else|else
name|len2
operator|=
name|colon2
operator|-
name|text2
expr_stmt|;
return|return
name|strncmp
argument_list|(
name|text1
argument_list|,
name|text2
argument_list|,
name|len1
operator|<=
name|len2
condition|?
name|len1
else|:
name|len2
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Insert ENTRY into the add_entries_before vector    for line number LINE_NUMBER of the dir file.    DIR_LINES and N_ENTRIES carry information from like-named variables    in main.  */
end_comment

begin_function
name|void
name|insert_entry_here
parameter_list|(
name|entry
parameter_list|,
name|line_number
parameter_list|,
name|dir_lines
parameter_list|,
name|n_entries
parameter_list|)
name|struct
name|spec_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|line_number
decl_stmt|;
name|struct
name|line_data
modifier|*
name|dir_lines
decl_stmt|;
name|int
name|n_entries
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|dir_lines
index|[
name|line_number
index|]
operator|.
name|add_entries_before
operator|==
literal|0
condition|)
block|{
name|dir_lines
index|[
name|line_number
index|]
operator|.
name|add_entries_before
operator|=
operator|(
expr|struct
name|spec_entry
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_entries
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|spec_entry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_entries
condition|;
name|i
operator|++
control|)
name|dir_lines
index|[
name|line_number
index|]
operator|.
name|add_entries_before
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Find the place where this entry belongs.  If there are already      several entries to add before LINE_NUMBER, make sure they are in      alphabetical order.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_entries
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dir_lines
index|[
name|line_number
index|]
operator|.
name|add_entries_before
index|[
name|i
index|]
operator|==
literal|0
operator|||
name|menu_line_lessp
argument_list|(
name|entry
operator|->
name|text
argument_list|,
name|strlen
argument_list|(
name|entry
operator|->
name|text
argument_list|)
argument_list|,
name|dir_lines
index|[
name|line_number
index|]
operator|.
name|add_entries_before
index|[
name|i
index|]
operator|->
name|text
argument_list|,
name|strlen
argument_list|(
name|dir_lines
index|[
name|line_number
index|]
operator|.
name|add_entries_before
index|[
name|i
index|]
operator|->
name|text
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|n_entries
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If we need to plug ENTRY into the middle of the      ADD_ENTRIES_BEFORE array, move the entries which should be output      after this one down one notch, before adding a new one.  */
if|if
condition|(
name|dir_lines
index|[
name|line_number
index|]
operator|.
name|add_entries_before
index|[
name|i
index|]
operator|!=
literal|0
condition|)
for|for
control|(
name|j
operator|=
name|n_entries
operator|-
literal|1
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|--
control|)
name|dir_lines
index|[
name|line_number
index|]
operator|.
name|add_entries_before
index|[
name|j
index|]
operator|=
name|dir_lines
index|[
name|line_number
index|]
operator|.
name|add_entries_before
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|dir_lines
index|[
name|line_number
index|]
operator|.
name|add_entries_before
index|[
name|i
index|]
operator|=
name|entry
expr_stmt|;
block|}
end_function

end_unit

