begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Prepare TeX index dribble output into an actual index.    $Id: texindex.c,v 1.6 1996/10/04 18:21:30 karl Exp $     Copyright (C) 1987, 91, 92, 96 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_define
define|#
directive|define
name|TEXINDEX_VERSION_STRING
value|"GNU Texindex (Texinfo 3.9) 2.1"
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|emacs
argument_list|)
end_if

begin_include
include|#
directive|include
file|"../src/config.h"
end_include

begin_comment
comment|/* Some s/os.h files redefine these. */
end_comment

begin_undef
undef|#
directive|undef
name|read
end_undef

begin_undef
undef|#
directive|undef
name|close
end_undef

begin_undef
undef|#
directive|undef
name|write
end_undef

begin_undef
undef|#
directive|undef
name|open
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STRING_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STRING_H */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_STRCHR
argument_list|)
end_if

begin_function_decl
name|char
modifier|*
name|strrchr
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_STRCHR */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !STDC_HEADERS */
end_comment

begin_decl_stmt
name|char
modifier|*
name|getenv
argument_list|()
decl_stmt|,
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|realloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !STDC_HEADERS */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_UNISTD_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !HAVE_UNISTD_H */
end_comment

begin_function_decl
name|off_t
name|lseek
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_UNISTD_H */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_MEMSET
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|memset
end_undef

begin_define
define|#
directive|define
name|memset
parameter_list|(
name|ptr
parameter_list|,
name|ignore
parameter_list|,
name|count
parameter_list|)
value|bzero (ptr, count)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<file.h>
end_include

begin_define
define|#
directive|define
name|TI_NO_ERROR
value|((1<< 28) | 1)
end_define

begin_define
define|#
directive|define
name|TI_FATAL_ERROR
value|((1<< 28) | 4)
end_define

begin_define
define|#
directive|define
name|unlink
value|delete
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !VMS */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_FCNTL_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_FCNTL_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_AIX
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !AIX&& _POSIX_VERSION */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_SYS_FCNTL_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_FCNTL_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_AIX&& _POSIX_VERSION */
end_comment

begin_define
define|#
directive|define
name|TI_NO_ERROR
value|0
end_define

begin_define
define|#
directive|define
name|TI_FATAL_ERROR
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !VMS */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SEEK_SET
argument_list|)
end_if

begin_define
define|#
directive|define
name|SEEK_SET
value|0
end_define

begin_define
define|#
directive|define
name|SEEK_CUR
value|1
end_define

begin_define
define|#
directive|define
name|SEEK_END
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SEEK_SET */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|errno
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|strerror
end_ifndef

begin_function_decl
specifier|extern
name|char
modifier|*
name|strerror
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* When sorting in core, this structure describes one line    and the position and length of its first keyfield.  */
end_comment

begin_struct
struct|struct
name|lineinfo
block|{
name|char
modifier|*
name|text
decl_stmt|;
comment|/* The actual text of the line. */
union|union
block|{
name|char
modifier|*
name|text
decl_stmt|;
comment|/* The start of the key (for textual comparison). */
name|long
name|number
decl_stmt|;
comment|/* The numeric value (for numeric comparison). */
block|}
name|key
union|;
name|long
name|keylen
decl_stmt|;
comment|/* Length of KEY field. */
block|}
struct|;
end_struct

begin_comment
comment|/* This structure describes a field to use as a sort key. */
end_comment

begin_struct
struct|struct
name|keyfield
block|{
name|int
name|startwords
decl_stmt|;
comment|/* Number of words to skip. */
name|int
name|startchars
decl_stmt|;
comment|/* Number of additional chars to skip. */
name|int
name|endwords
decl_stmt|;
comment|/* Number of words to ignore at end. */
name|int
name|endchars
decl_stmt|;
comment|/* Ditto for characters of last word. */
name|char
name|ignore_blanks
decl_stmt|;
comment|/* Non-zero means ignore spaces and tabs. */
name|char
name|fold_case
decl_stmt|;
comment|/* Non-zero means case doesn't matter. */
name|char
name|reverse
decl_stmt|;
comment|/* Non-zero means compare in reverse order. */
name|char
name|numeric
decl_stmt|;
comment|/* Non-zeros means field is ASCII numeric. */
name|char
name|positional
decl_stmt|;
comment|/* Sort according to file position. */
name|char
name|braced
decl_stmt|;
comment|/* Count balanced-braced groupings as fields. */
block|}
struct|;
end_struct

begin_comment
comment|/* Vector of keyfields to use. */
end_comment

begin_decl_stmt
name|struct
name|keyfield
name|keyfields
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of keyfields stored in that vector.  */
end_comment

begin_decl_stmt
name|int
name|num_keyfields
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector of input file names, terminated with a null pointer. */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|infiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector of corresponding output file names, or NULL, meaning default it    (add an `s' to the end). */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|outfiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of `infiles'. */
end_comment

begin_decl_stmt
name|int
name|num_infiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the array of pointers to lines being sorted. */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|linearray
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The allocated length of `linearray'. */
end_comment

begin_decl_stmt
name|long
name|nlines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Directory to use for temporary files.  On Unix, it ends with a slash.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tempdir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Start of filename to use for temporary files.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tempbase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of last temporary file.  */
end_comment

begin_decl_stmt
name|int
name|tempcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of last temporary file already deleted.    Temporary files are deleted by `flush_tempfiles' in order of creation.  */
end_comment

begin_decl_stmt
name|int
name|last_deleted_tempcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During in-core sort, this points to the base of the data block    which contains all the lines of data.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|text_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Additional command switches .*/
end_comment

begin_comment
comment|/* Nonzero means do not delete tempfiles -- for debugging. */
end_comment

begin_decl_stmt
name|int
name|keep_tempfiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name this program was run with. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations of functions in this file. */
end_comment

begin_function_decl
name|void
name|decode_command
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sort_in_core
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sort_offline
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
modifier|*
name|parsefile
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|find_field
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|find_pos
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|find_value
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|find_braced_pos
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|find_braced_end
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|writelines
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|compare_field
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|compare_full
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|readline
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|merge_files
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|merge_direct
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pfatal_with_name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fatal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|void
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|concat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|maketempname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|flush_tempfiles
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|tempcopy
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_define
define|#
directive|define
name|MAX_IN_CORE_SORT
value|500000
end_define

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|tempcount
operator|=
literal|0
expr_stmt|;
name|last_deleted_tempcount
operator|=
literal|0
expr_stmt|;
name|program_name
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|program_name
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|program_name
operator|++
expr_stmt|;
else|else
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* Describe the kind of sorting to do. */
comment|/* The first keyfield uses the first braced field and folds case. */
name|keyfields
index|[
literal|0
index|]
operator|.
name|braced
operator|=
literal|1
expr_stmt|;
name|keyfields
index|[
literal|0
index|]
operator|.
name|fold_case
operator|=
literal|1
expr_stmt|;
name|keyfields
index|[
literal|0
index|]
operator|.
name|endwords
operator|=
operator|-
literal|1
expr_stmt|;
name|keyfields
index|[
literal|0
index|]
operator|.
name|endchars
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* The second keyfield uses the second braced field, numerically. */
name|keyfields
index|[
literal|1
index|]
operator|.
name|braced
operator|=
literal|1
expr_stmt|;
name|keyfields
index|[
literal|1
index|]
operator|.
name|numeric
operator|=
literal|1
expr_stmt|;
name|keyfields
index|[
literal|1
index|]
operator|.
name|startwords
operator|=
literal|1
expr_stmt|;
name|keyfields
index|[
literal|1
index|]
operator|.
name|endwords
operator|=
operator|-
literal|1
expr_stmt|;
name|keyfields
index|[
literal|1
index|]
operator|.
name|endchars
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* The third keyfield (which is ignored while discarding duplicates)      compares the whole line. */
name|keyfields
index|[
literal|2
index|]
operator|.
name|endwords
operator|=
operator|-
literal|1
expr_stmt|;
name|keyfields
index|[
literal|2
index|]
operator|.
name|endchars
operator|=
operator|-
literal|1
expr_stmt|;
name|decode_command
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|tempbase
operator|=
name|mktemp
argument_list|(
name|concat
argument_list|(
literal|"txiXXXXXX"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Process input files completely, one by one.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_infiles
condition|;
name|i
operator|++
control|)
block|{
name|int
name|desc
decl_stmt|;
name|long
name|ptr
decl_stmt|;
name|char
modifier|*
name|outfile
decl_stmt|;
name|desc
operator|=
name|open
argument_list|(
name|infiles
index|[
name|i
index|]
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|infiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|desc
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|long
operator|)
name|lseek
argument_list|(
name|desc
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|outfile
operator|=
name|outfiles
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|outfile
condition|)
block|{
name|outfile
operator|=
name|concat
argument_list|(
name|infiles
index|[
name|i
index|]
argument_list|,
literal|"s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ptr
operator|<
name|MAX_IN_CORE_SORT
condition|)
comment|/* Sort a small amount of data. */
name|sort_in_core
argument_list|(
name|infiles
index|[
name|i
index|]
argument_list|,
name|ptr
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
else|else
name|sort_offline
argument_list|(
name|infiles
index|[
name|i
index|]
argument_list|,
name|ptr
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
name|flush_tempfiles
argument_list|(
name|tempcount
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|TI_NO_ERROR
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|long_name
decl_stmt|;
name|char
modifier|*
name|short_name
decl_stmt|;
name|int
modifier|*
name|variable_ref
decl_stmt|;
name|int
name|variable_value
decl_stmt|;
name|char
modifier|*
name|arg_name
decl_stmt|;
name|char
modifier|*
name|doc_string
decl_stmt|;
block|}
name|TEXINDEX_OPTION
typedef|;
end_typedef

begin_decl_stmt
name|TEXINDEX_OPTION
name|texindex_options
index|[]
init|=
block|{
block|{
literal|"--keep"
block|,
literal|"-k"
block|,
operator|&
name|keep_tempfiles
block|,
literal|1
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
literal|"keep temporary files around after processing"
block|}
block|,
block|{
literal|"--no-keep"
block|,
literal|0
block|,
operator|&
name|keep_tempfiles
block|,
literal|0
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
literal|"do not keep temporary files around after processing (default)"
block|}
block|,
block|{
literal|"--output"
block|,
literal|"-o"
block|,
operator|(
name|int
operator|*
operator|)
name|NULL
block|,
literal|0
block|,
literal|"FILE"
block|,
literal|"send output to FILE"
block|}
block|,
block|{
literal|"--version"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|int
operator|*
operator|)
name|NULL
block|,
literal|0
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
literal|"display version information and exit"
block|}
block|,
block|{
literal|"--help"
block|,
literal|"-h"
block|,
operator|(
name|int
operator|*
operator|)
name|NULL
block|,
literal|0
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
literal|"display this help and exit"
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|int
operator|*
operator|)
name|NULL
block|,
literal|0
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|usage
parameter_list|(
name|result_value
parameter_list|)
name|int
name|result_value
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|result_value
condition|?
name|stderr
else|:
name|stdout
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Usage: %s [OPTION]... FILE...\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Generate a sorted index for each TeX output FILE.\n"
argument_list|)
expr_stmt|;
comment|/* Avoid trigraph nonsense.  */
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"Usually FILE... is `foo.??\' for a document `foo.texi'.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nOptions:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|texindex_options
index|[
name|i
index|]
operator|.
name|long_name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|texindex_options
index|[
name|i
index|]
operator|.
name|short_name
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s, "
argument_list|,
name|texindex_options
index|[
name|i
index|]
operator|.
name|short_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s %s"
argument_list|,
name|texindex_options
index|[
name|i
index|]
operator|.
name|long_name
argument_list|,
name|texindex_options
index|[
name|i
index|]
operator|.
name|arg_name
condition|?
name|texindex_options
index|[
name|i
index|]
operator|.
name|arg_name
else|:
literal|""
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\n"
argument_list|,
name|texindex_options
index|[
name|i
index|]
operator|.
name|doc_string
argument_list|)
expr_stmt|;
block|}
name|puts
argument_list|(
literal|"\nEmail bug reports to bug-texinfo@prep.ai.mit.edu."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|result_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decode the command line arguments to set the parameter variables    and set up the vector of keyfields and the vector of input files. */
end_comment

begin_function
name|void
name|decode_command
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|arg_index
init|=
literal|1
decl_stmt|;
name|int
name|optc
decl_stmt|;
name|char
modifier|*
modifier|*
name|ip
decl_stmt|;
name|char
modifier|*
modifier|*
name|op
decl_stmt|;
comment|/* Store default values into parameter variables. */
name|tempdir
operator|=
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
name|tempdir
operator|==
name|NULL
condition|)
name|tempdir
operator|=
literal|"sys$scratch:"
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|tempdir
operator|==
name|NULL
condition|)
name|tempdir
operator|=
literal|"/tmp/"
expr_stmt|;
else|else
name|tempdir
operator|=
name|concat
argument_list|(
name|tempdir
argument_list|,
literal|"/"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|keep_tempfiles
operator|=
literal|0
expr_stmt|;
comment|/* Allocate ARGC input files, which must be enough.  */
name|infiles
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|outfiles
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|=
name|infiles
expr_stmt|;
name|op
operator|=
name|outfiles
expr_stmt|;
while|while
condition|(
name|arg_index
operator|<
name|argc
condition|)
block|{
name|char
modifier|*
name|arg
init|=
name|argv
index|[
name|arg_index
operator|++
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--version"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|puts
argument_list|(
name|TEXINDEX_VERSION_STRING
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"Copyright (C) 1996 Free Software Foundation, Inc.\n\ There is NO warranty.  You may redistribute this software\n\ under the terms of the GNU General Public License.\n\ For more information about these matters, see the files named COPYING."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--keep"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-k"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|keep_tempfiles
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--help"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-h"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|usage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--output"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-o"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|argv
index|[
name|arg_index
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|arg_index
operator|++
expr_stmt|;
if|if
condition|(
name|op
operator|>
name|outfiles
condition|)
operator|*
operator|(
name|op
operator|-
literal|1
operator|)
operator|=
name|argv
index|[
name|arg_index
index|]
expr_stmt|;
block|}
else|else
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ip
operator|++
operator|=
name|arg
expr_stmt|;
operator|*
name|op
operator|++
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Record number of keyfields and terminate list of filenames. */
name|num_infiles
operator|=
name|ip
operator|-
name|infiles
expr_stmt|;
operator|*
name|ip
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|num_infiles
operator|==
literal|0
condition|)
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a name for a temporary file. */
end_comment

begin_function
name|char
modifier|*
name|maketempname
parameter_list|(
name|count
parameter_list|)
name|int
name|count
decl_stmt|;
block|{
name|char
name|tempsuffix
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|tempsuffix
argument_list|,
literal|"%d"
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
name|concat
argument_list|(
name|tempdir
argument_list|,
name|tempbase
argument_list|,
name|tempsuffix
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Delete all temporary files up to TO_COUNT. */
end_comment

begin_function
name|void
name|flush_tempfiles
parameter_list|(
name|to_count
parameter_list|)
name|int
name|to_count
decl_stmt|;
block|{
if|if
condition|(
name|keep_tempfiles
condition|)
return|return;
while|while
condition|(
name|last_deleted_tempcount
operator|<
name|to_count
condition|)
name|unlink
argument_list|(
name|maketempname
argument_list|(
operator|++
name|last_deleted_tempcount
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the input file open on IDESC into a temporary file    and return the temporary file name. */
end_comment

begin_define
define|#
directive|define
name|BUFSIZE
value|1024
end_define

begin_function
name|char
modifier|*
name|tempcopy
parameter_list|(
name|idesc
parameter_list|)
name|int
name|idesc
decl_stmt|;
block|{
name|char
modifier|*
name|outfile
init|=
name|maketempname
argument_list|(
operator|++
name|tempcount
argument_list|)
decl_stmt|;
name|int
name|odesc
decl_stmt|;
name|char
name|buffer
index|[
name|BUFSIZE
index|]
decl_stmt|;
name|odesc
operator|=
name|open
argument_list|(
name|outfile
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|odesc
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|nread
init|=
name|read
argument_list|(
name|idesc
argument_list|,
name|buffer
argument_list|,
name|BUFSIZE
argument_list|)
decl_stmt|;
name|write
argument_list|(
name|odesc
argument_list|,
name|buffer
argument_list|,
name|nread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nread
condition|)
break|break;
block|}
name|close
argument_list|(
name|odesc
argument_list|)
expr_stmt|;
return|return
name|outfile
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare LINE1 and LINE2 according to the specified set of keyfields. */
end_comment

begin_function
name|int
name|compare_full
parameter_list|(
name|line1
parameter_list|,
name|line2
parameter_list|)
name|char
modifier|*
modifier|*
name|line1
decl_stmt|,
decl|*
modifier|*
name|line2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
comment|/* Compare using the first keyfield;      if that does not distinguish the lines, try the second keyfield;      and so on. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_keyfields
condition|;
name|i
operator|++
control|)
block|{
name|long
name|length1
decl_stmt|,
name|length2
decl_stmt|;
name|char
modifier|*
name|start1
init|=
name|find_field
argument_list|(
operator|&
name|keyfields
index|[
name|i
index|]
argument_list|,
operator|*
name|line1
argument_list|,
operator|&
name|length1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|start2
init|=
name|find_field
argument_list|(
operator|&
name|keyfields
index|[
name|i
index|]
argument_list|,
operator|*
name|line2
argument_list|,
operator|&
name|length2
argument_list|)
decl_stmt|;
name|int
name|tem
init|=
name|compare_field
argument_list|(
operator|&
name|keyfields
index|[
name|i
index|]
argument_list|,
name|start1
argument_list|,
name|length1
argument_list|,
operator|*
name|line1
operator|-
name|text_base
argument_list|,
name|start2
argument_list|,
name|length2
argument_list|,
operator|*
name|line2
operator|-
name|text_base
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
condition|)
block|{
if|if
condition|(
name|keyfields
index|[
name|i
index|]
operator|.
name|reverse
condition|)
return|return
operator|-
name|tem
return|;
return|return
name|tem
return|;
block|}
block|}
return|return
literal|0
return|;
comment|/* Lines match exactly. */
block|}
end_block

begin_comment
comment|/* Compare LINE1 and LINE2, described by structures    in which the first keyfield is identified in advance.    For positional sorting, assumes that the order of the lines in core    reflects their nominal order.  */
end_comment

begin_function
name|int
name|compare_prepared
parameter_list|(
name|line1
parameter_list|,
name|line2
parameter_list|)
name|struct
name|lineinfo
modifier|*
name|line1
decl_stmt|,
decl|*
name|line2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|tem
decl_stmt|;
name|char
modifier|*
name|text1
decl_stmt|,
modifier|*
name|text2
decl_stmt|;
comment|/* Compare using the first keyfield, which has been found for us already. */
if|if
condition|(
name|keyfields
operator|->
name|positional
condition|)
block|{
if|if
condition|(
name|line1
operator|->
name|text
operator|-
name|text_base
operator|>
name|line2
operator|->
name|text
operator|-
name|text_base
condition|)
name|tem
operator|=
literal|1
expr_stmt|;
else|else
name|tem
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|keyfields
operator|->
name|numeric
condition|)
name|tem
operator|=
name|line1
operator|->
name|key
operator|.
name|number
operator|-
name|line2
operator|->
name|key
operator|.
name|number
expr_stmt|;
else|else
name|tem
operator|=
name|compare_field
argument_list|(
name|keyfields
argument_list|,
name|line1
operator|->
name|key
operator|.
name|text
argument_list|,
name|line1
operator|->
name|keylen
argument_list|,
literal|0
argument_list|,
name|line2
operator|->
name|key
operator|.
name|text
argument_list|,
name|line2
operator|->
name|keylen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
block|{
if|if
condition|(
name|keyfields
operator|->
name|reverse
condition|)
return|return
operator|-
name|tem
return|;
return|return
name|tem
return|;
block|}
name|text1
operator|=
name|line1
operator|->
name|text
expr_stmt|;
name|text2
operator|=
name|line2
operator|->
name|text
expr_stmt|;
comment|/* Compare using the second keyfield;      if that does not distinguish the lines, try the third keyfield;      and so on. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_keyfields
condition|;
name|i
operator|++
control|)
block|{
name|long
name|length1
decl_stmt|,
name|length2
decl_stmt|;
name|char
modifier|*
name|start1
init|=
name|find_field
argument_list|(
operator|&
name|keyfields
index|[
name|i
index|]
argument_list|,
name|text1
argument_list|,
operator|&
name|length1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|start2
init|=
name|find_field
argument_list|(
operator|&
name|keyfields
index|[
name|i
index|]
argument_list|,
name|text2
argument_list|,
operator|&
name|length2
argument_list|)
decl_stmt|;
name|int
name|tem
init|=
name|compare_field
argument_list|(
operator|&
name|keyfields
index|[
name|i
index|]
argument_list|,
name|start1
argument_list|,
name|length1
argument_list|,
name|text1
operator|-
name|text_base
argument_list|,
name|start2
argument_list|,
name|length2
argument_list|,
name|text2
operator|-
name|text_base
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
condition|)
block|{
if|if
condition|(
name|keyfields
index|[
name|i
index|]
operator|.
name|reverse
condition|)
return|return
operator|-
name|tem
return|;
return|return
name|tem
return|;
block|}
block|}
return|return
literal|0
return|;
comment|/* Lines match exactly. */
block|}
end_block

begin_comment
comment|/* Like compare_full but more general.    You can pass any strings, and you can say how many keyfields to use.    POS1 and POS2 should indicate the nominal positional ordering of    the two lines in the input.  */
end_comment

begin_function
name|int
name|compare_general
parameter_list|(
name|str1
parameter_list|,
name|str2
parameter_list|,
name|pos1
parameter_list|,
name|pos2
parameter_list|,
name|use_keyfields
parameter_list|)
name|char
modifier|*
name|str1
decl_stmt|,
decl|*
name|str2
decl_stmt|;
end_function

begin_decl_stmt
name|long
name|pos1
decl_stmt|,
name|pos2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|use_keyfields
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
comment|/* Compare using the first keyfield;      if that does not distinguish the lines, try the second keyfield;      and so on. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|use_keyfields
condition|;
name|i
operator|++
control|)
block|{
name|long
name|length1
decl_stmt|,
name|length2
decl_stmt|;
name|char
modifier|*
name|start1
init|=
name|find_field
argument_list|(
operator|&
name|keyfields
index|[
name|i
index|]
argument_list|,
name|str1
argument_list|,
operator|&
name|length1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|start2
init|=
name|find_field
argument_list|(
operator|&
name|keyfields
index|[
name|i
index|]
argument_list|,
name|str2
argument_list|,
operator|&
name|length2
argument_list|)
decl_stmt|;
name|int
name|tem
init|=
name|compare_field
argument_list|(
operator|&
name|keyfields
index|[
name|i
index|]
argument_list|,
name|start1
argument_list|,
name|length1
argument_list|,
name|pos1
argument_list|,
name|start2
argument_list|,
name|length2
argument_list|,
name|pos2
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem
condition|)
block|{
if|if
condition|(
name|keyfields
index|[
name|i
index|]
operator|.
name|reverse
condition|)
return|return
operator|-
name|tem
return|;
return|return
name|tem
return|;
block|}
block|}
return|return
literal|0
return|;
comment|/* Lines match exactly. */
block|}
end_block

begin_comment
comment|/* Find the start and length of a field in STR according to KEYFIELD.    A pointer to the starting character is returned, and the length    is stored into the int that LENGTHPTR points to.  */
end_comment

begin_function
name|char
modifier|*
name|find_field
parameter_list|(
name|keyfield
parameter_list|,
name|str
parameter_list|,
name|lengthptr
parameter_list|)
name|struct
name|keyfield
modifier|*
name|keyfield
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|long
modifier|*
name|lengthptr
decl_stmt|;
block|{
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
function_decl|(
modifier|*
name|fun
function_decl|)
parameter_list|()
function_decl|;
if|if
condition|(
name|keyfield
operator|->
name|braced
condition|)
name|fun
operator|=
name|find_braced_pos
expr_stmt|;
else|else
name|fun
operator|=
name|find_pos
expr_stmt|;
name|start
operator|=
call|(
modifier|*
name|fun
call|)
argument_list|(
name|str
argument_list|,
name|keyfield
operator|->
name|startwords
argument_list|,
name|keyfield
operator|->
name|startchars
argument_list|,
name|keyfield
operator|->
name|ignore_blanks
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyfield
operator|->
name|endwords
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|keyfield
operator|->
name|braced
condition|)
name|end
operator|=
name|find_braced_end
argument_list|(
name|start
argument_list|)
expr_stmt|;
else|else
block|{
name|end
operator|=
name|start
expr_stmt|;
while|while
condition|(
operator|*
name|end
operator|&&
operator|*
name|end
operator|!=
literal|'\n'
condition|)
name|end
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|end
operator|=
call|(
modifier|*
name|fun
call|)
argument_list|(
name|str
argument_list|,
name|keyfield
operator|->
name|endwords
argument_list|,
name|keyfield
operator|->
name|endchars
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|-
name|str
operator|<
name|start
operator|-
name|str
condition|)
name|end
operator|=
name|start
expr_stmt|;
block|}
operator|*
name|lengthptr
operator|=
name|end
operator|-
name|start
expr_stmt|;
return|return
name|start
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to a specified place within STR,    skipping (from the beginning) WORDS words and then CHARS chars.    If IGNORE_BLANKS is nonzero, we skip all blanks    after finding the specified word.  */
end_comment

begin_function
name|char
modifier|*
name|find_pos
parameter_list|(
name|str
parameter_list|,
name|words
parameter_list|,
name|chars
parameter_list|,
name|ignore_blanks
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|words
decl_stmt|,
name|chars
decl_stmt|;
name|int
name|ignore_blanks
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|str
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
decl_stmt|;
comment|/* Find next bunch of nonblanks and skip them. */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
operator|!
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|)
return|return
name|p
return|;
block|}
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chars
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|p
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|)
break|break;
name|p
operator|++
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Like find_pos but assumes that each field is surrounded by braces    and that braces within fields are balanced. */
end_comment

begin_function
name|char
modifier|*
name|find_braced_pos
parameter_list|(
name|str
parameter_list|,
name|words
parameter_list|,
name|chars
parameter_list|,
name|ignore_blanks
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|words
decl_stmt|,
name|chars
decl_stmt|;
name|int
name|ignore_blanks
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|bracelevel
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|str
decl_stmt|;
name|char
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
name|bracelevel
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'{'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
condition|)
comment|/* Do nothing. */
empty_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'{'
condition|)
return|return
name|p
operator|-
literal|1
return|;
while|while
condition|(
name|bracelevel
condition|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
name|bracelevel
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
name|bracelevel
operator|--
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
operator|||
name|c
operator|==
literal|'\n'
condition|)
return|return
name|p
operator|-
literal|1
return|;
block|}
block|}
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'{'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
condition|)
comment|/* Do nothing. */
empty_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'{'
condition|)
return|return
name|p
operator|-
literal|1
return|;
if|if
condition|(
name|ignore_blanks
condition|)
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chars
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|p
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|)
break|break;
name|p
operator|++
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Find the end of the balanced-brace field which starts at STR.    The position returned is just before the closing brace. */
end_comment

begin_function
name|char
modifier|*
name|find_braced_end
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|bracelevel
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|str
decl_stmt|;
name|char
name|c
decl_stmt|;
name|bracelevel
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|bracelevel
condition|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
name|bracelevel
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
name|bracelevel
operator|--
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
operator|||
name|c
operator|==
literal|'\n'
condition|)
return|return
name|p
operator|-
literal|1
return|;
block|}
return|return
name|p
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|long
name|find_value
parameter_list|(
name|start
parameter_list|,
name|length
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
name|long
name|length
decl_stmt|;
block|{
while|while
condition|(
name|length
operator|!=
literal|0L
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|start
argument_list|)
condition|)
return|return
name|atol
argument_list|(
name|start
argument_list|)
return|;
name|length
operator|--
expr_stmt|;
name|start
operator|++
expr_stmt|;
block|}
return|return
literal|0l
return|;
block|}
end_function

begin_comment
comment|/* Vector used to translate characters for comparison.    This is how we make all alphanumerics follow all else,    and ignore case in the first sorting.  */
end_comment

begin_decl_stmt
name|int
name|char_order
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_char_order
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|char_order
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|'0'
init|;
name|i
operator|<=
literal|'9'
condition|;
name|i
operator|++
control|)
name|char_order
index|[
name|i
index|]
operator|+=
literal|512
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|'a'
init|;
name|i
operator|<=
literal|'z'
condition|;
name|i
operator|++
control|)
block|{
name|char_order
index|[
name|i
index|]
operator|=
literal|512
operator|+
name|i
expr_stmt|;
name|char_order
index|[
name|i
operator|+
literal|'A'
operator|-
literal|'a'
index|]
operator|=
literal|512
operator|+
name|i
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compare two fields (each specified as a start pointer and a character count)    according to KEYFIELD.    The sign of the value reports the relation between the fields. */
end_comment

begin_function
name|int
name|compare_field
parameter_list|(
name|keyfield
parameter_list|,
name|start1
parameter_list|,
name|length1
parameter_list|,
name|pos1
parameter_list|,
name|start2
parameter_list|,
name|length2
parameter_list|,
name|pos2
parameter_list|)
name|struct
name|keyfield
modifier|*
name|keyfield
decl_stmt|;
name|char
modifier|*
name|start1
decl_stmt|;
name|long
name|length1
decl_stmt|;
name|long
name|pos1
decl_stmt|;
name|char
modifier|*
name|start2
decl_stmt|;
name|long
name|length2
decl_stmt|;
name|long
name|pos2
decl_stmt|;
block|{
if|if
condition|(
name|keyfields
operator|->
name|positional
condition|)
block|{
if|if
condition|(
name|pos1
operator|>
name|pos2
condition|)
return|return
literal|1
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|keyfield
operator|->
name|numeric
condition|)
block|{
name|long
name|value
init|=
name|find_value
argument_list|(
name|start1
argument_list|,
name|length1
argument_list|)
operator|-
name|find_value
argument_list|(
name|start2
argument_list|,
name|length2
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|>
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|char
modifier|*
name|p1
init|=
name|start1
decl_stmt|;
name|char
modifier|*
name|p2
init|=
name|start2
decl_stmt|;
name|char
modifier|*
name|e1
init|=
name|start1
operator|+
name|length1
decl_stmt|;
name|char
modifier|*
name|e2
init|=
name|start2
operator|+
name|length2
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
if|if
condition|(
name|p1
operator|==
name|e1
condition|)
name|c1
operator|=
literal|0
expr_stmt|;
else|else
name|c1
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
if|if
condition|(
name|p2
operator|==
name|e2
condition|)
name|c2
operator|=
literal|0
expr_stmt|;
else|else
name|c2
operator|=
operator|*
name|p2
operator|++
expr_stmt|;
if|if
condition|(
name|char_order
index|[
name|c1
index|]
operator|!=
name|char_order
index|[
name|c2
index|]
condition|)
return|return
name|char_order
index|[
name|c1
index|]
operator|-
name|char_order
index|[
name|c2
index|]
return|;
if|if
condition|(
operator|!
name|c1
condition|)
break|break;
block|}
comment|/* Strings are equal except possibly for case.  */
name|p1
operator|=
name|start1
expr_stmt|;
name|p2
operator|=
name|start2
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
if|if
condition|(
name|p1
operator|==
name|e1
condition|)
name|c1
operator|=
literal|0
expr_stmt|;
else|else
name|c1
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
if|if
condition|(
name|p2
operator|==
name|e2
condition|)
name|c2
operator|=
literal|0
expr_stmt|;
else|else
name|c2
operator|=
operator|*
name|p2
operator|++
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
comment|/* Reverse sign here so upper case comes out last.  */
return|return
name|c2
operator|-
name|c1
return|;
if|if
condition|(
operator|!
name|c1
condition|)
break|break;
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A `struct linebuffer' is a structure which holds a line of text.    `readline' reads a line from a stream into a linebuffer    and works regardless of the length of the line.  */
end_comment

begin_struct
struct|struct
name|linebuffer
block|{
name|long
name|size
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Initialize LINEBUFFER for use. */
end_comment

begin_function
name|void
name|initbuffer
parameter_list|(
name|linebuffer
parameter_list|)
name|struct
name|linebuffer
modifier|*
name|linebuffer
decl_stmt|;
block|{
name|linebuffer
operator|->
name|size
operator|=
literal|200
expr_stmt|;
name|linebuffer
operator|->
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a line of text from STREAM into LINEBUFFER.    Return the length of the line.  */
end_comment

begin_function
name|long
name|readline
parameter_list|(
name|linebuffer
parameter_list|,
name|stream
parameter_list|)
name|struct
name|linebuffer
modifier|*
name|linebuffer
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|char
modifier|*
name|buffer
init|=
name|linebuffer
operator|->
name|buffer
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|linebuffer
operator|->
name|buffer
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|p
operator|+
name|linebuffer
operator|->
name|size
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|c
init|=
name|getc
argument_list|(
name|stream
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|end
condition|)
block|{
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|linebuffer
operator|->
name|size
operator|*=
literal|2
argument_list|)
expr_stmt|;
name|p
operator|+=
name|buffer
operator|-
name|linebuffer
operator|->
name|buffer
expr_stmt|;
name|end
operator|+=
name|buffer
operator|-
name|linebuffer
operator|->
name|buffer
expr_stmt|;
name|linebuffer
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|0
operator|||
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
break|break;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
return|return
name|p
operator|-
name|buffer
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Sort an input file too big to sort in core.  */
end_comment

begin_function
name|void
name|sort_offline
parameter_list|(
name|infile
parameter_list|,
name|nfiles
parameter_list|,
name|total
parameter_list|,
name|outfile
parameter_list|)
name|char
modifier|*
name|infile
decl_stmt|;
name|int
name|nfiles
decl_stmt|;
name|long
name|total
decl_stmt|;
name|char
modifier|*
name|outfile
decl_stmt|;
block|{
comment|/* More than enough. */
name|int
name|ntemps
init|=
literal|2
operator|*
operator|(
name|total
operator|+
name|MAX_IN_CORE_SORT
operator|-
literal|1
operator|)
operator|/
name|MAX_IN_CORE_SORT
decl_stmt|;
name|char
modifier|*
modifier|*
name|tempfiles
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|ntemps
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|istream
init|=
name|fopen
argument_list|(
name|infile
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|linebuffer
name|lb
decl_stmt|;
name|long
name|linelength
decl_stmt|;
name|int
name|failure
init|=
literal|0
decl_stmt|;
name|initbuffer
argument_list|(
operator|&
name|lb
argument_list|)
expr_stmt|;
comment|/* Read in one line of input data.  */
name|linelength
operator|=
name|readline
argument_list|(
operator|&
name|lb
argument_list|,
name|istream
argument_list|)
expr_stmt|;
if|if
condition|(
name|lb
operator|.
name|buffer
index|[
literal|0
index|]
operator|!=
literal|'\\'
operator|&&
name|lb
operator|.
name|buffer
index|[
literal|0
index|]
operator|!=
literal|'@'
condition|)
block|{
name|error
argument_list|(
literal|"%s: not a texinfo index file"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Split up the input into `ntemps' temporary files, or maybe fewer,      and put the new files' names into `tempfiles' */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntemps
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|outname
init|=
name|maketempname
argument_list|(
operator|++
name|tempcount
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|ostream
init|=
name|fopen
argument_list|(
name|outname
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
name|long
name|tempsize
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|ostream
condition|)
name|pfatal_with_name
argument_list|(
name|outname
argument_list|)
expr_stmt|;
name|tempfiles
index|[
name|i
index|]
operator|=
name|outname
expr_stmt|;
comment|/* Copy lines into this temp file as long as it does not make file 	 "too big" or until there are no more lines.  */
while|while
condition|(
name|tempsize
operator|+
name|linelength
operator|+
literal|1
operator|<=
name|MAX_IN_CORE_SORT
condition|)
block|{
name|tempsize
operator|+=
name|linelength
operator|+
literal|1
expr_stmt|;
name|fputs
argument_list|(
name|lb
operator|.
name|buffer
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
comment|/* Read another line of input data.  */
name|linelength
operator|=
name|readline
argument_list|(
operator|&
name|lb
argument_list|,
name|istream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linelength
operator|&&
name|feof
argument_list|(
name|istream
argument_list|)
condition|)
break|break;
if|if
condition|(
name|lb
operator|.
name|buffer
index|[
literal|0
index|]
operator|!=
literal|'\\'
operator|&&
name|lb
operator|.
name|buffer
index|[
literal|0
index|]
operator|!=
literal|'@'
condition|)
block|{
name|error
argument_list|(
literal|"%s: not a texinfo index file"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|failure
operator|=
literal|1
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|fclose
argument_list|(
name|ostream
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|istream
argument_list|)
condition|)
break|break;
block|}
name|free
argument_list|(
name|lb
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|fail
label|:
comment|/* Record number of temp files we actually needed.  */
name|ntemps
operator|=
name|i
expr_stmt|;
comment|/* Sort each tempfile into another tempfile.     Delete the first set of tempfiles and put the names of the second     into `tempfiles'. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntemps
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|newtemp
init|=
name|maketempname
argument_list|(
operator|++
name|tempcount
argument_list|)
decl_stmt|;
name|sort_in_core
argument_list|(
operator|&
name|tempfiles
index|[
name|i
index|]
argument_list|,
name|MAX_IN_CORE_SORT
argument_list|,
name|newtemp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|keep_tempfiles
condition|)
name|unlink
argument_list|(
name|tempfiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|tempfiles
index|[
name|i
index|]
operator|=
name|newtemp
expr_stmt|;
block|}
if|if
condition|(
name|failure
condition|)
return|return;
comment|/* Merge the tempfiles together and indexify. */
name|merge_files
argument_list|(
name|tempfiles
argument_list|,
name|ntemps
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Sort INFILE, whose size is TOTAL,    assuming that is small enough to be done in-core,    then indexify it and send the output to OUTFILE (or to stdout).  */
end_comment

begin_function
name|void
name|sort_in_core
parameter_list|(
name|infile
parameter_list|,
name|total
parameter_list|,
name|outfile
parameter_list|)
name|char
modifier|*
name|infile
decl_stmt|;
name|long
name|total
decl_stmt|;
name|char
modifier|*
name|outfile
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|nextline
decl_stmt|;
name|char
modifier|*
name|data
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|total
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|file_data
decl_stmt|;
name|long
name|file_size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|ostream
init|=
name|stdout
decl_stmt|;
name|struct
name|lineinfo
modifier|*
name|lineinfo
decl_stmt|;
comment|/* Read the contents of the file into the moby array `data'. */
name|int
name|desc
init|=
name|open
argument_list|(
name|infile
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"failure reopening %s"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
for|for
control|(
name|file_size
operator|=
literal|0
init|;
condition|;
control|)
block|{
name|i
operator|=
name|read
argument_list|(
name|desc
argument_list|,
name|data
operator|+
name|file_size
argument_list|,
name|total
operator|-
name|file_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
break|break;
name|file_size
operator|+=
name|i
expr_stmt|;
block|}
name|file_data
operator|=
name|data
expr_stmt|;
name|data
index|[
name|file_size
index|]
operator|=
literal|0
expr_stmt|;
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_size
operator|>
literal|0
operator|&&
name|data
index|[
literal|0
index|]
operator|!=
literal|'\\'
operator|&&
name|data
index|[
literal|0
index|]
operator|!=
literal|'@'
condition|)
block|{
name|error
argument_list|(
literal|"%s: not a texinfo index file"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
return|return;
block|}
name|init_char_order
argument_list|()
expr_stmt|;
comment|/* Sort routines want to know this address. */
name|text_base
operator|=
name|data
expr_stmt|;
comment|/* Create the array of pointers to lines, with a default size      frequently enough.  */
name|nlines
operator|=
name|total
operator|/
literal|50
expr_stmt|;
if|if
condition|(
operator|!
name|nlines
condition|)
name|nlines
operator|=
literal|2
expr_stmt|;
name|linearray
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|nlines
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* `nextline' points to the next free slot in this array.      `nlines' is the allocated size.  */
name|nextline
operator|=
name|linearray
expr_stmt|;
comment|/* Parse the input file's data, and make entries for the lines.  */
name|nextline
operator|=
name|parsefile
argument_list|(
name|infile
argument_list|,
name|nextline
argument_list|,
name|file_data
argument_list|,
name|file_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextline
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s: not a texinfo index file"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Sort the lines. */
comment|/* If we have enough space, find the first keyfield of each line in advance.      Make a `struct lineinfo' for each line, which records the keyfield      as well as the line, and sort them.  */
name|lineinfo
operator|=
operator|(
expr|struct
name|lineinfo
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|nextline
operator|-
name|linearray
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lineinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lineinfo
condition|)
block|{
name|struct
name|lineinfo
modifier|*
name|lp
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|lp
operator|=
name|lineinfo
operator|,
name|p
operator|=
name|linearray
init|;
name|p
operator|!=
name|nextline
condition|;
name|lp
operator|++
operator|,
name|p
operator|++
control|)
block|{
name|lp
operator|->
name|text
operator|=
operator|*
name|p
expr_stmt|;
name|lp
operator|->
name|key
operator|.
name|text
operator|=
name|find_field
argument_list|(
name|keyfields
argument_list|,
operator|*
name|p
argument_list|,
operator|&
name|lp
operator|->
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyfields
operator|->
name|numeric
condition|)
name|lp
operator|->
name|key
operator|.
name|number
operator|=
name|find_value
argument_list|(
name|lp
operator|->
name|key
operator|.
name|text
argument_list|,
name|lp
operator|->
name|keylen
argument_list|)
expr_stmt|;
block|}
name|qsort
argument_list|(
name|lineinfo
argument_list|,
name|nextline
operator|-
name|linearray
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lineinfo
argument_list|)
argument_list|,
name|compare_prepared
argument_list|)
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|lineinfo
operator|,
name|p
operator|=
name|linearray
init|;
name|p
operator|!=
name|nextline
condition|;
name|lp
operator|++
operator|,
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|lp
operator|->
name|text
expr_stmt|;
name|free
argument_list|(
name|lineinfo
argument_list|)
expr_stmt|;
block|}
else|else
name|qsort
argument_list|(
name|linearray
argument_list|,
name|nextline
operator|-
name|linearray
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|compare_full
argument_list|)
expr_stmt|;
comment|/* Open the output file. */
if|if
condition|(
name|outfile
condition|)
block|{
name|ostream
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ostream
condition|)
name|pfatal_with_name
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
name|writelines
argument_list|(
name|linearray
argument_list|,
name|nextline
operator|-
name|linearray
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
condition|)
name|fclose
argument_list|(
name|ostream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|linearray
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse an input string in core into lines.    DATA is the input string, and SIZE is its length.    Data goes in LINEARRAY starting at NEXTLINE.    The value returned is the first entry in LINEARRAY still unused.    Value 0 means input file contents are invalid.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|parsefile
parameter_list|(
name|filename
parameter_list|,
name|nextline
parameter_list|,
name|data
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
modifier|*
name|nextline
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
modifier|*
name|line
init|=
name|nextline
decl_stmt|;
name|p
operator|=
name|data
expr_stmt|;
name|end
operator|=
name|p
operator|+
name|size
expr_stmt|;
operator|*
name|end
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|end
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|'\\'
operator|&&
name|p
index|[
literal|0
index|]
operator|!=
literal|'@'
condition|)
return|return
literal|0
return|;
operator|*
name|line
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|end
condition|)
name|p
operator|++
expr_stmt|;
name|line
operator|++
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|linearray
operator|+
name|nlines
condition|)
block|{
name|char
modifier|*
modifier|*
name|old
init|=
name|linearray
decl_stmt|;
name|linearray
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|linearray
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|nlines
operator|*=
literal|4
operator|)
argument_list|)
expr_stmt|;
name|line
operator|+=
name|linearray
operator|-
name|old
expr_stmt|;
block|}
block|}
return|return
name|line
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Indexification is a filter applied to the sorted lines    as they are being written to the output file.    Multiple entries for the same name, with different page numbers,    get combined into a single entry with multiple page numbers.    The first braced field, which is used for sorting, is discarded.    However, its first character is examined, folded to lower case,    and if it is different from that in the previous line fed to us    a \initial line is written with one argument, the new initial.     If an entry has four braced fields, then the second and third    constitute primary and secondary names.    In this case, each change of primary name    generates a \primary line which contains only the primary name,    and in between these are \secondary lines which contain    just a secondary name and page numbers. */
end_comment

begin_comment
comment|/* The last primary name we wrote a \primary entry for.    If only one level of indexing is being done, this is the last name seen. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|lastprimary
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of storage allocated for lastprimary. */
end_comment

begin_decl_stmt
name|int
name|lastprimarylength
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar, for the secondary name. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|lastsecondary
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastsecondarylength
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Zero if we are not in the middle of writing an entry.    One if we have written the beginning of an entry but have not    yet written any page numbers into it.    Greater than one if we have written the beginning of an entry    plus at least one page number. */
end_comment

begin_decl_stmt
name|int
name|pending
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The initial (for sorting purposes) of the last primary entry written.    When this changes, a \initial {c} line is written */
end_comment

begin_decl_stmt
name|char
modifier|*
name|lastinitial
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastinitiallength
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When we need a string of length 1 for the value of lastinitial,    store it here.  */
end_comment

begin_decl_stmt
name|char
name|lastinitial1
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize static storage for writing an index. */
end_comment

begin_function
name|void
name|init_index
parameter_list|()
block|{
name|pending
operator|=
literal|0
expr_stmt|;
name|lastinitial
operator|=
name|lastinitial1
expr_stmt|;
name|lastinitial1
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|lastinitial1
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|lastinitiallength
operator|=
literal|0
expr_stmt|;
name|lastprimarylength
operator|=
literal|100
expr_stmt|;
name|lastprimary
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|lastprimarylength
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|lastprimary
argument_list|,
literal|'\0'
argument_list|,
name|lastprimarylength
operator|+
literal|1
argument_list|)
expr_stmt|;
name|lastsecondarylength
operator|=
literal|100
expr_stmt|;
name|lastsecondary
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|lastsecondarylength
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|lastsecondary
argument_list|,
literal|'\0'
argument_list|,
name|lastsecondarylength
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Indexify.  Merge entries for the same name,    insert headers for each initial character, etc.  */
end_comment

begin_function
name|void
name|indexify
parameter_list|(
name|line
parameter_list|,
name|ostream
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|FILE
modifier|*
name|ostream
decl_stmt|;
block|{
name|char
modifier|*
name|primary
decl_stmt|,
modifier|*
name|secondary
decl_stmt|,
modifier|*
name|pagenumber
decl_stmt|;
name|int
name|primarylength
decl_stmt|,
name|secondarylength
init|=
literal|0
decl_stmt|,
name|pagelength
decl_stmt|;
name|int
name|nosecondary
decl_stmt|;
name|int
name|initiallength
decl_stmt|;
name|char
modifier|*
name|initial
decl_stmt|;
name|char
name|initial1
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* First, analyze the parts of the entry fed to us this time. */
name|p
operator|=
name|find_braced_pos
argument_list|(
name|line
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'{'
condition|)
block|{
name|initial
operator|=
name|p
expr_stmt|;
comment|/* Get length of inner pair of braces starting at `p', 	 including that inner pair of braces.  */
name|initiallength
operator|=
name|find_braced_end
argument_list|(
name|p
operator|+
literal|1
argument_list|)
operator|+
literal|1
operator|-
name|p
expr_stmt|;
block|}
else|else
block|{
name|initial
operator|=
name|initial1
expr_stmt|;
name|initial1
index|[
literal|0
index|]
operator|=
operator|*
name|p
expr_stmt|;
name|initial1
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|initiallength
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|initial1
index|[
literal|0
index|]
operator|>=
literal|'a'
operator|&&
name|initial1
index|[
literal|0
index|]
operator|<=
literal|'z'
condition|)
name|initial1
index|[
literal|0
index|]
operator|-=
literal|040
expr_stmt|;
block|}
name|pagenumber
operator|=
name|find_braced_pos
argument_list|(
name|line
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pagelength
operator|=
name|find_braced_end
argument_list|(
name|pagenumber
argument_list|)
operator|-
name|pagenumber
expr_stmt|;
if|if
condition|(
name|pagelength
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|primary
operator|=
name|find_braced_pos
argument_list|(
name|line
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|primarylength
operator|=
name|find_braced_end
argument_list|(
name|primary
argument_list|)
operator|-
name|primary
expr_stmt|;
name|secondary
operator|=
name|find_braced_pos
argument_list|(
name|line
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nosecondary
operator|=
operator|!
operator|*
name|secondary
expr_stmt|;
if|if
condition|(
operator|!
name|nosecondary
condition|)
name|secondarylength
operator|=
name|find_braced_end
argument_list|(
name|secondary
argument_list|)
operator|-
name|secondary
expr_stmt|;
comment|/* If the primary is different from before, make a new primary entry. */
if|if
condition|(
name|strncmp
argument_list|(
name|primary
argument_list|,
name|lastprimary
argument_list|,
name|primarylength
argument_list|)
condition|)
block|{
comment|/* Close off current secondary entry first, if one is open. */
if|if
condition|(
name|pending
condition|)
block|{
name|fputs
argument_list|(
literal|"}\n"
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
name|pending
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this primary has a different initial, include an entry for 	 the initial. */
if|if
condition|(
name|initiallength
operator|!=
name|lastinitiallength
operator|||
name|strncmp
argument_list|(
name|initial
argument_list|,
name|lastinitial
argument_list|,
name|initiallength
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|ostream
argument_list|,
literal|"\\initial {"
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|initial
argument_list|,
literal|1
argument_list|,
name|initiallength
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ostream
argument_list|,
literal|"}\n"
argument_list|,
name|initial
argument_list|)
expr_stmt|;
if|if
condition|(
name|initial
operator|==
name|initial1
condition|)
block|{
name|lastinitial
operator|=
name|lastinitial1
expr_stmt|;
operator|*
name|lastinitial1
operator|=
operator|*
name|initial1
expr_stmt|;
block|}
else|else
block|{
name|lastinitial
operator|=
name|initial
expr_stmt|;
block|}
name|lastinitiallength
operator|=
name|initiallength
expr_stmt|;
block|}
comment|/* Make the entry for the primary.  */
if|if
condition|(
name|nosecondary
condition|)
name|fputs
argument_list|(
literal|"\\entry {"
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"\\primary {"
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|primary
argument_list|,
name|primarylength
argument_list|,
literal|1
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
if|if
condition|(
name|nosecondary
condition|)
block|{
name|fputs
argument_list|(
literal|"}{"
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
name|pending
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
literal|"}\n"
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
comment|/* Record name of most recent primary. */
if|if
condition|(
name|lastprimarylength
operator|<
name|primarylength
condition|)
block|{
name|lastprimarylength
operator|=
name|primarylength
operator|+
literal|100
expr_stmt|;
name|lastprimary
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|lastprimary
argument_list|,
literal|1
operator|+
name|lastprimarylength
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|lastprimary
argument_list|,
name|primary
argument_list|,
name|primarylength
argument_list|)
expr_stmt|;
name|lastprimary
index|[
name|primarylength
index|]
operator|=
literal|0
expr_stmt|;
comment|/* There is no current secondary within this primary, now. */
name|lastsecondary
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Should not have an entry with no subtopic following one with a subtopic. */
if|if
condition|(
name|nosecondary
operator|&&
operator|*
name|lastsecondary
condition|)
name|error
argument_list|(
literal|"entry %s follows an entry with a secondary name"
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Start a new secondary entry if necessary. */
if|if
condition|(
operator|!
name|nosecondary
operator|&&
name|strncmp
argument_list|(
name|secondary
argument_list|,
name|lastsecondary
argument_list|,
name|secondarylength
argument_list|)
condition|)
block|{
if|if
condition|(
name|pending
condition|)
block|{
name|fputs
argument_list|(
literal|"}\n"
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
name|pending
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Write the entry for the secondary.  */
name|fputs
argument_list|(
literal|"\\secondary {"
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|secondary
argument_list|,
name|secondarylength
argument_list|,
literal|1
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"}{"
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
name|pending
operator|=
literal|1
expr_stmt|;
comment|/* Record name of most recent secondary. */
if|if
condition|(
name|lastsecondarylength
operator|<
name|secondarylength
condition|)
block|{
name|lastsecondarylength
operator|=
name|secondarylength
operator|+
literal|100
expr_stmt|;
name|lastsecondary
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|lastsecondary
argument_list|,
literal|1
operator|+
name|lastsecondarylength
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|lastsecondary
argument_list|,
name|secondary
argument_list|,
name|secondarylength
argument_list|)
expr_stmt|;
name|lastsecondary
index|[
name|secondarylength
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Here to add one more page number to the current entry. */
if|if
condition|(
name|pending
operator|++
operator|!=
literal|1
condition|)
name|fputs
argument_list|(
literal|", "
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
comment|/* Punctuate first, if this is not the first. */
name|fwrite
argument_list|(
name|pagenumber
argument_list|,
name|pagelength
argument_list|,
literal|1
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close out any unfinished output entry. */
end_comment

begin_function
name|void
name|finish_index
parameter_list|(
name|ostream
parameter_list|)
name|FILE
modifier|*
name|ostream
decl_stmt|;
block|{
if|if
condition|(
name|pending
condition|)
name|fputs
argument_list|(
literal|"}\n"
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lastprimary
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lastsecondary
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy the lines in the sorted order.    Each line is copied out of the input file it was found in. */
end_comment

begin_function
name|void
name|writelines
parameter_list|(
name|linearray
parameter_list|,
name|nlines
parameter_list|,
name|ostream
parameter_list|)
name|char
modifier|*
modifier|*
name|linearray
decl_stmt|;
name|int
name|nlines
decl_stmt|;
name|FILE
modifier|*
name|ostream
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|stop_line
init|=
name|linearray
operator|+
name|nlines
decl_stmt|;
name|char
modifier|*
modifier|*
name|next_line
decl_stmt|;
name|init_index
argument_list|()
expr_stmt|;
comment|/* Output the text of the lines, and free the buffer space. */
for|for
control|(
name|next_line
operator|=
name|linearray
init|;
name|next_line
operator|!=
name|stop_line
condition|;
name|next_line
operator|++
control|)
block|{
comment|/* If -u was specified, output the line only if distinct from previous one.  */
if|if
condition|(
name|next_line
operator|==
name|linearray
comment|/* Compare previous line with this one, using only the          explicitly specd keyfields. */
operator|||
name|compare_general
argument_list|(
operator|*
operator|(
name|next_line
operator|-
literal|1
operator|)
argument_list|,
operator|*
name|next_line
argument_list|,
literal|0L
argument_list|,
literal|0L
argument_list|,
name|num_keyfields
operator|-
literal|1
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|next_line
decl_stmt|;
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
comment|/* Do nothing. */
empty_stmt|;
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
name|indexify
argument_list|(
operator|*
name|next_line
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
block|}
block|}
name|finish_index
argument_list|(
name|ostream
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assume (and optionally verify) that each input file is sorted;    merge them and output the result.    Returns nonzero if any input file fails to be sorted.     This is the high-level interface that can handle an unlimited    number of files.  */
end_comment

begin_define
define|#
directive|define
name|MAX_DIRECT_MERGE
value|10
end_define

begin_function
name|int
name|merge_files
parameter_list|(
name|infiles
parameter_list|,
name|nfiles
parameter_list|,
name|outfile
parameter_list|)
name|char
modifier|*
modifier|*
name|infiles
decl_stmt|;
name|int
name|nfiles
decl_stmt|;
name|char
modifier|*
name|outfile
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|tempfiles
decl_stmt|;
name|int
name|ntemps
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
name|int
name|start_tempcount
init|=
name|tempcount
decl_stmt|;
if|if
condition|(
name|nfiles
operator|<=
name|MAX_DIRECT_MERGE
condition|)
return|return
name|merge_direct
argument_list|(
name|infiles
argument_list|,
name|nfiles
argument_list|,
name|outfile
argument_list|)
return|;
comment|/* Merge groups of MAX_DIRECT_MERGE input files at a time,      making a temporary file to hold each group's result.  */
name|ntemps
operator|=
operator|(
name|nfiles
operator|+
name|MAX_DIRECT_MERGE
operator|-
literal|1
operator|)
operator|/
name|MAX_DIRECT_MERGE
expr_stmt|;
name|tempfiles
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|ntemps
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntemps
condition|;
name|i
operator|++
control|)
block|{
name|int
name|nf
init|=
name|MAX_DIRECT_MERGE
decl_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|ntemps
condition|)
name|nf
operator|=
name|nfiles
operator|-
name|i
operator|*
name|MAX_DIRECT_MERGE
expr_stmt|;
name|tempfiles
index|[
name|i
index|]
operator|=
name|maketempname
argument_list|(
operator|++
name|tempcount
argument_list|)
expr_stmt|;
name|value
operator||=
name|merge_direct
argument_list|(
operator|&
name|infiles
index|[
name|i
operator|*
name|MAX_DIRECT_MERGE
index|]
argument_list|,
name|nf
argument_list|,
name|tempfiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* All temporary files that existed before are no longer needed      since their contents have been merged into our new tempfiles.      So delete them.  */
name|flush_tempfiles
argument_list|(
name|start_tempcount
argument_list|)
expr_stmt|;
comment|/* Now merge the temporary files we created.  */
name|merge_files
argument_list|(
name|tempfiles
argument_list|,
name|ntemps
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tempfiles
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assume (and optionally verify) that each input file is sorted;    merge them and output the result.    Returns nonzero if any input file fails to be sorted.     This version of merging will not work if the number of    input files gets too high.  Higher level functions    use it only with a bounded number of input files.  */
end_comment

begin_function
name|int
name|merge_direct
parameter_list|(
name|infiles
parameter_list|,
name|nfiles
parameter_list|,
name|outfile
parameter_list|)
name|char
modifier|*
modifier|*
name|infiles
decl_stmt|;
name|int
name|nfiles
decl_stmt|;
name|char
modifier|*
name|outfile
decl_stmt|;
block|{
name|struct
name|linebuffer
modifier|*
name|lb1
decl_stmt|,
modifier|*
name|lb2
decl_stmt|;
name|struct
name|linebuffer
modifier|*
modifier|*
name|thisline
decl_stmt|,
modifier|*
modifier|*
name|prevline
decl_stmt|;
name|FILE
modifier|*
modifier|*
name|streams
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|nleft
decl_stmt|;
name|int
name|lossage
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|file_lossage
decl_stmt|;
name|struct
name|linebuffer
modifier|*
name|prev_out
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|ostream
init|=
name|stdout
decl_stmt|;
if|if
condition|(
name|outfile
condition|)
block|{
name|ostream
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ostream
condition|)
name|pfatal_with_name
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|init_index
argument_list|()
expr_stmt|;
if|if
condition|(
name|nfiles
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|outfile
condition|)
name|fclose
argument_list|(
name|ostream
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* For each file, make two line buffers.      Also, for each file, there is an element of `thisline'      which points at any time to one of the file's two buffers,      and an element of `prevline' which points to the other buffer.      `thisline' is supposed to point to the next available line from the file,      while `prevline' holds the last file line used,      which is remembered so that we can verify that the file is properly sorted. */
comment|/* lb1 and lb2 contain one buffer each per file. */
name|lb1
operator|=
operator|(
expr|struct
name|linebuffer
operator|*
operator|)
name|xmalloc
argument_list|(
name|nfiles
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linebuffer
argument_list|)
argument_list|)
expr_stmt|;
name|lb2
operator|=
operator|(
expr|struct
name|linebuffer
operator|*
operator|)
name|xmalloc
argument_list|(
name|nfiles
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linebuffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* thisline[i] points to the linebuffer holding the next available line in file i,      or is zero if there are no lines left in that file.  */
name|thisline
operator|=
operator|(
expr|struct
name|linebuffer
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|nfiles
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linebuffer
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* prevline[i] points to the linebuffer holding the last used line      from file i.  This is just for verifying that file i is properly      sorted.  */
name|prevline
operator|=
operator|(
expr|struct
name|linebuffer
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|nfiles
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linebuffer
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* streams[i] holds the input stream for file i.  */
name|streams
operator|=
operator|(
name|FILE
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|nfiles
operator|*
sizeof|sizeof
argument_list|(
name|FILE
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* file_lossage[i] is nonzero if we already know file i is not      properly sorted.  */
name|file_lossage
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|nfiles
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate and initialize all that storage. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
name|i
operator|++
control|)
block|{
name|initbuffer
argument_list|(
operator|&
name|lb1
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|initbuffer
argument_list|(
operator|&
name|lb2
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|thisline
index|[
name|i
index|]
operator|=
operator|&
name|lb1
index|[
name|i
index|]
expr_stmt|;
name|prevline
index|[
name|i
index|]
operator|=
operator|&
name|lb2
index|[
name|i
index|]
expr_stmt|;
name|file_lossage
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|streams
index|[
name|i
index|]
operator|=
name|fopen
argument_list|(
name|infiles
index|[
name|i
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|streams
index|[
name|i
index|]
condition|)
name|pfatal_with_name
argument_list|(
name|infiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|readline
argument_list|(
name|thisline
index|[
name|i
index|]
argument_list|,
name|streams
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Keep count of number of files not at eof. */
name|nleft
operator|=
name|nfiles
expr_stmt|;
while|while
condition|(
name|nleft
condition|)
block|{
name|struct
name|linebuffer
modifier|*
name|best
init|=
literal|0
decl_stmt|;
name|struct
name|linebuffer
modifier|*
name|exch
decl_stmt|;
name|int
name|bestfile
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Look at the next avail line of each file; choose the least one.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|thisline
index|[
name|i
index|]
operator|&&
operator|(
operator|!
name|best
operator|||
literal|0
operator|<
name|compare_general
argument_list|(
name|best
operator|->
name|buffer
argument_list|,
name|thisline
index|[
name|i
index|]
operator|->
name|buffer
argument_list|,
operator|(
name|long
operator|)
name|bestfile
argument_list|,
operator|(
name|long
operator|)
name|i
argument_list|,
name|num_keyfields
argument_list|)
operator|)
condition|)
block|{
name|best
operator|=
name|thisline
index|[
name|i
index|]
expr_stmt|;
name|bestfile
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* Output that line, unless it matches the previous one and we 	 don't want duplicates. */
if|if
condition|(
operator|!
operator|(
name|prev_out
operator|&&
operator|!
name|compare_general
argument_list|(
name|prev_out
operator|->
name|buffer
argument_list|,
name|best
operator|->
name|buffer
argument_list|,
literal|0L
argument_list|,
literal|1L
argument_list|,
name|num_keyfields
operator|-
literal|1
argument_list|)
operator|)
condition|)
name|indexify
argument_list|(
name|best
operator|->
name|buffer
argument_list|,
name|ostream
argument_list|)
expr_stmt|;
name|prev_out
operator|=
name|best
expr_stmt|;
comment|/* Now make the line the previous of its file, and fetch a new 	 line from that file.  */
name|exch
operator|=
name|prevline
index|[
name|bestfile
index|]
expr_stmt|;
name|prevline
index|[
name|bestfile
index|]
operator|=
name|thisline
index|[
name|bestfile
index|]
expr_stmt|;
name|thisline
index|[
name|bestfile
index|]
operator|=
name|exch
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* If the file has no more, mark it empty. */
if|if
condition|(
name|feof
argument_list|(
name|streams
index|[
name|bestfile
index|]
argument_list|)
condition|)
block|{
name|thisline
index|[
name|bestfile
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Update the number of files still not empty. */
name|nleft
operator|--
expr_stmt|;
break|break;
block|}
name|readline
argument_list|(
name|thisline
index|[
name|bestfile
index|]
argument_list|,
name|streams
index|[
name|bestfile
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisline
index|[
name|bestfile
index|]
operator|->
name|buffer
index|[
literal|0
index|]
operator|||
operator|!
name|feof
argument_list|(
name|streams
index|[
name|bestfile
index|]
argument_list|)
condition|)
break|break;
block|}
block|}
name|finish_index
argument_list|(
name|ostream
argument_list|)
expr_stmt|;
comment|/* Free all storage and close all input streams. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
name|i
operator|++
control|)
block|{
name|fclose
argument_list|(
name|streams
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lb1
index|[
name|i
index|]
operator|.
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lb2
index|[
name|i
index|]
operator|.
name|buffer
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|file_lossage
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lb1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lb2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|thisline
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prevline
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|streams
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
condition|)
name|fclose
argument_list|(
name|ostream
argument_list|)
expr_stmt|;
return|return
name|lossage
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print error message and exit.  */
end_comment

begin_function
name|void
name|fatal
parameter_list|(
name|format
parameter_list|,
name|arg
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|,
decl|*
name|arg
decl_stmt|;
end_function

begin_block
block|{
name|error
argument_list|(
name|format
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|TI_FATAL_ERROR
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Print error message.  FORMAT is printf control string, ARG is arg for it. */
end_comment

begin_function
name|void
name|error
parameter_list|(
name|format
parameter_list|,
name|arg
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|,
decl|*
name|arg
decl_stmt|;
end_function

begin_block
block|{
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|format
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
index|[
name|strlen
argument_list|(
name|format
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|perror_with_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|strerror
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s; for file `%s'.\n"
argument_list|,
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pfatal_with_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|strerror
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s; for file `%s'.\n"
argument_list|,
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|TI_FATAL_ERROR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a newly-allocated string whose contents concatenate those of    S1, S2, S3.  */
end_comment

begin_function
name|char
modifier|*
name|concat
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
end_function

begin_block
block|{
name|int
name|len1
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
decl_stmt|,
name|len2
init|=
name|strlen
argument_list|(
name|s2
argument_list|)
decl_stmt|,
name|len3
init|=
name|strlen
argument_list|(
name|s3
argument_list|)
decl_stmt|;
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len1
operator|+
name|len2
operator|+
name|len3
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
operator|+
name|len2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
operator|*
operator|(
name|result
operator|+
name|len1
operator|+
name|len2
operator|+
name|len3
operator|)
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_STRERROR
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|strerror
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
if|if
condition|(
name|num
operator|>=
name|sys_nerr
condition|)
return|return
operator|(
literal|""
operator|)
return|;
else|else
return|return
operator|(
name|sys_errlist
index|[
name|num
index|]
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_STRERROR */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_STRCHR
argument_list|)
end_if

begin_function
name|char
modifier|*
name|strrchr
parameter_list|(
name|string
parameter_list|,
name|character
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|character
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>
operator|-
literal|1
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
name|character
condition|)
return|return
operator|(
name|string
operator|+
name|i
operator|)
return|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_STRCHR */
end_comment

begin_comment
comment|/* Just like malloc, but kills the program in case of fatal error. */
end_comment

begin_function
name|void
modifier|*
name|xmalloc
parameter_list|(
name|nbytes
parameter_list|)
name|int
name|nbytes
decl_stmt|;
block|{
name|void
modifier|*
name|temp
init|=
operator|(
name|void
operator|*
operator|)
name|malloc
argument_list|(
name|nbytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|nbytes
operator|&&
name|temp
operator|==
operator|(
name|void
operator|*
operator|)
name|NULL
condition|)
name|memory_error
argument_list|(
literal|"xmalloc"
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like realloc (), but barfs if there isn't enough memory. */
end_comment

begin_function
name|void
modifier|*
name|xrealloc
parameter_list|(
name|pointer
parameter_list|,
name|nbytes
parameter_list|)
name|void
modifier|*
name|pointer
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
name|void
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|pointer
condition|)
name|temp
operator|=
operator|(
name|void
operator|*
operator|)
name|xmalloc
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
operator|(
name|void
operator|*
operator|)
name|realloc
argument_list|(
name|pointer
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|&&
operator|!
name|temp
condition|)
name|memory_error
argument_list|(
literal|"xrealloc"
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_macro
name|memory_error
argument_list|(
argument|callers_name
argument_list|,
argument|bytes_wanted
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|callers_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bytes_wanted
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|printable_string
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|printable_string
argument_list|,
literal|"Virtual memory exhausted in %s ()!  Needed %d bytes."
argument_list|,
name|callers_name
argument_list|,
name|bytes_wanted
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|printable_string
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

end_unit

