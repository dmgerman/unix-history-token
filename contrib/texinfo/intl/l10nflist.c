begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle list of needed message catalogs    Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.    Written by Ulrich Drepper<drepper@gnu.ai.mit.edu>, 1995.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|HAVE_STRING_H
operator|||
name|defined
name|_LIBC
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|_GNU_SOURCE
end_ifndef

begin_define
define|#
directive|define
name|_GNU_SOURCE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|memcpy
end_ifndef

begin_define
define|#
directive|define
name|memcpy
parameter_list|(
name|Dst
parameter_list|,
name|Src
parameter_list|,
name|Num
parameter_list|)
value|bcopy (Src, Dst, Num)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|HAVE_STRCHR
operator|&&
operator|!
name|defined
name|_LIBC
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|strchr
end_ifndef

begin_define
define|#
directive|define
name|strchr
value|index
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|_LIBC
operator|||
name|defined
name|HAVE_ARGZ_H
end_if

begin_include
include|#
directive|include
file|<argz.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
name|STDC_HEADERS
operator|||
name|defined
name|_LIBC
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"loadinfo.h"
end_include

begin_comment
comment|/* On some strange systems still no definition of NULL is found.  Sigh!  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_if
if|#
directive|if
name|defined
name|__STDC__
operator|&&
name|__STDC__
end_if

begin_define
define|#
directive|define
name|NULL
value|((void *) 0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* @@ end of prolog @@ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_comment
comment|/* Rename the non ANSI C functions.  This is required by the standard    because some ANSI C functions will require linking with this object    file and the name space must not be polluted.  */
end_comment

begin_define
define|#
directive|define
name|stpcpy
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
value|__stpcpy(dest, src)
end_define

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STPCPY
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stpcpy
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|dest
operator|,
specifier|const
name|char
operator|*
name|src
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define function which are usually not available.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
name|_LIBC
operator|&&
operator|!
name|defined
name|HAVE___ARGZ_COUNT
end_if

begin_comment
comment|/* Returns the number of strings in ARGZ.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|argz_count__
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|argz
operator|,
name|size_t
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|size_t
name|argz_count__
parameter_list|(
name|argz
parameter_list|,
name|len
parameter_list|)
specifier|const
name|char
modifier|*
name|argz
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|size_t
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|size_t
name|part_len
init|=
name|strlen
argument_list|(
name|argz
argument_list|)
decl_stmt|;
name|argz
operator|+=
name|part_len
operator|+
literal|1
expr_stmt|;
name|len
operator|-=
name|part_len
operator|+
literal|1
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|__argz_count
end_undef

begin_define
define|#
directive|define
name|__argz_count
parameter_list|(
name|argz
parameter_list|,
name|len
parameter_list|)
value|argz_count__ (argz, len)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_LIBC&& !HAVE___ARGZ_COUNT */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
name|_LIBC
operator|&&
operator|!
name|defined
name|HAVE___ARGZ_STRINGIFY
end_if

begin_comment
comment|/* Make '\0' separated arg vector ARGZ printable by converting all the '\0's    except the last into the character SEP.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|argz_stringify__
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|argz
operator|,
name|size_t
name|len
operator|,
name|int
name|sep
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|argz_stringify__
parameter_list|(
name|argz
parameter_list|,
name|len
parameter_list|,
name|sep
parameter_list|)
name|char
modifier|*
name|argz
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|sep
decl_stmt|;
block|{
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|size_t
name|part_len
init|=
name|strlen
argument_list|(
name|argz
argument_list|)
decl_stmt|;
name|argz
operator|+=
name|part_len
expr_stmt|;
name|len
operator|-=
name|part_len
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
operator|*
name|argz
operator|++
operator|=
name|sep
expr_stmt|;
block|}
block|}
end_function

begin_undef
undef|#
directive|undef
name|__argz_stringify
end_undef

begin_define
define|#
directive|define
name|__argz_stringify
parameter_list|(
name|argz
parameter_list|,
name|len
parameter_list|,
name|sep
parameter_list|)
value|argz_stringify__ (argz, len, sep)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_LIBC&& !HAVE___ARGZ_STRINGIFY */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
name|_LIBC
operator|&&
operator|!
name|defined
name|HAVE___ARGZ_NEXT
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|argz_next__
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|argz
operator|,
name|size_t
name|argz_len
operator|,
specifier|const
name|char
operator|*
name|entry
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|argz_next__
parameter_list|(
name|argz
parameter_list|,
name|argz_len
parameter_list|,
name|entry
parameter_list|)
name|char
modifier|*
name|argz
decl_stmt|;
name|size_t
name|argz_len
decl_stmt|;
specifier|const
name|char
modifier|*
name|entry
decl_stmt|;
block|{
if|if
condition|(
name|entry
condition|)
block|{
if|if
condition|(
name|entry
operator|<
name|argz
operator|+
name|argz_len
condition|)
name|entry
operator|=
name|strchr
argument_list|(
name|entry
argument_list|,
literal|'\0'
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
name|entry
operator|>=
name|argz
operator|+
name|argz_len
condition|?
name|NULL
else|:
operator|(
name|char
operator|*
operator|)
name|entry
return|;
block|}
elseif|else
if|if
condition|(
name|argz_len
operator|>
literal|0
condition|)
return|return
name|argz
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|__argz_next
end_undef

begin_define
define|#
directive|define
name|__argz_next
parameter_list|(
name|argz
parameter_list|,
name|len
parameter_list|,
name|entry
parameter_list|)
value|argz_next__ (argz, len, entry)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_LIBC&& !HAVE___ARGZ_NEXT */
end_comment

begin_comment
comment|/* Return number of bits set in X.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pop
name|PARAMS
argument_list|(
operator|(
name|int
name|x
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|int
name|pop
parameter_list|(
name|x
parameter_list|)
name|int
name|x
decl_stmt|;
block|{
comment|/* We assume that no more than 16 bits are used.  */
name|x
operator|=
operator|(
operator|(
name|x
operator|&
operator|~
literal|0x5555
operator|)
operator|>>
literal|1
operator|)
operator|+
operator|(
name|x
operator|&
literal|0x5555
operator|)
expr_stmt|;
name|x
operator|=
operator|(
operator|(
name|x
operator|&
operator|~
literal|0x3333
operator|)
operator|>>
literal|2
operator|)
operator|+
operator|(
name|x
operator|&
literal|0x3333
operator|)
expr_stmt|;
name|x
operator|=
operator|(
operator|(
name|x
operator|>>
literal|4
operator|)
operator|+
name|x
operator|)
operator|&
literal|0x0f0f
expr_stmt|;
name|x
operator|=
operator|(
operator|(
name|x
operator|>>
literal|8
operator|)
operator|+
name|x
operator|)
operator|&
literal|0xff
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|struct
name|loaded_l10nfile
modifier|*
name|_nl_make_l10nflist
parameter_list|(
name|l10nfile_list
parameter_list|,
name|dirlist
parameter_list|,
name|dirlist_len
parameter_list|,
name|mask
parameter_list|,
name|language
parameter_list|,
name|territory
parameter_list|,
name|codeset
parameter_list|,
name|normalized_codeset
parameter_list|,
name|modifier
parameter_list|,
name|special
parameter_list|,
name|sponsor
parameter_list|,
name|revision
parameter_list|,
name|filename
parameter_list|,
name|do_allocate
parameter_list|)
name|struct
name|loaded_l10nfile
modifier|*
modifier|*
name|l10nfile_list
decl_stmt|;
specifier|const
name|char
modifier|*
name|dirlist
decl_stmt|;
name|size_t
name|dirlist_len
decl_stmt|;
name|int
name|mask
decl_stmt|;
specifier|const
name|char
modifier|*
name|language
decl_stmt|;
specifier|const
name|char
modifier|*
name|territory
decl_stmt|;
specifier|const
name|char
modifier|*
name|codeset
decl_stmt|;
specifier|const
name|char
modifier|*
name|normalized_codeset
decl_stmt|;
specifier|const
name|char
modifier|*
name|modifier
decl_stmt|;
specifier|const
name|char
modifier|*
name|special
decl_stmt|;
specifier|const
name|char
modifier|*
name|sponsor
decl_stmt|;
specifier|const
name|char
modifier|*
name|revision
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|do_allocate
decl_stmt|;
block|{
name|char
modifier|*
name|abs_filename
decl_stmt|;
name|struct
name|loaded_l10nfile
modifier|*
name|last
init|=
name|NULL
decl_stmt|;
name|struct
name|loaded_l10nfile
modifier|*
name|retval
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|entries
decl_stmt|;
name|int
name|cnt
decl_stmt|;
comment|/* Allocate room for the full file name.  */
name|abs_filename
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|dirlist_len
operator|+
name|strlen
argument_list|(
name|language
argument_list|)
operator|+
operator|(
operator|(
name|mask
operator|&
name|TERRITORY
operator|)
operator|!=
literal|0
condition|?
name|strlen
argument_list|(
name|territory
argument_list|)
operator|+
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|mask
operator|&
name|XPG_CODESET
operator|)
operator|!=
literal|0
condition|?
name|strlen
argument_list|(
name|codeset
argument_list|)
operator|+
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|mask
operator|&
name|XPG_NORM_CODESET
operator|)
operator|!=
literal|0
condition|?
name|strlen
argument_list|(
name|normalized_codeset
argument_list|)
operator|+
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
operator|(
name|mask
operator|&
name|XPG_MODIFIER
operator|)
operator|!=
literal|0
operator|||
operator|(
name|mask
operator|&
name|CEN_AUDIENCE
operator|)
operator|!=
literal|0
operator|)
condition|?
name|strlen
argument_list|(
name|modifier
argument_list|)
operator|+
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|mask
operator|&
name|CEN_SPECIAL
operator|)
operator|!=
literal|0
condition|?
name|strlen
argument_list|(
name|special
argument_list|)
operator|+
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
operator|(
name|mask
operator|&
name|CEN_SPONSOR
operator|)
operator|!=
literal|0
operator|||
operator|(
name|mask
operator|&
name|CEN_REVISION
operator|)
operator|!=
literal|0
operator|)
condition|?
operator|(
literal|1
operator|+
operator|(
operator|(
name|mask
operator|&
name|CEN_SPONSOR
operator|)
operator|!=
literal|0
condition|?
name|strlen
argument_list|(
name|sponsor
argument_list|)
operator|+
literal|1
else|:
literal|0
operator|)
operator|+
operator|(
operator|(
name|mask
operator|&
name|CEN_REVISION
operator|)
operator|!=
literal|0
condition|?
name|strlen
argument_list|(
name|revision
argument_list|)
operator|+
literal|1
else|:
literal|0
operator|)
operator|)
else|:
literal|0
operator|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs_filename
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|retval
operator|=
name|NULL
expr_stmt|;
name|last
operator|=
name|NULL
expr_stmt|;
comment|/* Construct file name.  */
name|memcpy
argument_list|(
name|abs_filename
argument_list|,
name|dirlist
argument_list|,
name|dirlist_len
argument_list|)
expr_stmt|;
name|__argz_stringify
argument_list|(
name|abs_filename
argument_list|,
name|dirlist_len
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|cp
operator|=
name|abs_filename
operator|+
operator|(
name|dirlist_len
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'/'
expr_stmt|;
name|cp
operator|=
name|stpcpy
argument_list|(
name|cp
argument_list|,
name|language
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|TERRITORY
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'_'
expr_stmt|;
name|cp
operator|=
name|stpcpy
argument_list|(
name|cp
argument_list|,
name|territory
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|XPG_CODESET
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'.'
expr_stmt|;
name|cp
operator|=
name|stpcpy
argument_list|(
name|cp
argument_list|,
name|codeset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|XPG_NORM_CODESET
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'.'
expr_stmt|;
name|cp
operator|=
name|stpcpy
argument_list|(
name|cp
argument_list|,
name|normalized_codeset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
name|XPG_MODIFIER
operator||
name|CEN_AUDIENCE
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* This component can be part of both syntaces but has different 	 leading characters.  For CEN we use `+', else `@'.  */
operator|*
name|cp
operator|++
operator|=
operator|(
name|mask
operator|&
name|CEN_AUDIENCE
operator|)
operator|!=
literal|0
condition|?
literal|'+'
else|:
literal|'@'
expr_stmt|;
name|cp
operator|=
name|stpcpy
argument_list|(
name|cp
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|CEN_SPECIAL
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'+'
expr_stmt|;
name|cp
operator|=
name|stpcpy
argument_list|(
name|cp
argument_list|,
name|special
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
name|CEN_SPONSOR
operator||
name|CEN_REVISION
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|','
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|CEN_SPONSOR
operator|)
operator|!=
literal|0
condition|)
name|cp
operator|=
name|stpcpy
argument_list|(
name|cp
argument_list|,
name|sponsor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|CEN_REVISION
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'_'
expr_stmt|;
name|cp
operator|=
name|stpcpy
argument_list|(
name|cp
argument_list|,
name|revision
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|cp
operator|++
operator|=
literal|'/'
expr_stmt|;
name|stpcpy
argument_list|(
name|cp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* Look in list of already loaded domains whether it is already      available.  */
name|last
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|retval
operator|=
operator|*
name|l10nfile_list
init|;
name|retval
operator|!=
name|NULL
condition|;
name|retval
operator|=
name|retval
operator|->
name|next
control|)
if|if
condition|(
name|retval
operator|->
name|filename
operator|!=
name|NULL
condition|)
block|{
name|int
name|compare
init|=
name|strcmp
argument_list|(
name|retval
operator|->
name|filename
argument_list|,
name|abs_filename
argument_list|)
decl_stmt|;
if|if
condition|(
name|compare
operator|==
literal|0
condition|)
comment|/* We found it!  */
break|break;
if|if
condition|(
name|compare
operator|<
literal|0
condition|)
block|{
comment|/* It's not in the list.  */
name|retval
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|last
operator|=
name|retval
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|!=
name|NULL
operator|||
name|do_allocate
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|abs_filename
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
name|retval
operator|=
operator|(
expr|struct
name|loaded_l10nfile
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|retval
argument_list|)
operator|+
operator|(
name|__argz_count
argument_list|(
name|dirlist
argument_list|,
name|dirlist_len
argument_list|)
operator|*
operator|(
literal|1
operator|<<
name|pop
argument_list|(
name|mask
argument_list|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|loaded_l10nfile
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|retval
operator|->
name|filename
operator|=
name|abs_filename
expr_stmt|;
name|retval
operator|->
name|decided
operator|=
operator|(
name|__argz_count
argument_list|(
name|dirlist
argument_list|,
name|dirlist_len
argument_list|)
operator|!=
literal|1
operator|||
operator|(
operator|(
name|mask
operator|&
name|XPG_CODESET
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|mask
operator|&
name|XPG_NORM_CODESET
operator|)
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
name|retval
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|last
operator|==
name|NULL
condition|)
block|{
name|retval
operator|->
name|next
operator|=
operator|*
name|l10nfile_list
expr_stmt|;
operator|*
name|l10nfile_list
operator|=
name|retval
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|->
name|next
operator|=
name|last
operator|->
name|next
expr_stmt|;
name|last
operator|->
name|next
operator|=
name|retval
expr_stmt|;
block|}
name|entries
operator|=
literal|0
expr_stmt|;
comment|/* If the DIRLIST is a real list the RETVAL entry corresponds not to      a real file.  So we have to use the DIRLIST separation mechanism      of the inner loop.  */
name|cnt
operator|=
name|__argz_count
argument_list|(
name|dirlist
argument_list|,
name|dirlist_len
argument_list|)
operator|==
literal|1
condition|?
name|mask
operator|-
literal|1
else|:
name|mask
expr_stmt|;
for|for
control|(
init|;
name|cnt
operator|>=
literal|0
condition|;
operator|--
name|cnt
control|)
if|if
condition|(
operator|(
name|cnt
operator|&
operator|~
name|mask
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|cnt
operator|&
name|CEN_SPECIFIC
operator|)
operator|==
literal|0
operator|||
operator|(
name|cnt
operator|&
name|XPG_SPECIFIC
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|cnt
operator|&
name|XPG_CODESET
operator|)
operator|==
literal|0
operator|||
operator|(
name|cnt
operator|&
name|XPG_NORM_CODESET
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Iterate over all elements of the DIRLIST.  */
name|char
modifier|*
name|dir
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|(
name|dir
operator|=
name|__argz_next
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dirlist
argument_list|,
name|dirlist_len
argument_list|,
name|dir
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|retval
operator|->
name|successor
index|[
name|entries
operator|++
index|]
operator|=
name|_nl_make_l10nflist
argument_list|(
name|l10nfile_list
argument_list|,
name|dir
argument_list|,
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|1
argument_list|,
name|cnt
argument_list|,
name|language
argument_list|,
name|territory
argument_list|,
name|codeset
argument_list|,
name|normalized_codeset
argument_list|,
name|modifier
argument_list|,
name|special
argument_list|,
name|sponsor
argument_list|,
name|revision
argument_list|,
name|filename
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|retval
operator|->
name|successor
index|[
name|entries
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Normalize codeset name.  There is no standard for the codeset    names.  Normalization allows the user to use any of the common    names.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|_nl_normalize_codeset
parameter_list|(
name|codeset
parameter_list|,
name|name_len
parameter_list|)
specifier|const
name|char
modifier|*
name|codeset
decl_stmt|;
name|size_t
name|name_len
decl_stmt|;
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|only_digit
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|retval
decl_stmt|;
name|char
modifier|*
name|wp
decl_stmt|;
name|size_t
name|cnt
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|name_len
condition|;
operator|++
name|cnt
control|)
if|if
condition|(
name|isalnum
argument_list|(
name|codeset
index|[
name|cnt
index|]
argument_list|)
condition|)
block|{
operator|++
name|len
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|codeset
index|[
name|cnt
index|]
argument_list|)
condition|)
name|only_digit
operator|=
literal|0
expr_stmt|;
block|}
name|retval
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|only_digit
condition|?
literal|3
else|:
literal|0
operator|)
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|only_digit
condition|)
name|wp
operator|=
name|stpcpy
argument_list|(
name|retval
argument_list|,
literal|"iso"
argument_list|)
expr_stmt|;
else|else
name|wp
operator|=
name|retval
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|name_len
condition|;
operator|++
name|cnt
control|)
if|if
condition|(
name|isalpha
argument_list|(
name|codeset
index|[
name|cnt
index|]
argument_list|)
condition|)
operator|*
name|wp
operator|++
operator|=
name|tolower
argument_list|(
name|codeset
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|codeset
index|[
name|cnt
index|]
argument_list|)
condition|)
operator|*
name|wp
operator|++
operator|=
name|codeset
index|[
name|cnt
index|]
expr_stmt|;
operator|*
name|wp
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
operator|(
specifier|const
name|char
operator|*
operator|)
name|retval
return|;
block|}
end_function

begin_comment
comment|/* @@ begin of epilog @@ */
end_comment

begin_comment
comment|/* We don't want libintl.a to depend on any other library.  So we    avoid the non-standard function stpcpy.  In GNU C Library this    function is available, though.  Also allow the symbol HAVE_STPCPY    to be defined.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|_LIBC
operator|&&
operator|!
name|HAVE_STPCPY
end_if

begin_function
specifier|static
name|char
modifier|*
name|stpcpy
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|char
modifier|*
name|dest
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
block|{
while|while
condition|(
operator|(
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
comment|/* Do nothing. */
empty_stmt|;
return|return
name|dest
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

