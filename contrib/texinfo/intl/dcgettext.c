begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Implementation of the dcgettext(3) function    Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_define
define|#
directive|define
name|HAVE_ALLOCA
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
name|HAVE_ALLOCA_H
operator|||
name|defined
name|_LIBC
end_if

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|_AIX
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|alloca
end_ifndef

begin_function_decl
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|errno
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__set_errno
end_ifndef

begin_define
define|#
directive|define
name|__set_errno
parameter_list|(
name|val
parameter_list|)
value|errno = (val)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|STDC_HEADERS
operator|||
name|defined
name|_LIBC
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MALLOC_H
end_ifdef

begin_include
include|#
directive|include
file|<malloc.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|HAVE_STRING_H
operator|||
name|defined
name|_LIBC
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|_GNU_SOURCE
end_ifndef

begin_define
define|#
directive|define
name|_GNU_SOURCE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|HAVE_STRCHR
operator|&&
operator|!
name|defined
name|_LIBC
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|strchr
end_ifndef

begin_define
define|#
directive|define
name|strchr
value|index
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|HAVE_UNISTD_H
operator|||
name|defined
name|_LIBC
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gettext.h"
end_include

begin_include
include|#
directive|include
file|"gettextP.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"libgettext.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"hash-string.h"
end_include

begin_comment
comment|/* @@ end of prolog @@ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_comment
comment|/* Rename the non ANSI C functions.  This is required by the standard    because some ANSI C functions will require linking with this object    file and the name space must not be polluted.  */
end_comment

begin_define
define|#
directive|define
name|getcwd
value|__getcwd
end_define

begin_define
define|#
directive|define
name|stpcpy
value|__stpcpy
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|!
name|defined
name|HAVE_GETCWD
end_if

begin_function_decl
name|char
modifier|*
name|getwd
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|getcwd
parameter_list|(
name|buf
parameter_list|,
name|max
parameter_list|)
value|getwd (buf)
end_define

begin_else
else|#
directive|else
end_else

begin_function_decl
name|char
modifier|*
name|getcwd
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STPCPY
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stpcpy
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|dest
operator|,
specifier|const
name|char
operator|*
name|src
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Amount to increase buffer size by in each try.  */
end_comment

begin_define
define|#
directive|define
name|PATH_INCR
value|32
end_define

begin_comment
comment|/* The following is from pathmax.h.  */
end_comment

begin_comment
comment|/* Non-POSIX BSD systems might have gcc's limits.h, which doesn't define    PATH_MAX but might cause redefinition warnings when sys/param.h is    later included (as on MORE/BSD 4.3).  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|HAVE_LIMITS_H
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|)
end_if

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_POSIX_PATH_MAX
end_ifndef

begin_define
define|#
directive|define
name|_POSIX_PATH_MAX
value|255
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PATH_MAX
argument_list|)
operator|&&
name|defined
argument_list|(
name|_PC_PATH_MAX
argument_list|)
end_if

begin_define
define|#
directive|define
name|PATH_MAX
value|(pathconf ("/", _PC_PATH_MAX)< 1 ? 1024 : pathconf ("/", _PC_PATH_MAX))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Don't include sys/param.h if it already has been.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_PARAM_H
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PATH_MAX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MAXPATHLEN
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PATH_MAX
argument_list|)
operator|&&
name|defined
argument_list|(
name|MAXPATHLEN
argument_list|)
end_if

begin_define
define|#
directive|define
name|PATH_MAX
value|MAXPATHLEN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PATH_MAX
end_ifndef

begin_define
define|#
directive|define
name|PATH_MAX
value|_POSIX_PATH_MAX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XPG3 defines the result of `setlocale (category, NULL)' as:    ``Directs `setlocale()' to query `category' and return the current      setting of `local'.''    However it does not specify the exact format.  And even worse: POSIX    defines this not at all.  So we can use this feature only on selected    system (e.g. those using GNU C Library).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_define
define|#
directive|define
name|HAVE_LOCALE_NULL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Name of the default domain used for gettext(3) prior any call to    textdomain(3).  The default value for this is "messages".  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|_nl_default_default_domain
index|[]
init|=
literal|"messages"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Value used as the default domain for gettext(3).  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|_nl_current_default_domain
init|=
name|_nl_default_default_domain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Contains the default location of the message catalogs.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|_nl_default_dirname
index|[]
init|=
name|GNULOCALEDIR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List with bindings of specific domains created by bindtextdomain()    calls.  */
end_comment

begin_decl_stmt
name|struct
name|binding
modifier|*
name|_nl_domain_bindings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|find_msg
name|PARAMS
argument_list|(
operator|(
expr|struct
name|loaded_l10nfile
operator|*
name|domain_file
operator|,
specifier|const
name|char
operator|*
name|msgid
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|category_to_name
name|PARAMS
argument_list|(
operator|(
name|int
name|category
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|guess_category_value
name|PARAMS
argument_list|(
operator|(
name|int
name|category
operator|,
specifier|const
name|char
operator|*
name|categoryname
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For those loosing systems which don't have `alloca' we have to add    some additional code emulating it.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ALLOCA
end_ifdef

begin_comment
comment|/* Nothing has to be done.  */
end_comment

begin_define
define|#
directive|define
name|ADD_BLOCK
parameter_list|(
name|list
parameter_list|,
name|address
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_define
define|#
directive|define
name|FREE_BLOCKS
parameter_list|(
name|list
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_else
else|#
directive|else
end_else

begin_struct
struct|struct
name|block_list
block|{
name|void
modifier|*
name|address
decl_stmt|;
name|struct
name|block_list
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ADD_BLOCK
parameter_list|(
name|list
parameter_list|,
name|addr
parameter_list|)
define|\
value|do {									      \     struct block_list *newp = (struct block_list *) malloc (sizeof (*newp));  \
comment|/* If we cannot get a free block we cannot add the new element to	      \        the list.  */
value|\     if (newp != NULL) {							      \       newp->address = (addr);						      \       newp->next = (list);						      \       (list) = newp;							      \     }									      \   } while (0)
end_define

begin_define
define|#
directive|define
name|FREE_BLOCKS
parameter_list|(
name|list
parameter_list|)
define|\
value|do {									      \     while (list != NULL) {						      \       struct block_list *old = list;					      \       list = list->next;						      \       free (old);							      \     }									      \   } while (0)
end_define

begin_undef
undef|#
directive|undef
name|alloca
end_undef

begin_define
define|#
directive|define
name|alloca
parameter_list|(
name|size
parameter_list|)
value|(malloc (size))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* have alloca */
end_comment

begin_comment
comment|/* Names for the libintl functions are a problem.  They must not clash    with existing names and they should follow ANSI C.  But this source    code is also used in GNU C Library where the names have a __    prefix.  So we have to make a difference here.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_define
define|#
directive|define
name|DCGETTEXT
value|__dcgettext
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DCGETTEXT
value|dcgettext__
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Look up MSGID in the DOMAINNAME message catalog for the current CATEGORY    locale.  */
end_comment

begin_function
name|char
modifier|*
name|DCGETTEXT
parameter_list|(
name|domainname
parameter_list|,
name|msgid
parameter_list|,
name|category
parameter_list|)
specifier|const
name|char
modifier|*
name|domainname
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|int
name|category
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|HAVE_ALLOCA
name|struct
name|block_list
modifier|*
name|block_list
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|struct
name|loaded_l10nfile
modifier|*
name|domain
decl_stmt|;
name|struct
name|binding
modifier|*
name|binding
decl_stmt|;
specifier|const
name|char
modifier|*
name|categoryname
decl_stmt|;
specifier|const
name|char
modifier|*
name|categoryvalue
decl_stmt|;
name|char
modifier|*
name|dirname
decl_stmt|,
modifier|*
name|xdomainname
decl_stmt|;
name|char
modifier|*
name|single_locale
decl_stmt|;
name|char
modifier|*
name|retval
decl_stmt|;
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
comment|/* If no real MSGID is given return NULL.  */
if|if
condition|(
name|msgid
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* If DOMAINNAME is NULL, we are interested in the default domain.  If      CATEGORY is not LC_MESSAGES this might not make much sense but the      defintion left this undefined.  */
if|if
condition|(
name|domainname
operator|==
name|NULL
condition|)
name|domainname
operator|=
name|_nl_current_default_domain
expr_stmt|;
comment|/* First find matching binding.  */
for|for
control|(
name|binding
operator|=
name|_nl_domain_bindings
init|;
name|binding
operator|!=
name|NULL
condition|;
name|binding
operator|=
name|binding
operator|->
name|next
control|)
block|{
name|int
name|compare
init|=
name|strcmp
argument_list|(
name|domainname
argument_list|,
name|binding
operator|->
name|domainname
argument_list|)
decl_stmt|;
if|if
condition|(
name|compare
operator|==
literal|0
condition|)
comment|/* We found it!  */
break|break;
if|if
condition|(
name|compare
operator|<
literal|0
condition|)
block|{
comment|/* It is not in the list.  */
name|binding
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|binding
operator|==
name|NULL
condition|)
name|dirname
operator|=
operator|(
name|char
operator|*
operator|)
name|_nl_default_dirname
expr_stmt|;
elseif|else
if|if
condition|(
name|binding
operator|->
name|dirname
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|dirname
operator|=
name|binding
operator|->
name|dirname
expr_stmt|;
else|else
block|{
comment|/* We have a relative path.  Make it absolute now.  */
name|size_t
name|dirname_len
init|=
name|strlen
argument_list|(
name|binding
operator|->
name|dirname
argument_list|)
operator|+
literal|1
decl_stmt|;
name|size_t
name|path_max
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
name|path_max
operator|=
operator|(
name|unsigned
operator|)
name|PATH_MAX
expr_stmt|;
name|path_max
operator|+=
literal|2
expr_stmt|;
comment|/* The getcwd docs say to do this.  */
name|dirname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|path_max
operator|+
name|dirname_len
argument_list|)
expr_stmt|;
name|ADD_BLOCK
argument_list|(
name|block_list
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
name|__set_errno
argument_list|(
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ret
operator|=
name|getcwd
argument_list|(
name|dirname
argument_list|,
name|path_max
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
name|errno
operator|==
name|ERANGE
condition|)
block|{
name|path_max
operator|+=
name|PATH_INCR
expr_stmt|;
name|dirname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|path_max
operator|+
name|dirname_len
argument_list|)
expr_stmt|;
name|ADD_BLOCK
argument_list|(
name|block_list
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
name|__set_errno
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
comment|/* We cannot get the current working directory.  Don't signal an 	     error but simply return the default string.  */
name|FREE_BLOCKS
argument_list|(
name|block_list
argument_list|)
expr_stmt|;
name|__set_errno
argument_list|(
name|saved_errno
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|msgid
return|;
block|}
name|stpcpy
argument_list|(
name|stpcpy
argument_list|(
name|strchr
argument_list|(
name|dirname
argument_list|,
literal|'\0'
argument_list|)
argument_list|,
literal|"/"
argument_list|)
argument_list|,
name|binding
operator|->
name|dirname
argument_list|)
expr_stmt|;
block|}
comment|/* Now determine the symbolic name of CATEGORY and its value.  */
name|categoryname
operator|=
name|category_to_name
argument_list|(
name|category
argument_list|)
expr_stmt|;
name|categoryvalue
operator|=
name|guess_category_value
argument_list|(
name|category
argument_list|,
name|categoryname
argument_list|)
expr_stmt|;
name|xdomainname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|categoryname
argument_list|)
operator|+
name|strlen
argument_list|(
name|domainname
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|ADD_BLOCK
argument_list|(
name|block_list
argument_list|,
name|xdomainname
argument_list|)
expr_stmt|;
name|stpcpy
argument_list|(
name|stpcpy
argument_list|(
name|stpcpy
argument_list|(
name|stpcpy
argument_list|(
name|xdomainname
argument_list|,
name|categoryname
argument_list|)
argument_list|,
literal|"/"
argument_list|)
argument_list|,
name|domainname
argument_list|)
argument_list|,
literal|".mo"
argument_list|)
expr_stmt|;
comment|/* Creating working area.  */
name|single_locale
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|categoryvalue
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ADD_BLOCK
argument_list|(
name|block_list
argument_list|,
name|single_locale
argument_list|)
expr_stmt|;
comment|/* Search for the given string.  This is a loop because we perhaps      got an ordered list of languages to consider for th translation.  */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Make CATEGORYVALUE point to the next element of the list.  */
while|while
condition|(
name|categoryvalue
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|categoryvalue
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
operator|++
name|categoryvalue
expr_stmt|;
if|if
condition|(
name|categoryvalue
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* The whole contents of CATEGORYVALUE has been searched but 	     no valid entry has been found.  We solve this situation 	     by implicitly appending a "C" entry, i.e. no translation 	     will take place.  */
name|single_locale
index|[
literal|0
index|]
operator|=
literal|'C'
expr_stmt|;
name|single_locale
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|cp
init|=
name|single_locale
decl_stmt|;
while|while
condition|(
name|categoryvalue
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|categoryvalue
index|[
literal|0
index|]
operator|!=
literal|':'
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|categoryvalue
operator|++
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* If the current locale value is C (or POSIX) we don't load a 	 domain.  Return the MSGID.  */
if|if
condition|(
name|strcmp
argument_list|(
name|single_locale
argument_list|,
literal|"C"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|single_locale
argument_list|,
literal|"POSIX"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FREE_BLOCKS
argument_list|(
name|block_list
argument_list|)
expr_stmt|;
name|__set_errno
argument_list|(
name|saved_errno
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|msgid
return|;
block|}
comment|/* Find structure describing the message catalog matching the 	 DOMAINNAME and CATEGORY.  */
name|domain
operator|=
name|_nl_find_domain
argument_list|(
name|dirname
argument_list|,
name|single_locale
argument_list|,
name|xdomainname
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain
operator|!=
name|NULL
condition|)
block|{
name|retval
operator|=
name|find_msg
argument_list|(
name|domain
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|NULL
condition|)
block|{
name|int
name|cnt
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|domain
operator|->
name|successor
index|[
name|cnt
index|]
operator|!=
name|NULL
condition|;
operator|++
name|cnt
control|)
block|{
name|retval
operator|=
name|find_msg
argument_list|(
name|domain
operator|->
name|successor
index|[
name|cnt
index|]
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
block|{
name|FREE_BLOCKS
argument_list|(
name|block_list
argument_list|)
expr_stmt|;
name|__set_errno
argument_list|(
name|saved_errno
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
block|}
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_comment
comment|/* Alias for function name in GNU C Library.  */
end_comment

begin_expr_stmt
name|weak_alias
argument_list|(
name|__dcgettext
argument_list|,
name|dcgettext
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|char
modifier|*
name|find_msg
parameter_list|(
name|domain_file
parameter_list|,
name|msgid
parameter_list|)
name|struct
name|loaded_l10nfile
modifier|*
name|domain_file
decl_stmt|;
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
block|{
name|size_t
name|top
decl_stmt|,
name|act
decl_stmt|,
name|bottom
decl_stmt|;
name|struct
name|loaded_domain
modifier|*
name|domain
decl_stmt|;
if|if
condition|(
name|domain_file
operator|->
name|decided
operator|==
literal|0
condition|)
name|_nl_load_domain
argument_list|(
name|domain_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain_file
operator|->
name|data
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|domain
operator|=
operator|(
expr|struct
name|loaded_domain
operator|*
operator|)
name|domain_file
operator|->
name|data
expr_stmt|;
comment|/* Locate the MSGID and its translation.  */
if|if
condition|(
name|domain
operator|->
name|hash_size
operator|>
literal|2
operator|&&
name|domain
operator|->
name|hash_tab
operator|!=
name|NULL
condition|)
block|{
comment|/* Use the hashing table.  */
name|nls_uint32
name|len
init|=
name|strlen
argument_list|(
name|msgid
argument_list|)
decl_stmt|;
name|nls_uint32
name|hash_val
init|=
name|hash_string
argument_list|(
name|msgid
argument_list|)
decl_stmt|;
name|nls_uint32
name|idx
init|=
name|hash_val
operator|%
name|domain
operator|->
name|hash_size
decl_stmt|;
name|nls_uint32
name|incr
init|=
literal|1
operator|+
operator|(
name|hash_val
operator|%
operator|(
name|domain
operator|->
name|hash_size
operator|-
literal|2
operator|)
operator|)
decl_stmt|;
name|nls_uint32
name|nstr
init|=
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|domain
operator|->
name|hash_tab
index|[
name|idx
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|nstr
operator|==
literal|0
condition|)
comment|/* Hash table entry is empty.  */
return|return
name|NULL
return|;
if|if
condition|(
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|domain
operator|->
name|orig_tab
index|[
name|nstr
operator|-
literal|1
index|]
operator|.
name|length
argument_list|)
operator|==
name|len
operator|&&
name|strcmp
argument_list|(
name|msgid
argument_list|,
name|domain
operator|->
name|data
operator|+
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|domain
operator|->
name|orig_tab
index|[
name|nstr
operator|-
literal|1
index|]
operator|.
name|offset
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|domain
operator|->
name|data
operator|+
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|domain
operator|->
name|trans_tab
index|[
name|nstr
operator|-
literal|1
index|]
operator|.
name|offset
argument_list|)
return|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|idx
operator|>=
name|domain
operator|->
name|hash_size
operator|-
name|incr
condition|)
name|idx
operator|-=
name|domain
operator|->
name|hash_size
operator|-
name|incr
expr_stmt|;
else|else
name|idx
operator|+=
name|incr
expr_stmt|;
name|nstr
operator|=
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|domain
operator|->
name|hash_tab
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nstr
operator|==
literal|0
condition|)
comment|/* Hash table entry is empty.  */
return|return
name|NULL
return|;
if|if
condition|(
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|domain
operator|->
name|orig_tab
index|[
name|nstr
operator|-
literal|1
index|]
operator|.
name|length
argument_list|)
operator|==
name|len
operator|&&
name|strcmp
argument_list|(
name|msgid
argument_list|,
name|domain
operator|->
name|data
operator|+
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|domain
operator|->
name|orig_tab
index|[
name|nstr
operator|-
literal|1
index|]
operator|.
name|offset
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|domain
operator|->
name|data
operator|+
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|domain
operator|->
name|trans_tab
index|[
name|nstr
operator|-
literal|1
index|]
operator|.
name|offset
argument_list|)
return|;
block|}
comment|/* NOTREACHED */
block|}
comment|/* Now we try the default method:  binary search in the sorted      array of messages.  */
name|bottom
operator|=
literal|0
expr_stmt|;
name|top
operator|=
name|domain
operator|->
name|nstrings
expr_stmt|;
while|while
condition|(
name|bottom
operator|<
name|top
condition|)
block|{
name|int
name|cmp_val
decl_stmt|;
name|act
operator|=
operator|(
name|bottom
operator|+
name|top
operator|)
operator|/
literal|2
expr_stmt|;
name|cmp_val
operator|=
name|strcmp
argument_list|(
name|msgid
argument_list|,
name|domain
operator|->
name|data
operator|+
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|domain
operator|->
name|orig_tab
index|[
name|act
index|]
operator|.
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp_val
operator|<
literal|0
condition|)
name|top
operator|=
name|act
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp_val
operator|>
literal|0
condition|)
name|bottom
operator|=
name|act
operator|+
literal|1
expr_stmt|;
else|else
break|break;
block|}
comment|/* If an translation is found return this.  */
return|return
name|bottom
operator|>=
name|top
condition|?
name|NULL
else|:
operator|(
name|char
operator|*
operator|)
name|domain
operator|->
name|data
operator|+
name|W
argument_list|(
name|domain
operator|->
name|must_swap
argument_list|,
name|domain
operator|->
name|trans_tab
index|[
name|act
index|]
operator|.
name|offset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return string representation of locale CATEGORY.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|category_to_name
parameter_list|(
name|category
parameter_list|)
name|int
name|category
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|retval
decl_stmt|;
switch|switch
condition|(
name|category
condition|)
block|{
ifdef|#
directive|ifdef
name|LC_COLLATE
case|case
name|LC_COLLATE
case|:
name|retval
operator|=
literal|"LC_COLLATE"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LC_CTYPE
case|case
name|LC_CTYPE
case|:
name|retval
operator|=
literal|"LC_CTYPE"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LC_MONETARY
case|case
name|LC_MONETARY
case|:
name|retval
operator|=
literal|"LC_MONETARY"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LC_NUMERIC
case|case
name|LC_NUMERIC
case|:
name|retval
operator|=
literal|"LC_NUMERIC"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LC_TIME
case|case
name|LC_TIME
case|:
name|retval
operator|=
literal|"LC_TIME"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LC_MESSAGES
case|case
name|LC_MESSAGES
case|:
name|retval
operator|=
literal|"LC_MESSAGES"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LC_RESPONSE
case|case
name|LC_RESPONSE
case|:
name|retval
operator|=
literal|"LC_RESPONSE"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LC_ALL
case|case
name|LC_ALL
case|:
comment|/* This might not make sense but is perhaps better than any other        value.  */
name|retval
operator|=
literal|"LC_ALL"
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* If you have a better idea for a default value let me know.  */
name|retval
operator|=
literal|"LC_XXX"
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Guess value of current locale from value of the environment variables.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|guess_category_value
parameter_list|(
name|category
parameter_list|,
name|categoryname
parameter_list|)
name|int
name|category
decl_stmt|;
specifier|const
name|char
modifier|*
name|categoryname
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|retval
decl_stmt|;
comment|/* The highest priority value is the `LANGUAGE' environment      variable.  This is a GNU extension.  */
name|retval
operator|=
name|getenv
argument_list|(
literal|"LANGUAGE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
operator|&&
name|retval
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
return|return
name|retval
return|;
comment|/* `LANGUAGE' is not set.  So we have to proceed with the POSIX      methods of looking to `LC_ALL', `LC_xxx', and `LANG'.  On some      systems this can be done by the `setlocale' function itself.  */
if|#
directive|if
name|defined
name|HAVE_SETLOCALE
operator|&&
name|defined
name|HAVE_LC_MESSAGES
operator|&&
name|defined
name|HAVE_LOCALE_NULL
return|return
name|setlocale
argument_list|(
name|category
argument_list|,
name|NULL
argument_list|)
return|;
else|#
directive|else
comment|/* Setting of LC_ALL overwrites all other.  */
name|retval
operator|=
name|getenv
argument_list|(
literal|"LC_ALL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
operator|&&
name|retval
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
return|return
name|retval
return|;
comment|/* Next comes the name of the desired category.  */
name|retval
operator|=
name|getenv
argument_list|(
name|categoryname
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
operator|&&
name|retval
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
return|return
name|retval
return|;
comment|/* Last possibility is the LANG environment variable.  */
name|retval
operator|=
name|getenv
argument_list|(
literal|"LANG"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
operator|&&
name|retval
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
return|return
name|retval
return|;
comment|/* We use C as the default domain.  POSIX says this is implementation      defined.  */
return|return
literal|"C"
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* @@ begin of epilog @@ */
end_comment

begin_comment
comment|/* We don't want libintl.a to depend on any other library.  So we    avoid the non-standard function stpcpy.  In GNU C Library this    function is available, though.  Also allow the symbol HAVE_STPCPY    to be defined.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|_LIBC
operator|&&
operator|!
name|HAVE_STPCPY
end_if

begin_function
specifier|static
name|char
modifier|*
name|stpcpy
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|char
modifier|*
name|dest
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
block|{
while|while
condition|(
operator|(
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
comment|/* Do nothing. */
empty_stmt|;
return|return
name|dest
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

