begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle list of needed message catalogs    Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.    Written by Ulrich Drepper<drepper@gnu.ai.mit.edu>, 1995.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
name|STDC_HEADERS
operator|||
name|defined
name|_LIBC
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MALLOC_H
end_ifdef

begin_include
include|#
directive|include
file|<malloc.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|HAVE_STRING_H
operator|||
name|defined
name|_LIBC
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|memcpy
end_ifndef

begin_define
define|#
directive|define
name|memcpy
parameter_list|(
name|Dst
parameter_list|,
name|Src
parameter_list|,
name|Num
parameter_list|)
value|bcopy (Src, Dst, Num)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|HAVE_STRCHR
operator|&&
operator|!
name|defined
name|_LIBC
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|strchr
end_ifndef

begin_define
define|#
directive|define
name|strchr
value|index
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|HAVE_UNISTD_H
operator|||
name|defined
name|_LIBC
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gettext.h"
end_include

begin_include
include|#
directive|include
file|"gettextP.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"libgettext.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* @@ end of prolog @@ */
end_comment

begin_comment
comment|/* List of already loaded domains.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|loaded_l10nfile
modifier|*
name|_nl_loaded_domains
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a data structure describing the message catalog described by    the DOMAINNAME and CATEGORY parameters with respect to the currently    established bindings.  */
end_comment

begin_function
name|struct
name|loaded_l10nfile
modifier|*
name|_nl_find_domain
parameter_list|(
name|dirname
parameter_list|,
name|locale
parameter_list|,
name|domainname
parameter_list|)
specifier|const
name|char
modifier|*
name|dirname
decl_stmt|;
name|char
modifier|*
name|locale
decl_stmt|;
specifier|const
name|char
modifier|*
name|domainname
decl_stmt|;
block|{
name|struct
name|loaded_l10nfile
modifier|*
name|retval
decl_stmt|;
specifier|const
name|char
modifier|*
name|language
decl_stmt|;
specifier|const
name|char
modifier|*
name|modifier
decl_stmt|;
specifier|const
name|char
modifier|*
name|territory
decl_stmt|;
specifier|const
name|char
modifier|*
name|codeset
decl_stmt|;
specifier|const
name|char
modifier|*
name|normalized_codeset
decl_stmt|;
specifier|const
name|char
modifier|*
name|special
decl_stmt|;
specifier|const
name|char
modifier|*
name|sponsor
decl_stmt|;
specifier|const
name|char
modifier|*
name|revision
decl_stmt|;
specifier|const
name|char
modifier|*
name|alias_value
decl_stmt|;
name|int
name|mask
decl_stmt|;
comment|/* LOCALE can consist of up to four recognized parts for the XPG syntax:  		language[_territory[.codeset]][@modifier]       and six parts for the CEN syntax:  	language[_territory][+audience][+special][,[sponsor][_revision]]       Beside the first all of them are allowed to be missing.  If the      full specified locale is not found, the less specific one are      looked for.  The various part will be stripped of according to      the following order: 		(1) revision 		(2) sponsor 		(3) special 		(4) codeset 		(5) normalized codeset 		(6) territory 		(7) audience/modifier    */
comment|/* If we have already tested for this locale entry there has to      be one data set in the list of loaded domains.  */
name|retval
operator|=
name|_nl_make_l10nflist
argument_list|(
operator|&
name|_nl_loaded_domains
argument_list|,
name|dirname
argument_list|,
name|strlen
argument_list|(
name|dirname
argument_list|)
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
name|locale
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|domainname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
block|{
comment|/* We know something about this locale.  */
name|int
name|cnt
decl_stmt|;
if|if
condition|(
name|retval
operator|->
name|decided
operator|==
literal|0
condition|)
name|_nl_load_domain
argument_list|(
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|->
name|data
operator|!=
name|NULL
condition|)
return|return
name|retval
return|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|retval
operator|->
name|successor
index|[
name|cnt
index|]
operator|!=
name|NULL
condition|;
operator|++
name|cnt
control|)
block|{
if|if
condition|(
name|retval
operator|->
name|successor
index|[
name|cnt
index|]
operator|->
name|decided
operator|==
literal|0
condition|)
name|_nl_load_domain
argument_list|(
name|retval
operator|->
name|successor
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|->
name|successor
index|[
name|cnt
index|]
operator|->
name|data
operator|!=
name|NULL
condition|)
break|break;
block|}
return|return
name|cnt
operator|>=
literal|0
condition|?
name|retval
else|:
name|NULL
return|;
comment|/* NOTREACHED */
block|}
comment|/* See whether the locale value is an alias.  If yes its value      *overwrites* the alias name.  No test for the original value is      done.  */
name|alias_value
operator|=
name|_nl_expand_alias
argument_list|(
name|locale
argument_list|)
expr_stmt|;
if|if
condition|(
name|alias_value
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|alias_value
argument_list|)
operator|+
literal|1
decl_stmt|;
name|locale
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|locale
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
name|locale
argument_list|,
name|alias_value
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* Now we determine the single parts of the locale name.  First      look for the language.  Termination symbols are `_' and `@' if      we use XPG4 style, and `_', `+', and `,' if we use CEN syntax.  */
name|mask
operator|=
name|_nl_explode_name
argument_list|(
name|locale
argument_list|,
operator|&
name|language
argument_list|,
operator|&
name|modifier
argument_list|,
operator|&
name|territory
argument_list|,
operator|&
name|codeset
argument_list|,
operator|&
name|normalized_codeset
argument_list|,
operator|&
name|special
argument_list|,
operator|&
name|sponsor
argument_list|,
operator|&
name|revision
argument_list|)
expr_stmt|;
comment|/* Create all possible locale entries which might be interested in      generalization.  */
name|retval
operator|=
name|_nl_make_l10nflist
argument_list|(
operator|&
name|_nl_loaded_domains
argument_list|,
name|dirname
argument_list|,
name|strlen
argument_list|(
name|dirname
argument_list|)
operator|+
literal|1
argument_list|,
name|mask
argument_list|,
name|language
argument_list|,
name|territory
argument_list|,
name|codeset
argument_list|,
name|normalized_codeset
argument_list|,
name|modifier
argument_list|,
name|special
argument_list|,
name|sponsor
argument_list|,
name|revision
argument_list|,
name|domainname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|NULL
condition|)
comment|/* This means we are out of core.  */
return|return
name|NULL
return|;
if|if
condition|(
name|retval
operator|->
name|decided
operator|==
literal|0
condition|)
name|_nl_load_domain
argument_list|(
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|int
name|cnt
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|retval
operator|->
name|successor
index|[
name|cnt
index|]
operator|!=
name|NULL
condition|;
operator|++
name|cnt
control|)
block|{
if|if
condition|(
name|retval
operator|->
name|successor
index|[
name|cnt
index|]
operator|->
name|decided
operator|==
literal|0
condition|)
name|_nl_load_domain
argument_list|(
name|retval
operator|->
name|successor
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|->
name|successor
index|[
name|cnt
index|]
operator|->
name|data
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
comment|/* The room for an alias was dynamically allocated.  Free it now.  */
if|if
condition|(
name|alias_value
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|locale
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

end_unit

