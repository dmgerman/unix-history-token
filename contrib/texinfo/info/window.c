begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* window.c -- windows in Info.    $Id: window.c,v 1.15 2002/01/19 01:08:20 karl Exp $     Copyright (C) 1993, 97, 98, 2001, 02 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Written by Brian Fox (bfox@ai.mit.edu). */
end_comment

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_include
include|#
directive|include
file|"nodes.h"
end_include

begin_include
include|#
directive|include
file|"window.h"
end_include

begin_include
include|#
directive|include
file|"display.h"
end_include

begin_include
include|#
directive|include
file|"info-utils.h"
end_include

begin_include
include|#
directive|include
file|"infomap.h"
end_include

begin_comment
comment|/* The window which describes the screen. */
end_comment

begin_decl_stmt
name|WINDOW
modifier|*
name|the_screen
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The window which describes the echo area. */
end_comment

begin_decl_stmt
name|WINDOW
modifier|*
name|the_echo_area
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of windows in Info. */
end_comment

begin_decl_stmt
name|WINDOW
modifier|*
name|windows
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to the active window in WINDOW_LIST. */
end_comment

begin_decl_stmt
name|WINDOW
modifier|*
name|active_window
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The size of the echo area in Info.  It never changes, irregardless of the    size of the screen. */
end_comment

begin_define
define|#
directive|define
name|ECHO_AREA_HEIGHT
value|1
end_define

begin_comment
comment|/* Macro returns the amount of space that the echo area truly requires relative    to the entire screen. */
end_comment

begin_define
define|#
directive|define
name|echo_area_required
value|(1 + the_echo_area->height)
end_define

begin_comment
comment|/* Initalize the window system by creating THE_SCREEN and THE_ECHO_AREA.    Create the first window ever.    You pass the dimensions of the total screen size. */
end_comment

begin_function
name|void
name|window_initialize_windows
parameter_list|(
name|width
parameter_list|,
name|height
parameter_list|)
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
block|{
name|the_screen
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|WINDOW
argument_list|)
argument_list|)
expr_stmt|;
name|the_echo_area
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|WINDOW
argument_list|)
argument_list|)
expr_stmt|;
name|windows
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|WINDOW
argument_list|)
argument_list|)
expr_stmt|;
name|active_window
operator|=
name|windows
expr_stmt|;
name|zero_mem
argument_list|(
name|the_screen
argument_list|,
sizeof|sizeof
argument_list|(
name|WINDOW
argument_list|)
argument_list|)
expr_stmt|;
name|zero_mem
argument_list|(
name|the_echo_area
argument_list|,
sizeof|sizeof
argument_list|(
name|WINDOW
argument_list|)
argument_list|)
expr_stmt|;
name|zero_mem
argument_list|(
name|active_window
argument_list|,
sizeof|sizeof
argument_list|(
name|WINDOW
argument_list|)
argument_list|)
expr_stmt|;
comment|/* None of these windows has a goal column yet. */
name|the_echo_area
operator|->
name|goal_column
operator|=
operator|-
literal|1
expr_stmt|;
name|active_window
operator|->
name|goal_column
operator|=
operator|-
literal|1
expr_stmt|;
name|the_screen
operator|->
name|goal_column
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* The active and echo_area windows are visible.      The echo_area is permanent.      The screen is permanent. */
name|active_window
operator|->
name|flags
operator|=
name|W_WindowVisible
expr_stmt|;
name|the_echo_area
operator|->
name|flags
operator|=
name|W_WindowIsPerm
operator||
name|W_InhibitMode
operator||
name|W_WindowVisible
expr_stmt|;
name|the_screen
operator|->
name|flags
operator|=
name|W_WindowIsPerm
expr_stmt|;
comment|/* The height of the echo area never changes.  It is statically set right      here, and it must be at least 1 line for display.  The size of the      initial window cannot be the same size as the screen, since the screen      includes the echo area.  So, we make the height of the initial window      equal to the screen's displayable region minus the height of the echo      area. */
name|the_echo_area
operator|->
name|height
operator|=
name|ECHO_AREA_HEIGHT
expr_stmt|;
name|active_window
operator|->
name|height
operator|=
name|the_screen
operator|->
name|height
operator|-
literal|1
operator|-
name|the_echo_area
operator|->
name|height
expr_stmt|;
name|window_new_screen_size
argument_list|(
name|width
argument_list|,
name|height
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* The echo area uses a different keymap than normal info windows. */
name|the_echo_area
operator|->
name|keymap
operator|=
name|echo_area_keymap
expr_stmt|;
name|active_window
operator|->
name|keymap
operator|=
name|info_keymap
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given that the size of the screen has changed to WIDTH and HEIGHT    from whatever it was before (found in the_screen->height, ->width),    change the size (and possibly location) of each window in the screen.    If a window would become too small, call the function DELETER on it,    after deleting the window from our chain of windows.  If DELETER is NULL,    nothing extra is done.  The last window can never be deleted, but it can    become invisible. */
end_comment

begin_comment
comment|/* If non-null, a function to call with WINDOW as argument when the function    window_new_screen_size () has deleted WINDOW. */
end_comment

begin_decl_stmt
name|VFunction
modifier|*
name|window_deletion_notifier
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|window_new_screen_size
parameter_list|(
name|width
parameter_list|,
name|height
parameter_list|)
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
block|{
specifier|register
name|WINDOW
modifier|*
name|win
decl_stmt|;
name|int
name|delta_height
decl_stmt|,
name|delta_each
decl_stmt|,
name|delta_leftover
decl_stmt|;
name|int
name|numwins
decl_stmt|;
comment|/* If no change, do nothing. */
if|if
condition|(
name|width
operator|==
name|the_screen
operator|->
name|width
operator|&&
name|height
operator|==
name|the_screen
operator|->
name|height
condition|)
return|return;
comment|/* If the new window height is too small, make it be zero. */
if|if
condition|(
name|height
operator|<
operator|(
name|WINDOW_MIN_SIZE
operator|+
name|the_echo_area
operator|->
name|height
operator|)
condition|)
name|height
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|width
operator|<
literal|0
condition|)
name|width
operator|=
literal|0
expr_stmt|;
comment|/* Find out how many windows will change. */
for|for
control|(
name|numwins
operator|=
literal|0
operator|,
name|win
operator|=
name|windows
init|;
name|win
condition|;
name|win
operator|=
name|win
operator|->
name|next
operator|,
name|numwins
operator|++
control|)
empty_stmt|;
comment|/* See if some windows will need to be deleted.  This is the case if      the screen is getting smaller, and the available space divided by      the number of windows is less than WINDOW_MIN_SIZE.  In that case,      delete some windows and try again until there is either enough      space to divy up among the windows, or until there is only one      window left. */
while|while
condition|(
operator|(
name|height
operator|-
name|echo_area_required
operator|)
operator|/
name|numwins
operator|<=
name|WINDOW_MIN_SIZE
condition|)
block|{
comment|/* If only one window, make the size of it be zero, and return          immediately. */
if|if
condition|(
operator|!
name|windows
operator|->
name|next
condition|)
block|{
name|windows
operator|->
name|height
operator|=
literal|0
expr_stmt|;
name|maybe_free
argument_list|(
name|windows
operator|->
name|line_starts
argument_list|)
expr_stmt|;
name|windows
operator|->
name|line_starts
operator|=
name|NULL
expr_stmt|;
name|windows
operator|->
name|line_count
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* If we have some temporary windows, delete one of them. */
for|for
control|(
name|win
operator|=
name|windows
init|;
name|win
condition|;
name|win
operator|=
name|win
operator|->
name|next
control|)
if|if
condition|(
name|win
operator|->
name|flags
operator|&
name|W_TempWindow
condition|)
break|break;
comment|/* Otherwise, delete the first window, and try again. */
if|if
condition|(
operator|!
name|win
condition|)
name|win
operator|=
name|windows
expr_stmt|;
if|if
condition|(
name|window_deletion_notifier
condition|)
call|(
modifier|*
name|window_deletion_notifier
call|)
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|window_delete_window
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|numwins
operator|--
expr_stmt|;
block|}
comment|/* The screen has changed height and width. */
name|delta_height
operator|=
name|height
operator|-
name|the_screen
operator|->
name|height
expr_stmt|;
comment|/* This is how much. */
name|the_screen
operator|->
name|height
operator|=
name|height
expr_stmt|;
comment|/* This is the new height. */
name|the_screen
operator|->
name|width
operator|=
name|width
expr_stmt|;
comment|/* This is the new width. */
comment|/* Set the start of the echo area. */
name|the_echo_area
operator|->
name|first_row
operator|=
name|height
operator|-
name|the_echo_area
operator|->
name|height
expr_stmt|;
name|the_echo_area
operator|->
name|width
operator|=
name|width
expr_stmt|;
comment|/* Check to see if the screen can really be changed this way. */
if|if
condition|(
operator|(
operator|!
name|windows
operator|->
name|next
operator|)
operator|&&
operator|(
operator|(
name|windows
operator|->
name|height
operator|==
literal|0
operator|)
operator|&&
operator|(
name|delta_height
operator|<
literal|0
operator|)
operator|)
condition|)
return|return;
comment|/* Divide the change in height among the available windows. */
name|delta_each
operator|=
name|delta_height
operator|/
name|numwins
expr_stmt|;
name|delta_leftover
operator|=
name|delta_height
operator|-
operator|(
name|delta_each
operator|*
name|numwins
operator|)
expr_stmt|;
comment|/* Change the height of each window in the chain by delta_each.  Change      the height of the last window in the chain by delta_each and by the      leftover amount of change.  Change the width of each window to be      WIDTH. */
for|for
control|(
name|win
operator|=
name|windows
init|;
name|win
condition|;
name|win
operator|=
name|win
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|win
operator|->
name|width
operator|!=
name|width
operator|)
operator|&&
operator|(
operator|(
name|win
operator|->
name|flags
operator|&
name|W_InhibitMode
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|win
operator|->
name|width
operator|=
name|width
expr_stmt|;
name|maybe_free
argument_list|(
name|win
operator|->
name|modeline
argument_list|)
expr_stmt|;
name|win
operator|->
name|modeline
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|width
argument_list|)
expr_stmt|;
block|}
name|win
operator|->
name|height
operator|+=
name|delta_each
expr_stmt|;
comment|/* If the previous height of this window was zero, it was the only          window, and it was not visible.  Thus we need to compensate for          the echo_area. */
if|if
condition|(
name|win
operator|->
name|height
operator|==
name|delta_each
condition|)
name|win
operator|->
name|height
operator|-=
operator|(
literal|1
operator|+
name|the_echo_area
operator|->
name|height
operator|)
expr_stmt|;
comment|/* If this is not the first window in the chain, then change the          first row of it.  We cannot just add delta_each to the first row,          since this window's first row is the sum of the collective increases          that have gone before it.  So we just add one to the location of the          previous window's modeline. */
if|if
condition|(
name|win
operator|->
name|prev
condition|)
name|win
operator|->
name|first_row
operator|=
operator|(
name|win
operator|->
name|prev
operator|->
name|first_row
operator|+
name|win
operator|->
name|prev
operator|->
name|height
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* The last window in the chain gets the extra space (or shrinkage). */
if|if
condition|(
operator|!
name|win
operator|->
name|next
condition|)
name|win
operator|->
name|height
operator|+=
name|delta_leftover
expr_stmt|;
if|if
condition|(
name|win
operator|->
name|node
condition|)
name|recalculate_line_starts
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|win
operator|->
name|flags
operator||=
name|W_UpdateWindow
expr_stmt|;
block|}
comment|/* If the screen got smaller, check over the windows just shrunk to      keep them within bounds.  Some of the windows may have gotten smaller      than WINDOW_MIN_HEIGHT in which case some of the other windows are      larger than the available display space in the screen.  Because of our      intial test above, we know that there is enough space for all of the      windows. */
if|if
condition|(
operator|(
name|delta_each
operator|<
literal|0
operator|)
operator|&&
operator|(
operator|(
name|windows
operator|->
name|height
operator|!=
literal|0
operator|)
operator|&&
name|windows
operator|->
name|next
operator|)
condition|)
block|{
name|int
name|avail
decl_stmt|;
name|avail
operator|=
name|the_screen
operator|->
name|height
operator|-
operator|(
name|numwins
operator|+
name|the_echo_area
operator|->
name|height
operator|)
expr_stmt|;
name|win
operator|=
name|windows
expr_stmt|;
while|while
condition|(
name|win
condition|)
block|{
if|if
condition|(
operator|(
name|win
operator|->
name|height
operator|<
name|WINDOW_MIN_HEIGHT
operator|)
operator|||
operator|(
name|win
operator|->
name|height
operator|>
name|avail
operator|)
condition|)
block|{
name|WINDOW
modifier|*
name|lastwin
decl_stmt|;
comment|/* Split the space among the available windows. */
name|delta_each
operator|=
name|avail
operator|/
name|numwins
expr_stmt|;
name|delta_leftover
operator|=
name|avail
operator|-
operator|(
name|delta_each
operator|*
name|numwins
operator|)
expr_stmt|;
for|for
control|(
name|win
operator|=
name|windows
init|;
name|win
condition|;
name|win
operator|=
name|win
operator|->
name|next
control|)
block|{
name|lastwin
operator|=
name|win
expr_stmt|;
if|if
condition|(
name|win
operator|->
name|prev
condition|)
name|win
operator|->
name|first_row
operator|=
operator|(
name|win
operator|->
name|prev
operator|->
name|first_row
operator|+
name|win
operator|->
name|prev
operator|->
name|height
operator|)
operator|+
literal|1
expr_stmt|;
name|win
operator|->
name|height
operator|=
name|delta_each
expr_stmt|;
block|}
comment|/* Give the leftover space (if any) to the last window. */
name|lastwin
operator|->
name|height
operator|+=
name|delta_leftover
expr_stmt|;
break|break;
block|}
else|else
name|win
operator|=
name|win
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Make a new window showing NODE, and return that window structure.    If NODE is passed as NULL, then show the node showing in the active    window.  If the window could not be made return a NULL pointer.  The    active window is not changed.*/
end_comment

begin_function
name|WINDOW
modifier|*
name|window_make_window
parameter_list|(
name|node
parameter_list|)
name|NODE
modifier|*
name|node
decl_stmt|;
block|{
name|WINDOW
modifier|*
name|window
decl_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
name|node
operator|=
name|active_window
operator|->
name|node
expr_stmt|;
comment|/* If there isn't enough room to make another window, return now. */
if|if
condition|(
operator|(
name|active_window
operator|->
name|height
operator|/
literal|2
operator|)
operator|<
name|WINDOW_MIN_SIZE
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Make and initialize the new window.      The fudging about with -1 and +1 is because the following window in the      chain cannot start at window->height, since that is where the modeline      for the previous window is displayed.  The inverse adjustment is made      in window_delete_window (). */
name|window
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|WINDOW
argument_list|)
argument_list|)
expr_stmt|;
name|window
operator|->
name|width
operator|=
name|the_screen
operator|->
name|width
expr_stmt|;
name|window
operator|->
name|height
operator|=
operator|(
name|active_window
operator|->
name|height
operator|/
literal|2
operator|)
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SPLIT_BEFORE_ACTIVE
argument_list|)
name|window
operator|->
name|first_row
operator|=
name|active_window
operator|->
name|first_row
expr_stmt|;
else|#
directive|else
name|window
operator|->
name|first_row
operator|=
name|active_window
operator|->
name|first_row
operator|+
operator|(
name|active_window
operator|->
name|height
operator|-
name|window
operator|->
name|height
operator|)
expr_stmt|;
endif|#
directive|endif
name|window
operator|->
name|keymap
operator|=
name|info_keymap
expr_stmt|;
name|window
operator|->
name|goal_column
operator|=
operator|-
literal|1
expr_stmt|;
name|window
operator|->
name|modeline
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|window
operator|->
name|width
argument_list|)
expr_stmt|;
name|window
operator|->
name|line_starts
operator|=
name|NULL
expr_stmt|;
name|window
operator|->
name|flags
operator|=
name|W_UpdateWindow
operator||
name|W_WindowVisible
expr_stmt|;
name|window_set_node_of_window
argument_list|(
name|window
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|/* Adjust the height of the old active window. */
name|active_window
operator|->
name|height
operator|-=
operator|(
name|window
operator|->
name|height
operator|+
literal|1
operator|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SPLIT_BEFORE_ACTIVE
argument_list|)
name|active_window
operator|->
name|first_row
operator|+=
operator|(
name|window
operator|->
name|height
operator|+
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
name|active_window
operator|->
name|flags
operator||=
name|W_UpdateWindow
expr_stmt|;
comment|/* Readjust the new and old windows so that their modelines and contents      will be displayed correctly. */
if|#
directive|if
name|defined
argument_list|(
name|NOTDEF
argument_list|)
comment|/* We don't have to do this for WINDOW since window_set_node_of_window ()      already did. */
name|window_adjust_pagetop
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|window_make_modeline
argument_list|(
name|window
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NOTDEF */
comment|/* We do have to readjust the existing active window. */
name|window_adjust_pagetop
argument_list|(
name|active_window
argument_list|)
expr_stmt|;
name|window_make_modeline
argument_list|(
name|active_window
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SPLIT_BEFORE_ACTIVE
argument_list|)
comment|/* This window is just before the active one.  The active window gets      bumped down one.  The active window is not changed. */
name|window
operator|->
name|next
operator|=
name|active_window
expr_stmt|;
name|window
operator|->
name|prev
operator|=
name|active_window
operator|->
name|prev
expr_stmt|;
name|active_window
operator|->
name|prev
operator|=
name|window
expr_stmt|;
if|if
condition|(
name|window
operator|->
name|prev
condition|)
name|window
operator|->
name|prev
operator|->
name|next
operator|=
name|window
expr_stmt|;
else|else
name|windows
operator|=
name|window
expr_stmt|;
else|#
directive|else
comment|/* This window is just after the active one.  Which window is active is      not changed. */
name|window
operator|->
name|prev
operator|=
name|active_window
expr_stmt|;
name|window
operator|->
name|next
operator|=
name|active_window
operator|->
name|next
expr_stmt|;
name|active_window
operator|->
name|next
operator|=
name|window
expr_stmt|;
if|if
condition|(
name|window
operator|->
name|next
condition|)
name|window
operator|->
name|next
operator|->
name|prev
operator|=
name|window
expr_stmt|;
endif|#
directive|endif
comment|/* !SPLIT_BEFORE_ACTIVE */
return|return
operator|(
name|window
operator|)
return|;
block|}
end_function

begin_comment
comment|/* These useful macros make it possible to read the code in    window_change_window_height (). */
end_comment

begin_define
define|#
directive|define
name|grow_me_shrinking_next
parameter_list|(
name|me
parameter_list|,
name|next
parameter_list|,
name|diff
parameter_list|)
define|\
value|do { \     me->height += diff; \     next->height -= diff; \     next->first_row += diff; \     window_adjust_pagetop (next); \   } while (0)
end_define

begin_define
define|#
directive|define
name|grow_me_shrinking_prev
parameter_list|(
name|me
parameter_list|,
name|prev
parameter_list|,
name|diff
parameter_list|)
define|\
value|do { \     me->height += diff; \     prev->height -= diff; \     me->first_row -=diff; \     window_adjust_pagetop (prev); \   } while (0)
end_define

begin_define
define|#
directive|define
name|shrink_me_growing_next
parameter_list|(
name|me
parameter_list|,
name|next
parameter_list|,
name|diff
parameter_list|)
define|\
value|do { \     me->height -= diff; \     next->height += diff; \     next->first_row -= diff; \     window_adjust_pagetop (next); \   } while (0)
end_define

begin_define
define|#
directive|define
name|shrink_me_growing_prev
parameter_list|(
name|me
parameter_list|,
name|prev
parameter_list|,
name|diff
parameter_list|)
define|\
value|do { \     me->height -= diff; \     prev->height += diff; \     me->first_row += diff; \     window_adjust_pagetop (prev); \   } while (0)
end_define

begin_comment
comment|/* Change the height of WINDOW by AMOUNT.  This also automagically adjusts    the previous and next windows in the chain.  If there is only one user    window, then no change takes place. */
end_comment

begin_function
name|void
name|window_change_window_height
parameter_list|(
name|window
parameter_list|,
name|amount
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|int
name|amount
decl_stmt|;
block|{
specifier|register
name|WINDOW
modifier|*
name|win
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
comment|/* If there is only one window, or if the amount of change is zero,      return immediately. */
if|if
condition|(
operator|!
name|windows
operator|->
name|next
operator|||
name|amount
operator|==
literal|0
condition|)
return|return;
comment|/* Find this window in our chain. */
for|for
control|(
name|win
operator|=
name|windows
init|;
name|win
condition|;
name|win
operator|=
name|win
operator|->
name|next
control|)
if|if
condition|(
name|win
operator|==
name|window
condition|)
break|break;
comment|/* If the window is isolated (i.e., doesn't appear in our window list,      then quit now. */
if|if
condition|(
operator|!
name|win
condition|)
return|return;
comment|/* Change the height of this window by AMOUNT, if that is possible.      It can be impossible if there isn't enough available room on the      screen, or if the resultant window would be too small. */
name|prev
operator|=
name|window
operator|->
name|prev
expr_stmt|;
name|next
operator|=
name|window
operator|->
name|next
expr_stmt|;
comment|/* WINDOW decreasing in size? */
if|if
condition|(
name|amount
operator|<
literal|0
condition|)
block|{
name|int
name|abs_amount
init|=
operator|-
name|amount
decl_stmt|;
comment|/* It is easier to deal with this way. */
comment|/* If the resultant window would be too small, stop here. */
if|if
condition|(
operator|(
name|window
operator|->
name|height
operator|-
name|abs_amount
operator|)
operator|<
name|WINDOW_MIN_HEIGHT
condition|)
return|return;
comment|/* If we have two neighboring windows, choose the smaller one to get          larger. */
if|if
condition|(
name|next
operator|&&
name|prev
condition|)
block|{
if|if
condition|(
name|prev
operator|->
name|height
operator|<
name|next
operator|->
name|height
condition|)
name|shrink_me_growing_prev
argument_list|(
name|window
argument_list|,
name|prev
argument_list|,
name|abs_amount
argument_list|)
expr_stmt|;
else|else
name|shrink_me_growing_next
argument_list|(
name|window
argument_list|,
name|next
argument_list|,
name|abs_amount
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|next
condition|)
name|shrink_me_growing_next
argument_list|(
name|window
argument_list|,
name|next
argument_list|,
name|abs_amount
argument_list|)
expr_stmt|;
else|else
name|shrink_me_growing_prev
argument_list|(
name|window
argument_list|,
name|prev
argument_list|,
name|abs_amount
argument_list|)
expr_stmt|;
block|}
comment|/* WINDOW increasing in size? */
if|if
condition|(
name|amount
operator|>
literal|0
condition|)
block|{
name|int
name|total_avail
decl_stmt|,
name|next_avail
init|=
literal|0
decl_stmt|,
name|prev_avail
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|next
condition|)
name|next_avail
operator|=
name|next
operator|->
name|height
operator|-
name|WINDOW_MIN_SIZE
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev_avail
operator|=
name|prev
operator|->
name|height
operator|-
name|WINDOW_MIN_SIZE
expr_stmt|;
name|total_avail
operator|=
name|next_avail
operator|+
name|prev_avail
expr_stmt|;
comment|/* If there isn't enough space available to grow this window, give up. */
if|if
condition|(
name|amount
operator|>
name|total_avail
condition|)
return|return;
comment|/* If there aren't two neighboring windows, or if one of the neighbors          is larger than the other one by at least AMOUNT, grow that one. */
if|if
condition|(
operator|(
name|next
operator|&&
operator|!
name|prev
operator|)
operator|||
operator|(
operator|(
name|next_avail
operator|-
name|amount
operator|)
operator|>=
name|prev_avail
operator|)
condition|)
name|grow_me_shrinking_next
argument_list|(
name|window
argument_list|,
name|next
argument_list|,
name|amount
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|prev
operator|&&
operator|!
name|next
operator|)
operator|||
operator|(
operator|(
name|prev_avail
operator|-
name|amount
operator|)
operator|>=
name|next_avail
operator|)
condition|)
name|grow_me_shrinking_prev
argument_list|(
name|window
argument_list|,
name|prev
argument_list|,
name|amount
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|change
decl_stmt|;
comment|/* This window has two neighbors.  They both must be shrunk in to              make enough space for WINDOW to grow.  Make them both the same              size. */
if|if
condition|(
name|prev_avail
operator|>
name|next_avail
condition|)
block|{
name|change
operator|=
name|prev_avail
operator|-
name|next_avail
expr_stmt|;
name|grow_me_shrinking_prev
argument_list|(
name|window
argument_list|,
name|prev
argument_list|,
name|change
argument_list|)
expr_stmt|;
name|amount
operator|-=
name|change
expr_stmt|;
block|}
else|else
block|{
name|change
operator|=
name|next_avail
operator|-
name|prev_avail
expr_stmt|;
name|grow_me_shrinking_next
argument_list|(
name|window
argument_list|,
name|next
argument_list|,
name|change
argument_list|)
expr_stmt|;
name|amount
operator|-=
name|change
expr_stmt|;
block|}
comment|/* Both neighbors are the same size.  Split the difference in              AMOUNT between them. */
while|while
condition|(
name|amount
condition|)
block|{
name|window
operator|->
name|height
operator|++
expr_stmt|;
name|amount
operator|--
expr_stmt|;
comment|/* Odd numbers grow next, even grow prev. */
if|if
condition|(
name|amount
operator|&
literal|1
condition|)
block|{
name|prev
operator|->
name|height
operator|--
expr_stmt|;
name|window
operator|->
name|first_row
operator|--
expr_stmt|;
block|}
else|else
block|{
name|next
operator|->
name|height
operator|--
expr_stmt|;
name|next
operator|->
name|first_row
operator|++
expr_stmt|;
block|}
block|}
name|window_adjust_pagetop
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|window_adjust_pagetop
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|flags
operator||=
name|W_UpdateWindow
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|next
operator|->
name|flags
operator||=
name|W_UpdateWindow
expr_stmt|;
name|window
operator|->
name|flags
operator||=
name|W_UpdateWindow
expr_stmt|;
name|window_adjust_pagetop
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tile all of the windows currently displayed in the global variable    WINDOWS.  If argument STYLE is TILE_INTERNALS, tile windows displaying    internal nodes as well, otherwise do not change the height of such    windows. */
end_comment

begin_function
name|void
name|window_tile_windows
parameter_list|(
name|style
parameter_list|)
name|int
name|style
decl_stmt|;
block|{
name|WINDOW
modifier|*
name|win
decl_stmt|,
modifier|*
name|last_adjusted
decl_stmt|;
name|int
name|numwins
decl_stmt|,
name|avail
decl_stmt|,
name|per_win_height
decl_stmt|,
name|leftover
decl_stmt|;
name|int
name|do_internals
decl_stmt|;
name|numwins
operator|=
name|avail
operator|=
literal|0
expr_stmt|;
name|do_internals
operator|=
operator|(
name|style
operator|==
name|TILE_INTERNALS
operator|)
expr_stmt|;
for|for
control|(
name|win
operator|=
name|windows
init|;
name|win
condition|;
name|win
operator|=
name|win
operator|->
name|next
control|)
if|if
condition|(
name|do_internals
operator|||
operator|!
name|win
operator|->
name|node
operator|||
operator|(
name|win
operator|->
name|node
operator|->
name|flags
operator|&
name|N_IsInternal
operator|)
operator|==
literal|0
condition|)
block|{
name|avail
operator|+=
name|win
operator|->
name|height
expr_stmt|;
name|numwins
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|numwins
operator|<=
literal|1
operator|||
operator|!
name|the_screen
operator|->
name|height
condition|)
return|return;
comment|/* Find the size for each window.  Divide the size of the usable portion      of the screen by the number of windows. */
name|per_win_height
operator|=
name|avail
operator|/
name|numwins
expr_stmt|;
name|leftover
operator|=
name|avail
operator|-
operator|(
name|per_win_height
operator|*
name|numwins
operator|)
expr_stmt|;
name|last_adjusted
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|win
operator|=
name|windows
init|;
name|win
condition|;
name|win
operator|=
name|win
operator|->
name|next
control|)
block|{
if|if
condition|(
name|do_internals
operator|||
operator|!
name|win
operator|->
name|node
operator|||
operator|(
name|win
operator|->
name|node
operator|->
name|flags
operator|&
name|N_IsInternal
operator|)
operator|==
literal|0
condition|)
block|{
name|last_adjusted
operator|=
name|win
expr_stmt|;
name|win
operator|->
name|height
operator|=
name|per_win_height
expr_stmt|;
block|}
block|}
if|if
condition|(
name|last_adjusted
condition|)
name|last_adjusted
operator|->
name|height
operator|+=
name|leftover
expr_stmt|;
comment|/* Readjust the first_row of every window in the chain. */
for|for
control|(
name|win
operator|=
name|windows
init|;
name|win
condition|;
name|win
operator|=
name|win
operator|->
name|next
control|)
block|{
if|if
condition|(
name|win
operator|->
name|prev
condition|)
name|win
operator|->
name|first_row
operator|=
name|win
operator|->
name|prev
operator|->
name|first_row
operator|+
name|win
operator|->
name|prev
operator|->
name|height
operator|+
literal|1
expr_stmt|;
name|window_adjust_pagetop
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|win
operator|->
name|flags
operator||=
name|W_UpdateWindow
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Toggle the state of line wrapping in WINDOW.  This can do a bit of fancy    redisplay. */
end_comment

begin_function
name|void
name|window_toggle_wrap
parameter_list|(
name|window
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
block|{
if|if
condition|(
name|window
operator|->
name|flags
operator|&
name|W_NoWrap
condition|)
name|window
operator|->
name|flags
operator|&=
operator|~
name|W_NoWrap
expr_stmt|;
else|else
name|window
operator|->
name|flags
operator||=
name|W_NoWrap
expr_stmt|;
if|if
condition|(
name|window
operator|!=
name|the_echo_area
condition|)
block|{
name|char
modifier|*
modifier|*
name|old_starts
decl_stmt|;
name|int
name|old_lines
decl_stmt|,
name|old_pagetop
decl_stmt|;
name|old_starts
operator|=
name|window
operator|->
name|line_starts
expr_stmt|;
name|old_lines
operator|=
name|window
operator|->
name|line_count
expr_stmt|;
name|old_pagetop
operator|=
name|window
operator|->
name|pagetop
expr_stmt|;
name|calculate_line_starts
argument_list|(
name|window
argument_list|)
expr_stmt|;
comment|/* Make sure that point appears within this window. */
name|window_adjust_pagetop
argument_list|(
name|window
argument_list|)
expr_stmt|;
comment|/* If the pagetop hasn't changed maybe we can do some scrolling now          to speed up the display.  Many of the line starts will be the same,          so scrolling here is a very good optimization.*/
if|if
condition|(
name|old_pagetop
operator|==
name|window
operator|->
name|pagetop
condition|)
name|display_scroll_line_starts
argument_list|(
name|window
argument_list|,
name|old_pagetop
argument_list|,
name|old_starts
argument_list|,
name|old_lines
argument_list|)
expr_stmt|;
name|maybe_free
argument_list|(
name|old_starts
argument_list|)
expr_stmt|;
block|}
name|window
operator|->
name|flags
operator||=
name|W_UpdateWindow
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set WINDOW to display NODE. */
end_comment

begin_function
name|void
name|window_set_node_of_window
parameter_list|(
name|window
parameter_list|,
name|node
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|NODE
modifier|*
name|node
decl_stmt|;
block|{
name|window
operator|->
name|node
operator|=
name|node
expr_stmt|;
name|window
operator|->
name|pagetop
operator|=
literal|0
expr_stmt|;
name|window
operator|->
name|point
operator|=
literal|0
expr_stmt|;
name|recalculate_line_starts
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|window
operator|->
name|flags
operator||=
name|W_UpdateWindow
expr_stmt|;
comment|/* The display_pos member is nonzero if we're displaying an anchor.  */
name|window
operator|->
name|point
operator|=
name|node
condition|?
name|node
operator|->
name|display_pos
else|:
literal|0
expr_stmt|;
name|window_adjust_pagetop
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|window_make_modeline
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete WINDOW from the list of known windows.  If this window was the    active window, make the next window in the chain be the active window.    If the active window is the next or previous window, choose that window    as the recipient of the extra space.  Otherwise, prefer the next window. */
end_comment

begin_function
name|void
name|window_delete_window
parameter_list|(
name|window
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
block|{
name|WINDOW
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|window_to_fix
decl_stmt|;
name|next
operator|=
name|window
operator|->
name|next
expr_stmt|;
name|prev
operator|=
name|window
operator|->
name|prev
expr_stmt|;
comment|/* You cannot delete the only window or a permanent window. */
if|if
condition|(
operator|(
operator|!
name|next
operator|&&
operator|!
name|prev
operator|)
operator|||
operator|(
name|window
operator|->
name|flags
operator|&
name|W_WindowIsPerm
operator|)
condition|)
return|return;
if|if
condition|(
name|next
condition|)
name|next
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
if|if
condition|(
operator|!
name|prev
condition|)
name|windows
operator|=
name|next
expr_stmt|;
else|else
name|prev
operator|->
name|next
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|window
operator|->
name|line_starts
condition|)
name|free
argument_list|(
name|window
operator|->
name|line_starts
argument_list|)
expr_stmt|;
if|if
condition|(
name|window
operator|->
name|modeline
condition|)
name|free
argument_list|(
name|window
operator|->
name|modeline
argument_list|)
expr_stmt|;
if|if
condition|(
name|window
operator|==
name|active_window
condition|)
block|{
comment|/* If there isn't a next window, then there must be a previous one,          since we cannot delete the last window.  If there is a next window,          prefer to use that as the active window. */
if|if
condition|(
name|next
condition|)
name|active_window
operator|=
name|next
expr_stmt|;
else|else
name|active_window
operator|=
name|prev
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|&&
name|active_window
operator|==
name|next
condition|)
name|window_to_fix
operator|=
name|next
expr_stmt|;
elseif|else
if|if
condition|(
name|prev
operator|&&
name|active_window
operator|==
name|prev
condition|)
name|window_to_fix
operator|=
name|prev
expr_stmt|;
elseif|else
if|if
condition|(
name|next
condition|)
name|window_to_fix
operator|=
name|next
expr_stmt|;
elseif|else
if|if
condition|(
name|prev
condition|)
name|window_to_fix
operator|=
name|prev
expr_stmt|;
else|else
name|window_to_fix
operator|=
name|windows
expr_stmt|;
if|if
condition|(
name|window_to_fix
operator|->
name|first_row
operator|>
name|window
operator|->
name|first_row
condition|)
block|{
name|int
name|diff
decl_stmt|;
comment|/* Try to adjust the visible part of the node so that as little          text as possible has to move. */
name|diff
operator|=
name|window_to_fix
operator|->
name|first_row
operator|-
name|window
operator|->
name|first_row
expr_stmt|;
name|window_to_fix
operator|->
name|first_row
operator|=
name|window
operator|->
name|first_row
expr_stmt|;
name|window_to_fix
operator|->
name|pagetop
operator|-=
name|diff
expr_stmt|;
if|if
condition|(
name|window_to_fix
operator|->
name|pagetop
operator|<
literal|0
condition|)
name|window_to_fix
operator|->
name|pagetop
operator|=
literal|0
expr_stmt|;
block|}
comment|/* The `+ 1' is to offset the difference between the first_row locations.      See the code in window_make_window (). */
name|window_to_fix
operator|->
name|height
operator|+=
name|window
operator|->
name|height
operator|+
literal|1
expr_stmt|;
name|window_to_fix
operator|->
name|flags
operator||=
name|W_UpdateWindow
expr_stmt|;
name|free
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For every window in CHAIN, set the flags member to have FLAG set. */
end_comment

begin_function
name|void
name|window_mark_chain
parameter_list|(
name|chain
parameter_list|,
name|flag
parameter_list|)
name|WINDOW
modifier|*
name|chain
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|WINDOW
modifier|*
name|win
decl_stmt|;
for|for
control|(
name|win
operator|=
name|chain
init|;
name|win
condition|;
name|win
operator|=
name|win
operator|->
name|next
control|)
name|win
operator|->
name|flags
operator||=
name|flag
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For every window in CHAIN, clear the flags member of FLAG. */
end_comment

begin_function
name|void
name|window_unmark_chain
parameter_list|(
name|chain
parameter_list|,
name|flag
parameter_list|)
name|WINDOW
modifier|*
name|chain
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|WINDOW
modifier|*
name|win
decl_stmt|;
for|for
control|(
name|win
operator|=
name|chain
init|;
name|win
condition|;
name|win
operator|=
name|win
operator|->
name|next
control|)
name|win
operator|->
name|flags
operator|&=
operator|~
name|flag
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of characters it takes to display CHARACTER on the    screen at HPOS. */
end_comment

begin_function
name|int
name|character_width
parameter_list|(
name|character
parameter_list|,
name|hpos
parameter_list|)
name|int
name|character
decl_stmt|,
name|hpos
decl_stmt|;
block|{
name|int
name|printable_limit
init|=
literal|127
decl_stmt|;
name|int
name|width
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|ISO_Latin_p
condition|)
name|printable_limit
operator|=
literal|255
expr_stmt|;
if|if
condition|(
name|character
operator|>
name|printable_limit
condition|)
name|width
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|iscntrl
argument_list|(
name|character
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|character
condition|)
block|{
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
name|width
operator|=
name|the_screen
operator|->
name|width
operator|-
name|hpos
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|width
operator|=
operator|(
operator|(
name|hpos
operator|+
literal|8
operator|)
operator|&
literal|0xf8
operator|)
operator|-
name|hpos
expr_stmt|;
break|break;
default|default:
name|width
operator|=
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|character
operator|==
name|DEL
condition|)
name|width
operator|=
literal|2
expr_stmt|;
return|return
operator|(
name|width
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the number of characters it takes to display STRING on the screen    at HPOS. */
end_comment

begin_function
name|int
name|string_width
parameter_list|(
name|string
parameter_list|,
name|hpos
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|hpos
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|width
decl_stmt|,
name|this_char_width
decl_stmt|;
for|for
control|(
name|width
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|this_char_width
operator|=
name|character_width
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
name|hpos
argument_list|)
expr_stmt|;
name|width
operator|+=
name|this_char_width
expr_stmt|;
name|hpos
operator|+=
name|this_char_width
expr_stmt|;
block|}
return|return
operator|(
name|width
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Quickly guess the approximate number of lines that NODE would    take to display.  This really only counts carriage returns. */
end_comment

begin_function
name|int
name|window_physical_lines
parameter_list|(
name|node
parameter_list|)
name|NODE
modifier|*
name|node
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|lines
decl_stmt|;
name|char
modifier|*
name|contents
decl_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|contents
operator|=
name|node
operator|->
name|contents
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|lines
operator|=
literal|1
init|;
name|i
operator|<
name|node
operator|->
name|nodelen
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|contents
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
name|lines
operator|++
expr_stmt|;
return|return
operator|(
name|lines
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Calculate a list of line starts for the node belonging to WINDOW.  The line    starts are pointers to the actual text within WINDOW->NODE. */
end_comment

begin_function
name|void
name|calculate_line_starts
parameter_list|(
name|window
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|hpos
decl_stmt|;
name|char
modifier|*
modifier|*
name|line_starts
init|=
name|NULL
decl_stmt|;
name|int
name|line_starts_index
init|=
literal|0
decl_stmt|,
name|line_starts_slots
init|=
literal|0
decl_stmt|;
name|int
name|bump_index
decl_stmt|;
name|NODE
modifier|*
name|node
decl_stmt|;
name|window
operator|->
name|line_starts
operator|=
name|NULL
expr_stmt|;
name|window
operator|->
name|line_count
operator|=
literal|0
expr_stmt|;
name|node
operator|=
name|window
operator|->
name|node
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
return|return;
comment|/* Grovel the node starting at the top, and for each line calculate the      width of the characters appearing in that line.  Add each line start      to our array. */
name|i
operator|=
literal|0
expr_stmt|;
name|hpos
operator|=
literal|0
expr_stmt|;
name|bump_index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|node
operator|->
name|nodelen
condition|)
block|{
name|char
modifier|*
name|line
init|=
name|node
operator|->
name|contents
operator|+
name|i
decl_stmt|;
name|unsigned
name|int
name|cwidth
decl_stmt|,
name|c
decl_stmt|;
name|add_pointer_to_array
argument_list|(
name|line
argument_list|,
name|line_starts_index
argument_list|,
name|line_starts
argument_list|,
name|line_starts_slots
argument_list|,
literal|100
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|bump_index
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|bump_index
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
comment|/* The cast to unsigned char is for 8-bit characters, which 	     could be passed as negative integers to character_width 	     and wreak havoc on some naive implementations of iscntrl.  */
name|c
operator|=
operator|(
name|unsigned
name|char
operator|)
name|node
operator|->
name|contents
index|[
name|i
index|]
expr_stmt|;
name|cwidth
operator|=
name|character_width
argument_list|(
name|c
argument_list|,
name|hpos
argument_list|)
expr_stmt|;
comment|/* If this character fits within this line, just do the next one. */
if|if
condition|(
operator|(
name|hpos
operator|+
name|cwidth
operator|)
operator|<
name|window
operator|->
name|width
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|hpos
operator|+=
name|cwidth
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* If this character would position the cursor at the start of                  the next printed screen line, then do the next line. */
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\r'
operator|||
name|c
operator|==
literal|'\t'
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|hpos
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* This character passes the window width border.  Postion                      the cursor after the printed character, but remember this                      line start as where this character is.  A bit tricky. */
comment|/* If this window doesn't wrap lines, proceed to the next                      physical line here. */
if|if
condition|(
name|window
operator|->
name|flags
operator|&
name|W_NoWrap
condition|)
block|{
name|hpos
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|node
operator|->
name|nodelen
operator|&&
name|node
operator|->
name|contents
index|[
name|i
index|]
operator|!=
literal|'\n'
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|contents
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
name|hpos
operator|=
name|the_screen
operator|->
name|width
operator|-
name|hpos
expr_stmt|;
name|bump_index
operator|++
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
name|window
operator|->
name|line_starts
operator|=
name|line_starts
expr_stmt|;
name|window
operator|->
name|line_count
operator|=
name|line_starts_index
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given WINDOW, recalculate the line starts for the node it displays. */
end_comment

begin_function
name|void
name|recalculate_line_starts
parameter_list|(
name|window
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
block|{
name|maybe_free
argument_list|(
name|window
operator|->
name|line_starts
argument_list|)
expr_stmt|;
name|calculate_line_starts
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Global variable control redisplay of scrolled windows.  If non-zero, it    is the desired number of lines to scroll the window in order to make    point visible.  A user might set this to 1 for smooth scrolling.  If    set to zero, the line containing point is centered within the window. */
end_comment

begin_decl_stmt
name|int
name|window_scroll_step
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Adjust the pagetop of WINDOW such that the cursor point will be visible. */
end_comment

begin_function
name|void
name|window_adjust_pagetop
parameter_list|(
name|window
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
block|{
specifier|register
name|int
name|line
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|contents
decl_stmt|;
if|if
condition|(
operator|!
name|window
operator|->
name|node
condition|)
return|return;
name|contents
operator|=
name|window
operator|->
name|node
operator|->
name|contents
expr_stmt|;
comment|/* Find the first printed line start which is after WINDOW->point. */
for|for
control|(
name|line
operator|=
literal|0
init|;
name|line
operator|<
name|window
operator|->
name|line_count
condition|;
name|line
operator|++
control|)
block|{
name|char
modifier|*
name|line_start
decl_stmt|;
name|line_start
operator|=
name|window
operator|->
name|line_starts
index|[
name|line
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|line_start
operator|-
name|contents
operator|)
operator|>
name|window
operator|->
name|point
condition|)
break|break;
block|}
comment|/* The line index preceding the line start which is past point is the      one containing point. */
name|line
operator|--
expr_stmt|;
comment|/* If this line appears in the current displayable page, do nothing.      Otherwise, adjust the top of the page to make this line visible. */
if|if
condition|(
operator|(
name|line
operator|<
name|window
operator|->
name|pagetop
operator|)
operator|||
operator|(
name|line
operator|-
name|window
operator|->
name|pagetop
operator|>
operator|(
name|window
operator|->
name|height
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* The user-settable variable "scroll-step" is used to attempt          to make point visible, iff it is non-zero.  If that variable          is zero, then the line containing point is centered within          the window. */
if|if
condition|(
name|window_scroll_step
operator|<
name|window
operator|->
name|height
condition|)
block|{
if|if
condition|(
operator|(
name|line
operator|<
name|window
operator|->
name|pagetop
operator|)
operator|&&
operator|(
operator|(
name|window
operator|->
name|pagetop
operator|-
name|window_scroll_step
operator|)
operator|<=
name|line
operator|)
condition|)
name|window
operator|->
name|pagetop
operator|-=
name|window_scroll_step
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|line
operator|-
name|window
operator|->
name|pagetop
operator|>
operator|(
name|window
operator|->
name|height
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|line
operator|-
operator|(
name|window
operator|->
name|pagetop
operator|+
name|window_scroll_step
operator|)
operator|<
name|window
operator|->
name|height
operator|)
operator|)
condition|)
name|window
operator|->
name|pagetop
operator|+=
name|window_scroll_step
expr_stmt|;
else|else
name|window
operator|->
name|pagetop
operator|=
name|line
operator|-
operator|(
operator|(
name|window
operator|->
name|height
operator|-
literal|1
operator|)
operator|/
literal|2
operator|)
expr_stmt|;
block|}
else|else
name|window
operator|->
name|pagetop
operator|=
name|line
operator|-
operator|(
operator|(
name|window
operator|->
name|height
operator|-
literal|1
operator|)
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|window
operator|->
name|pagetop
operator|<
literal|0
condition|)
name|window
operator|->
name|pagetop
operator|=
literal|0
expr_stmt|;
name|window
operator|->
name|flags
operator||=
name|W_UpdateWindow
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the index of the line containing point. */
end_comment

begin_function
name|int
name|window_line_of_point
parameter_list|(
name|window
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|start
init|=
literal|0
decl_stmt|;
comment|/* Try to optimize.  Check to see if point is past the pagetop for      this window, and if so, start searching forward from there. */
if|if
condition|(
operator|(
name|window
operator|->
name|pagetop
operator|>
operator|-
literal|1
operator|&&
name|window
operator|->
name|pagetop
operator|<
name|window
operator|->
name|line_count
operator|)
operator|&&
operator|(
name|window
operator|->
name|line_starts
index|[
name|window
operator|->
name|pagetop
index|]
operator|-
name|window
operator|->
name|node
operator|->
name|contents
operator|)
operator|<=
name|window
operator|->
name|point
condition|)
name|start
operator|=
name|window
operator|->
name|pagetop
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|window
operator|->
name|line_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|window
operator|->
name|line_starts
index|[
name|i
index|]
operator|-
name|window
operator|->
name|node
operator|->
name|contents
operator|)
operator|>
name|window
operator|->
name|point
condition|)
break|break;
block|}
return|return
operator|(
name|i
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get and return the goal column for this window. */
end_comment

begin_function
name|int
name|window_get_goal_column
parameter_list|(
name|window
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|window
operator|->
name|node
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|window
operator|->
name|goal_column
operator|!=
operator|-
literal|1
condition|)
return|return
operator|(
name|window
operator|->
name|goal_column
operator|)
return|;
comment|/* Okay, do the work.  Find the printed offset of the cursor      in this window. */
return|return
operator|(
name|window_get_cursor_column
argument_list|(
name|window
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get and return the printed column offset of the cursor in this window. */
end_comment

begin_function
name|int
name|window_get_cursor_column
parameter_list|(
name|window
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|hpos
decl_stmt|,
name|end
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|i
operator|=
name|window_line_of_point
argument_list|(
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|line
operator|=
name|window
operator|->
name|line_starts
index|[
name|i
index|]
expr_stmt|;
name|end
operator|=
name|window
operator|->
name|point
operator|-
operator|(
name|line
operator|-
name|window
operator|->
name|node
operator|->
name|contents
operator|)
expr_stmt|;
for|for
control|(
name|hpos
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|end
condition|;
name|i
operator|++
control|)
name|hpos
operator|+=
name|character_width
argument_list|(
name|line
index|[
name|i
index|]
argument_list|,
name|hpos
argument_list|)
expr_stmt|;
return|return
operator|(
name|hpos
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Count the number of characters in LINE that precede the printed column    offset of GOAL. */
end_comment

begin_function
name|int
name|window_chars_to_goal
parameter_list|(
name|line
parameter_list|,
name|goal
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|goal
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|check
decl_stmt|,
name|hpos
decl_stmt|;
for|for
control|(
name|hpos
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|line
index|[
name|i
index|]
operator|!=
literal|'\n'
condition|;
name|i
operator|++
control|)
block|{
name|check
operator|=
name|hpos
operator|+
name|character_width
argument_list|(
name|line
index|[
name|i
index|]
argument_list|,
name|hpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
operator|>
name|goal
condition|)
break|break;
name|hpos
operator|=
name|check
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create a modeline for WINDOW, and store it in window->modeline. */
end_comment

begin_function
name|void
name|window_make_modeline
parameter_list|(
name|window
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|modeline
decl_stmt|;
name|char
name|location_indicator
index|[
literal|4
index|]
decl_stmt|;
name|int
name|lines_remaining
decl_stmt|;
comment|/* Only make modelines for those windows which have one. */
if|if
condition|(
name|window
operator|->
name|flags
operator|&
name|W_InhibitMode
condition|)
return|return;
comment|/* Find the number of lines actually displayed in this window. */
name|lines_remaining
operator|=
name|window
operator|->
name|line_count
operator|-
name|window
operator|->
name|pagetop
expr_stmt|;
if|if
condition|(
name|window
operator|->
name|pagetop
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lines_remaining
operator|<=
name|window
operator|->
name|height
condition|)
name|strcpy
argument_list|(
name|location_indicator
argument_list|,
literal|"All"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|location_indicator
argument_list|,
literal|"Top"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lines_remaining
operator|<=
name|window
operator|->
name|height
condition|)
name|strcpy
argument_list|(
name|location_indicator
argument_list|,
literal|"Bot"
argument_list|)
expr_stmt|;
else|else
block|{
name|float
name|pt
decl_stmt|,
name|lc
decl_stmt|;
name|int
name|percentage
decl_stmt|;
name|pt
operator|=
operator|(
name|float
operator|)
name|window
operator|->
name|pagetop
expr_stmt|;
name|lc
operator|=
operator|(
name|float
operator|)
name|window
operator|->
name|line_count
expr_stmt|;
name|percentage
operator|=
literal|100
operator|*
operator|(
name|pt
operator|/
name|lc
operator|)
expr_stmt|;
name|sprintf
argument_list|(
name|location_indicator
argument_list|,
literal|"%2d%%"
argument_list|,
name|percentage
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Calculate the maximum size of the information to stick in MODELINE. */
block|{
name|int
name|modeline_len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|parent
init|=
name|NULL
decl_stmt|,
modifier|*
name|filename
init|=
literal|"*no file*"
decl_stmt|;
name|char
modifier|*
name|nodename
init|=
literal|"*no node*"
decl_stmt|;
name|char
modifier|*
name|update_message
init|=
name|NULL
decl_stmt|;
name|NODE
modifier|*
name|node
init|=
name|window
operator|->
name|node
decl_stmt|;
if|if
condition|(
name|node
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|nodename
condition|)
name|nodename
operator|=
name|node
operator|->
name|nodename
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|parent
condition|)
block|{
name|parent
operator|=
name|filename_non_directory
argument_list|(
name|node
operator|->
name|parent
argument_list|)
expr_stmt|;
name|modeline_len
operator|+=
name|strlen
argument_list|(
literal|"Subfile: "
argument_list|)
operator|+
name|strlen
argument_list|(
name|node
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|filename
condition|)
name|filename
operator|=
name|filename_non_directory
argument_list|(
name|node
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|flags
operator|&
name|N_UpdateTags
condition|)
name|update_message
operator|=
name|_
argument_list|(
literal|"--*** Tags out of Date ***"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|update_message
condition|)
name|modeline_len
operator|+=
name|strlen
argument_list|(
name|update_message
argument_list|)
expr_stmt|;
name|modeline_len
operator|+=
name|strlen
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|modeline_len
operator|+=
name|strlen
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
name|modeline_len
operator|+=
literal|4
expr_stmt|;
comment|/* strlen (location_indicator). */
comment|/* 10 for the decimal representation of the number of lines in this        node, and the remainder of the text that can appear in the line. */
name|modeline_len
operator|+=
literal|10
operator|+
name|strlen
argument_list|(
name|_
argument_list|(
literal|"-----Info: (), lines ----, "
argument_list|)
argument_list|)
expr_stmt|;
name|modeline_len
operator|+=
name|window
operator|->
name|width
expr_stmt|;
name|modeline
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|modeline_len
argument_list|)
expr_stmt|;
comment|/* Special internal windows have no filename. */
if|if
condition|(
operator|!
name|parent
operator|&&
operator|!
operator|*
name|filename
condition|)
name|sprintf
argument_list|(
name|modeline
argument_list|,
name|_
argument_list|(
literal|"-%s---Info: %s, %d lines --%s--"
argument_list|)
argument_list|,
operator|(
name|window
operator|->
name|flags
operator|&
name|W_NoWrap
operator|)
condition|?
literal|"$"
else|:
literal|"-"
argument_list|,
name|nodename
argument_list|,
name|window
operator|->
name|line_count
argument_list|,
name|location_indicator
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|modeline
argument_list|,
name|_
argument_list|(
literal|"-%s%s-Info: (%s)%s, %d lines --%s--"
argument_list|)
argument_list|,
operator|(
name|window
operator|->
name|flags
operator|&
name|W_NoWrap
operator|)
condition|?
literal|"$"
else|:
literal|"-"
argument_list|,
operator|(
name|node
operator|&&
operator|(
name|node
operator|->
name|flags
operator|&
name|N_IsCompressed
operator|)
operator|)
condition|?
literal|"zz"
else|:
literal|"--"
argument_list|,
name|parent
condition|?
name|parent
else|:
name|filename
argument_list|,
name|nodename
argument_list|,
name|window
operator|->
name|line_count
argument_list|,
name|location_indicator
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
condition|)
name|sprintf
argument_list|(
name|modeline
operator|+
name|strlen
argument_list|(
name|modeline
argument_list|)
argument_list|,
name|_
argument_list|(
literal|" Subfile: %s"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_message
condition|)
name|sprintf
argument_list|(
name|modeline
operator|+
name|strlen
argument_list|(
name|modeline
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|update_message
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|modeline
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|window
operator|->
name|width
condition|)
name|modeline
index|[
name|window
operator|->
name|width
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
while|while
condition|(
name|i
operator|<
name|window
operator|->
name|width
condition|)
name|modeline
index|[
name|i
operator|++
index|]
operator|=
literal|'-'
expr_stmt|;
name|modeline
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|window
operator|->
name|modeline
argument_list|,
name|modeline
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|modeline
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make WINDOW start displaying at PERCENT percentage of its node. */
end_comment

begin_function
name|void
name|window_goto_percentage
parameter_list|(
name|window
parameter_list|,
name|percent
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|int
name|percent
decl_stmt|;
block|{
name|int
name|desired_line
decl_stmt|;
if|if
condition|(
operator|!
name|percent
condition|)
name|desired_line
operator|=
literal|0
expr_stmt|;
else|else
name|desired_line
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|float
operator|)
name|window
operator|->
name|line_count
operator|*
operator|(
operator|(
name|float
operator|)
name|percent
operator|/
literal|100.0
operator|)
argument_list|)
expr_stmt|;
name|window
operator|->
name|pagetop
operator|=
name|desired_line
expr_stmt|;
name|window
operator|->
name|point
operator|=
name|window
operator|->
name|line_starts
index|[
name|window
operator|->
name|pagetop
index|]
operator|-
name|window
operator|->
name|node
operator|->
name|contents
expr_stmt|;
name|window
operator|->
name|flags
operator||=
name|W_UpdateWindow
expr_stmt|;
name|window_make_modeline
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the state of WINDOW, and save it in STATE. */
end_comment

begin_function
name|void
name|window_get_state
parameter_list|(
name|window
parameter_list|,
name|state
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|WINDOW_STATE
modifier|*
name|state
decl_stmt|;
block|{
name|state
operator|->
name|node
operator|=
name|window
operator|->
name|node
expr_stmt|;
name|state
operator|->
name|pagetop
operator|=
name|window
operator|->
name|pagetop
expr_stmt|;
name|state
operator|->
name|point
operator|=
name|window
operator|->
name|point
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the node, pagetop, and point of WINDOW. */
end_comment

begin_function
name|void
name|window_set_state
parameter_list|(
name|window
parameter_list|,
name|state
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|WINDOW_STATE
modifier|*
name|state
decl_stmt|;
block|{
if|if
condition|(
name|window
operator|->
name|node
operator|!=
name|state
operator|->
name|node
condition|)
name|window_set_node_of_window
argument_list|(
name|window
argument_list|,
name|state
operator|->
name|node
argument_list|)
expr_stmt|;
name|window
operator|->
name|pagetop
operator|=
name|state
operator|->
name|pagetop
expr_stmt|;
name|window
operator|->
name|point
operator|=
name|state
operator|->
name|point
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Manipulating home-made nodes.  */
end_comment

begin_comment
comment|/* A place to buffer echo area messages. */
end_comment

begin_decl_stmt
specifier|static
name|NODE
modifier|*
name|echo_area_node
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make the node of the_echo_area be an empty one. */
end_comment

begin_function
specifier|static
name|void
name|free_echo_area
parameter_list|()
block|{
if|if
condition|(
name|echo_area_node
condition|)
block|{
name|maybe_free
argument_list|(
name|echo_area_node
operator|->
name|contents
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|echo_area_node
argument_list|)
expr_stmt|;
block|}
name|echo_area_node
operator|=
name|NULL
expr_stmt|;
name|window_set_node_of_window
argument_list|(
name|the_echo_area
argument_list|,
name|echo_area_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the echo area, removing any message that is already present.    The echo area is cleared immediately. */
end_comment

begin_function
name|void
name|window_clear_echo_area
parameter_list|()
block|{
name|free_echo_area
argument_list|()
expr_stmt|;
name|display_update_one_window
argument_list|(
name|the_echo_area
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make a message appear in the echo area, built from FORMAT, ARG1 and ARG2.    The arguments are treated similar to printf () arguments, but not all of    printf () hair is present.  The message appears immediately.  If there was    already a message appearing in the echo area, it is removed. */
end_comment

begin_function
name|void
name|window_message_in_echo_area
parameter_list|(
name|format
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
name|void
modifier|*
name|arg1
decl_stmt|,
decl|*
name|arg2
decl_stmt|;
end_function

begin_block
block|{
name|free_echo_area
argument_list|()
expr_stmt|;
name|echo_area_node
operator|=
name|build_message_node
argument_list|(
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|window_set_node_of_window
argument_list|(
name|the_echo_area
argument_list|,
name|echo_area_node
argument_list|)
expr_stmt|;
name|display_update_one_window
argument_list|(
name|the_echo_area
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Place a temporary message in the echo area built from FORMAT, ARG1    and ARG2.  The message appears immediately, but does not destroy    any existing message.  A future call to unmessage_in_echo_area ()    restores the old contents. */
end_comment

begin_decl_stmt
specifier|static
name|NODE
modifier|*
modifier|*
name|old_echo_area_nodes
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|old_echo_area_nodes_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|old_echo_area_nodes_slots
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|message_in_echo_area
parameter_list|(
name|format
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
name|void
modifier|*
name|arg1
decl_stmt|,
decl|*
name|arg2
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|echo_area_node
condition|)
block|{
name|add_pointer_to_array
argument_list|(
name|echo_area_node
argument_list|,
name|old_echo_area_nodes_index
argument_list|,
name|old_echo_area_nodes
argument_list|,
name|old_echo_area_nodes_slots
argument_list|,
literal|4
argument_list|,
name|NODE
operator|*
argument_list|)
expr_stmt|;
block|}
name|echo_area_node
operator|=
name|NULL
expr_stmt|;
name|window_message_in_echo_area
argument_list|(
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|unmessage_in_echo_area
parameter_list|()
block|{
name|free_echo_area
argument_list|()
expr_stmt|;
if|if
condition|(
name|old_echo_area_nodes_index
condition|)
name|echo_area_node
operator|=
name|old_echo_area_nodes
index|[
operator|--
name|old_echo_area_nodes_index
index|]
expr_stmt|;
name|window_set_node_of_window
argument_list|(
name|the_echo_area
argument_list|,
name|echo_area_node
argument_list|)
expr_stmt|;
name|display_update_one_window
argument_list|(
name|the_echo_area
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A place to build a message. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|message_buffer
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|message_buffer_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|message_buffer_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ensure that there is enough space to stuff LENGTH characters into    MESSAGE_BUFFER. */
end_comment

begin_function
specifier|static
name|void
name|message_buffer_resize
parameter_list|(
name|length
parameter_list|)
name|int
name|length
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|message_buffer
condition|)
block|{
name|message_buffer_size
operator|=
name|length
operator|+
literal|1
expr_stmt|;
name|message_buffer
operator|=
name|xmalloc
argument_list|(
name|message_buffer_size
argument_list|)
expr_stmt|;
name|message_buffer_index
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|message_buffer_size
operator|<=
name|message_buffer_index
operator|+
name|length
condition|)
name|message_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|message_buffer
argument_list|,
name|message_buffer_size
operator|+=
literal|100
operator|+
operator|(
literal|2
operator|*
name|length
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Format MESSAGE_BUFFER with the results of printing FORMAT with ARG1 and    ARG2. */
end_comment

begin_function
specifier|static
name|void
name|build_message_buffer
parameter_list|(
name|format
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
name|void
modifier|*
name|arg1
decl_stmt|,
decl|*
name|arg2
decl_stmt|,
modifier|*
name|arg3
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|void
modifier|*
name|args
index|[
literal|3
index|]
decl_stmt|;
name|int
name|arg_index
init|=
literal|0
decl_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|arg1
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|arg2
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|arg3
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|format
argument_list|)
expr_stmt|;
name|message_buffer_resize
argument_list|(
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|format
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|format
index|[
name|i
index|]
operator|!=
literal|'%'
condition|)
block|{
name|message_buffer
index|[
name|message_buffer_index
operator|++
index|]
operator|=
name|format
index|[
name|i
index|]
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
else|else
block|{
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|fmt_start
init|=
name|format
operator|+
name|i
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|fmt_len
decl_stmt|,
name|formatted_len
decl_stmt|;
name|int
name|paramed
init|=
literal|0
decl_stmt|;
name|format_again
label|:
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|format
index|[
name|i
index|]
operator|&&
name|strchr
argument_list|(
literal|"-. +0123456789"
argument_list|,
name|format
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
name|c
operator|=
name|format
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
block|{
comment|/* position parameter parameter */
comment|/* better to use bprintf from bfox's metahtml? */
name|arg_index
operator|=
name|atoi
argument_list|(
name|fmt_start
operator|+
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|arg_index
operator|<
literal|0
condition|)
name|arg_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg_index
operator|>=
literal|2
condition|)
name|arg_index
operator|=
literal|1
expr_stmt|;
name|paramed
operator|=
literal|1
expr_stmt|;
goto|goto
name|format_again
goto|;
block|}
name|fmt_len
operator|=
name|format
operator|+
name|i
operator|-
name|fmt_start
operator|+
literal|1
expr_stmt|;
name|fmt
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|fmt_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|fmt
argument_list|,
name|fmt_start
argument_list|,
name|fmt_len
argument_list|)
expr_stmt|;
name|fmt
index|[
name|fmt_len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|paramed
condition|)
block|{
comment|/* removed positioned parameter */
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|fmt
operator|+
literal|1
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'$'
condition|;
name|p
operator|++
control|)
block|{
empty_stmt|;
block|}
name|strcpy
argument_list|(
name|fmt
operator|+
literal|1
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If we have "%-98s", maybe 98 calls for a longer string.  */
if|if
condition|(
name|fmt_len
operator|>
literal|2
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|fmt_len
operator|-
literal|2
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|isdigit
argument_list|(
name|fmt
index|[
name|j
index|]
argument_list|)
operator|||
name|fmt
index|[
name|j
index|]
operator|==
literal|'$'
condition|)
break|break;
name|formatted_len
operator|=
name|atoi
argument_list|(
name|fmt
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
else|else
name|formatted_len
operator|=
name|c
operator|==
literal|'s'
condition|?
literal|0
else|:
literal|1
expr_stmt|;
comment|/* %s can produce empty string */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'%'
case|:
comment|/* Insert a percent sign. */
name|message_buffer_resize
argument_list|(
name|len
operator|+
name|formatted_len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|message_buffer
operator|+
name|message_buffer_index
argument_list|,
name|fmt
argument_list|,
literal|"%"
argument_list|)
expr_stmt|;
name|message_buffer_index
operator|+=
name|formatted_len
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Insert the current arg as a string. */
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|string_len
decl_stmt|;
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|args
index|[
name|arg_index
operator|++
index|]
expr_stmt|;
name|string_len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|formatted_len
operator|>
name|string_len
condition|)
name|string_len
operator|=
name|formatted_len
expr_stmt|;
name|message_buffer_resize
argument_list|(
name|len
operator|+
name|string_len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|message_buffer
operator|+
name|message_buffer_index
argument_list|,
name|fmt
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|message_buffer_index
operator|+=
name|string_len
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
comment|/* Insert the current arg as an integer. */
block|{
name|long
name|long_val
decl_stmt|;
name|int
name|integer
decl_stmt|;
name|long_val
operator|=
operator|(
name|long
operator|)
name|args
index|[
name|arg_index
operator|++
index|]
expr_stmt|;
name|integer
operator|=
operator|(
name|int
operator|)
name|long_val
expr_stmt|;
name|message_buffer_resize
argument_list|(
name|len
operator|+
name|formatted_len
operator|>
literal|32
condition|?
name|formatted_len
else|:
literal|32
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|message_buffer
operator|+
name|message_buffer_index
argument_list|,
name|fmt
argument_list|,
name|integer
argument_list|)
expr_stmt|;
name|message_buffer_index
operator|=
name|strlen
argument_list|(
name|message_buffer
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'c'
case|:
comment|/* Insert the current arg as a character. */
block|{
name|long
name|long_val
decl_stmt|;
name|int
name|character
decl_stmt|;
name|long_val
operator|=
operator|(
name|long
operator|)
name|args
index|[
name|arg_index
operator|++
index|]
expr_stmt|;
name|character
operator|=
operator|(
name|int
operator|)
name|long_val
expr_stmt|;
name|message_buffer_resize
argument_list|(
name|len
operator|+
name|formatted_len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|message_buffer
operator|+
name|message_buffer_index
argument_list|,
name|fmt
argument_list|,
name|character
argument_list|)
expr_stmt|;
name|message_buffer_index
operator|+=
name|formatted_len
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|fmt
argument_list|)
expr_stmt|;
block|}
block|}
name|message_buffer
index|[
name|message_buffer_index
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Build a new node which has FORMAT printed with ARG1 and ARG2 as the    contents. */
end_comment

begin_function
name|NODE
modifier|*
name|build_message_node
parameter_list|(
name|format
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
name|void
modifier|*
name|arg1
decl_stmt|,
decl|*
name|arg2
decl_stmt|;
end_function

begin_block
block|{
name|NODE
modifier|*
name|node
decl_stmt|;
name|message_buffer_index
operator|=
literal|0
expr_stmt|;
name|build_message_buffer
argument_list|(
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|node
operator|=
name|message_buffer_to_node
argument_list|()
expr_stmt|;
return|return
operator|(
name|node
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Convert the contents of the message buffer to a node. */
end_comment

begin_function
name|NODE
modifier|*
name|message_buffer_to_node
parameter_list|()
block|{
name|NODE
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NODE
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|filename
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|nodename
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|display_pos
operator|=
literal|0
expr_stmt|;
comment|/* Make sure that this buffer ends with a newline. */
name|node
operator|->
name|nodelen
operator|=
literal|1
operator|+
name|strlen
argument_list|(
name|message_buffer
argument_list|)
expr_stmt|;
name|node
operator|->
name|contents
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|node
operator|->
name|nodelen
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|node
operator|->
name|contents
argument_list|,
name|message_buffer
argument_list|)
expr_stmt|;
name|node
operator|->
name|contents
index|[
name|node
operator|->
name|nodelen
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
name|node
operator|->
name|contents
index|[
name|node
operator|->
name|nodelen
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|node
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Useful functions can be called from outside of window.c. */
end_comment

begin_function
name|void
name|initialize_message_buffer
parameter_list|()
block|{
name|message_buffer_index
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print FORMAT with ARG1,2 to the end of the current message buffer. */
end_comment

begin_function
name|void
name|printf_to_message_buffer
parameter_list|(
name|format
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
name|void
modifier|*
name|arg1
decl_stmt|,
decl|*
name|arg2
decl_stmt|,
modifier|*
name|arg3
decl_stmt|;
end_function

begin_block
block|{
name|build_message_buffer
argument_list|(
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return the current horizontal position of the "cursor" on the most    recently output message buffer line. */
end_comment

begin_function
name|int
name|message_buffer_length_this_line
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|message_buffer_index
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
name|message_buffer_index
init|;
name|i
operator|&&
name|message_buffer
index|[
name|i
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|;
name|i
operator|--
control|)
empty_stmt|;
return|return
operator|(
name|string_width
argument_list|(
name|message_buffer
operator|+
name|i
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Pad STRING to COUNT characters by inserting blanks. */
end_comment

begin_function
name|int
name|pad_to
parameter_list|(
name|count
parameter_list|,
name|string
parameter_list|)
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|count
condition|)
name|string
index|[
name|i
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
else|else
block|{
while|while
condition|(
name|i
operator|<
name|count
condition|)
name|string
index|[
name|i
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
name|string
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

end_unit

