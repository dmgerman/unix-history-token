begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* infodoc.c -- Functions which build documentation nodes. */
end_comment

begin_comment
comment|/* This file is part of GNU Info, a program for reading online documentation    stored in Info format.     Copyright (C) 1993 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Written by Brian Fox (bfox@ai.mit.edu). */
end_comment

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_comment
comment|/* Normally we do not define HELP_NODE_GETS_REGENERATED because the    contents of the help node currently can never change once an info    session has been started.   You should consider defining this in    the case that you place information about dynamic variables in the    help text.  When that happens, the contents of the help node will    change dependent on the value of those variables, and the user will    expect to see those changes. */
end_comment

begin_comment
comment|/* #define HELP_NODE_GETS_REGENERATED 1 */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			  Info Help Windows			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* The name of the node used in the help window. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|info_help_nodename
init|=
literal|"*Info Help*"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A node containing printed key bindings and their documentation. */
end_comment

begin_decl_stmt
specifier|static
name|NODE
modifier|*
name|internal_info_help_node
init|=
operator|(
name|NODE
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A pointer to the contents of the help node. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|internal_info_help_node_contents
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The static text which appears in the internal info help node. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|info_internal_help_text
index|[]
init|=
block|{
literal|"Basic Commands in Info Windows"
block|,
literal|"******************************"
block|,
literal|""
block|,
literal|"  h   Invoke the Info tutorial."
block|,
literal|""
block|,
literal|"Selecting other nodes:"
block|,
literal|"----------------------"
block|,
literal|"  n   Move to the \"next\" node of this node."
block|,
literal|"  p   Move to the \"previous\" node of this node."
block|,
literal|"  u   Move \"up\" from this node."
block|,
literal|"  m   Pick menu item specified by name."
block|,
literal|"      Picking a menu item causes another node to be selected."
block|,
literal|"  f   Follow a cross reference.  Reads name of reference."
block|,
literal|"  l   Move to the last node seen in this window."
block|,
literal|"  d   Move to the `directory' node.  Equivalent to `g(DIR)'."
block|,
literal|""
block|,
literal|"Moving within a node:"
block|,
literal|"---------------------"
block|,
literal|"  SPC Scroll forward a page."
block|,
literal|"  DEL Scroll backward a page."
block|,
literal|"  b   Go to the beginning of this node."
block|,
literal|"  e   Go to the end of this node."
block|,
literal|""
block|,
literal|"\"Advanced\" commands:"
block|,
literal|"--------------------"
block|,
literal|"  q   Quit Info."
block|,
literal|"  1   Pick first item in node's menu."
block|,
literal|"  2-9 Pick second ... ninth item in node's menu."
block|,
literal|"  0   Pick last item in node's menu."
block|,
literal|"  g   Move to node specified by name."
block|,
literal|"      You may include a filename as well, as in (FILENAME)NODENAME."
block|,
literal|"  s   Search through this Info file for a specified string,"
block|,
literal|"      and select the node in which the next occurrence is found."
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|where_is
argument_list|()
decl_stmt|,
modifier|*
name|where_is_internal
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|dump_map_to_message_buffer
parameter_list|(
name|prefix
parameter_list|,
name|map
parameter_list|)
name|char
modifier|*
name|prefix
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|map
index|[
name|i
index|]
operator|.
name|type
operator|==
name|ISKMAP
condition|)
block|{
name|char
modifier|*
name|new_prefix
decl_stmt|,
modifier|*
name|keyname
decl_stmt|;
name|keyname
operator|=
name|pretty_keyname
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|new_prefix
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|3
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|keyname
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new_prefix
argument_list|,
literal|"%s%s%s "
argument_list|,
name|prefix
argument_list|,
operator|*
name|prefix
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|keyname
argument_list|)
expr_stmt|;
name|dump_map_to_message_buffer
argument_list|(
name|new_prefix
argument_list|,
operator|(
name|Keymap
operator|)
name|map
index|[
name|i
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_prefix
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|map
index|[
name|i
index|]
operator|.
name|function
condition|)
block|{
specifier|register
name|int
name|last
decl_stmt|;
name|char
modifier|*
name|doc
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|doc
operator|=
name|function_documentation
argument_list|(
name|map
index|[
name|i
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
name|name
operator|=
name|function_name
argument_list|(
name|map
index|[
name|i
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|doc
condition|)
continue|continue;
comment|/* Find out if there is a series of identical functions, as in 	     ea_insert (). */
for|for
control|(
name|last
operator|=
name|i
operator|+
literal|1
init|;
name|last
operator|<
literal|256
condition|;
name|last
operator|++
control|)
if|if
condition|(
operator|(
name|map
index|[
name|last
index|]
operator|.
name|type
operator|!=
name|ISFUNC
operator|)
operator|||
operator|(
name|map
index|[
name|last
index|]
operator|.
name|function
operator|!=
name|map
index|[
name|i
index|]
operator|.
name|function
operator|)
condition|)
break|break;
if|if
condition|(
name|last
operator|-
literal|1
operator|!=
name|i
condition|)
block|{
name|printf_to_message_buffer
argument_list|(
literal|"%s%s .. "
argument_list|,
name|prefix
argument_list|,
name|pretty_keyname
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|printf_to_message_buffer
argument_list|(
literal|"%s%s\t"
argument_list|,
name|prefix
argument_list|,
name|pretty_keyname
argument_list|(
name|last
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|last
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|printf_to_message_buffer
argument_list|(
literal|"%s%s\t"
argument_list|,
name|prefix
argument_list|,
name|pretty_keyname
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NAMED_FUNCTIONS
argument_list|)
comment|/* Print the name of the function, and some padding before the 	     documentation string is printed. */
block|{
name|int
name|length_so_far
decl_stmt|;
name|int
name|desired_doc_start
init|=
literal|40
decl_stmt|;
comment|/* Must be multiple of 8. */
name|printf_to_message_buffer
argument_list|(
literal|"(%s)"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|length_so_far
operator|=
name|message_buffer_length_this_line
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|desired_doc_start
operator|+
name|strlen
argument_list|(
name|doc
argument_list|)
operator|)
operator|>=
name|the_screen
operator|->
name|width
condition|)
name|printf_to_message_buffer
argument_list|(
literal|"\n     "
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|length_so_far
operator|<
name|desired_doc_start
condition|)
block|{
name|printf_to_message_buffer
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|length_so_far
operator|+=
name|character_width
argument_list|(
literal|'\t'
argument_list|,
name|length_so_far
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* NAMED_FUNCTIONS */
name|printf_to_message_buffer
argument_list|(
literal|"%s\n"
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* How to create internal_info_help_node. */
end_comment

begin_function
specifier|static
name|void
name|create_internal_info_help_node
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|contents
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|NODE
modifier|*
name|node
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HELP_NODE_GETS_REGENERATED
argument_list|)
if|if
condition|(
name|internal_info_help_node_contents
condition|)
name|contents
operator|=
name|internal_info_help_node_contents
expr_stmt|;
endif|#
directive|endif
comment|/* !HELP_NODE_GETS_REGENERATED */
if|if
condition|(
operator|!
name|contents
condition|)
block|{
name|int
name|printed_one_mx
init|=
literal|0
decl_stmt|;
name|initialize_message_buffer
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|info_internal_help_text
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|printf_to_message_buffer
argument_list|(
literal|"%s\n"
argument_list|,
name|info_internal_help_text
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf_to_message_buffer
argument_list|(
literal|"---------------------\n\n"
argument_list|)
expr_stmt|;
name|printf_to_message_buffer
argument_list|(
literal|"The current search path is:\n"
argument_list|)
expr_stmt|;
name|printf_to_message_buffer
argument_list|(
literal|"  \"%s\"\n"
argument_list|,
name|infopath
argument_list|)
expr_stmt|;
name|printf_to_message_buffer
argument_list|(
literal|"---------------------\n\n"
argument_list|)
expr_stmt|;
name|printf_to_message_buffer
argument_list|(
literal|"Commands available in Info windows:\n\n"
argument_list|)
expr_stmt|;
name|dump_map_to_message_buffer
argument_list|(
literal|""
argument_list|,
name|info_keymap
argument_list|)
expr_stmt|;
name|printf_to_message_buffer
argument_list|(
literal|"---------------------\n\n"
argument_list|)
expr_stmt|;
name|printf_to_message_buffer
argument_list|(
literal|"Commands available in the echo area:\n\n"
argument_list|)
expr_stmt|;
name|dump_map_to_message_buffer
argument_list|(
literal|""
argument_list|,
name|echo_area_keymap
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NAMED_FUNCTIONS
argument_list|)
comment|/* Get a list of the M-x commands which have no keystroke equivs. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|function_doc_array
index|[
name|i
index|]
operator|.
name|func
condition|;
name|i
operator|++
control|)
block|{
name|VFunction
modifier|*
name|func
init|=
name|function_doc_array
index|[
name|i
index|]
operator|.
name|func
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|where_is_internal
argument_list|(
name|info_keymap
argument_list|,
name|func
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|where_is_internal
argument_list|(
name|echo_area_keymap
argument_list|,
name|func
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|printed_one_mx
condition|)
block|{
name|printf_to_message_buffer
argument_list|(
literal|"---------------------\n\n"
argument_list|)
expr_stmt|;
name|printf_to_message_buffer
argument_list|(
literal|"The following commands can only be invoked via M-x:\n\n"
argument_list|)
expr_stmt|;
name|printed_one_mx
operator|=
literal|1
expr_stmt|;
block|}
name|printf_to_message_buffer
argument_list|(
literal|"M-x %s\n     %s\n"
argument_list|,
name|function_doc_array
index|[
name|i
index|]
operator|.
name|func_name
argument_list|,
name|replace_in_documentation
argument_list|(
name|function_doc_array
index|[
name|i
index|]
operator|.
name|doc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|printed_one_mx
condition|)
name|printf_to_message_buffer
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NAMED_FUNCTIONS */
name|printf_to_message_buffer
argument_list|(
literal|"%s"
argument_list|,
name|replace_in_documentation
argument_list|(
literal|"--- Use `\\[history-node]' or `\\[kill-node]' to exit ---\n"
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|message_buffer_to_node
argument_list|()
expr_stmt|;
name|internal_info_help_node_contents
operator|=
name|node
operator|->
name|contents
expr_stmt|;
block|}
else|else
block|{
comment|/* We already had the right contents, so simply use them. */
name|node
operator|=
name|build_message_node
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
operator|->
name|contents
argument_list|)
expr_stmt|;
name|node
operator|->
name|contents
operator|=
name|contents
expr_stmt|;
name|node
operator|->
name|nodelen
operator|=
literal|1
operator|+
name|strlen
argument_list|(
name|contents
argument_list|)
expr_stmt|;
block|}
name|internal_info_help_node
operator|=
name|node
expr_stmt|;
comment|/* Do not GC this node's contents.  It never changes, and we never need      to delete it once it is made.  If you change some things (such as      placing information about dynamic variables in the help text) then      you will need to allow the contents to be gc'd, and you will have to      arrange to always regenerate the help node. */
if|#
directive|if
name|defined
argument_list|(
name|HELP_NODE_GETS_REGENERATED
argument_list|)
name|add_gcable_pointer
argument_list|(
name|internal_info_help_node
operator|->
name|contents
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|name_internal_node
argument_list|(
name|internal_info_help_node
argument_list|,
name|info_help_nodename
argument_list|)
expr_stmt|;
comment|/* Even though this is an internal node, we don't want the window      system to treat it specially.  So we turn off the internalness      of it here. */
name|internal_info_help_node
operator|->
name|flags
operator|&=
operator|~
name|N_IsInternal
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a window which is the window showing help in this Info. */
end_comment

begin_function
specifier|static
name|WINDOW
modifier|*
name|info_find_or_create_help_window
parameter_list|()
block|{
name|WINDOW
modifier|*
name|help_window
decl_stmt|,
modifier|*
name|eligible
decl_stmt|,
modifier|*
name|window
decl_stmt|;
name|eligible
operator|=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
expr_stmt|;
name|help_window
operator|=
name|get_internal_info_window
argument_list|(
name|info_help_nodename
argument_list|)
expr_stmt|;
comment|/* If we couldn't find the help window, then make it. */
if|if
condition|(
operator|!
name|help_window
condition|)
block|{
name|int
name|max
init|=
literal|0
decl_stmt|;
for|for
control|(
name|window
operator|=
name|windows
init|;
name|window
condition|;
name|window
operator|=
name|window
operator|->
name|next
control|)
block|{
if|if
condition|(
name|window
operator|->
name|height
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|window
operator|->
name|height
expr_stmt|;
name|eligible
operator|=
name|window
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|eligible
condition|)
return|return
operator|(
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HELP_NODE_GETS_REGENERATED
argument_list|)
else|else
return|return
operator|(
name|help_window
operator|)
return|;
endif|#
directive|endif
comment|/* !HELP_NODE_GETS_REGENERATED */
comment|/* Make sure that we have a node containing the help text. */
name|create_internal_info_help_node
argument_list|()
expr_stmt|;
comment|/* Either use the existing window to display the help node, or create      a new window if there was no existing help window. */
if|if
condition|(
operator|!
name|help_window
condition|)
block|{
comment|/* Split the largest window into 2 windows, and show the help text 	 in that window. */
if|if
condition|(
name|eligible
operator|->
name|height
operator|>
literal|30
condition|)
block|{
name|active_window
operator|=
name|eligible
expr_stmt|;
name|help_window
operator|=
name|window_make_window
argument_list|(
name|internal_info_help_node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_remembered_pagetop_and_point
argument_list|(
name|active_window
argument_list|)
expr_stmt|;
name|window_set_node_of_window
argument_list|(
name|active_window
argument_list|,
name|internal_info_help_node
argument_list|)
expr_stmt|;
name|help_window
operator|=
name|active_window
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Case where help node always gets regenerated, and we have an 	 existing window in which to place the node. */
if|if
condition|(
name|active_window
operator|!=
name|help_window
condition|)
block|{
name|set_remembered_pagetop_and_point
argument_list|(
name|active_window
argument_list|)
expr_stmt|;
name|active_window
operator|=
name|help_window
expr_stmt|;
block|}
name|window_set_node_of_window
argument_list|(
name|active_window
argument_list|,
name|internal_info_help_node
argument_list|)
expr_stmt|;
block|}
name|remember_window_and_node
argument_list|(
name|help_window
argument_list|,
name|help_window
operator|->
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|help_window
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create or move to the help window. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_get_help_window
argument_list|,
literal|"Display help message"
argument_list|)
end_macro

begin_block
block|{
name|WINDOW
modifier|*
name|help_window
decl_stmt|;
name|help_window
operator|=
name|info_find_or_create_help_window
argument_list|()
expr_stmt|;
if|if
condition|(
name|help_window
condition|)
block|{
name|active_window
operator|=
name|help_window
expr_stmt|;
name|active_window
operator|->
name|flags
operator||=
name|W_UpdateWindow
expr_stmt|;
block|}
else|else
block|{
name|info_error
argument_list|(
name|CANT_MAKE_HELP
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Show the Info help node.  This means that the "info" file is installed    where it can easily be found on your system. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_get_info_help_node
argument_list|,
literal|"Visit Info node `(info)Help'"
argument_list|)
end_macro

begin_block
block|{
name|NODE
modifier|*
name|node
decl_stmt|;
name|char
modifier|*
name|nodename
decl_stmt|;
comment|/* If there is a window on the screen showing the node "(info)Help" or      the node "(info)Help-Small-Screen", simply select that window. */
block|{
name|WINDOW
modifier|*
name|win
decl_stmt|;
for|for
control|(
name|win
operator|=
name|windows
init|;
name|win
condition|;
name|win
operator|=
name|win
operator|->
name|next
control|)
block|{
if|if
condition|(
name|win
operator|->
name|node
operator|&&
name|win
operator|->
name|node
operator|->
name|filename
operator|&&
operator|(
name|strcasecmp
argument_list|(
name|filename_non_directory
argument_list|(
name|win
operator|->
name|node
operator|->
name|filename
argument_list|)
argument_list|,
literal|"info"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|strcmp
argument_list|(
name|win
operator|->
name|node
operator|->
name|nodename
argument_list|,
literal|"Help"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|win
operator|->
name|node
operator|->
name|nodename
argument_list|,
literal|"Help-Small-Screen"
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|active_window
operator|=
name|win
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* If the current window is small, show the small screen help. */
if|if
condition|(
name|active_window
operator|->
name|height
operator|<
literal|24
condition|)
name|nodename
operator|=
literal|"Help-Small-Screen"
expr_stmt|;
else|else
name|nodename
operator|=
literal|"Help"
expr_stmt|;
comment|/* Try to get the info file for Info. */
name|node
operator|=
name|info_get_node
argument_list|(
literal|"Info"
argument_list|,
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
block|{
if|if
condition|(
name|info_recent_file_error
condition|)
name|info_error
argument_list|(
name|info_recent_file_error
argument_list|)
expr_stmt|;
else|else
name|info_error
argument_list|(
name|CANT_FILE_NODE
argument_list|,
literal|"Info"
argument_list|,
name|nodename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the current window is very large (greater than 45 lines), 	 then split it and show the help node in another window. 	 Otherwise, use the current window. */
if|if
condition|(
name|active_window
operator|->
name|height
operator|>
literal|45
condition|)
name|active_window
operator|=
name|window_make_window
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
block|{
name|set_remembered_pagetop_and_point
argument_list|(
name|active_window
argument_list|)
expr_stmt|;
name|window_set_node_of_window
argument_list|(
name|active_window
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
name|remember_window_and_node
argument_list|(
name|active_window
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		     Groveling Info Keymaps and Docs		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Return the documentation associated with the Info command FUNCTION. */
end_comment

begin_function
name|char
modifier|*
name|function_documentation
parameter_list|(
name|function
parameter_list|)
name|VFunction
modifier|*
name|function
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|function_doc_array
index|[
name|i
index|]
operator|.
name|func
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|function
operator|==
name|function_doc_array
index|[
name|i
index|]
operator|.
name|func
condition|)
break|break;
return|return
operator|(
name|replace_in_documentation
argument_list|(
name|function_doc_array
index|[
name|i
index|]
operator|.
name|doc
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NAMED_FUNCTIONS
argument_list|)
end_if

begin_comment
comment|/* Return the user-visible name of the function associated with the    Info command FUNCTION. */
end_comment

begin_function
name|char
modifier|*
name|function_name
parameter_list|(
name|function
parameter_list|)
name|VFunction
modifier|*
name|function
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|function_doc_array
index|[
name|i
index|]
operator|.
name|func
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|function
operator|==
name|function_doc_array
index|[
name|i
index|]
operator|.
name|func
condition|)
break|break;
return|return
operator|(
name|function_doc_array
index|[
name|i
index|]
operator|.
name|func_name
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the function named NAME. */
end_comment

begin_function
name|VFunction
modifier|*
name|named_function
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|function_doc_array
index|[
name|i
index|]
operator|.
name|func
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|function_doc_array
index|[
name|i
index|]
operator|.
name|func_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
return|return
operator|(
name|function_doc_array
index|[
name|i
index|]
operator|.
name|func
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAMED_FUNCTIONS */
end_comment

begin_comment
comment|/* Return the documentation associated with KEY in MAP. */
end_comment

begin_function
name|char
modifier|*
name|key_documentation
parameter_list|(
name|key
parameter_list|,
name|map
parameter_list|)
name|char
name|key
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
block|{
name|VFunction
modifier|*
name|function
init|=
name|map
index|[
name|key
index|]
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|function
condition|)
return|return
operator|(
name|function_documentation
argument_list|(
name|function
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|describe_key
argument_list|,
literal|"Print documentation for KEY"
argument_list|)
end_macro

begin_block
block|{
name|char
name|keyname
index|[
literal|50
index|]
decl_stmt|;
name|int
name|keyname_index
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|keystroke
decl_stmt|;
name|char
modifier|*
name|rep
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
name|keyname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|map
operator|=
name|window
operator|->
name|keymap
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|message_in_echo_area
argument_list|(
literal|"Describe key: %s"
argument_list|,
name|keyname
argument_list|)
expr_stmt|;
name|keystroke
operator|=
name|info_get_input_char
argument_list|()
expr_stmt|;
name|unmessage_in_echo_area
argument_list|()
expr_stmt|;
if|if
condition|(
name|Meta_p
argument_list|(
name|keystroke
argument_list|)
operator|&&
operator|(
operator|!
name|ISO_Latin_p
operator|||
name|key
operator|<
literal|160
operator|)
condition|)
block|{
if|if
condition|(
name|map
index|[
name|ESC
index|]
operator|.
name|type
operator|!=
name|ISKMAP
condition|)
block|{
name|window_message_in_echo_area
argument_list|(
literal|"ESC %s is undefined."
argument_list|,
name|pretty_keyname
argument_list|(
name|UnMeta
argument_list|(
name|keystroke
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|keyname
operator|+
name|keyname_index
argument_list|,
literal|"ESC "
argument_list|)
expr_stmt|;
name|keyname_index
operator|=
name|strlen
argument_list|(
name|keyname
argument_list|)
expr_stmt|;
name|keystroke
operator|=
name|UnMeta
argument_list|(
name|keystroke
argument_list|)
expr_stmt|;
name|map
operator|=
operator|(
name|Keymap
operator|)
name|map
index|[
name|ESC
index|]
operator|.
name|function
expr_stmt|;
block|}
comment|/* Add the printed representation of KEYSTROKE to our keyname. */
name|rep
operator|=
name|pretty_keyname
argument_list|(
name|keystroke
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|keyname
operator|+
name|keyname_index
argument_list|,
name|rep
argument_list|)
expr_stmt|;
name|keyname_index
operator|=
name|strlen
argument_list|(
name|keyname
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
index|[
name|keystroke
index|]
operator|.
name|function
operator|==
operator|(
name|VFunction
operator|*
operator|)
name|NULL
condition|)
block|{
name|message_in_echo_area
argument_list|(
literal|"%s is undefined."
argument_list|,
name|keyname
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|map
index|[
name|keystroke
index|]
operator|.
name|type
operator|==
name|ISKMAP
condition|)
block|{
name|map
operator|=
operator|(
name|Keymap
operator|)
name|map
index|[
name|keystroke
index|]
operator|.
name|function
expr_stmt|;
name|strcat
argument_list|(
name|keyname
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|keyname_index
operator|=
name|strlen
argument_list|(
name|keyname
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|char
modifier|*
name|message
decl_stmt|,
modifier|*
name|fundoc
decl_stmt|,
modifier|*
name|funname
init|=
literal|""
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NAMED_FUNCTIONS
argument_list|)
name|funname
operator|=
name|function_name
argument_list|(
name|map
index|[
name|keystroke
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NAMED_FUNCTIONS */
name|fundoc
operator|=
name|function_documentation
argument_list|(
name|map
index|[
name|keystroke
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
name|message
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|10
operator|+
name|strlen
argument_list|(
name|keyname
argument_list|)
operator|+
name|strlen
argument_list|(
name|fundoc
argument_list|)
operator|+
name|strlen
argument_list|(
name|funname
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NAMED_FUNCTIONS
argument_list|)
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"%s (%s): %s."
argument_list|,
name|keyname
argument_list|,
name|funname
argument_list|,
name|fundoc
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"%s is defined to %s."
argument_list|,
name|keyname
argument_list|,
name|fundoc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !NAMED_FUNCTIONS */
name|window_message_in_echo_area
argument_list|(
literal|"%s"
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|message
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_comment
comment|/* How to get the pretty printable name of a character. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rep_buffer
index|[
literal|30
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|pretty_keyname
parameter_list|(
name|key
parameter_list|)
name|unsigned
name|char
name|key
decl_stmt|;
block|{
name|char
modifier|*
name|rep
decl_stmt|;
if|if
condition|(
name|Meta_p
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|char
name|temp
index|[
literal|20
index|]
decl_stmt|;
name|rep
operator|=
name|pretty_keyname
argument_list|(
name|UnMeta
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"ESC %s"
argument_list|,
name|rep
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rep_buffer
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|rep
operator|=
name|rep_buffer
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Control_p
argument_list|(
name|key
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|'\n'
case|:
name|rep
operator|=
literal|"LFD"
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|rep
operator|=
literal|"TAB"
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|rep
operator|=
literal|"RET"
expr_stmt|;
break|break;
case|case
name|ESC
case|:
name|rep
operator|=
literal|"ESC"
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|rep_buffer
argument_list|,
literal|"C-%c"
argument_list|,
name|UnControl
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|=
name|rep_buffer
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|' '
case|:
name|rep
operator|=
literal|"SPC"
expr_stmt|;
break|break;
case|case
name|DEL
case|:
name|rep
operator|=
literal|"DEL"
expr_stmt|;
break|break;
default|default:
name|rep_buffer
index|[
literal|0
index|]
operator|=
name|key
expr_stmt|;
name|rep_buffer
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rep
operator|=
name|rep_buffer
expr_stmt|;
block|}
block|}
return|return
operator|(
name|rep
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Replace the names of functions with the key that invokes them. */
end_comment

begin_function
name|char
modifier|*
name|replace_in_documentation
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|start
decl_stmt|,
name|next
decl_stmt|;
specifier|static
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|maybe_free
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|next
operator|=
name|start
operator|=
literal|0
expr_stmt|;
comment|/* Skip to the beginning of a replaceable function. */
for|for
control|(
name|i
operator|=
name|start
init|;
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
comment|/* Is this the start of a replaceable function name? */
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'\\'
operator|&&
name|string
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'['
condition|)
block|{
name|char
modifier|*
name|fun_name
decl_stmt|,
modifier|*
name|rep
decl_stmt|;
name|VFunction
modifier|*
name|function
decl_stmt|;
comment|/* Copy in the old text. */
name|strncpy
argument_list|(
name|result
operator|+
name|next
argument_list|,
name|string
operator|+
name|start
argument_list|,
name|i
operator|-
name|start
argument_list|)
expr_stmt|;
name|next
operator|+=
operator|(
name|i
operator|-
name|start
operator|)
expr_stmt|;
name|start
operator|=
name|i
operator|+
literal|2
expr_stmt|;
comment|/* Move to the end of the function name. */
for|for
control|(
name|i
operator|=
name|start
init|;
name|string
index|[
name|i
index|]
operator|&&
operator|(
name|string
index|[
name|i
index|]
operator|!=
literal|']'
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|fun_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|i
operator|-
name|start
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|fun_name
argument_list|,
name|string
operator|+
name|start
argument_list|,
name|i
operator|-
name|start
argument_list|)
expr_stmt|;
name|fun_name
index|[
name|i
operator|-
name|start
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Find a key which invokes this function in the info_keymap. */
name|function
operator|=
name|named_function
argument_list|(
name|fun_name
argument_list|)
expr_stmt|;
comment|/* If the internal documentation string fails, there is a  	     serious problem with the associated command's documentation. 	     We croak so that it can be fixed immediately. */
if|if
condition|(
operator|!
name|function
condition|)
name|abort
argument_list|()
expr_stmt|;
name|rep
operator|=
name|where_is
argument_list|(
name|info_keymap
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|next
argument_list|,
name|rep
argument_list|)
expr_stmt|;
name|next
operator|=
name|strlen
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|start
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|string
index|[
name|i
index|]
condition|)
name|start
operator|++
expr_stmt|;
block|}
block|}
name|strcpy
argument_list|(
name|result
operator|+
name|next
argument_list|,
name|string
operator|+
name|start
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a string of characters which could be typed from the keymap    MAP to invoke FUNCTION. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|where_is_rep
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|where_is_rep_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|where_is_rep_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|where_is
parameter_list|(
name|map
parameter_list|,
name|function
parameter_list|)
name|Keymap
name|map
decl_stmt|;
name|VFunction
modifier|*
name|function
decl_stmt|;
block|{
name|char
modifier|*
name|rep
decl_stmt|;
if|if
condition|(
operator|!
name|where_is_rep_size
condition|)
name|where_is_rep
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|where_is_rep_size
operator|=
literal|100
argument_list|)
expr_stmt|;
name|where_is_rep_index
operator|=
literal|0
expr_stmt|;
name|rep
operator|=
name|where_is_internal
argument_list|(
name|map
argument_list|,
name|function
argument_list|)
expr_stmt|;
comment|/* If it couldn't be found, return "M-x Foo". */
if|if
condition|(
operator|!
name|rep
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|function_name
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|sprintf
argument_list|(
name|where_is_rep
argument_list|,
literal|"M-x %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rep
operator|=
name|where_is_rep
expr_stmt|;
block|}
return|return
operator|(
name|rep
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the printed rep of FUNCTION as found in MAP, or NULL. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|where_is_internal
parameter_list|(
name|map
parameter_list|,
name|function
parameter_list|)
name|Keymap
name|map
decl_stmt|;
name|VFunction
modifier|*
name|function
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* If the function is directly invokable in MAP, return the representation      of that keystroke. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|map
index|[
name|i
index|]
operator|.
name|type
operator|==
name|ISFUNC
operator|)
operator|&&
name|map
index|[
name|i
index|]
operator|.
name|function
operator|==
name|function
condition|)
block|{
name|sprintf
argument_list|(
name|where_is_rep
operator|+
name|where_is_rep_index
argument_list|,
literal|"%s"
argument_list|,
name|pretty_keyname
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|where_is_rep
operator|)
return|;
block|}
comment|/* Okay, search subsequent maps for this function. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|map
index|[
name|i
index|]
operator|.
name|type
operator|==
name|ISKMAP
condition|)
block|{
name|int
name|saved_index
init|=
name|where_is_rep_index
decl_stmt|;
name|char
modifier|*
name|rep
decl_stmt|;
name|sprintf
argument_list|(
name|where_is_rep
operator|+
name|where_is_rep_index
argument_list|,
literal|"%s "
argument_list|,
name|pretty_keyname
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|where_is_rep_index
operator|=
name|strlen
argument_list|(
name|where_is_rep
argument_list|)
expr_stmt|;
name|rep
operator|=
name|where_is_internal
argument_list|(
operator|(
name|Keymap
operator|)
name|map
index|[
name|i
index|]
operator|.
name|function
argument_list|,
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
condition|)
return|return
operator|(
name|where_is_rep
operator|)
return|;
name|where_is_rep_index
operator|=
name|saved_index
expr_stmt|;
block|}
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|extern
name|char
modifier|*
name|read_function_name
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_where_is
argument_list|,
literal|"Show what to type to execute a given command"
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|command_name
decl_stmt|;
name|command_name
operator|=
name|read_function_name
argument_list|(
literal|"Where is command: "
argument_list|,
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|command_name
condition|)
block|{
name|info_abort_key
argument_list|(
name|active_window
argument_list|,
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|command_name
condition|)
block|{
name|VFunction
modifier|*
name|function
decl_stmt|;
name|function
operator|=
name|named_function
argument_list|(
name|command_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|function
condition|)
block|{
name|char
modifier|*
name|location
decl_stmt|;
name|location
operator|=
name|where_is
argument_list|(
name|active_window
operator|->
name|keymap
argument_list|,
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|location
condition|)
block|{
name|info_error
argument_list|(
literal|"`%s' is not on any keys"
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|location
argument_list|,
literal|"M-x "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|window_message_in_echo_area
argument_list|(
literal|"%s can only be invoked via %s."
argument_list|,
name|command_name
argument_list|,
name|location
argument_list|)
expr_stmt|;
else|else
name|window_message_in_echo_area
argument_list|(
literal|"%s can be invoked via %s."
argument_list|,
name|command_name
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|info_error
argument_list|(
literal|"There is no function named `%s'"
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|command_name
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

