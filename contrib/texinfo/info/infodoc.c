begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* infodoc.c -- Functions which build documentation nodes.    $Id: infodoc.c,v 1.23 1999/09/25 16:10:04 karl Exp $     Copyright (C) 1993, 97, 98, 99 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Written by Brian Fox (bfox@ai.mit.edu). */
end_comment

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_comment
comment|/* HELP_NODE_GETS_REGENERATED is always defined now that keys may get    rebound, or other changes in the help text may occur.  */
end_comment

begin_define
define|#
directive|define
name|HELP_NODE_GETS_REGENERATED
value|1
end_define

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/*                        Info Help Windows                         */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* The name of the node used in the help window. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|info_help_nodename
init|=
literal|"*Info Help*"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A node containing printed key bindings and their documentation. */
end_comment

begin_decl_stmt
specifier|static
name|NODE
modifier|*
name|internal_info_help_node
init|=
operator|(
name|NODE
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A pointer to the contents of the help node. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|internal_info_help_node_contents
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The static text which appears in the internal info help node. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|info_internal_help_text
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"Basic Commands in Info Windows\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"******************************\n"
argument_list|)
block|,
literal|"\n"
block|,
name|N_
argument_list|(
literal|"  %-10s  Quit this help.\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  %-10s  Quit Info altogether.\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  %-10s  Invoke the Info tutorial.\n"
argument_list|)
block|,
literal|"\n"
block|,
name|N_
argument_list|(
literal|"Moving within a node:\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"---------------------\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  %-10s  Scroll forward a page.\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  %-10s  Scroll backward a page.\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  %-10s  Go to the beginning of this node.\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  %-10s  Go to the end of this node.\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  %-10s  Scroll forward 1 line.\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  %-10s  Scroll backward 1 line.\n"
argument_list|)
block|,
literal|"\n"
block|,
name|N_
argument_list|(
literal|"Selecting other nodes:\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"----------------------\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  %-10s  Move to the `next' node of this node.\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  %-10s  Move to the `previous' node of this node.\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  %-10s  Move `up' from this node.\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  %-10s  Pick menu item specified by name.\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"              Picking a menu item causes another node to be selected.\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  %-10s  Follow a cross reference.  Reads name of reference.\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  %-10s  Move to the last node seen in this window.\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  %-10s  Skip to next hypertext link within this node.\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  %-10s  Follow the hypertext link under cursor.\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  %-10s  Move to the `directory' node.  Equivalent to `g (DIR)'.\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  %-10s  Move to the Top node.  Equivalent to `g Top'.\n"
argument_list|)
block|,
literal|"\n"
block|,
name|N_
argument_list|(
literal|"Other commands:\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"---------------\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  %-10s  Pick first ... ninth item in node's menu.\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  %-10s  Pick last item in node's menu.\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  %-10s  Search for a specified string in the index entries of this Info\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"              file, and select the node referenced by the first entry found.\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  %-10s  Move to node specified by name.\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"              You may include a filename as well, as in (FILENAME)NODENAME.\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  %-10s  Search forward through this Info file for a specified string,\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"              and select the node in which the next occurrence is found.\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"  %-10s  Search backward in this Info file for a specified string,\n"
argument_list|)
block|,
name|N_
argument_list|(
literal|"              and select the node in which the next occurrence is found.\n"
argument_list|)
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|info_help_keys_text
index|[]
index|[
literal|2
index|]
init|=
block|{
block|{
literal|""
block|,
literal|""
block|}
block|,
block|{
literal|""
block|,
literal|""
block|}
block|,
block|{
literal|""
block|,
literal|""
block|}
block|,
block|{
literal|"CTRL-x 0"
block|,
literal|"CTRL-x 0"
block|}
block|,
block|{
literal|"q"
block|,
literal|"q"
block|}
block|,
block|{
literal|"h"
block|,
literal|"ESC h"
block|}
block|,
block|{
literal|""
block|,
literal|""
block|}
block|,
block|{
literal|""
block|,
literal|""
block|}
block|,
block|{
literal|""
block|,
literal|""
block|}
block|,
block|{
literal|"SPC"
block|,
literal|"SPC"
block|}
block|,
block|{
literal|"DEL"
block|,
literal|"b"
block|}
block|,
block|{
literal|"b"
block|,
literal|"ESC b"
block|}
block|,
block|{
literal|"e"
block|,
literal|"ESC e"
block|}
block|,
block|{
literal|"ESC 1 SPC"
block|,
literal|"RET"
block|}
block|,
block|{
literal|"ESC 1 DEL"
block|,
literal|"y"
block|}
block|,
block|{
literal|""
block|,
literal|""
block|}
block|,
block|{
literal|""
block|,
literal|""
block|}
block|,
block|{
literal|""
block|,
literal|""
block|}
block|,
block|{
literal|"n"
block|,
literal|"CTRL-x n"
block|}
block|,
block|{
literal|"p"
block|,
literal|"CTRL-x p"
block|}
block|,
block|{
literal|"u"
block|,
literal|"CTRL-x u"
block|}
block|,
block|{
literal|"m"
block|,
literal|"ESC m"
block|}
block|,
block|{
literal|""
block|,
literal|""
block|}
block|,
block|{
literal|"f"
block|,
literal|"ESC f"
block|}
block|,
block|{
literal|"l"
block|,
literal|"l"
block|}
block|,
block|{
literal|"TAB"
block|,
literal|"TAB"
block|}
block|,
block|{
literal|"RET"
block|,
literal|"CTRL-x RET"
block|}
block|,
block|{
literal|"d"
block|,
literal|"ESC d"
block|}
block|,
block|{
literal|"t"
block|,
literal|"ESC t"
block|}
block|,
block|{
literal|""
block|,
literal|""
block|}
block|,
block|{
literal|""
block|,
literal|""
block|}
block|,
block|{
literal|""
block|,
literal|""
block|}
block|,
block|{
literal|"1-9"
block|,
literal|"ESC 1-9"
block|}
block|,
block|{
literal|"0"
block|,
literal|"ESC 0"
block|}
block|,
block|{
literal|"i"
block|,
literal|"CTRL-x i"
block|}
block|,
block|{
literal|""
block|,
literal|""
block|}
block|,
block|{
literal|"g"
block|,
literal|"CTRL-x g"
block|}
block|,
block|{
literal|""
block|,
literal|""
block|}
block|,
block|{
literal|"s"
block|,
literal|"/"
block|}
block|,
block|{
literal|""
block|,
literal|""
block|}
block|,
block|{
literal|"ESC - s"
block|,
literal|"?"
block|}
block|,
block|{
literal|""
block|,
literal|""
block|}
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|where_is
argument_list|()
decl_stmt|,
modifier|*
name|where_is_internal
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|dump_map_to_message_buffer
parameter_list|(
name|prefix
parameter_list|,
name|map
parameter_list|)
name|char
modifier|*
name|prefix
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|map
index|[
name|i
index|]
operator|.
name|type
operator|==
name|ISKMAP
condition|)
block|{
name|char
modifier|*
name|new_prefix
decl_stmt|,
modifier|*
name|keyname
decl_stmt|;
name|keyname
operator|=
name|pretty_keyname
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|new_prefix
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|3
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|keyname
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new_prefix
argument_list|,
literal|"%s%s%s "
argument_list|,
name|prefix
argument_list|,
operator|*
name|prefix
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|keyname
argument_list|)
expr_stmt|;
name|dump_map_to_message_buffer
argument_list|(
name|new_prefix
argument_list|,
operator|(
name|Keymap
operator|)
name|map
index|[
name|i
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_prefix
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|map
index|[
name|i
index|]
operator|.
name|function
condition|)
block|{
specifier|register
name|int
name|last
decl_stmt|;
name|char
modifier|*
name|doc
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|doc
operator|=
name|function_documentation
argument_list|(
name|map
index|[
name|i
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
name|name
operator|=
name|function_name
argument_list|(
name|map
index|[
name|i
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|doc
condition|)
continue|continue;
comment|/* Find out if there is a series of identical functions, as in              ea_insert (). */
for|for
control|(
name|last
operator|=
name|i
operator|+
literal|1
init|;
name|last
operator|<
literal|256
condition|;
name|last
operator|++
control|)
if|if
condition|(
operator|(
name|map
index|[
name|last
index|]
operator|.
name|type
operator|!=
name|ISFUNC
operator|)
operator|||
operator|(
name|map
index|[
name|last
index|]
operator|.
name|function
operator|!=
name|map
index|[
name|i
index|]
operator|.
name|function
operator|)
condition|)
break|break;
if|if
condition|(
name|last
operator|-
literal|1
operator|!=
name|i
condition|)
block|{
name|printf_to_message_buffer
argument_list|(
literal|"%s%s .. "
argument_list|,
name|prefix
argument_list|,
name|pretty_keyname
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|printf_to_message_buffer
argument_list|(
literal|"%s%s\t"
argument_list|,
name|prefix
argument_list|,
name|pretty_keyname
argument_list|(
name|last
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|last
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|printf_to_message_buffer
argument_list|(
literal|"%s%s\t"
argument_list|,
name|prefix
argument_list|,
name|pretty_keyname
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NAMED_FUNCTIONS
argument_list|)
comment|/* Print the name of the function, and some padding before the              documentation string is printed. */
block|{
name|int
name|length_so_far
decl_stmt|;
name|int
name|desired_doc_start
init|=
literal|40
decl_stmt|;
comment|/* Must be multiple of 8. */
name|printf_to_message_buffer
argument_list|(
literal|"(%s)"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|length_so_far
operator|=
name|message_buffer_length_this_line
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|desired_doc_start
operator|+
name|strlen
argument_list|(
name|doc
argument_list|)
operator|)
operator|>=
name|the_screen
operator|->
name|width
condition|)
name|printf_to_message_buffer
argument_list|(
literal|"\n     "
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|length_so_far
operator|<
name|desired_doc_start
condition|)
block|{
name|printf_to_message_buffer
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|length_so_far
operator|+=
name|character_width
argument_list|(
literal|'\t'
argument_list|,
name|length_so_far
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* NAMED_FUNCTIONS */
name|printf_to_message_buffer
argument_list|(
literal|"%s\n"
argument_list|,
name|doc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* How to create internal_info_help_node.  HELP_IS_ONLY_WINDOW_P says    whether we're going to end up in a second (or more) window of our    own, or whether there's only one window and we're going to usurp it.    This determines how to quit the help window.  Maybe we should just    make q do the right thing in both cases.  */
end_comment

begin_function
specifier|static
name|void
name|create_internal_info_help_node
parameter_list|(
name|help_is_only_window_p
parameter_list|)
name|int
name|help_is_only_window_p
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|NODE
modifier|*
name|node
decl_stmt|;
name|char
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
ifndef|#
directive|ifndef
name|HELP_NODE_GETS_REGENERATED
if|if
condition|(
name|internal_info_help_node_contents
condition|)
name|contents
operator|=
name|internal_info_help_node_contents
expr_stmt|;
endif|#
directive|endif
comment|/* !HELP_NODE_GETS_REGENERATED */
if|if
condition|(
operator|!
name|contents
condition|)
block|{
name|int
name|printed_one_mx
init|=
literal|0
decl_stmt|;
name|initialize_message_buffer
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|info_internal_help_text
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
comment|/* Don't translate blank lines, gettext outputs the po file              header in that case.  We want a blank line.  */
name|char
modifier|*
name|msg
init|=
operator|*
operator|(
name|info_internal_help_text
index|[
name|i
index|]
operator|)
condition|?
name|_
argument_list|(
name|info_internal_help_text
index|[
name|i
index|]
argument_list|)
else|:
name|info_internal_help_text
index|[
name|i
index|]
decl_stmt|;
name|char
modifier|*
name|key
init|=
name|info_help_keys_text
index|[
name|i
index|]
index|[
name|vi_keys_p
index|]
decl_stmt|;
comment|/* If we have only one window (because the window size was too              small to split it), CTRL-x 0 doesn't work to `quit' help.  */
if|if
condition|(
name|STREQ
argument_list|(
name|key
argument_list|,
literal|"CTRL-x 0"
argument_list|)
operator|&&
name|help_is_only_window_p
condition|)
name|key
operator|=
literal|"l"
expr_stmt|;
name|printf_to_message_buffer
argument_list|(
name|msg
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
name|printf_to_message_buffer
argument_list|(
literal|"---------------------\n\n"
argument_list|)
expr_stmt|;
name|printf_to_message_buffer
argument_list|(
name|_
argument_list|(
literal|"The current search path is:\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_to_message_buffer
argument_list|(
literal|"  %s\n"
argument_list|,
name|infopath
argument_list|)
expr_stmt|;
name|printf_to_message_buffer
argument_list|(
literal|"---------------------\n\n"
argument_list|)
expr_stmt|;
name|printf_to_message_buffer
argument_list|(
name|_
argument_list|(
literal|"Commands available in Info windows:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|dump_map_to_message_buffer
argument_list|(
literal|""
argument_list|,
name|info_keymap
argument_list|)
expr_stmt|;
name|printf_to_message_buffer
argument_list|(
literal|"---------------------\n\n"
argument_list|)
expr_stmt|;
name|printf_to_message_buffer
argument_list|(
name|_
argument_list|(
literal|"Commands available in the echo area:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|dump_map_to_message_buffer
argument_list|(
literal|""
argument_list|,
name|echo_area_keymap
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NAMED_FUNCTIONS
argument_list|)
comment|/* Get a list of the M-x commands which have no keystroke equivs. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|function_doc_array
index|[
name|i
index|]
operator|.
name|func
condition|;
name|i
operator|++
control|)
block|{
name|VFunction
modifier|*
name|func
init|=
name|function_doc_array
index|[
name|i
index|]
operator|.
name|func
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|where_is_internal
argument_list|(
name|info_keymap
argument_list|,
name|func
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|where_is_internal
argument_list|(
name|echo_area_keymap
argument_list|,
name|func
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|printed_one_mx
condition|)
block|{
name|printf_to_message_buffer
argument_list|(
literal|"---------------------\n\n"
argument_list|)
expr_stmt|;
name|printf_to_message_buffer
argument_list|(
name|_
argument_list|(
literal|"The following commands can only be invoked via M-x:\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printed_one_mx
operator|=
literal|1
expr_stmt|;
block|}
name|printf_to_message_buffer
argument_list|(
literal|"M-x %s\n     %s\n"
argument_list|,
name|function_doc_array
index|[
name|i
index|]
operator|.
name|func_name
argument_list|,
name|replace_in_documentation
argument_list|(
name|strlen
argument_list|(
name|function_doc_array
index|[
name|i
index|]
operator|.
name|doc
argument_list|)
operator|==
literal|0
condition|?
name|function_doc_array
index|[
name|i
index|]
operator|.
name|doc
else|:
name|_
argument_list|(
name|function_doc_array
index|[
name|i
index|]
operator|.
name|doc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|printed_one_mx
condition|)
name|printf_to_message_buffer
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NAMED_FUNCTIONS */
name|printf_to_message_buffer
argument_list|(
literal|"%s"
argument_list|,
name|replace_in_documentation
argument_list|(
name|_
argument_list|(
literal|"--- Use `\\[history-node]' or `\\[kill-node]' to exit ---\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|message_buffer_to_node
argument_list|()
expr_stmt|;
name|internal_info_help_node_contents
operator|=
name|node
operator|->
name|contents
expr_stmt|;
block|}
else|else
block|{
comment|/* We already had the right contents, so simply use them. */
name|node
operator|=
name|build_message_node
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
operator|->
name|contents
argument_list|)
expr_stmt|;
name|node
operator|->
name|contents
operator|=
name|contents
expr_stmt|;
name|node
operator|->
name|nodelen
operator|=
literal|1
operator|+
name|strlen
argument_list|(
name|contents
argument_list|)
expr_stmt|;
block|}
name|internal_info_help_node
operator|=
name|node
expr_stmt|;
comment|/* Do not GC this node's contents.  It never changes, and we never need      to delete it once it is made.  If you change some things (such as      placing information about dynamic variables in the help text) then      you will need to allow the contents to be gc'd, and you will have to      arrange to always regenerate the help node. */
if|#
directive|if
name|defined
argument_list|(
name|HELP_NODE_GETS_REGENERATED
argument_list|)
name|add_gcable_pointer
argument_list|(
name|internal_info_help_node
operator|->
name|contents
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|name_internal_node
argument_list|(
name|internal_info_help_node
argument_list|,
name|info_help_nodename
argument_list|)
expr_stmt|;
comment|/* Even though this is an internal node, we don't want the window      system to treat it specially.  So we turn off the internalness      of it here. */
name|internal_info_help_node
operator|->
name|flags
operator|&=
operator|~
name|N_IsInternal
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a window which is the window showing help in this Info. */
end_comment

begin_comment
comment|/* If the eligible window's height is>= this, split it to make the help    window.  Otherwise display the help window in the current window.  */
end_comment

begin_define
define|#
directive|define
name|HELP_SPLIT_SIZE
value|24
end_define

begin_function
specifier|static
name|WINDOW
modifier|*
name|info_find_or_create_help_window
parameter_list|()
block|{
name|int
name|help_is_only_window_p
decl_stmt|;
name|WINDOW
modifier|*
name|eligible
init|=
name|NULL
decl_stmt|;
name|WINDOW
modifier|*
name|help_window
init|=
name|get_window_of_node
argument_list|(
name|internal_info_help_node
argument_list|)
decl_stmt|;
comment|/* If we couldn't find the help window, then make it. */
if|if
condition|(
operator|!
name|help_window
condition|)
block|{
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|int
name|max
init|=
literal|0
decl_stmt|;
for|for
control|(
name|window
operator|=
name|windows
init|;
name|window
condition|;
name|window
operator|=
name|window
operator|->
name|next
control|)
block|{
if|if
condition|(
name|window
operator|->
name|height
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|window
operator|->
name|height
expr_stmt|;
name|eligible
operator|=
name|window
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|eligible
condition|)
return|return
name|NULL
return|;
block|}
ifndef|#
directive|ifndef
name|HELP_NODE_GETS_REGENERATED
else|else
comment|/* help window is static, just return it.  */
return|return
name|help_window
return|;
endif|#
directive|endif
comment|/* not HELP_NODE_GETS_REGENERATED */
comment|/* Make sure that we have a node containing the help text.  The      argument is false if help will be the only window (so l must be used      to quit help), true if help will be one of several visible windows      (so CTRL-x 0 must be used to quit help).  */
name|help_is_only_window_p
operator|=
operator|(
name|help_window
operator|&&
operator|!
name|windows
operator|->
name|next
operator|||
operator|!
name|help_window
operator|&&
name|eligible
operator|->
name|height
operator|<
name|HELP_SPLIT_SIZE
operator|)
expr_stmt|;
name|create_internal_info_help_node
argument_list|(
name|help_is_only_window_p
argument_list|)
expr_stmt|;
comment|/* Either use the existing window to display the help node, or create      a new window if there was no existing help window. */
if|if
condition|(
operator|!
name|help_window
condition|)
block|{
comment|/* Split the largest window into 2 windows, and show the help text          in that window. */
if|if
condition|(
name|eligible
operator|->
name|height
operator|>=
name|HELP_SPLIT_SIZE
condition|)
block|{
name|active_window
operator|=
name|eligible
expr_stmt|;
name|help_window
operator|=
name|window_make_window
argument_list|(
name|internal_info_help_node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_remembered_pagetop_and_point
argument_list|(
name|active_window
argument_list|)
expr_stmt|;
name|window_set_node_of_window
argument_list|(
name|active_window
argument_list|,
name|internal_info_help_node
argument_list|)
expr_stmt|;
name|help_window
operator|=
name|active_window
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Case where help node always gets regenerated, and we have an          existing window in which to place the node. */
if|if
condition|(
name|active_window
operator|!=
name|help_window
condition|)
block|{
name|set_remembered_pagetop_and_point
argument_list|(
name|active_window
argument_list|)
expr_stmt|;
name|active_window
operator|=
name|help_window
expr_stmt|;
block|}
name|window_set_node_of_window
argument_list|(
name|active_window
argument_list|,
name|internal_info_help_node
argument_list|)
expr_stmt|;
block|}
name|remember_window_and_node
argument_list|(
name|help_window
argument_list|,
name|help_window
operator|->
name|node
argument_list|)
expr_stmt|;
return|return
name|help_window
return|;
block|}
end_function

begin_comment
comment|/* Create or move to the help window. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_get_help_window
argument_list|,
argument|_(
literal|"Display help message"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|WINDOW
modifier|*
name|help_window
decl_stmt|;
name|help_window
operator|=
name|info_find_or_create_help_window
argument_list|()
expr_stmt|;
if|if
condition|(
name|help_window
condition|)
block|{
name|active_window
operator|=
name|help_window
expr_stmt|;
name|active_window
operator|->
name|flags
operator||=
name|W_UpdateWindow
expr_stmt|;
block|}
else|else
block|{
name|info_error
argument_list|(
name|msg_cant_make_help
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Show the Info help node.  This means that the "info" file is installed    where it can easily be found on your system. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_get_info_help_node
argument_list|,
argument|_(
literal|"Visit Info node `(info)Help'"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|NODE
modifier|*
name|node
decl_stmt|;
name|char
modifier|*
name|nodename
decl_stmt|;
comment|/* If there is a window on the screen showing the node "(info)Help" or      the node "(info)Help-Small-Screen", simply select that window. */
block|{
name|WINDOW
modifier|*
name|win
decl_stmt|;
for|for
control|(
name|win
operator|=
name|windows
init|;
name|win
condition|;
name|win
operator|=
name|win
operator|->
name|next
control|)
block|{
if|if
condition|(
name|win
operator|->
name|node
operator|&&
name|win
operator|->
name|node
operator|->
name|filename
operator|&&
operator|(
name|strcasecmp
argument_list|(
name|filename_non_directory
argument_list|(
name|win
operator|->
name|node
operator|->
name|filename
argument_list|)
argument_list|,
literal|"info"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|strcmp
argument_list|(
name|win
operator|->
name|node
operator|->
name|nodename
argument_list|,
literal|"Help"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|win
operator|->
name|node
operator|->
name|nodename
argument_list|,
literal|"Help-Small-Screen"
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|active_window
operator|=
name|win
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* If the current window is small, show the small screen help. */
if|if
condition|(
name|active_window
operator|->
name|height
operator|<
literal|24
condition|)
name|nodename
operator|=
literal|"Help-Small-Screen"
expr_stmt|;
else|else
name|nodename
operator|=
literal|"Help"
expr_stmt|;
comment|/* Try to get the info file for Info. */
name|node
operator|=
name|info_get_node
argument_list|(
literal|"Info"
argument_list|,
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
block|{
if|if
condition|(
name|info_recent_file_error
condition|)
name|info_error
argument_list|(
name|info_recent_file_error
argument_list|)
expr_stmt|;
else|else
name|info_error
argument_list|(
name|msg_cant_file_node
argument_list|,
literal|"Info"
argument_list|,
name|nodename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the current window is very large (greater than 45 lines),          then split it and show the help node in another window.          Otherwise, use the current window. */
if|if
condition|(
name|active_window
operator|->
name|height
operator|>
literal|45
condition|)
name|active_window
operator|=
name|window_make_window
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
block|{
name|set_remembered_pagetop_and_point
argument_list|(
name|active_window
argument_list|)
expr_stmt|;
name|window_set_node_of_window
argument_list|(
name|active_window
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
name|remember_window_and_node
argument_list|(
name|active_window
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/*                   Groveling Info Keymaps and Docs                */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Return the documentation associated with the Info command FUNCTION. */
end_comment

begin_function
name|char
modifier|*
name|function_documentation
parameter_list|(
name|function
parameter_list|)
name|VFunction
modifier|*
name|function
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|function_doc_array
index|[
name|i
index|]
operator|.
name|func
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|function
operator|==
name|function_doc_array
index|[
name|i
index|]
operator|.
name|func
condition|)
break|break;
return|return
name|replace_in_documentation
argument_list|(
operator|(
name|strlen
argument_list|(
name|function_doc_array
index|[
name|i
index|]
operator|.
name|doc
argument_list|)
operator|==
literal|0
operator|)
condition|?
name|function_doc_array
index|[
name|i
index|]
operator|.
name|doc
else|:
name|_
argument_list|(
name|function_doc_array
index|[
name|i
index|]
operator|.
name|doc
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NAMED_FUNCTIONS
argument_list|)
end_if

begin_comment
comment|/* Return the user-visible name of the function associated with the    Info command FUNCTION. */
end_comment

begin_function
name|char
modifier|*
name|function_name
parameter_list|(
name|function
parameter_list|)
name|VFunction
modifier|*
name|function
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|function_doc_array
index|[
name|i
index|]
operator|.
name|func
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|function
operator|==
name|function_doc_array
index|[
name|i
index|]
operator|.
name|func
condition|)
break|break;
return|return
operator|(
name|function_doc_array
index|[
name|i
index|]
operator|.
name|func_name
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the function named NAME. */
end_comment

begin_function
name|VFunction
modifier|*
name|named_function
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|function_doc_array
index|[
name|i
index|]
operator|.
name|func
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|function_doc_array
index|[
name|i
index|]
operator|.
name|func_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
return|return
operator|(
name|function_doc_array
index|[
name|i
index|]
operator|.
name|func
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAMED_FUNCTIONS */
end_comment

begin_comment
comment|/* Return the documentation associated with KEY in MAP. */
end_comment

begin_function
name|char
modifier|*
name|key_documentation
parameter_list|(
name|key
parameter_list|,
name|map
parameter_list|)
name|char
name|key
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
block|{
name|VFunction
modifier|*
name|function
init|=
name|map
index|[
name|key
index|]
operator|.
name|function
decl_stmt|;
if|if
condition|(
name|function
condition|)
return|return
operator|(
name|function_documentation
argument_list|(
name|function
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|describe_key
argument_list|,
argument|_(
literal|"Print documentation for KEY"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|char
name|keyname
index|[
literal|50
index|]
decl_stmt|;
name|int
name|keyname_index
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|keystroke
decl_stmt|;
name|char
modifier|*
name|rep
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
name|keyname
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|map
operator|=
name|window
operator|->
name|keymap
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|message_in_echo_area
argument_list|(
name|_
argument_list|(
literal|"Describe key: %s"
argument_list|)
argument_list|,
name|keyname
argument_list|)
expr_stmt|;
name|keystroke
operator|=
name|info_get_input_char
argument_list|()
expr_stmt|;
name|unmessage_in_echo_area
argument_list|()
expr_stmt|;
if|if
condition|(
name|Meta_p
argument_list|(
name|keystroke
argument_list|)
condition|)
block|{
if|if
condition|(
name|map
index|[
name|ESC
index|]
operator|.
name|type
operator|!=
name|ISKMAP
condition|)
block|{
name|window_message_in_echo_area
argument_list|(
name|_
argument_list|(
literal|"ESC %s is undefined."
argument_list|)
argument_list|,
name|pretty_keyname
argument_list|(
name|UnMeta
argument_list|(
name|keystroke
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|strcpy
argument_list|(
name|keyname
operator|+
name|keyname_index
argument_list|,
literal|"ESC "
argument_list|)
expr_stmt|;
name|keyname_index
operator|=
name|strlen
argument_list|(
name|keyname
argument_list|)
expr_stmt|;
name|keystroke
operator|=
name|UnMeta
argument_list|(
name|keystroke
argument_list|)
expr_stmt|;
name|map
operator|=
operator|(
name|Keymap
operator|)
name|map
index|[
name|ESC
index|]
operator|.
name|function
expr_stmt|;
block|}
comment|/* Add the printed representation of KEYSTROKE to our keyname. */
name|rep
operator|=
name|pretty_keyname
argument_list|(
name|keystroke
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|keyname
operator|+
name|keyname_index
argument_list|,
name|rep
argument_list|)
expr_stmt|;
name|keyname_index
operator|=
name|strlen
argument_list|(
name|keyname
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
index|[
name|keystroke
index|]
operator|.
name|function
operator|==
operator|(
name|VFunction
operator|*
operator|)
name|NULL
condition|)
block|{
name|message_in_echo_area
argument_list|(
name|_
argument_list|(
literal|"%s is undefined."
argument_list|)
argument_list|,
name|keyname
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|map
index|[
name|keystroke
index|]
operator|.
name|type
operator|==
name|ISKMAP
condition|)
block|{
name|map
operator|=
operator|(
name|Keymap
operator|)
name|map
index|[
name|keystroke
index|]
operator|.
name|function
expr_stmt|;
name|strcat
argument_list|(
name|keyname
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|keyname_index
operator|=
name|strlen
argument_list|(
name|keyname
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|char
modifier|*
name|message
decl_stmt|,
modifier|*
name|fundoc
decl_stmt|,
modifier|*
name|funname
init|=
literal|""
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NAMED_FUNCTIONS
argument_list|)
name|funname
operator|=
name|function_name
argument_list|(
name|map
index|[
name|keystroke
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NAMED_FUNCTIONS */
name|fundoc
operator|=
name|function_documentation
argument_list|(
name|map
index|[
name|keystroke
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
name|message
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|10
operator|+
name|strlen
argument_list|(
name|keyname
argument_list|)
operator|+
name|strlen
argument_list|(
name|fundoc
argument_list|)
operator|+
name|strlen
argument_list|(
name|funname
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NAMED_FUNCTIONS
argument_list|)
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"%s (%s): %s."
argument_list|,
name|keyname
argument_list|,
name|funname
argument_list|,
name|fundoc
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|message
argument_list|,
name|_
argument_list|(
literal|"%s is defined to %s."
argument_list|)
argument_list|,
name|keyname
argument_list|,
name|fundoc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !NAMED_FUNCTIONS */
name|window_message_in_echo_area
argument_list|(
literal|"%s"
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|message
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_comment
comment|/* How to get the pretty printable name of a character. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rep_buffer
index|[
literal|30
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|pretty_keyname
parameter_list|(
name|key
parameter_list|)
name|unsigned
name|char
name|key
decl_stmt|;
block|{
name|char
modifier|*
name|rep
decl_stmt|;
if|if
condition|(
name|Meta_p
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|char
name|temp
index|[
literal|20
index|]
decl_stmt|;
name|rep
operator|=
name|pretty_keyname
argument_list|(
name|UnMeta
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"ESC %s"
argument_list|,
name|rep
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|rep_buffer
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|rep
operator|=
name|rep_buffer
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Control_p
argument_list|(
name|key
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|'\n'
case|:
name|rep
operator|=
literal|"LFD"
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|rep
operator|=
literal|"TAB"
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|rep
operator|=
literal|"RET"
expr_stmt|;
break|break;
case|case
name|ESC
case|:
name|rep
operator|=
literal|"ESC"
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|rep_buffer
argument_list|,
literal|"C-%c"
argument_list|,
name|UnControl
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|=
name|rep_buffer
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|' '
case|:
name|rep
operator|=
literal|"SPC"
expr_stmt|;
break|break;
case|case
name|DEL
case|:
name|rep
operator|=
literal|"DEL"
expr_stmt|;
break|break;
default|default:
name|rep_buffer
index|[
literal|0
index|]
operator|=
name|key
expr_stmt|;
name|rep_buffer
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rep
operator|=
name|rep_buffer
expr_stmt|;
block|}
block|}
return|return
operator|(
name|rep
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Replace the names of functions with the key that invokes them. */
end_comment

begin_function
name|char
modifier|*
name|replace_in_documentation
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|start
decl_stmt|,
name|next
decl_stmt|;
specifier|static
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|maybe_free
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|next
operator|=
name|start
operator|=
literal|0
expr_stmt|;
comment|/* Skip to the beginning of a replaceable function. */
for|for
control|(
name|i
operator|=
name|start
init|;
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
comment|/* Is this the start of a replaceable function name? */
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'\\'
operator|&&
name|string
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'['
condition|)
block|{
name|char
modifier|*
name|fun_name
decl_stmt|,
modifier|*
name|rep
decl_stmt|;
name|VFunction
modifier|*
name|function
decl_stmt|;
comment|/* Copy in the old text. */
name|strncpy
argument_list|(
name|result
operator|+
name|next
argument_list|,
name|string
operator|+
name|start
argument_list|,
name|i
operator|-
name|start
argument_list|)
expr_stmt|;
name|next
operator|+=
operator|(
name|i
operator|-
name|start
operator|)
expr_stmt|;
name|start
operator|=
name|i
operator|+
literal|2
expr_stmt|;
comment|/* Move to the end of the function name. */
for|for
control|(
name|i
operator|=
name|start
init|;
name|string
index|[
name|i
index|]
operator|&&
operator|(
name|string
index|[
name|i
index|]
operator|!=
literal|']'
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|fun_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|i
operator|-
name|start
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|fun_name
argument_list|,
name|string
operator|+
name|start
argument_list|,
name|i
operator|-
name|start
argument_list|)
expr_stmt|;
name|fun_name
index|[
name|i
operator|-
name|start
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Find a key which invokes this function in the info_keymap. */
name|function
operator|=
name|named_function
argument_list|(
name|fun_name
argument_list|)
expr_stmt|;
comment|/* If the internal documentation string fails, there is a              serious problem with the associated command's documentation.              We croak so that it can be fixed immediately. */
if|if
condition|(
operator|!
name|function
condition|)
name|abort
argument_list|()
expr_stmt|;
name|rep
operator|=
name|where_is
argument_list|(
name|info_keymap
argument_list|,
name|function
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|next
argument_list|,
name|rep
argument_list|)
expr_stmt|;
name|next
operator|=
name|strlen
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|start
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|string
index|[
name|i
index|]
condition|)
name|start
operator|++
expr_stmt|;
block|}
block|}
name|strcpy
argument_list|(
name|result
operator|+
name|next
argument_list|,
name|string
operator|+
name|start
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a string of characters which could be typed from the keymap    MAP to invoke FUNCTION. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|where_is_rep
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|where_is_rep_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|where_is_rep_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|where_is
parameter_list|(
name|map
parameter_list|,
name|function
parameter_list|)
name|Keymap
name|map
decl_stmt|;
name|VFunction
modifier|*
name|function
decl_stmt|;
block|{
name|char
modifier|*
name|rep
decl_stmt|;
if|if
condition|(
operator|!
name|where_is_rep_size
condition|)
name|where_is_rep
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|where_is_rep_size
operator|=
literal|100
argument_list|)
expr_stmt|;
name|where_is_rep_index
operator|=
literal|0
expr_stmt|;
name|rep
operator|=
name|where_is_internal
argument_list|(
name|map
argument_list|,
name|function
argument_list|)
expr_stmt|;
comment|/* If it couldn't be found, return "M-x Foo". */
if|if
condition|(
operator|!
name|rep
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|function_name
argument_list|(
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|sprintf
argument_list|(
name|where_is_rep
argument_list|,
literal|"M-x %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rep
operator|=
name|where_is_rep
expr_stmt|;
block|}
return|return
operator|(
name|rep
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the printed rep of FUNCTION as found in MAP, or NULL. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|where_is_internal
parameter_list|(
name|map
parameter_list|,
name|function
parameter_list|)
name|Keymap
name|map
decl_stmt|;
name|VFunction
modifier|*
name|function
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* If the function is directly invokable in MAP, return the representation      of that keystroke. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|map
index|[
name|i
index|]
operator|.
name|type
operator|==
name|ISFUNC
operator|)
operator|&&
name|map
index|[
name|i
index|]
operator|.
name|function
operator|==
name|function
condition|)
block|{
name|sprintf
argument_list|(
name|where_is_rep
operator|+
name|where_is_rep_index
argument_list|,
literal|"%s"
argument_list|,
name|pretty_keyname
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|where_is_rep
operator|)
return|;
block|}
comment|/* Okay, search subsequent maps for this function. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|map
index|[
name|i
index|]
operator|.
name|type
operator|==
name|ISKMAP
condition|)
block|{
name|int
name|saved_index
init|=
name|where_is_rep_index
decl_stmt|;
name|char
modifier|*
name|rep
decl_stmt|;
name|sprintf
argument_list|(
name|where_is_rep
operator|+
name|where_is_rep_index
argument_list|,
literal|"%s "
argument_list|,
name|pretty_keyname
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|where_is_rep_index
operator|=
name|strlen
argument_list|(
name|where_is_rep
argument_list|)
expr_stmt|;
name|rep
operator|=
name|where_is_internal
argument_list|(
operator|(
name|Keymap
operator|)
name|map
index|[
name|i
index|]
operator|.
name|function
argument_list|,
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
condition|)
return|return
operator|(
name|where_is_rep
operator|)
return|;
name|where_is_rep_index
operator|=
name|saved_index
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function_decl
specifier|extern
name|char
modifier|*
name|read_function_name
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_where_is
argument_list|,
argument|_(
literal|"Show what to type to execute a given command"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|command_name
decl_stmt|;
name|command_name
operator|=
name|read_function_name
argument_list|(
name|_
argument_list|(
literal|"Where is command: "
argument_list|)
argument_list|,
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|command_name
condition|)
block|{
name|info_abort_key
argument_list|(
name|active_window
argument_list|,
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|command_name
condition|)
block|{
name|VFunction
modifier|*
name|function
decl_stmt|;
name|function
operator|=
name|named_function
argument_list|(
name|command_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|function
condition|)
block|{
name|char
modifier|*
name|location
decl_stmt|;
name|location
operator|=
name|where_is
argument_list|(
name|active_window
operator|->
name|keymap
argument_list|,
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|location
condition|)
block|{
name|info_error
argument_list|(
name|_
argument_list|(
literal|"`%s' is not on any keys"
argument_list|)
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|location
argument_list|,
literal|"M-x "
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|window_message_in_echo_area
argument_list|(
name|_
argument_list|(
literal|"%s can only be invoked via %s."
argument_list|)
argument_list|,
name|command_name
argument_list|,
name|location
argument_list|)
expr_stmt|;
else|else
name|window_message_in_echo_area
argument_list|(
name|_
argument_list|(
literal|"%s can be invoked via %s."
argument_list|)
argument_list|,
name|command_name
argument_list|,
name|location
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|info_error
argument_list|(
name|_
argument_list|(
literal|"There is no function named `%s'"
argument_list|)
argument_list|,
name|command_name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|command_name
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

