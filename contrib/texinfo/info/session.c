begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* session.c -- user windowing interface to Info.    $Id: session.c,v 1.45 2002/03/02 15:05:04 karl Exp $     Copyright (C) 1993, 96, 97, 98, 99, 2000, 01, 02    Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Written by Brian Fox (bfox@ai.mit.edu). */
end_comment

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_TIME_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_define
define|#
directive|define
name|HAVE_STRUCT_TIMEVAL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_TIME_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MAN_PAGES
argument_list|)
end_if

begin_include
include|#
directive|include
file|"man.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|M_XENIX
end_ifdef

begin_comment
comment|/* SCO 3.2v5.0.2 defines but does not correctly declare strncasecmp.    Since we use it as a symbol, have to get it right.  --gildea, 1jul99.  */
end_comment

begin_function_decl
specifier|extern
name|int
name|strncasecmp
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|info_clear_pending_input
argument_list|()
decl_stmt|,
name|info_set_pending_input
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|info_handle_pointer
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/*                   Running an Info Session                        */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* The place that we are reading input from. */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|info_input_stream
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last executed command. */
end_comment

begin_decl_stmt
name|VFunction
modifier|*
name|info_last_executed_command
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Becomes non-zero when 'q' is typed to an Info window. */
end_comment

begin_decl_stmt
name|int
name|quit_info_immediately
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of structures describing for each window which nodes have been    visited in that window. */
end_comment

begin_decl_stmt
name|INFO_WINDOW
modifier|*
modifier|*
name|info_windows
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where to add the next window, if we need to add one. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|info_windows_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of slots allocated to `info_windows'. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|info_windows_slots
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|remember_window_and_node
argument_list|()
decl_stmt|,
name|forget_window_and_nodes
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|initialize_info_session
argument_list|()
decl_stmt|,
name|info_session
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|display_startup_message_and_start
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Begin an info session finding the nodes specified by FILENAME and NODENAMES.    For each loaded node, create a new window.  Always split the largest of the    available windows. */
end_comment

begin_function
name|void
name|begin_multiple_window_info_session
parameter_list|(
name|filename
parameter_list|,
name|nodenames
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
modifier|*
name|nodenames
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|WINDOW
modifier|*
name|window
init|=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|nodenames
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|NODE
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|info_get_node
argument_list|(
name|filename
argument_list|,
name|nodenames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
break|break;
comment|/* If this is the first node, initialize the info session. */
if|if
condition|(
operator|!
name|window
condition|)
block|{
name|initialize_info_session
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|window
operator|=
name|active_window
expr_stmt|;
block|}
else|else
block|{
comment|/* Find the largest window in WINDOWS, and make that be the active              one.  Then split it and add our window and node to the list              of remembered windows and nodes.  Then tile the windows. */
name|WINDOW
modifier|*
name|win
decl_stmt|,
modifier|*
name|largest
init|=
name|NULL
decl_stmt|;
name|int
name|max_height
init|=
literal|0
decl_stmt|;
for|for
control|(
name|win
operator|=
name|windows
init|;
name|win
condition|;
name|win
operator|=
name|win
operator|->
name|next
control|)
if|if
condition|(
name|win
operator|->
name|height
operator|>
name|max_height
condition|)
block|{
name|max_height
operator|=
name|win
operator|->
name|height
expr_stmt|;
name|largest
operator|=
name|win
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|largest
condition|)
block|{
name|display_update_display
argument_list|(
name|windows
argument_list|)
expr_stmt|;
name|info_error
argument_list|(
name|msg_cant_find_window
argument_list|)
expr_stmt|;
name|info_session
argument_list|()
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|active_window
operator|=
name|largest
expr_stmt|;
name|window
operator|=
name|window_make_window
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|window
condition|)
block|{
name|window_tile_windows
argument_list|(
name|TILE_INTERNALS
argument_list|)
expr_stmt|;
name|remember_window_and_node
argument_list|(
name|window
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|display_update_display
argument_list|(
name|windows
argument_list|)
expr_stmt|;
name|info_error
argument_list|(
name|msg_win_too_small
argument_list|)
expr_stmt|;
name|info_session
argument_list|()
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|display_startup_message_and_start
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start an info session with INITIAL_NODE, and an error message in the echo    area made from FORMAT and ARG. */
end_comment

begin_function
name|void
name|begin_info_session_with_error
parameter_list|(
name|initial_node
parameter_list|,
name|format
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|NODE
modifier|*
name|initial_node
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|void
modifier|*
name|arg1
decl_stmt|;
name|void
modifier|*
name|arg2
decl_stmt|;
block|{
name|initialize_info_session
argument_list|(
name|initial_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|info_error
argument_list|(
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|info_session
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start an info session with INITIAL_NODE. */
end_comment

begin_function
name|void
name|begin_info_session
parameter_list|(
name|initial_node
parameter_list|)
name|NODE
modifier|*
name|initial_node
decl_stmt|;
block|{
name|initialize_info_session
argument_list|(
name|initial_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|display_startup_message_and_start
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|display_startup_message_and_start
parameter_list|()
block|{
name|char
modifier|*
name|format
decl_stmt|;
name|format
operator|=
name|replace_in_documentation
argument_list|(
name|_
argument_list|(
literal|"Welcome to Info version %s. Type \\[get-help-window] for help, \\[menu-item] for menu item."
argument_list|)
argument_list|)
expr_stmt|;
name|window_message_in_echo_area
argument_list|(
name|format
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
name|info_session
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Run an info session with an already initialized window and node. */
end_comment

begin_function
name|void
name|info_session
parameter_list|()
block|{
name|display_update_display
argument_list|(
name|windows
argument_list|)
expr_stmt|;
name|info_last_executed_command
operator|=
name|NULL
expr_stmt|;
name|info_read_and_dispatch
argument_list|()
expr_stmt|;
comment|/* On program exit, leave the cursor at the bottom of the window, and      restore the terminal I/O. */
name|terminal_goto_xy
argument_list|(
literal|0
argument_list|,
name|screenheight
operator|-
literal|1
argument_list|)
expr_stmt|;
name|terminal_clear_to_eol
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|terminal_unprep_terminal
argument_list|()
expr_stmt|;
name|close_dribble_file
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Here is a window-location dependent event loop.  Called from the    functions info_session (), and from read_xxx_in_echo_area (). */
end_comment

begin_function
name|void
name|info_read_and_dispatch
parameter_list|()
block|{
name|unsigned
name|char
name|key
decl_stmt|;
name|int
name|done
decl_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
operator|!
name|quit_info_immediately
condition|)
block|{
name|int
name|lk
decl_stmt|;
comment|/* If we haven't just gone up or down a line, there is no          goal column for this window. */
if|if
condition|(
operator|(
name|info_last_executed_command
operator|!=
name|info_next_line
operator|)
operator|&&
operator|(
name|info_last_executed_command
operator|!=
name|info_prev_line
operator|)
condition|)
name|active_window
operator|->
name|goal_column
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|echo_area_is_active
condition|)
block|{
name|lk
operator|=
name|echo_area_last_command_was_kill
expr_stmt|;
name|echo_area_prep_read
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|info_any_buffered_input_p
argument_list|()
condition|)
name|display_update_display
argument_list|(
name|windows
argument_list|)
expr_stmt|;
name|display_cursor_at_point
argument_list|(
name|active_window
argument_list|)
expr_stmt|;
name|info_initialize_numeric_arg
argument_list|()
expr_stmt|;
name|initialize_keyseq
argument_list|()
expr_stmt|;
name|key
operator|=
name|info_get_input_char
argument_list|()
expr_stmt|;
comment|/* No errors yet.  We just read a character, that's all.  Only clear          the echo_area if it is not currently active. */
if|if
condition|(
operator|!
name|echo_area_is_active
condition|)
name|window_clear_echo_area
argument_list|()
expr_stmt|;
name|info_error_was_printed
operator|=
literal|0
expr_stmt|;
comment|/* Do the selected command. */
name|info_dispatch_on_key
argument_list|(
name|key
argument_list|,
name|active_window
operator|->
name|keymap
argument_list|)
expr_stmt|;
if|if
condition|(
name|echo_area_is_active
condition|)
block|{
comment|/* Echo area commands that do killing increment the value of              ECHO_AREA_LAST_COMMAND_WAS_KILL.  Thus, if there is no              change in the value of this variable, the last command              executed was not a kill command. */
if|if
condition|(
name|lk
operator|==
name|echo_area_last_command_was_kill
condition|)
name|echo_area_last_command_was_kill
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ea_last_executed_command
operator|==
name|ea_newline
operator|||
name|info_aborted_echo_area
condition|)
block|{
name|ea_last_executed_command
operator|=
operator|(
name|VFunction
operator|*
operator|)
name|NULL
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|info_last_executed_command
operator|==
name|info_quit
condition|)
name|quit_info_immediately
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info_last_executed_command
operator|==
name|info_quit
condition|)
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Found in signals.c */
end_comment

begin_function_decl
specifier|extern
name|void
name|initialize_info_signal_handler
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Initialize the first info session by starting the terminal, window,    and display systems.  If CLEAR_SCREEN is 0, don't clear the screen.  */
end_comment

begin_function
name|void
name|initialize_info_session
parameter_list|(
name|node
parameter_list|,
name|clear_screen
parameter_list|)
name|NODE
modifier|*
name|node
decl_stmt|;
name|int
name|clear_screen
decl_stmt|;
block|{
name|char
modifier|*
name|term_name
init|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
decl_stmt|;
name|terminal_initialize_terminal
argument_list|(
name|term_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|terminal_is_dumb_p
condition|)
block|{
if|if
condition|(
operator|!
name|term_name
condition|)
name|term_name
operator|=
literal|"dumb"
expr_stmt|;
name|info_error
argument_list|(
name|msg_term_too_dumb
argument_list|,
name|term_name
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|clear_screen
condition|)
block|{
name|terminal_prep_terminal
argument_list|()
expr_stmt|;
name|terminal_clear_screen
argument_list|()
expr_stmt|;
block|}
name|initialize_info_keymaps
argument_list|()
expr_stmt|;
name|window_initialize_windows
argument_list|(
name|screenwidth
argument_list|,
name|screenheight
argument_list|)
expr_stmt|;
name|initialize_info_signal_handler
argument_list|()
expr_stmt|;
name|display_initialize_display
argument_list|(
name|screenwidth
argument_list|,
name|screenheight
argument_list|)
expr_stmt|;
name|info_set_node_of_window
argument_list|(
literal|0
argument_list|,
name|active_window
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|/* Tell the window system how to notify us when a window needs to be      asynchronously deleted (e.g., user resizes window very small). */
name|window_deletion_notifier
operator|=
name|forget_window_and_nodes
expr_stmt|;
comment|/* If input has not been redirected yet, make it come from unbuffered      standard input. */
if|if
condition|(
operator|!
name|info_input_stream
condition|)
block|{
name|setbuf
argument_list|(
name|stdin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|info_input_stream
operator|=
name|stdin
expr_stmt|;
block|}
name|info_windows_initialized_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell Info that input is coming from the file FILENAME. */
end_comment

begin_function
name|void
name|info_set_input_from_file
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|FILE
modifier|*
name|stream
decl_stmt|;
comment|/* Input may include binary characters.  */
name|stream
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
name|FOPEN_RBIN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stream
condition|)
return|return;
if|if
condition|(
operator|(
name|info_input_stream
operator|!=
operator|(
name|FILE
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|info_input_stream
operator|!=
name|stdin
operator|)
condition|)
name|fclose
argument_list|(
name|info_input_stream
argument_list|)
expr_stmt|;
name|info_input_stream
operator|=
name|stream
expr_stmt|;
if|if
condition|(
name|stream
operator|!=
name|stdin
condition|)
name|display_inhibited
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the INFO_WINDOW containing WINDOW, or NULL if there isn't one. */
end_comment

begin_function
specifier|static
name|INFO_WINDOW
modifier|*
name|get_info_window_of_window
parameter_list|(
name|window
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|INFO_WINDOW
modifier|*
name|info_win
init|=
operator|(
name|INFO_WINDOW
operator|*
operator|)
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|info_windows
operator|&&
operator|(
name|info_win
operator|=
name|info_windows
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|info_win
operator|->
name|window
operator|==
name|window
condition|)
break|break;
return|return
operator|(
name|info_win
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Reset the remembered pagetop and point of WINDOW to WINDOW's current    values if the window and node are the same as the current one being    displayed. */
end_comment

begin_function
name|void
name|set_remembered_pagetop_and_point
parameter_list|(
name|window
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
block|{
name|INFO_WINDOW
modifier|*
name|info_win
decl_stmt|;
name|info_win
operator|=
name|get_info_window_of_window
argument_list|(
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info_win
condition|)
return|return;
if|if
condition|(
name|info_win
operator|->
name|nodes_index
operator|&&
operator|(
name|info_win
operator|->
name|nodes
index|[
name|info_win
operator|->
name|current
index|]
operator|==
name|window
operator|->
name|node
operator|)
condition|)
block|{
name|info_win
operator|->
name|pagetops
index|[
name|info_win
operator|->
name|current
index|]
operator|=
name|window
operator|->
name|pagetop
expr_stmt|;
name|info_win
operator|->
name|points
index|[
name|info_win
operator|->
name|current
index|]
operator|=
name|window
operator|->
name|point
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|remember_window_and_node
parameter_list|(
name|window
parameter_list|,
name|node
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|NODE
modifier|*
name|node
decl_stmt|;
block|{
comment|/* See if we already have this window in our list. */
name|INFO_WINDOW
modifier|*
name|info_win
init|=
name|get_info_window_of_window
argument_list|(
name|window
argument_list|)
decl_stmt|;
comment|/* If the window wasn't already on our list, then make a new entry. */
if|if
condition|(
operator|!
name|info_win
condition|)
block|{
name|info_win
operator|=
operator|(
name|INFO_WINDOW
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|INFO_WINDOW
argument_list|)
argument_list|)
expr_stmt|;
name|info_win
operator|->
name|window
operator|=
name|window
expr_stmt|;
name|info_win
operator|->
name|nodes
operator|=
operator|(
name|NODE
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
name|info_win
operator|->
name|pagetops
operator|=
operator|(
name|int
operator|*
operator|)
name|NULL
expr_stmt|;
name|info_win
operator|->
name|points
operator|=
operator|(
name|long
operator|*
operator|)
name|NULL
expr_stmt|;
name|info_win
operator|->
name|current
operator|=
literal|0
expr_stmt|;
name|info_win
operator|->
name|nodes_index
operator|=
literal|0
expr_stmt|;
name|info_win
operator|->
name|nodes_slots
operator|=
literal|0
expr_stmt|;
name|add_pointer_to_array
argument_list|(
name|info_win
argument_list|,
name|info_windows_index
argument_list|,
name|info_windows
argument_list|,
name|info_windows_slots
argument_list|,
literal|10
argument_list|,
name|INFO_WINDOW
operator|*
argument_list|)
expr_stmt|;
block|}
comment|/* If this node, the current pagetop, and the current point are the      same as the current saved node and pagetop, don't really add this to      the list of history nodes.  This may happen only at the very      beginning of the program, I'm not sure.  --karl  */
if|if
condition|(
name|info_win
operator|->
name|nodes
operator|&&
name|info_win
operator|->
name|current
operator|>=
literal|0
operator|&&
name|info_win
operator|->
name|nodes
index|[
name|info_win
operator|->
name|current
index|]
operator|->
name|contents
operator|==
name|node
operator|->
name|contents
operator|&&
name|info_win
operator|->
name|pagetops
index|[
name|info_win
operator|->
name|current
index|]
operator|==
name|window
operator|->
name|pagetop
operator|&&
name|info_win
operator|->
name|points
index|[
name|info_win
operator|->
name|current
index|]
operator|==
name|window
operator|->
name|point
condition|)
return|return;
comment|/* Remember this node, the currently displayed pagetop, and the current      location of point in this window.  Because we are updating pagetops      and points as well as nodes, it is more efficient to avoid the      add_pointer_to_array macro here. */
if|if
condition|(
name|info_win
operator|->
name|nodes_index
operator|+
literal|2
operator|>=
name|info_win
operator|->
name|nodes_slots
condition|)
block|{
name|info_win
operator|->
name|nodes_slots
operator|+=
literal|20
expr_stmt|;
name|info_win
operator|->
name|nodes
operator|=
operator|(
name|NODE
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|info_win
operator|->
name|nodes
argument_list|,
name|info_win
operator|->
name|nodes_slots
operator|*
sizeof|sizeof
argument_list|(
name|NODE
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|info_win
operator|->
name|pagetops
operator|=
operator|(
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
name|info_win
operator|->
name|pagetops
argument_list|,
name|info_win
operator|->
name|nodes_slots
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|info_win
operator|->
name|points
operator|=
operator|(
name|long
operator|*
operator|)
name|xrealloc
argument_list|(
name|info_win
operator|->
name|points
argument_list|,
name|info_win
operator|->
name|nodes_slots
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|info_win
operator|->
name|nodes
index|[
name|info_win
operator|->
name|nodes_index
index|]
operator|=
name|node
expr_stmt|;
name|info_win
operator|->
name|pagetops
index|[
name|info_win
operator|->
name|nodes_index
index|]
operator|=
name|window
operator|->
name|pagetop
expr_stmt|;
name|info_win
operator|->
name|points
index|[
name|info_win
operator|->
name|nodes_index
index|]
operator|=
name|window
operator|->
name|point
expr_stmt|;
name|info_win
operator|->
name|current
operator|=
name|info_win
operator|->
name|nodes_index
operator|++
expr_stmt|;
name|info_win
operator|->
name|nodes
index|[
name|info_win
operator|->
name|nodes_index
index|]
operator|=
name|NULL
expr_stmt|;
name|info_win
operator|->
name|pagetops
index|[
name|info_win
operator|->
name|nodes_index
index|]
operator|=
literal|0
expr_stmt|;
name|info_win
operator|->
name|points
index|[
name|info_win
operator|->
name|nodes_index
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|DEBUG_FORGET_WINDOW_AND_NODES
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_FORGET_WINDOW_AND_NODES
argument_list|)
end_if

begin_function
specifier|static
name|void
name|consistency_check_info_windows
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info_windows_index
condition|;
name|i
operator|++
control|)
block|{
name|WINDOW
modifier|*
name|win
decl_stmt|;
for|for
control|(
name|win
operator|=
name|windows
init|;
name|win
condition|;
name|win
operator|=
name|win
operator|->
name|next
control|)
if|if
condition|(
name|win
operator|==
name|info_windows
index|[
name|i
index|]
operator|->
name|window
condition|)
break|break;
if|if
condition|(
operator|!
name|win
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG_FORGET_WINDOW_AND_NODES */
end_comment

begin_comment
comment|/* Remove WINDOW and its associated list of nodes from INFO_WINDOWS. */
end_comment

begin_function
name|void
name|forget_window_and_nodes
parameter_list|(
name|window
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|INFO_WINDOW
modifier|*
name|info_win
init|=
operator|(
name|INFO_WINDOW
operator|*
operator|)
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|info_windows
operator|&&
operator|(
name|info_win
operator|=
name|info_windows
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|info_win
operator|->
name|window
operator|==
name|window
condition|)
break|break;
comment|/* If we found the window to forget, then do so. */
if|if
condition|(
name|info_win
condition|)
block|{
while|while
condition|(
name|i
operator|<
name|info_windows_index
condition|)
block|{
name|info_windows
index|[
name|i
index|]
operator|=
name|info_windows
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|info_windows_index
operator|--
expr_stmt|;
name|info_windows
index|[
name|info_windows_index
index|]
operator|=
operator|(
name|INFO_WINDOW
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|info_win
operator|->
name|nodes
condition|)
block|{
comment|/* Free the node structures which held onto internal node contents              here.  This doesn't free the contents; we have a garbage collector              which does that. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|info_win
operator|->
name|nodes
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|internal_info_node_p
argument_list|(
name|info_win
operator|->
name|nodes
index|[
name|i
index|]
argument_list|)
condition|)
name|free
argument_list|(
name|info_win
operator|->
name|nodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info_win
operator|->
name|nodes
argument_list|)
expr_stmt|;
name|maybe_free
argument_list|(
name|info_win
operator|->
name|pagetops
argument_list|)
expr_stmt|;
name|maybe_free
argument_list|(
name|info_win
operator|->
name|points
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|info_win
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_FORGET_WINDOW_AND_NODES
argument_list|)
name|consistency_check_info_windows
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_FORGET_WINDOW_AND_NODES */
block|}
end_function

begin_comment
comment|/* Set WINDOW to show NODE.  Remember the new window in our list of Info    windows.  If we are doing automatic footnote display, also try to display    the footnotes for this window.  If REMEMBER is nonzero, first call    set_remembered_pagetop_and_point.  */
end_comment

begin_function
name|void
name|info_set_node_of_window
parameter_list|(
name|remember
parameter_list|,
name|window
parameter_list|,
name|node
parameter_list|)
name|int
name|remember
decl_stmt|;
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|NODE
modifier|*
name|node
decl_stmt|;
block|{
if|if
condition|(
name|remember
condition|)
name|set_remembered_pagetop_and_point
argument_list|(
name|window
argument_list|)
expr_stmt|;
comment|/* Put this node into the window. */
name|window_set_node_of_window
argument_list|(
name|window
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|/* Remember this node and window in our list of info windows. */
name|remember_window_and_node
argument_list|(
name|window
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|/* If doing auto-footnote display/undisplay, show the footnotes belonging      to this window's node. */
if|if
condition|(
name|auto_footnotes_p
condition|)
name|info_get_or_remove_footnotes
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/*                     Info Movement Commands                       */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Change the pagetop of WINDOW to DESIRED_TOP, perhaps scrolling the screen    to do so. */
end_comment

begin_function
name|void
name|set_window_pagetop
parameter_list|(
name|window
parameter_list|,
name|desired_top
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|int
name|desired_top
decl_stmt|;
block|{
name|int
name|point_line
decl_stmt|,
name|old_pagetop
decl_stmt|;
if|if
condition|(
name|desired_top
operator|<
literal|0
condition|)
name|desired_top
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|desired_top
operator|>
name|window
operator|->
name|line_count
condition|)
name|desired_top
operator|=
name|window
operator|->
name|line_count
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|window
operator|->
name|pagetop
operator|==
name|desired_top
condition|)
return|return;
name|old_pagetop
operator|=
name|window
operator|->
name|pagetop
expr_stmt|;
name|window
operator|->
name|pagetop
operator|=
name|desired_top
expr_stmt|;
comment|/* Make sure that point appears in this window. */
name|point_line
operator|=
name|window_line_of_point
argument_list|(
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|point_line
operator|<
name|window
operator|->
name|pagetop
operator|)
operator|||
operator|(
operator|(
name|point_line
operator|-
name|window
operator|->
name|pagetop
operator|)
operator|>
name|window
operator|->
name|height
operator|-
literal|1
operator|)
condition|)
name|window
operator|->
name|point
operator|=
name|window
operator|->
name|line_starts
index|[
name|window
operator|->
name|pagetop
index|]
operator|-
name|window
operator|->
name|node
operator|->
name|contents
expr_stmt|;
name|window
operator|->
name|flags
operator||=
name|W_UpdateWindow
expr_stmt|;
comment|/* Find out which direction to scroll, and scroll the window in that      direction.  Do this only if there would be a savings in redisplay      time.  This is true if the amount to scroll is less than the height      of the window, and if the number of lines scrolled would be greater      than 10 % of the window's height. */
if|if
condition|(
name|old_pagetop
operator|<
name|desired_top
condition|)
block|{
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|amount
decl_stmt|;
name|amount
operator|=
name|desired_top
operator|-
name|old_pagetop
expr_stmt|;
if|if
condition|(
operator|(
name|amount
operator|>=
name|window
operator|->
name|height
operator|)
operator|||
operator|(
operator|(
operator|(
name|window
operator|->
name|height
operator|-
name|amount
operator|)
operator|*
literal|10
operator|)
operator|<
name|window
operator|->
name|height
operator|)
condition|)
return|return;
name|start
operator|=
name|amount
operator|+
name|window
operator|->
name|first_row
expr_stmt|;
name|end
operator|=
name|window
operator|->
name|height
operator|+
name|window
operator|->
name|first_row
expr_stmt|;
name|display_scroll_display
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
operator|-
name|amount
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|amount
decl_stmt|;
name|amount
operator|=
name|old_pagetop
operator|-
name|desired_top
expr_stmt|;
if|if
condition|(
operator|(
name|amount
operator|>=
name|window
operator|->
name|height
operator|)
operator|||
operator|(
operator|(
operator|(
name|window
operator|->
name|height
operator|-
name|amount
operator|)
operator|*
literal|10
operator|)
operator|<
name|window
operator|->
name|height
operator|)
condition|)
return|return;
name|start
operator|=
name|window
operator|->
name|first_row
expr_stmt|;
name|end
operator|=
operator|(
name|window
operator|->
name|first_row
operator|+
name|window
operator|->
name|height
operator|)
operator|-
name|amount
expr_stmt|;
name|display_scroll_display
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|amount
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Immediately make WINDOW->point visible on the screen, and move the    terminal cursor there. */
end_comment

begin_function
specifier|static
name|void
name|info_show_point
parameter_list|(
name|window
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
block|{
name|int
name|old_pagetop
decl_stmt|;
name|old_pagetop
operator|=
name|window
operator|->
name|pagetop
expr_stmt|;
name|window_adjust_pagetop
argument_list|(
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_pagetop
operator|!=
name|window
operator|->
name|pagetop
condition|)
block|{
name|int
name|new_pagetop
decl_stmt|;
name|new_pagetop
operator|=
name|window
operator|->
name|pagetop
expr_stmt|;
name|window
operator|->
name|pagetop
operator|=
name|old_pagetop
expr_stmt|;
name|set_window_pagetop
argument_list|(
name|window
argument_list|,
name|new_pagetop
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|window
operator|->
name|flags
operator|&
name|W_UpdateWindow
condition|)
name|display_update_one_window
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|display_cursor_at_point
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move WINDOW->point from OLD line index to NEW line index. */
end_comment

begin_function
specifier|static
name|void
name|move_to_new_line
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|,
name|window
parameter_list|)
name|int
name|old
decl_stmt|,
name|new
decl_stmt|;
name|WINDOW
modifier|*
name|window
decl_stmt|;
block|{
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
block|{
name|info_error
argument_list|(
name|msg_cant_find_point
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|goal
decl_stmt|;
if|if
condition|(
name|new
operator|>=
name|window
operator|->
name|line_count
operator|||
name|new
operator|<
literal|0
condition|)
return|return;
name|goal
operator|=
name|window_get_goal_column
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|window
operator|->
name|goal_column
operator|=
name|goal
expr_stmt|;
name|window
operator|->
name|point
operator|=
name|window
operator|->
name|line_starts
index|[
name|new
index|]
operator|-
name|window
operator|->
name|node
operator|->
name|contents
expr_stmt|;
name|window
operator|->
name|point
operator|+=
name|window_chars_to_goal
argument_list|(
name|window
operator|->
name|line_starts
index|[
name|new
index|]
argument_list|,
name|goal
argument_list|)
expr_stmt|;
name|info_show_point
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Move WINDOW's point down to the next line if possible. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_next_line
argument_list|,
argument|_(
literal|"Move down to the next line"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|int
name|old_line
decl_stmt|,
name|new_line
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|info_prev_line
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
block|{
name|old_line
operator|=
name|window_line_of_point
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|new_line
operator|=
name|old_line
operator|+
name|count
expr_stmt|;
name|move_to_new_line
argument_list|(
name|old_line
argument_list|,
name|new_line
argument_list|,
name|window
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Move WINDOW's point up to the previous line if possible. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_prev_line
argument_list|,
argument|_(
literal|"Move up to the previous line"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|int
name|old_line
decl_stmt|,
name|new_line
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|info_next_line
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
block|{
name|old_line
operator|=
name|window_line_of_point
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|new_line
operator|=
name|old_line
operator|-
name|count
expr_stmt|;
name|move_to_new_line
argument_list|(
name|old_line
argument_list|,
name|new_line
argument_list|,
name|window
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Move WINDOW's point to the end of the true line. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_end_of_line
argument_list|,
argument|_(
literal|"Move to the end of the line"
argument|)
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|point
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|buffer
decl_stmt|;
name|buffer
operator|=
name|window
operator|->
name|node
operator|->
name|contents
expr_stmt|;
name|len
operator|=
name|window
operator|->
name|node
operator|->
name|nodelen
expr_stmt|;
for|for
control|(
name|point
operator|=
name|window
operator|->
name|point
init|;
operator|(
name|point
operator|<
name|len
operator|)
operator|&&
operator|(
name|buffer
index|[
name|point
index|]
operator|!=
literal|'\n'
operator|)
condition|;
name|point
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|point
operator|!=
name|window
operator|->
name|point
condition|)
block|{
name|window
operator|->
name|point
operator|=
name|point
expr_stmt|;
name|info_show_point
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Move WINDOW's point to the beginning of the true line. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_beginning_of_line
argument_list|,
argument|_(
literal|"Move to the start of the line"
argument|)
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|point
decl_stmt|;
specifier|register
name|char
modifier|*
name|buffer
decl_stmt|;
name|buffer
operator|=
name|window
operator|->
name|node
operator|->
name|contents
expr_stmt|;
name|point
operator|=
name|window
operator|->
name|point
expr_stmt|;
for|for
control|(
init|;
operator|(
name|point
operator|)
operator|&&
operator|(
name|buffer
index|[
name|point
operator|-
literal|1
index|]
operator|!=
literal|'\n'
operator|)
condition|;
name|point
operator|--
control|)
empty_stmt|;
comment|/* If at a line start already, do nothing. */
if|if
condition|(
name|point
operator|!=
name|window
operator|->
name|point
condition|)
block|{
name|window
operator|->
name|point
operator|=
name|point
expr_stmt|;
name|info_show_point
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Move point forward in the node. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_forward_char
argument_list|,
argument|_(
literal|"Move forward a character"
argument|)
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|info_backward_char
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
block|{
name|window
operator|->
name|point
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|window
operator|->
name|point
operator|>=
name|window
operator|->
name|node
operator|->
name|nodelen
condition|)
name|window
operator|->
name|point
operator|=
name|window
operator|->
name|node
operator|->
name|nodelen
operator|-
literal|1
expr_stmt|;
name|info_show_point
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Move point backward in the node. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_backward_char
argument_list|,
argument|_(
literal|"Move backward a character"
argument|)
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|info_forward_char
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
block|{
name|window
operator|->
name|point
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|window
operator|->
name|point
operator|<
literal|0
condition|)
name|window
operator|->
name|point
operator|=
literal|0
expr_stmt|;
name|info_show_point
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|alphabetic
parameter_list|(
name|c
parameter_list|)
value|(islower (c) || isupper (c) || isdigit (c))
end_define

begin_comment
comment|/* Move forward a word in this node. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_forward_word
argument_list|,
argument|_(
literal|"Move forward a word"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|long
name|point
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|end
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|info_backward_word
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return;
block|}
name|point
operator|=
name|window
operator|->
name|point
expr_stmt|;
name|buffer
operator|=
name|window
operator|->
name|node
operator|->
name|contents
expr_stmt|;
name|end
operator|=
name|window
operator|->
name|node
operator|->
name|nodelen
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
name|point
operator|+
literal|1
operator|>=
name|end
condition|)
return|return;
comment|/* If we are not in a word, move forward until we are in one.          Then, move forward until we hit a non-alphabetic character. */
name|c
operator|=
name|buffer
index|[
name|point
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|alphabetic
argument_list|(
name|c
argument_list|)
condition|)
block|{
while|while
condition|(
operator|++
name|point
operator|<
name|end
condition|)
block|{
name|c
operator|=
name|buffer
index|[
name|point
index|]
expr_stmt|;
if|if
condition|(
name|alphabetic
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|point
operator|>=
name|end
condition|)
return|return;
while|while
condition|(
operator|++
name|point
operator|<
name|end
condition|)
block|{
name|c
operator|=
name|buffer
index|[
name|point
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|alphabetic
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
operator|--
name|count
expr_stmt|;
block|}
name|window
operator|->
name|point
operator|=
name|point
expr_stmt|;
name|info_show_point
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_backward_word
argument_list|,
argument|_(
literal|"Move backward a word"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|long
name|point
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|info_forward_word
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return;
block|}
name|buffer
operator|=
name|window
operator|->
name|node
operator|->
name|contents
expr_stmt|;
name|point
operator|=
name|window
operator|->
name|point
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
name|point
operator|==
literal|0
condition|)
break|break;
comment|/* Like info_forward_word (), except that we look at the          characters just before point. */
name|c
operator|=
name|buffer
index|[
name|point
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|alphabetic
argument_list|(
name|c
argument_list|)
condition|)
block|{
while|while
condition|(
operator|--
name|point
condition|)
block|{
name|c
operator|=
name|buffer
index|[
name|point
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|alphabetic
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
block|}
while|while
condition|(
name|point
condition|)
block|{
name|c
operator|=
name|buffer
index|[
name|point
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|alphabetic
argument_list|(
name|c
argument_list|)
condition|)
break|break;
else|else
operator|--
name|point
expr_stmt|;
block|}
operator|--
name|count
expr_stmt|;
block|}
name|window
operator|->
name|point
operator|=
name|point
expr_stmt|;
name|info_show_point
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Variable controlling the behaviour of default scrolling when you are    already at the bottom of a node.  Possible values are defined in session.h.    The meanings are:     IS_Continuous        Try to get first menu item, or failing that, the                         "Next:" pointer, or failing that, the "Up:" and                         "Next:" of the up.    IS_NextOnly          Try to get "Next:" menu item.    IS_PageOnly          Simply give up at the bottom of a node. */
end_comment

begin_decl_stmt
name|int
name|info_scroll_behaviour
init|=
name|IS_Continuous
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Choices used by the completer when reading a value for the user-visible    variable "scroll-behaviour". */
end_comment

begin_decl_stmt
name|char
modifier|*
name|info_scroll_choices
index|[]
init|=
block|{
literal|"Continuous"
block|,
literal|"Next Only"
block|,
literal|"Page Only"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default window sizes for scrolling commands.  */
end_comment

begin_decl_stmt
name|int
name|default_window_size
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* meaning 1 window-full */
end_comment

begin_decl_stmt
name|int
name|default_scroll_size
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* meaning half screen size */
end_comment

begin_define
define|#
directive|define
name|INFO_LABEL_FOUND
parameter_list|()
define|\
value|(info_parsed_nodename || (info_parsed_filename \&& !is_dir_name (info_parsed_filename)))
end_define

begin_comment
comment|/* Move to 1st menu item, Next, Up/Next, or error in this window. */
end_comment

begin_function
specifier|static
name|void
name|forward_move_node_structure
parameter_list|(
name|window
parameter_list|,
name|behaviour
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|int
name|behaviour
decl_stmt|;
block|{
switch|switch
condition|(
name|behaviour
condition|)
block|{
case|case
name|IS_PageOnly
case|:
name|info_error
argument_list|(
name|msg_at_node_bottom
argument_list|)
expr_stmt|;
break|break;
case|case
name|IS_NextOnly
case|:
name|info_next_label_of_node
argument_list|(
name|window
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info_parsed_nodename
operator|&&
operator|!
name|info_parsed_filename
condition|)
name|info_error
argument_list|(
name|msg_no_pointer
argument_list|,
name|_
argument_list|(
literal|"Next"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|window_message_in_echo_area
argument_list|(
name|_
argument_list|(
literal|"Following Next node..."
argument_list|)
argument_list|)
expr_stmt|;
name|info_handle_pointer
argument_list|(
literal|"Next"
argument_list|,
name|window
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IS_Continuous
case|:
block|{
comment|/* First things first.  If this node contains a menu, move down            into the menu. */
block|{
name|REFERENCE
modifier|*
modifier|*
name|menu
decl_stmt|;
name|menu
operator|=
name|info_menu_of_node
argument_list|(
name|window
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|menu
condition|)
block|{
name|info_free_references
argument_list|(
name|menu
argument_list|)
expr_stmt|;
name|window_message_in_echo_area
argument_list|(
name|_
argument_list|(
literal|"Selecting first menu item..."
argument_list|)
argument_list|)
expr_stmt|;
name|info_menu_digit
argument_list|(
name|window
argument_list|,
literal|1
argument_list|,
literal|'1'
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Okay, this node does not contain a menu.  If it contains a            "Next:" pointer, use that. */
name|info_next_label_of_node
argument_list|(
name|window
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|INFO_LABEL_FOUND
argument_list|()
condition|)
block|{
name|window_message_in_echo_area
argument_list|(
name|_
argument_list|(
literal|"Selecting Next node..."
argument_list|)
argument_list|)
expr_stmt|;
name|info_handle_pointer
argument_list|(
literal|"Next"
argument_list|,
name|window
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Okay, there wasn't a "Next:" for this node.  Move "Up:" until we            can move "Next:".  If that isn't possible, complain that there            are no more nodes. */
block|{
name|int
name|up_counter
decl_stmt|,
name|old_current
decl_stmt|;
name|INFO_WINDOW
modifier|*
name|info_win
decl_stmt|;
comment|/* Remember the current node and location. */
name|info_win
operator|=
name|get_info_window_of_window
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|old_current
operator|=
name|info_win
operator|->
name|current
expr_stmt|;
comment|/* Back up through the "Up:" pointers until we have found a "Next:"              that isn't the same as the first menu item found in that node. */
name|up_counter
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|info_error_was_printed
condition|)
block|{
name|info_up_label_of_node
argument_list|(
name|window
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|INFO_LABEL_FOUND
argument_list|()
condition|)
block|{
name|info_handle_pointer
argument_list|(
literal|"Up"
argument_list|,
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_error_was_printed
condition|)
continue|continue;
name|up_counter
operator|++
expr_stmt|;
name|info_next_label_of_node
argument_list|(
name|window
operator|->
name|node
argument_list|)
expr_stmt|;
comment|/* If no "Next" pointer, keep backing up. */
if|if
condition|(
operator|!
name|INFO_LABEL_FOUND
argument_list|()
condition|)
continue|continue;
comment|/* If this node's first menu item is the same as this node's                      Next pointer, keep backing up. */
if|if
condition|(
operator|!
name|info_parsed_filename
condition|)
block|{
name|REFERENCE
modifier|*
modifier|*
name|menu
decl_stmt|;
name|char
modifier|*
name|next_nodename
decl_stmt|;
comment|/* Remember the name of the Next node, since reading                          the menu can overwrite the contents of the                          info_parsed_xxx strings. */
name|next_nodename
operator|=
name|xstrdup
argument_list|(
name|info_parsed_nodename
argument_list|)
expr_stmt|;
name|menu
operator|=
name|info_menu_of_node
argument_list|(
name|window
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|menu
operator|&&
operator|(
name|strcmp
argument_list|(
name|menu
index|[
literal|0
index|]
operator|->
name|nodename
argument_list|,
name|next_nodename
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|info_free_references
argument_list|(
name|menu
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|next_nodename
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* Restore the world to where it was before                              reading the menu contents. */
name|info_free_references
argument_list|(
name|menu
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|next_nodename
argument_list|)
expr_stmt|;
name|info_next_label_of_node
argument_list|(
name|window
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* This node has a "Next" pointer, and it is not the                      same as the first menu item found in this node. */
name|window_message_in_echo_area
argument_list|(
name|_
argument_list|(
literal|"Moving Up %d time(s), then Next."
argument_list|)
argument_list|,
name|up_counter
argument_list|)
expr_stmt|;
name|info_handle_pointer
argument_list|(
literal|"Next"
argument_list|,
name|window
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* No more "Up" pointers.  Print an error, and call it                      quits. */
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|up_counter
condition|;
name|i
operator|++
control|)
block|{
name|info_win
operator|->
name|nodes_index
operator|--
expr_stmt|;
name|free
argument_list|(
name|info_win
operator|->
name|nodes
index|[
name|info_win
operator|->
name|nodes_index
index|]
argument_list|)
expr_stmt|;
name|info_win
operator|->
name|nodes
index|[
name|info_win
operator|->
name|nodes_index
index|]
operator|=
operator|(
name|NODE
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|info_win
operator|->
name|current
operator|=
name|old_current
expr_stmt|;
name|window
operator|->
name|node
operator|=
name|info_win
operator|->
name|nodes
index|[
name|old_current
index|]
expr_stmt|;
name|window
operator|->
name|pagetop
operator|=
name|info_win
operator|->
name|pagetops
index|[
name|old_current
index|]
expr_stmt|;
name|window
operator|->
name|point
operator|=
name|info_win
operator|->
name|points
index|[
name|old_current
index|]
expr_stmt|;
name|recalculate_line_starts
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|window
operator|->
name|flags
operator||=
name|W_UpdateWindow
expr_stmt|;
name|info_error
argument_list|(
name|_
argument_list|(
literal|"No more nodes within this document."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Move Prev, Up or error in WINDOW depending on BEHAVIOUR. */
end_comment

begin_function
specifier|static
name|void
name|backward_move_node_structure
parameter_list|(
name|window
parameter_list|,
name|behaviour
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|int
name|behaviour
decl_stmt|;
block|{
switch|switch
condition|(
name|behaviour
condition|)
block|{
case|case
name|IS_PageOnly
case|:
name|info_error
argument_list|(
name|msg_at_node_top
argument_list|)
expr_stmt|;
break|break;
case|case
name|IS_NextOnly
case|:
name|info_prev_label_of_node
argument_list|(
name|window
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info_parsed_nodename
operator|&&
operator|!
name|info_parsed_filename
condition|)
name|info_error
argument_list|(
name|_
argument_list|(
literal|"No `Prev' for this node."
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|window_message_in_echo_area
argument_list|(
name|_
argument_list|(
literal|"Moving Prev in this window."
argument_list|)
argument_list|)
expr_stmt|;
name|info_handle_pointer
argument_list|(
literal|"Prev"
argument_list|,
name|window
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IS_Continuous
case|:
name|info_prev_label_of_node
argument_list|(
name|window
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info_parsed_nodename
operator|&&
operator|(
operator|!
name|info_parsed_filename
operator|||
name|is_dir_name
argument_list|(
name|info_parsed_filename
argument_list|)
operator|)
condition|)
block|{
name|info_up_label_of_node
argument_list|(
name|window
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info_parsed_nodename
operator|&&
operator|(
operator|!
name|info_parsed_filename
operator|||
name|is_dir_name
argument_list|(
name|info_parsed_filename
argument_list|)
operator|)
condition|)
name|info_error
argument_list|(
name|_
argument_list|(
literal|"No `Prev' or `Up' for this node within this document."
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|window_message_in_echo_area
argument_list|(
name|_
argument_list|(
literal|"Moving Up in this window."
argument_list|)
argument_list|)
expr_stmt|;
name|info_handle_pointer
argument_list|(
literal|"Up"
argument_list|,
name|window
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|REFERENCE
modifier|*
modifier|*
name|menu
decl_stmt|;
name|int
name|inhibit_menu_traversing
init|=
literal|0
decl_stmt|;
comment|/* Watch out!  If this node's Prev is the same as the Up, then              move Up.  Otherwise, we could move Prev, and then to the last              menu item in the Prev.  This would cause the user to loop              through a subsection of the info file. */
if|if
condition|(
operator|!
name|info_parsed_filename
operator|&&
name|info_parsed_nodename
condition|)
block|{
name|char
modifier|*
name|pnode
decl_stmt|;
name|pnode
operator|=
name|xstrdup
argument_list|(
name|info_parsed_nodename
argument_list|)
expr_stmt|;
name|info_up_label_of_node
argument_list|(
name|window
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info_parsed_filename
operator|&&
name|info_parsed_nodename
operator|&&
name|strcmp
argument_list|(
name|info_parsed_nodename
argument_list|,
name|pnode
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* The nodes are the same.  Inhibit moving to the last                      menu item. */
name|free
argument_list|(
name|pnode
argument_list|)
expr_stmt|;
name|inhibit_menu_traversing
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|pnode
argument_list|)
expr_stmt|;
name|info_prev_label_of_node
argument_list|(
name|window
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Move to the previous node.  If this node now contains a menu,              and we have not inhibited movement to it, move to the node              corresponding to the last menu item. */
name|window_message_in_echo_area
argument_list|(
name|_
argument_list|(
literal|"Moving Prev in this window."
argument_list|)
argument_list|)
expr_stmt|;
name|info_handle_pointer
argument_list|(
literal|"Prev"
argument_list|,
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inhibit_menu_traversing
condition|)
block|{
while|while
condition|(
operator|!
name|info_error_was_printed
operator|&&
operator|(
name|menu
operator|=
name|info_menu_of_node
argument_list|(
name|window
operator|->
name|node
argument_list|)
operator|)
condition|)
block|{
name|info_free_references
argument_list|(
name|menu
argument_list|)
expr_stmt|;
name|window_message_in_echo_area
argument_list|(
name|_
argument_list|(
literal|"Moving to `Prev's last menu item."
argument_list|)
argument_list|)
expr_stmt|;
name|info_menu_digit
argument_list|(
name|window
argument_list|,
literal|1
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Move continuously forward through the node structure of this info file. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_global_next_node
argument_list|,
argument|_(
literal|"Move forwards or down through node structure"
argument|)
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|info_global_prev_node
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|count
operator|&&
operator|!
name|info_error_was_printed
condition|)
block|{
name|forward_move_node_structure
argument_list|(
name|window
argument_list|,
name|IS_Continuous
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Move continuously backward through the node structure of this info file. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_global_prev_node
argument_list|,
argument|_(
literal|"Move backwards or up through node structure"
argument|)
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|info_global_next_node
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|count
operator|&&
operator|!
name|info_error_was_printed
condition|)
block|{
name|backward_move_node_structure
argument_list|(
name|window
argument_list|,
name|IS_Continuous
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
block|}
block|}
end_block

begin_function_decl
specifier|static
name|void
name|_scroll_forward
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_scroll_backward
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|_scroll_forward
parameter_list|(
name|window
parameter_list|,
name|count
parameter_list|,
name|key
parameter_list|,
name|behaviour
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|int
name|count
decl_stmt|;
name|unsigned
name|char
name|key
decl_stmt|;
name|int
name|behaviour
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|_scroll_backward
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|,
name|behaviour
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|desired_top
decl_stmt|;
comment|/* Without an explicit numeric argument, scroll the bottom two          lines to the top of this window,  Or, if at bottom of window,          and the chosen behaviour is to scroll through nodes get the 	 "Next" node for this window. */
if|if
condition|(
name|default_window_size
operator|>
literal|0
condition|)
name|desired_top
operator|=
name|window
operator|->
name|pagetop
operator|+
name|default_window_size
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|info_explicit_arg
operator|&&
name|count
operator|==
literal|1
condition|)
block|{
name|desired_top
operator|=
name|window
operator|->
name|pagetop
operator|+
operator|(
name|window
operator|->
name|height
operator|-
literal|2
operator|)
expr_stmt|;
comment|/* If there are no more lines to scroll here, error, or get              another node, depending on BEHAVIOUR. */
if|if
condition|(
name|desired_top
operator|>
name|window
operator|->
name|line_count
condition|)
block|{
name|forward_move_node_structure
argument_list|(
name|window
argument_list|,
name|behaviour
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|desired_top
operator|=
name|window
operator|->
name|pagetop
operator|+
name|count
expr_stmt|;
if|if
condition|(
name|desired_top
operator|>=
name|window
operator|->
name|line_count
condition|)
name|desired_top
operator|=
name|window
operator|->
name|line_count
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|window
operator|->
name|pagetop
operator|>
name|desired_top
condition|)
return|return;
else|else
name|set_window_pagetop
argument_list|(
name|window
argument_list|,
name|desired_top
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_scroll_backward
parameter_list|(
name|window
parameter_list|,
name|count
parameter_list|,
name|key
parameter_list|,
name|behaviour
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|int
name|count
decl_stmt|;
name|unsigned
name|char
name|key
decl_stmt|;
name|int
name|behaviour
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|_scroll_forward
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|,
name|behaviour
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|desired_top
decl_stmt|;
comment|/* Without an explicit numeric argument, scroll the top two lines          to the bottom of this window, or, depending on the selected 	 behaviour, move to the previous, or Up'th node. */
if|if
condition|(
name|default_window_size
operator|>
literal|0
condition|)
name|desired_top
operator|=
name|window
operator|->
name|pagetop
operator|-
name|default_window_size
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|info_explicit_arg
operator|&&
name|count
operator|==
literal|1
condition|)
block|{
name|desired_top
operator|=
name|window
operator|->
name|pagetop
operator|-
operator|(
name|window
operator|->
name|height
operator|-
literal|2
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|desired_top
operator|<
literal|0
operator|)
operator|&&
operator|(
name|window
operator|->
name|pagetop
operator|==
literal|0
operator|)
condition|)
block|{
name|backward_move_node_structure
argument_list|(
name|window
argument_list|,
name|behaviour
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|desired_top
operator|=
name|window
operator|->
name|pagetop
operator|-
name|count
expr_stmt|;
if|if
condition|(
name|desired_top
operator|<
literal|0
condition|)
name|desired_top
operator|=
literal|0
expr_stmt|;
name|set_window_pagetop
argument_list|(
name|window
argument_list|,
name|desired_top
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Show the next screen of WINDOW's node. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_scroll_forward
argument_list|,
argument|_(
literal|"Scroll forward in this window"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|_scroll_forward
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|,
name|info_scroll_behaviour
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Like info_scroll_forward, but sets default_window_size as a side    effect.  */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_scroll_forward_set_window
argument_list|,
argument|_(
literal|"Scroll forward in this window and set default window size"
argument|)
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|info_explicit_arg
condition|)
name|default_window_size
operator|=
name|count
expr_stmt|;
name|_scroll_forward
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|,
name|info_scroll_behaviour
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Show the next screen of WINDOW's node but never advance to next node. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_scroll_forward_page_only
argument_list|,
argument|_(
literal|"Scroll forward in this window staying within node"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|_scroll_forward
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|,
name|IS_PageOnly
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Like info_scroll_forward_page_only, but sets default_window_size as a side    effect.  */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_scroll_forward_page_only_set_window
argument_list|,
argument|_(
literal|"Scroll forward in this window staying within node and set default window size"
argument|)
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|info_explicit_arg
condition|)
name|default_window_size
operator|=
name|count
expr_stmt|;
name|_scroll_forward
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|,
name|IS_PageOnly
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Show the previous screen of WINDOW's node. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_scroll_backward
argument_list|,
argument|_(
literal|"Scroll backward in this window"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|_scroll_backward
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|,
name|info_scroll_behaviour
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Like info_scroll_backward, but sets default_window_size as a side    effect.  */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_scroll_backward_set_window
argument_list|,
argument|_(
literal|"Scroll backward in this window and set default window size"
argument|)
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|info_explicit_arg
condition|)
name|default_window_size
operator|=
name|count
expr_stmt|;
name|_scroll_backward
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|,
name|info_scroll_behaviour
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Show the previous screen of WINDOW's node but never move to previous    node. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_scroll_backward_page_only
argument_list|,
argument|_(
literal|"Scroll backward in this window staying within node"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|_scroll_backward
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|,
name|IS_PageOnly
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Like info_scroll_backward_page_only, but sets default_window_size as a side    effect.  */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_scroll_backward_page_only_set_window
argument_list|,
argument|_(
literal|"Scroll backward in this window staying within node and set default window size"
argument|)
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|info_explicit_arg
condition|)
name|default_window_size
operator|=
name|count
expr_stmt|;
name|_scroll_backward
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|,
name|IS_PageOnly
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Move to the beginning of the node. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_beginning_of_node
argument_list|,
argument|_(
literal|"Move to the start of this node"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|window
operator|->
name|pagetop
operator|=
name|window
operator|->
name|point
operator|=
literal|0
expr_stmt|;
name|window
operator|->
name|flags
operator||=
name|W_UpdateWindow
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Move to the end of the node. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_end_of_node
argument_list|,
argument|_(
literal|"Move to the end of this node"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|window
operator|->
name|point
operator|=
name|window
operator|->
name|node
operator|->
name|nodelen
operator|-
literal|1
expr_stmt|;
name|info_show_point
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Scroll the window forward by N lines.  */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_down_line
argument_list|,
argument|_(
literal|"Scroll down by lines"
argument|)
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|info_up_line
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|desired_top
init|=
name|window
operator|->
name|pagetop
operator|+
name|count
decl_stmt|;
if|if
condition|(
name|desired_top
operator|>=
name|window
operator|->
name|line_count
condition|)
name|desired_top
operator|=
name|window
operator|->
name|line_count
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|window
operator|->
name|pagetop
operator|<=
name|desired_top
condition|)
name|set_window_pagetop
argument_list|(
name|window
argument_list|,
name|desired_top
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Scroll the window backward by N lines.  */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_up_line
argument_list|,
argument|_(
literal|"Scroll up by lines"
argument|)
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|info_down_line
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|desired_top
init|=
name|window
operator|->
name|pagetop
operator|-
name|count
decl_stmt|;
if|if
condition|(
name|desired_top
operator|<
literal|0
condition|)
name|desired_top
operator|=
literal|0
expr_stmt|;
name|set_window_pagetop
argument_list|(
name|window
argument_list|,
name|desired_top
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Scroll the window forward by N lines and remember N as default for    subsequent commands.  */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_scroll_half_screen_down
argument_list|,
argument|_(
literal|"Scroll down by half screen size"
argument|)
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|info_scroll_half_screen_up
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|scroll_size
init|=
operator|(
name|the_screen
operator|->
name|height
operator|+
literal|1
operator|)
operator|/
literal|2
decl_stmt|;
name|int
name|desired_top
decl_stmt|;
if|if
condition|(
name|info_explicit_arg
condition|)
name|default_scroll_size
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|default_scroll_size
operator|>
literal|0
condition|)
name|scroll_size
operator|=
name|default_scroll_size
expr_stmt|;
name|desired_top
operator|=
name|window
operator|->
name|pagetop
operator|+
name|scroll_size
expr_stmt|;
if|if
condition|(
name|desired_top
operator|>=
name|window
operator|->
name|line_count
condition|)
name|desired_top
operator|=
name|window
operator|->
name|line_count
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|window
operator|->
name|pagetop
operator|<=
name|desired_top
condition|)
name|set_window_pagetop
argument_list|(
name|window
argument_list|,
name|desired_top
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Scroll the window backward by N lines and remember N as default for    subsequent commands.  */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_scroll_half_screen_up
argument_list|,
argument|_(
literal|"Scroll up by half screen size"
argument|)
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|info_scroll_half_screen_down
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|scroll_size
init|=
operator|(
name|the_screen
operator|->
name|height
operator|+
literal|1
operator|)
operator|/
literal|2
decl_stmt|;
name|int
name|desired_top
decl_stmt|;
if|if
condition|(
name|info_explicit_arg
condition|)
name|default_scroll_size
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|default_scroll_size
operator|>
literal|0
condition|)
name|scroll_size
operator|=
name|default_scroll_size
expr_stmt|;
name|desired_top
operator|=
name|window
operator|->
name|pagetop
operator|-
name|scroll_size
expr_stmt|;
if|if
condition|(
name|desired_top
operator|<
literal|0
condition|)
name|desired_top
operator|=
literal|0
expr_stmt|;
name|set_window_pagetop
argument_list|(
name|window
argument_list|,
name|desired_top
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/*                 Commands for Manipulating Windows                */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Make the next window in the chain be the active window. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_next_window
argument_list|,
argument|_(
literal|"Select the next window"
argument|)
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|info_prev_window
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If no other window, error now. */
if|if
condition|(
operator|!
name|windows
operator|->
name|next
operator|&&
operator|!
name|echo_area_is_active
condition|)
block|{
name|info_error
argument_list|(
name|msg_one_window
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|count
operator|--
condition|)
block|{
if|if
condition|(
name|window
operator|->
name|next
condition|)
name|window
operator|=
name|window
operator|->
name|next
expr_stmt|;
else|else
block|{
if|if
condition|(
name|window
operator|==
name|the_echo_area
operator|||
operator|!
name|echo_area_is_active
condition|)
name|window
operator|=
name|windows
expr_stmt|;
else|else
name|window
operator|=
name|the_echo_area
expr_stmt|;
block|}
block|}
if|if
condition|(
name|active_window
operator|!=
name|window
condition|)
block|{
if|if
condition|(
name|auto_footnotes_p
condition|)
name|info_get_or_remove_footnotes
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|window
operator|->
name|flags
operator||=
name|W_UpdateWindow
expr_stmt|;
name|active_window
operator|=
name|window
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Make the previous window in the chain be the active window. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_prev_window
argument_list|,
argument|_(
literal|"Select the previous window"
argument|)
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|info_next_window
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Only one window? */
if|if
condition|(
operator|!
name|windows
operator|->
name|next
operator|&&
operator|!
name|echo_area_is_active
condition|)
block|{
name|info_error
argument_list|(
name|msg_one_window
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|count
operator|--
condition|)
block|{
comment|/* If we are in the echo area, or if the echo area isn't active and we          are in the first window, find the last window in the chain. */
if|if
condition|(
name|window
operator|==
name|the_echo_area
operator|||
operator|(
name|window
operator|==
name|windows
operator|&&
operator|!
name|echo_area_is_active
operator|)
condition|)
block|{
specifier|register
name|WINDOW
modifier|*
name|win
decl_stmt|,
modifier|*
name|last
decl_stmt|;
for|for
control|(
name|win
operator|=
name|windows
init|;
name|win
condition|;
name|win
operator|=
name|win
operator|->
name|next
control|)
name|last
operator|=
name|win
expr_stmt|;
name|window
operator|=
name|last
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|window
operator|==
name|windows
condition|)
name|window
operator|=
name|the_echo_area
expr_stmt|;
else|else
name|window
operator|=
name|window
operator|->
name|prev
expr_stmt|;
block|}
block|}
if|if
condition|(
name|active_window
operator|!=
name|window
condition|)
block|{
if|if
condition|(
name|auto_footnotes_p
condition|)
name|info_get_or_remove_footnotes
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|window
operator|->
name|flags
operator||=
name|W_UpdateWindow
expr_stmt|;
name|active_window
operator|=
name|window
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Split WINDOW into two windows, both showing the same node.  If we    are automatically tiling windows, re-tile after the split. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_split_window
argument_list|,
argument|_(
literal|"Split the current window"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|WINDOW
modifier|*
name|split
decl_stmt|,
modifier|*
name|old_active
decl_stmt|;
name|int
name|pagetop
decl_stmt|;
comment|/* Remember the current pagetop of the window being split.  If it doesn't      change, we can scroll its contents around after the split. */
name|pagetop
operator|=
name|window
operator|->
name|pagetop
expr_stmt|;
comment|/* Make the new window. */
name|old_active
operator|=
name|active_window
expr_stmt|;
name|active_window
operator|=
name|window
expr_stmt|;
name|split
operator|=
name|window_make_window
argument_list|(
name|window
operator|->
name|node
argument_list|)
expr_stmt|;
name|active_window
operator|=
name|old_active
expr_stmt|;
if|if
condition|(
operator|!
name|split
condition|)
block|{
name|info_error
argument_list|(
name|msg_win_too_small
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|SPLIT_BEFORE_ACTIVE
argument_list|)
comment|/* Try to scroll the old window into its new postion. */
if|if
condition|(
name|pagetop
operator|==
name|window
operator|->
name|pagetop
condition|)
block|{
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|amount
decl_stmt|;
name|start
operator|=
name|split
operator|->
name|first_row
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|window
operator|->
name|height
expr_stmt|;
name|amount
operator|=
name|split
operator|->
name|height
operator|+
literal|1
expr_stmt|;
name|display_scroll_display
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|amount
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !SPLIT_BEFORE_ACTIVE */
comment|/* Make sure point still appears in the active window. */
name|info_show_point
argument_list|(
name|window
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !SPLIT_BEFORE_ACTIVE */
comment|/* If the window just split was one internal to Info, try to display          something else in it. */
if|if
condition|(
name|internal_info_node_p
argument_list|(
name|split
operator|->
name|node
argument_list|)
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|INFO_WINDOW
modifier|*
name|iw
decl_stmt|;
name|NODE
modifier|*
name|node
init|=
operator|(
name|NODE
operator|*
operator|)
name|NULL
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|iw
operator|=
name|info_windows
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|iw
operator|->
name|nodes_index
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|internal_info_node_p
argument_list|(
name|iw
operator|->
name|nodes
index|[
name|j
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|iw
operator|->
name|nodes
index|[
name|j
index|]
operator|->
name|parent
condition|)
name|filename
operator|=
name|iw
operator|->
name|nodes
index|[
name|j
index|]
operator|->
name|parent
expr_stmt|;
else|else
name|filename
operator|=
name|iw
operator|->
name|nodes
index|[
name|j
index|]
operator|->
name|filename
expr_stmt|;
name|node
operator|=
name|info_get_node
argument_list|(
name|filename
argument_list|,
name|iw
operator|->
name|nodes
index|[
name|j
index|]
operator|->
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
name|window_set_node_of_window
argument_list|(
name|split
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|i
operator|=
name|info_windows_index
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|split
operator|->
name|pagetop
operator|=
name|window
operator|->
name|pagetop
expr_stmt|;
if|if
condition|(
name|auto_tiling_p
condition|)
name|window_tile_windows
argument_list|(
name|DONT_TILE_INTERNALS
argument_list|)
expr_stmt|;
else|else
name|window_adjust_pagetop
argument_list|(
name|split
argument_list|)
expr_stmt|;
name|remember_window_and_node
argument_list|(
name|split
argument_list|,
name|split
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Delete WINDOW, forgetting the list of last visited nodes.  If we are    automatically displaying footnotes, show or remove the footnotes    window.  If we are automatically tiling windows, re-tile after the    deletion. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_delete_window
argument_list|,
argument|_(
literal|"Delete the current window"
argument|)
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|windows
operator|->
name|next
condition|)
block|{
name|info_error
argument_list|(
name|msg_cant_kill_last
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|window
operator|->
name|flags
operator|&
name|W_WindowIsPerm
condition|)
block|{
name|info_error
argument_list|(
name|_
argument_list|(
literal|"Cannot delete a permanent window"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|info_delete_window_internal
argument_list|(
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
name|auto_footnotes_p
condition|)
name|info_get_or_remove_footnotes
argument_list|(
name|active_window
argument_list|)
expr_stmt|;
if|if
condition|(
name|auto_tiling_p
condition|)
name|window_tile_windows
argument_list|(
name|DONT_TILE_INTERNALS
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Do the physical deletion of WINDOW, and forget this window and    associated nodes. */
end_comment

begin_function
name|void
name|info_delete_window_internal
parameter_list|(
name|window
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
block|{
if|if
condition|(
name|windows
operator|->
name|next
operator|&&
operator|(
operator|(
name|window
operator|->
name|flags
operator|&
name|W_WindowIsPerm
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* We not only delete the window from the display, we forget it from          our list of remembered windows. */
name|forget_window_and_nodes
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|window_delete_window
argument_list|(
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
name|echo_area_is_active
condition|)
name|echo_area_inform_of_deleted_window
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Just keep WINDOW, deleting all others. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_keep_one_window
argument_list|,
argument|_(
literal|"Delete all other windows"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|int
name|num_deleted
decl_stmt|;
comment|/* The number of windows we deleted. */
name|int
name|pagetop
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|;
comment|/* Remember a few things about this window.  We may be able to speed up      redisplay later by scrolling its contents. */
name|pagetop
operator|=
name|window
operator|->
name|pagetop
expr_stmt|;
name|start
operator|=
name|window
operator|->
name|first_row
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|window
operator|->
name|height
expr_stmt|;
name|num_deleted
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|WINDOW
modifier|*
name|win
decl_stmt|;
comment|/* Find an eligible window and delete it.  If no eligible windows          are found, we are done.  A window is eligible for deletion if          is it not permanent, and it is not WINDOW. */
for|for
control|(
name|win
operator|=
name|windows
init|;
name|win
condition|;
name|win
operator|=
name|win
operator|->
name|next
control|)
if|if
condition|(
name|win
operator|!=
name|window
operator|&&
operator|(
operator|(
name|win
operator|->
name|flags
operator|&
name|W_WindowIsPerm
operator|)
operator|==
literal|0
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|win
condition|)
break|break;
name|info_delete_window_internal
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|num_deleted
operator|++
expr_stmt|;
block|}
comment|/* Scroll the contents of this window into the right place so that the      user doesn't have to wait any longer than necessary for redisplay. */
if|if
condition|(
name|num_deleted
condition|)
block|{
name|int
name|amount
decl_stmt|;
name|amount
operator|=
operator|(
name|window
operator|->
name|first_row
operator|-
name|start
operator|)
expr_stmt|;
name|amount
operator|-=
operator|(
name|window
operator|->
name|pagetop
operator|-
name|pagetop
operator|)
expr_stmt|;
name|display_scroll_display
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|amount
argument_list|)
expr_stmt|;
block|}
name|window
operator|->
name|flags
operator||=
name|W_UpdateWindow
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Scroll the "other" window of WINDOW. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_scroll_other_window
argument_list|,
argument|_(
literal|"Scroll the other window"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|WINDOW
modifier|*
name|other
decl_stmt|;
comment|/* If only one window, give up. */
if|if
condition|(
operator|!
name|windows
operator|->
name|next
condition|)
block|{
name|info_error
argument_list|(
name|msg_one_window
argument_list|)
expr_stmt|;
return|return;
block|}
name|other
operator|=
name|window
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|other
condition|)
name|other
operator|=
name|window
operator|->
name|prev
expr_stmt|;
name|info_scroll_forward
argument_list|(
name|other
argument_list|,
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Scroll the "other" window of WINDOW. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_scroll_other_window_backward
argument_list|,
argument|_(
literal|"Scroll the other window backward"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|info_scroll_other_window
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Change the size of WINDOW by AMOUNT. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_grow_window
argument_list|,
argument|_(
literal|"Grow (or shrink) this window"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|window_change_window_height
argument_list|(
name|window
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* When non-zero, tiling takes place automatically when info_split_window    is called. */
end_comment

begin_decl_stmt
name|int
name|auto_tiling_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tile all of the visible windows. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_tile_windows
argument_list|,
argument|_(
literal|"Divide the available screen space among the visible windows"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|window_tile_windows
argument_list|(
name|TILE_INTERNALS
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Toggle the state of this window's wrapping of lines. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_toggle_wrap
argument_list|,
argument|_(
literal|"Toggle the state of line wrapping in the current window"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|window_toggle_wrap
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/*                      Info Node Commands                          */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Return (FILENAME)NODENAME for NODE, or just NODENAME if NODE's    filename is not set. */
end_comment

begin_function
name|char
modifier|*
name|node_printed_rep
parameter_list|(
name|node
parameter_list|)
name|NODE
modifier|*
name|node
decl_stmt|;
block|{
name|char
modifier|*
name|rep
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|filename
condition|)
block|{
name|char
modifier|*
name|filename
init|=
name|filename_non_directory
argument_list|(
name|node
operator|->
name|parent
condition|?
name|node
operator|->
name|parent
else|:
name|node
operator|->
name|filename
argument_list|)
decl_stmt|;
name|rep
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|node
operator|->
name|nodename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|rep
argument_list|,
literal|"(%s)%s"
argument_list|,
name|filename
argument_list|,
name|node
operator|->
name|nodename
argument_list|)
expr_stmt|;
block|}
else|else
name|rep
operator|=
name|node
operator|->
name|nodename
expr_stmt|;
return|return
name|rep
return|;
block|}
end_function

begin_comment
comment|/* Using WINDOW for various defaults, select the node referenced by ENTRY    in it.  If the node is selected, the window and node are remembered. */
end_comment

begin_function
name|void
name|info_select_reference
parameter_list|(
name|window
parameter_list|,
name|entry
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|REFERENCE
modifier|*
name|entry
decl_stmt|;
block|{
name|NODE
modifier|*
name|node
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|,
modifier|*
name|nodename
decl_stmt|,
modifier|*
name|file_system_error
decl_stmt|;
name|file_system_error
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|filename
operator|=
name|entry
operator|->
name|filename
expr_stmt|;
if|if
condition|(
operator|!
name|filename
condition|)
name|filename
operator|=
name|window
operator|->
name|node
operator|->
name|parent
expr_stmt|;
if|if
condition|(
operator|!
name|filename
condition|)
name|filename
operator|=
name|window
operator|->
name|node
operator|->
name|filename
expr_stmt|;
if|if
condition|(
name|filename
condition|)
name|filename
operator|=
name|xstrdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|nodename
condition|)
name|nodename
operator|=
name|xstrdup
argument_list|(
name|entry
operator|->
name|nodename
argument_list|)
expr_stmt|;
else|else
name|nodename
operator|=
name|xstrdup
argument_list|(
literal|"Top"
argument_list|)
expr_stmt|;
name|node
operator|=
name|info_get_node
argument_list|(
name|filename
argument_list|,
name|nodename
argument_list|)
expr_stmt|;
comment|/* Try something a little weird.  If the node couldn't be found, and the      reference was of the form "foo::", see if the entry->label can be found      as a file, with a node of "Top". */
if|if
condition|(
operator|!
name|node
condition|)
block|{
if|if
condition|(
name|info_recent_file_error
condition|)
name|file_system_error
operator|=
name|xstrdup
argument_list|(
name|info_recent_file_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|nodename
operator|&&
operator|(
name|strcmp
argument_list|(
name|entry
operator|->
name|nodename
argument_list|,
name|entry
operator|->
name|label
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|node
operator|=
name|info_get_node
argument_list|(
name|entry
operator|->
name|label
argument_list|,
literal|"Top"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|&&
name|info_recent_file_error
condition|)
block|{
name|maybe_free
argument_list|(
name|file_system_error
argument_list|)
expr_stmt|;
name|file_system_error
operator|=
name|xstrdup
argument_list|(
name|info_recent_file_error
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|node
condition|)
block|{
if|if
condition|(
name|file_system_error
condition|)
name|info_error
argument_list|(
name|file_system_error
argument_list|)
expr_stmt|;
else|else
name|info_error
argument_list|(
name|msg_cant_find_node
argument_list|,
name|nodename
argument_list|)
expr_stmt|;
block|}
name|maybe_free
argument_list|(
name|file_system_error
argument_list|)
expr_stmt|;
name|maybe_free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|maybe_free
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
name|info_set_node_of_window
argument_list|(
literal|1
argument_list|,
name|window
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse the node specification in LINE using WINDOW to default the filename.    Select the parsed node in WINDOW and remember it, or error if the node    couldn't be found. */
end_comment

begin_function
specifier|static
name|void
name|info_parse_and_select
parameter_list|(
name|line
parameter_list|,
name|window
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|WINDOW
modifier|*
name|window
decl_stmt|;
block|{
name|REFERENCE
name|entry
decl_stmt|;
name|info_parse_node
argument_list|(
name|line
argument_list|,
name|DONT_SKIP_NEWLINES
argument_list|)
expr_stmt|;
name|entry
operator|.
name|nodename
operator|=
name|info_parsed_nodename
expr_stmt|;
name|entry
operator|.
name|filename
operator|=
name|info_parsed_filename
expr_stmt|;
name|entry
operator|.
name|label
operator|=
literal|"*info-parse-and-select*"
expr_stmt|;
name|info_select_reference
argument_list|(
name|window
argument_list|,
operator|&
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given that the values of INFO_PARSED_FILENAME and INFO_PARSED_NODENAME    are previously filled, try to get the node represented by them into    WINDOW.  The node should have been pointed to by the LABEL pointer of    WINDOW->node. */
end_comment

begin_function
specifier|static
name|void
name|info_handle_pointer
parameter_list|(
name|label
parameter_list|,
name|window
parameter_list|)
name|char
modifier|*
name|label
decl_stmt|;
name|WINDOW
modifier|*
name|window
decl_stmt|;
block|{
if|if
condition|(
name|info_parsed_filename
operator|||
name|info_parsed_nodename
condition|)
block|{
name|char
modifier|*
name|filename
decl_stmt|,
modifier|*
name|nodename
decl_stmt|;
name|NODE
modifier|*
name|node
decl_stmt|;
name|filename
operator|=
name|nodename
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|info_parsed_filename
condition|)
name|filename
operator|=
name|xstrdup
argument_list|(
name|info_parsed_filename
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|window
operator|->
name|node
operator|->
name|parent
condition|)
name|filename
operator|=
name|xstrdup
argument_list|(
name|window
operator|->
name|node
operator|->
name|parent
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|window
operator|->
name|node
operator|->
name|filename
condition|)
name|filename
operator|=
name|xstrdup
argument_list|(
name|window
operator|->
name|node
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info_parsed_nodename
condition|)
name|nodename
operator|=
name|xstrdup
argument_list|(
name|info_parsed_nodename
argument_list|)
expr_stmt|;
else|else
name|nodename
operator|=
name|xstrdup
argument_list|(
literal|"Top"
argument_list|)
expr_stmt|;
name|node
operator|=
name|info_get_node
argument_list|(
name|filename
argument_list|,
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
name|INFO_WINDOW
modifier|*
name|info_win
decl_stmt|;
name|info_win
operator|=
name|get_info_window_of_window
argument_list|(
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_win
condition|)
block|{
name|info_win
operator|->
name|pagetops
index|[
name|info_win
operator|->
name|current
index|]
operator|=
name|window
operator|->
name|pagetop
expr_stmt|;
name|info_win
operator|->
name|points
index|[
name|info_win
operator|->
name|current
index|]
operator|=
name|window
operator|->
name|point
expr_stmt|;
block|}
name|info_set_node_of_window
argument_list|(
literal|1
argument_list|,
name|window
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|info_recent_file_error
condition|)
name|info_error
argument_list|(
name|info_recent_file_error
argument_list|)
expr_stmt|;
else|else
name|info_error
argument_list|(
name|msg_cant_file_node
argument_list|,
name|filename
argument_list|,
name|nodename
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|info_error
argument_list|(
name|msg_no_pointer
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make WINDOW display the "Next:" node of the node currently being    displayed. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_next_node
argument_list|,
argument|_(
literal|"Select the Next node"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|info_next_label_of_node
argument_list|(
name|window
operator|->
name|node
argument_list|)
expr_stmt|;
name|info_handle_pointer
argument_list|(
literal|"Next"
argument_list|,
name|window
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Make WINDOW display the "Prev:" node of the node currently being    displayed. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_prev_node
argument_list|,
argument|_(
literal|"Select the Prev node"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|info_prev_label_of_node
argument_list|(
name|window
operator|->
name|node
argument_list|)
expr_stmt|;
name|info_handle_pointer
argument_list|(
literal|"Prev"
argument_list|,
name|window
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Make WINDOW display the "Up:" node of the node currently being    displayed. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_up_node
argument_list|,
argument|_(
literal|"Select the Up node"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|info_up_label_of_node
argument_list|(
name|window
operator|->
name|node
argument_list|)
expr_stmt|;
name|info_handle_pointer
argument_list|(
literal|"Up"
argument_list|,
name|window
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Make WINDOW display the last node of this info file. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_last_node
argument_list|,
argument|_(
literal|"Select the last node in this file"
argument|)
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|FILE_BUFFER
modifier|*
name|fb
init|=
name|file_buffer_of_window
argument_list|(
name|window
argument_list|)
decl_stmt|;
name|NODE
modifier|*
name|node
init|=
operator|(
name|NODE
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|fb
operator|&&
name|fb
operator|->
name|tags
condition|)
block|{
name|int
name|last_node_tag_idx
init|=
operator|-
literal|1
decl_stmt|;
comment|/* If no explicit argument, or argument of zero, default to the          last node.  */
if|if
condition|(
name|count
operator|==
literal|0
operator|||
operator|(
name|count
operator|==
literal|1
operator|&&
operator|!
name|info_explicit_arg
operator|)
condition|)
name|count
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|count
operator|&&
name|fb
operator|->
name|tags
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fb
operator|->
name|tags
index|[
name|i
index|]
operator|->
name|nodelen
operator|!=
literal|0
condition|)
comment|/* don't count anchor tags */
block|{
name|count
operator|--
expr_stmt|;
name|last_node_tag_idx
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|i
operator|=
name|last_node_tag_idx
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|node
operator|=
name|info_get_node
argument_list|(
name|fb
operator|->
name|filename
argument_list|,
name|fb
operator|->
name|tags
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|nodename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|node
condition|)
name|info_error
argument_list|(
name|_
argument_list|(
literal|"This window has no additional nodes"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|info_set_node_of_window
argument_list|(
literal|1
argument_list|,
name|window
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Make WINDOW display the first node of this info file. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_first_node
argument_list|,
argument|_(
literal|"Select the first node in this file"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|FILE_BUFFER
modifier|*
name|fb
init|=
name|file_buffer_of_window
argument_list|(
name|window
argument_list|)
decl_stmt|;
name|NODE
modifier|*
name|node
init|=
operator|(
name|NODE
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* If no explicit argument, or argument of zero, default to the      first node.  */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fb
operator|&&
name|fb
operator|->
name|tags
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|last_node_tag_idx
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|count
operator|&&
name|fb
operator|->
name|tags
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fb
operator|->
name|tags
index|[
name|i
index|]
operator|->
name|nodelen
operator|!=
literal|0
condition|)
comment|/* don't count anchor tags */
block|{
name|count
operator|--
expr_stmt|;
name|last_node_tag_idx
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|i
operator|=
name|last_node_tag_idx
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|node
operator|=
name|info_get_node
argument_list|(
name|fb
operator|->
name|filename
argument_list|,
name|fb
operator|->
name|tags
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|nodename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|node
condition|)
name|info_error
argument_list|(
name|_
argument_list|(
literal|"This window has no additional nodes"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|info_set_node_of_window
argument_list|(
literal|1
argument_list|,
name|window
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Select the last menu item in WINDOW->node. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_last_menu_item
argument_list|,
argument|_(
literal|"Select the last item in this node's menu"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|info_menu_digit
argument_list|(
name|window
argument_list|,
literal|1
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Use KEY (a digit) to select the Nth menu item in WINDOW->node. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_menu_digit
argument_list|,
argument|_(
literal|"Select this menu item"
argument|)
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|item
decl_stmt|;
specifier|register
name|REFERENCE
modifier|*
name|entry
decl_stmt|,
modifier|*
modifier|*
name|menu
decl_stmt|;
name|menu
operator|=
name|info_menu_of_node
argument_list|(
name|window
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|menu
condition|)
block|{
name|info_error
argument_list|(
name|msg_no_menu_node
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We have the menu.  See if there are this many items in it. */
name|item
operator|=
name|key
operator|-
literal|'0'
expr_stmt|;
comment|/* Special case.  Item "0" is the last item in this menu. */
if|if
condition|(
name|item
operator|==
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|menu
index|[
name|i
operator|+
literal|1
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|entry
operator|=
name|menu
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|==
name|item
operator|-
literal|1
condition|)
break|break;
block|}
if|if
condition|(
name|menu
index|[
name|i
index|]
condition|)
name|info_select_reference
argument_list|(
name|window
argument_list|,
name|menu
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|info_error
argument_list|(
name|_
argument_list|(
literal|"There aren't %d items in this menu."
argument_list|)
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|info_free_references
argument_list|(
name|menu
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/* Read a menu or followed reference from the user defaulting to the    reference found on the current line, and select that node.  The    reading is done with completion.  BUILDER is the function used    to build the list of references.  ASK_P is non-zero if the user    should be prompted, or zero to select the default item. */
end_comment

begin_function
specifier|static
name|void
name|info_menu_or_ref_item
parameter_list|(
name|window
parameter_list|,
name|count
parameter_list|,
name|key
parameter_list|,
name|builder
parameter_list|,
name|ask_p
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|int
name|count
decl_stmt|;
name|unsigned
name|char
name|key
decl_stmt|;
function|REFERENCE **
parameter_list|(
function|*builder
end_function

begin_expr_stmt
unit|)
operator|(
operator|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ask_p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|REFERENCE
modifier|*
modifier|*
name|menu
decl_stmt|,
modifier|*
name|entry
decl_stmt|,
modifier|*
name|defentry
init|=
operator|(
name|REFERENCE
operator|*
operator|)
name|NULL
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|menu
operator|=
call|(
modifier|*
name|builder
call|)
argument_list|(
name|window
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|menu
condition|)
block|{
if|if
condition|(
name|builder
operator|==
name|info_menu_of_node
condition|)
name|info_error
argument_list|(
name|msg_no_menu_node
argument_list|)
expr_stmt|;
else|else
name|info_error
argument_list|(
name|msg_no_xref_node
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Default the selected reference to the one which is on the line that      point is in.  */
block|{
name|REFERENCE
modifier|*
modifier|*
name|refs
init|=
operator|(
name|REFERENCE
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|point_line
decl_stmt|;
name|point_line
operator|=
name|window_line_of_point
argument_list|(
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
name|point_line
operator|!=
operator|-
literal|1
condition|)
block|{
name|SEARCH_BINDING
name|binding
decl_stmt|;
name|binding
operator|.
name|buffer
operator|=
name|window
operator|->
name|node
operator|->
name|contents
expr_stmt|;
name|binding
operator|.
name|start
operator|=
name|window
operator|->
name|line_starts
index|[
name|point_line
index|]
operator|-
name|binding
operator|.
name|buffer
expr_stmt|;
if|if
condition|(
name|window
operator|->
name|line_starts
index|[
name|point_line
operator|+
literal|1
index|]
condition|)
name|binding
operator|.
name|end
operator|=
name|window
operator|->
name|line_starts
index|[
name|point_line
operator|+
literal|1
index|]
operator|-
name|binding
operator|.
name|buffer
expr_stmt|;
else|else
name|binding
operator|.
name|end
operator|=
name|window
operator|->
name|node
operator|->
name|nodelen
expr_stmt|;
name|binding
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|builder
operator|==
name|info_menu_of_node
condition|)
block|{
if|if
condition|(
name|point_line
condition|)
block|{
name|binding
operator|.
name|start
operator|--
expr_stmt|;
name|refs
operator|=
name|info_menu_items
argument_list|(
operator|&
name|binding
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MAN_PAGES
argument_list|)
if|if
condition|(
name|window
operator|->
name|node
operator|->
name|flags
operator|&
name|N_IsManPage
condition|)
name|refs
operator|=
name|manpage_xrefs_in_binding
argument_list|(
name|window
operator|->
name|node
argument_list|,
operator|&
name|binding
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* HANDLE_MAN_PAGES */
block|{
name|refs
operator|=
name|info_xrefs
argument_list|(
operator|&
name|binding
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|refs
operator|&&
name|point_line
operator|>
literal|0
condition|)
block|{
comment|/* People get annoyed that Info cannot find an xref 		     which starts on a previous line and ends on this 		     one.  So if we fail to find a reference on this 		     line, let's try the one before.  */
name|binding
operator|.
name|start
operator|=
name|window
operator|->
name|line_starts
index|[
name|point_line
operator|-
literal|1
index|]
operator|-
name|binding
operator|.
name|buffer
expr_stmt|;
name|refs
operator|=
name|info_xrefs
argument_list|(
operator|&
name|binding
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|refs
condition|)
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|refs
index|[
literal|0
index|]
operator|->
name|label
argument_list|,
literal|"Menu"
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|builder
operator|==
name|info_xrefs_of_node
operator|)
condition|)
block|{
name|int
name|which
init|=
literal|0
decl_stmt|;
comment|/* Find the closest reference to point. */
if|if
condition|(
name|builder
operator|==
name|info_xrefs_of_node
condition|)
block|{
name|int
name|closest
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
init|;
name|refs
index|[
name|which
index|]
condition|;
name|which
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|window
operator|->
name|point
operator|>=
name|refs
index|[
name|which
index|]
operator|->
name|start
operator|)
operator|&&
operator|(
name|window
operator|->
name|point
operator|<=
name|refs
index|[
name|which
index|]
operator|->
name|end
operator|)
condition|)
block|{
name|closest
operator|=
name|which
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|window
operator|->
name|point
operator|<
name|refs
index|[
name|which
index|]
operator|->
name|start
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|closest
operator|==
operator|-
literal|1
condition|)
name|which
operator|--
expr_stmt|;
else|else
name|which
operator|=
name|closest
expr_stmt|;
block|}
name|defentry
operator|=
operator|(
name|REFERENCE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|REFERENCE
argument_list|)
argument_list|)
expr_stmt|;
name|defentry
operator|->
name|label
operator|=
name|xstrdup
argument_list|(
name|refs
index|[
name|which
index|]
operator|->
name|label
argument_list|)
expr_stmt|;
name|defentry
operator|->
name|filename
operator|=
name|refs
index|[
name|which
index|]
operator|->
name|filename
expr_stmt|;
name|defentry
operator|->
name|nodename
operator|=
name|refs
index|[
name|which
index|]
operator|->
name|nodename
expr_stmt|;
if|if
condition|(
name|defentry
operator|->
name|filename
condition|)
name|defentry
operator|->
name|filename
operator|=
name|xstrdup
argument_list|(
name|defentry
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|defentry
operator|->
name|nodename
condition|)
name|defentry
operator|->
name|nodename
operator|=
name|xstrdup
argument_list|(
name|defentry
operator|->
name|nodename
argument_list|)
expr_stmt|;
block|}
name|info_free_references
argument_list|(
name|refs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If we are going to ask the user a question, do it now. */
if|if
condition|(
name|ask_p
condition|)
block|{
name|char
modifier|*
name|prompt
decl_stmt|;
comment|/* Build the prompt string. */
if|if
condition|(
name|defentry
condition|)
name|prompt
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|20
operator|+
name|strlen
argument_list|(
name|defentry
operator|->
name|label
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|prompt
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|builder
operator|==
name|info_menu_of_node
condition|)
block|{
if|if
condition|(
name|defentry
condition|)
name|sprintf
argument_list|(
name|prompt
argument_list|,
name|_
argument_list|(
literal|"Menu item (%s): "
argument_list|)
argument_list|,
name|defentry
operator|->
name|label
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|prompt
argument_list|,
name|_
argument_list|(
literal|"Menu item: "
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|defentry
condition|)
name|sprintf
argument_list|(
name|prompt
argument_list|,
name|_
argument_list|(
literal|"Follow xref (%s): "
argument_list|)
argument_list|,
name|defentry
operator|->
name|label
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|prompt
argument_list|,
name|_
argument_list|(
literal|"Follow xref: "
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|line
operator|=
name|info_read_completing_in_echo_area
argument_list|(
name|window
argument_list|,
name|prompt
argument_list|,
name|menu
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|window
operator|=
name|active_window
expr_stmt|;
comment|/* User aborts, just quit. */
if|if
condition|(
operator|!
name|line
condition|)
block|{
name|maybe_free
argument_list|(
name|defentry
argument_list|)
expr_stmt|;
name|info_free_references
argument_list|(
name|menu
argument_list|)
expr_stmt|;
name|info_abort_key
argument_list|(
name|window
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we had a default and the user accepted it, use that. */
if|if
condition|(
operator|!
operator|*
name|line
condition|)
block|{
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|defentry
condition|)
name|line
operator|=
name|xstrdup
argument_list|(
name|defentry
operator|->
name|label
argument_list|)
expr_stmt|;
else|else
name|line
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Not going to ask any questions.  If we have a default entry, use          that, otherwise return. */
if|if
condition|(
operator|!
name|defentry
condition|)
return|return;
else|else
name|line
operator|=
name|xstrdup
argument_list|(
name|defentry
operator|->
name|label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|line
condition|)
block|{
comment|/* It is possible that the references have more than a single          entry with the same label, and also LINE is down-cased, which          complicates matters even more.  Try to be as accurate as we          can: if they've chosen the default, use defentry directly. */
if|if
condition|(
name|defentry
operator|&&
name|strcmp
argument_list|(
name|line
argument_list|,
name|defentry
operator|->
name|label
argument_list|)
operator|==
literal|0
condition|)
name|entry
operator|=
name|defentry
expr_stmt|;
else|else
comment|/* Find the selected label in the references.  If there are            more than one label which matches, find the one that's            closest to point.  */
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|best
init|=
operator|-
literal|1
decl_stmt|,
name|min_dist
init|=
name|window
operator|->
name|node
operator|->
name|nodelen
decl_stmt|;
name|REFERENCE
modifier|*
name|ref
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|menu
operator|&&
operator|(
name|ref
operator|=
name|menu
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* Need to use strcasecmp because LINE is downcased                  inside info_read_completing_in_echo_area.  */
if|if
condition|(
name|strcasecmp
argument_list|(
name|line
argument_list|,
name|ref
operator|->
name|label
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* ref->end is more accurate estimate of position                      for menus than ref->start.  Go figure.  */
name|int
name|dist
init|=
name|abs
argument_list|(
name|window
operator|->
name|point
operator|-
name|ref
operator|->
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|dist
operator|<
name|min_dist
condition|)
block|{
name|min_dist
operator|=
name|dist
expr_stmt|;
name|best
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|best
operator|!=
operator|-
literal|1
condition|)
name|entry
operator|=
name|menu
index|[
name|best
index|]
expr_stmt|;
else|else
name|entry
operator|=
operator|(
name|REFERENCE
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|entry
operator|&&
name|defentry
condition|)
name|info_error
argument_list|(
name|_
argument_list|(
literal|"The reference disappeared! (%s)."
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
else|else
block|{
name|NODE
modifier|*
name|orig
init|=
name|window
operator|->
name|node
decl_stmt|;
name|info_select_reference
argument_list|(
name|window
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|builder
operator|==
name|info_xrefs_of_node
operator|&&
name|window
operator|->
name|node
operator|!=
name|orig
operator|&&
operator|!
operator|(
name|window
operator|->
name|node
operator|->
name|flags
operator|&
name|N_FromAnchor
operator|)
condition|)
block|{
comment|/* Search for this reference in the node.  */
name|long
name|offset
decl_stmt|;
name|long
name|start
decl_stmt|;
if|if
condition|(
name|window
operator|->
name|line_count
operator|>
literal|0
condition|)
name|start
operator|=
name|window
operator|->
name|line_starts
index|[
literal|1
index|]
operator|-
name|window
operator|->
name|node
operator|->
name|contents
expr_stmt|;
else|else
name|start
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
name|info_target_search_node
argument_list|(
name|window
operator|->
name|node
argument_list|,
name|entry
operator|->
name|label
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
operator|-
literal|1
condition|)
block|{
name|window
operator|->
name|point
operator|=
name|offset
expr_stmt|;
name|window_adjust_pagetop
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|defentry
condition|)
block|{
name|free
argument_list|(
name|defentry
operator|->
name|label
argument_list|)
expr_stmt|;
name|maybe_free
argument_list|(
name|defentry
operator|->
name|filename
argument_list|)
expr_stmt|;
name|maybe_free
argument_list|(
name|defentry
operator|->
name|nodename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|defentry
argument_list|)
expr_stmt|;
block|}
block|}
name|info_free_references
argument_list|(
name|menu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info_error_was_printed
condition|)
name|window_clear_echo_area
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Read a line (with completion) which is the name of a menu item,    and select that item. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_menu_item
argument_list|,
argument|_(
literal|"Read a menu item and select its node"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|info_menu_or_ref_item
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|,
name|info_menu_of_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Read a line (with completion) which is the name of a reference to    follow, and select the node. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_xref_item
argument_list|,
argument|_(
literal|"Read a footnote or cross reference and select its node"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|info_menu_or_ref_item
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|,
name|info_xrefs_of_node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Position the cursor at the start of this node's menu. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_find_menu
argument_list|,
argument|_(
literal|"Move to the start of this node's menu"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|SEARCH_BINDING
name|binding
decl_stmt|;
name|long
name|position
decl_stmt|;
name|binding
operator|.
name|buffer
operator|=
name|window
operator|->
name|node
operator|->
name|contents
expr_stmt|;
name|binding
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|binding
operator|.
name|end
operator|=
name|window
operator|->
name|node
operator|->
name|nodelen
expr_stmt|;
name|binding
operator|.
name|flags
operator|=
name|S_FoldCase
operator||
name|S_SkipDest
expr_stmt|;
name|position
operator|=
name|search
argument_list|(
name|INFO_MENU_LABEL
argument_list|,
operator|&
name|binding
argument_list|)
expr_stmt|;
if|if
condition|(
name|position
operator|==
operator|-
literal|1
condition|)
name|info_error
argument_list|(
name|msg_no_menu_node
argument_list|)
expr_stmt|;
else|else
block|{
name|window
operator|->
name|point
operator|=
name|position
expr_stmt|;
name|window_adjust_pagetop
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|window
operator|->
name|flags
operator||=
name|W_UpdateWindow
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Visit as many menu items as is possible, each in a separate window. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_visit_menu
argument_list|,
argument|_(
literal|"Visit as many menu items at once as possible"
argument|)
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|REFERENCE
modifier|*
name|entry
decl_stmt|,
modifier|*
modifier|*
name|menu
decl_stmt|;
name|menu
operator|=
name|info_menu_of_node
argument_list|(
name|window
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|menu
condition|)
name|info_error
argument_list|(
name|msg_no_menu_node
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|!
name|info_error_was_printed
operator|)
operator|&&
operator|(
name|entry
operator|=
name|menu
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|WINDOW
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|window_make_window
argument_list|(
name|window
operator|->
name|node
argument_list|)
expr_stmt|;
name|window_tile_windows
argument_list|(
name|TILE_INTERNALS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
name|info_error
argument_list|(
name|msg_win_too_small
argument_list|)
expr_stmt|;
else|else
block|{
name|active_window
operator|=
name|new
expr_stmt|;
name|info_select_reference
argument_list|(
name|new
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Read a line of input which is a node name, and go to that node. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_goto_node
argument_list|,
argument|_(
literal|"Read a node name and select it"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|line
decl_stmt|;
define|#
directive|define
name|GOTO_COMPLETES
if|#
directive|if
name|defined
argument_list|(
name|GOTO_COMPLETES
argument_list|)
comment|/* Build a completion list of all of the known nodes. */
block|{
specifier|register
name|int
name|fbi
decl_stmt|,
name|i
decl_stmt|;
name|FILE_BUFFER
modifier|*
name|current
decl_stmt|;
name|REFERENCE
modifier|*
modifier|*
name|items
init|=
operator|(
name|REFERENCE
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|items_index
init|=
literal|0
decl_stmt|;
name|int
name|items_slots
init|=
literal|0
decl_stmt|;
name|current
operator|=
name|file_buffer_of_window
argument_list|(
name|window
argument_list|)
expr_stmt|;
for|for
control|(
name|fbi
operator|=
literal|0
init|;
name|info_loaded_files
operator|&&
name|info_loaded_files
index|[
name|fbi
index|]
condition|;
name|fbi
operator|++
control|)
block|{
name|FILE_BUFFER
modifier|*
name|fb
decl_stmt|;
name|REFERENCE
modifier|*
name|entry
decl_stmt|;
name|int
name|this_is_the_current_fb
decl_stmt|;
name|fb
operator|=
name|info_loaded_files
index|[
name|fbi
index|]
expr_stmt|;
name|this_is_the_current_fb
operator|=
operator|(
name|current
operator|==
name|fb
operator|)
expr_stmt|;
name|entry
operator|=
operator|(
name|REFERENCE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|REFERENCE
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|filename
operator|=
name|entry
operator|->
name|nodename
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|entry
operator|->
name|label
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|4
operator|+
name|strlen
argument_list|(
name|fb
operator|->
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|entry
operator|->
name|label
argument_list|,
literal|"(%s)*"
argument_list|,
name|fb
operator|->
name|filename
argument_list|)
expr_stmt|;
name|add_pointer_to_array
argument_list|(
name|entry
argument_list|,
name|items_index
argument_list|,
name|items
argument_list|,
name|items_slots
argument_list|,
literal|10
argument_list|,
name|REFERENCE
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|fb
operator|->
name|tags
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|fb
operator|->
name|tags
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
operator|(
name|REFERENCE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|REFERENCE
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|filename
operator|=
name|entry
operator|->
name|nodename
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|this_is_the_current_fb
condition|)
name|entry
operator|->
name|label
operator|=
name|xstrdup
argument_list|(
name|fb
operator|->
name|tags
index|[
name|i
index|]
operator|->
name|nodename
argument_list|)
expr_stmt|;
else|else
block|{
name|entry
operator|->
name|label
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|4
operator|+
name|strlen
argument_list|(
name|fb
operator|->
name|filename
argument_list|)
operator|+
name|strlen
argument_list|(
name|fb
operator|->
name|tags
index|[
name|i
index|]
operator|->
name|nodename
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|entry
operator|->
name|label
argument_list|,
literal|"(%s)%s"
argument_list|,
name|fb
operator|->
name|filename
argument_list|,
name|fb
operator|->
name|tags
index|[
name|i
index|]
operator|->
name|nodename
argument_list|)
expr_stmt|;
block|}
name|add_pointer_to_array
argument_list|(
name|entry
argument_list|,
name|items_index
argument_list|,
name|items
argument_list|,
name|items_slots
argument_list|,
literal|100
argument_list|,
name|REFERENCE
operator|*
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|line
operator|=
name|info_read_maybe_completing
argument_list|(
name|window
argument_list|,
name|_
argument_list|(
literal|"Goto node: "
argument_list|)
argument_list|,
name|items
argument_list|)
expr_stmt|;
name|info_free_references
argument_list|(
name|items
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !GOTO_COMPLETES */
name|line
operator|=
name|info_read_in_echo_area
argument_list|(
name|window
argument_list|,
name|_
argument_list|(
literal|"Goto node: "
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !GOTO_COMPLETES */
comment|/* If the user aborted, quit now. */
if|if
condition|(
operator|!
name|line
condition|)
block|{
name|info_abort_key
argument_list|(
name|window
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|canonicalize_whitespace
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|line
condition|)
name|info_parse_and_select
argument_list|(
name|line
argument_list|,
name|window
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info_error_was_printed
condition|)
name|window_clear_echo_area
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Follow the menu list in MENUS (list of strings terminated by a NULL    entry) from INITIAL_NODE.  If can't continue at any point (no menu or    no menu entry for the next item), return the node so far -- that    might be INITIAL_NODE itself.  If error, *ERRSTR and *ERRARG[12] will    be set to the error message and argument for message, otherwise they    will be NULL.  */
end_comment

begin_function
name|NODE
modifier|*
name|info_follow_menus
parameter_list|(
name|initial_node
parameter_list|,
name|menus
parameter_list|,
name|errstr
parameter_list|,
name|errarg1
parameter_list|,
name|errarg2
parameter_list|)
name|NODE
modifier|*
name|initial_node
decl_stmt|;
name|char
modifier|*
modifier|*
name|menus
decl_stmt|;
name|char
modifier|*
modifier|*
name|errstr
decl_stmt|,
decl|*
modifier|*
name|errarg1
decl_stmt|,
modifier|*
modifier|*
name|errarg2
decl_stmt|;
end_function

begin_block
block|{
name|NODE
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
operator|*
name|errstr
operator|=
operator|*
name|errarg1
operator|=
operator|*
name|errarg2
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
operator|*
name|menus
condition|;
name|menus
operator|++
control|)
block|{
specifier|static
name|char
modifier|*
name|first_arg
init|=
name|NULL
decl_stmt|;
name|REFERENCE
modifier|*
modifier|*
name|menu
decl_stmt|;
name|REFERENCE
modifier|*
name|entry
decl_stmt|;
name|char
modifier|*
name|arg
init|=
operator|*
name|menus
decl_stmt|;
comment|/* Remember the name of the menu entry we want. */
comment|/* A leading space is certainly NOT part of a node name.  Most 	 probably, they typed a space after the separating comma.  The 	 strings in menus[] have their whitespace canonicalized, so 	 there's at most one space to ignore.  */
if|if
condition|(
operator|*
name|arg
operator|==
literal|' '
condition|)
name|arg
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|first_arg
condition|)
name|first_arg
operator|=
name|arg
expr_stmt|;
comment|/* Build and return a list of the menu items in this node. */
name|menu
operator|=
name|info_menu_of_node
argument_list|(
name|initial_node
argument_list|)
expr_stmt|;
comment|/* If no menu item in this node, stop here, but let the user          continue to use Info.  Perhaps they wanted this node and didn't          realize it. */
if|if
condition|(
operator|!
name|menu
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|first_arg
condition|)
block|{
name|node
operator|=
name|make_manpage_node
argument_list|(
name|first_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
goto|goto
name|maybe_got_node
goto|;
block|}
operator|*
name|errstr
operator|=
name|_
argument_list|(
literal|"No menu in node `%s'."
argument_list|)
expr_stmt|;
operator|*
name|errarg1
operator|=
name|node_printed_rep
argument_list|(
name|initial_node
argument_list|)
expr_stmt|;
return|return
name|initial_node
return|;
block|}
comment|/* Find the specified menu item. */
name|entry
operator|=
name|info_get_labeled_reference
argument_list|(
name|arg
argument_list|,
name|menu
argument_list|)
expr_stmt|;
comment|/* If the item wasn't found, search the list sloppily.  Perhaps this          user typed "buffer" when they really meant "Buffers". */
if|if
condition|(
operator|!
name|entry
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|best_guess
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|entry
operator|=
name|menu
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|entry
operator|->
name|label
argument_list|,
name|arg
argument_list|)
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|entry
operator|->
name|label
argument_list|,
name|arg
argument_list|,
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|best_guess
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|entry
operator|&&
name|best_guess
operator|!=
operator|-
literal|1
condition|)
name|entry
operator|=
name|menu
index|[
name|best_guess
index|]
expr_stmt|;
block|}
comment|/* If we still failed to find the reference, start Info with the current          node anyway.  It is probably a misspelling. */
if|if
condition|(
operator|!
name|entry
condition|)
block|{
if|if
condition|(
name|arg
operator|==
name|first_arg
condition|)
block|{
comment|/* Maybe they typed "info foo" instead of "info -f foo".  */
name|node
operator|=
name|info_get_node
argument_list|(
name|first_arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
name|add_file_directory_to_path
argument_list|(
name|first_arg
argument_list|)
expr_stmt|;
else|else
name|node
operator|=
name|make_manpage_node
argument_list|(
name|first_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
goto|goto
name|maybe_got_node
goto|;
block|}
name|info_free_references
argument_list|(
name|menu
argument_list|)
expr_stmt|;
operator|*
name|errstr
operator|=
name|_
argument_list|(
literal|"No menu item `%s' in node `%s'."
argument_list|)
expr_stmt|;
operator|*
name|errarg1
operator|=
name|arg
expr_stmt|;
operator|*
name|errarg2
operator|=
name|node_printed_rep
argument_list|(
name|initial_node
argument_list|)
expr_stmt|;
return|return
name|initial_node
return|;
block|}
comment|/* We have found the reference that the user specified.  If no          filename in this reference, define it. */
if|if
condition|(
operator|!
name|entry
operator|->
name|filename
condition|)
name|entry
operator|->
name|filename
operator|=
name|xstrdup
argument_list|(
name|initial_node
operator|->
name|parent
condition|?
name|initial_node
operator|->
name|parent
else|:
name|initial_node
operator|->
name|filename
argument_list|)
expr_stmt|;
comment|/* Try to find this node.  */
name|node
operator|=
name|info_get_node
argument_list|(
name|entry
operator|->
name|filename
argument_list|,
name|entry
operator|->
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|&&
name|arg
operator|==
name|first_arg
condition|)
block|{
name|node
operator|=
name|make_manpage_node
argument_list|(
name|first_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
goto|goto
name|maybe_got_node
goto|;
block|}
comment|/* Since we cannot find it, try using the label of the entry as a          file, i.e., "(LABEL)Top".  */
if|if
condition|(
operator|!
name|node
operator|&&
name|entry
operator|->
name|nodename
operator|&&
name|strcmp
argument_list|(
name|entry
operator|->
name|label
argument_list|,
name|entry
operator|->
name|nodename
argument_list|)
operator|==
literal|0
condition|)
name|node
operator|=
name|info_get_node
argument_list|(
name|entry
operator|->
name|label
argument_list|,
literal|"Top"
argument_list|)
expr_stmt|;
name|maybe_got_node
label|:
if|if
condition|(
operator|!
name|node
condition|)
block|{
operator|*
name|errstr
operator|=
name|_
argument_list|(
literal|"Unable to find node referenced by `%s' in `%s'."
argument_list|)
expr_stmt|;
operator|*
name|errarg1
operator|=
name|xstrdup
argument_list|(
name|entry
operator|->
name|label
argument_list|)
expr_stmt|;
operator|*
name|errarg2
operator|=
name|node_printed_rep
argument_list|(
name|initial_node
argument_list|)
expr_stmt|;
name|info_free_references
argument_list|(
name|menu
argument_list|)
expr_stmt|;
return|return
name|initial_node
return|;
block|}
name|info_free_references
argument_list|(
name|menu
argument_list|)
expr_stmt|;
comment|/* Success.  Go round the loop again.  */
name|free
argument_list|(
name|initial_node
argument_list|)
expr_stmt|;
name|initial_node
operator|=
name|node
expr_stmt|;
block|}
return|return
name|initial_node
return|;
block|}
end_block

begin_comment
comment|/* Split STR into individual node names by writing null bytes in wherever    there are commas and constructing a list of the resulting pointers.    (We can do this since STR has had canonicalize_whitespace called on it.)    Return array terminated with NULL.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|split_list_of_nodenames
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|unsigned
name|len
init|=
literal|2
decl_stmt|;
name|char
modifier|*
modifier|*
name|nodes
init|=
name|xmalloc
argument_list|(
name|len
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|nodes
index|[
name|len
operator|-
literal|2
index|]
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|*
name|str
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|','
condition|)
block|{
operator|*
name|str
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* get past the null byte */
name|len
operator|++
expr_stmt|;
name|nodes
operator|=
name|xrealloc
argument_list|(
name|nodes
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|nodes
index|[
name|len
operator|-
literal|2
index|]
operator|=
name|str
expr_stmt|;
block|}
block|}
name|nodes
index|[
name|len
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|nodes
return|;
block|}
end_function

begin_comment
comment|/* Read a line of input which is a sequence of menus (starting from    dir), and follow them.  */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_menu_sequence
argument_list|,
argument|_(
literal|"Read a list of menus starting from dir and follow them"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|line
init|=
name|info_read_in_echo_area
argument_list|(
name|window
argument_list|,
name|_
argument_list|(
literal|"Follow menus: "
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If the user aborted, quit now. */
if|if
condition|(
operator|!
name|line
condition|)
block|{
name|info_abort_key
argument_list|(
name|window
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|canonicalize_whitespace
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|line
condition|)
block|{
name|char
modifier|*
name|errstr
decl_stmt|,
modifier|*
name|errarg1
decl_stmt|,
modifier|*
name|errarg2
decl_stmt|;
name|NODE
modifier|*
name|dir_node
init|=
name|info_get_node
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|nodes
init|=
name|split_list_of_nodenames
argument_list|(
name|line
argument_list|)
decl_stmt|;
name|NODE
modifier|*
name|node
decl_stmt|;
comment|/* If DIR_NODE is NULL, they might be reading a file directly, 	 like in "info -d . -f ./foo".  Try using "Top" instead.  */
if|if
condition|(
operator|!
name|dir_node
condition|)
block|{
name|char
modifier|*
name|file_name
init|=
name|window
operator|->
name|node
operator|->
name|parent
decl_stmt|;
if|if
condition|(
operator|!
name|file_name
condition|)
name|file_name
operator|=
name|window
operator|->
name|node
operator|->
name|filename
expr_stmt|;
name|dir_node
operator|=
name|info_get_node
argument_list|(
name|file_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* If we still cannot find the starting point, give up. 	 We cannot allow a NULL pointer inside info_follow_menus.  */
if|if
condition|(
operator|!
name|dir_node
condition|)
name|info_error
argument_list|(
name|msg_cant_find_node
argument_list|,
literal|"Top"
argument_list|)
expr_stmt|;
else|else
name|node
operator|=
name|info_follow_menus
argument_list|(
name|dir_node
argument_list|,
name|nodes
argument_list|,
operator|&
name|errstr
argument_list|,
operator|&
name|errarg1
argument_list|,
operator|&
name|errarg2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nodes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|errstr
condition|)
name|info_set_node_of_window
argument_list|(
literal|1
argument_list|,
name|window
argument_list|,
name|node
argument_list|)
expr_stmt|;
else|else
name|info_error
argument_list|(
name|errstr
argument_list|,
name|errarg1
argument_list|,
name|errarg2
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info_error_was_printed
condition|)
name|window_clear_echo_area
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Search the menu MENU for a (possibly mis-spelled) entry ARG.    Return the menu entry, or the best guess for what they meant by ARG,    or NULL if there's nothing in this menu seems to fit the bill.    If EXACT is non-zero, allow only exact matches.  */
end_comment

begin_function
specifier|static
name|REFERENCE
modifier|*
name|entry_in_menu
parameter_list|(
name|arg
parameter_list|,
name|menu
parameter_list|,
name|exact
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|REFERENCE
modifier|*
modifier|*
name|menu
decl_stmt|;
name|int
name|exact
decl_stmt|;
block|{
name|REFERENCE
modifier|*
name|entry
decl_stmt|;
comment|/* First, try to find the specified menu item verbatim.  */
name|entry
operator|=
name|info_get_labeled_reference
argument_list|(
name|arg
argument_list|,
name|menu
argument_list|)
expr_stmt|;
comment|/* If the item wasn't found, search the list sloppily.  Perhaps we      have "Option Summary", but ARG is "option".  */
if|if
condition|(
operator|!
name|entry
operator|&&
operator|!
name|exact
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|best_guess
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|entry
operator|=
name|menu
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|entry
operator|->
name|label
argument_list|,
name|arg
argument_list|)
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|entry
operator|->
name|label
argument_list|,
name|arg
argument_list|,
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|best_guess
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|entry
operator|&&
name|best_guess
operator|!=
operator|-
literal|1
condition|)
name|entry
operator|=
name|menu
index|[
name|best_guess
index|]
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Find the node that is the best candidate to list the PROGRAM's    invocation info and its command-line options, by looking for menu    items and chains of menu items with characteristic names.  */
end_comment

begin_function
name|void
name|info_intuit_options_node
parameter_list|(
name|window
parameter_list|,
name|initial_node
parameter_list|,
name|program
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|NODE
modifier|*
name|initial_node
decl_stmt|;
name|char
modifier|*
name|program
decl_stmt|;
block|{
comment|/* The list of node names typical for GNU manuals where the program      usage and specifically the command-line arguments are described.      This is pure heuristics.  I gathered these node names by looking      at all the Info files I could put my hands on.  If you are      looking for evidence to complain to the GNU project about      non-uniform style of documentation, here you have your case!  */
specifier|static
specifier|const
name|char
modifier|*
name|invocation_nodes
index|[]
init|=
block|{
literal|"%s invocation"
block|,
literal|"Invoking %s"
block|,
literal|"Preliminaries"
block|,
comment|/* m4 has Invoking under Preliminaries! */
literal|"Invocation"
block|,
literal|"Command Arguments"
block|,
comment|/* Emacs */
literal|"Invoking `%s'"
block|,
literal|"%s options"
block|,
literal|"Options"
block|,
literal|"Option "
block|,
comment|/* e.g. "Option Summary" */
literal|"Invoking"
block|,
literal|"All options"
block|,
comment|/* tar, paxutils */
literal|"Arguments"
block|,
literal|"%s cmdline"
block|,
comment|/* ar */
literal|"%s"
block|,
comment|/* last resort */
operator|(
specifier|const
name|char
operator|*
operator|)
literal|0
block|}
decl_stmt|;
name|NODE
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|REFERENCE
modifier|*
modifier|*
name|menu
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|try_node
decl_stmt|;
comment|/* We keep looking deeper and deeper in the menu structure until      there are no more menus or no menu items from the above list.      Some manuals have the invocation node sitting 3 or 4 levels deep      in the menu hierarchy...  */
for|for
control|(
name|node
operator|=
name|initial_node
init|;
name|node
condition|;
name|initial_node
operator|=
name|node
control|)
block|{
name|REFERENCE
modifier|*
name|entry
decl_stmt|;
comment|/* Build and return a list of the menu items in this node. */
name|menu
operator|=
name|info_menu_of_node
argument_list|(
name|initial_node
argument_list|)
expr_stmt|;
comment|/* If no menu item in this node, stop here.  Perhaps this node 	 is the one they need.  */
if|if
condition|(
operator|!
name|menu
condition|)
break|break;
comment|/* Look for node names typical for usage nodes in this menu.  */
for|for
control|(
name|try_node
operator|=
name|invocation_nodes
init|;
operator|*
name|try_node
condition|;
name|try_node
operator|++
control|)
block|{
name|char
name|nodename
index|[
literal|200
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|nodename
argument_list|,
operator|*
name|try_node
argument_list|,
name|program
argument_list|)
expr_stmt|;
comment|/* The last resort "%s" is dangerous, so we restrict it              to exact matches here.  */
name|entry
operator|=
name|entry_in_menu
argument_list|(
name|nodename
argument_list|,
name|menu
argument_list|,
name|strcmp
argument_list|(
operator|*
name|try_node
argument_list|,
literal|"%s"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|entry
condition|)
break|break;
if|if
condition|(
operator|!
name|entry
operator|->
name|filename
condition|)
name|entry
operator|->
name|filename
operator|=
name|xstrdup
argument_list|(
name|initial_node
operator|->
name|parent
condition|?
name|initial_node
operator|->
name|parent
else|:
name|initial_node
operator|->
name|filename
argument_list|)
expr_stmt|;
comment|/* Try to find this node.  */
name|node
operator|=
name|info_get_node
argument_list|(
name|entry
operator|->
name|filename
argument_list|,
name|entry
operator|->
name|nodename
argument_list|)
expr_stmt|;
name|info_free_references
argument_list|(
name|menu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
break|break;
block|}
comment|/* We've got our best shot at the invocation node.  Now select it.  */
if|if
condition|(
name|initial_node
condition|)
name|info_set_node_of_window
argument_list|(
literal|1
argument_list|,
name|window
argument_list|,
name|initial_node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info_error_was_printed
condition|)
name|window_clear_echo_area
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a name of an Info file, find the name of the package it    describes by removing the leading directories and extensions.  */
end_comment

begin_function
name|char
modifier|*
name|program_name_from_file_name
parameter_list|(
name|file_name
parameter_list|)
name|char
modifier|*
name|file_name
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|program_name
init|=
name|xstrdup
argument_list|(
name|filename_non_directory
argument_list|(
name|file_name
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|program_name
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|program_name
index|[
name|i
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|FILENAME_CMPN
argument_list|(
name|program_name
operator|+
name|i
argument_list|,
literal|".info"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|||
name|FILENAME_CMPN
argument_list|(
name|program_name
operator|+
name|i
argument_list|,
literal|".inf"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
ifdef|#
directive|ifdef
name|__MSDOS__
operator|||
name|FILENAME_CMPN
argument_list|(
name|program_name
operator|+
name|i
argument_list|,
literal|".i"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
endif|#
directive|endif
operator|||
name|isdigit
argument_list|(
name|program_name
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|)
condition|)
comment|/* a man page foo.1 */
block|{
name|program_name
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|program_name
return|;
block|}
end_function

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_goto_invocation_node
argument_list|,
argument|_(
literal|"Find the node describing program invocation"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|invocation_prompt
init|=
name|_
argument_list|(
literal|"Find Invocation node of [%s]: "
argument_list|)
decl_stmt|;
name|char
modifier|*
name|program_name
decl_stmt|,
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|default_program_name
decl_stmt|,
modifier|*
name|prompt
decl_stmt|,
modifier|*
name|file_name
decl_stmt|;
name|NODE
modifier|*
name|top_node
decl_stmt|;
comment|/* Intuit the name of the program they are likely to want.      We use the file name of the current Info file as a hint.  */
name|file_name
operator|=
name|window
operator|->
name|node
operator|->
name|parent
condition|?
name|window
operator|->
name|node
operator|->
name|parent
else|:
name|window
operator|->
name|node
operator|->
name|filename
expr_stmt|;
name|default_program_name
operator|=
name|program_name_from_file_name
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
name|prompt
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|default_program_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|invocation_prompt
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|prompt
argument_list|,
name|invocation_prompt
argument_list|,
name|default_program_name
argument_list|)
expr_stmt|;
name|line
operator|=
name|info_read_in_echo_area
argument_list|(
name|window
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|line
condition|)
block|{
name|info_abort_key
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|line
condition|)
name|program_name
operator|=
name|line
expr_stmt|;
else|else
name|program_name
operator|=
name|default_program_name
expr_stmt|;
comment|/* In interactive usage they'd probably expect us to begin looking      from the Top node.  */
name|top_node
operator|=
name|info_get_node
argument_list|(
name|file_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|top_node
condition|)
name|info_error
argument_list|(
name|msg_cant_find_node
argument_list|,
literal|"Top"
argument_list|)
expr_stmt|;
name|info_intuit_options_node
argument_list|(
name|window
argument_list|,
name|top_node
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|default_program_name
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MAN_PAGES
argument_list|)
end_if

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_man
argument_list|,
argument|_(
literal|"Read a manpage reference and select it"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|line
operator|=
name|info_read_in_echo_area
argument_list|(
name|window
argument_list|,
name|_
argument_list|(
literal|"Get Manpage: "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|line
condition|)
block|{
name|info_abort_key
argument_list|(
name|window
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|canonicalize_whitespace
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|line
condition|)
block|{
name|char
modifier|*
name|goto_command
decl_stmt|;
name|goto_command
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|4
operator|+
name|strlen
argument_list|(
name|MANPAGE_FILE_BUFFER_NAME
argument_list|)
operator|+
name|strlen
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|goto_command
argument_list|,
literal|"(%s)%s"
argument_list|,
name|MANPAGE_FILE_BUFFER_NAME
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|info_parse_and_select
argument_list|(
name|goto_command
argument_list|,
name|window
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|goto_command
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info_error_was_printed
condition|)
name|window_clear_echo_area
argument_list|()
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HANDLE_MAN_PAGES */
end_comment

begin_comment
comment|/* Move to the "Top" node in this file. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_top_node
argument_list|,
argument|_(
literal|"Select the node `Top' in this file"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|info_parse_and_select
argument_list|(
literal|"Top"
argument_list|,
name|window
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Move to the node "(dir)Top". */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_dir_node
argument_list|,
argument|_(
literal|"Select the node `(dir)'"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|info_parse_and_select
argument_list|(
literal|"(dir)Top"
argument_list|,
name|window
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Read the name of a node to kill.  The list of available nodes comes    from the nodes appearing in the current window configuration. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|read_nodename_to_kill
parameter_list|(
name|window
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
block|{
name|int
name|iw
decl_stmt|;
name|char
modifier|*
name|nodename
decl_stmt|;
name|INFO_WINDOW
modifier|*
name|info_win
decl_stmt|;
name|REFERENCE
modifier|*
modifier|*
name|menu
init|=
name|NULL
decl_stmt|;
name|int
name|menu_index
init|=
literal|0
decl_stmt|,
name|menu_slots
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|default_nodename
init|=
name|xstrdup
argument_list|(
name|active_window
operator|->
name|node
operator|->
name|nodename
argument_list|)
decl_stmt|;
name|char
modifier|*
name|prompt
init|=
name|xmalloc
argument_list|(
literal|40
operator|+
name|strlen
argument_list|(
name|default_nodename
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|prompt
argument_list|,
name|_
argument_list|(
literal|"Kill node (%s): "
argument_list|)
argument_list|,
name|default_nodename
argument_list|)
expr_stmt|;
for|for
control|(
name|iw
operator|=
literal|0
init|;
operator|(
name|info_win
operator|=
name|info_windows
index|[
name|iw
index|]
operator|)
condition|;
name|iw
operator|++
control|)
block|{
name|REFERENCE
modifier|*
name|entry
init|=
operator|(
name|REFERENCE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|REFERENCE
argument_list|)
argument_list|)
decl_stmt|;
name|entry
operator|->
name|label
operator|=
name|xstrdup
argument_list|(
name|info_win
operator|->
name|window
operator|->
name|node
operator|->
name|nodename
argument_list|)
expr_stmt|;
name|entry
operator|->
name|filename
operator|=
name|entry
operator|->
name|nodename
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|add_pointer_to_array
argument_list|(
name|entry
argument_list|,
name|menu_index
argument_list|,
name|menu
argument_list|,
name|menu_slots
argument_list|,
literal|10
argument_list|,
name|REFERENCE
operator|*
argument_list|)
expr_stmt|;
block|}
name|nodename
operator|=
name|info_read_completing_in_echo_area
argument_list|(
name|window
argument_list|,
name|prompt
argument_list|,
name|menu
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|info_free_references
argument_list|(
name|menu
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodename
operator|&&
operator|!
operator|*
name|nodename
condition|)
block|{
name|free
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
name|nodename
operator|=
name|default_nodename
expr_stmt|;
block|}
else|else
name|free
argument_list|(
name|default_nodename
argument_list|)
expr_stmt|;
return|return
name|nodename
return|;
block|}
end_function

begin_comment
comment|/* Delete NODENAME from this window, showing the most    recently selected node in this window. */
end_comment

begin_function
specifier|static
name|void
name|kill_node
parameter_list|(
name|window
parameter_list|,
name|nodename
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|char
modifier|*
name|nodename
decl_stmt|;
block|{
name|int
name|iw
decl_stmt|,
name|i
decl_stmt|;
name|INFO_WINDOW
modifier|*
name|info_win
decl_stmt|;
name|NODE
modifier|*
name|temp
decl_stmt|;
comment|/* If there is no nodename to kill, quit now. */
if|if
condition|(
operator|!
name|nodename
condition|)
block|{
name|info_abort_key
argument_list|(
name|window
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If there is a nodename, find it in our window list. */
for|for
control|(
name|iw
operator|=
literal|0
init|;
operator|(
name|info_win
operator|=
name|info_windows
index|[
name|iw
index|]
operator|)
condition|;
name|iw
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|nodename
argument_list|,
name|info_win
operator|->
name|nodes
index|[
name|info_win
operator|->
name|current
index|]
operator|->
name|nodename
argument_list|)
operator|==
literal|0
operator|&&
name|info_win
operator|->
name|window
operator|==
name|window
condition|)
break|break;
if|if
condition|(
operator|!
name|info_win
condition|)
block|{
if|if
condition|(
operator|*
name|nodename
condition|)
name|info_error
argument_list|(
name|_
argument_list|(
literal|"Cannot kill node `%s'"
argument_list|)
argument_list|,
name|nodename
argument_list|)
expr_stmt|;
else|else
name|window_clear_echo_area
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* If there are no more nodes left anywhere to view, complain and exit. */
if|if
condition|(
name|info_windows_index
operator|==
literal|1
operator|&&
name|info_windows
index|[
literal|0
index|]
operator|->
name|nodes_index
operator|==
literal|1
condition|)
block|{
name|info_error
argument_list|(
name|_
argument_list|(
literal|"Cannot kill the last node"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* INFO_WIN contains the node that the user wants to stop viewing.  Delete      this node from the list of nodes previously shown in this window. */
for|for
control|(
name|i
operator|=
name|info_win
operator|->
name|current
init|;
name|i
operator|<
name|info_win
operator|->
name|nodes_index
condition|;
name|i
operator|++
control|)
name|info_win
operator|->
name|nodes
index|[
name|i
index|]
operator|=
name|info_win
operator|->
name|nodes
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
comment|/* There is one less node in this window's history list. */
name|info_win
operator|->
name|nodes_index
operator|--
expr_stmt|;
comment|/* Make this window show the most recent history node. */
name|info_win
operator|->
name|current
operator|=
name|info_win
operator|->
name|nodes_index
operator|-
literal|1
expr_stmt|;
comment|/* If there aren't any nodes left in this window, steal one from the      next window. */
if|if
condition|(
name|info_win
operator|->
name|current
operator|<
literal|0
condition|)
block|{
name|INFO_WINDOW
modifier|*
name|stealer
decl_stmt|;
name|int
name|which
decl_stmt|,
name|pagetop
decl_stmt|;
name|long
name|point
decl_stmt|;
if|if
condition|(
name|info_windows
index|[
name|iw
operator|+
literal|1
index|]
condition|)
name|stealer
operator|=
name|info_windows
index|[
name|iw
operator|+
literal|1
index|]
expr_stmt|;
else|else
name|stealer
operator|=
name|info_windows
index|[
literal|0
index|]
expr_stmt|;
comment|/* If the node being displayed in the next window is not the most          recently loaded one, get the most recently loaded one. */
if|if
condition|(
operator|(
name|stealer
operator|->
name|nodes_index
operator|-
literal|1
operator|)
operator|!=
name|stealer
operator|->
name|current
condition|)
name|which
operator|=
name|stealer
operator|->
name|nodes_index
operator|-
literal|1
expr_stmt|;
comment|/* Else, if there is another node behind the stealers current node,          use that one. */
elseif|else
if|if
condition|(
name|stealer
operator|->
name|current
operator|>
literal|0
condition|)
name|which
operator|=
name|stealer
operator|->
name|current
operator|-
literal|1
expr_stmt|;
comment|/* Else, just use the node appearing in STEALER's window. */
else|else
name|which
operator|=
name|stealer
operator|->
name|current
expr_stmt|;
comment|/* Copy this node. */
block|{
name|NODE
modifier|*
name|copy
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NODE
argument_list|)
argument_list|)
decl_stmt|;
name|temp
operator|=
name|stealer
operator|->
name|nodes
index|[
name|which
index|]
expr_stmt|;
name|point
operator|=
name|stealer
operator|->
name|points
index|[
name|which
index|]
expr_stmt|;
name|pagetop
operator|=
name|stealer
operator|->
name|pagetops
index|[
name|which
index|]
expr_stmt|;
name|copy
operator|->
name|filename
operator|=
name|temp
operator|->
name|filename
expr_stmt|;
name|copy
operator|->
name|parent
operator|=
name|temp
operator|->
name|parent
expr_stmt|;
name|copy
operator|->
name|nodename
operator|=
name|temp
operator|->
name|nodename
expr_stmt|;
name|copy
operator|->
name|contents
operator|=
name|temp
operator|->
name|contents
expr_stmt|;
name|copy
operator|->
name|nodelen
operator|=
name|temp
operator|->
name|nodelen
expr_stmt|;
name|copy
operator|->
name|flags
operator|=
name|temp
operator|->
name|flags
expr_stmt|;
name|copy
operator|->
name|display_pos
operator|=
name|temp
operator|->
name|display_pos
expr_stmt|;
name|temp
operator|=
name|copy
expr_stmt|;
block|}
name|window_set_node_of_window
argument_list|(
name|info_win
operator|->
name|window
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|window
operator|->
name|point
operator|=
name|point
expr_stmt|;
name|window
operator|->
name|pagetop
operator|=
name|pagetop
expr_stmt|;
name|remember_window_and_node
argument_list|(
name|info_win
operator|->
name|window
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
name|info_win
operator|->
name|nodes
index|[
name|info_win
operator|->
name|current
index|]
expr_stmt|;
name|temp
operator|->
name|display_pos
operator|=
name|info_win
operator|->
name|points
index|[
name|info_win
operator|->
name|current
index|]
expr_stmt|;
name|window_set_node_of_window
argument_list|(
name|info_win
operator|->
name|window
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|info_error_was_printed
condition|)
name|window_clear_echo_area
argument_list|()
expr_stmt|;
if|if
condition|(
name|auto_footnotes_p
condition|)
name|info_get_or_remove_footnotes
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Kill current node, thus going back one in the node history.  I (karl)    do not think this is completely correct yet, because of the    window-changing stuff in kill_node, but it's a lot better than the    previous implementation, which did not account for nodes being    visited twice at all.  */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_history_node
argument_list|,
argument|_(
literal|"Select the most recently selected node"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|kill_node
argument_list|(
name|window
argument_list|,
name|active_window
operator|->
name|node
operator|->
name|nodename
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Kill named node.  */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_kill_node
argument_list|,
argument|_(
literal|"Kill this node"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|nodename
init|=
name|read_nodename_to_kill
argument_list|(
name|window
argument_list|)
decl_stmt|;
name|kill_node
argument_list|(
name|window
argument_list|,
name|nodename
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Read the name of a file and select the entire file. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_view_file
argument_list|,
argument|_(
literal|"Read the name of a file and select it"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|line
operator|=
name|info_read_in_echo_area
argument_list|(
name|window
argument_list|,
name|_
argument_list|(
literal|"Find file: "
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|line
condition|)
block|{
name|info_abort_key
argument_list|(
name|active_window
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|line
condition|)
block|{
name|NODE
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|info_get_node
argument_list|(
name|line
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
block|{
if|if
condition|(
name|info_recent_file_error
condition|)
name|info_error
argument_list|(
name|info_recent_file_error
argument_list|)
expr_stmt|;
else|else
name|info_error
argument_list|(
name|_
argument_list|(
literal|"Cannot find `%s'."
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
else|else
name|info_set_node_of_window
argument_list|(
literal|1
argument_list|,
name|window
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|info_error_was_printed
condition|)
name|window_clear_echo_area
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/*                 Dumping and Printing Nodes                       */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_define
define|#
directive|define
name|VERBOSE_NODE_DUMPING
end_define

begin_function_decl
specifier|static
name|void
name|write_node_to_stream
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_node_to_stream
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initialize_dumping
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Dump the nodes specified by FILENAME and NODENAMES to the file named    in OUTPUT_FILENAME.  If DUMP_SUBNODES is non-zero, recursively dump    the nodes which appear in the menu of each node dumped. */
end_comment

begin_function
name|void
name|dump_nodes_to_file
parameter_list|(
name|filename
parameter_list|,
name|nodenames
parameter_list|,
name|output_filename
parameter_list|,
name|dump_subnodes
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
modifier|*
name|nodenames
decl_stmt|;
name|char
modifier|*
name|output_filename
decl_stmt|;
name|int
name|dump_subnodes
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|output_stream
decl_stmt|;
comment|/* Get the stream to print the nodes to.  Special case of an output      filename of "-" means to dump the nodes to stdout. */
if|if
condition|(
name|strcmp
argument_list|(
name|output_filename
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|output_stream
operator|=
name|stdout
expr_stmt|;
else|else
name|output_stream
operator|=
name|fopen
argument_list|(
name|output_filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|output_stream
condition|)
block|{
name|info_error
argument_list|(
name|_
argument_list|(
literal|"Could not create output file `%s'."
argument_list|)
argument_list|,
name|output_filename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Print each node to stream. */
name|initialize_dumping
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|nodenames
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|dump_node_to_stream
argument_list|(
name|filename
argument_list|,
name|nodenames
index|[
name|i
index|]
argument_list|,
name|output_stream
argument_list|,
name|dump_subnodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_stream
operator|!=
name|stdout
condition|)
name|fclose
argument_list|(
name|output_stream
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VERBOSE_NODE_DUMPING
argument_list|)
name|info_error
argument_list|(
name|_
argument_list|(
literal|"Done."
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VERBOSE_NODE_DUMPING */
block|}
end_function

begin_comment
comment|/* A place to remember already dumped nodes. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|dumped_already
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dumped_already_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dumped_already_slots
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|initialize_dumping
parameter_list|()
block|{
name|dumped_already_index
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get and print the node specified by FILENAME and NODENAME to STREAM.    If DUMP_SUBNODES is non-zero, recursively dump the nodes which appear    in the menu of each node dumped. */
end_comment

begin_function
specifier|static
name|void
name|dump_node_to_stream
parameter_list|(
name|filename
parameter_list|,
name|nodename
parameter_list|,
name|stream
parameter_list|,
name|dump_subnodes
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|,
decl|*
name|nodename
decl_stmt|;
end_function

begin_decl_stmt
name|FILE
modifier|*
name|stream
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dump_subnodes
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|NODE
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|info_get_node
argument_list|(
name|filename
argument_list|,
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
block|{
if|if
condition|(
name|info_recent_file_error
condition|)
name|info_error
argument_list|(
name|info_recent_file_error
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|filename
operator|&&
operator|*
name|nodename
operator|!=
literal|'('
condition|)
name|info_error
argument_list|(
name|msg_cant_file_node
argument_list|,
name|filename_non_directory
argument_list|(
name|filename
argument_list|)
argument_list|,
name|nodename
argument_list|)
expr_stmt|;
else|else
name|info_error
argument_list|(
name|msg_cant_find_node
argument_list|,
name|nodename
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* If we have already dumped this node, don't dump it again. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dumped_already_index
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|node
operator|->
name|nodename
argument_list|,
name|dumped_already
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return;
block|}
name|add_pointer_to_array
argument_list|(
name|node
operator|->
name|nodename
argument_list|,
name|dumped_already_index
argument_list|,
name|dumped_already
argument_list|,
name|dumped_already_slots
argument_list|,
literal|50
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VERBOSE_NODE_DUMPING
argument_list|)
comment|/* Maybe we should print some information about the node being output. */
name|info_error
argument_list|(
name|_
argument_list|(
literal|"Writing node %s..."
argument_list|)
argument_list|,
name|node_printed_rep
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VERBOSE_NODE_DUMPING */
name|write_node_to_stream
argument_list|(
name|node
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* If we are dumping subnodes, get the list of menu items in this node,      and dump each one recursively. */
if|if
condition|(
name|dump_subnodes
condition|)
block|{
name|REFERENCE
modifier|*
modifier|*
name|menu
init|=
operator|(
name|REFERENCE
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* If this node is an Index, do not dump the menu references. */
if|if
condition|(
name|string_in_line
argument_list|(
literal|"Index"
argument_list|,
name|node
operator|->
name|nodename
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|menu
operator|=
name|info_menu_of_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|menu
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|menu
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
comment|/* We don't dump Info files which are different than the                  current one. */
if|if
condition|(
operator|!
name|menu
index|[
name|i
index|]
operator|->
name|filename
condition|)
name|dump_node_to_stream
argument_list|(
name|filename
argument_list|,
name|menu
index|[
name|i
index|]
operator|->
name|nodename
argument_list|,
name|stream
argument_list|,
name|dump_subnodes
argument_list|)
expr_stmt|;
block|}
name|info_free_references
argument_list|(
name|menu
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Dump NODE to FILENAME.  If DUMP_SUBNODES is non-zero, recursively dump    the nodes which appear in the menu of each node dumped. */
end_comment

begin_function
name|void
name|dump_node_to_file
parameter_list|(
name|node
parameter_list|,
name|filename
parameter_list|,
name|dump_subnodes
parameter_list|)
name|NODE
modifier|*
name|node
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|dump_subnodes
decl_stmt|;
block|{
name|FILE
modifier|*
name|output_stream
decl_stmt|;
name|char
modifier|*
name|nodes_filename
decl_stmt|;
comment|/* Get the stream to print this node to.  Special case of an output      filename of "-" means to dump the nodes to stdout. */
if|if
condition|(
name|strcmp
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|output_stream
operator|=
name|stdout
expr_stmt|;
else|else
name|output_stream
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|output_stream
condition|)
block|{
name|info_error
argument_list|(
name|_
argument_list|(
literal|"Could not create output file `%s'."
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|node
operator|->
name|parent
condition|)
name|nodes_filename
operator|=
name|node
operator|->
name|parent
expr_stmt|;
else|else
name|nodes_filename
operator|=
name|node
operator|->
name|filename
expr_stmt|;
name|initialize_dumping
argument_list|()
expr_stmt|;
name|dump_node_to_stream
argument_list|(
name|nodes_filename
argument_list|,
name|node
operator|->
name|nodename
argument_list|,
name|output_stream
argument_list|,
name|dump_subnodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_stream
operator|!=
name|stdout
condition|)
name|fclose
argument_list|(
name|output_stream
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VERBOSE_NODE_DUMPING
argument_list|)
name|info_error
argument_list|(
name|_
argument_list|(
literal|"Done."
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VERBOSE_NODE_DUMPING */
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DEFAULT_INFO_PRINT_COMMAND
argument_list|)
end_if

begin_define
define|#
directive|define
name|DEFAULT_INFO_PRINT_COMMAND
value|"lpr"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !DEFAULT_INFO_PRINT_COMMAND */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_print_node
argument_list|,
argument|_(
literal|"Pipe the contents of this node through INFO_PRINT_COMMAND"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|print_node
argument_list|(
name|window
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Print NODE on a printer piping it into INFO_PRINT_COMMAND. */
end_comment

begin_function
name|void
name|print_node
parameter_list|(
name|node
parameter_list|)
name|NODE
modifier|*
name|node
decl_stmt|;
block|{
name|FILE
modifier|*
name|printer_pipe
decl_stmt|;
name|char
modifier|*
name|print_command
init|=
name|getenv
argument_list|(
literal|"INFO_PRINT_COMMAND"
argument_list|)
decl_stmt|;
name|int
name|piping
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|print_command
operator|||
operator|!
operator|*
name|print_command
condition|)
name|print_command
operator|=
name|DEFAULT_INFO_PRINT_COMMAND
expr_stmt|;
comment|/* Note that on MS-DOS/MS-Windows, this MUST open the pipe in the      (default) text mode, since the printer drivers there need to see      DOS-style CRLF pairs at the end of each line.       FIXME: if we are to support Mac-style text files, we might need      to convert the text here.  */
comment|/* INFO_PRINT_COMMAND which says ">file" means write to that file.      Presumably, the name of the file is the local printer device.  */
if|if
condition|(
operator|*
name|print_command
operator|==
literal|'>'
condition|)
name|printer_pipe
operator|=
name|fopen
argument_list|(
operator|++
name|print_command
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
else|else
block|{
name|printer_pipe
operator|=
name|popen
argument_list|(
name|print_command
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|piping
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|printer_pipe
condition|)
block|{
name|info_error
argument_list|(
name|_
argument_list|(
literal|"Cannot open pipe to `%s'."
argument_list|)
argument_list|,
name|print_command
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|defined
argument_list|(
name|VERBOSE_NODE_DUMPING
argument_list|)
comment|/* Maybe we should print some information about the node being output. */
name|info_error
argument_list|(
name|_
argument_list|(
literal|"Printing node %s..."
argument_list|)
argument_list|,
name|node_printed_rep
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VERBOSE_NODE_DUMPING */
name|write_node_to_stream
argument_list|(
name|node
argument_list|,
name|printer_pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|piping
condition|)
name|pclose
argument_list|(
name|printer_pipe
argument_list|)
expr_stmt|;
else|else
name|fclose
argument_list|(
name|printer_pipe
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VERBOSE_NODE_DUMPING
argument_list|)
name|info_error
argument_list|(
name|_
argument_list|(
literal|"Done."
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VERBOSE_NODE_DUMPING */
block|}
end_function

begin_function
specifier|static
name|void
name|write_node_to_stream
parameter_list|(
name|node
parameter_list|,
name|stream
parameter_list|)
name|NODE
modifier|*
name|node
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fwrite
argument_list|(
name|node
operator|->
name|contents
argument_list|,
literal|1
argument_list|,
name|node
operator|->
name|nodelen
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/*                    Info Searching Commands                       */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Variable controlling the garbage collection of files briefly visited    during searches.  Such files are normally gc'ed, unless they were    compressed to begin with.  If this variable is non-zero, it says    to gc even those file buffer contents which had to be uncompressed. */
end_comment

begin_decl_stmt
name|int
name|gc_compressed_files
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|info_gc_file_buffers
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|info_search_1
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
modifier|*
name|search_string
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|search_string_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|search_string_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isearch_is_active
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|last_search_direction
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|last_search_case_sensitive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the file buffer which belongs to WINDOW's node. */
end_comment

begin_function
name|FILE_BUFFER
modifier|*
name|file_buffer_of_window
parameter_list|(
name|window
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
block|{
comment|/* If this window has no node, then it has no file buffer. */
if|if
condition|(
operator|!
name|window
operator|->
name|node
condition|)
return|return
operator|(
operator|(
name|FILE_BUFFER
operator|*
operator|)
name|NULL
operator|)
return|;
if|if
condition|(
name|window
operator|->
name|node
operator|->
name|parent
condition|)
return|return
operator|(
name|info_find_file
argument_list|(
name|window
operator|->
name|node
operator|->
name|parent
argument_list|)
operator|)
return|;
if|if
condition|(
name|window
operator|->
name|node
operator|->
name|filename
condition|)
return|return
operator|(
name|info_find_file
argument_list|(
name|window
operator|->
name|node
operator|->
name|filename
argument_list|)
operator|)
return|;
return|return
operator|(
operator|(
name|FILE_BUFFER
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search for STRING in NODE starting at START.  Return -1 if the string    was not found, or the location of the string if it was.  If WINDOW is    passed as non-null, set the window's node to be NODE, its point to be    the found string, and readjust the window's pagetop.  Final argument    DIR says which direction to search in.  If it is positive, search    forward, else backwards. */
end_comment

begin_function
name|long
name|info_search_in_node
parameter_list|(
name|string
parameter_list|,
name|node
parameter_list|,
name|start
parameter_list|,
name|window
parameter_list|,
name|dir
parameter_list|,
name|case_sensitive
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|NODE
modifier|*
name|node
decl_stmt|;
name|long
name|start
decl_stmt|;
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|int
name|dir
decl_stmt|,
name|case_sensitive
decl_stmt|;
block|{
name|SEARCH_BINDING
name|binding
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|binding
operator|.
name|buffer
operator|=
name|node
operator|->
name|contents
expr_stmt|;
name|binding
operator|.
name|start
operator|=
name|start
expr_stmt|;
name|binding
operator|.
name|end
operator|=
name|node
operator|->
name|nodelen
expr_stmt|;
name|binding
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|case_sensitive
condition|)
name|binding
operator|.
name|flags
operator||=
name|S_FoldCase
expr_stmt|;
if|if
condition|(
name|dir
operator|<
literal|0
condition|)
block|{
name|binding
operator|.
name|end
operator|=
literal|0
expr_stmt|;
name|binding
operator|.
name|flags
operator||=
name|S_SkipDest
expr_stmt|;
block|}
if|if
condition|(
name|binding
operator|.
name|start
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* For incremental searches, we always wish to skip past the string. */
if|if
condition|(
name|isearch_is_active
condition|)
name|binding
operator|.
name|flags
operator||=
name|S_SkipDest
expr_stmt|;
name|offset
operator|=
name|search
argument_list|(
name|string
argument_list|,
operator|&
name|binding
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
operator|-
literal|1
operator|&&
name|window
condition|)
block|{
name|set_remembered_pagetop_and_point
argument_list|(
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
name|window
operator|->
name|node
operator|!=
name|node
condition|)
name|window_set_node_of_window
argument_list|(
name|window
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|window
operator|->
name|point
operator|=
name|offset
expr_stmt|;
name|window_adjust_pagetop
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search NODE, looking for the largest possible match of STRING.  Start the    search at START.  Return the absolute position of the match, or -1, if    no part of the string could be found. */
end_comment

begin_function
name|long
name|info_target_search_node
parameter_list|(
name|node
parameter_list|,
name|string
parameter_list|,
name|start
parameter_list|)
name|NODE
modifier|*
name|node
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|long
name|start
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|char
modifier|*
name|target
decl_stmt|;
name|target
operator|=
name|xstrdup
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|target
argument_list|)
expr_stmt|;
comment|/* Try repeatedly searching for this string while removing words from      the end of it. */
while|while
condition|(
name|i
condition|)
block|{
name|target
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|offset
operator|=
name|info_search_in_node
argument_list|(
name|target
argument_list|,
name|node
argument_list|,
name|start
argument_list|,
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
operator|-
literal|1
condition|)
break|break;
comment|/* Delete the last word from TARGET. */
for|for
control|(
init|;
name|i
operator|&&
operator|(
operator|!
name|whitespace
argument_list|(
name|target
index|[
name|i
index|]
argument_list|)
operator|&&
operator|(
name|target
index|[
name|i
index|]
operator|!=
literal|','
operator|)
operator|)
condition|;
name|i
operator|--
control|)
empty_stmt|;
block|}
name|free
argument_list|(
name|target
argument_list|)
expr_stmt|;
return|return
operator|(
name|offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search for STRING starting in WINDOW at point.  If the string is found    in this node, set point to that position.  Otherwise, get the file buffer    associated with WINDOW's node, and search through each node in that file.    If the search fails, return non-zero, else zero.  Side-effect window    leaving the node and point where the string was found current. */
end_comment

begin_function
specifier|static
name|int
name|info_search_internal
parameter_list|(
name|string
parameter_list|,
name|window
parameter_list|,
name|dir
parameter_list|,
name|case_sensitive
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|int
name|dir
decl_stmt|,
name|case_sensitive
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|FILE_BUFFER
modifier|*
name|file_buffer
decl_stmt|;
name|char
modifier|*
name|initial_nodename
decl_stmt|;
name|long
name|ret
decl_stmt|,
name|start
init|=
literal|0
decl_stmt|;
name|file_buffer
operator|=
name|file_buffer_of_window
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|initial_nodename
operator|=
name|window
operator|->
name|node
operator|->
name|nodename
expr_stmt|;
comment|/* This used to begin from window->point, unless this was a repeated      search command.  But invoking search with an argument loses with      that logic, since info_last_executed_command is then set to      info_add_digit_to_numeric_arg.  I think there's no sense in      ``finding'' a string that is already under the cursor, anyway.  */
name|ret
operator|=
name|info_search_in_node
argument_list|(
name|string
argument_list|,
name|window
operator|->
name|node
argument_list|,
name|window
operator|->
name|point
operator|+
name|dir
argument_list|,
name|window
argument_list|,
name|dir
argument_list|,
name|case_sensitive
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* We won! */
if|if
condition|(
operator|!
name|echo_area_is_active
operator|&&
operator|!
name|isearch_is_active
condition|)
name|window_clear_echo_area
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* The string wasn't found in the current node.  Search through the      window's file buffer, iff the current node is not "*". */
if|if
condition|(
operator|!
name|file_buffer
operator|||
operator|(
name|strcmp
argument_list|(
name|initial_nodename
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* If this file has tags, search through every subfile, starting at      this node's subfile and node.  Otherwise, search through the      file's node list. */
if|if
condition|(
name|file_buffer
operator|->
name|tags
condition|)
block|{
specifier|register
name|int
name|current_tag
decl_stmt|,
name|number_of_tags
decl_stmt|;
name|char
modifier|*
name|last_subfile
decl_stmt|;
name|TAG
modifier|*
name|tag
decl_stmt|;
comment|/* Find number of tags and current tag. */
name|last_subfile
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|file_buffer
operator|->
name|tags
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|initial_nodename
argument_list|,
name|file_buffer
operator|->
name|tags
index|[
name|i
index|]
operator|->
name|nodename
argument_list|)
operator|==
literal|0
condition|)
block|{
name|current_tag
operator|=
name|i
expr_stmt|;
name|last_subfile
operator|=
name|file_buffer
operator|->
name|tags
index|[
name|i
index|]
operator|->
name|filename
expr_stmt|;
block|}
name|number_of_tags
operator|=
name|i
expr_stmt|;
comment|/* If there is no last_subfile, our tag wasn't found. */
if|if
condition|(
operator|!
name|last_subfile
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Search through subsequent nodes, wrapping around to the top          of the info file until we find the string or return to this          window's node and point. */
while|while
condition|(
literal|1
condition|)
block|{
name|NODE
modifier|*
name|node
decl_stmt|;
comment|/* Allow C-g to quit the search, failing it if pressed. */
name|return_if_control_g
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Find the next tag that isn't an anchor.  */
for|for
control|(
name|i
operator|=
name|current_tag
operator|+
name|dir
init|;
name|i
operator|!=
name|current_tag
condition|;
name|i
operator|+=
name|dir
control|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
name|number_of_tags
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|number_of_tags
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|tag
operator|=
name|file_buffer
operator|->
name|tags
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|tag
operator|->
name|nodelen
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* If we got past out starting point, bail out.  */
if|if
condition|(
name|i
operator|==
name|current_tag
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|current_tag
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|echo_area_is_active
operator|&&
operator|(
name|last_subfile
operator|!=
name|tag
operator|->
name|filename
operator|)
condition|)
block|{
name|window_message_in_echo_area
argument_list|(
name|_
argument_list|(
literal|"Searching subfile %s ..."
argument_list|)
argument_list|,
name|filename_non_directory
argument_list|(
name|tag
operator|->
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|last_subfile
operator|=
name|tag
operator|->
name|filename
expr_stmt|;
block|}
name|node
operator|=
name|info_get_node
argument_list|(
name|file_buffer
operator|->
name|filename
argument_list|,
name|tag
operator|->
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
block|{
comment|/* If not doing i-search... */
if|if
condition|(
operator|!
name|echo_area_is_active
condition|)
block|{
if|if
condition|(
name|info_recent_file_error
condition|)
name|info_error
argument_list|(
name|info_recent_file_error
argument_list|)
expr_stmt|;
else|else
name|info_error
argument_list|(
name|msg_cant_file_node
argument_list|,
name|filename_non_directory
argument_list|(
name|file_buffer
operator|->
name|filename
argument_list|)
argument_list|,
name|tag
operator|->
name|nodename
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dir
operator|<
literal|0
condition|)
name|start
operator|=
name|tag
operator|->
name|nodelen
expr_stmt|;
name|ret
operator|=
name|info_search_in_node
argument_list|(
name|string
argument_list|,
name|node
argument_list|,
name|start
argument_list|,
name|window
argument_list|,
name|dir
argument_list|,
name|case_sensitive
argument_list|)
expr_stmt|;
comment|/* Did we find the string in this node? */
if|if
condition|(
name|ret
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Yes!  We win. */
name|remember_window_and_node
argument_list|(
name|window
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|echo_area_is_active
condition|)
name|window_clear_echo_area
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* No.  Free this node, and make sure that we haven't passed              our starting point. */
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|initial_nodename
argument_list|,
name|tag
operator|->
name|nodename
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_search_case_sensitively
argument_list|,
argument|_(
literal|"Read a string and search for it case-sensitively"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|last_search_direction
operator|=
name|count
operator|>
literal|0
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
name|last_search_case_sensitive
operator|=
literal|1
expr_stmt|;
name|info_search_1
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_search
argument_list|,
argument|_(
literal|"Read a string and search for it"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|last_search_direction
operator|=
name|count
operator|>
literal|0
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
name|last_search_case_sensitive
operator|=
literal|0
expr_stmt|;
name|info_search_1
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_search_backward
argument_list|,
argument|_(
literal|"Read a string and search backward for it"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|last_search_direction
operator|=
name|count
operator|>
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
name|last_search_case_sensitive
operator|=
literal|0
expr_stmt|;
name|info_search_1
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|info_search_1
parameter_list|(
name|window
parameter_list|,
name|count
parameter_list|,
name|key
parameter_list|,
name|case_sensitive
parameter_list|,
name|ask_for_string
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|int
name|count
decl_stmt|;
name|unsigned
name|char
name|key
decl_stmt|;
name|int
name|case_sensitive
decl_stmt|;
name|int
name|ask_for_string
decl_stmt|;
block|{
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|prompt
decl_stmt|;
name|int
name|result
decl_stmt|,
name|old_pagetop
decl_stmt|;
name|int
name|direction
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|direction
operator|=
operator|-
literal|1
expr_stmt|;
name|count
operator|=
operator|-
name|count
expr_stmt|;
block|}
else|else
block|{
name|direction
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|count
operator|=
literal|1
expr_stmt|;
comment|/* for backward compatibility */
block|}
comment|/* Read a string from the user, defaulting the search to SEARCH_STRING. */
if|if
condition|(
operator|!
name|search_string
condition|)
block|{
name|search_string
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|search_string_size
operator|=
literal|100
argument_list|)
expr_stmt|;
name|search_string
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|ask_for_string
condition|)
block|{
name|prompt
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|50
operator|+
name|strlen
argument_list|(
name|search_string
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|prompt
argument_list|,
name|_
argument_list|(
literal|"%s%sfor string [%s]: "
argument_list|)
argument_list|,
name|direction
operator|<
literal|0
condition|?
name|_
argument_list|(
literal|"Search backward"
argument_list|)
else|:
name|_
argument_list|(
literal|"Search"
argument_list|)
argument_list|,
name|case_sensitive
condition|?
name|_
argument_list|(
literal|" case-sensitively "
argument_list|)
else|:
name|_
argument_list|(
literal|" "
argument_list|)
argument_list|,
name|search_string
argument_list|)
expr_stmt|;
name|line
operator|=
name|info_read_in_echo_area
argument_list|(
name|window
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|line
condition|)
block|{
name|info_abort_key
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|line
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|line
argument_list|)
operator|+
literal|1
operator|>
name|search_string_size
condition|)
name|search_string
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|search_string
argument_list|,
operator|(
name|search_string_size
operator|+=
literal|50
operator|+
name|strlen
argument_list|(
name|line
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|search_string
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|search_string_index
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the search string includes upper-case letters, make the search      case-sensitive.  */
if|if
condition|(
name|case_sensitive
operator|==
literal|0
condition|)
for|for
control|(
name|line
operator|=
name|search_string
init|;
operator|*
name|line
condition|;
name|line
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|line
argument_list|)
condition|)
block|{
name|case_sensitive
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|old_pagetop
operator|=
name|active_window
operator|->
name|pagetop
expr_stmt|;
for|for
control|(
name|result
operator|=
literal|0
init|;
name|result
operator|==
literal|0
operator|&&
name|count
operator|--
condition|;
control|)
name|result
operator|=
name|info_search_internal
argument_list|(
name|search_string
argument_list|,
name|active_window
argument_list|,
name|direction
argument_list|,
name|case_sensitive
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
operator|&&
operator|!
name|info_error_was_printed
condition|)
name|info_error
argument_list|(
name|_
argument_list|(
literal|"Search failed."
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|old_pagetop
operator|!=
name|active_window
operator|->
name|pagetop
condition|)
block|{
name|int
name|new_pagetop
decl_stmt|;
name|new_pagetop
operator|=
name|active_window
operator|->
name|pagetop
expr_stmt|;
name|active_window
operator|->
name|pagetop
operator|=
name|old_pagetop
expr_stmt|;
name|set_window_pagetop
argument_list|(
name|active_window
argument_list|,
name|new_pagetop
argument_list|)
expr_stmt|;
if|if
condition|(
name|auto_footnotes_p
condition|)
name|info_get_or_remove_footnotes
argument_list|(
name|active_window
argument_list|)
expr_stmt|;
block|}
comment|/* Perhaps free the unreferenced file buffers that were searched, but      not retained. */
name|info_gc_file_buffers
argument_list|()
expr_stmt|;
block|}
end_function

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_search_next
argument_list|,
argument|_(
literal|"Repeat last search in the same direction"
argument|)
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|last_search_direction
condition|)
name|info_error
argument_list|(
name|_
argument_list|(
literal|"No previous search string"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|info_search_1
argument_list|(
name|window
argument_list|,
name|last_search_direction
operator|*
name|count
argument_list|,
name|key
argument_list|,
name|last_search_case_sensitive
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_search_previous
argument_list|,
argument|_(
literal|"Repeat last search in the reverse direction"
argument|)
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|last_search_direction
condition|)
name|info_error
argument_list|(
name|_
argument_list|(
literal|"No previous search string"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|info_search_1
argument_list|(
name|window
argument_list|,
operator|-
name|last_search_direction
operator|*
name|count
argument_list|,
name|key
argument_list|,
name|last_search_case_sensitive
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/*                      Incremental Searching                       */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function_decl
specifier|static
name|void
name|incremental_search
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|isearch_forward
argument_list|,
argument|_(
literal|"Search interactively for a string as you type it"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|incremental_search
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|isearch_backward
argument_list|,
argument|_(
literal|"Search interactively for a string as you type it"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|incremental_search
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Incrementally search for a string as it is typed. */
end_comment

begin_comment
comment|/* The last accepted incremental search string. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_isearch_accepted
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current incremental search string. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|isearch_string
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isearch_string_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isearch_string_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|isearch_terminate_search_key
init|=
name|ESC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure defining the current state of an incremental search. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|WINDOW_STATE_DECL
expr_stmt|;
comment|/* The node, pagetop and point. */
name|int
name|search_index
decl_stmt|;
comment|/* Offset of the last char in the search string. */
name|int
name|direction
decl_stmt|;
comment|/* The direction that this search is heading in. */
name|int
name|failing
decl_stmt|;
comment|/* Whether or not this search failed. */
block|}
name|SEARCH_STATE
typedef|;
end_typedef

begin_comment
comment|/* Array of search states. */
end_comment

begin_decl_stmt
specifier|static
name|SEARCH_STATE
modifier|*
modifier|*
name|isearch_states
init|=
operator|(
name|SEARCH_STATE
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isearch_states_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isearch_states_slots
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Push the state of this search. */
end_comment

begin_function
specifier|static
name|void
name|push_isearch
parameter_list|(
name|window
parameter_list|,
name|search_index
parameter_list|,
name|direction
parameter_list|,
name|failing
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|int
name|search_index
decl_stmt|,
name|direction
decl_stmt|,
name|failing
decl_stmt|;
block|{
name|SEARCH_STATE
modifier|*
name|state
decl_stmt|;
name|state
operator|=
operator|(
name|SEARCH_STATE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SEARCH_STATE
argument_list|)
argument_list|)
expr_stmt|;
name|window_get_state
argument_list|(
name|window
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|state
operator|->
name|search_index
operator|=
name|search_index
expr_stmt|;
name|state
operator|->
name|direction
operator|=
name|direction
expr_stmt|;
name|state
operator|->
name|failing
operator|=
name|failing
expr_stmt|;
name|add_pointer_to_array
argument_list|(
name|state
argument_list|,
name|isearch_states_index
argument_list|,
name|isearch_states
argument_list|,
name|isearch_states_slots
argument_list|,
literal|20
argument_list|,
name|SEARCH_STATE
operator|*
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop the state of this search to WINDOW, SEARCH_INDEX, and DIRECTION. */
end_comment

begin_function
specifier|static
name|void
name|pop_isearch
parameter_list|(
name|window
parameter_list|,
name|search_index
parameter_list|,
name|direction
parameter_list|,
name|failing
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|int
modifier|*
name|search_index
decl_stmt|,
decl|*
name|direction
decl_stmt|,
modifier|*
name|failing
decl_stmt|;
end_function

begin_block
block|{
name|SEARCH_STATE
modifier|*
name|state
decl_stmt|;
if|if
condition|(
name|isearch_states_index
condition|)
block|{
name|isearch_states_index
operator|--
expr_stmt|;
name|state
operator|=
name|isearch_states
index|[
name|isearch_states_index
index|]
expr_stmt|;
name|window_set_state
argument_list|(
name|window
argument_list|,
name|state
argument_list|)
expr_stmt|;
operator|*
name|search_index
operator|=
name|state
operator|->
name|search_index
expr_stmt|;
operator|*
name|direction
operator|=
name|state
operator|->
name|direction
expr_stmt|;
operator|*
name|failing
operator|=
name|state
operator|->
name|failing
expr_stmt|;
name|free
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|isearch_states
index|[
name|isearch_states_index
index|]
operator|=
operator|(
name|SEARCH_STATE
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Free the memory used by isearch_states. */
end_comment

begin_function
specifier|static
name|void
name|free_isearch_states
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|isearch_states_index
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|isearch_states
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|isearch_states
index|[
name|i
index|]
operator|=
operator|(
name|SEARCH_STATE
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|isearch_states_index
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Display the current search in the echo area. */
end_comment

begin_function
specifier|static
name|void
name|show_isearch_prompt
parameter_list|(
name|dir
parameter_list|,
name|string
parameter_list|,
name|failing_p
parameter_list|)
name|int
name|dir
decl_stmt|;
name|unsigned
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|failing_p
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|,
modifier|*
name|prompt
decl_stmt|,
modifier|*
name|p_rep
decl_stmt|;
name|int
name|prompt_len
decl_stmt|,
name|p_rep_index
decl_stmt|,
name|p_rep_size
decl_stmt|;
if|if
condition|(
name|dir
operator|<
literal|0
condition|)
name|prefix
operator|=
name|_
argument_list|(
literal|"I-search backward: "
argument_list|)
expr_stmt|;
else|else
name|prefix
operator|=
name|_
argument_list|(
literal|"I-search: "
argument_list|)
expr_stmt|;
name|p_rep_index
operator|=
name|p_rep_size
operator|=
literal|0
expr_stmt|;
name|p_rep
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|rep
decl_stmt|;
switch|switch
condition|(
name|string
index|[
name|i
index|]
condition|)
block|{
case|case
literal|' '
case|:
name|rep
operator|=
literal|" "
expr_stmt|;
break|break;
case|case
name|LFD
case|:
name|rep
operator|=
literal|"\\n"
expr_stmt|;
break|break;
case|case
name|TAB
case|:
name|rep
operator|=
literal|"\\t"
expr_stmt|;
break|break;
default|default:
name|rep
operator|=
name|pretty_keyname
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p_rep_index
operator|+
name|strlen
argument_list|(
name|rep
argument_list|)
operator|+
literal|1
operator|)
operator|>=
name|p_rep_size
condition|)
name|p_rep
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|p_rep
argument_list|,
name|p_rep_size
operator|+=
literal|100
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p_rep
operator|+
name|p_rep_index
argument_list|,
name|rep
argument_list|)
expr_stmt|;
name|p_rep_index
operator|+=
name|strlen
argument_list|(
name|rep
argument_list|)
expr_stmt|;
block|}
name|prompt_len
operator|=
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
name|p_rep_index
operator|+
literal|20
expr_stmt|;
name|prompt
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|prompt_len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|prompt
argument_list|,
literal|"%s%s%s"
argument_list|,
name|failing_p
condition|?
name|_
argument_list|(
literal|"Failing "
argument_list|)
else|:
literal|""
argument_list|,
name|prefix
argument_list|,
name|p_rep
condition|?
name|p_rep
else|:
literal|""
argument_list|)
expr_stmt|;
name|window_message_in_echo_area
argument_list|(
literal|"%s"
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|maybe_free
argument_list|(
name|p_rep
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|display_cursor_at_point
argument_list|(
name|active_window
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|incremental_search
parameter_list|(
name|window
parameter_list|,
name|count
parameter_list|,
name|ignore
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|int
name|count
decl_stmt|;
name|unsigned
name|char
name|ignore
decl_stmt|;
block|{
name|unsigned
name|char
name|key
decl_stmt|;
name|int
name|last_search_result
decl_stmt|,
name|search_result
decl_stmt|,
name|dir
decl_stmt|;
name|SEARCH_STATE
name|mystate
decl_stmt|,
name|orig_state
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|case_sensitive
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|dir
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|dir
operator|=
literal|1
expr_stmt|;
name|last_search_result
operator|=
name|search_result
operator|=
literal|0
expr_stmt|;
name|window_get_state
argument_list|(
name|window
argument_list|,
operator|&
name|orig_state
argument_list|)
expr_stmt|;
name|isearch_string_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|isearch_string_size
condition|)
name|isearch_string
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|isearch_string_size
operator|=
literal|50
argument_list|)
expr_stmt|;
comment|/* Show the search string in the echo area. */
name|isearch_string
index|[
name|isearch_string_index
index|]
operator|=
literal|'\0'
expr_stmt|;
name|show_isearch_prompt
argument_list|(
name|dir
argument_list|,
name|isearch_string
argument_list|,
name|search_result
argument_list|)
expr_stmt|;
name|isearch_is_active
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|isearch_is_active
condition|)
block|{
name|VFunction
modifier|*
name|func
init|=
operator|(
name|VFunction
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|quoted
init|=
literal|0
decl_stmt|;
comment|/* If a recent display was interrupted, then do the redisplay now if          it is convenient. */
if|if
condition|(
operator|!
name|info_any_buffered_input_p
argument_list|()
operator|&&
name|display_was_interrupted_p
condition|)
block|{
name|display_update_one_window
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|display_cursor_at_point
argument_list|(
name|active_window
argument_list|)
expr_stmt|;
block|}
comment|/* Read a character and dispatch on it. */
name|key
operator|=
name|info_get_input_char
argument_list|()
expr_stmt|;
name|window_get_state
argument_list|(
name|window
argument_list|,
operator|&
name|mystate
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|DEL
condition|)
block|{
comment|/* User wants to delete one level of search? */
if|if
condition|(
operator|!
name|isearch_states_index
condition|)
block|{
name|terminal_ring_bell
argument_list|()
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|pop_isearch
argument_list|(
name|window
argument_list|,
operator|&
name|isearch_string_index
argument_list|,
operator|&
name|dir
argument_list|,
operator|&
name|search_result
argument_list|)
expr_stmt|;
name|isearch_string
index|[
name|isearch_string_index
index|]
operator|=
literal|'\0'
expr_stmt|;
name|show_isearch_prompt
argument_list|(
name|dir
argument_list|,
name|isearch_string
argument_list|,
name|search_result
argument_list|)
expr_stmt|;
goto|goto
name|after_search
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|key
operator|==
name|Control
argument_list|(
literal|'q'
argument_list|)
condition|)
block|{
name|key
operator|=
name|info_get_input_char
argument_list|()
expr_stmt|;
name|quoted
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We are about to search again, or quit.  Save the current search. */
name|push_isearch
argument_list|(
name|window
argument_list|,
name|isearch_string_index
argument_list|,
name|dir
argument_list|,
name|search_result
argument_list|)
expr_stmt|;
if|if
condition|(
name|quoted
condition|)
goto|goto
name|insert_and_search
goto|;
if|if
condition|(
operator|!
name|Meta_p
argument_list|(
name|key
argument_list|)
operator|||
name|key
operator|>
literal|32
condition|)
block|{
name|func
operator|=
name|InfoFunction
argument_list|(
name|window
operator|->
name|keymap
index|[
name|key
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|isprint
argument_list|(
name|key
argument_list|)
operator|||
name|func
operator|==
operator|(
name|VFunction
operator|*
operator|)
name|NULL
condition|)
block|{
name|insert_and_search
label|:
if|if
condition|(
name|isearch_string_index
operator|+
literal|2
operator|>=
name|isearch_string_size
condition|)
name|isearch_string
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|isearch_string
argument_list|,
name|isearch_string_size
operator|+=
literal|100
argument_list|)
expr_stmt|;
name|isearch_string
index|[
name|isearch_string_index
operator|++
index|]
operator|=
name|key
expr_stmt|;
name|isearch_string
index|[
name|isearch_string_index
index|]
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|search_now
goto|;
block|}
elseif|else
if|if
condition|(
name|func
operator|==
name|isearch_forward
operator|||
name|func
operator|==
name|isearch_backward
condition|)
block|{
comment|/* If this key invokes an incremental search, then this 		 means that we will either search again in the same 		 direction, search again in the reverse direction, or 		 insert the last search string that was accepted through 		 incremental searching. */
if|if
condition|(
operator|(
name|func
operator|==
name|isearch_forward
operator|&&
name|dir
operator|>
literal|0
operator|)
operator|||
operator|(
name|func
operator|==
name|isearch_backward
operator|&&
name|dir
operator|<
literal|0
operator|)
condition|)
block|{
comment|/* If the user has typed no characters, then insert the                      last successful search into the current search string. */
if|if
condition|(
name|isearch_string_index
operator|==
literal|0
condition|)
block|{
comment|/* Of course, there must be something to insert. */
if|if
condition|(
name|last_isearch_accepted
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|last_isearch_accepted
argument_list|)
operator|+
literal|1
operator|>=
name|isearch_string_size
condition|)
name|isearch_string
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|isearch_string
argument_list|,
name|isearch_string_size
operator|+=
literal|10
operator|+
name|strlen
argument_list|(
name|last_isearch_accepted
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|isearch_string
argument_list|,
name|last_isearch_accepted
argument_list|)
expr_stmt|;
name|isearch_string_index
operator|=
name|strlen
argument_list|(
name|isearch_string
argument_list|)
expr_stmt|;
goto|goto
name|search_now
goto|;
block|}
else|else
continue|continue;
block|}
else|else
block|{
comment|/* Search again in the same direction.  This means start                          from a new place if the last search was successful. */
if|if
condition|(
name|search_result
operator|==
literal|0
condition|)
name|window
operator|->
name|point
operator|+=
name|dir
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Reverse the direction of the search. */
name|dir
operator|=
operator|-
name|dir
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|func
operator|==
name|info_abort_key
condition|)
block|{
comment|/* If C-g pressed, and the search is failing, pop the search                  stack back to the last unfailed search. */
if|if
condition|(
name|isearch_states_index
operator|&&
operator|(
name|search_result
operator|!=
literal|0
operator|)
condition|)
block|{
name|terminal_ring_bell
argument_list|()
expr_stmt|;
while|while
condition|(
name|isearch_states_index
operator|&&
operator|(
name|search_result
operator|!=
literal|0
operator|)
condition|)
name|pop_isearch
argument_list|(
name|window
argument_list|,
operator|&
name|isearch_string_index
argument_list|,
operator|&
name|dir
argument_list|,
operator|&
name|search_result
argument_list|)
expr_stmt|;
name|isearch_string
index|[
name|isearch_string_index
index|]
operator|=
literal|'\0'
expr_stmt|;
name|show_isearch_prompt
argument_list|(
name|dir
argument_list|,
name|isearch_string
argument_list|,
name|search_result
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
goto|goto
name|exit_search
goto|;
block|}
else|else
goto|goto
name|exit_search
goto|;
block|}
else|else
block|{
name|exit_search
label|:
comment|/* The character is not printable, or it has a function which is              non-null.  Exit the search, remembering the search string.  If              the key is not the same as the isearch_terminate_search_key,              then push it into pending input. */
if|if
condition|(
name|isearch_string_index
operator|&&
name|func
operator|!=
name|info_abort_key
condition|)
block|{
name|maybe_free
argument_list|(
name|last_isearch_accepted
argument_list|)
expr_stmt|;
name|last_isearch_accepted
operator|=
name|xstrdup
argument_list|(
name|isearch_string
argument_list|)
expr_stmt|;
block|}
comment|/* If the key is the isearch_terminate_search_key, but some buffered 	     input is pending, it is almost invariably because the ESC key is 	     actually the beginning of an escape sequence, like in case they 	     pressed an arrow key.  So don't gobble the ESC key, push it back 	     into pending input.  */
comment|/* FIXME: this seems like a kludge!  We need a more reliable 	     mechanism to know when ESC is a separate key and when it is 	     part of an escape sequence.  */
if|if
condition|(
name|key
operator|!=
name|RET
comment|/* Emacs addicts want RET to get lost */
operator|&&
operator|(
name|key
operator|!=
name|isearch_terminate_search_key
operator|||
name|info_any_buffered_input_p
argument_list|()
operator|)
condition|)
name|info_set_pending_input
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|info_abort_key
condition|)
block|{
if|if
condition|(
name|isearch_states_index
condition|)
name|window_set_state
argument_list|(
name|window
argument_list|,
operator|&
name|orig_state
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|echo_area_is_active
condition|)
name|window_clear_echo_area
argument_list|()
expr_stmt|;
if|if
condition|(
name|auto_footnotes_p
condition|)
name|info_get_or_remove_footnotes
argument_list|(
name|active_window
argument_list|)
expr_stmt|;
name|isearch_is_active
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* Search for the contents of isearch_string. */
name|search_now
label|:
name|show_isearch_prompt
argument_list|(
name|dir
argument_list|,
name|isearch_string
argument_list|,
name|search_result
argument_list|)
expr_stmt|;
comment|/* If the search string includes upper-case letters, make the          search case-sensitive.  */
for|for
control|(
name|p
operator|=
name|isearch_string
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|case_sensitive
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|search_result
operator|==
literal|0
condition|)
block|{
comment|/* Check to see if the current search string is right here.  If              we are looking at it, then don't bother calling the search              function. */
if|if
condition|(
operator|(
operator|(
name|dir
operator|<
literal|0
operator|)
operator|&&
operator|(
operator|(
name|case_sensitive
condition|?
name|strncmp
else|:
name|strncasecmp
operator|)
operator|(
name|window
operator|->
name|node
operator|->
name|contents
operator|+
name|window
operator|->
name|point
operator|,
name|isearch_string
operator|,
name|isearch_string_index
operator|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|dir
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|window
operator|->
name|point
operator|-
name|isearch_string_index
operator|)
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|case_sensitive
condition|?
name|strncmp
else|:
name|strncasecmp
operator|)
operator|(
name|window
operator|->
name|node
operator|->
name|contents
operator|+
operator|(
name|window
operator|->
name|point
operator|-
operator|(
name|isearch_string_index
operator|-
literal|1
operator|)
operator|)
operator|,
name|isearch_string
operator|,
name|isearch_string_index
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
name|window
operator|->
name|point
operator|++
expr_stmt|;
block|}
else|else
name|search_result
operator|=
name|info_search_internal
argument_list|(
name|isearch_string
argument_list|,
name|window
argument_list|,
name|dir
argument_list|,
name|case_sensitive
argument_list|)
expr_stmt|;
block|}
comment|/* If this search failed, and we didn't already have a failed search,          then ring the terminal bell. */
if|if
condition|(
name|search_result
operator|!=
literal|0
operator|&&
name|last_search_result
operator|==
literal|0
condition|)
name|terminal_ring_bell
argument_list|()
expr_stmt|;
name|after_search
label|:
name|show_isearch_prompt
argument_list|(
name|dir
argument_list|,
name|isearch_string
argument_list|,
name|search_result
argument_list|)
expr_stmt|;
if|if
condition|(
name|search_result
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|mystate
operator|.
name|node
operator|==
name|window
operator|->
name|node
operator|)
operator|&&
operator|(
name|mystate
operator|.
name|pagetop
operator|!=
name|window
operator|->
name|pagetop
operator|)
condition|)
block|{
name|int
name|newtop
init|=
name|window
operator|->
name|pagetop
decl_stmt|;
name|window
operator|->
name|pagetop
operator|=
name|mystate
operator|.
name|pagetop
expr_stmt|;
name|set_window_pagetop
argument_list|(
name|window
argument_list|,
name|newtop
argument_list|)
expr_stmt|;
block|}
name|display_update_one_window
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|display_cursor_at_point
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
name|last_search_result
operator|=
name|search_result
expr_stmt|;
block|}
comment|/* Free the memory used to remember each search state. */
name|free_isearch_states
argument_list|()
expr_stmt|;
comment|/* Perhaps GC some file buffers. */
name|info_gc_file_buffers
argument_list|()
expr_stmt|;
comment|/* After searching, leave the window in the correct state. */
if|if
condition|(
operator|!
name|echo_area_is_active
condition|)
name|window_clear_echo_area
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* GC some file buffers.  A file buffer can be gc-ed if there we have    no nodes in INFO_WINDOWS that reference this file buffer's contents.    Garbage collecting a file buffer means to free the file buffers    contents. */
end_comment

begin_function
specifier|static
name|void
name|info_gc_file_buffers
parameter_list|()
block|{
specifier|register
name|int
name|fb_index
decl_stmt|,
name|iw_index
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|FILE_BUFFER
modifier|*
name|fb
decl_stmt|;
specifier|register
name|INFO_WINDOW
modifier|*
name|iw
decl_stmt|;
if|if
condition|(
operator|!
name|info_loaded_files
condition|)
return|return;
for|for
control|(
name|fb_index
operator|=
literal|0
init|;
operator|(
name|fb
operator|=
name|info_loaded_files
index|[
name|fb_index
index|]
operator|)
condition|;
name|fb_index
operator|++
control|)
block|{
name|int
name|fb_referenced_p
init|=
literal|0
decl_stmt|;
comment|/* If already gc-ed, do nothing. */
if|if
condition|(
operator|!
name|fb
operator|->
name|contents
condition|)
continue|continue;
comment|/* If this file had to be uncompressed, check to see if we should          gc it.  This means that the user-variable "gc-compressed-files"          is non-zero. */
if|if
condition|(
operator|(
name|fb
operator|->
name|flags
operator|&
name|N_IsCompressed
operator|)
operator|&&
operator|!
name|gc_compressed_files
condition|)
continue|continue;
comment|/* If this file's contents are not gc-able, move on. */
if|if
condition|(
name|fb
operator|->
name|flags
operator|&
name|N_CannotGC
condition|)
continue|continue;
comment|/* Check each INFO_WINDOW to see if it has any nodes which reference          this file. */
for|for
control|(
name|iw_index
operator|=
literal|0
init|;
operator|(
name|iw
operator|=
name|info_windows
index|[
name|iw_index
index|]
operator|)
condition|;
name|iw_index
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|iw
operator|->
name|nodes
operator|&&
name|iw
operator|->
name|nodes
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|FILENAME_CMP
argument_list|(
name|fb
operator|->
name|fullpath
argument_list|,
name|iw
operator|->
name|nodes
index|[
name|i
index|]
operator|->
name|filename
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|FILENAME_CMP
argument_list|(
name|fb
operator|->
name|filename
argument_list|,
name|iw
operator|->
name|nodes
index|[
name|i
index|]
operator|->
name|filename
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|fb_referenced_p
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If this file buffer wasn't referenced, free its contents. */
if|if
condition|(
operator|!
name|fb_referenced_p
condition|)
block|{
name|free
argument_list|(
name|fb
operator|->
name|contents
argument_list|)
expr_stmt|;
name|fb
operator|->
name|contents
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/*                Traversing and Selecting References               */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Move to the next or previous cross reference in this node. */
end_comment

begin_function
specifier|static
name|void
name|info_move_to_xref
parameter_list|(
name|window
parameter_list|,
name|count
parameter_list|,
name|key
parameter_list|,
name|dir
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|int
name|count
decl_stmt|;
name|unsigned
name|char
name|key
decl_stmt|;
name|int
name|dir
decl_stmt|;
block|{
name|long
name|firstmenu
decl_stmt|,
name|firstxref
decl_stmt|;
name|long
name|nextmenu
decl_stmt|,
name|nextxref
decl_stmt|;
name|long
name|placement
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|start
init|=
literal|0
decl_stmt|;
name|NODE
modifier|*
name|node
init|=
name|window
operator|->
name|node
decl_stmt|;
if|if
condition|(
name|dir
operator|<
literal|0
condition|)
name|start
operator|=
name|node
operator|->
name|nodelen
expr_stmt|;
comment|/* This search is only allowed to fail if there is no menu or cross      reference in the current node.  Otherwise, the first menu or xref      found is moved to. */
name|firstmenu
operator|=
name|info_search_in_node
argument_list|(
name|INFO_MENU_ENTRY_LABEL
argument_list|,
name|node
argument_list|,
name|start
argument_list|,
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
argument_list|,
name|dir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIRSTMENU may point directly to the line defining the menu.  Skip that      and go directly to the first item. */
if|if
condition|(
name|firstmenu
operator|!=
operator|-
literal|1
condition|)
block|{
name|char
modifier|*
name|text
init|=
name|node
operator|->
name|contents
operator|+
name|firstmenu
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|text
argument_list|,
name|INFO_MENU_LABEL
argument_list|,
name|strlen
argument_list|(
name|INFO_MENU_LABEL
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|firstmenu
operator|=
name|info_search_in_node
argument_list|(
name|INFO_MENU_ENTRY_LABEL
argument_list|,
name|node
argument_list|,
name|firstmenu
operator|+
name|dir
argument_list|,
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
argument_list|,
name|dir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|firstxref
operator|=
name|info_search_in_node
argument_list|(
name|INFO_XREF_LABEL
argument_list|,
name|node
argument_list|,
name|start
argument_list|,
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
argument_list|,
name|dir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MAN_PAGES
argument_list|)
if|if
condition|(
operator|(
name|firstxref
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|node
operator|->
name|flags
operator|&
name|N_IsManPage
operator|)
condition|)
block|{
name|firstxref
operator|=
name|locate_manpage_xref
argument_list|(
name|node
argument_list|,
name|start
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HANDLE_MAN_PAGES */
if|if
condition|(
name|firstmenu
operator|==
operator|-
literal|1
operator|&&
name|firstxref
operator|==
operator|-
literal|1
condition|)
block|{
name|info_error
argument_list|(
name|msg_no_xref_node
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* There is at least one cross reference or menu entry in this node.      Try hard to find the next available one. */
name|nextmenu
operator|=
name|info_search_in_node
argument_list|(
name|INFO_MENU_ENTRY_LABEL
argument_list|,
name|node
argument_list|,
name|window
operator|->
name|point
operator|+
name|dir
argument_list|,
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
argument_list|,
name|dir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nextxref
operator|=
name|info_search_in_node
argument_list|(
name|INFO_XREF_LABEL
argument_list|,
name|node
argument_list|,
name|window
operator|->
name|point
operator|+
name|dir
argument_list|,
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
argument_list|,
name|dir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MAN_PAGES
argument_list|)
if|if
condition|(
operator|(
name|nextxref
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|node
operator|->
name|flags
operator|&
name|N_IsManPage
operator|)
operator|&&
operator|(
name|firstxref
operator|!=
operator|-
literal|1
operator|)
condition|)
name|nextxref
operator|=
name|locate_manpage_xref
argument_list|(
name|node
argument_list|,
name|window
operator|->
name|point
operator|+
name|dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HANDLE_MAN_PAGES */
comment|/* Ignore "Menu:" as a menu item. */
if|if
condition|(
name|nextmenu
operator|!=
operator|-
literal|1
condition|)
block|{
name|char
modifier|*
name|text
init|=
name|node
operator|->
name|contents
operator|+
name|nextmenu
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|text
argument_list|,
name|INFO_MENU_LABEL
argument_list|,
name|strlen
argument_list|(
name|INFO_MENU_LABEL
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|nextmenu
operator|=
name|info_search_in_node
argument_list|(
name|INFO_MENU_ENTRY_LABEL
argument_list|,
name|node
argument_list|,
name|nextmenu
operator|+
name|dir
argument_list|,
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
argument_list|,
name|dir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If there is both a next menu entry, and a next xref entry, choose the      one which occurs first.  Otherwise, select the one which actually      appears in this node following point. */
if|if
condition|(
name|nextmenu
operator|!=
operator|-
literal|1
operator|&&
name|nextxref
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|dir
operator|==
literal|1
operator|)
operator|&&
operator|(
name|nextmenu
operator|<
name|nextxref
operator|)
operator|)
operator|||
operator|(
operator|(
name|dir
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|nextmenu
operator|>
name|nextxref
operator|)
operator|)
condition|)
name|placement
operator|=
name|nextmenu
operator|+
literal|1
expr_stmt|;
else|else
name|placement
operator|=
name|nextxref
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextmenu
operator|!=
operator|-
literal|1
condition|)
name|placement
operator|=
name|nextmenu
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|nextxref
operator|!=
operator|-
literal|1
condition|)
name|placement
operator|=
name|nextxref
expr_stmt|;
comment|/* If there was neither a menu or xref entry appearing in this node after      point, choose the first menu or xref entry appearing in this node. */
if|if
condition|(
name|placement
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|firstmenu
operator|!=
operator|-
literal|1
operator|&&
name|firstxref
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|dir
operator|==
literal|1
operator|)
operator|&&
operator|(
name|firstmenu
operator|<
name|firstxref
operator|)
operator|)
operator|||
operator|(
operator|(
name|dir
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|firstmenu
operator|>
name|firstxref
operator|)
operator|)
condition|)
name|placement
operator|=
name|firstmenu
operator|+
literal|1
expr_stmt|;
else|else
name|placement
operator|=
name|firstxref
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|firstmenu
operator|!=
operator|-
literal|1
condition|)
name|placement
operator|=
name|firstmenu
operator|+
literal|1
expr_stmt|;
else|else
name|placement
operator|=
name|firstxref
expr_stmt|;
block|}
name|window
operator|->
name|point
operator|=
name|placement
expr_stmt|;
name|window_adjust_pagetop
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|window
operator|->
name|flags
operator||=
name|W_UpdateWindow
expr_stmt|;
block|}
end_function

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_move_to_prev_xref
argument_list|,
argument|_(
literal|"Move to the previous cross reference"
argument|)
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|info_move_to_prev_xref
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
name|info_move_to_xref
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_move_to_next_xref
argument_list|,
argument|_(
literal|"Move to the next cross reference"
argument|)
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|info_move_to_next_xref
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
name|info_move_to_xref
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Select the menu item or reference that appears on this line. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_select_reference_this_line
argument_list|,
argument|_(
literal|"Select reference or menu item appearing on this line"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|NODE
modifier|*
name|orig
decl_stmt|;
name|line
operator|=
name|window
operator|->
name|line_starts
index|[
name|window_line_of_point
argument_list|(
name|window
argument_list|)
index|]
expr_stmt|;
name|orig
operator|=
name|window
operator|->
name|node
expr_stmt|;
comment|/* If this line contains a menu item, select that one. */
if|if
condition|(
name|strncmp
argument_list|(
literal|"* "
argument_list|,
name|line
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|info_menu_or_ref_item
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|,
name|info_menu_of_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|info_menu_or_ref_item
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|,
name|info_xrefs_of_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/*                  Miscellaneous Info Commands                     */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* What to do when C-g is pressed in a window. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_abort_key
argument_list|,
argument|_(
literal|"Cancel current operation"
argument|)
argument_list|)
end_macro

begin_block
block|{
comment|/* If error printing doesn't oridinarily ring the bell, do it now,      since C-g always rings the bell.  Otherwise, let the error printer      do it. */
if|if
condition|(
operator|!
name|info_error_rings_bell_p
condition|)
name|terminal_ring_bell
argument_list|()
expr_stmt|;
name|info_error
argument_list|(
name|_
argument_list|(
literal|"Quit"
argument_list|)
argument_list|)
expr_stmt|;
name|info_initialize_numeric_arg
argument_list|()
expr_stmt|;
name|info_clear_pending_input
argument_list|()
expr_stmt|;
name|info_last_executed_command
operator|=
operator|(
name|VFunction
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Move the cursor to the desired line of the window. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_move_to_window_line
argument_list|,
argument|_(
literal|"Move the cursor to a specific line of the window"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|int
name|line
decl_stmt|;
comment|/* With no numeric argument of any kind, default to the center line. */
if|if
condition|(
operator|!
name|info_explicit_arg
operator|&&
name|count
operator|==
literal|1
condition|)
name|line
operator|=
operator|(
name|window
operator|->
name|height
operator|/
literal|2
operator|)
operator|+
name|window
operator|->
name|pagetop
expr_stmt|;
else|else
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|line
operator|=
operator|(
name|window
operator|->
name|height
operator|+
name|count
operator|)
operator|+
name|window
operator|->
name|pagetop
expr_stmt|;
else|else
name|line
operator|=
name|window
operator|->
name|pagetop
operator|+
name|count
expr_stmt|;
block|}
comment|/* If the line doesn't appear in this window, make it do so. */
if|if
condition|(
operator|(
name|line
operator|-
name|window
operator|->
name|pagetop
operator|)
operator|>=
name|window
operator|->
name|height
condition|)
name|line
operator|=
name|window
operator|->
name|pagetop
operator|+
operator|(
name|window
operator|->
name|height
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* If the line is too small, make it fit. */
if|if
condition|(
name|line
operator|<
name|window
operator|->
name|pagetop
condition|)
name|line
operator|=
name|window
operator|->
name|pagetop
expr_stmt|;
comment|/* If the selected line is past the bottom of the node, force it back. */
if|if
condition|(
name|line
operator|>=
name|window
operator|->
name|line_count
condition|)
name|line
operator|=
name|window
operator|->
name|line_count
operator|-
literal|1
expr_stmt|;
name|window
operator|->
name|point
operator|=
operator|(
name|window
operator|->
name|line_starts
index|[
name|line
index|]
operator|-
name|window
operator|->
name|node
operator|->
name|contents
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Clear the screen and redraw its contents.  Given a numeric argument,    move the line the cursor is on to the COUNT'th line of the window. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_redraw_display
argument_list|,
argument|_(
literal|"Redraw the display"
argument|)
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|(
operator|!
name|info_explicit_arg
operator|&&
name|count
operator|==
literal|1
operator|)
operator|||
name|echo_area_is_active
condition|)
block|{
name|terminal_clear_screen
argument_list|()
expr_stmt|;
name|display_clear_display
argument_list|(
name|the_display
argument_list|)
expr_stmt|;
name|window_mark_chain
argument_list|(
name|windows
argument_list|,
name|W_UpdateWindow
argument_list|)
expr_stmt|;
name|display_update_display
argument_list|(
name|windows
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|desired_line
decl_stmt|,
name|point_line
decl_stmt|;
name|int
name|new_pagetop
decl_stmt|;
name|point_line
operator|=
name|window_line_of_point
argument_list|(
name|window
argument_list|)
operator|-
name|window
operator|->
name|pagetop
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|desired_line
operator|=
name|window
operator|->
name|height
operator|+
name|count
expr_stmt|;
else|else
name|desired_line
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|desired_line
operator|<
literal|0
condition|)
name|desired_line
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|desired_line
operator|>=
name|window
operator|->
name|height
condition|)
name|desired_line
operator|=
name|window
operator|->
name|height
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|desired_line
operator|==
name|point_line
condition|)
return|return;
name|new_pagetop
operator|=
name|window
operator|->
name|pagetop
operator|+
operator|(
name|point_line
operator|-
name|desired_line
operator|)
expr_stmt|;
name|set_window_pagetop
argument_list|(
name|window
argument_list|,
name|new_pagetop
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* This command does nothing.  It is the fact that a key is bound to it    that has meaning.  See the code at the top of info_session (). */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_quit
argument_list|,
argument|_(
literal|"Quit using Info"
argument|)
argument_list|)
end_macro

begin_block
block|{}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/*               Reading Keys and Dispatching on Them               */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Declaration only.  Special cased in info_dispatch_on_key ().    Doc string is to avoid ugly results with describe_key etc.  */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_do_lowercase_version
argument_list|,
argument|_(
literal|"Run command bound to this key's lowercase variant"
argument|)
argument_list|)
end_macro

begin_block
block|{}
end_block

begin_function
specifier|static
name|void
name|dispatch_error
parameter_list|(
name|keyseq
parameter_list|)
name|char
modifier|*
name|keyseq
decl_stmt|;
block|{
name|char
modifier|*
name|rep
decl_stmt|;
name|rep
operator|=
name|pretty_keyseq
argument_list|(
name|keyseq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|echo_area_is_active
condition|)
name|info_error
argument_list|(
name|_
argument_list|(
literal|"Unknown command (%s)."
argument_list|)
argument_list|,
name|rep
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|temp
init|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|rep
argument_list|)
operator|+
name|strlen
argument_list|(
name|_
argument_list|(
literal|"\"\" is invalid"
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
name|_
argument_list|(
literal|"\"%s\" is invalid"
argument_list|)
argument_list|,
name|rep
argument_list|)
expr_stmt|;
name|terminal_ring_bell
argument_list|()
expr_stmt|;
name|inform_in_echo_area
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Keeping track of key sequences. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|info_keyseq
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|info_keyseq_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|info_keyseq_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|info_keyseq_displayed_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the length of the current key sequence. */
end_comment

begin_function
name|void
name|initialize_keyseq
parameter_list|()
block|{
name|info_keyseq_index
operator|=
literal|0
expr_stmt|;
name|info_keyseq_displayed_p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add CHARACTER to the current key sequence. */
end_comment

begin_function
name|void
name|add_char_to_keyseq
parameter_list|(
name|character
parameter_list|)
name|char
name|character
decl_stmt|;
block|{
if|if
condition|(
name|info_keyseq_index
operator|+
literal|2
operator|>=
name|info_keyseq_size
condition|)
name|info_keyseq
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|info_keyseq
argument_list|,
name|info_keyseq_size
operator|+=
literal|10
argument_list|)
expr_stmt|;
name|info_keyseq
index|[
name|info_keyseq_index
operator|++
index|]
operator|=
name|character
expr_stmt|;
name|info_keyseq
index|[
name|info_keyseq_index
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Display the current value of info_keyseq.  If argument EXPECTING is    non-zero, input is expected to be read after the key sequence is    displayed, so add an additional prompting character to the sequence. */
end_comment

begin_function
name|void
name|display_info_keyseq
parameter_list|(
name|expecting_future_input
parameter_list|)
name|int
name|expecting_future_input
decl_stmt|;
block|{
name|char
modifier|*
name|rep
decl_stmt|;
name|rep
operator|=
name|pretty_keyseq
argument_list|(
name|info_keyseq
argument_list|)
expr_stmt|;
if|if
condition|(
name|expecting_future_input
condition|)
name|strcat
argument_list|(
name|rep
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|echo_area_is_active
condition|)
name|inform_in_echo_area
argument_list|(
name|rep
argument_list|)
expr_stmt|;
else|else
block|{
name|window_message_in_echo_area
argument_list|(
name|rep
argument_list|)
expr_stmt|;
name|display_cursor_at_point
argument_list|(
name|active_window
argument_list|)
expr_stmt|;
block|}
name|info_keyseq_displayed_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called by interactive commands to read a keystroke. */
end_comment

begin_function
name|unsigned
name|char
name|info_get_another_input_char
parameter_list|()
block|{
name|int
name|ready
init|=
operator|!
name|info_keyseq_displayed_p
decl_stmt|;
comment|/* ready if new and pending key */
comment|/* If there isn't any input currently available, then wait a      moment looking for input.  If we don't get it fast enough,      prompt a little bit with the current key sequence. */
if|if
condition|(
operator|!
name|info_keyseq_displayed_p
condition|)
block|{
name|ready
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|info_any_buffered_input_p
argument_list|()
operator|&&
operator|!
name|info_input_pending_p
argument_list|()
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|FD_SET
argument_list|)
name|struct
name|timeval
name|timer
decl_stmt|;
name|fd_set
name|readfds
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|fileno
argument_list|(
name|info_input_stream
argument_list|)
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|timer
operator|.
name|tv_sec
operator|=
literal|1
expr_stmt|;
name|timer
operator|.
name|tv_usec
operator|=
literal|750
expr_stmt|;
name|ready
operator|=
name|select
argument_list|(
name|fileno
argument_list|(
name|info_input_stream
argument_list|)
operator|+
literal|1
argument_list|,
operator|&
name|readfds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|timer
argument_list|)
expr_stmt|;
else|#
directive|else
name|ready
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* FD_SET */
block|}
block|}
if|if
condition|(
operator|!
name|ready
condition|)
name|display_info_keyseq
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|info_get_input_char
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Do the command associated with KEY in MAP.  If the associated command is    really a keymap, then read another key, and dispatch into that map. */
end_comment

begin_function
name|void
name|info_dispatch_on_key
parameter_list|(
name|key
parameter_list|,
name|map
parameter_list|)
name|unsigned
name|char
name|key
decl_stmt|;
name|Keymap
name|map
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|INFOKEY
argument_list|)
if|if
condition|(
name|Meta_p
argument_list|(
name|key
argument_list|)
operator|&&
operator|(
operator|!
name|ISO_Latin_p
operator|||
name|map
index|[
name|key
index|]
operator|.
name|function
operator|!=
name|ea_insert
operator|)
condition|)
block|{
if|if
condition|(
name|map
index|[
name|ESC
index|]
operator|.
name|type
operator|==
name|ISKMAP
condition|)
block|{
name|map
operator|=
operator|(
name|Keymap
operator|)
name|map
index|[
name|ESC
index|]
operator|.
name|function
expr_stmt|;
name|add_char_to_keyseq
argument_list|(
name|ESC
argument_list|)
expr_stmt|;
name|key
operator|=
name|UnMeta
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|info_dispatch_on_key
argument_list|(
name|key
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dispatch_error
argument_list|(
name|info_keyseq
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
endif|#
directive|endif
comment|/* INFOKEY */
switch|switch
condition|(
name|map
index|[
name|key
index|]
operator|.
name|type
condition|)
block|{
case|case
name|ISFUNC
case|:
block|{
name|VFunction
modifier|*
name|func
decl_stmt|;
name|func
operator|=
name|InfoFunction
argument_list|(
name|map
index|[
name|key
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|!=
operator|(
name|VFunction
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Special case info_do_lowercase_version (). */
if|if
condition|(
name|func
operator|==
name|info_do_lowercase_version
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INFOKEY
argument_list|)
name|unsigned
name|char
name|lowerkey
decl_stmt|;
name|lowerkey
operator|=
name|Meta_p
argument_list|(
name|key
argument_list|)
condition|?
name|Meta
argument_list|(
name|tolower
argument_list|(
name|UnMeta
argument_list|(
name|key
argument_list|)
argument_list|)
argument_list|)
else|:
name|tolower
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowerkey
operator|==
name|key
condition|)
block|{
name|add_char_to_keyseq
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|dispatch_error
argument_list|(
name|info_keyseq
argument_list|)
expr_stmt|;
return|return;
block|}
name|info_dispatch_on_key
argument_list|(
name|lowerkey
argument_list|,
name|map
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !INFOKEY */
name|info_dispatch_on_key
argument_list|(
name|tolower
argument_list|(
name|key
argument_list|)
argument_list|,
name|map
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* INFOKEY */
return|return;
block|}
name|add_char_to_keyseq
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_keyseq_displayed_p
condition|)
name|display_info_keyseq
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|{
name|WINDOW
modifier|*
name|where
decl_stmt|;
name|where
operator|=
name|active_window
expr_stmt|;
operator|(
operator|*
name|InfoFunction
argument_list|(
name|map
index|[
name|key
index|]
operator|.
name|function
argument_list|)
operator|)
operator|(
name|active_window
operator|,
name|info_numeric_arg
operator|*
name|info_numeric_arg_sign
operator|,
name|key
operator|)
expr_stmt|;
comment|/* If we have input pending, then the last command was a prefix                  command.  Don't change the value of the last function vars.                  Otherwise, remember the last command executed in the var                  appropriate to the window in which it was executed. */
if|if
condition|(
operator|!
name|info_input_pending_p
argument_list|()
condition|)
block|{
if|if
condition|(
name|where
operator|==
name|the_echo_area
condition|)
name|ea_last_executed_command
operator|=
name|InfoFunction
argument_list|(
name|map
index|[
name|key
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
else|else
name|info_last_executed_command
operator|=
name|InfoFunction
argument_list|(
name|map
index|[
name|key
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|add_char_to_keyseq
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|dispatch_error
argument_list|(
name|info_keyseq
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
break|break;
case|case
name|ISKMAP
case|:
name|add_char_to_keyseq
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
index|[
name|key
index|]
operator|.
name|function
operator|!=
operator|(
name|InfoCommand
operator|*
operator|)
name|NULL
condition|)
block|{
name|unsigned
name|char
name|newkey
decl_stmt|;
name|newkey
operator|=
name|info_get_another_input_char
argument_list|()
expr_stmt|;
name|info_dispatch_on_key
argument_list|(
name|newkey
argument_list|,
operator|(
name|Keymap
operator|)
name|map
index|[
name|key
index|]
operator|.
name|function
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dispatch_error
argument_list|(
name|info_keyseq
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/*                      Numeric Arguments                           */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Handle C-u style numeric args, as well as M--, and M-digits. */
end_comment

begin_comment
comment|/* Non-zero means that an explicit argument has been passed to this    command, as in C-u C-v. */
end_comment

begin_decl_stmt
name|int
name|info_explicit_arg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The sign of the numeric argument. */
end_comment

begin_decl_stmt
name|int
name|info_numeric_arg_sign
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The value of the argument itself. */
end_comment

begin_decl_stmt
name|int
name|info_numeric_arg
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add the current digit to the argument in progress. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_add_digit_to_numeric_arg
argument_list|,
argument|_(
literal|"Add this digit to the current numeric argument"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|info_numeric_arg_digit_loop
argument_list|(
name|window
argument_list|,
literal|0
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* C-u, universal argument.  Multiply the current argument by 4.    Read a key.  If the key has nothing to do with arguments, then    dispatch on it.  If the key is the abort character then abort. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_universal_argument
argument_list|,
argument|_(
literal|"Start (or multiply by 4) the current numeric argument"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|info_numeric_arg
operator|*=
literal|4
expr_stmt|;
name|info_numeric_arg_digit_loop
argument_list|(
name|window
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Create a default argument. */
end_comment

begin_function
name|void
name|info_initialize_numeric_arg
parameter_list|()
block|{
name|info_numeric_arg
operator|=
name|info_numeric_arg_sign
operator|=
literal|1
expr_stmt|;
name|info_explicit_arg
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_numeric_arg_digit_loop
argument_list|,
argument|_(
literal|"Internally used by \\[universal-argument]"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|unsigned
name|char
name|pure_key
decl_stmt|;
name|Keymap
name|keymap
init|=
name|window
operator|->
name|keymap
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|key
condition|)
name|pure_key
operator|=
name|key
expr_stmt|;
else|else
block|{
if|if
condition|(
name|display_was_interrupted_p
operator|&&
operator|!
name|info_any_buffered_input_p
argument_list|()
condition|)
name|display_update_display
argument_list|(
name|windows
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_window
operator|!=
name|the_echo_area
condition|)
name|display_cursor_at_point
argument_list|(
name|active_window
argument_list|)
expr_stmt|;
name|pure_key
operator|=
name|key
operator|=
name|info_get_another_input_char
argument_list|()
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|INFOKEY
argument_list|)
if|if
condition|(
name|Meta_p
argument_list|(
name|key
argument_list|)
condition|)
name|add_char_to_keyseq
argument_list|(
name|ESC
argument_list|)
expr_stmt|;
name|add_char_to_keyseq
argument_list|(
name|UnMeta
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* defined(INFOKEY) */
name|add_char_to_keyseq
argument_list|(
name|key
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(INFOKEY) */
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|INFOKEY
argument_list|)
if|if
condition|(
name|Meta_p
argument_list|(
name|key
argument_list|)
condition|)
name|key
operator|=
name|UnMeta
argument_list|(
name|key
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(INFOKEY) */
if|if
condition|(
name|keymap
index|[
name|key
index|]
operator|.
name|type
operator|==
name|ISFUNC
operator|&&
name|InfoFunction
argument_list|(
name|keymap
index|[
name|key
index|]
operator|.
name|function
argument_list|)
operator|==
name|info_universal_argument
condition|)
block|{
name|info_numeric_arg
operator|*=
literal|4
expr_stmt|;
name|key
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
name|defined
argument_list|(
name|INFOKEY
argument_list|)
if|if
condition|(
name|Meta_p
argument_list|(
name|key
argument_list|)
condition|)
name|key
operator|=
name|UnMeta
argument_list|(
name|key
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !defined(INFOKEY) */
if|if
condition|(
name|isdigit
argument_list|(
name|key
argument_list|)
condition|)
block|{
if|if
condition|(
name|info_explicit_arg
condition|)
name|info_numeric_arg
operator|=
operator|(
name|info_numeric_arg
operator|*
literal|10
operator|)
operator|+
operator|(
name|key
operator|-
literal|'0'
operator|)
expr_stmt|;
else|else
name|info_numeric_arg
operator|=
operator|(
name|key
operator|-
literal|'0'
operator|)
expr_stmt|;
name|info_explicit_arg
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|key
operator|==
literal|'-'
operator|&&
operator|!
name|info_explicit_arg
condition|)
block|{
name|info_numeric_arg_sign
operator|=
operator|-
literal|1
expr_stmt|;
name|info_numeric_arg
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|info_keyseq_index
operator|--
expr_stmt|;
name|info_dispatch_on_key
argument_list|(
name|pure_key
argument_list|,
name|keymap
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|key
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/*                      Input Character Buffering                   */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Character waiting to be read next. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pending_input_character
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to make there be no pending input. */
end_comment

begin_function
specifier|static
name|void
name|info_clear_pending_input
parameter_list|()
block|{
name|pending_input_character
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* How to set the pending input character. */
end_comment

begin_function
specifier|static
name|void
name|info_set_pending_input
parameter_list|(
name|key
parameter_list|)
name|unsigned
name|char
name|key
decl_stmt|;
block|{
name|pending_input_character
operator|=
name|key
expr_stmt|;
block|}
end_function

begin_comment
comment|/* How to see if there is any pending input. */
end_comment

begin_function
name|unsigned
name|char
name|info_input_pending_p
parameter_list|()
block|{
return|return
operator|(
name|pending_input_character
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Largest number of characters that we can read in advance. */
end_comment

begin_define
define|#
directive|define
name|MAX_INFO_INPUT_BUFFERING
value|512
end_define

begin_decl_stmt
specifier|static
name|int
name|pop_index
init|=
literal|0
decl_stmt|,
name|push_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|info_input_buffer
index|[
name|MAX_INFO_INPUT_BUFFERING
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add KEY to the buffer of characters to be read. */
end_comment

begin_function
specifier|static
name|void
name|info_push_typeahead
parameter_list|(
name|key
parameter_list|)
name|unsigned
name|char
name|key
decl_stmt|;
block|{
comment|/* Flush all pending input in the case of C-g pressed. */
if|if
condition|(
name|key
operator|==
name|Control
argument_list|(
literal|'g'
argument_list|)
condition|)
block|{
name|push_index
operator|=
name|pop_index
expr_stmt|;
name|info_set_pending_input
argument_list|(
name|Control
argument_list|(
literal|'g'
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|info_input_buffer
index|[
name|push_index
operator|++
index|]
operator|=
name|key
expr_stmt|;
if|if
condition|(
name|push_index
operator|>=
sizeof|sizeof
argument_list|(
name|info_input_buffer
argument_list|)
condition|)
name|push_index
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the amount of space available in INFO_INPUT_BUFFER for new chars. */
end_comment

begin_function
specifier|static
name|int
name|info_input_buffer_space_available
parameter_list|()
block|{
if|if
condition|(
name|pop_index
operator|>
name|push_index
condition|)
return|return
operator|(
name|pop_index
operator|-
name|push_index
operator|)
return|;
else|else
return|return
operator|(
sizeof|sizeof
argument_list|(
name|info_input_buffer
argument_list|)
operator|-
operator|(
name|push_index
operator|-
name|pop_index
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get a key from the buffer of characters to be read.    Return the key in KEY.    Result is non-zero if there was a key, or 0 if there wasn't. */
end_comment

begin_function
specifier|static
name|int
name|info_get_key_from_typeahead
parameter_list|(
name|key
parameter_list|)
name|unsigned
name|char
modifier|*
name|key
decl_stmt|;
block|{
if|if
condition|(
name|push_index
operator|==
name|pop_index
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|key
operator|=
name|info_input_buffer
index|[
name|pop_index
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|pop_index
operator|>=
sizeof|sizeof
argument_list|(
name|info_input_buffer
argument_list|)
condition|)
name|pop_index
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|info_any_buffered_input_p
parameter_list|()
block|{
name|info_gather_typeahead
argument_list|()
expr_stmt|;
return|return
operator|(
name|push_index
operator|!=
name|pop_index
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If characters are available to be read, then read them and stuff them into    info_input_buffer.  Otherwise, do nothing. */
end_comment

begin_function
name|void
name|info_gather_typeahead
parameter_list|()
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|tty
decl_stmt|,
name|space_avail
decl_stmt|;
name|long
name|chars_avail
decl_stmt|;
name|unsigned
name|char
name|input
index|[
name|MAX_INFO_INPUT_BUFFERING
index|]
decl_stmt|;
name|tty
operator|=
name|fileno
argument_list|(
name|info_input_stream
argument_list|)
expr_stmt|;
name|chars_avail
operator|=
literal|0
expr_stmt|;
name|space_avail
operator|=
name|info_input_buffer_space_available
argument_list|()
expr_stmt|;
comment|/* If we can just find out how many characters there are to read, do so. */
if|#
directive|if
name|defined
argument_list|(
name|FIONREAD
argument_list|)
block|{
name|ioctl
argument_list|(
name|tty
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|chars_avail
argument_list|)
expr_stmt|;
if|if
condition|(
name|chars_avail
operator|>
name|space_avail
condition|)
name|chars_avail
operator|=
name|space_avail
expr_stmt|;
if|if
condition|(
name|chars_avail
condition|)
name|chars_avail
operator|=
name|read
argument_list|(
name|tty
argument_list|,
operator|&
name|input
index|[
literal|0
index|]
argument_list|,
name|chars_avail
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !FIONREAD */
if|#
directive|if
name|defined
argument_list|(
name|O_NDELAY
argument_list|)
block|{
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|fcntl
argument_list|(
name|tty
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|tty
argument_list|,
name|F_SETFL
argument_list|,
operator|(
name|flags
operator||
name|O_NDELAY
operator|)
argument_list|)
expr_stmt|;
name|chars_avail
operator|=
name|read
argument_list|(
name|tty
argument_list|,
operator|&
name|input
index|[
literal|0
index|]
argument_list|,
name|space_avail
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|tty
argument_list|,
name|F_SETFL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|chars_avail
operator|==
operator|-
literal|1
condition|)
name|chars_avail
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
comment|/* !O_NDELAY */
ifdef|#
directive|ifdef
name|__DJGPP__
block|{
specifier|extern
name|long
name|pc_term_chars_avail
argument_list|(
name|void
argument_list|)
decl_stmt|;
if|if
condition|(
name|isatty
argument_list|(
name|tty
argument_list|)
condition|)
name|chars_avail
operator|=
name|pc_term_chars_avail
argument_list|()
expr_stmt|;
else|else
block|{
comment|/* We could be more accurate by calling ltell, but we have no idea 	   whether tty is buffered by stdio functions, and if so, how many 	   characters are already waiting in the buffer.  So we punt.  */
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|tty
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
name|chars_avail
operator|=
literal|1
expr_stmt|;
else|else
name|chars_avail
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
block|}
if|if
condition|(
name|chars_avail
operator|>
name|space_avail
condition|)
name|chars_avail
operator|=
name|space_avail
expr_stmt|;
if|if
condition|(
name|chars_avail
condition|)
name|chars_avail
operator|=
name|read
argument_list|(
name|tty
argument_list|,
operator|&
name|input
index|[
literal|0
index|]
argument_list|,
name|chars_avail
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* __DJGPP__ */
endif|#
directive|endif
comment|/* O_NDELAY */
endif|#
directive|endif
comment|/* !FIONREAD */
while|while
condition|(
name|i
operator|<
name|chars_avail
condition|)
block|{
name|info_push_typeahead
argument_list|(
name|input
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* How to read a single character. */
end_comment

begin_function
name|unsigned
name|char
name|info_get_input_char
parameter_list|()
block|{
name|unsigned
name|char
name|keystroke
decl_stmt|;
name|info_gather_typeahead
argument_list|()
expr_stmt|;
if|if
condition|(
name|pending_input_character
condition|)
block|{
name|keystroke
operator|=
name|pending_input_character
expr_stmt|;
name|pending_input_character
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info_get_key_from_typeahead
argument_list|(
operator|&
name|keystroke
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|rawkey
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|int
name|tty
init|=
name|fileno
argument_list|(
name|info_input_stream
argument_list|)
decl_stmt|;
comment|/* Using stream I/O causes FIONREAD etc to fail to work          so unless someone can find a portable way of finding          out how many characters are currently buffered, we          should stay with away from stream I/O.          --Egil Kvaleberg<egilk@sn.no>, January 1997.  */
ifdef|#
directive|ifdef
name|EINTR
comment|/* Keep reading if we got EINTR, so that we don't just exit.          --Andreas Schwab<schwab@issan.informatik.uni-dortmund.de>,          22 Dec 1997.  */
block|{
name|int
name|n
decl_stmt|;
do|do
name|n
operator|=
name|read
argument_list|(
name|tty
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
name|n
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
name|rawkey
operator|=
name|n
operator|==
literal|1
condition|?
name|c
else|:
name|EOF
expr_stmt|;
block|}
else|#
directive|else
name|rawkey
operator|=
operator|(
name|read
argument_list|(
name|tty
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
operator|)
condition|?
name|c
else|:
name|EOF
expr_stmt|;
endif|#
directive|endif
name|keystroke
operator|=
name|rawkey
expr_stmt|;
if|if
condition|(
name|rawkey
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|info_input_stream
operator|!=
name|stdin
condition|)
block|{
name|fclose
argument_list|(
name|info_input_stream
argument_list|)
expr_stmt|;
name|info_input_stream
operator|=
name|stdin
expr_stmt|;
name|tty
operator|=
name|fileno
argument_list|(
name|info_input_stream
argument_list|)
expr_stmt|;
name|display_inhibited
operator|=
literal|0
expr_stmt|;
name|display_update_display
argument_list|(
name|windows
argument_list|)
expr_stmt|;
name|display_cursor_at_point
argument_list|(
name|active_window
argument_list|)
expr_stmt|;
name|rawkey
operator|=
operator|(
name|read
argument_list|(
name|tty
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
operator|)
condition|?
name|c
else|:
name|EOF
expr_stmt|;
name|keystroke
operator|=
name|rawkey
expr_stmt|;
block|}
if|if
condition|(
name|rawkey
operator|==
name|EOF
condition|)
block|{
name|terminal_unprep_terminal
argument_list|()
expr_stmt|;
name|close_dribble_file
argument_list|()
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|info_dribble_file
condition|)
name|dribble
argument_list|(
name|keystroke
argument_list|)
expr_stmt|;
return|return
name|keystroke
return|;
block|}
end_function

end_unit

