begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* search.c -- How to search large bodies of text. */
end_comment

begin_comment
comment|/* This file is part of GNU Info, a program for reading online documentation    stored in Info format.     Copyright (C) 1993 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Written by Brian Fox (bfox@ai.mit.edu). */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_include
include|#
directive|include
file|"search.h"
end_include

begin_include
include|#
directive|include
file|"nodes.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NULL
argument_list|)
end_if

begin_define
define|#
directive|define
name|NULL
value|0x0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !NULL */
end_comment

begin_comment
comment|/* The search functions take two arguments:       1) a string to search for, and       2) a pointer to a SEARCH_BINDING which contains the buffer, start,         and end of the search.     They return a long, which is the offset from the start of the buffer    at which the match was found.  An offset of -1 indicates failure. */
end_comment

begin_comment
comment|/* A function which makes a binding with buffer and bounds. */
end_comment

begin_function
name|SEARCH_BINDING
modifier|*
name|make_binding
parameter_list|(
name|buffer
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|char
modifier|*
name|buffer
decl_stmt|;
name|long
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
name|SEARCH_BINDING
modifier|*
name|binding
decl_stmt|;
name|binding
operator|=
operator|(
name|SEARCH_BINDING
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SEARCH_BINDING
argument_list|)
argument_list|)
expr_stmt|;
name|binding
operator|->
name|buffer
operator|=
name|buffer
expr_stmt|;
name|binding
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|binding
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|binding
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|binding
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Make a copy of BINDING without duplicating the data. */
end_comment

begin_function
name|SEARCH_BINDING
modifier|*
name|copy_binding
parameter_list|(
name|binding
parameter_list|)
name|SEARCH_BINDING
modifier|*
name|binding
decl_stmt|;
block|{
name|SEARCH_BINDING
modifier|*
name|copy
decl_stmt|;
name|copy
operator|=
name|make_binding
argument_list|(
name|binding
operator|->
name|buffer
argument_list|,
name|binding
operator|->
name|start
argument_list|,
name|binding
operator|->
name|end
argument_list|)
expr_stmt|;
name|copy
operator|->
name|flags
operator|=
name|binding
operator|->
name|flags
expr_stmt|;
return|return
operator|(
name|copy
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		   The Actual Searching Functions		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Search forwards or backwards for the text delimited by BINDING.    The search is forwards if BINDING->start is greater than BINDING->end. */
end_comment

begin_function
name|long
name|search
parameter_list|(
name|string
parameter_list|,
name|binding
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|SEARCH_BINDING
modifier|*
name|binding
decl_stmt|;
block|{
name|long
name|result
decl_stmt|;
comment|/* If the search is backwards, then search backwards, otherwise forwards. */
if|if
condition|(
name|binding
operator|->
name|start
operator|>
name|binding
operator|->
name|end
condition|)
name|result
operator|=
name|search_backward
argument_list|(
name|string
argument_list|,
name|binding
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|search_forward
argument_list|(
name|string
argument_list|,
name|binding
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search forwards for STRING through the text delimited in BINDING. */
end_comment

begin_function
name|long
name|search_forward
parameter_list|(
name|string
parameter_list|,
name|binding
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|SEARCH_BINDING
modifier|*
name|binding
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|buff
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
name|alternate
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
comment|/* We match characters in the search buffer against STRING and ALTERNATE.      ALTERNATE is a case reversed version of STRING; this is cheaper than      case folding each character before comparison.   Alternate is only      used if the case folding bit is turned on in the passed BINDING. */
if|if
condition|(
name|binding
operator|->
name|flags
operator|&
name|S_FoldCase
condition|)
block|{
name|alternate
operator|=
name|strdup
argument_list|(
name|string
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|islower
argument_list|(
name|alternate
index|[
name|i
index|]
argument_list|)
condition|)
name|alternate
index|[
name|i
index|]
operator|=
name|toupper
argument_list|(
name|alternate
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isupper
argument_list|(
name|alternate
index|[
name|i
index|]
argument_list|)
condition|)
name|alternate
index|[
name|i
index|]
operator|=
name|tolower
argument_list|(
name|alternate
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|buff
operator|=
name|binding
operator|->
name|buffer
operator|+
name|binding
operator|->
name|start
expr_stmt|;
name|end
operator|=
name|binding
operator|->
name|buffer
operator|+
name|binding
operator|->
name|end
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|buff
operator|<
operator|(
name|end
operator|-
name|len
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|buff
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|!=
name|string
index|[
name|i
index|]
operator|)
operator|&&
operator|(
operator|!
name|alternate
operator|||
name|c
operator|!=
name|alternate
index|[
name|i
index|]
operator|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|string
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|alternate
condition|)
name|free
argument_list|(
name|alternate
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding
operator|->
name|flags
operator|&
name|S_SkipDest
condition|)
name|buff
operator|+=
name|len
expr_stmt|;
return|return
operator|(
call|(
name|long
call|)
argument_list|(
name|buff
operator|-
name|binding
operator|->
name|buffer
argument_list|)
operator|)
return|;
block|}
name|buff
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|alternate
condition|)
name|free
argument_list|(
name|alternate
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|long
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search for STRING backwards through the text delimited in BINDING. */
end_comment

begin_function
name|long
name|search_backward
parameter_list|(
name|input_string
parameter_list|,
name|binding
parameter_list|)
name|char
modifier|*
name|input_string
decl_stmt|;
name|SEARCH_BINDING
modifier|*
name|binding
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|buff
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
name|alternate
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|input_string
argument_list|)
expr_stmt|;
comment|/* Reverse the characters in the search string. */
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
operator|,
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|input_string
index|[
name|c
index|]
condition|;
name|c
operator|++
operator|,
name|i
operator|--
control|)
name|string
index|[
name|i
index|]
operator|=
name|input_string
index|[
name|c
index|]
expr_stmt|;
name|string
index|[
name|c
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* We match characters in the search buffer against STRING and ALTERNATE.      ALTERNATE is a case reversed version of STRING; this is cheaper than      case folding each character before comparison.   ALTERNATE is only      used if the case folding bit is turned on in the passed BINDING. */
if|if
condition|(
name|binding
operator|->
name|flags
operator|&
name|S_FoldCase
condition|)
block|{
name|alternate
operator|=
name|strdup
argument_list|(
name|string
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|islower
argument_list|(
name|alternate
index|[
name|i
index|]
argument_list|)
condition|)
name|alternate
index|[
name|i
index|]
operator|=
name|toupper
argument_list|(
name|alternate
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isupper
argument_list|(
name|alternate
index|[
name|i
index|]
argument_list|)
condition|)
name|alternate
index|[
name|i
index|]
operator|=
name|tolower
argument_list|(
name|alternate
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|buff
operator|=
name|binding
operator|->
name|buffer
operator|+
name|binding
operator|->
name|start
operator|-
literal|1
expr_stmt|;
name|end
operator|=
name|binding
operator|->
name|buffer
operator|+
name|binding
operator|->
name|end
expr_stmt|;
while|while
condition|(
name|buff
operator|>
operator|(
name|end
operator|+
name|len
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|*
operator|(
name|buff
operator|-
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|string
index|[
name|i
index|]
operator|&&
operator|(
name|alternate
operator|&&
name|c
operator|!=
name|alternate
index|[
name|i
index|]
operator|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|string
index|[
name|i
index|]
condition|)
block|{
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|alternate
condition|)
name|free
argument_list|(
name|alternate
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding
operator|->
name|flags
operator|&
name|S_SkipDest
condition|)
name|buff
operator|-=
name|len
expr_stmt|;
return|return
operator|(
call|(
name|long
call|)
argument_list|(
literal|1
operator|+
operator|(
name|buff
operator|-
name|binding
operator|->
name|buffer
operator|)
argument_list|)
operator|)
return|;
block|}
name|buff
operator|--
expr_stmt|;
block|}
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|alternate
condition|)
name|free
argument_list|(
name|alternate
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|long
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find STRING in LINE, returning the offset of the end of the string.    Return an offset of -1 if STRING does not appear in LINE.  The search    is bound by the end of the line (i.e., either NEWLINE or 0). */
end_comment

begin_decl_stmt
name|int
name|string_in_line
argument_list|(
name|string
argument_list|,
name|line
argument_list|)
name|char
modifier|*
name|string
decl_stmt|,
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|end
decl_stmt|;
name|SEARCH_BINDING
name|binding
decl_stmt|;
comment|/* Find the end of the line. */
for|for
control|(
name|end
operator|=
literal|0
init|;
name|line
index|[
name|end
index|]
operator|&&
name|line
index|[
name|end
index|]
operator|!=
literal|'\n'
condition|;
name|end
operator|++
control|)
empty_stmt|;
comment|/* Search for STRING within these confines. */
name|binding
operator|.
name|buffer
operator|=
name|line
expr_stmt|;
name|binding
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|binding
operator|.
name|end
operator|=
name|end
expr_stmt|;
name|binding
operator|.
name|flags
operator|=
name|S_FoldCase
operator||
name|S_SkipDest
expr_stmt|;
return|return
operator|(
name|search_forward
argument_list|(
name|string
argument_list|,
operator|&
name|binding
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Return non-zero if STRING is the first text to appear at BINDING. */
end_comment

begin_function
name|int
name|looking_at
parameter_list|(
name|string
parameter_list|,
name|binding
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|SEARCH_BINDING
modifier|*
name|binding
decl_stmt|;
block|{
name|long
name|search_end
decl_stmt|;
name|search_end
operator|=
name|search
argument_list|(
name|string
argument_list|,
name|binding
argument_list|)
expr_stmt|;
comment|/* If the string was not found, SEARCH_END is -1.  If the string was found,      but not right away, SEARCH_END is != binding->start.  Otherwise, the      string was found at binding->start. */
return|return
operator|(
name|search_end
operator|==
name|binding
operator|->
name|start
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		      Small String Searches			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Function names that start with "skip" are passed a string, and return    an offset from the start of that string.  Function names that start    with "find" are passed a SEARCH_BINDING, and return an absolute position    marker of the item being searched for.  "Find" functions return a value    of -1 if the item being looked for couldn't be found. */
end_comment

begin_comment
comment|/* Return the index of the first non-whitespace character in STRING. */
end_comment

begin_function
name|int
name|skip_whitespace
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|string
operator|&&
name|whitespace
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the index of the first non-whitespace or newline character in    STRING. */
end_comment

begin_function
name|int
name|skip_whitespace_and_newlines
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|string
operator|&&
operator|(
name|whitespace
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
operator|||
name|string
index|[
name|i
index|]
operator|==
literal|'\n'
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the index of the first whitespace character in STRING. */
end_comment

begin_function
name|int
name|skip_non_whitespace
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|string
operator|&&
operator|!
name|whitespace
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the index of the first non-node character in STRING.  Note that    this function contains quite a bit of hair to ignore periods in some    special cases.  This is because we here at GNU ship some info files which    contain nodenames that contain periods.  No such nodename can start with    a period, or continue with whitespace, newline, or ')' immediately following    the period.  If second argument NEWLINES_OKAY is non-zero, newlines should    be skipped while parsing out the nodename specification. */
end_comment

begin_function
name|int
name|skip_node_characters
parameter_list|(
name|string
parameter_list|,
name|newlines_okay
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|newlines_okay
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|int
name|paren_seen
init|=
literal|0
decl_stmt|;
name|int
name|paren
init|=
literal|0
decl_stmt|;
comment|/* Handle special case.  This is when another function has parsed out the      filename component of the node name, and we just want to parse out the      nodename proper.  In that case, a period at the start of the nodename      indicates an empty nodename. */
if|if
condition|(
name|string
operator|&&
operator|*
name|string
operator|==
literal|'.'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|string
operator|&&
operator|*
name|string
operator|==
literal|'('
condition|)
block|{
name|paren
operator|++
expr_stmt|;
name|paren_seen
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|string
operator|&&
operator|(
name|c
operator|=
name|string
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|paren
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
name|paren
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
name|paren
operator|--
expr_stmt|;
continue|continue;
block|}
comment|/* If the character following the close paren is a space or period, 	 then this node name has no more characters associated with it. */
if|if
condition|(
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|','
operator|||
name|c
operator|==
name|INFO_TAGSEP
operator|||
operator|(
operator|(
operator|!
name|newlines_okay
operator|)
operator|&&
operator|(
name|c
operator|==
literal|'\n'
operator|)
operator|)
operator|||
operator|(
operator|(
name|paren_seen
operator|&&
name|string
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|')'
operator|)
operator|&&
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'.'
operator|)
operator|)
operator|||
operator|(
name|c
operator|==
literal|'.'
operator|&&
operator|(
operator|(
operator|!
name|string
index|[
name|i
operator|+
literal|1
index|]
operator|)
operator|||
operator|(
name|whitespace_or_newline
argument_list|(
name|string
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|)
operator|||
operator|(
name|string
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|')'
operator|)
operator|)
operator|)
condition|)
break|break;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		     Searching FILE_BUFFER's			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Return the absolute position of the first occurence of a node separator in    BINDING-buffer.  The search starts at BINDING->start.  Return -1 if no node    separator was found. */
end_comment

begin_function
name|long
name|find_node_separator
parameter_list|(
name|binding
parameter_list|)
name|SEARCH_BINDING
modifier|*
name|binding
decl_stmt|;
block|{
specifier|register
name|long
name|i
decl_stmt|;
name|char
modifier|*
name|body
decl_stmt|;
name|body
operator|=
name|binding
operator|->
name|buffer
expr_stmt|;
comment|/* A node is started by [^L]^_[^L]\n.  That is to say, the C-l's are      optional, but the DELETE and NEWLINE are not.  This separator holds      true for all separated elements in an Info file, including the tags      table (if present) and the indirect tags table (if present). */
for|for
control|(
name|i
operator|=
name|binding
operator|->
name|start
init|;
name|i
operator|<
name|binding
operator|->
name|end
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|body
index|[
name|i
index|]
operator|==
name|INFO_FF
operator|&&
name|body
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|INFO_COOKIE
operator|)
operator|&&
operator|(
name|body
index|[
name|i
operator|+
literal|2
index|]
operator|==
literal|'\n'
operator|||
operator|(
name|body
index|[
name|i
operator|+
literal|2
index|]
operator|==
name|INFO_FF
operator|&&
name|body
index|[
name|i
operator|+
literal|3
index|]
operator|==
literal|'\n'
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|body
index|[
name|i
index|]
operator|==
name|INFO_COOKIE
operator|)
operator|&&
operator|(
name|body
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\n'
operator|||
operator|(
name|body
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|INFO_FF
operator|&&
name|body
index|[
name|i
operator|+
literal|2
index|]
operator|==
literal|'\n'
operator|)
operator|)
operator|)
condition|)
return|return
operator|(
name|i
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the length of the node separator characters that BODY is    currently pointing at. */
end_comment

begin_function
name|int
name|skip_node_separator
parameter_list|(
name|body
parameter_list|)
name|char
modifier|*
name|body
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|body
index|[
name|i
index|]
operator|==
name|INFO_FF
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|body
index|[
name|i
operator|++
index|]
operator|!=
name|INFO_COOKIE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|body
index|[
name|i
index|]
operator|==
name|INFO_FF
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|body
index|[
name|i
operator|++
index|]
operator|!=
literal|'\n'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the number of characters from STRING to the start of    the next line. */
end_comment

begin_function
name|int
name|skip_line
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|string
operator|&&
name|string
index|[
name|i
index|]
operator|&&
name|string
index|[
name|i
index|]
operator|!=
literal|'\n'
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
name|i
operator|++
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the absolute position of the beginning of a tags table in this    binding starting the search at binding->start. */
end_comment

begin_function
name|long
name|find_tags_table
parameter_list|(
name|binding
parameter_list|)
name|SEARCH_BINDING
modifier|*
name|binding
decl_stmt|;
block|{
name|SEARCH_BINDING
name|search
decl_stmt|;
name|long
name|position
decl_stmt|;
name|search
operator|.
name|buffer
operator|=
name|binding
operator|->
name|buffer
expr_stmt|;
name|search
operator|.
name|start
operator|=
name|binding
operator|->
name|start
expr_stmt|;
name|search
operator|.
name|end
operator|=
name|binding
operator|->
name|end
expr_stmt|;
name|search
operator|.
name|flags
operator|=
name|S_FoldCase
expr_stmt|;
while|while
condition|(
operator|(
name|position
operator|=
name|find_node_separator
argument_list|(
operator|&
name|search
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|search
operator|.
name|start
operator|=
name|position
expr_stmt|;
name|search
operator|.
name|start
operator|+=
name|skip_node_separator
argument_list|(
name|search
operator|.
name|buffer
operator|+
name|search
operator|.
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|looking_at
argument_list|(
name|TAGS_TABLE_BEG_LABEL
argument_list|,
operator|&
name|search
argument_list|)
condition|)
return|return
operator|(
name|position
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the absolute position of the node named NODENAME in BINDING.    This is a brute force search, and we wish to avoid it when possible.    This function is called when a tag (indirect or otherwise) doesn't    really point to the right node.  It returns the absolute position of    the separator preceding the node. */
end_comment

begin_function
name|long
name|find_node_in_binding
parameter_list|(
name|nodename
parameter_list|,
name|binding
parameter_list|)
name|char
modifier|*
name|nodename
decl_stmt|;
name|SEARCH_BINDING
modifier|*
name|binding
decl_stmt|;
block|{
specifier|register
name|long
name|position
decl_stmt|;
specifier|register
name|int
name|offset
decl_stmt|,
name|namelen
decl_stmt|;
name|SEARCH_BINDING
name|search
decl_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
name|search
operator|.
name|buffer
operator|=
name|binding
operator|->
name|buffer
expr_stmt|;
name|search
operator|.
name|start
operator|=
name|binding
operator|->
name|start
expr_stmt|;
name|search
operator|.
name|end
operator|=
name|binding
operator|->
name|end
expr_stmt|;
name|search
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|position
operator|=
name|find_node_separator
argument_list|(
operator|&
name|search
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|search
operator|.
name|start
operator|=
name|position
expr_stmt|;
name|search
operator|.
name|start
operator|+=
name|skip_node_separator
argument_list|(
name|search
operator|.
name|buffer
operator|+
name|search
operator|.
name|start
argument_list|)
expr_stmt|;
name|offset
operator|=
name|string_in_line
argument_list|(
name|INFO_NODE_LABEL
argument_list|,
name|search
operator|.
name|buffer
operator|+
name|search
operator|.
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|search
operator|.
name|start
operator|+=
name|offset
expr_stmt|;
name|search
operator|.
name|start
operator|+=
name|skip_whitespace
argument_list|(
name|search
operator|.
name|buffer
operator|+
name|search
operator|.
name|start
argument_list|)
expr_stmt|;
name|offset
operator|=
name|skip_node_characters
argument_list|(
name|search
operator|.
name|buffer
operator|+
name|search
operator|.
name|start
argument_list|,
name|DONT_SKIP_NEWLINES
argument_list|)
expr_stmt|;
comment|/* Notice that this is an exact match.  You cannot grovel through 	 the buffer with this function looking for random nodes. */
if|if
condition|(
operator|(
name|offset
operator|==
name|namelen
operator|)
operator|&&
operator|(
name|search
operator|.
name|buffer
index|[
name|search
operator|.
name|start
index|]
operator|==
name|nodename
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|search
operator|.
name|buffer
operator|+
name|search
operator|.
name|start
argument_list|,
name|nodename
argument_list|,
name|offset
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|position
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

end_unit

