begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* terminal.c -- How to handle the physical terminal for Info.    $Id: terminal.c,v 1.19 1999/09/20 12:28:54 karl Exp $     Copyright (C) 1988, 89, 90, 91, 92, 93, 96, 97, 98, 99    Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Written by Brian Fox (bfox@ai.mit.edu). */
end_comment

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_include
include|#
directive|include
file|"terminal.h"
end_include

begin_include
include|#
directive|include
file|"termdep.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_comment
comment|/* TIOCGWINSZ on LynxOS, at least */
end_comment

begin_comment
comment|/* The Unix termcap interface code. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_NCURSES_TERMCAP_H
end_ifdef

begin_include
include|#
directive|include
file|<ncurses/termcap.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TERMCAP_H
end_ifdef

begin_include
include|#
directive|include
file|<termcap.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* On Solaris2, sys/types.h #includes sys/reg.h, which #defines PC.    Unfortunately, PC is a global variable used by the termcap library. */
end_comment

begin_undef
undef|#
directive|undef
name|PC
end_undef

begin_comment
comment|/* Termcap requires these variables, whether we access them or not. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|BC
decl_stmt|,
modifier|*
name|UP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|PC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pad character */
end_comment

begin_decl_stmt
name|short
name|ospeed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Terminal output baud rate */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|tgetnum
argument_list|()
decl_stmt|,
name|tgetflag
argument_list|()
decl_stmt|,
name|tgetent
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tgetstr
argument_list|()
decl_stmt|,
modifier|*
name|tgoto
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|tputs
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_TERMCAP_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_NCURSES_TERMCAP_H */
end_comment

begin_comment
comment|/* Function "hooks".  If you make one of these point to a function, that    function is called when appropriate instead of its namesake.  Your    function is called with exactly the same arguments that were passed    to the namesake function. */
end_comment

begin_decl_stmt
name|VFunction
modifier|*
name|terminal_begin_inverse_hook
init|=
operator|(
name|VFunction
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VFunction
modifier|*
name|terminal_end_inverse_hook
init|=
operator|(
name|VFunction
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VFunction
modifier|*
name|terminal_prep_terminal_hook
init|=
operator|(
name|VFunction
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VFunction
modifier|*
name|terminal_unprep_terminal_hook
init|=
operator|(
name|VFunction
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VFunction
modifier|*
name|terminal_up_line_hook
init|=
operator|(
name|VFunction
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VFunction
modifier|*
name|terminal_down_line_hook
init|=
operator|(
name|VFunction
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VFunction
modifier|*
name|terminal_clear_screen_hook
init|=
operator|(
name|VFunction
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VFunction
modifier|*
name|terminal_clear_to_eol_hook
init|=
operator|(
name|VFunction
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VFunction
modifier|*
name|terminal_get_screen_size_hook
init|=
operator|(
name|VFunction
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VFunction
modifier|*
name|terminal_goto_xy_hook
init|=
operator|(
name|VFunction
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VFunction
modifier|*
name|terminal_initialize_terminal_hook
init|=
operator|(
name|VFunction
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VFunction
modifier|*
name|terminal_new_terminal_hook
init|=
operator|(
name|VFunction
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VFunction
modifier|*
name|terminal_put_text_hook
init|=
operator|(
name|VFunction
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VFunction
modifier|*
name|terminal_ring_bell_hook
init|=
operator|(
name|VFunction
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VFunction
modifier|*
name|terminal_write_chars_hook
init|=
operator|(
name|VFunction
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VFunction
modifier|*
name|terminal_scroll_terminal_hook
init|=
operator|(
name|VFunction
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/*                      Terminal and Termcap                        */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* A buffer which holds onto the current terminal description, and a pointer    used to float within it.  And the name of the terminal.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|term_buffer
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|term_string_buffer
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|term_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some strings to control terminal actions.  These are output by tputs (). */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|term_goto
decl_stmt|,
modifier|*
name|term_clreol
decl_stmt|,
modifier|*
name|term_cr
decl_stmt|,
modifier|*
name|term_clrpag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|term_begin_use
decl_stmt|,
modifier|*
name|term_end_use
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|term_AL
decl_stmt|,
modifier|*
name|term_DL
decl_stmt|,
modifier|*
name|term_al
decl_stmt|,
modifier|*
name|term_dl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|term_keypad_on
decl_stmt|,
modifier|*
name|term_keypad_off
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to go up a line. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|term_up
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to go down a line. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|term_dn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An audible bell, if the terminal can be made to make noise. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|audible_bell
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A visible bell, if the terminal can be made to flash the screen. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|visible_bell
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The string to write to turn on the meta key, if this term has one. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|term_mm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The string to write to turn off the meta key, if this term has one. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|term_mo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The string to turn on inverse mode, if this term has one. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|term_invbeg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The string to turn off inverse mode, if this term has one. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|term_invend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Although I can't find any documentation that says this is supposed to    return its argument, all the code I've looked at (termutils, less)    does so, so fine.  */
end_comment

begin_function
specifier|static
name|int
name|output_character_function
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Macro to send STRING to the terminal. */
end_comment

begin_define
define|#
directive|define
name|send_to_terminal
parameter_list|(
name|string
parameter_list|)
define|\
value|do { \     if (string) \       tputs (string, 1, output_character_function); \      } while (0)
end_define

begin_comment
comment|/* Tell the terminal that we will be doing cursor addressable motion.  */
end_comment

begin_function
specifier|static
name|void
name|terminal_begin_using_terminal
parameter_list|()
block|{
name|RETSIGTYPE
function_decl|(
modifier|*
name|sigsave
function_decl|)
parameter_list|()
function_decl|;
if|if
condition|(
name|term_keypad_on
condition|)
name|send_to_terminal
argument_list|(
name|term_keypad_on
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|term_begin_use
operator|||
operator|!
operator|*
name|term_begin_use
condition|)
return|return;
ifdef|#
directive|ifdef
name|SIGWINCH
name|sigsave
operator|=
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|send_to_terminal
argument_list|(
name|term_begin_use
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|term_name
argument_list|,
literal|"sun-cmd"
argument_list|)
condition|)
comment|/* Without this fflush and sleep, running info in a shelltool or        cmdtool (TERM=sun-cmd) with scrollbars loses -- the scrollbars are        not restored properly.        From: strube@physik3.gwdg.de (Hans Werner Strube).  */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGWINCH
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|sigsave
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Tell the terminal that we will not be doing any more cursor    addressable motion. */
end_comment

begin_function
specifier|static
name|void
name|terminal_end_using_terminal
parameter_list|()
block|{
name|RETSIGTYPE
function_decl|(
modifier|*
name|sigsave
function_decl|)
parameter_list|()
function_decl|;
if|if
condition|(
name|term_keypad_off
condition|)
name|send_to_terminal
argument_list|(
name|term_keypad_off
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|term_end_use
operator|||
operator|!
operator|*
name|term_end_use
condition|)
return|return;
ifdef|#
directive|ifdef
name|SIGWINCH
name|sigsave
operator|=
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|send_to_terminal
argument_list|(
name|term_end_use
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|term_name
argument_list|,
literal|"sun-cmd"
argument_list|)
condition|)
comment|/* See comments at other sleep.  */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGWINCH
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
name|sigsave
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/*                   Necessary Terminal Functions                   */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* The functions and variables on this page implement the user visible    portion of the terminal interface. */
end_comment

begin_comment
comment|/* The width and height of the terminal. */
end_comment

begin_decl_stmt
name|int
name|screenwidth
decl_stmt|,
name|screenheight
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means this terminal can't really do anything. */
end_comment

begin_decl_stmt
name|int
name|terminal_is_dumb_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that this terminal has a meta key. */
end_comment

begin_decl_stmt
name|int
name|terminal_has_meta_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that this terminal can produce a visible bell. */
end_comment

begin_decl_stmt
name|int
name|terminal_has_visible_bell_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means to use that visible bell if at all possible. */
end_comment

begin_decl_stmt
name|int
name|terminal_use_visible_bell_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that the terminal can do scrolling. */
end_comment

begin_decl_stmt
name|int
name|terminal_can_scroll
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The key sequences output by the arrow keys, if this terminal has any. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|term_ku
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|term_kd
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|term_kr
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|term_kl
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|term_kP
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* page-up */
end_comment

begin_decl_stmt
name|char
modifier|*
name|term_kN
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* page-down */
end_comment

begin_comment
comment|/* Move the cursor to the terminal location of X and Y. */
end_comment

begin_function
name|void
name|terminal_goto_xy
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
if|if
condition|(
name|terminal_goto_xy_hook
condition|)
call|(
modifier|*
name|terminal_goto_xy_hook
call|)
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|term_goto
condition|)
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|term_goto
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
argument_list|,
literal|1
argument_list|,
name|output_character_function
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print STRING to the terminal at the current position. */
end_comment

begin_function
name|void
name|terminal_put_text
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
if|if
condition|(
name|terminal_put_text_hook
condition|)
call|(
modifier|*
name|terminal_put_text_hook
call|)
argument_list|(
name|string
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print NCHARS from STRING to the terminal at the current position. */
end_comment

begin_function
name|void
name|terminal_write_chars
parameter_list|(
name|string
parameter_list|,
name|nchars
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|nchars
decl_stmt|;
block|{
if|if
condition|(
name|terminal_write_chars_hook
condition|)
call|(
modifier|*
name|terminal_write_chars_hook
call|)
argument_list|(
name|string
argument_list|,
name|nchars
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|nchars
condition|)
name|fwrite
argument_list|(
name|string
argument_list|,
literal|1
argument_list|,
name|nchars
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Clear from the current position of the cursor to the end of the line. */
end_comment

begin_function
name|void
name|terminal_clear_to_eol
parameter_list|()
block|{
if|if
condition|(
name|terminal_clear_to_eol_hook
condition|)
call|(
modifier|*
name|terminal_clear_to_eol_hook
call|)
argument_list|()
expr_stmt|;
else|else
block|{
name|send_to_terminal
argument_list|(
name|term_clreol
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Clear the entire terminal screen. */
end_comment

begin_function
name|void
name|terminal_clear_screen
parameter_list|()
block|{
if|if
condition|(
name|terminal_clear_screen_hook
condition|)
call|(
modifier|*
name|terminal_clear_screen_hook
call|)
argument_list|()
expr_stmt|;
else|else
block|{
name|send_to_terminal
argument_list|(
name|term_clrpag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Move the cursor up one line. */
end_comment

begin_function
name|void
name|terminal_up_line
parameter_list|()
block|{
if|if
condition|(
name|terminal_up_line_hook
condition|)
call|(
modifier|*
name|terminal_up_line_hook
call|)
argument_list|()
expr_stmt|;
else|else
block|{
name|send_to_terminal
argument_list|(
name|term_up
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Move the cursor down one line. */
end_comment

begin_function
name|void
name|terminal_down_line
parameter_list|()
block|{
if|if
condition|(
name|terminal_down_line_hook
condition|)
call|(
modifier|*
name|terminal_down_line_hook
call|)
argument_list|()
expr_stmt|;
else|else
block|{
name|send_to_terminal
argument_list|(
name|term_dn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Turn on reverse video if possible. */
end_comment

begin_function
name|void
name|terminal_begin_inverse
parameter_list|()
block|{
if|if
condition|(
name|terminal_begin_inverse_hook
condition|)
call|(
modifier|*
name|terminal_begin_inverse_hook
call|)
argument_list|()
expr_stmt|;
else|else
block|{
name|send_to_terminal
argument_list|(
name|term_invbeg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Turn off reverse video if possible. */
end_comment

begin_function
name|void
name|terminal_end_inverse
parameter_list|()
block|{
if|if
condition|(
name|terminal_end_inverse_hook
condition|)
call|(
modifier|*
name|terminal_end_inverse_hook
call|)
argument_list|()
expr_stmt|;
else|else
block|{
name|send_to_terminal
argument_list|(
name|term_invend
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Ring the terminal bell.  The bell is run visibly if it both has one and    terminal_use_visible_bell_p is non-zero. */
end_comment

begin_function
name|void
name|terminal_ring_bell
parameter_list|()
block|{
if|if
condition|(
name|terminal_ring_bell_hook
condition|)
call|(
modifier|*
name|terminal_ring_bell_hook
call|)
argument_list|()
expr_stmt|;
else|else
block|{
if|if
condition|(
name|terminal_has_visible_bell_p
operator|&&
name|terminal_use_visible_bell_p
condition|)
name|send_to_terminal
argument_list|(
name|visible_bell
argument_list|)
expr_stmt|;
else|else
name|send_to_terminal
argument_list|(
name|audible_bell
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* At the line START, delete COUNT lines from the terminal display. */
end_comment

begin_function
specifier|static
name|void
name|terminal_delete_lines
parameter_list|(
name|start
parameter_list|,
name|count
parameter_list|)
name|int
name|start
decl_stmt|,
name|count
decl_stmt|;
block|{
name|int
name|lines
decl_stmt|;
comment|/* Normalize arguments. */
if|if
condition|(
name|start
operator|<
literal|0
condition|)
name|start
operator|=
literal|0
expr_stmt|;
name|lines
operator|=
name|screenheight
operator|-
name|start
expr_stmt|;
name|terminal_goto_xy
argument_list|(
literal|0
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|term_DL
condition|)
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|term_DL
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
argument_list|,
name|lines
argument_list|,
name|output_character_function
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|count
operator|--
condition|)
name|tputs
argument_list|(
name|term_dl
argument_list|,
name|lines
argument_list|,
name|output_character_function
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* At the line START, insert COUNT lines in the terminal display. */
end_comment

begin_function
specifier|static
name|void
name|terminal_insert_lines
parameter_list|(
name|start
parameter_list|,
name|count
parameter_list|)
name|int
name|start
decl_stmt|,
name|count
decl_stmt|;
block|{
name|int
name|lines
decl_stmt|;
comment|/* Normalize arguments. */
if|if
condition|(
name|start
operator|<
literal|0
condition|)
name|start
operator|=
literal|0
expr_stmt|;
name|lines
operator|=
name|screenheight
operator|-
name|start
expr_stmt|;
name|terminal_goto_xy
argument_list|(
literal|0
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|term_AL
condition|)
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|term_AL
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
argument_list|,
name|lines
argument_list|,
name|output_character_function
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|count
operator|--
condition|)
name|tputs
argument_list|(
name|term_al
argument_list|,
name|lines
argument_list|,
name|output_character_function
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scroll an area of the terminal, starting with the region from START    to END, AMOUNT lines.  If AMOUNT is negative, the lines are scrolled    towards the top of the screen, else they are scrolled towards the    bottom of the screen. */
end_comment

begin_function
name|void
name|terminal_scroll_terminal
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|,
name|amount
parameter_list|)
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|amount
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|terminal_can_scroll
condition|)
return|return;
comment|/* Any scrolling at all? */
if|if
condition|(
name|amount
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|terminal_scroll_terminal_hook
condition|)
call|(
modifier|*
name|terminal_scroll_terminal_hook
call|)
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|amount
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If we are scrolling down, delete AMOUNT lines at END.  Then insert          AMOUNT lines at START. */
if|if
condition|(
name|amount
operator|>
literal|0
condition|)
block|{
name|terminal_delete_lines
argument_list|(
name|end
argument_list|,
name|amount
argument_list|)
expr_stmt|;
name|terminal_insert_lines
argument_list|(
name|start
argument_list|,
name|amount
argument_list|)
expr_stmt|;
block|}
comment|/* If we are scrolling up, delete AMOUNT lines before START.  This          actually does the upwards scroll.  Then, insert AMOUNT lines          after the already scrolled region (i.e., END - AMOUNT). */
if|if
condition|(
name|amount
operator|<
literal|0
condition|)
block|{
name|int
name|abs_amount
init|=
operator|-
name|amount
decl_stmt|;
name|terminal_delete_lines
argument_list|(
name|start
operator|-
name|abs_amount
argument_list|,
name|abs_amount
argument_list|)
expr_stmt|;
name|terminal_insert_lines
argument_list|(
name|end
operator|-
name|abs_amount
argument_list|,
name|abs_amount
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Re-initialize the terminal considering that the TERM/TERMCAP variable    has changed. */
end_comment

begin_function
name|void
name|terminal_new_terminal
parameter_list|(
name|terminal_name
parameter_list|)
name|char
modifier|*
name|terminal_name
decl_stmt|;
block|{
if|if
condition|(
name|terminal_new_terminal_hook
condition|)
call|(
modifier|*
name|terminal_new_terminal_hook
call|)
argument_list|(
name|terminal_name
argument_list|)
expr_stmt|;
else|else
block|{
name|terminal_initialize_terminal
argument_list|(
name|terminal_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set the global variables SCREENWIDTH and SCREENHEIGHT. */
end_comment

begin_function
name|void
name|terminal_get_screen_size
parameter_list|()
block|{
if|if
condition|(
name|terminal_get_screen_size_hook
condition|)
call|(
modifier|*
name|terminal_get_screen_size_hook
call|)
argument_list|()
expr_stmt|;
else|else
block|{
name|screenwidth
operator|=
name|screenheight
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TIOCGWINSZ
argument_list|)
block|{
name|struct
name|winsize
name|window_size
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|window_size
argument_list|)
operator|==
literal|0
condition|)
block|{
name|screenwidth
operator|=
operator|(
name|int
operator|)
name|window_size
operator|.
name|ws_col
expr_stmt|;
name|screenheight
operator|=
operator|(
name|int
operator|)
name|window_size
operator|.
name|ws_row
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* TIOCGWINSZ */
comment|/* Environment variable COLUMNS overrides setting of "co". */
if|if
condition|(
name|screenwidth
operator|<=
literal|0
condition|)
block|{
name|char
modifier|*
name|sw
init|=
name|getenv
argument_list|(
literal|"COLUMNS"
argument_list|)
decl_stmt|;
if|if
condition|(
name|sw
condition|)
name|screenwidth
operator|=
name|atoi
argument_list|(
name|sw
argument_list|)
expr_stmt|;
if|if
condition|(
name|screenwidth
operator|<=
literal|0
condition|)
name|screenwidth
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
expr_stmt|;
block|}
comment|/* Environment variable LINES overrides setting of "li". */
if|if
condition|(
name|screenheight
operator|<=
literal|0
condition|)
block|{
name|char
modifier|*
name|sh
init|=
name|getenv
argument_list|(
literal|"LINES"
argument_list|)
decl_stmt|;
if|if
condition|(
name|sh
condition|)
name|screenheight
operator|=
name|atoi
argument_list|(
name|sh
argument_list|)
expr_stmt|;
if|if
condition|(
name|screenheight
operator|<=
literal|0
condition|)
name|screenheight
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
block|}
comment|/* If all else fails, default to 80x24 terminal. */
if|if
condition|(
name|screenwidth
operator|<=
literal|0
condition|)
name|screenwidth
operator|=
literal|80
expr_stmt|;
if|if
condition|(
name|screenheight
operator|<=
literal|0
condition|)
name|screenheight
operator|=
literal|24
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize the terminal which is known as TERMINAL_NAME.  If this    terminal doesn't have cursor addressability, `terminal_is_dumb_p'    becomes nonzero.  The variables SCREENHEIGHT and SCREENWIDTH are set    to the dimensions that this terminal actually has.  The variable    TERMINAL_HAS_META_P becomes nonzero if this terminal supports a Meta    key.  Finally, the terminal screen is cleared. */
end_comment

begin_function
name|void
name|terminal_initialize_terminal
parameter_list|(
name|terminal_name
parameter_list|)
name|char
modifier|*
name|terminal_name
decl_stmt|;
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|terminal_is_dumb_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|terminal_initialize_terminal_hook
condition|)
block|{
call|(
modifier|*
name|terminal_initialize_terminal_hook
call|)
argument_list|(
name|terminal_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|term_name
operator|=
name|terminal_name
condition|?
name|terminal_name
else|:
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|term_name
condition|)
name|term_name
operator|=
literal|"dumb"
expr_stmt|;
if|if
condition|(
operator|!
name|term_string_buffer
condition|)
name|term_string_buffer
operator|=
name|xmalloc
argument_list|(
literal|2048
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|term_buffer
condition|)
name|term_buffer
operator|=
name|xmalloc
argument_list|(
literal|2048
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|term_string_buffer
expr_stmt|;
name|term_clrpag
operator|=
name|term_cr
operator|=
name|term_clreol
operator|=
name|NULL
expr_stmt|;
comment|/* HP-UX 11.x returns 0 for OK --jeff.hull@state.co.us.  */
if|if
condition|(
name|tgetent
argument_list|(
name|term_buffer
argument_list|,
name|term_name
argument_list|)
operator|<
literal|0
condition|)
block|{
name|terminal_is_dumb_p
operator|=
literal|1
expr_stmt|;
name|screenwidth
operator|=
literal|80
expr_stmt|;
name|screenheight
operator|=
literal|24
expr_stmt|;
name|term_cr
operator|=
literal|"\r"
expr_stmt|;
name|term_up
operator|=
name|term_dn
operator|=
name|audible_bell
operator|=
name|visible_bell
operator|=
name|NULL
expr_stmt|;
name|term_ku
operator|=
name|term_kd
operator|=
name|term_kl
operator|=
name|term_kr
operator|=
name|NULL
expr_stmt|;
name|term_kP
operator|=
name|term_kN
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|BC
operator|=
name|tgetstr
argument_list|(
literal|"pc"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|PC
operator|=
name|BC
condition|?
operator|*
name|BC
else|:
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS_H
argument_list|)
block|{
name|struct
name|termios
name|ti
decl_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
operator|&
name|ti
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|ospeed
operator|=
name|cfgetospeed
argument_list|(
operator|&
name|ti
argument_list|)
expr_stmt|;
else|else
name|ospeed
operator|=
name|B9600
expr_stmt|;
block|}
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|TIOCGETP
argument_list|)
block|{
name|struct
name|sgttyb
name|sg
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|sg
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|ospeed
operator|=
name|sg
operator|.
name|sg_ospeed
expr_stmt|;
else|else
name|ospeed
operator|=
name|B9600
expr_stmt|;
block|}
else|#
directive|else
name|ospeed
operator|=
name|B9600
expr_stmt|;
endif|#
directive|endif
comment|/* !TIOCGETP */
endif|#
directive|endif
name|term_cr
operator|=
name|tgetstr
argument_list|(
literal|"cr"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|term_clreol
operator|=
name|tgetstr
argument_list|(
literal|"ce"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|term_clrpag
operator|=
name|tgetstr
argument_list|(
literal|"cl"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|term_goto
operator|=
name|tgetstr
argument_list|(
literal|"cm"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
comment|/* Find out about this terminal's scrolling capability. */
name|term_AL
operator|=
name|tgetstr
argument_list|(
literal|"AL"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|term_DL
operator|=
name|tgetstr
argument_list|(
literal|"DL"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|term_al
operator|=
name|tgetstr
argument_list|(
literal|"al"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|term_dl
operator|=
name|tgetstr
argument_list|(
literal|"dl"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|terminal_can_scroll
operator|=
operator|(
operator|(
name|term_AL
operator|||
name|term_al
operator|)
operator|&&
operator|(
name|term_DL
operator|||
name|term_dl
operator|)
operator|)
expr_stmt|;
name|term_invbeg
operator|=
name|tgetstr
argument_list|(
literal|"mr"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|term_invbeg
condition|)
name|term_invend
operator|=
name|tgetstr
argument_list|(
literal|"me"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
else|else
name|term_invend
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|term_cr
condition|)
name|term_cr
operator|=
literal|"\r"
expr_stmt|;
name|terminal_get_screen_size
argument_list|()
expr_stmt|;
name|term_up
operator|=
name|tgetstr
argument_list|(
literal|"up"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|term_dn
operator|=
name|tgetstr
argument_list|(
literal|"dn"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|visible_bell
operator|=
name|tgetstr
argument_list|(
literal|"vb"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|terminal_has_visible_bell_p
operator|=
operator|(
name|visible_bell
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
expr_stmt|;
name|audible_bell
operator|=
name|tgetstr
argument_list|(
literal|"bl"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|audible_bell
condition|)
name|audible_bell
operator|=
literal|"\007"
expr_stmt|;
name|term_begin_use
operator|=
name|tgetstr
argument_list|(
literal|"ti"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|term_end_use
operator|=
name|tgetstr
argument_list|(
literal|"te"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|term_keypad_on
operator|=
name|tgetstr
argument_list|(
literal|"ks"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|term_keypad_off
operator|=
name|tgetstr
argument_list|(
literal|"ke"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
comment|/* Check to see if this terminal has a meta key. */
name|terminal_has_meta_p
operator|=
operator|(
name|tgetflag
argument_list|(
literal|"km"
argument_list|)
operator|||
name|tgetflag
argument_list|(
literal|"MT"
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|terminal_has_meta_p
condition|)
block|{
name|term_mm
operator|=
name|tgetstr
argument_list|(
literal|"mm"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|term_mo
operator|=
name|tgetstr
argument_list|(
literal|"mo"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|term_mm
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|term_mo
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* Attempt to find the arrow keys.  */
name|term_ku
operator|=
name|tgetstr
argument_list|(
literal|"ku"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|term_kd
operator|=
name|tgetstr
argument_list|(
literal|"kd"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|term_kr
operator|=
name|tgetstr
argument_list|(
literal|"kr"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|term_kl
operator|=
name|tgetstr
argument_list|(
literal|"kl"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|term_kP
operator|=
name|tgetstr
argument_list|(
literal|"kP"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
name|term_kN
operator|=
name|tgetstr
argument_list|(
literal|"kN"
argument_list|,
operator|&
name|buffer
argument_list|)
expr_stmt|;
comment|/* If this terminal is not cursor addressable, then it is really dumb. */
if|if
condition|(
operator|!
name|term_goto
condition|)
name|terminal_is_dumb_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* How to read characters from the terminal.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS_H
argument_list|)
end_if

begin_decl_stmt
name|struct
name|termios
name|original_termios
decl_stmt|,
name|ttybuff
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIO_H
argument_list|)
end_if

begin_comment
comment|/* A buffer containing the terminal mode flags upon entry to info. */
end_comment

begin_decl_stmt
name|struct
name|termio
name|original_termio
decl_stmt|,
name|ttybuff
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !HAVE_TERMIO_H */
end_comment

begin_comment
comment|/* Buffers containing the terminal mode flags upon entry to info. */
end_comment

begin_decl_stmt
name|int
name|original_tty_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|original_lmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sgttyb
name|ttybuff
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TIOCGETC
argument_list|)
operator|&&
name|defined
argument_list|(
name|M_XENIX
argument_list|)
end_if

begin_comment
comment|/* SCO 3.2v5.0.2 defines but does not support TIOCGETC.  Gak.  Maybe    better fix would be to use Posix termios in preference.  --gildea,    1jul99.  */
end_comment

begin_undef
undef|#
directive|undef
name|TIOCGETC
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TIOCGETC
argument_list|)
end_if

begin_comment
comment|/* A buffer containing the terminal interrupt characters upon entry    to Info. */
end_comment

begin_decl_stmt
name|struct
name|tchars
name|original_tchars
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TIOCGLTC
argument_list|)
end_if

begin_comment
comment|/* A buffer containing the local terminal mode characters upon entry    to Info. */
end_comment

begin_decl_stmt
name|struct
name|ltchars
name|original_ltchars
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_TERMIO_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_TERMIOS_H */
end_comment

begin_comment
comment|/* Prepare to start using the terminal to read characters singly. */
end_comment

begin_function
name|void
name|terminal_prep_terminal
parameter_list|()
block|{
name|int
name|tty
decl_stmt|;
if|if
condition|(
name|terminal_prep_terminal_hook
condition|)
block|{
call|(
modifier|*
name|terminal_prep_terminal_hook
call|)
argument_list|()
expr_stmt|;
return|return;
block|}
name|terminal_begin_using_terminal
argument_list|()
expr_stmt|;
name|tty
operator|=
name|fileno
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS_H
argument_list|)
name|tcgetattr
argument_list|(
name|tty
argument_list|,
operator|&
name|original_termios
argument_list|)
expr_stmt|;
name|tcgetattr
argument_list|(
name|tty
argument_list|,
operator|&
name|ttybuff
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIO_H
argument_list|)
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|original_termio
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|ttybuff
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS_H
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_TERMIO_H
argument_list|)
name|ttybuff
operator|.
name|c_iflag
operator|&=
operator|(
operator|~
name|ISTRIP
operator|&
operator|~
name|INLCR
operator|&
operator|~
name|IGNCR
operator|&
operator|~
name|ICRNL
operator|&
operator|~
name|IXON
operator|)
expr_stmt|;
comment|/* These output flags are not part of POSIX, so only use them if they    are defined.  */
ifdef|#
directive|ifdef
name|ONLCR
name|ttybuff
operator|.
name|c_oflag
operator|&=
operator|~
name|ONLCR
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OCRNL
name|ttybuff
operator|.
name|c_oflag
operator|&=
operator|~
name|OCRNL
expr_stmt|;
endif|#
directive|endif
name|ttybuff
operator|.
name|c_lflag
operator|&=
operator|(
operator|~
name|ICANON
operator|&
operator|~
name|ECHO
operator|)
expr_stmt|;
name|ttybuff
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|ttybuff
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ttybuff
operator|.
name|c_cc
index|[
name|VINTR
index|]
operator|==
literal|'\177'
condition|)
name|ttybuff
operator|.
name|c_cc
index|[
name|VINTR
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ttybuff
operator|.
name|c_cc
index|[
name|VQUIT
index|]
operator|==
literal|'\177'
condition|)
name|ttybuff
operator|.
name|c_cc
index|[
name|VQUIT
index|]
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|VLNEXT
if|if
condition|(
name|ttybuff
operator|.
name|c_cc
index|[
name|VLNEXT
index|]
operator|==
literal|'\026'
condition|)
name|ttybuff
operator|.
name|c_cc
index|[
name|VLNEXT
index|]
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* VLNEXT */
endif|#
directive|endif
comment|/* TERMIOS or TERMIO */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS_H
argument_list|)
name|tcsetattr
argument_list|(
name|tty
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|ttybuff
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIO_H
argument_list|)
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|ttybuff
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_TERMIOS_H
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_TERMIO_H
argument_list|)
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|ttybuff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|original_tty_flags
condition|)
name|original_tty_flags
operator|=
name|ttybuff
operator|.
name|sg_flags
expr_stmt|;
comment|/* Make this terminal pass 8 bits around while we are using it. */
if|#
directive|if
name|defined
argument_list|(
name|PASS8
argument_list|)
name|ttybuff
operator|.
name|sg_flags
operator||=
name|PASS8
expr_stmt|;
endif|#
directive|endif
comment|/* PASS8 */
if|#
directive|if
name|defined
argument_list|(
name|TIOCLGET
argument_list|)
operator|&&
name|defined
argument_list|(
name|LPASS8
argument_list|)
block|{
name|int
name|flags
decl_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCLGET
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|original_lmode
operator|=
name|flags
expr_stmt|;
name|flags
operator||=
name|LPASS8
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCLSET
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TIOCLGET&& LPASS8 */
if|#
directive|if
name|defined
argument_list|(
name|TIOCGETC
argument_list|)
block|{
name|struct
name|tchars
name|temp
decl_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
name|original_tchars
argument_list|)
expr_stmt|;
name|temp
operator|=
name|original_tchars
expr_stmt|;
comment|/* C-s and C-q. */
name|temp
operator|.
name|t_startc
operator|=
name|temp
operator|.
name|t_stopc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Often set to C-d. */
name|temp
operator|.
name|t_eofc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If the a quit or interrupt character conflicts with one of our        commands, then make it go away. */
if|if
condition|(
name|temp
operator|.
name|t_intrc
operator|==
literal|'\177'
condition|)
name|temp
operator|.
name|t_intrc
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|temp
operator|.
name|t_quitc
operator|==
literal|'\177'
condition|)
name|temp
operator|.
name|t_quitc
operator|=
operator|-
literal|1
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TIOCGETC */
if|#
directive|if
name|defined
argument_list|(
name|TIOCGLTC
argument_list|)
block|{
name|struct
name|ltchars
name|temp
decl_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|original_ltchars
argument_list|)
expr_stmt|;
name|temp
operator|=
name|original_ltchars
expr_stmt|;
comment|/* Make the interrupt keys go away.  Just enough to make people happy. */
name|temp
operator|.
name|t_lnextc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* C-v. */
name|temp
operator|.
name|t_dsuspc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* C-y. */
name|temp
operator|.
name|t_flushc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* C-o. */
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TIOCGLTC */
name|ttybuff
operator|.
name|sg_flags
operator|&=
operator|~
name|ECHO
expr_stmt|;
name|ttybuff
operator|.
name|sg_flags
operator||=
name|CBREAK
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|ttybuff
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !HAVE_TERMIOS_H&& !HAVE_TERMIO_H */
block|}
end_function

begin_comment
comment|/* Restore the tty settings back to what they were before we started using    this terminal. */
end_comment

begin_function
name|void
name|terminal_unprep_terminal
parameter_list|()
block|{
name|int
name|tty
decl_stmt|;
if|if
condition|(
name|terminal_unprep_terminal_hook
condition|)
block|{
call|(
modifier|*
name|terminal_unprep_terminal_hook
call|)
argument_list|()
expr_stmt|;
return|return;
block|}
name|tty
operator|=
name|fileno
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIOS_H
argument_list|)
name|tcsetattr
argument_list|(
name|tty
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|original_termios
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERMIO_H
argument_list|)
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TCSETA
argument_list|,
operator|&
name|original_termio
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !HAVE_TERMIO_H */
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|ttybuff
argument_list|)
expr_stmt|;
name|ttybuff
operator|.
name|sg_flags
operator|=
name|original_tty_flags
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|ttybuff
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TIOCGETC
argument_list|)
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|original_tchars
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCGETC */
if|#
directive|if
name|defined
argument_list|(
name|TIOCGLTC
argument_list|)
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|original_ltchars
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCGLTC */
if|#
directive|if
name|defined
argument_list|(
name|TIOCLGET
argument_list|)
operator|&&
name|defined
argument_list|(
name|LPASS8
argument_list|)
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCLSET
argument_list|,
operator|&
name|original_lmode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCLGET&& LPASS8 */
endif|#
directive|endif
comment|/* !HAVE_TERMIO_H */
endif|#
directive|endif
comment|/* !HAVE_TERMIOS_H */
name|terminal_end_using_terminal
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__MSDOS__
end_ifdef

begin_include
include|#
directive|include
file|"pcterm.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

end_unit

