begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* info.c -- Display nodes of Info files in multiple windows.    $Id: info.c,v 1.18 1998/02/27 21:37:27 karl Exp $     Copyright (C) 1993, 96, 97, 98 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Written by Brian Fox (bfox@ai.mit.edu). */
end_comment

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_include
include|#
directive|include
file|"indices.h"
end_include

begin_include
include|#
directive|include
file|"dribble.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MAN_PAGES
argument_list|)
end_if

begin_include
include|#
directive|include
file|"man.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HANDLE_MAN_PAGES */
end_comment

begin_comment
comment|/* The version numbers of this version of Info. */
end_comment

begin_decl_stmt
name|int
name|info_major_version
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|info_minor_version
init|=
literal|18
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* basename (argv[0]) */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|program_name
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means search all indices for APROPOS_SEARCH_STRING. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|apropos_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variable containing the string to search for when apropos_p is non-zero. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|apropos_search_string
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means search all indices for INDEX_SEARCH_STRING.  Unlike    apropos, this puts the user at the node, running info. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|index_search_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variable containing the string to search for when index_search_p is    non-zero. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|index_search_string
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means print version info only. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_version_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means print a short description of the options. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_help_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of the names of nodes that the user specified with "--node" on the    command line. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|user_nodenames
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|user_nodenames_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|user_nodenames_slots
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String specifying the first file to load.  This string can only be set    by the user specifying "--file" on the command line. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|user_filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String specifying the name of the file to dump nodes to.  This value is    filled if the user speficies "--output" on the command line. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|user_output_filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero indicates that when "--output" is specified, all of the menu    items of the specified nodes (and their subnodes as well) should be    dumped in the order encountered.  This basically can print a book. */
end_comment

begin_decl_stmt
name|int
name|dump_subnodes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure describing the options that Info accepts.  We pass this structure    to getopt_long ().  If you add or otherwise change this structure, you must    also change the string which follows it. */
end_comment

begin_define
define|#
directive|define
name|APROPOS_OPTION
value|1
end_define

begin_define
define|#
directive|define
name|DRIBBLE_OPTION
value|2
end_define

begin_define
define|#
directive|define
name|RESTORE_OPTION
value|3
end_define

begin_define
define|#
directive|define
name|IDXSRCH_OPTION
value|4
end_define

begin_decl_stmt
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"apropos"
block|,
literal|1
block|,
literal|0
block|,
name|APROPOS_OPTION
block|}
block|,
block|{
literal|"directory"
block|,
literal|1
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"node"
block|,
literal|1
block|,
literal|0
block|,
literal|'n'
block|}
block|,
block|{
literal|"file"
block|,
literal|1
block|,
literal|0
block|,
literal|'f'
block|}
block|,
block|{
literal|"subnodes"
block|,
literal|0
block|,
operator|&
name|dump_subnodes
block|,
literal|1
block|}
block|,
block|{
literal|"output"
block|,
literal|1
block|,
literal|0
block|,
literal|'o'
block|}
block|,
block|{
literal|"help"
block|,
literal|0
block|,
operator|&
name|print_help_p
block|,
literal|1
block|}
block|,
block|{
literal|"version"
block|,
literal|0
block|,
operator|&
name|print_version_p
block|,
literal|1
block|}
block|,
block|{
literal|"dribble"
block|,
literal|1
block|,
literal|0
block|,
name|DRIBBLE_OPTION
block|}
block|,
block|{
literal|"restore"
block|,
literal|1
block|,
literal|0
block|,
name|RESTORE_OPTION
block|}
block|,
block|{
literal|"index-search"
block|,
literal|1
block|,
literal|0
block|,
name|IDXSRCH_OPTION
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String describing the shorthand versions of the long options found above. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|short_options
init|=
literal|"d:n:f:o:s"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When non-zero, the Info window system has been initialized. */
end_comment

begin_decl_stmt
name|int
name|info_windows_initialized_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some "forward" declarations. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|info_short_help
argument_list|()
decl_stmt|,
name|remember_info_program_name
argument_list|()
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/*                Main Entry Point to the Info Program              */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|getopt_long_index
decl_stmt|;
comment|/* Index returned by getopt_long (). */
name|NODE
modifier|*
name|initial_node
decl_stmt|;
comment|/* First node loaded by Info. */
name|remember_info_program_name
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SETLOCALE
comment|/* Set locale via LC_ALL.  */
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set the text message domain.  */
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|option_character
decl_stmt|;
name|option_character
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|short_options
argument_list|,
name|long_options
argument_list|,
operator|&
name|getopt_long_index
argument_list|)
expr_stmt|;
comment|/* getopt_long () returns EOF when there are no more long options. */
if|if
condition|(
name|option_character
operator|==
name|EOF
condition|)
break|break;
comment|/* If this is a long option, then get the short version of it. */
if|if
condition|(
name|option_character
operator|==
literal|0
operator|&&
name|long_options
index|[
name|getopt_long_index
index|]
operator|.
name|flag
operator|==
literal|0
condition|)
name|option_character
operator|=
name|long_options
index|[
name|getopt_long_index
index|]
operator|.
name|val
expr_stmt|;
comment|/* Case on the option that we have received. */
switch|switch
condition|(
name|option_character
condition|)
block|{
case|case
literal|0
case|:
break|break;
comment|/* User wants to add a directory. */
case|case
literal|'d'
case|:
name|info_add_path
argument_list|(
name|optarg
argument_list|,
name|INFOPATH_PREPEND
argument_list|)
expr_stmt|;
break|break;
comment|/* User is specifying a particular node. */
case|case
literal|'n'
case|:
name|add_pointer_to_array
argument_list|(
name|optarg
argument_list|,
name|user_nodenames_index
argument_list|,
name|user_nodenames
argument_list|,
name|user_nodenames_slots
argument_list|,
literal|10
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
break|break;
comment|/* User is specifying a particular Info file. */
case|case
literal|'f'
case|:
if|if
condition|(
name|user_filename
condition|)
name|free
argument_list|(
name|user_filename
argument_list|)
expr_stmt|;
name|user_filename
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
comment|/* User is specifying the name of a file to output to. */
case|case
literal|'o'
case|:
if|if
condition|(
name|user_output_filename
condition|)
name|free
argument_list|(
name|user_output_filename
argument_list|)
expr_stmt|;
name|user_output_filename
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
comment|/* User is specifying that she wishes to dump the subnodes of              the node that she is dumping. */
case|case
literal|'s'
case|:
name|dump_subnodes
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* User has specified a string to search all indices for. */
case|case
name|APROPOS_OPTION
case|:
name|apropos_p
operator|=
literal|1
expr_stmt|;
name|maybe_free
argument_list|(
name|apropos_search_string
argument_list|)
expr_stmt|;
name|apropos_search_string
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
comment|/* User has specified a dribble file to receive keystrokes. */
case|case
name|DRIBBLE_OPTION
case|:
name|close_dribble_file
argument_list|()
expr_stmt|;
name|open_dribble_file
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
comment|/* User has specified an alternate input stream. */
case|case
name|RESTORE_OPTION
case|:
name|info_set_input_from_file
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
comment|/* User has specified a string to search all indices for. */
case|case
name|IDXSRCH_OPTION
case|:
name|index_search_p
operator|=
literal|1
expr_stmt|;
name|maybe_free
argument_list|(
name|index_search_string
argument_list|)
expr_stmt|;
name|index_search_string
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Try --help for more information."
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the output device is not a terminal, and no output filename has been      specified, make user_output_filename be "-", so that the info is written      to stdout, and turn on the dumping of subnodes. */
if|if
condition|(
operator|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|user_output_filename
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
name|user_output_filename
operator|=
name|xstrdup
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
name|dump_subnodes
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If the user specified --version, then show the version and exit. */
if|if
condition|(
name|print_version_p
condition|)
block|{
name|printf
argument_list|(
literal|"%s (GNU %s %s) %s\n"
argument_list|,
name|program_name
argument_list|,
name|PACKAGE
argument_list|,
name|VERSION
argument_list|,
name|version_string
argument_list|()
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Copyright (C) %s Free Software Foundation, Inc.\n\ There is NO warranty.  You may redistribute this software\n\ under the terms of the GNU General Public License.\n\ For more information about these matters, see the files named COPYING.\n"
argument_list|)
argument_list|,
literal|"1998"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If the `--help' option was present, show the help and exit. */
if|if
condition|(
name|print_help_p
condition|)
block|{
name|info_short_help
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If the user hasn't specified a path for Info files, default it.      Lowest priority is our messy hardwired list in filesys.h.      Then comes the user's INFODIR from the Makefile.      Highest priority is the environment variable, if set.  */
if|if
condition|(
operator|!
name|infopath
condition|)
block|{
name|char
modifier|*
name|path_from_env
init|=
name|getenv
argument_list|(
literal|"INFOPATH"
argument_list|)
decl_stmt|;
if|if
condition|(
name|path_from_env
condition|)
block|{
name|unsigned
name|len
init|=
name|strlen
argument_list|(
name|path_from_env
argument_list|)
decl_stmt|;
comment|/* Trailing : on INFOPATH means insert the default path.  */
if|if
condition|(
name|len
operator|&&
name|path_from_env
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|path_from_env
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|info_add_path
argument_list|(
name|DEFAULT_INFOPATH
argument_list|,
name|INFOPATH_PREPEND
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INFODIR
comment|/* from the Makefile */
name|info_add_path
argument_list|(
name|INFODIR
argument_list|,
name|INFOPATH_PREPEND
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|info_add_path
argument_list|(
name|path_from_env
argument_list|,
name|INFOPATH_PREPEND
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|info_add_path
argument_list|(
name|DEFAULT_INFOPATH
argument_list|,
name|INFOPATH_PREPEND
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INFODIR
comment|/* from the Makefile */
name|info_add_path
argument_list|(
name|INFODIR
argument_list|,
name|INFOPATH_PREPEND
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* If the user specified a particular filename, add the path of that      file to the contents of INFOPATH. */
if|if
condition|(
name|user_filename
condition|)
block|{
name|char
modifier|*
name|directory_name
init|=
name|xstrdup
argument_list|(
name|user_filename
argument_list|)
decl_stmt|;
name|char
modifier|*
name|temp
init|=
name|filename_non_directory
argument_list|(
name|directory_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|!=
name|directory_name
condition|)
block|{
operator|*
name|temp
operator|=
literal|0
expr_stmt|;
name|info_add_path
argument_list|(
name|directory_name
argument_list|,
name|INFOPATH_PREPEND
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|directory_name
argument_list|)
expr_stmt|;
block|}
comment|/* If the user wants to search every known index for a given string,      do that now, and report the results. */
if|if
condition|(
name|apropos_p
condition|)
block|{
name|info_apropos
argument_list|(
name|apropos_search_string
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Get the initial Info node.  It is either "(dir)Top", or what the user      specifed with values in user_filename and user_nodenames. */
name|initial_node
operator|=
name|info_get_node
argument_list|(
name|user_filename
argument_list|,
name|user_nodenames
condition|?
name|user_nodenames
index|[
literal|0
index|]
else|:
name|NULL
argument_list|)
expr_stmt|;
comment|/* If we couldn't get the initial node, this user is in trouble. */
if|if
condition|(
operator|!
name|initial_node
condition|)
block|{
if|if
condition|(
name|info_recent_file_error
condition|)
name|info_error
argument_list|(
name|info_recent_file_error
argument_list|)
expr_stmt|;
else|else
name|info_error
argument_list|(
name|CANT_FIND_NODE
argument_list|,
name|user_nodenames
condition|?
name|user_nodenames
index|[
literal|0
index|]
else|:
literal|"Top"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Special cases for when the user specifies multiple nodes.  If we      are dumping to an output file, dump all of the nodes specified.      Otherwise, attempt to create enough windows to handle the nodes      that this user wants displayed. */
if|if
condition|(
name|user_nodenames_index
operator|>
literal|1
condition|)
block|{
name|free
argument_list|(
name|initial_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|user_output_filename
condition|)
name|dump_nodes_to_file
argument_list|(
name|user_filename
argument_list|,
name|user_nodenames
argument_list|,
name|user_output_filename
argument_list|,
name|dump_subnodes
argument_list|)
expr_stmt|;
else|else
name|begin_multiple_window_info_session
argument_list|(
name|user_filename
argument_list|,
name|user_nodenames
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If the user specified `--index-search=STRING', start the info      session in the node corresponding to the first match. */
if|if
condition|(
name|index_search_p
condition|)
block|{
name|int
name|status
init|=
literal|0
decl_stmt|;
name|initialize_info_session
argument_list|(
name|initial_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|index_entry_exists
argument_list|(
name|windows
argument_list|,
name|index_search_string
argument_list|)
condition|)
block|{
name|terminal_clear_screen
argument_list|()
expr_stmt|;
name|terminal_prep_terminal
argument_list|()
expr_stmt|;
name|display_update_display
argument_list|(
name|windows
argument_list|)
expr_stmt|;
name|info_last_executed_command
operator|=
operator|(
name|VFunction
operator|*
operator|)
name|NULL
expr_stmt|;
name|do_info_index_search
argument_list|(
name|windows
argument_list|,
literal|0
argument_list|,
name|index_search_string
argument_list|)
expr_stmt|;
name|info_read_and_dispatch
argument_list|()
expr_stmt|;
name|terminal_unprep_terminal
argument_list|()
expr_stmt|;
comment|/* On program exit, leave the cursor at the bottom of the              window, and restore the terminal IO. */
name|terminal_goto_xy
argument_list|(
literal|0
argument_list|,
name|screenheight
operator|-
literal|1
argument_list|)
expr_stmt|;
name|terminal_clear_to_eol
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputs
argument_list|(
name|_
argument_list|(
literal|"no entries found\n"
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|status
operator|=
literal|2
expr_stmt|;
block|}
name|close_dribble_file
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
comment|/* If there are arguments remaining, they are the names of menu items      in sequential info files starting from the first one loaded.  That      file name is either "dir", or the contents of user_filename if one      was specified. */
while|while
condition|(
name|optind
operator|!=
name|argc
condition|)
block|{
name|REFERENCE
modifier|*
modifier|*
name|menu
decl_stmt|;
name|REFERENCE
modifier|*
name|entry
decl_stmt|;
name|NODE
modifier|*
name|node
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
specifier|static
name|char
modifier|*
name|first_arg
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* Remember the name of the menu entry we want. */
name|arg
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|first_arg
condition|)
name|first_arg
operator|=
name|arg
expr_stmt|;
comment|/* Build and return a list of the menu items in this node. */
name|menu
operator|=
name|info_menu_of_node
argument_list|(
name|initial_node
argument_list|)
expr_stmt|;
comment|/* If there wasn't a menu item in this node, stop here, but let          the user continue to use Info.  Perhaps they wanted this node          and didn't realize it. */
if|if
condition|(
operator|!
name|menu
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MAN_PAGES
argument_list|)
if|if
condition|(
name|first_arg
operator|==
name|arg
condition|)
block|{
name|node
operator|=
name|make_manpage_node
argument_list|(
name|first_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
goto|goto
name|maybe_got_node
goto|;
block|}
endif|#
directive|endif
comment|/* HANDLE_MAN_PAGES */
name|begin_info_session_with_error
argument_list|(
name|initial_node
argument_list|,
name|_
argument_list|(
literal|"There is no menu in this node."
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Find the specified menu item. */
name|entry
operator|=
name|info_get_labeled_reference
argument_list|(
name|arg
argument_list|,
name|menu
argument_list|)
expr_stmt|;
comment|/* If the item wasn't found, search the list sloppily.  Perhaps this          user typed "buffer" when they really meant "Buffers". */
if|if
condition|(
operator|!
name|entry
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|best_guess
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|entry
operator|=
name|menu
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|entry
operator|->
name|label
argument_list|,
name|arg
argument_list|)
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|entry
operator|->
name|label
argument_list|,
name|arg
argument_list|,
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|best_guess
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|entry
operator|&&
name|best_guess
operator|!=
operator|-
literal|1
condition|)
name|entry
operator|=
name|menu
index|[
name|best_guess
index|]
expr_stmt|;
block|}
comment|/* If we failed to find the reference, start Info with the current          node anyway.  It is probably a misspelling. */
if|if
condition|(
operator|!
name|entry
condition|)
block|{
name|char
modifier|*
name|error_message
init|=
name|_
argument_list|(
literal|"There is no menu item \"%s\" in this node."
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MAN_PAGES
argument_list|)
if|if
condition|(
name|first_arg
operator|==
name|arg
condition|)
block|{
name|node
operator|=
name|make_manpage_node
argument_list|(
name|first_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
goto|goto
name|maybe_got_node
goto|;
block|}
endif|#
directive|endif
comment|/* HANDLE_MAN_PAGES */
name|info_free_references
argument_list|(
name|menu
argument_list|)
expr_stmt|;
comment|/* If we were supposed to dump this node, complain. */
if|if
condition|(
name|user_output_filename
condition|)
name|info_error
argument_list|(
name|error_message
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|begin_info_session_with_error
argument_list|(
name|initial_node
argument_list|,
name|error_message
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* We have found the reference that the user specified.  Clean it          up a little bit. */
if|if
condition|(
operator|!
name|entry
operator|->
name|filename
condition|)
block|{
if|if
condition|(
name|initial_node
operator|->
name|parent
condition|)
name|entry
operator|->
name|filename
operator|=
name|xstrdup
argument_list|(
name|initial_node
operator|->
name|parent
argument_list|)
expr_stmt|;
else|else
name|entry
operator|->
name|filename
operator|=
name|xstrdup
argument_list|(
name|initial_node
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
comment|/* Find this node.  If we can find it, then turn the initial_node          into this one.  If we cannot find it, try using the label of the          entry as a file (i.e., "(LABEL)Top").  Otherwise the Info file is          malformed in some way, and we will just use the current value of          initial node. */
name|node
operator|=
name|info_get_node
argument_list|(
name|entry
operator|->
name|filename
argument_list|,
name|entry
operator|->
name|nodename
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MAN_PAGES
argument_list|)
if|if
condition|(
operator|(
name|first_arg
operator|==
name|arg
operator|)
operator|&&
operator|!
name|node
condition|)
block|{
name|node
operator|=
name|make_manpage_node
argument_list|(
name|first_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
goto|goto
name|maybe_got_node
goto|;
block|}
endif|#
directive|endif
comment|/* HANDLE_MAN_PAGES */
if|if
condition|(
operator|!
name|node
operator|&&
name|entry
operator|->
name|nodename
operator|&&
operator|(
name|strcmp
argument_list|(
name|entry
operator|->
name|label
argument_list|,
name|entry
operator|->
name|nodename
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|node
operator|=
name|info_get_node
argument_list|(
name|entry
operator|->
name|label
argument_list|,
literal|"Top"
argument_list|)
expr_stmt|;
name|maybe_got_node
label|:
if|if
condition|(
name|node
condition|)
block|{
name|free
argument_list|(
name|initial_node
argument_list|)
expr_stmt|;
name|initial_node
operator|=
name|node
expr_stmt|;
name|info_free_references
argument_list|(
name|menu
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|temp
init|=
name|xstrdup
argument_list|(
name|entry
operator|->
name|label
argument_list|)
decl_stmt|;
name|char
modifier|*
name|error_message
decl_stmt|;
name|error_message
operator|=
name|_
argument_list|(
literal|"Unable to find the node referenced by \"%s\"."
argument_list|)
expr_stmt|;
name|info_free_references
argument_list|(
name|menu
argument_list|)
expr_stmt|;
comment|/* If we were trying to dump the node, then give up.  Otherwise,              start the session with an error message. */
if|if
condition|(
name|user_output_filename
condition|)
name|info_error
argument_list|(
name|error_message
argument_list|,
name|temp
argument_list|)
expr_stmt|;
else|else
name|begin_info_session_with_error
argument_list|(
name|initial_node
argument_list|,
name|error_message
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the user specified that this node should be output, then do that      now.  Otherwise, start the Info session with this node. */
if|if
condition|(
name|user_output_filename
condition|)
name|dump_node_to_file
argument_list|(
name|initial_node
argument_list|,
name|user_output_filename
argument_list|,
name|dump_subnodes
argument_list|)
expr_stmt|;
else|else
name|begin_info_session
argument_list|(
name|initial_node
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a string describing the current version of Info. */
end_comment

begin_function
name|char
modifier|*
name|version_string
parameter_list|()
block|{
specifier|static
name|char
modifier|*
name|vstring
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|vstring
condition|)
block|{
name|vstring
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|vstring
argument_list|,
literal|"%d.%d"
argument_list|,
name|info_major_version
argument_list|,
name|info_minor_version
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|vstring
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Error handling.  */
end_comment

begin_function
specifier|static
name|void
name|remember_info_program_name
parameter_list|(
name|fullpath
parameter_list|)
name|char
modifier|*
name|fullpath
decl_stmt|;
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|filename
operator|=
name|filename_non_directory
argument_list|(
name|fullpath
argument_list|)
expr_stmt|;
name|program_name
operator|=
name|xstrdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Non-zero if an error has been signalled. */
end_comment

begin_decl_stmt
name|int
name|info_error_was_printed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means ring terminal bell on errors. */
end_comment

begin_decl_stmt
name|int
name|info_error_rings_bell_p
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print FORMAT with ARG1 and ARG2.  If the window system was initialized,    then the message is printed in the echo area.  Otherwise, a message is    output to stderr. */
end_comment

begin_function
name|void
name|info_error
parameter_list|(
name|format
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
name|void
modifier|*
name|arg1
decl_stmt|,
decl|*
name|arg2
decl_stmt|;
end_function

begin_block
block|{
name|info_error_was_printed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|info_windows_initialized_p
operator|||
name|display_inhibited
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|echo_area_is_active
condition|)
block|{
if|if
condition|(
name|info_error_rings_bell_p
condition|)
name|terminal_ring_bell
argument_list|()
expr_stmt|;
name|window_message_in_echo_area
argument_list|(
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NODE
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|build_message_node
argument_list|(
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_error_rings_bell_p
condition|)
name|terminal_ring_bell
argument_list|()
expr_stmt|;
name|inform_in_echo_area
argument_list|(
name|temp
operator|->
name|contents
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|contents
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Produce a scaled down description of the available options to Info. */
end_comment

begin_function
specifier|static
name|void
name|info_short_help
parameter_list|()
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ Usage: %s [OPTION]... [INFO-FILE [MENU-ITEM...]]\n\ \n\ Read documentation in Info format.\n\ For more complete documentation on how to use Info, run `info info options'.\n\ \n\ Options:\n\ --directory DIR              add DIR to INFOPATH.\n\ --dribble FILENAME           remember user keystrokes in FILENAME.\n\ --file FILENAME              specify Info file to visit.\n\ --node NODENAME              specify nodes in first visited Info file.\n\ --output FILENAME            output selected nodes to FILENAME.\n\ --restore FILENAME           read initial keystrokes from FILENAME.\n\ --subnodes                   recursively output menu items.\n\ --help                       display this help and exit.\n\ --version                    display version information and exit.\n\ \n\ The first argument, if present, is the name of the Info file to read.\n\ Any remaining arguments are treated as the names of menu\n\ items in the initial node visited.  For example, `info emacs buffers'\n\ moves to the node `buffers' in the info file `emacs'.\n\ \n\ Email bug reports to bug-texinfo@gnu.org."
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

