begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* info.c -- Display nodes of Info files in multiple windows.    $Id: info.c,v 1.53 2002/03/02 15:18:58 karl Exp $     Copyright (C) 1993, 96, 97, 98, 99, 2000, 01, 02    Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Written by Brian Fox (bfox@ai.mit.edu). */
end_comment

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_include
include|#
directive|include
file|"indices.h"
end_include

begin_include
include|#
directive|include
file|"dribble.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MAN_PAGES
argument_list|)
end_if

begin_include
include|#
directive|include
file|"man.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HANDLE_MAN_PAGES */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|program_name
init|=
literal|"info"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means search all indices for APROPOS_SEARCH_STRING. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|apropos_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variable containing the string to search for when apropos_p is non-zero. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|apropos_search_string
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means search all indices for INDEX_SEARCH_STRING.  Unlike    apropos, this puts the user at the node, running info. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|index_search_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means look for the node which describes the invocation    and command-line options of the program, and start the info    session at that node.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|goto_invocation_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variable containing the string to search for when index_search_p is    non-zero. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|index_search_string
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means print version info only. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_version_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means print a short description of the options. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_help_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of the names of nodes that the user specified with "--node" on the    command line. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|user_nodenames
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|user_nodenames_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|user_nodenames_slots
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String specifying the first file to load.  This string can only be set    by the user specifying "--file" on the command line. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|user_filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String specifying the name of the file to dump nodes to.  This value is    filled if the user speficies "--output" on the command line. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|user_output_filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero indicates that when "--output" is specified, all of the menu    items of the specified nodes (and their subnodes as well) should be    dumped in the order encountered.  This basically can print a book. */
end_comment

begin_decl_stmt
name|int
name|dump_subnodes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means make default keybindings be loosely modeled on vi(1).  */
end_comment

begin_decl_stmt
name|int
name|vi_keys_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means don't remove ANSI escape sequences from man pages.  */
end_comment

begin_decl_stmt
name|int
name|raw_escapes_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__MSDOS__
end_ifdef

begin_comment
comment|/* Non-zero indicates that screen output should be made 'speech-friendly'.    Since on MSDOS the usual behavior is to write directly to the video    memory, speech synthesizer software cannot grab the output.  Therefore,    we provide a user option which tells us to avoid direct screen output    and use stdout instead (which loses the color output).  */
end_comment

begin_decl_stmt
name|int
name|speech_friendly
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Structure describing the options that Info accepts.  We pass this structure    to getopt_long ().  If you add or otherwise change this structure, you must    also change the string which follows it. */
end_comment

begin_define
define|#
directive|define
name|APROPOS_OPTION
value|1
end_define

begin_define
define|#
directive|define
name|DRIBBLE_OPTION
value|2
end_define

begin_define
define|#
directive|define
name|RESTORE_OPTION
value|3
end_define

begin_define
define|#
directive|define
name|IDXSRCH_OPTION
value|4
end_define

begin_decl_stmt
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"apropos"
block|,
literal|1
block|,
literal|0
block|,
name|APROPOS_OPTION
block|}
block|,
block|{
literal|"directory"
block|,
literal|1
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"node"
block|,
literal|1
block|,
literal|0
block|,
literal|'n'
block|}
block|,
block|{
literal|"file"
block|,
literal|1
block|,
literal|0
block|,
literal|'f'
block|}
block|,
block|{
literal|"subnodes"
block|,
literal|0
block|,
operator|&
name|dump_subnodes
block|,
literal|1
block|}
block|,
block|{
literal|"output"
block|,
literal|1
block|,
literal|0
block|,
literal|'o'
block|}
block|,
block|{
literal|"raw-escapes"
block|,
literal|0
block|,
operator|&
name|raw_escapes_p
block|,
literal|1
block|}
block|,
block|{
literal|"show-options"
block|,
literal|0
block|,
literal|0
block|,
literal|'O'
block|}
block|,
block|{
literal|"usage"
block|,
literal|0
block|,
literal|0
block|,
literal|'O'
block|}
block|,
block|{
literal|"vi-keys"
block|,
literal|0
block|,
operator|&
name|vi_keys_p
block|,
literal|1
block|}
block|,
block|{
literal|"help"
block|,
literal|0
block|,
operator|&
name|print_help_p
block|,
literal|1
block|}
block|,
block|{
literal|"version"
block|,
literal|0
block|,
operator|&
name|print_version_p
block|,
literal|1
block|}
block|,
block|{
literal|"dribble"
block|,
literal|1
block|,
literal|0
block|,
name|DRIBBLE_OPTION
block|}
block|,
block|{
literal|"restore"
block|,
literal|1
block|,
literal|0
block|,
name|RESTORE_OPTION
block|}
block|,
ifdef|#
directive|ifdef
name|__MSDOS__
block|{
literal|"speech-friendly"
block|,
literal|0
block|,
operator|&
name|speech_friendly
block|,
literal|1
block|}
block|,
endif|#
directive|endif
block|{
literal|"index-search"
block|,
literal|1
block|,
literal|0
block|,
name|IDXSRCH_OPTION
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String describing the shorthand versions of the long options found above. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__MSDOS__
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|short_options
init|=
literal|"d:n:f:o:ORsb"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
modifier|*
name|short_options
init|=
literal|"d:n:f:o:ORs"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* When non-zero, the Info window system has been initialized. */
end_comment

begin_decl_stmt
name|int
name|info_windows_initialized_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some "forward" declarations. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|info_short_help
argument_list|()
decl_stmt|,
name|remember_info_program_name
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|init_messages
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|add_file_directory_to_path
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/*                Main Entry Point to the Info Program              */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|getopt_long_index
decl_stmt|;
comment|/* Index returned by getopt_long (). */
name|NODE
modifier|*
name|initial_node
decl_stmt|;
comment|/* First node loaded by Info. */
ifdef|#
directive|ifdef
name|HAVE_SETLOCALE
comment|/* Set locale via LC_ALL.  */
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set the text message domain.  */
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
name|init_messages
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|option_character
decl_stmt|;
name|option_character
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|short_options
argument_list|,
name|long_options
argument_list|,
operator|&
name|getopt_long_index
argument_list|)
expr_stmt|;
comment|/* getopt_long () returns EOF when there are no more long options. */
if|if
condition|(
name|option_character
operator|==
name|EOF
condition|)
break|break;
comment|/* If this is a long option, then get the short version of it. */
if|if
condition|(
name|option_character
operator|==
literal|0
operator|&&
name|long_options
index|[
name|getopt_long_index
index|]
operator|.
name|flag
operator|==
literal|0
condition|)
name|option_character
operator|=
name|long_options
index|[
name|getopt_long_index
index|]
operator|.
name|val
expr_stmt|;
comment|/* Case on the option that we have received. */
switch|switch
condition|(
name|option_character
condition|)
block|{
case|case
literal|0
case|:
break|break;
comment|/* User wants to add a directory. */
case|case
literal|'d'
case|:
name|info_add_path
argument_list|(
name|optarg
argument_list|,
name|INFOPATH_PREPEND
argument_list|)
expr_stmt|;
break|break;
comment|/* User is specifying a particular node. */
case|case
literal|'n'
case|:
name|add_pointer_to_array
argument_list|(
name|optarg
argument_list|,
name|user_nodenames_index
argument_list|,
name|user_nodenames
argument_list|,
name|user_nodenames_slots
argument_list|,
literal|10
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
break|break;
comment|/* User is specifying a particular Info file. */
case|case
literal|'f'
case|:
if|if
condition|(
name|user_filename
condition|)
name|free
argument_list|(
name|user_filename
argument_list|)
expr_stmt|;
name|user_filename
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
comment|/* User is specifying the name of a file to output to. */
case|case
literal|'o'
case|:
if|if
condition|(
name|user_output_filename
condition|)
name|free
argument_list|(
name|user_output_filename
argument_list|)
expr_stmt|;
name|user_output_filename
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
comment|/* User has specified that she wants to find the "Options"              or "Invocation" node for the program.  */
case|case
literal|'O'
case|:
name|goto_invocation_p
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* User has specified that she wants the escape sequences 	     in man pages to be passed thru unaltered.  */
case|case
literal|'R'
case|:
name|raw_escapes_p
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* User is specifying that she wishes to dump the subnodes of              the node that she is dumping. */
case|case
literal|'s'
case|:
name|dump_subnodes
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|__MSDOS__
comment|/* User wants speech-friendly output.  */
case|case
literal|'b'
case|:
name|speech_friendly
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* __MSDOS__ */
comment|/* User has specified a string to search all indices for. */
case|case
name|APROPOS_OPTION
case|:
name|apropos_p
operator|=
literal|1
expr_stmt|;
name|maybe_free
argument_list|(
name|apropos_search_string
argument_list|)
expr_stmt|;
name|apropos_search_string
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
comment|/* User has specified a dribble file to receive keystrokes. */
case|case
name|DRIBBLE_OPTION
case|:
name|close_dribble_file
argument_list|()
expr_stmt|;
name|open_dribble_file
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
comment|/* User has specified an alternate input stream. */
case|case
name|RESTORE_OPTION
case|:
name|info_set_input_from_file
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
comment|/* User has specified a string to search all indices for. */
case|case
name|IDXSRCH_OPTION
case|:
name|index_search_p
operator|=
literal|1
expr_stmt|;
name|maybe_free
argument_list|(
name|index_search_string
argument_list|)
expr_stmt|;
name|index_search_string
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Try --help for more information.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the output device is not a terminal, and no output filename has been      specified, make user_output_filename be "-", so that the info is written      to stdout, and turn on the dumping of subnodes. */
if|if
condition|(
operator|(
operator|!
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|user_output_filename
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
name|user_output_filename
operator|=
name|xstrdup
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
name|dump_subnodes
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If the user specified --version, then show the version and exit. */
if|if
condition|(
name|print_version_p
condition|)
block|{
name|printf
argument_list|(
literal|"%s (GNU %s) %s\n"
argument_list|,
name|program_name
argument_list|,
name|PACKAGE
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Copyright (C) %s Free Software Foundation, Inc.\n\ There is NO warranty.  You may redistribute this software\n\ under the terms of the GNU General Public License.\n\ For more information about these matters, see the files named COPYING.\n"
argument_list|)
argument_list|,
literal|"2002"
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If the `--help' option was present, show the help and exit. */
if|if
condition|(
name|print_help_p
condition|)
block|{
name|info_short_help
argument_list|()
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If the user hasn't specified a path for Info files, default it.      Lowest priority is our messy hardwired list in filesys.h.      Then comes the user's INFODIR from the Makefile.      Highest priority is the environment variable, if set.  */
if|if
condition|(
operator|!
name|infopath
condition|)
block|{
name|char
modifier|*
name|path_from_env
init|=
name|getenv
argument_list|(
literal|"INFOPATH"
argument_list|)
decl_stmt|;
if|if
condition|(
name|path_from_env
condition|)
block|{
name|unsigned
name|len
init|=
name|strlen
argument_list|(
name|path_from_env
argument_list|)
decl_stmt|;
comment|/* Trailing : on INFOPATH means insert the default path.  */
if|if
condition|(
name|len
operator|&&
name|path_from_env
index|[
name|len
operator|-
literal|1
index|]
operator|==
name|PATH_SEP
index|[
literal|0
index|]
condition|)
block|{
name|path_from_env
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|info_add_path
argument_list|(
name|DEFAULT_INFOPATH
argument_list|,
name|INFOPATH_PREPEND
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INFODIR
comment|/* from the Makefile */
name|info_add_path
argument_list|(
name|INFODIR
argument_list|,
name|INFOPATH_PREPEND
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|info_add_path
argument_list|(
name|path_from_env
argument_list|,
name|INFOPATH_PREPEND
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|info_add_path
argument_list|(
name|DEFAULT_INFOPATH
argument_list|,
name|INFOPATH_PREPEND
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INFODIR
comment|/* from the Makefile */
name|info_add_path
argument_list|(
name|INFODIR
argument_list|,
name|INFOPATH_PREPEND
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* If the user specified a particular filename, add the path of that      file to the contents of INFOPATH. */
if|if
condition|(
name|user_filename
condition|)
name|add_file_directory_to_path
argument_list|(
name|user_filename
argument_list|)
expr_stmt|;
comment|/* If the user wants to search every known index for a given string,      do that now, and report the results. */
if|if
condition|(
name|apropos_p
condition|)
block|{
name|info_apropos
argument_list|(
name|apropos_search_string
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Get the initial Info node.  It is either "(dir)Top", or what the user      specifed with values in user_filename and user_nodenames. */
name|initial_node
operator|=
name|info_get_node
argument_list|(
name|user_filename
argument_list|,
name|user_nodenames
condition|?
name|user_nodenames
index|[
literal|0
index|]
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* If we couldn't get the initial node, this user is in trouble. */
if|if
condition|(
operator|!
name|initial_node
condition|)
block|{
if|if
condition|(
name|info_recent_file_error
condition|)
name|info_error
argument_list|(
name|info_recent_file_error
argument_list|)
expr_stmt|;
else|else
name|info_error
argument_list|(
name|msg_cant_find_node
argument_list|,
name|user_nodenames
condition|?
name|user_nodenames
index|[
literal|0
index|]
else|:
literal|"Top"
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Special cases for when the user specifies multiple nodes.  If we      are dumping to an output file, dump all of the nodes specified.      Otherwise, attempt to create enough windows to handle the nodes      that this user wants displayed. */
if|if
condition|(
name|user_nodenames_index
operator|>
literal|1
condition|)
block|{
name|free
argument_list|(
name|initial_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|user_output_filename
condition|)
name|dump_nodes_to_file
argument_list|(
name|user_filename
argument_list|,
name|user_nodenames
argument_list|,
name|user_output_filename
argument_list|,
name|dump_subnodes
argument_list|)
expr_stmt|;
else|else
name|begin_multiple_window_info_session
argument_list|(
name|user_filename
argument_list|,
name|user_nodenames
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If there are arguments remaining, they are the names of menu items      in sequential info files starting from the first one loaded.  That      file name is either "dir", or the contents of user_filename if one      was specified. */
block|{
name|char
modifier|*
name|errstr
decl_stmt|,
modifier|*
name|errarg1
decl_stmt|,
modifier|*
name|errarg2
decl_stmt|;
name|NODE
modifier|*
name|new_initial_node
init|=
name|info_follow_menus
argument_list|(
name|initial_node
argument_list|,
name|argv
operator|+
name|optind
argument_list|,
operator|&
name|errstr
argument_list|,
operator|&
name|errarg1
argument_list|,
operator|&
name|errarg2
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_initial_node
operator|&&
name|new_initial_node
operator|!=
name|initial_node
condition|)
name|initial_node
operator|=
name|new_initial_node
expr_stmt|;
comment|/* If the user specified that this node should be output, then do that        now.  Otherwise, start the Info session with this node.  Or act        accordingly if the initial node was not found.  */
if|if
condition|(
name|user_output_filename
operator|&&
operator|!
name|goto_invocation_p
condition|)
block|{
if|if
condition|(
operator|!
name|errstr
condition|)
name|dump_node_to_file
argument_list|(
name|initial_node
argument_list|,
name|user_output_filename
argument_list|,
name|dump_subnodes
argument_list|)
expr_stmt|;
else|else
name|info_error
argument_list|(
name|errstr
argument_list|,
name|errarg1
argument_list|,
name|errarg2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|errstr
condition|)
name|begin_info_session_with_error
argument_list|(
name|initial_node
argument_list|,
name|errstr
argument_list|,
name|errarg1
argument_list|,
name|errarg2
argument_list|)
expr_stmt|;
comment|/* If the user specified `--index-search=STRING' or            --show-options, start the info session in the node            corresponding to what they want. */
elseif|else
if|if
condition|(
name|index_search_p
operator|||
name|goto_invocation_p
condition|)
block|{
name|int
name|status
init|=
literal|0
decl_stmt|;
name|initialize_info_session
argument_list|(
name|initial_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|goto_invocation_p
operator|||
name|index_entry_exists
argument_list|(
name|windows
argument_list|,
name|index_search_string
argument_list|)
condition|)
block|{
name|terminal_prep_terminal
argument_list|()
expr_stmt|;
name|terminal_clear_screen
argument_list|()
expr_stmt|;
name|info_last_executed_command
operator|=
operator|(
name|VFunction
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|index_search_p
condition|)
name|do_info_index_search
argument_list|(
name|windows
argument_list|,
literal|0
argument_list|,
name|index_search_string
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If they said "info --show-options foo bar baz",                        the last of the arguments is the program whose                        options they want to see.  */
name|char
modifier|*
modifier|*
name|p
init|=
name|argv
operator|+
name|optind
decl_stmt|;
name|char
modifier|*
name|program
decl_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
while|while
condition|(
name|p
index|[
literal|1
index|]
condition|)
name|p
operator|++
expr_stmt|;
name|program
operator|=
name|xstrdup
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|user_filename
condition|)
comment|/* If there's no command-line arguments to 			 supply the program name, use the Info file 			 name (sans extension and leading directories) 			 instead.  */
name|program
operator|=
name|program_name_from_file_name
argument_list|(
name|user_filename
argument_list|)
expr_stmt|;
else|else
name|program
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|info_intuit_options_node
argument_list|(
name|windows
argument_list|,
name|initial_node
argument_list|,
name|program
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|program
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|user_output_filename
condition|)
block|{
name|dump_node_to_file
argument_list|(
name|windows
operator|->
name|node
argument_list|,
name|user_output_filename
argument_list|,
name|dump_subnodes
argument_list|)
expr_stmt|;
block|}
else|else
name|info_read_and_dispatch
argument_list|()
expr_stmt|;
comment|/* On program exit, leave the cursor at the bottom of the                    window, and restore the terminal IO. */
name|terminal_goto_xy
argument_list|(
literal|0
argument_list|,
name|screenheight
operator|-
literal|1
argument_list|)
expr_stmt|;
name|terminal_clear_to_eol
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|terminal_unprep_terminal
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"no index entries found for `%s'\n"
argument_list|)
argument_list|,
name|index_search_string
argument_list|)
expr_stmt|;
name|status
operator|=
literal|2
expr_stmt|;
block|}
name|close_dribble_file
argument_list|()
expr_stmt|;
name|xexit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
else|else
name|begin_info_session
argument_list|(
name|initial_node
argument_list|)
expr_stmt|;
block|}
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|add_file_directory_to_path
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|directory_name
init|=
name|xstrdup
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|char
modifier|*
name|temp
init|=
name|filename_non_directory
argument_list|(
name|directory_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|!=
name|directory_name
condition|)
block|{
if|if
condition|(
name|HAVE_DRIVE
argument_list|(
name|directory_name
argument_list|)
operator|&&
name|temp
operator|==
name|directory_name
operator|+
literal|2
condition|)
block|{
comment|/* The directory of "d:foo" is stored as "d:.", to avoid 	     mixing it with "d:/" when a slash is appended.  */
operator|*
name|temp
operator|=
literal|'.'
expr_stmt|;
name|temp
operator|+=
literal|2
expr_stmt|;
block|}
name|temp
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|info_add_path
argument_list|(
name|directory_name
argument_list|,
name|INFOPATH_PREPEND
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|directory_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Error handling.  */
end_comment

begin_comment
comment|/* Non-zero if an error has been signalled. */
end_comment

begin_decl_stmt
name|int
name|info_error_was_printed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means ring terminal bell on errors. */
end_comment

begin_decl_stmt
name|int
name|info_error_rings_bell_p
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print FORMAT with ARG1 and ARG2.  If the window system was initialized,    then the message is printed in the echo area.  Otherwise, a message is    output to stderr. */
end_comment

begin_function
name|void
name|info_error
parameter_list|(
name|format
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
name|void
modifier|*
name|arg1
decl_stmt|,
decl|*
name|arg2
decl_stmt|;
end_function

begin_block
block|{
name|info_error_was_printed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|info_windows_initialized_p
operator|||
name|display_inhibited
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|echo_area_is_active
condition|)
block|{
if|if
condition|(
name|info_error_rings_bell_p
condition|)
name|terminal_ring_bell
argument_list|()
expr_stmt|;
name|window_message_in_echo_area
argument_list|(
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NODE
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|build_message_node
argument_list|(
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_error_rings_bell_p
condition|)
name|terminal_ring_bell
argument_list|()
expr_stmt|;
name|inform_in_echo_area
argument_list|(
name|temp
operator|->
name|contents
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|contents
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Produce a scaled down description of the available options to Info. */
end_comment

begin_function
specifier|static
name|void
name|info_short_help
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|__MSDOS__
specifier|static
specifier|const
name|char
name|speech_friendly_string
index|[]
init|=
name|N_
argument_list|(
literal|"\  --speech-friendly        be friendly to speech synthesizers.\n"
argument_list|)
decl_stmt|;
else|#
directive|else
specifier|static
specifier|const
name|char
name|speech_friendly_string
index|[]
init|=
literal|""
decl_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ Usage: %s [OPTION]... [MENU-ITEM...]\n\ \n\ Read documentation in Info format.\n\ \n\ Options:\n\  --apropos=SUBJECT        look up SUBJECT in all indices of all manuals.\n\  --directory=DIR          add DIR to INFOPATH.\n\  --dribble=FILENAME       remember user keystrokes in FILENAME.\n\  --file=FILENAME          specify Info file to visit.\n\  --help                   display this help and exit.\n\  --index-search=STRING    go to node pointed by index entry STRING.\n\  --node=NODENAME          specify nodes in first visited Info file.\n\  --output=FILENAME        output selected nodes to FILENAME.\n\  --raw-escapes            don't remove ANSI escapes from man pages.\n\  --restore=FILENAME       read initial keystrokes from FILENAME.\n\  --show-options, --usage  go to command-line options node.\n%s\  --subnodes               recursively output menu items.\n\  --vi-keys                use vi-like and less-like key bindings.\n\  --version                display version information and exit.\n\ \n\ The first non-option argument, if present, is the menu entry to start from;\n\ it is searched for in all `dir' files along INFOPATH.\n\ If it is not present, info merges all `dir' files and shows the result.\n\ Any remaining arguments are treated as the names of menu\n\ items relative to the initial node visited.\n\ \n\ Examples:\n\   info                       show top-level dir menu\n\   info emacs                 start at emacs node from top-level dir\n\   info emacs buffers         start at buffers node within emacs manual\n\   info --show-options emacs  start at node with emacs' command line options\n\   info -f ./foo.info         show file ./foo.info, not searching dir\n\ \n\ Email bug reports to bug-texinfo@gnu.org,\n\ general questions and discussion to help-texinfo@gnu.org.\n\ "
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|speech_friendly_string
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize strings for gettext.  Because gettext doesn't handle N_ or    _ within macro definitions, we put shared messages into variables and    use them that way.  This also has the advantage that there's only one    copy of the strings.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|msg_cant_find_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg_cant_file_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg_cant_find_window
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg_cant_find_point
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg_cant_kill_last
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg_no_menu_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg_no_foot_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg_no_xref_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg_no_pointer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg_unknown_command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg_term_too_dumb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg_at_node_bottom
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg_at_node_top
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg_one_window
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg_win_too_small
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg_cant_make_help
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_messages
parameter_list|()
block|{
name|msg_cant_find_node
operator|=
name|_
argument_list|(
literal|"Cannot find node `%s'."
argument_list|)
expr_stmt|;
name|msg_cant_file_node
operator|=
name|_
argument_list|(
literal|"Cannot find node `(%s)%s'."
argument_list|)
expr_stmt|;
name|msg_cant_find_window
operator|=
name|_
argument_list|(
literal|"Cannot find a window!"
argument_list|)
expr_stmt|;
name|msg_cant_find_point
operator|=
name|_
argument_list|(
literal|"Point doesn't appear within this window's node!"
argument_list|)
expr_stmt|;
name|msg_cant_kill_last
operator|=
name|_
argument_list|(
literal|"Cannot delete the last window."
argument_list|)
expr_stmt|;
name|msg_no_menu_node
operator|=
name|_
argument_list|(
literal|"No menu in this node."
argument_list|)
expr_stmt|;
name|msg_no_foot_node
operator|=
name|_
argument_list|(
literal|"No footnotes in this node."
argument_list|)
expr_stmt|;
name|msg_no_xref_node
operator|=
name|_
argument_list|(
literal|"No cross references in this node."
argument_list|)
expr_stmt|;
name|msg_no_pointer
operator|=
name|_
argument_list|(
literal|"No `%s' pointer for this node."
argument_list|)
expr_stmt|;
name|msg_unknown_command
operator|=
name|_
argument_list|(
literal|"Unknown Info command `%c'; try `?' for help."
argument_list|)
expr_stmt|;
name|msg_term_too_dumb
operator|=
name|_
argument_list|(
literal|"Terminal type `%s' is not smart enough to run Info."
argument_list|)
expr_stmt|;
name|msg_at_node_bottom
operator|=
name|_
argument_list|(
literal|"You are already at the last page of this node."
argument_list|)
expr_stmt|;
name|msg_at_node_top
operator|=
name|_
argument_list|(
literal|"You are already at the first page of this node."
argument_list|)
expr_stmt|;
name|msg_one_window
operator|=
name|_
argument_list|(
literal|"Only one window."
argument_list|)
expr_stmt|;
name|msg_win_too_small
operator|=
name|_
argument_list|(
literal|"Resulting window would be too small."
argument_list|)
expr_stmt|;
name|msg_cant_make_help
operator|=
name|_
argument_list|(
literal|"Not enough room for a help window, please delete a window."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

