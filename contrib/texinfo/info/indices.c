begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* indices.c -- deal with an Info file index.    $Id: indices.c,v 1.14 1999/09/25 16:10:04 karl Exp $     Copyright (C) 1993, 97, 98, 99 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Written by Brian Fox (bfox@ai.mit.edu). */
end_comment

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_include
include|#
directive|include
file|"indices.h"
end_include

begin_comment
comment|/* User-visible variable controls the output of info-index-next. */
end_comment

begin_decl_stmt
name|int
name|show_index_match
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In the Info sense, an index is a menu.  This variable holds the last    parsed index. */
end_comment

begin_decl_stmt
specifier|static
name|REFERENCE
modifier|*
modifier|*
name|index_index
init|=
operator|(
name|REFERENCE
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The offset of the most recently selected index element. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|index_offset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variable which holds the last string searched for. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|index_search
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A couple of "globals" describing where the initial index was found. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|initial_index_filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|initial_index_nodename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A structure associating index names with index offset ranges. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The nodename of this index. */
name|int
name|first
decl_stmt|;
comment|/* The index in our list of the first entry. */
name|int
name|last
decl_stmt|;
comment|/* The index in our list of the last entry. */
block|}
name|INDEX_NAME_ASSOC
typedef|;
end_typedef

begin_comment
comment|/* An array associating index nodenames with index offset ranges. */
end_comment

begin_decl_stmt
specifier|static
name|INDEX_NAME_ASSOC
modifier|*
modifier|*
name|index_nodenames
init|=
operator|(
name|INDEX_NAME_ASSOC
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|index_nodenames_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|index_nodenames_slots
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add the name of NODE, and the range of the associated index elements    (passed in ARRAY) to index_nodenames. */
end_comment

begin_function
specifier|static
name|void
name|add_index_to_index_nodenames
parameter_list|(
name|array
parameter_list|,
name|node
parameter_list|)
name|REFERENCE
modifier|*
modifier|*
name|array
decl_stmt|;
name|NODE
modifier|*
name|node
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|last
decl_stmt|;
name|INDEX_NAME_ASSOC
modifier|*
name|assoc
decl_stmt|;
for|for
control|(
name|last
operator|=
literal|0
init|;
name|array
index|[
name|last
index|]
condition|;
name|last
operator|++
control|)
empty_stmt|;
name|assoc
operator|=
operator|(
name|INDEX_NAME_ASSOC
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|INDEX_NAME_ASSOC
argument_list|)
argument_list|)
expr_stmt|;
name|assoc
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|node
operator|->
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index_nodenames_index
condition|)
block|{
name|assoc
operator|->
name|first
operator|=
literal|0
expr_stmt|;
name|assoc
operator|->
name|last
operator|=
name|last
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|index_nodenames
index|[
name|i
operator|+
literal|1
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|assoc
operator|->
name|first
operator|=
literal|1
operator|+
name|index_nodenames
index|[
name|i
index|]
operator|->
name|last
expr_stmt|;
name|assoc
operator|->
name|last
operator|=
name|assoc
operator|->
name|first
operator|+
name|last
expr_stmt|;
block|}
name|add_pointer_to_array
argument_list|(
name|assoc
argument_list|,
name|index_nodenames_index
argument_list|,
name|index_nodenames
argument_list|,
name|index_nodenames_slots
argument_list|,
literal|10
argument_list|,
name|INDEX_NAME_ASSOC
operator|*
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find and return the indices of WINDOW's file.  The indices are defined    as the first node in the file containing the word "Index" and any    immediately following nodes whose names also contain "Index".  All such    indices are concatenated and the result returned.  If WINDOW's info file    doesn't have any indices, a NULL pointer is returned. */
end_comment

begin_function
name|REFERENCE
modifier|*
modifier|*
name|info_indices_of_window
parameter_list|(
name|window
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
block|{
name|FILE_BUFFER
modifier|*
name|fb
decl_stmt|;
name|fb
operator|=
name|file_buffer_of_window
argument_list|(
name|window
argument_list|)
expr_stmt|;
return|return
operator|(
name|info_indices_of_file_buffer
argument_list|(
name|fb
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|REFERENCE
modifier|*
modifier|*
name|info_indices_of_file_buffer
parameter_list|(
name|file_buffer
parameter_list|)
name|FILE_BUFFER
modifier|*
name|file_buffer
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|REFERENCE
modifier|*
modifier|*
name|result
init|=
operator|(
name|REFERENCE
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* No file buffer, no indices. */
if|if
condition|(
operator|!
name|file_buffer
condition|)
return|return
operator|(
operator|(
name|REFERENCE
operator|*
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* Reset globals describing where the index was found. */
name|maybe_free
argument_list|(
name|initial_index_filename
argument_list|)
expr_stmt|;
name|maybe_free
argument_list|(
name|initial_index_nodename
argument_list|)
expr_stmt|;
name|initial_index_filename
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|initial_index_nodename
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|index_nodenames
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|index_nodenames
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|index_nodenames
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|index_nodenames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|index_nodenames_index
operator|=
literal|0
expr_stmt|;
name|index_nodenames
index|[
literal|0
index|]
operator|=
operator|(
name|INDEX_NAME_ASSOC
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* Grovel the names of the nodes found in this file. */
if|if
condition|(
name|file_buffer
operator|->
name|tags
condition|)
block|{
name|TAG
modifier|*
name|tag
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|tag
operator|=
name|file_buffer
operator|->
name|tags
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|string_in_line
argument_list|(
literal|"Index"
argument_list|,
name|tag
operator|->
name|nodename
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|NODE
modifier|*
name|node
decl_stmt|;
name|REFERENCE
modifier|*
modifier|*
name|menu
decl_stmt|;
comment|/* Found one.  Get its menu. */
name|node
operator|=
name|info_get_node
argument_list|(
name|tag
operator|->
name|filename
argument_list|,
name|tag
operator|->
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
continue|continue;
comment|/* Remember the filename and nodename of this index. */
name|initial_index_filename
operator|=
name|xstrdup
argument_list|(
name|file_buffer
operator|->
name|filename
argument_list|)
expr_stmt|;
name|initial_index_nodename
operator|=
name|xstrdup
argument_list|(
name|tag
operator|->
name|nodename
argument_list|)
expr_stmt|;
name|menu
operator|=
name|info_menu_of_node
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* If we have a menu, add this index's nodename and range                  to our list of index_nodenames. */
if|if
condition|(
name|menu
condition|)
block|{
name|add_index_to_index_nodenames
argument_list|(
name|menu
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|/* Concatenate the references found so far. */
name|result
operator|=
name|info_concatenate_references
argument_list|(
name|result
argument_list|,
name|menu
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If there is a result, clean it up so that every entry has a filename. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|result
operator|&&
name|result
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|result
index|[
name|i
index|]
operator|->
name|filename
condition|)
name|result
index|[
name|i
index|]
operator|->
name|filename
operator|=
name|xstrdup
argument_list|(
name|file_buffer
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_index_search
argument_list|,
argument|_(
literal|"Look up a string in the index for this file"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|do_info_index_search
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Look up SEARCH_STRING in the index for this file.  If SEARCH_STRING    is NULL, prompt user for input.  */
end_comment

begin_function
name|void
name|do_info_index_search
parameter_list|(
name|window
parameter_list|,
name|count
parameter_list|,
name|search_string
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|search_string
decl_stmt|;
block|{
name|FILE_BUFFER
modifier|*
name|fb
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
comment|/* Reset the index offset, since this is not the info-index-next command. */
name|index_offset
operator|=
literal|0
expr_stmt|;
comment|/* The user is selecting a new search string, so flush the old one. */
name|maybe_free
argument_list|(
name|index_search
argument_list|)
expr_stmt|;
name|index_search
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* If this window's file is not the same as the one that we last built an      index for, build and remember an index now. */
name|fb
operator|=
name|file_buffer_of_window
argument_list|(
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|initial_index_filename
operator|||
operator|(
name|FILENAME_CMP
argument_list|(
name|initial_index_filename
argument_list|,
name|fb
operator|->
name|filename
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|info_free_references
argument_list|(
name|index_index
argument_list|)
expr_stmt|;
name|window_message_in_echo_area
argument_list|(
name|_
argument_list|(
literal|"Finding index entries..."
argument_list|)
argument_list|)
expr_stmt|;
name|index_index
operator|=
name|info_indices_of_file_buffer
argument_list|(
name|fb
argument_list|)
expr_stmt|;
block|}
comment|/* If there is no index, quit now. */
if|if
condition|(
operator|!
name|index_index
condition|)
block|{
name|info_error
argument_list|(
name|_
argument_list|(
literal|"No indices found."
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Okay, there is an index.  Look for SEARCH_STRING, or, if it is      empty, prompt for one.  */
if|if
condition|(
name|search_string
operator|&&
operator|*
name|search_string
condition|)
name|line
operator|=
name|xstrdup
argument_list|(
name|search_string
argument_list|)
expr_stmt|;
else|else
block|{
name|line
operator|=
name|info_read_maybe_completing
argument_list|(
name|window
argument_list|,
name|_
argument_list|(
literal|"Index entry: "
argument_list|)
argument_list|,
name|index_index
argument_list|)
expr_stmt|;
name|window
operator|=
name|active_window
expr_stmt|;
comment|/* User aborted? */
if|if
condition|(
operator|!
name|line
condition|)
block|{
name|info_abort_key
argument_list|(
name|active_window
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Empty line means move to the Index node. */
if|if
condition|(
operator|!
operator|*
name|line
condition|)
block|{
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|initial_index_filename
operator|&&
name|initial_index_nodename
condition|)
block|{
name|NODE
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|info_get_node
argument_list|(
name|initial_index_filename
argument_list|,
name|initial_index_nodename
argument_list|)
expr_stmt|;
name|set_remembered_pagetop_and_point
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|window_set_node_of_window
argument_list|(
name|window
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|remember_window_and_node
argument_list|(
name|window
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|window_clear_echo_area
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* The user typed either a completed index label, or a partial string.      Find an exact match, or, failing that, the first index entry containing      the partial string.  So, we just call info_next_index_match () with minor      manipulation of INDEX_OFFSET. */
block|{
name|int
name|old_offset
decl_stmt|;
comment|/* Start the search right after/before this index. */
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|index_index
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|index_offset
operator|=
name|i
expr_stmt|;
block|}
else|else
name|index_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|old_offset
operator|=
name|index_offset
expr_stmt|;
comment|/* The "last" string searched for is this one. */
name|index_search
operator|=
name|line
expr_stmt|;
comment|/* Find it, or error. */
name|info_next_index_match
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the search failed, return the index offset to where it belongs. */
if|if
condition|(
name|index_offset
operator|==
name|old_offset
condition|)
name|index_offset
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|index_entry_exists
parameter_list|(
name|window
parameter_list|,
name|string
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|FILE_BUFFER
modifier|*
name|fb
decl_stmt|;
comment|/* If there is no previous search string, the user hasn't built an index      yet. */
if|if
condition|(
operator|!
name|string
condition|)
return|return
literal|0
return|;
name|fb
operator|=
name|file_buffer_of_window
argument_list|(
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|initial_index_filename
operator|||
operator|(
name|FILENAME_CMP
argument_list|(
name|initial_index_filename
argument_list|,
name|fb
operator|->
name|filename
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|info_free_references
argument_list|(
name|index_index
argument_list|)
expr_stmt|;
name|index_index
operator|=
name|info_indices_of_file_buffer
argument_list|(
name|fb
argument_list|)
expr_stmt|;
block|}
comment|/* If there is no index, that is an error. */
if|if
condition|(
operator|!
name|index_index
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|>
operator|-
literal|1
operator|)
operator|&&
operator|(
name|index_index
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
name|index_index
index|[
name|i
index|]
operator|->
name|label
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* If that failed, look for the next substring match. */
if|if
condition|(
operator|(
name|i
operator|<
literal|0
operator|)
operator|||
operator|(
operator|!
name|index_index
index|[
name|i
index|]
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|>
operator|-
literal|1
operator|)
operator|&&
operator|(
name|index_index
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|string_in_line
argument_list|(
name|string
argument_list|,
name|index_index
index|[
name|i
index|]
operator|->
name|label
argument_list|)
operator|!=
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
operator|(
name|i
operator|>
operator|-
literal|1
operator|)
operator|&&
operator|(
name|index_index
index|[
name|i
index|]
operator|)
condition|)
name|string_in_line
argument_list|(
name|string
argument_list|,
name|index_index
index|[
name|i
index|]
operator|->
name|label
argument_list|)
expr_stmt|;
block|}
comment|/* If that failed, return 0. */
if|if
condition|(
operator|(
name|i
operator|<
literal|0
operator|)
operator|||
operator|(
operator|!
name|index_index
index|[
name|i
index|]
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_next_index_match
argument_list|,
argument|_(
literal|"Go to the next matching index item from the last `\\[index-search]' command"
argument|)
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|partial
decl_stmt|,
name|dir
decl_stmt|;
name|NODE
modifier|*
name|node
decl_stmt|;
comment|/* If there is no previous search string, the user hasn't built an index      yet. */
if|if
condition|(
operator|!
name|index_search
condition|)
block|{
name|info_error
argument_list|(
name|_
argument_list|(
literal|"No previous index search string."
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If there is no index, that is an error. */
if|if
condition|(
operator|!
name|index_index
condition|)
block|{
name|info_error
argument_list|(
name|_
argument_list|(
literal|"No index entries."
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The direction of this search is controlled by the value of the      numeric argument. */
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|dir
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|dir
operator|=
literal|1
expr_stmt|;
comment|/* Search for the next occurence of index_search.  First try to find      an exact match. */
name|partial
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|index_offset
operator|+
name|dir
init|;
operator|(
name|i
operator|>
operator|-
literal|1
operator|)
operator|&&
operator|(
name|index_index
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|+=
name|dir
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|index_search
argument_list|,
name|index_index
index|[
name|i
index|]
operator|->
name|label
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* If that failed, look for the next substring match. */
if|if
condition|(
operator|(
name|i
operator|<
literal|0
operator|)
operator|||
operator|(
operator|!
name|index_index
index|[
name|i
index|]
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|index_offset
operator|+
name|dir
init|;
operator|(
name|i
operator|>
operator|-
literal|1
operator|)
operator|&&
operator|(
name|index_index
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|+=
name|dir
control|)
if|if
condition|(
name|string_in_line
argument_list|(
name|index_search
argument_list|,
name|index_index
index|[
name|i
index|]
operator|->
name|label
argument_list|)
operator|!=
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
operator|(
name|i
operator|>
operator|-
literal|1
operator|)
operator|&&
operator|(
name|index_index
index|[
name|i
index|]
operator|)
condition|)
name|partial
operator|=
name|string_in_line
argument_list|(
name|index_search
argument_list|,
name|index_index
index|[
name|i
index|]
operator|->
name|label
argument_list|)
expr_stmt|;
block|}
comment|/* If that failed, print an error. */
if|if
condition|(
operator|(
name|i
operator|<
literal|0
operator|)
operator|||
operator|(
operator|!
name|index_index
index|[
name|i
index|]
operator|)
condition|)
block|{
name|info_error
argument_list|(
name|_
argument_list|(
literal|"No %sindex entries containing \"%s\"."
argument_list|)
argument_list|,
name|index_offset
operator|>
literal|0
condition|?
name|_
argument_list|(
literal|"more "
argument_list|)
else|:
literal|""
argument_list|,
name|index_search
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Okay, we found the next one.  Move the offset to the current entry. */
name|index_offset
operator|=
name|i
expr_stmt|;
comment|/* Report to the user on what we have found. */
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|_
argument_list|(
literal|"CAN'T SEE THIS"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|match
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|index_nodenames
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|>=
name|index_nodenames
index|[
name|j
index|]
operator|->
name|first
operator|)
operator|&&
operator|(
name|i
operator|<=
name|index_nodenames
index|[
name|j
index|]
operator|->
name|last
operator|)
condition|)
block|{
name|name
operator|=
name|index_nodenames
index|[
name|j
index|]
operator|->
name|name
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we had a partial match, indicate to the user which part of the        string matched. */
name|match
operator|=
name|xstrdup
argument_list|(
name|index_index
index|[
name|i
index|]
operator|->
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|partial
operator|&&
name|show_index_match
condition|)
block|{
name|int
name|j
decl_stmt|,
name|ls
decl_stmt|,
name|start
decl_stmt|,
name|upper
decl_stmt|;
name|ls
operator|=
name|strlen
argument_list|(
name|index_search
argument_list|)
expr_stmt|;
name|start
operator|=
name|partial
operator|-
name|ls
expr_stmt|;
name|upper
operator|=
name|isupper
argument_list|(
name|match
index|[
name|start
index|]
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ls
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|upper
condition|)
name|match
index|[
name|j
operator|+
name|start
index|]
operator|=
name|info_tolower
argument_list|(
name|match
index|[
name|j
operator|+
name|start
index|]
argument_list|)
expr_stmt|;
else|else
name|match
index|[
name|j
operator|+
name|start
index|]
operator|=
name|info_toupper
argument_list|(
name|match
index|[
name|j
operator|+
name|start
index|]
argument_list|)
expr_stmt|;
block|}
block|{
name|char
modifier|*
name|format
decl_stmt|;
name|format
operator|=
name|replace_in_documentation
argument_list|(
name|_
argument_list|(
literal|"Found \"%s\" in %s. (`\\[next-index-match]' tries to find next.)"
argument_list|)
argument_list|)
expr_stmt|;
name|window_message_in_echo_area
argument_list|(
name|format
argument_list|,
name|match
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|match
argument_list|)
expr_stmt|;
block|}
comment|/* Select the node corresponding to this index entry. */
name|node
operator|=
name|info_get_node
argument_list|(
name|index_index
index|[
name|i
index|]
operator|->
name|filename
argument_list|,
name|index_index
index|[
name|i
index|]
operator|->
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
block|{
name|info_error
argument_list|(
name|msg_cant_file_node
argument_list|,
name|index_index
index|[
name|i
index|]
operator|->
name|filename
argument_list|,
name|index_index
index|[
name|i
index|]
operator|->
name|nodename
argument_list|)
expr_stmt|;
return|return;
block|}
name|info_set_node_of_window
argument_list|(
literal|1
argument_list|,
name|window
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|/* Try to find an occurence of LABEL in this node. */
block|{
name|long
name|start
decl_stmt|,
name|loc
decl_stmt|;
name|start
operator|=
name|window
operator|->
name|line_starts
index|[
literal|1
index|]
operator|-
name|window
operator|->
name|node
operator|->
name|contents
expr_stmt|;
name|loc
operator|=
name|info_target_search_node
argument_list|(
name|node
argument_list|,
name|index_index
index|[
name|i
index|]
operator|->
name|label
argument_list|,
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|!=
operator|-
literal|1
condition|)
block|{
name|window
operator|->
name|point
operator|=
name|loc
expr_stmt|;
name|window_adjust_pagetop
argument_list|(
name|window
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/*                 Info APROPOS: Search every known index.          */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* For every menu item in DIR, search the indices of that file for    SEARCH_STRING. */
end_comment

begin_function
name|REFERENCE
modifier|*
modifier|*
name|apropos_in_all_indices
parameter_list|(
name|search_string
parameter_list|,
name|inform
parameter_list|)
name|char
modifier|*
name|search_string
decl_stmt|;
name|int
name|inform
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|dir_index
decl_stmt|;
name|REFERENCE
modifier|*
modifier|*
name|all_indices
init|=
operator|(
name|REFERENCE
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|REFERENCE
modifier|*
modifier|*
name|dir_menu
init|=
operator|(
name|REFERENCE
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|NODE
modifier|*
name|dir_node
decl_stmt|;
name|dir_node
operator|=
name|info_get_node
argument_list|(
literal|"dir"
argument_list|,
literal|"Top"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir_node
condition|)
name|dir_menu
operator|=
name|info_menu_of_node
argument_list|(
name|dir_node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dir_menu
condition|)
return|return
name|NULL
return|;
comment|/* For every menu item in DIR, get the associated node's file buffer and      read the indices of that file buffer.  Gather all of the indices into      one large one. */
for|for
control|(
name|dir_index
operator|=
literal|0
init|;
name|dir_menu
index|[
name|dir_index
index|]
condition|;
name|dir_index
operator|++
control|)
block|{
name|REFERENCE
modifier|*
modifier|*
name|this_index
decl_stmt|,
modifier|*
name|this_item
decl_stmt|;
name|NODE
modifier|*
name|this_node
decl_stmt|;
name|FILE_BUFFER
modifier|*
name|this_fb
decl_stmt|;
name|int
name|dir_node_duplicated
init|=
literal|0
decl_stmt|;
name|this_item
operator|=
name|dir_menu
index|[
name|dir_index
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|this_item
operator|->
name|filename
condition|)
block|{
name|dir_node_duplicated
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dir_node
operator|->
name|parent
condition|)
name|this_item
operator|->
name|filename
operator|=
name|xstrdup
argument_list|(
name|dir_node
operator|->
name|parent
argument_list|)
expr_stmt|;
else|else
name|this_item
operator|->
name|filename
operator|=
name|xstrdup
argument_list|(
name|dir_node
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
comment|/* Find this node.  If we cannot find it, try using the label of the          entry as a file (i.e., "(LABEL)Top"). */
name|this_node
operator|=
name|info_get_node
argument_list|(
name|this_item
operator|->
name|filename
argument_list|,
name|this_item
operator|->
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|this_node
operator|&&
name|this_item
operator|->
name|nodename
operator|&&
operator|(
name|strcmp
argument_list|(
name|this_item
operator|->
name|label
argument_list|,
name|this_item
operator|->
name|nodename
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|this_node
operator|=
name|info_get_node
argument_list|(
name|this_item
operator|->
name|label
argument_list|,
literal|"Top"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|this_node
condition|)
block|{
if|if
condition|(
name|dir_node_duplicated
condition|)
name|free
argument_list|(
name|this_item
operator|->
name|filename
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Get the file buffer associated with this node. */
block|{
name|char
modifier|*
name|files_name
decl_stmt|;
name|files_name
operator|=
name|this_node
operator|->
name|parent
expr_stmt|;
if|if
condition|(
operator|!
name|files_name
condition|)
name|files_name
operator|=
name|this_node
operator|->
name|filename
expr_stmt|;
name|this_fb
operator|=
name|info_find_file
argument_list|(
name|files_name
argument_list|)
expr_stmt|;
comment|/* If we already scanned this file, don't do that again. 	   In addition to being faster, this also avoids having 	   multiple identical entries in the *Apropos* menu.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dir_index
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|FILENAME_CMP
argument_list|(
name|this_fb
operator|->
name|filename
argument_list|,
name|dir_menu
index|[
name|i
index|]
operator|->
name|filename
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|dir_index
condition|)
block|{
if|if
condition|(
name|dir_node_duplicated
condition|)
name|free
argument_list|(
name|this_item
operator|->
name|filename
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|this_fb
operator|&&
name|inform
condition|)
name|message_in_echo_area
argument_list|(
name|_
argument_list|(
literal|"Scanning indices of \"%s\"..."
argument_list|)
argument_list|,
name|files_name
argument_list|)
expr_stmt|;
name|this_index
operator|=
name|info_indices_of_file_buffer
argument_list|(
name|this_fb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|this_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_fb
operator|&&
name|inform
condition|)
name|unmessage_in_echo_area
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|this_index
condition|)
block|{
comment|/* Remember the filename which contains this set of references. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|this_index
operator|&&
name|this_index
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|this_index
index|[
name|i
index|]
operator|->
name|filename
condition|)
name|this_index
index|[
name|i
index|]
operator|->
name|filename
operator|=
name|xstrdup
argument_list|(
name|this_fb
operator|->
name|filename
argument_list|)
expr_stmt|;
comment|/* Concatenate with the other indices.  */
name|all_indices
operator|=
name|info_concatenate_references
argument_list|(
name|all_indices
argument_list|,
name|this_index
argument_list|)
expr_stmt|;
block|}
block|}
name|info_free_references
argument_list|(
name|dir_menu
argument_list|)
expr_stmt|;
comment|/* Build a list of the references which contain SEARCH_STRING. */
if|if
condition|(
name|all_indices
condition|)
block|{
name|REFERENCE
modifier|*
name|entry
decl_stmt|,
modifier|*
modifier|*
name|apropos_list
init|=
operator|(
name|REFERENCE
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|apropos_list_index
init|=
literal|0
decl_stmt|;
name|int
name|apropos_list_slots
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|entry
operator|=
name|all_indices
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|string_in_line
argument_list|(
name|search_string
argument_list|,
name|entry
operator|->
name|label
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|add_pointer_to_array
argument_list|(
name|entry
argument_list|,
name|apropos_list_index
argument_list|,
name|apropos_list
argument_list|,
name|apropos_list_slots
argument_list|,
literal|100
argument_list|,
name|REFERENCE
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|maybe_free
argument_list|(
name|entry
operator|->
name|label
argument_list|)
expr_stmt|;
name|maybe_free
argument_list|(
name|entry
operator|->
name|filename
argument_list|)
expr_stmt|;
name|maybe_free
argument_list|(
name|entry
operator|->
name|nodename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|all_indices
argument_list|)
expr_stmt|;
name|all_indices
operator|=
name|apropos_list
expr_stmt|;
block|}
return|return
operator|(
name|all_indices
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|APROPOS_NONE
define|\
value|N_("No available info files have \"%s\" in their indices.")
end_define

begin_function
name|void
name|info_apropos
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|REFERENCE
modifier|*
modifier|*
name|apropos_list
decl_stmt|;
name|apropos_list
operator|=
name|apropos_in_all_indices
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|apropos_list
condition|)
block|{
name|info_error
argument_list|(
name|_
argument_list|(
name|APROPOS_NONE
argument_list|)
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|REFERENCE
modifier|*
name|entry
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|entry
operator|=
name|apropos_list
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\"(%s)%s\" -- %s\n"
argument_list|,
name|entry
operator|->
name|filename
argument_list|,
name|entry
operator|->
name|nodename
argument_list|,
name|entry
operator|->
name|label
argument_list|)
expr_stmt|;
block|}
name|info_free_references
argument_list|(
name|apropos_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|apropos_list_nodename
init|=
literal|"*Apropos*"
decl_stmt|;
end_decl_stmt

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|info_index_apropos
argument_list|,
argument|_(
literal|"Grovel all known info file's indices for a string and build a menu"
argument|)
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|line
operator|=
name|info_read_in_echo_area
argument_list|(
name|window
argument_list|,
name|_
argument_list|(
literal|"Index apropos: "
argument_list|)
argument_list|)
expr_stmt|;
name|window
operator|=
name|active_window
expr_stmt|;
comment|/* User aborted? */
if|if
condition|(
operator|!
name|line
condition|)
block|{
name|info_abort_key
argument_list|(
name|window
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* User typed something? */
if|if
condition|(
operator|*
name|line
condition|)
block|{
name|REFERENCE
modifier|*
modifier|*
name|apropos_list
decl_stmt|;
name|NODE
modifier|*
name|apropos_node
decl_stmt|;
name|apropos_list
operator|=
name|apropos_in_all_indices
argument_list|(
name|line
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|apropos_list
condition|)
block|{
name|info_error
argument_list|(
name|_
argument_list|(
name|APROPOS_NONE
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|line_buffer
decl_stmt|;
name|initialize_message_buffer
argument_list|()
expr_stmt|;
name|printf_to_message_buffer
argument_list|(
name|_
argument_list|(
literal|"\n* Menu: Nodes whoses indices contain \"%s\":\n"
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|line_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|500
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|apropos_list
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
decl_stmt|;
comment|/* The label might be identical to that of another index 		 entry in another Info file.  Therefore, we make the file 		 name part of the menu entry, to make them all distinct.  */
name|sprintf
argument_list|(
name|line_buffer
argument_list|,
literal|"* %s [%s]: "
argument_list|,
name|apropos_list
index|[
name|i
index|]
operator|->
name|label
argument_list|,
name|apropos_list
index|[
name|i
index|]
operator|->
name|filename
argument_list|)
expr_stmt|;
name|len
operator|=
name|pad_to
argument_list|(
literal|40
argument_list|,
name|line_buffer
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line_buffer
operator|+
name|len
argument_list|,
literal|"(%s)%s."
argument_list|,
name|apropos_list
index|[
name|i
index|]
operator|->
name|filename
argument_list|,
name|apropos_list
index|[
name|i
index|]
operator|->
name|nodename
argument_list|)
expr_stmt|;
name|printf_to_message_buffer
argument_list|(
literal|"%s\n"
argument_list|,
name|line_buffer
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|line_buffer
argument_list|)
expr_stmt|;
block|}
name|apropos_node
operator|=
name|message_buffer_to_node
argument_list|()
expr_stmt|;
name|add_gcable_pointer
argument_list|(
name|apropos_node
operator|->
name|contents
argument_list|)
expr_stmt|;
name|name_internal_node
argument_list|(
name|apropos_node
argument_list|,
name|apropos_list_nodename
argument_list|)
expr_stmt|;
comment|/* Even though this is an internal node, we don't want the window          system to treat it specially.  So we turn off the internalness          of it here. */
name|apropos_node
operator|->
name|flags
operator|&=
operator|~
name|N_IsInternal
expr_stmt|;
comment|/* Find/Create a window to contain this node. */
block|{
name|WINDOW
modifier|*
name|new
decl_stmt|;
name|NODE
modifier|*
name|node
decl_stmt|;
name|set_remembered_pagetop_and_point
argument_list|(
name|window
argument_list|)
expr_stmt|;
comment|/* If a window is visible and showing an apropos list already,            re-use it. */
for|for
control|(
name|new
operator|=
name|windows
init|;
name|new
condition|;
name|new
operator|=
name|new
operator|->
name|next
control|)
block|{
name|node
operator|=
name|new
operator|->
name|node
expr_stmt|;
if|if
condition|(
name|internal_info_node_p
argument_list|(
name|node
argument_list|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|node
operator|->
name|nodename
argument_list|,
name|apropos_list_nodename
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
comment|/* If we couldn't find an existing window, try to use the next window            in the chain. */
if|if
condition|(
operator|!
name|new
operator|&&
name|window
operator|->
name|next
condition|)
name|new
operator|=
name|window
operator|->
name|next
expr_stmt|;
comment|/* If we still don't have a window, make a new one to contain            the list. */
if|if
condition|(
operator|!
name|new
condition|)
block|{
name|WINDOW
modifier|*
name|old_active
decl_stmt|;
name|old_active
operator|=
name|active_window
expr_stmt|;
name|active_window
operator|=
name|window
expr_stmt|;
name|new
operator|=
name|window_make_window
argument_list|(
operator|(
name|NODE
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|active_window
operator|=
name|old_active
expr_stmt|;
block|}
comment|/* If we couldn't make a new window, use this one. */
if|if
condition|(
operator|!
name|new
condition|)
name|new
operator|=
name|window
expr_stmt|;
comment|/* Lines do not wrap in this window. */
name|new
operator|->
name|flags
operator||=
name|W_NoWrap
expr_stmt|;
name|window_set_node_of_window
argument_list|(
name|new
argument_list|,
name|apropos_node
argument_list|)
expr_stmt|;
name|remember_window_and_node
argument_list|(
name|new
argument_list|,
name|apropos_node
argument_list|)
expr_stmt|;
name|active_window
operator|=
name|new
expr_stmt|;
block|}
name|info_free_references
argument_list|(
name|apropos_list
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info_error_was_printed
condition|)
name|window_clear_echo_area
argument_list|()
expr_stmt|;
block|}
end_block

end_unit

