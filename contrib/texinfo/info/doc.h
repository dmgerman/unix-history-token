begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* doc.h -- Structures associating function pointers with documentation.    $Id: doc.h,v 1.5 2001/11/16 23:16:40 karl Exp $     Copyright (C) 1993, 2001 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Written by Brian Fox (bfox@ai.mit.edu). */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DOC_H
argument_list|)
end_if

begin_define
define|#
directive|define
name|DOC_H
end_define

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_comment
comment|/* for NAMED_FUNCTIONS, VFunction, etc.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INFOKEY
argument_list|)
end_if

begin_comment
comment|/* For each function, we keep track of the first defined key sequence    which invokes that function, for each different map.  This is so that    the dynamic documentation generation in infodoc.c (a) doesn't have to    search through copious KEYMAP_ENTRYs, and, more importantly, (b) the    user and programmer can choose the preferred key sequence that is    printed for any given function -- it's just the first one that    appears in the user's infokey file or the default keymaps in    infomap.c.     Each FUNCTION_DOC has a linked list of FUNCTION_KEYSEQ structs    hanging off it, which are created on startup when the user and/or    default keymaps are being parsed.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|function_keyseq
block|{
name|struct
name|function_keyseq
modifier|*
name|next
decl_stmt|;
name|struct
name|keymap_entry
modifier|*
name|map
decl_stmt|;
name|char
modifier|*
name|keyseq
decl_stmt|;
block|}
name|FUNCTION_KEYSEQ
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INFOKEY */
end_comment

begin_comment
comment|/* An array of FUNCTION_DOC structures is defined in doc.c, which is    automagically generated by the makedoc utility, whose job is to scan    through the source files for command function declarations and    compile a list of all the ones it finds.  This saves tedious    housekeeping and avoids errors of omission.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|VFunction
modifier|*
name|func
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NAMED_FUNCTIONS
argument_list|)
name|char
modifier|*
name|func_name
decl_stmt|;
endif|#
directive|endif
comment|/* NAMED_FUNCTIONS */
if|#
directive|if
name|defined
argument_list|(
name|INFOKEY
argument_list|)
name|FUNCTION_KEYSEQ
modifier|*
name|keys
decl_stmt|;
endif|#
directive|endif
comment|/* INFOKEY */
name|char
modifier|*
name|doc
decl_stmt|;
block|}
name|FUNCTION_DOC
typedef|;
end_typedef

begin_decl_stmt
specifier|extern
name|FUNCTION_DOC
name|function_doc_array
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|function_documentation
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|key_documentation
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|pretty_keyname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|pretty_keyseq
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|where_is
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|replace_in_documentation
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|info_document_key
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|dump_map_to_message_buffer
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Under the old key-binding system, an info command is specified by    the pointer to its function.  Under the new INFOKEY binding system,     it is specified by a pointer to the command's FUNCTION_DOC structure,    defined in doc.c, from which the pointer to the function can be    easily divined using the InfoFunction() extractor.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INFOKEY
argument_list|)
end_if

begin_typedef
typedef|typedef
name|FUNCTION_DOC
name|InfoCommand
typedef|;
end_typedef

begin_define
define|#
directive|define
name|InfoFunction
parameter_list|(
name|ic
parameter_list|)
value|((ic) ? (ic)->func : NULL)
end_define

begin_define
define|#
directive|define
name|InfoCmd
parameter_list|(
name|fn
parameter_list|)
value|(&function_doc_array[A_##fn])
end_define

begin_define
define|#
directive|define
name|DocInfoCmd
parameter_list|(
name|fd
parameter_list|)
value|((fd)&& (fd)->func ? (fd) : NULL)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !INFOKEY */
end_comment

begin_typedef
typedef|typedef
name|VFunction
name|InfoCommand
typedef|;
end_typedef

begin_define
define|#
directive|define
name|InfoFunction
parameter_list|(
name|vf
parameter_list|)
value|((vf))
end_define

begin_define
define|#
directive|define
name|InfoCmd
parameter_list|(
name|fn
parameter_list|)
value|fn
end_define

begin_define
define|#
directive|define
name|DocInfoCmd
parameter_list|(
name|fd
parameter_list|)
value|((fd)->func)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !INFOKEY */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NAMED_FUNCTIONS
argument_list|)
end_if

begin_function_decl
specifier|extern
name|char
modifier|*
name|function_name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|InfoCommand
modifier|*
name|named_function
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAMED_FUNCTIONS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !DOC_H */
end_comment

end_unit

