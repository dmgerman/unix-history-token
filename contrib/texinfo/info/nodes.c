begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* nodes.c -- how to get an Info file and node.    $Id: nodes.c,v 1.14 1999/08/15 10:18:09 karl Exp $     Copyright (C) 1993, 98, 99 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Written by Brian Fox (bfox@ai.mit.edu). */
end_comment

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_include
include|#
directive|include
file|"nodes.h"
end_include

begin_include
include|#
directive|include
file|"search.h"
end_include

begin_include
include|#
directive|include
file|"filesys.h"
end_include

begin_include
include|#
directive|include
file|"info-utils.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MAN_PAGES
argument_list|)
end_if

begin_include
include|#
directive|include
file|"man.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HANDLE_MAN_PAGES */
end_comment

begin_decl_stmt
specifier|static
name|void
name|forget_info_file
argument_list|()
decl_stmt|,
name|remember_info_file
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_file_buffer_tags
argument_list|()
decl_stmt|,
name|free_info_tag
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|get_nodes_of_tags_table
argument_list|()
decl_stmt|,
name|get_nodes_of_info_file
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|get_tags_of_indirect_tags_table
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|info_reload_file_buffer_contents
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|adjust_nodestart
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|FILE_BUFFER
modifier|*
name|info_load_file_internal
argument_list|()
decl_stmt|,
modifier|*
name|info_find_file_internal
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|NODE
modifier|*
name|info_node_of_file_buffer_tags
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|get_node_length
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Magic number that RMS used to decide how much a tags table pointer could    be off by.  I feel that it should be much smaller, like 4.  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_INFO_FUDGE
value|1000
end_define

begin_comment
comment|/* Passed to *_internal functions.  INFO_GET_TAGS says to do what is    neccessary to fill in the nodes or tags arrays in FILE_BUFFER. */
end_comment

begin_define
define|#
directive|define
name|INFO_NO_TAGS
value|0
end_define

begin_define
define|#
directive|define
name|INFO_GET_TAGS
value|1
end_define

begin_escape
end_escape

begin_comment
comment|/* Global variables.  */
end_comment

begin_comment
comment|/* When non-zero, this is a string describing the recent file error. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|info_recent_file_error
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of already loaded nodes. */
end_comment

begin_decl_stmt
name|FILE_BUFFER
modifier|*
modifier|*
name|info_loaded_files
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of slots currently allocated to LOADED_FILES. */
end_comment

begin_decl_stmt
name|int
name|info_loaded_files_slots
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Public functions for node manipulation.  */
end_comment

begin_comment
comment|/* Used to build `dir' menu from `localdir' files found in INFOPATH. */
end_comment

begin_function_decl
specifier|extern
name|void
name|maybe_build_dir_node
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Return a pointer to a NODE structure for the Info node (FILENAME)NODENAME.    If FILENAME is NULL, `dir' is used.    IF NODENAME is NULL, `Top' is used.    If the node cannot be found, return NULL. */
end_comment

begin_function
name|NODE
modifier|*
name|info_get_node
parameter_list|(
name|filename
parameter_list|,
name|nodename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|,
decl|*
name|nodename
decl_stmt|;
end_function

begin_block
block|{
name|NODE
modifier|*
name|node
decl_stmt|;
name|FILE_BUFFER
modifier|*
name|file_buffer
init|=
name|NULL
decl_stmt|;
name|info_recent_file_error
operator|=
name|NULL
expr_stmt|;
name|info_parse_node
argument_list|(
name|nodename
argument_list|,
name|DONT_SKIP_NEWLINES
argument_list|)
expr_stmt|;
name|nodename
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|info_parsed_filename
condition|)
name|filename
operator|=
name|info_parsed_filename
expr_stmt|;
if|if
condition|(
name|info_parsed_nodename
condition|)
name|nodename
operator|=
name|info_parsed_nodename
expr_stmt|;
comment|/* If FILENAME is not specified, it defaults to "dir". */
if|if
condition|(
operator|!
name|filename
condition|)
name|filename
operator|=
literal|"dir"
expr_stmt|;
comment|/* If the file to be looked up is "dir", build the contents from all of      the "dir"s and "localdir"s found in INFOPATH. */
if|if
condition|(
name|is_dir_name
argument_list|(
name|filename
argument_list|)
condition|)
name|maybe_build_dir_node
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Find the correct info file, or give up.  */
name|file_buffer
operator|=
name|info_find_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_buffer
condition|)
block|{
if|if
condition|(
name|filesys_error_number
condition|)
name|info_recent_file_error
operator|=
name|filesys_error_string
argument_list|(
name|filename
argument_list|,
name|filesys_error_number
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Look for the node.  */
name|node
operator|=
name|info_get_node_of_file_buffer
argument_list|(
name|nodename
argument_list|,
name|file_buffer
argument_list|)
expr_stmt|;
comment|/* If the node not found was "Top", try again with different case.  */
if|if
condition|(
operator|!
name|node
operator|&&
operator|(
name|nodename
operator|==
name|NULL
operator|||
name|strcasecmp
argument_list|(
name|nodename
argument_list|,
literal|"Top"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|node
operator|=
name|info_get_node_of_file_buffer
argument_list|(
literal|"Top"
argument_list|,
name|file_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
name|node
operator|=
name|info_get_node_of_file_buffer
argument_list|(
literal|"top"
argument_list|,
name|file_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
name|node
operator|=
name|info_get_node_of_file_buffer
argument_list|(
literal|"TOP"
argument_list|,
name|file_buffer
argument_list|)
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
end_block

begin_comment
comment|/* Return a pointer to a NODE structure for the Info node NODENAME in    FILE_BUFFER.  NODENAME can be passed as NULL, in which case the    nodename of "Top" is used.  If the node cannot be found, return a    NULL pointer. */
end_comment

begin_function
name|NODE
modifier|*
name|info_get_node_of_file_buffer
parameter_list|(
name|nodename
parameter_list|,
name|file_buffer
parameter_list|)
name|char
modifier|*
name|nodename
decl_stmt|;
name|FILE_BUFFER
modifier|*
name|file_buffer
decl_stmt|;
block|{
name|NODE
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
comment|/* If we are unable to find the file, we have to give up.  There isn't      anything else we can do. */
if|if
condition|(
operator|!
name|file_buffer
condition|)
return|return
name|NULL
return|;
comment|/* If the file buffer was gc'ed, reload the contents now. */
if|if
condition|(
operator|!
name|file_buffer
operator|->
name|contents
condition|)
name|info_reload_file_buffer_contents
argument_list|(
name|file_buffer
argument_list|)
expr_stmt|;
comment|/* If NODENAME is not specified, it defaults to "Top". */
if|if
condition|(
operator|!
name|nodename
condition|)
name|nodename
operator|=
literal|"Top"
expr_stmt|;
comment|/* If the name of the node that we wish to find is exactly "*", then the      node body is the contents of the entire file.  Create and return such      a node. */
if|if
condition|(
name|strcmp
argument_list|(
name|nodename
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|node
operator|=
operator|(
name|NODE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NODE
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|filename
operator|=
name|file_buffer
operator|->
name|fullpath
expr_stmt|;
name|node
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|nodename
operator|=
name|xstrdup
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|node
operator|->
name|contents
operator|=
name|file_buffer
operator|->
name|contents
expr_stmt|;
name|node
operator|->
name|nodelen
operator|=
name|file_buffer
operator|->
name|filesize
expr_stmt|;
name|node
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|display_pos
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MAN_PAGES
argument_list|)
comment|/* If the file buffer is the magic one associated with manpages, call      the manpage node finding function instead. */
elseif|else
if|if
condition|(
name|file_buffer
operator|->
name|flags
operator|&
name|N_IsManPage
condition|)
block|{
name|node
operator|=
name|get_manpage_node
argument_list|(
name|file_buffer
argument_list|,
name|nodename
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HANDLE_MAN_PAGES */
comment|/* If this is the "main" info file, it might contain a tags table.  Search      the tags table for an entry which matches the node that we want.  If      there is a tags table, get the file which contains this node, but don't      bother building a node list for it. */
elseif|else
if|if
condition|(
name|file_buffer
operator|->
name|tags
condition|)
block|{
name|node
operator|=
name|info_node_of_file_buffer_tags
argument_list|(
name|file_buffer
argument_list|,
name|nodename
argument_list|)
expr_stmt|;
block|}
comment|/* Return the results of our node search. */
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Locate the file named by FILENAME, and return the information structure    describing this file.  The file may appear in our list of loaded files    already, or it may not.  If it does not already appear, find the file,    and add it to the list of loaded files.  If the file cannot be found,    return a NULL FILE_BUFFER *. */
end_comment

begin_function
name|FILE_BUFFER
modifier|*
name|info_find_file
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
return|return
name|info_find_file_internal
argument_list|(
name|filename
argument_list|,
name|INFO_GET_TAGS
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Load the info file FILENAME, remembering information about it in a    file buffer. */
end_comment

begin_function
name|FILE_BUFFER
modifier|*
name|info_load_file
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
return|return
name|info_load_file_internal
argument_list|(
name|filename
argument_list|,
name|INFO_GET_TAGS
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Private functions implementation.  */
end_comment

begin_comment
comment|/* The workhorse for info_find_file ().  Non-zero 2nd argument says to    try to build a tags table (or otherwise glean the nodes) for this    file once found.  By default, we build the tags table, but when this    function is called by info_get_node () when we already have a valid    tags table describing the nodes, it is unnecessary. */
end_comment

begin_function
specifier|static
name|FILE_BUFFER
modifier|*
name|info_find_file_internal
parameter_list|(
name|filename
parameter_list|,
name|get_tags
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|get_tags
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|FILE_BUFFER
modifier|*
name|file_buffer
decl_stmt|;
comment|/* First try to find the file in our list of already loaded files. */
if|if
condition|(
name|info_loaded_files
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|file_buffer
operator|=
name|info_loaded_files
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|FILENAME_CMP
argument_list|(
name|filename
argument_list|,
name|file_buffer
operator|->
name|filename
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|FILENAME_CMP
argument_list|(
name|filename
argument_list|,
name|file_buffer
operator|->
name|fullpath
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|!
name|IS_ABSOLUTE
argument_list|(
name|filename
argument_list|)
operator|&&
name|FILENAME_CMP
argument_list|(
name|filename
argument_list|,
name|filename_non_directory
argument_list|(
name|file_buffer
operator|->
name|fullpath
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|struct
name|stat
name|new_info
decl_stmt|,
modifier|*
name|old_info
decl_stmt|;
comment|/* This file is loaded.  If the filename that we want is                specifically "dir", then simply return the file buffer. */
if|if
condition|(
name|is_dir_name
argument_list|(
name|filename_non_directory
argument_list|(
name|filename
argument_list|)
argument_list|)
condition|)
return|return
name|file_buffer
return|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MAN_PAGES
argument_list|)
comment|/* Do the same for the magic MANPAGE file. */
if|if
condition|(
name|file_buffer
operator|->
name|flags
operator|&
name|N_IsManPage
condition|)
return|return
name|file_buffer
return|;
endif|#
directive|endif
comment|/* HANDLE_MAN_PAGES */
comment|/* The file appears to be already loaded, and it is not "dir".                Check to see if it has changed since the last time it was                loaded. */
if|if
condition|(
name|stat
argument_list|(
name|file_buffer
operator|->
name|fullpath
argument_list|,
operator|&
name|new_info
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|filesys_error_number
operator|=
name|errno
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|old_info
operator|=
operator|&
name|file_buffer
operator|->
name|finfo
expr_stmt|;
if|if
condition|(
operator|(
name|new_info
operator|.
name|st_size
operator|!=
name|old_info
operator|->
name|st_size
operator|)
operator|||
operator|(
name|new_info
operator|.
name|st_mtime
operator|!=
name|old_info
operator|->
name|st_mtime
operator|)
condition|)
block|{
comment|/* The file has changed.  Forget that we ever had loaded it                    in the first place. */
name|forget_info_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* The info file exists, and has not changed since the last                    time it was loaded.  If the caller requested a nodes list                    for this file, and there isn't one here, build the nodes                    for this file_buffer.  In any case, return the file_buffer                    object. */
if|if
condition|(
operator|!
name|file_buffer
operator|->
name|contents
condition|)
block|{
comment|/* The file's contents have been gc'ed.  Reload it.  */
name|info_reload_file_buffer_contents
argument_list|(
name|file_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_buffer
operator|->
name|contents
condition|)
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|get_tags
operator|&&
operator|!
name|file_buffer
operator|->
name|tags
condition|)
name|build_tags_and_nodes
argument_list|(
name|file_buffer
argument_list|)
expr_stmt|;
return|return
name|file_buffer
return|;
block|}
block|}
block|}
comment|/* The file wasn't loaded.  Try to load it now. */
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MAN_PAGES
argument_list|)
comment|/* If the name of the file that we want is our special file buffer for      Unix manual pages, then create the file buffer, and return it now. */
if|if
condition|(
name|strcasecmp
argument_list|(
name|filename
argument_list|,
name|MANPAGE_FILE_BUFFER_NAME
argument_list|)
operator|==
literal|0
condition|)
name|file_buffer
operator|=
name|create_manpage_file_buffer
argument_list|()
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* HANDLE_MAN_PAGES */
name|file_buffer
operator|=
name|info_load_file_internal
argument_list|(
name|filename
argument_list|,
name|get_tags
argument_list|)
expr_stmt|;
comment|/* If the file was loaded, remember the name under which it was found. */
if|if
condition|(
name|file_buffer
condition|)
name|remember_info_file
argument_list|(
name|file_buffer
argument_list|)
expr_stmt|;
return|return
name|file_buffer
return|;
block|}
end_function

begin_comment
comment|/* The workhorse function for info_load_file ().  Non-zero second argument    says to build a list of tags (or nodes) for this file.  This is the    default behaviour when info_load_file () is called, but it is not    necessary when loading a subfile for which we already have tags. */
end_comment

begin_function
specifier|static
name|FILE_BUFFER
modifier|*
name|info_load_file_internal
parameter_list|(
name|filename
parameter_list|,
name|get_tags
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|get_tags
decl_stmt|;
block|{
name|char
modifier|*
name|fullpath
decl_stmt|,
modifier|*
name|contents
decl_stmt|;
name|long
name|filesize
decl_stmt|;
name|struct
name|stat
name|finfo
decl_stmt|;
name|int
name|retcode
decl_stmt|,
name|compressed
decl_stmt|;
name|FILE_BUFFER
modifier|*
name|file_buffer
init|=
name|NULL
decl_stmt|;
comment|/* Get the full pathname of this file, as known by the info system.      That is to say, search along INFOPATH and expand tildes, etc. */
name|fullpath
operator|=
name|info_find_fullpath
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Did we actually find the file? */
name|retcode
operator|=
name|stat
argument_list|(
name|fullpath
argument_list|,
operator|&
name|finfo
argument_list|)
expr_stmt|;
comment|/* If the file referenced by the name returned from info_find_fullpath ()      doesn't exist, then try again with the last part of the filename      appearing in lowercase. */
comment|/* This is probably not needed at all on those systems which define      FILENAME_CMP to be strcasecmp.  But let's do it anyway, lest some      network redirector supports case sensitivity.  */
if|if
condition|(
name|retcode
operator|<
literal|0
condition|)
block|{
name|char
modifier|*
name|lowered_name
decl_stmt|;
name|char
modifier|*
name|basename
decl_stmt|;
name|lowered_name
operator|=
name|xstrdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|basename
operator|=
name|filename_non_directory
argument_list|(
name|lowered_name
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|basename
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|basename
argument_list|)
condition|)
operator|*
name|basename
operator|=
name|tolower
argument_list|(
operator|*
name|basename
argument_list|)
expr_stmt|;
name|basename
operator|++
expr_stmt|;
block|}
name|fullpath
operator|=
name|info_find_fullpath
argument_list|(
name|lowered_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lowered_name
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|stat
argument_list|(
name|fullpath
argument_list|,
operator|&
name|finfo
argument_list|)
expr_stmt|;
block|}
comment|/* If the file wasn't found, give up, returning a NULL pointer. */
if|if
condition|(
name|retcode
operator|<
literal|0
condition|)
block|{
name|filesys_error_number
operator|=
name|errno
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Otherwise, try to load the file. */
name|contents
operator|=
name|filesys_read_info_file
argument_list|(
name|fullpath
argument_list|,
operator|&
name|filesize
argument_list|,
operator|&
name|finfo
argument_list|,
operator|&
name|compressed
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|contents
condition|)
return|return
name|NULL
return|;
comment|/* The file was found, and can be read.  Allocate FILE_BUFFER and fill      in the various members. */
name|file_buffer
operator|=
name|make_file_buffer
argument_list|()
expr_stmt|;
name|file_buffer
operator|->
name|filename
operator|=
name|xstrdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|file_buffer
operator|->
name|fullpath
operator|=
name|xstrdup
argument_list|(
name|fullpath
argument_list|)
expr_stmt|;
name|file_buffer
operator|->
name|finfo
operator|=
name|finfo
expr_stmt|;
name|file_buffer
operator|->
name|filesize
operator|=
name|filesize
expr_stmt|;
name|file_buffer
operator|->
name|contents
operator|=
name|contents
expr_stmt|;
if|if
condition|(
name|compressed
condition|)
name|file_buffer
operator|->
name|flags
operator||=
name|N_IsCompressed
expr_stmt|;
comment|/* If requested, build the tags and nodes for this file buffer. */
if|if
condition|(
name|get_tags
condition|)
name|build_tags_and_nodes
argument_list|(
name|file_buffer
argument_list|)
expr_stmt|;
return|return
name|file_buffer
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Grovel FILE_BUFFER->contents finding tags and nodes, and filling in the    various slots.  This can also be used to rebuild a tag or node table. */
end_comment

begin_function
name|void
name|build_tags_and_nodes
parameter_list|(
name|file_buffer
parameter_list|)
name|FILE_BUFFER
modifier|*
name|file_buffer
decl_stmt|;
block|{
name|SEARCH_BINDING
name|binding
decl_stmt|;
name|long
name|position
decl_stmt|;
name|free_file_buffer_tags
argument_list|(
name|file_buffer
argument_list|)
expr_stmt|;
name|file_buffer
operator|->
name|flags
operator|&=
operator|~
name|N_HasTagsTable
expr_stmt|;
comment|/* See if there is a tags table in this info file. */
name|binding
operator|.
name|buffer
operator|=
name|file_buffer
operator|->
name|contents
expr_stmt|;
name|binding
operator|.
name|start
operator|=
name|file_buffer
operator|->
name|filesize
expr_stmt|;
name|binding
operator|.
name|end
operator|=
name|binding
operator|.
name|start
operator|-
literal|1000
expr_stmt|;
if|if
condition|(
name|binding
operator|.
name|end
operator|<
literal|0
condition|)
name|binding
operator|.
name|end
operator|=
literal|0
expr_stmt|;
name|binding
operator|.
name|flags
operator|=
name|S_FoldCase
expr_stmt|;
name|position
operator|=
name|search_backward
argument_list|(
name|TAGS_TABLE_END_LABEL
argument_list|,
operator|&
name|binding
argument_list|)
expr_stmt|;
comment|/* If there is a tag table, find the start of it, and grovel over it      extracting tag information. */
if|if
condition|(
name|position
operator|!=
operator|-
literal|1
condition|)
while|while
condition|(
literal|1
condition|)
block|{
name|long
name|tags_table_begin
decl_stmt|,
name|tags_table_end
decl_stmt|;
name|binding
operator|.
name|end
operator|=
name|position
expr_stmt|;
name|binding
operator|.
name|start
operator|=
name|binding
operator|.
name|end
operator|-
literal|5
operator|-
name|strlen
argument_list|(
name|TAGS_TABLE_END_LABEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding
operator|.
name|start
operator|<
literal|0
condition|)
name|binding
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|position
operator|=
name|find_node_separator
argument_list|(
operator|&
name|binding
argument_list|)
expr_stmt|;
comment|/* For this test, (and all others here) failure indicates a bogus            tags table.  Grovel the file. */
if|if
condition|(
name|position
operator|==
operator|-
literal|1
condition|)
break|break;
comment|/* Remember the end of the tags table. */
name|binding
operator|.
name|start
operator|=
name|position
expr_stmt|;
name|tags_table_end
operator|=
name|binding
operator|.
name|start
expr_stmt|;
name|binding
operator|.
name|end
operator|=
literal|0
expr_stmt|;
comment|/* Locate the start of the tags table. */
name|position
operator|=
name|search_backward
argument_list|(
name|TAGS_TABLE_BEG_LABEL
argument_list|,
operator|&
name|binding
argument_list|)
expr_stmt|;
if|if
condition|(
name|position
operator|==
operator|-
literal|1
condition|)
break|break;
name|binding
operator|.
name|end
operator|=
name|position
expr_stmt|;
name|binding
operator|.
name|start
operator|=
name|binding
operator|.
name|end
operator|-
literal|5
operator|-
name|strlen
argument_list|(
name|TAGS_TABLE_BEG_LABEL
argument_list|)
expr_stmt|;
name|position
operator|=
name|find_node_separator
argument_list|(
operator|&
name|binding
argument_list|)
expr_stmt|;
if|if
condition|(
name|position
operator|==
operator|-
literal|1
condition|)
break|break;
comment|/* The file contains a valid tags table.  Fill the FILE_BUFFER's            tags member. */
name|file_buffer
operator|->
name|flags
operator||=
name|N_HasTagsTable
expr_stmt|;
name|tags_table_begin
operator|=
name|position
expr_stmt|;
comment|/* If this isn't an indirect tags table, just remember the nodes            described locally in this tags table.  Note that binding.end            is pointing to just after the beginning label. */
name|binding
operator|.
name|start
operator|=
name|binding
operator|.
name|end
expr_stmt|;
name|binding
operator|.
name|end
operator|=
name|file_buffer
operator|->
name|filesize
expr_stmt|;
if|if
condition|(
operator|!
name|looking_at
argument_list|(
name|TAGS_TABLE_IS_INDIRECT_LABEL
argument_list|,
operator|&
name|binding
argument_list|)
condition|)
block|{
name|binding
operator|.
name|start
operator|=
name|tags_table_begin
expr_stmt|;
name|binding
operator|.
name|end
operator|=
name|tags_table_end
expr_stmt|;
name|get_nodes_of_tags_table
argument_list|(
name|file_buffer
argument_list|,
operator|&
name|binding
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* This is an indirect tags table.  Build TAGS member. */
name|SEARCH_BINDING
name|indirect
decl_stmt|;
name|indirect
operator|.
name|start
operator|=
name|tags_table_begin
expr_stmt|;
name|indirect
operator|.
name|end
operator|=
literal|0
expr_stmt|;
name|indirect
operator|.
name|buffer
operator|=
name|binding
operator|.
name|buffer
expr_stmt|;
name|indirect
operator|.
name|flags
operator|=
name|S_FoldCase
expr_stmt|;
name|position
operator|=
name|search_backward
argument_list|(
name|INDIRECT_TAGS_TABLE_LABEL
argument_list|,
operator|&
name|indirect
argument_list|)
expr_stmt|;
if|if
condition|(
name|position
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* This file is malformed.  Give up. */
return|return;
block|}
name|indirect
operator|.
name|start
operator|=
name|position
expr_stmt|;
name|indirect
operator|.
name|end
operator|=
name|tags_table_begin
expr_stmt|;
name|binding
operator|.
name|start
operator|=
name|tags_table_begin
expr_stmt|;
name|binding
operator|.
name|end
operator|=
name|tags_table_end
expr_stmt|;
name|get_tags_of_indirect_tags_table
argument_list|(
name|file_buffer
argument_list|,
operator|&
name|indirect
argument_list|,
operator|&
name|binding
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* This file doesn't contain any kind of tags table.  Grovel the      file and build node entries for it. */
name|get_nodes_of_info_file
argument_list|(
name|file_buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Search through FILE_BUFFER->contents building an array of TAG *,    one entry per each node present in the file.  Store the tags in    FILE_BUFFER->tags, and the number of allocated slots in    FILE_BUFFER->tags_slots. */
end_comment

begin_function
specifier|static
name|void
name|get_nodes_of_info_file
parameter_list|(
name|file_buffer
parameter_list|)
name|FILE_BUFFER
modifier|*
name|file_buffer
decl_stmt|;
block|{
name|long
name|nodestart
decl_stmt|;
name|int
name|tags_index
init|=
literal|0
decl_stmt|;
name|SEARCH_BINDING
name|binding
decl_stmt|;
name|binding
operator|.
name|buffer
operator|=
name|file_buffer
operator|->
name|contents
expr_stmt|;
name|binding
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|binding
operator|.
name|end
operator|=
name|file_buffer
operator|->
name|filesize
expr_stmt|;
name|binding
operator|.
name|flags
operator|=
name|S_FoldCase
expr_stmt|;
while|while
condition|(
operator|(
name|nodestart
operator|=
name|find_node_separator
argument_list|(
operator|&
name|binding
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|char
modifier|*
name|nodeline
decl_stmt|;
name|TAG
modifier|*
name|entry
decl_stmt|;
name|int
name|anchor
init|=
literal|0
decl_stmt|;
comment|/* Skip past the characters just found. */
name|binding
operator|.
name|start
operator|=
name|nodestart
expr_stmt|;
name|binding
operator|.
name|start
operator|+=
name|skip_node_separator
argument_list|(
name|binding
operator|.
name|buffer
operator|+
name|binding
operator|.
name|start
argument_list|)
expr_stmt|;
comment|/* Move to the start of the line defining the node. */
name|nodeline
operator|=
name|binding
operator|.
name|buffer
operator|+
name|binding
operator|.
name|start
expr_stmt|;
comment|/* Find "Node:" */
name|start
operator|=
name|string_in_line
argument_list|(
name|INFO_NODE_LABEL
argument_list|,
name|nodeline
argument_list|)
expr_stmt|;
comment|/* No Node:.  Maybe it's a Ref:.  */
if|if
condition|(
name|start
operator|==
operator|-
literal|1
condition|)
block|{
name|start
operator|=
name|string_in_line
argument_list|(
name|INFO_REF_LABEL
argument_list|,
name|nodeline
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|!=
operator|-
literal|1
condition|)
name|anchor
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If not there, this is not the start of a node. */
if|if
condition|(
name|start
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|/* Find the start of the nodename. */
name|start
operator|+=
name|skip_whitespace
argument_list|(
name|nodeline
operator|+
name|start
argument_list|)
expr_stmt|;
comment|/* Find the end of the nodename. */
name|end
operator|=
name|start
operator|+
name|skip_node_characters
argument_list|(
name|nodeline
operator|+
name|start
argument_list|,
name|DONT_SKIP_NEWLINES
argument_list|)
expr_stmt|;
comment|/* Okay, we have isolated the node name, and we know where the          node starts.  Remember this information. */
name|entry
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TAG
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|nodename
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
operator|(
name|end
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|entry
operator|->
name|nodename
argument_list|,
name|nodeline
operator|+
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|entry
operator|->
name|nodename
index|[
name|end
operator|-
name|start
index|]
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|nodestart
operator|=
name|nodestart
expr_stmt|;
if|if
condition|(
name|anchor
condition|)
name|entry
operator|->
name|nodelen
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|SEARCH_BINDING
name|node_body
decl_stmt|;
name|node_body
operator|.
name|buffer
operator|=
name|binding
operator|.
name|buffer
operator|+
name|binding
operator|.
name|start
expr_stmt|;
name|node_body
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|node_body
operator|.
name|end
operator|=
name|binding
operator|.
name|end
operator|-
name|binding
operator|.
name|start
expr_stmt|;
name|node_body
operator|.
name|flags
operator|=
name|S_FoldCase
expr_stmt|;
name|entry
operator|->
name|nodelen
operator|=
name|get_node_length
argument_list|(
operator|&
name|node_body
argument_list|)
expr_stmt|;
block|}
name|entry
operator|->
name|filename
operator|=
name|file_buffer
operator|->
name|fullpath
expr_stmt|;
comment|/* Add this tag to the array of tag structures in this FILE_BUFFER. */
name|add_pointer_to_array
argument_list|(
name|entry
argument_list|,
name|tags_index
argument_list|,
name|file_buffer
operator|->
name|tags
argument_list|,
name|file_buffer
operator|->
name|tags_slots
argument_list|,
literal|100
argument_list|,
name|TAG
operator|*
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the length of the node which starts at BINDING. */
end_comment

begin_function
specifier|static
name|long
name|get_node_length
parameter_list|(
name|binding
parameter_list|)
name|SEARCH_BINDING
modifier|*
name|binding
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|body
decl_stmt|;
comment|/* [A node] ends with either a ^_, a ^L, or end of file.  */
for|for
control|(
name|i
operator|=
name|binding
operator|->
name|start
operator|,
name|body
operator|=
name|binding
operator|->
name|buffer
init|;
name|i
operator|<
name|binding
operator|->
name|end
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|body
index|[
name|i
index|]
operator|==
name|INFO_FF
operator|||
name|body
index|[
name|i
index|]
operator|==
name|INFO_COOKIE
condition|)
break|break;
block|}
return|return
name|i
operator|-
name|binding
operator|->
name|start
return|;
block|}
end_function

begin_comment
comment|/* Build and save the array of nodes in FILE_BUFFER by searching through the    contents of BUFFER_BINDING for a tags table, and groveling the contents. */
end_comment

begin_function
specifier|static
name|void
name|get_nodes_of_tags_table
parameter_list|(
name|file_buffer
parameter_list|,
name|buffer_binding
parameter_list|)
name|FILE_BUFFER
modifier|*
name|file_buffer
decl_stmt|;
name|SEARCH_BINDING
modifier|*
name|buffer_binding
decl_stmt|;
block|{
name|int
name|name_offset
decl_stmt|;
name|SEARCH_BINDING
modifier|*
name|search
decl_stmt|;
name|long
name|position
decl_stmt|;
name|int
name|tags_index
init|=
literal|0
decl_stmt|;
name|search
operator|=
name|copy_binding
argument_list|(
name|buffer_binding
argument_list|)
expr_stmt|;
comment|/* Find the start of the tags table. */
name|position
operator|=
name|find_tags_table
argument_list|(
name|search
argument_list|)
expr_stmt|;
comment|/* If none, we're all done. */
if|if
condition|(
name|position
operator|==
operator|-
literal|1
condition|)
return|return;
comment|/* Move to one character before the start of the actual table. */
name|search
operator|->
name|start
operator|=
name|position
expr_stmt|;
name|search
operator|->
name|start
operator|+=
name|skip_node_separator
argument_list|(
name|search
operator|->
name|buffer
operator|+
name|search
operator|->
name|start
argument_list|)
expr_stmt|;
name|search
operator|->
name|start
operator|+=
name|strlen
argument_list|(
name|TAGS_TABLE_BEG_LABEL
argument_list|)
expr_stmt|;
name|search
operator|->
name|start
operator|--
expr_stmt|;
comment|/* The tag table consists of lines containing node names and positions.      Do each line until we find one that doesn't contain a node name. */
while|while
condition|(
operator|(
name|position
operator|=
name|search_forward
argument_list|(
literal|"\n"
argument_list|,
name|search
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|TAG
modifier|*
name|entry
decl_stmt|;
name|char
modifier|*
name|nodedef
decl_stmt|;
name|unsigned
name|p
decl_stmt|;
name|int
name|anchor
init|=
literal|0
decl_stmt|;
comment|/* Prepare to skip this line. */
name|search
operator|->
name|start
operator|=
name|position
expr_stmt|;
name|search
operator|->
name|start
operator|++
expr_stmt|;
comment|/* Skip past informative "(Indirect)" tags table line. */
if|if
condition|(
operator|!
name|tags_index
operator|&&
name|looking_at
argument_list|(
name|TAGS_TABLE_IS_INDIRECT_LABEL
argument_list|,
name|search
argument_list|)
condition|)
continue|continue;
comment|/* Find the label preceding the node name. */
name|name_offset
operator|=
name|string_in_line
argument_list|(
name|INFO_NODE_LABEL
argument_list|,
name|search
operator|->
name|buffer
operator|+
name|search
operator|->
name|start
argument_list|)
expr_stmt|;
comment|/* If no node label, maybe it's an anchor.  */
if|if
condition|(
name|name_offset
operator|==
operator|-
literal|1
condition|)
block|{
name|name_offset
operator|=
name|string_in_line
argument_list|(
name|INFO_REF_LABEL
argument_list|,
name|search
operator|->
name|buffer
operator|+
name|search
operator|->
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_offset
operator|!=
operator|-
literal|1
condition|)
name|anchor
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If not there, not a defining line, so we must be out of the          tags table.  */
if|if
condition|(
name|name_offset
operator|==
operator|-
literal|1
condition|)
break|break;
name|entry
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TAG
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the beginning of the node definition. */
name|search
operator|->
name|start
operator|+=
name|name_offset
expr_stmt|;
name|nodedef
operator|=
name|search
operator|->
name|buffer
operator|+
name|search
operator|->
name|start
expr_stmt|;
name|nodedef
operator|+=
name|skip_whitespace
argument_list|(
name|nodedef
argument_list|)
expr_stmt|;
comment|/* Move past the node's name in this tag to the TAGSEP character. */
for|for
control|(
name|p
operator|=
literal|0
init|;
name|nodedef
index|[
name|p
index|]
operator|&&
name|nodedef
index|[
name|p
index|]
operator|!=
name|INFO_TAGSEP
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|nodedef
index|[
name|p
index|]
operator|!=
name|INFO_TAGSEP
condition|)
continue|continue;
name|entry
operator|->
name|nodename
operator|=
name|xmalloc
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|entry
operator|->
name|nodename
argument_list|,
name|nodedef
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|entry
operator|->
name|nodename
index|[
name|p
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|entry
operator|->
name|nodestart
operator|=
name|atol
argument_list|(
name|nodedef
operator|+
name|p
argument_list|)
expr_stmt|;
comment|/* If a node, we don't know the length yet, but if it's an          anchor, the length is 0. */
name|entry
operator|->
name|nodelen
operator|=
name|anchor
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
comment|/* The filename of this node is currently known as the same as the          name of this file. */
name|entry
operator|->
name|filename
operator|=
name|file_buffer
operator|->
name|fullpath
expr_stmt|;
comment|/* Add this node structure to the array of node structures in this          FILE_BUFFER. */
name|add_pointer_to_array
argument_list|(
name|entry
argument_list|,
name|tags_index
argument_list|,
name|file_buffer
operator|->
name|tags
argument_list|,
name|file_buffer
operator|->
name|tags_slots
argument_list|,
literal|100
argument_list|,
name|TAG
operator|*
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|search
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A structure used only in `get_tags_of_indirect_tags_table' to hold onto    an intermediate value. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|long
name|first_byte
decl_stmt|;
block|}
name|SUBFILE
typedef|;
end_typedef

begin_comment
comment|/* Remember in FILE_BUFFER the nodenames, subfilenames, and offsets within the    subfiles of every node which appears in TAGS_BINDING.  The 2nd argument is    a binding surrounding the indirect files list. */
end_comment

begin_function
specifier|static
name|void
name|get_tags_of_indirect_tags_table
parameter_list|(
name|file_buffer
parameter_list|,
name|indirect_binding
parameter_list|,
name|tags_binding
parameter_list|)
name|FILE_BUFFER
modifier|*
name|file_buffer
decl_stmt|;
name|SEARCH_BINDING
modifier|*
name|indirect_binding
decl_stmt|,
decl|*
name|tags_binding
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
name|SUBFILE
modifier|*
modifier|*
name|subfiles
init|=
name|NULL
decl_stmt|;
name|int
name|subfiles_index
init|=
literal|0
decl_stmt|,
name|subfiles_slots
init|=
literal|0
decl_stmt|;
name|TAG
modifier|*
name|entry
decl_stmt|;
comment|/* First get the list of tags from the tags table.  Then lookup the      associated file in the indirect list for each tag, and update it. */
name|get_nodes_of_tags_table
argument_list|(
name|file_buffer
argument_list|,
name|tags_binding
argument_list|)
expr_stmt|;
comment|/* We have the list of tags in file_buffer->tags.  Get the list of      subfiles from the indirect table. */
block|{
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|line
decl_stmt|;
name|SUBFILE
modifier|*
name|subfile
decl_stmt|;
name|start
operator|=
name|indirect_binding
operator|->
name|buffer
operator|+
name|indirect_binding
operator|->
name|start
expr_stmt|;
name|end
operator|=
name|indirect_binding
operator|->
name|buffer
operator|+
name|indirect_binding
operator|->
name|end
expr_stmt|;
name|line
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|line
operator|<
name|end
condition|)
block|{
name|int
name|colon
decl_stmt|;
name|colon
operator|=
name|string_in_line
argument_list|(
literal|":"
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|colon
operator|==
operator|-
literal|1
condition|)
break|break;
name|subfile
operator|=
operator|(
name|SUBFILE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SUBFILE
argument_list|)
argument_list|)
expr_stmt|;
name|subfile
operator|->
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|colon
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|subfile
operator|->
name|filename
argument_list|,
name|line
argument_list|,
name|colon
operator|-
literal|1
argument_list|)
expr_stmt|;
name|subfile
operator|->
name|filename
index|[
name|colon
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|subfile
operator|->
name|first_byte
operator|=
operator|(
name|long
operator|)
name|atol
argument_list|(
name|line
operator|+
name|colon
argument_list|)
expr_stmt|;
name|add_pointer_to_array
argument_list|(
name|subfile
argument_list|,
name|subfiles_index
argument_list|,
name|subfiles
argument_list|,
name|subfiles_slots
argument_list|,
literal|10
argument_list|,
name|SUBFILE
operator|*
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|line
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
block|}
block|}
comment|/* If we have successfully built the indirect files table, then      merge the information in the two tables. */
if|if
condition|(
operator|!
name|subfiles
condition|)
block|{
name|free_file_buffer_tags
argument_list|(
name|file_buffer
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|int
name|tags_index
decl_stmt|;
name|long
name|header_length
decl_stmt|;
name|SEARCH_BINDING
name|binding
decl_stmt|;
comment|/* Find the length of the header of the file containing the indirect          tags table.  This header appears at the start of every file.  We          want the absolute position of each node within each subfile, so          we subtract the start of the containing subfile from the logical          position of the node, and then add the length of the header in. */
name|binding
operator|.
name|buffer
operator|=
name|file_buffer
operator|->
name|contents
expr_stmt|;
name|binding
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|binding
operator|.
name|end
operator|=
name|file_buffer
operator|->
name|filesize
expr_stmt|;
name|binding
operator|.
name|flags
operator|=
name|S_FoldCase
expr_stmt|;
name|header_length
operator|=
name|find_node_separator
argument_list|(
operator|&
name|binding
argument_list|)
expr_stmt|;
if|if
condition|(
name|header_length
operator|==
operator|-
literal|1
condition|)
name|header_length
operator|=
literal|0
expr_stmt|;
comment|/* Build the file buffer's list of subfiles. */
block|{
name|char
modifier|*
name|containing_dir
init|=
name|xstrdup
argument_list|(
name|file_buffer
operator|->
name|fullpath
argument_list|)
decl_stmt|;
name|char
modifier|*
name|temp
init|=
name|filename_non_directory
argument_list|(
name|containing_dir
argument_list|)
decl_stmt|;
name|int
name|len_containing_dir
decl_stmt|;
if|if
condition|(
name|temp
operator|>
name|containing_dir
condition|)
block|{
if|if
condition|(
name|HAVE_DRIVE
argument_list|(
name|file_buffer
operator|->
name|fullpath
argument_list|)
operator|&&
name|temp
operator|==
name|containing_dir
operator|+
literal|2
condition|)
block|{
comment|/* Avoid converting "d:foo" into "d:/foo" below.  */
operator|*
name|temp
operator|=
literal|'.'
expr_stmt|;
name|temp
operator|+=
literal|2
expr_stmt|;
block|}
name|temp
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|len_containing_dir
operator|=
name|strlen
argument_list|(
name|containing_dir
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|subfiles
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|file_buffer
operator|->
name|subfiles
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
name|i
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|subfiles
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|fullpath
decl_stmt|;
name|fullpath
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
name|subfiles
index|[
name|i
index|]
operator|->
name|filename
argument_list|)
operator|+
name|len_containing_dir
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fullpath
argument_list|,
literal|"%s/%s"
argument_list|,
name|containing_dir
argument_list|,
name|subfiles
index|[
name|i
index|]
operator|->
name|filename
argument_list|)
expr_stmt|;
name|file_buffer
operator|->
name|subfiles
index|[
name|i
index|]
operator|=
name|fullpath
expr_stmt|;
block|}
name|file_buffer
operator|->
name|subfiles
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|containing_dir
argument_list|)
expr_stmt|;
block|}
comment|/* For each node in the file's tags table, remember the starting          position. */
for|for
control|(
name|tags_index
operator|=
literal|0
init|;
operator|(
name|entry
operator|=
name|file_buffer
operator|->
name|tags
index|[
name|tags_index
index|]
operator|)
condition|;
name|tags_index
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|subfiles
index|[
name|i
index|]
operator|&&
name|entry
operator|->
name|nodestart
operator|>=
name|subfiles
index|[
name|i
index|]
operator|->
name|first_byte
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* If the Info file containing the indirect tags table is              malformed, then give up. */
if|if
condition|(
operator|!
name|i
condition|)
block|{
comment|/* The Info file containing the indirect tags table is                  malformed.  Give up. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|subfiles
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|subfiles
index|[
name|i
index|]
operator|->
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|subfiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file_buffer
operator|->
name|subfiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|file_buffer
operator|->
name|subfiles
operator|=
name|NULL
expr_stmt|;
name|free_file_buffer_tags
argument_list|(
name|file_buffer
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* SUBFILES[i] is the index of the first subfile whose logical              first byte is greater than the logical offset of this node's              starting position.  This means that the subfile directly              preceding this one is the one containing the node. */
name|entry
operator|->
name|filename
operator|=
name|file_buffer
operator|->
name|subfiles
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|entry
operator|->
name|nodestart
operator|-=
name|subfiles
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|first_byte
expr_stmt|;
name|entry
operator|->
name|nodestart
operator|+=
name|header_length
expr_stmt|;
block|}
comment|/* We have successfully built the tags table.  Remember that it          was indirect. */
name|file_buffer
operator|->
name|flags
operator||=
name|N_TagsIndirect
expr_stmt|;
block|}
comment|/* Free the structures assigned to SUBFILES.  Free the names as well      as the structures themselves, then finally, the array. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|subfiles
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|subfiles
index|[
name|i
index|]
operator|->
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|subfiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|subfiles
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return the node that contains TAG in FILE_BUFFER, else    (pathologically) NULL.  Called from info_node_of_file_buffer_tags.  */
end_comment

begin_function
specifier|static
name|NODE
modifier|*
name|find_node_of_anchor
parameter_list|(
name|file_buffer
parameter_list|,
name|tag
parameter_list|)
name|FILE_BUFFER
modifier|*
name|file_buffer
decl_stmt|;
name|TAG
modifier|*
name|tag
decl_stmt|;
block|{
name|int
name|anchor_pos
decl_stmt|,
name|node_pos
decl_stmt|;
name|TAG
modifier|*
name|node_tag
decl_stmt|;
name|NODE
modifier|*
name|node
decl_stmt|;
comment|/* Look through the tag list for the anchor.  */
for|for
control|(
name|anchor_pos
operator|=
literal|0
init|;
name|file_buffer
operator|->
name|tags
index|[
name|anchor_pos
index|]
condition|;
name|anchor_pos
operator|++
control|)
block|{
name|TAG
modifier|*
name|t
init|=
name|file_buffer
operator|->
name|tags
index|[
name|anchor_pos
index|]
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|nodestart
operator|==
name|tag
operator|->
name|nodestart
condition|)
break|break;
block|}
comment|/* Should not happen, because we should always find the anchor.  */
if|if
condition|(
operator|!
name|file_buffer
operator|->
name|tags
index|[
name|anchor_pos
index|]
condition|)
return|return
name|NULL
return|;
comment|/* We've found the anchor.  Look backwards in the tag table for the      preceding node (we're assuming the tags are given in order),      skipping over any preceding anchors.  */
for|for
control|(
name|node_pos
operator|=
name|anchor_pos
operator|-
literal|1
init|;
name|node_pos
operator|>=
literal|0
operator|&&
name|file_buffer
operator|->
name|tags
index|[
name|node_pos
index|]
operator|->
name|nodelen
operator|==
literal|0
condition|;
name|node_pos
operator|--
control|)
empty_stmt|;
comment|/* An info file with an anchor before any nodes is pathological, but      it's possible, so don't crash.  */
if|if
condition|(
name|node_pos
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* We have the tag for the node that contained the anchor tag.  */
name|node_tag
operator|=
name|file_buffer
operator|->
name|tags
index|[
name|node_pos
index|]
expr_stmt|;
comment|/* Look up the node name in the tag table to get the actual node.      This is a recursive call, but it can't recurse again, because we      call it with a real node.  */
name|node
operator|=
name|info_node_of_file_buffer_tags
argument_list|(
name|file_buffer
argument_list|,
name|node_tag
operator|->
name|nodename
argument_list|)
expr_stmt|;
comment|/* Start displaying the node at the anchor position.  */
if|if
condition|(
name|node
condition|)
block|{
comment|/* The nodestart for real nodes is three characters before the `F'          in the `File:' line (a newline, the CTRL-_, and another          newline).  The nodestart for anchors is the actual position.          But we offset by only 2, rather than 3, because if an anchor is          at the beginning of a paragraph, it's nicer for it to end up on          the beginning of the first line of the paragraph rather than          the blank line before it.  (makeinfo has no way of knowing that          a paragraph is going to start, so we can't fix it there.)  */
name|node
operator|->
name|display_pos
operator|=
name|file_buffer
operator|->
name|tags
index|[
name|anchor_pos
index|]
operator|->
name|nodestart
operator|-
operator|(
name|node_tag
operator|->
name|nodestart
operator|+
literal|2
operator|)
expr_stmt|;
comment|/* Otherwise an anchor at the end of a node ends up displaying at          the end of the last line of the node (way over on the right of          the screen), which looks wrong.  */
if|if
condition|(
name|node
operator|->
name|display_pos
operator|>=
name|node
operator|->
name|nodelen
condition|)
name|node
operator|->
name|display_pos
operator|=
name|node
operator|->
name|nodelen
operator|-
literal|1
expr_stmt|;
comment|/* Don't search in the node for the xref text, it's not there.  */
name|node
operator|->
name|flags
operator||=
name|N_FromAnchor
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Return the node from FILE_BUFFER which matches NODENAME by searching    the tags table in FILE_BUFFER, or NULL.  */
end_comment

begin_function
specifier|static
name|NODE
modifier|*
name|info_node_of_file_buffer_tags
parameter_list|(
name|file_buffer
parameter_list|,
name|nodename
parameter_list|)
name|FILE_BUFFER
modifier|*
name|file_buffer
decl_stmt|;
name|char
modifier|*
name|nodename
decl_stmt|;
block|{
name|TAG
modifier|*
name|tag
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|tag
operator|=
name|file_buffer
operator|->
name|tags
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|nodename
argument_list|,
name|tag
operator|->
name|nodename
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FILE_BUFFER
modifier|*
name|subfile
decl_stmt|;
name|subfile
operator|=
name|info_find_file_internal
argument_list|(
name|tag
operator|->
name|filename
argument_list|,
name|INFO_NO_TAGS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subfile
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|subfile
operator|->
name|contents
condition|)
block|{
name|info_reload_file_buffer_contents
argument_list|(
name|subfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subfile
operator|->
name|contents
condition|)
return|return
name|NULL
return|;
block|}
comment|/* If we were able to find this file and load it, then return            the node within it. */
block|{
name|NODE
modifier|*
name|node
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NODE
argument_list|)
argument_list|)
decl_stmt|;
name|node
operator|->
name|filename
operator|=
name|subfile
operator|->
name|fullpath
expr_stmt|;
name|node
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|nodename
operator|=
name|tag
operator|->
name|nodename
expr_stmt|;
name|node
operator|->
name|contents
operator|=
name|subfile
operator|->
name|contents
operator|+
name|tag
operator|->
name|nodestart
expr_stmt|;
name|node
operator|->
name|display_pos
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|file_buffer
operator|->
name|flags
operator|&
name|N_HasTagsTable
condition|)
block|{
name|node
operator|->
name|flags
operator||=
name|N_HasTagsTable
expr_stmt|;
if|if
condition|(
name|file_buffer
operator|->
name|flags
operator|&
name|N_TagsIndirect
condition|)
block|{
name|node
operator|->
name|flags
operator||=
name|N_TagsIndirect
expr_stmt|;
name|node
operator|->
name|parent
operator|=
name|file_buffer
operator|->
name|fullpath
expr_stmt|;
block|}
block|}
if|if
condition|(
name|subfile
operator|->
name|flags
operator|&
name|N_IsCompressed
condition|)
name|node
operator|->
name|flags
operator||=
name|N_IsCompressed
expr_stmt|;
comment|/* If TAG->nodelen hasn't been calculated yet, then we aren't              in a position to trust the entry pointer.  Adjust things so              that ENTRY->nodestart gets the exact address of the start of              the node separator which starts this node, and NODE->contents              gets the address of the line defining this node.  If we cannot              do that, the node isn't really here. */
if|if
condition|(
name|tag
operator|->
name|nodelen
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|min
decl_stmt|,
name|max
decl_stmt|;
name|char
modifier|*
name|node_sep
decl_stmt|;
name|SEARCH_BINDING
name|node_body
decl_stmt|;
name|char
modifier|*
name|buff_end
decl_stmt|;
name|min
operator|=
name|max
operator|=
name|DEFAULT_INFO_FUDGE
expr_stmt|;
if|if
condition|(
name|tag
operator|->
name|nodestart
operator|<
name|DEFAULT_INFO_FUDGE
condition|)
name|min
operator|=
name|tag
operator|->
name|nodestart
expr_stmt|;
if|if
condition|(
name|DEFAULT_INFO_FUDGE
operator|>
operator|(
name|subfile
operator|->
name|filesize
operator|-
name|tag
operator|->
name|nodestart
operator|)
condition|)
name|max
operator|=
name|subfile
operator|->
name|filesize
operator|-
name|tag
operator|->
name|nodestart
expr_stmt|;
comment|/* NODE_SEP gets the address of the separator which defines                  this node, or NULL if the node wasn't found.                  NODE->contents is side-effected to point to right after                  the separator. */
name|node_sep
operator|=
name|adjust_nodestart
argument_list|(
name|node
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_sep
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Readjust tag->nodestart. */
name|tag
operator|->
name|nodestart
operator|=
name|node_sep
operator|-
name|subfile
operator|->
name|contents
expr_stmt|;
comment|/* Calculate the length of the current node. */
name|buff_end
operator|=
name|subfile
operator|->
name|contents
operator|+
name|subfile
operator|->
name|filesize
expr_stmt|;
name|node_body
operator|.
name|buffer
operator|=
name|node
operator|->
name|contents
expr_stmt|;
name|node_body
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|node_body
operator|.
name|end
operator|=
name|buff_end
operator|-
name|node_body
operator|.
name|buffer
expr_stmt|;
name|node_body
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|tag
operator|->
name|nodelen
operator|=
name|get_node_length
argument_list|(
operator|&
name|node_body
argument_list|)
expr_stmt|;
name|node
operator|->
name|nodelen
operator|=
name|tag
operator|->
name|nodelen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tag
operator|->
name|nodelen
operator|==
literal|0
condition|)
comment|/* anchor, return containing node */
block|{
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|find_node_of_anchor
argument_list|(
name|file_buffer
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Since we know the length of this node, we have already                  adjusted tag->nodestart to point to the exact start of                  it.  Simply skip the node separator. */
name|node
operator|->
name|contents
operator|+=
name|skip_node_separator
argument_list|(
name|node
operator|->
name|contents
argument_list|)
expr_stmt|;
name|node
operator|->
name|nodelen
operator|=
name|tag
operator|->
name|nodelen
expr_stmt|;
block|}
return|return
name|node
return|;
block|}
block|}
comment|/* There was a tag table for this file, and the node wasn't found.      Return NULL, since this file doesn't contain the desired node. */
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Managing file_buffers, nodes, and tags.  */
end_comment

begin_comment
comment|/* Create a new, empty file buffer. */
end_comment

begin_function
name|FILE_BUFFER
modifier|*
name|make_file_buffer
parameter_list|()
block|{
name|FILE_BUFFER
modifier|*
name|file_buffer
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FILE_BUFFER
argument_list|)
argument_list|)
decl_stmt|;
name|file_buffer
operator|->
name|filename
operator|=
name|file_buffer
operator|->
name|fullpath
operator|=
name|NULL
expr_stmt|;
name|file_buffer
operator|->
name|contents
operator|=
name|NULL
expr_stmt|;
name|file_buffer
operator|->
name|tags
operator|=
name|NULL
expr_stmt|;
name|file_buffer
operator|->
name|subfiles
operator|=
name|NULL
expr_stmt|;
name|file_buffer
operator|->
name|tags_slots
operator|=
literal|0
expr_stmt|;
name|file_buffer
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return
name|file_buffer
return|;
block|}
end_function

begin_comment
comment|/* Add FILE_BUFFER to our list of already loaded info files. */
end_comment

begin_function
specifier|static
name|void
name|remember_info_file
parameter_list|(
name|file_buffer
parameter_list|)
name|FILE_BUFFER
modifier|*
name|file_buffer
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|info_loaded_files
operator|&&
name|info_loaded_files
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|add_pointer_to_array
argument_list|(
name|file_buffer
argument_list|,
name|i
argument_list|,
name|info_loaded_files
argument_list|,
name|info_loaded_files_slots
argument_list|,
literal|10
argument_list|,
name|FILE_BUFFER
operator|*
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Forget the contents, tags table, nodes list, and names of FILENAME. */
end_comment

begin_function
specifier|static
name|void
name|forget_info_file
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|FILE_BUFFER
modifier|*
name|file_buffer
decl_stmt|;
if|if
condition|(
operator|!
name|info_loaded_files
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|file_buffer
operator|=
name|info_loaded_files
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|FILENAME_CMP
argument_list|(
name|filename
argument_list|,
name|file_buffer
operator|->
name|filename
argument_list|)
operator|==
literal|0
operator|||
name|FILENAME_CMP
argument_list|(
name|filename
argument_list|,
name|file_buffer
operator|->
name|fullpath
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|file_buffer
operator|->
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file_buffer
operator|->
name|fullpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_buffer
operator|->
name|contents
condition|)
name|free
argument_list|(
name|file_buffer
operator|->
name|contents
argument_list|)
expr_stmt|;
comment|/* free_file_buffer_tags () also kills the subfiles list, since            the subfiles list is only of use in conjunction with tags. */
name|free_file_buffer_tags
argument_list|(
name|file_buffer
argument_list|)
expr_stmt|;
comment|/* Move rest of list down.  */
while|while
condition|(
name|info_loaded_files
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
name|info_loaded_files
index|[
name|i
index|]
operator|=
name|info_loaded_files
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|info_loaded_files
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Free the tags (if any) associated with FILE_BUFFER. */
end_comment

begin_function
specifier|static
name|void
name|free_file_buffer_tags
parameter_list|(
name|file_buffer
parameter_list|)
name|FILE_BUFFER
modifier|*
name|file_buffer
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|file_buffer
operator|->
name|tags
condition|)
block|{
name|TAG
modifier|*
name|tag
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|tag
operator|=
name|file_buffer
operator|->
name|tags
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
name|free_info_tag
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file_buffer
operator|->
name|tags
argument_list|)
expr_stmt|;
name|file_buffer
operator|->
name|tags
operator|=
name|NULL
expr_stmt|;
name|file_buffer
operator|->
name|tags_slots
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|file_buffer
operator|->
name|subfiles
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|file_buffer
operator|->
name|subfiles
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|file_buffer
operator|->
name|subfiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file_buffer
operator|->
name|subfiles
argument_list|)
expr_stmt|;
name|file_buffer
operator|->
name|subfiles
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Free the data associated with TAG, as well as TAG itself. */
end_comment

begin_function
specifier|static
name|void
name|free_info_tag
parameter_list|(
name|tag
parameter_list|)
name|TAG
modifier|*
name|tag
decl_stmt|;
block|{
name|free
argument_list|(
name|tag
operator|->
name|nodename
argument_list|)
expr_stmt|;
comment|/* We don't free tag->filename, because that filename is part of the      subfiles list for the containing FILE_BUFFER.  free_info_tags ()      will free the subfiles when it is appropriate. */
name|free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Load the contents of FILE_BUFFER->contents.  This function is called    when a file buffer was loaded, and then in order to conserve memory, the    file buffer's contents were freed and the pointer was zero'ed.  Note that    the file was already loaded at least once successfully, so the tags and/or    nodes members are still correctly filled. */
end_comment

begin_function
specifier|static
name|void
name|info_reload_file_buffer_contents
parameter_list|(
name|fb
parameter_list|)
name|FILE_BUFFER
modifier|*
name|fb
decl_stmt|;
block|{
name|int
name|is_compressed
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MAN_PAGES
argument_list|)
comment|/* If this is the magic manpage node, don't try to reload, just give up. */
if|if
condition|(
name|fb
operator|->
name|flags
operator|&
name|N_IsManPage
condition|)
return|return;
endif|#
directive|endif
name|fb
operator|->
name|flags
operator|&=
operator|~
name|N_IsCompressed
expr_stmt|;
comment|/* Let the filesystem do all the work for us. */
name|fb
operator|->
name|contents
operator|=
name|filesys_read_info_file
argument_list|(
name|fb
operator|->
name|fullpath
argument_list|,
operator|&
operator|(
name|fb
operator|->
name|filesize
operator|)
argument_list|,
operator|&
operator|(
name|fb
operator|->
name|finfo
operator|)
argument_list|,
operator|&
name|is_compressed
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_compressed
condition|)
name|fb
operator|->
name|flags
operator||=
name|N_IsCompressed
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the actual starting memory location of NODE, side-effecting    NODE->contents.  MIN and MAX are bounds for a search if one is necessary.    Because of the way that tags are implemented, the physical nodestart may    not actually be where the tag says it is.  If that is the case, but the    node was found anyway, set N_UpdateTags in NODE->flags.  If the node is    found, return non-zero.  NODE->contents is returned positioned right after    the node separator that precedes this node, while the return value is    position directly on the separator that precedes this node.  If the node    could not be found, return a NULL pointer. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|adjust_nodestart
parameter_list|(
name|node
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|)
name|NODE
modifier|*
name|node
decl_stmt|;
name|int
name|min
decl_stmt|,
name|max
decl_stmt|;
block|{
name|long
name|position
decl_stmt|;
name|SEARCH_BINDING
name|node_body
decl_stmt|;
comment|/* Define the node body. */
name|node_body
operator|.
name|buffer
operator|=
name|node
operator|->
name|contents
expr_stmt|;
name|node_body
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|node_body
operator|.
name|end
operator|=
name|max
expr_stmt|;
name|node_body
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* Try the optimal case first.  Who knows?  This file may actually be      formatted (mostly) correctly. */
if|if
condition|(
name|node_body
operator|.
name|buffer
index|[
literal|0
index|]
operator|!=
name|INFO_COOKIE
operator|&&
name|min
operator|>
literal|2
condition|)
name|node_body
operator|.
name|buffer
operator|-=
literal|3
expr_stmt|;
name|position
operator|=
name|find_node_separator
argument_list|(
operator|&
name|node_body
argument_list|)
expr_stmt|;
comment|/* If we found a node start, then check it out. */
if|if
condition|(
name|position
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|sep_len
decl_stmt|;
name|sep_len
operator|=
name|skip_node_separator
argument_list|(
name|node
operator|->
name|contents
argument_list|)
expr_stmt|;
comment|/* If we managed to skip a node separator, then check for this node          being the right one. */
if|if
condition|(
name|sep_len
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|nodedef
decl_stmt|,
modifier|*
name|nodestart
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|nodestart
operator|=
name|node_body
operator|.
name|buffer
operator|+
name|position
operator|+
name|sep_len
expr_stmt|;
name|nodedef
operator|=
name|nodestart
expr_stmt|;
name|offset
operator|=
name|string_in_line
argument_list|(
name|INFO_NODE_LABEL
argument_list|,
name|nodedef
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
operator|-
literal|1
condition|)
block|{
name|nodedef
operator|+=
name|offset
expr_stmt|;
name|nodedef
operator|+=
name|skip_whitespace
argument_list|(
name|nodedef
argument_list|)
expr_stmt|;
name|offset
operator|=
name|skip_node_characters
argument_list|(
name|nodedef
argument_list|,
name|DONT_SKIP_NEWLINES
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|==
name|strlen
argument_list|(
name|node
operator|->
name|nodename
argument_list|)
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|node
operator|->
name|nodename
argument_list|,
name|nodedef
argument_list|,
name|offset
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|node
operator|->
name|contents
operator|=
name|nodestart
expr_stmt|;
return|return
name|node_body
operator|.
name|buffer
operator|+
name|position
return|;
block|}
block|}
block|}
block|}
comment|/* Oh well, I guess we have to try to find it in a larger area. */
name|node_body
operator|.
name|buffer
operator|=
name|node
operator|->
name|contents
operator|-
name|min
expr_stmt|;
name|node_body
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|node_body
operator|.
name|end
operator|=
name|min
operator|+
name|max
expr_stmt|;
name|node_body
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|position
operator|=
name|find_node_in_binding
argument_list|(
name|node
operator|->
name|nodename
argument_list|,
operator|&
name|node_body
argument_list|)
expr_stmt|;
comment|/* If the node couldn't be found, we lose big. */
if|if
condition|(
name|position
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
comment|/* Otherwise, the node was found, but the tags table could need updating      (if we used a tag to get here, that is).  Set the flag in NODE->flags. */
name|node
operator|->
name|contents
operator|=
name|node_body
operator|.
name|buffer
operator|+
name|position
expr_stmt|;
name|node
operator|->
name|contents
operator|+=
name|skip_node_separator
argument_list|(
name|node
operator|->
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|flags
operator|&
name|N_HasTagsTable
condition|)
name|node
operator|->
name|flags
operator||=
name|N_UpdateTags
expr_stmt|;
return|return
name|node_body
operator|.
name|buffer
operator|+
name|position
return|;
block|}
end_function

end_unit

