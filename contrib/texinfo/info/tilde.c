begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tilde.c -- tilde expansion code (~/foo := $HOME/foo).    $Id: tilde.c,v 1.13 1999/03/03 22:42:21 karl Exp $     Copyright (C) 1988, 89, 90, 91, 92, 93, 96, 98, 99    Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Written by Brian Fox (bfox@ai.mit.edu). */
end_comment

begin_comment
comment|/* Include config.h before doing alloca.  */
end_comment

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TEST
argument_list|)
operator|||
name|defined
argument_list|(
name|STATIC_MALLOC
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|void
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST || STATIC_MALLOC */
end_comment

begin_comment
comment|/* The default value of tilde_additional_prefixes.  This is set to    whitespace preceding a tilde so that simple programs which do not    perform any word separation get desired behaviour. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|default_prefixes
index|[]
init|=
block|{
literal|" ~"
block|,
literal|"\t~"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The default value of tilde_additional_suffixes.  This is set to    whitespace or newline so that simple programs which do not    perform any word separation get desired behaviour. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|default_suffixes
index|[]
init|=
block|{
literal|" "
block|,
literal|"\n"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-null, this contains the address of a function to call if the    standard meaning for expanding a tilde fails.  The function is called    with the text (sans tilde, as in "foo"), and returns a malloc()'ed string    which is the expansion, or a NULL pointer if there is no expansion. */
end_comment

begin_decl_stmt
name|CFunction
modifier|*
name|tilde_expansion_failure_hook
init|=
operator|(
name|CFunction
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When non-null, this is a NULL terminated array of strings which    are duplicates for a tilde prefix.  Bash uses this to expand    `=~' and `:~'. */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|tilde_additional_prefixes
init|=
name|default_prefixes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When non-null, this is a NULL terminated array of strings which match    the end of a username, instead of just "/".  Bash sets this to    `:' and `=~'. */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|tilde_additional_suffixes
init|=
name|default_suffixes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Find the start of a tilde expansion in STRING, and return the index of    the tilde which starts the expansion.  Place the length of the text    which identified this tilde starter in LEN, excluding the tilde itself. */
end_comment

begin_function
specifier|static
name|int
name|tilde_find_prefix
parameter_list|(
name|string
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|string_len
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|prefixes
init|=
name|tilde_additional_prefixes
decl_stmt|;
name|string_len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
operator|*
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|string
operator|||
operator|*
name|string
operator|==
literal|'~'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|prefixes
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|string_len
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|prefixes
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|string
operator|+
name|i
argument_list|,
name|prefixes
index|[
name|j
index|]
argument_list|,
name|strlen
argument_list|(
name|prefixes
index|[
name|j
index|]
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|len
operator|=
name|strlen
argument_list|(
name|prefixes
index|[
name|j
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|i
operator|+
operator|*
name|len
operator|)
return|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|string_len
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find the end of a tilde expansion in STRING, and return the index of    the character which ends the tilde definition.  */
end_comment

begin_function
specifier|static
name|int
name|tilde_find_suffix
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|string_len
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|suffixes
init|=
name|tilde_additional_suffixes
decl_stmt|;
name|string_len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|string_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IS_SLASH
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
operator|||
operator|!
name|string
index|[
name|i
index|]
condition|)
break|break;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|suffixes
operator|&&
name|suffixes
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|string
operator|+
name|i
argument_list|,
name|suffixes
index|[
name|j
index|]
argument_list|,
name|strlen
argument_list|(
name|suffixes
index|[
name|j
index|]
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a new string which is the result of tilde expanding STRING. */
end_comment

begin_function
name|char
modifier|*
name|tilde_expand
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|result
decl_stmt|,
modifier|*
name|tilde_expand_word
argument_list|()
decl_stmt|;
name|int
name|result_size
decl_stmt|,
name|result_index
decl_stmt|;
name|result_size
operator|=
name|result_index
operator|=
literal|0
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Scan through STRING expanding tildes as we come to them. */
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|char
modifier|*
name|tilde_word
decl_stmt|,
modifier|*
name|expansion
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Make START point to the tilde which starts the expansion. */
name|start
operator|=
name|tilde_find_prefix
argument_list|(
name|string
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
comment|/* Copy the skipped text into the result. */
if|if
condition|(
operator|(
name|result_index
operator|+
name|start
operator|+
literal|1
operator|)
operator|>
name|result_size
condition|)
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
literal|1
operator|+
operator|(
name|result_size
operator|+=
operator|(
name|start
operator|+
literal|20
operator|)
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|result
operator|+
name|result_index
argument_list|,
name|string
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|result_index
operator|+=
name|start
expr_stmt|;
comment|/* Advance STRING to the starting tilde. */
name|string
operator|+=
name|start
expr_stmt|;
comment|/* Make END be the index of one after the last character of the          username. */
name|end
operator|=
name|tilde_find_suffix
argument_list|(
name|string
argument_list|)
expr_stmt|;
comment|/* If both START and END are zero, we are all done. */
if|if
condition|(
operator|!
name|start
operator|&&
operator|!
name|end
condition|)
break|break;
comment|/* Expand the entire tilde word, and copy it into RESULT. */
name|tilde_word
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|end
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|tilde_word
argument_list|,
name|string
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|tilde_word
index|[
name|end
index|]
operator|=
literal|'\0'
expr_stmt|;
name|string
operator|+=
name|end
expr_stmt|;
name|expansion
operator|=
name|tilde_expand_word
argument_list|(
name|tilde_word
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tilde_word
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|expansion
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result_index
operator|+
name|len
operator|+
literal|1
operator|)
operator|>
name|result_size
condition|)
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
literal|1
operator|+
operator|(
name|result_size
operator|+=
operator|(
name|len
operator|+
literal|20
operator|)
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|result_index
argument_list|,
name|expansion
argument_list|)
expr_stmt|;
name|result_index
operator|+=
name|len
expr_stmt|;
name|free
argument_list|(
name|expansion
argument_list|)
expr_stmt|;
block|}
name|result
index|[
name|result_index
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Do the work of tilde expansion on FILENAME.  FILENAME starts with a    tilde.  If there is no expansion, call tilde_expansion_failure_hook. */
end_comment

begin_function
name|char
modifier|*
name|tilde_expand_word
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|dirname
init|=
name|filename
condition|?
name|xstrdup
argument_list|(
name|filename
argument_list|)
else|:
name|NULL
decl_stmt|;
if|if
condition|(
name|dirname
operator|&&
operator|*
name|dirname
operator|==
literal|'~'
condition|)
block|{
name|char
modifier|*
name|temp_name
decl_stmt|;
if|if
condition|(
operator|!
name|dirname
index|[
literal|1
index|]
operator|||
name|IS_SLASH
argument_list|(
name|dirname
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* Prepend $HOME to the rest of the string. */
name|char
modifier|*
name|temp_home
init|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
decl_stmt|;
comment|/* If there is no HOME variable, look up the directory in              the password database. */
if|if
condition|(
operator|!
name|temp_home
condition|)
block|{
name|struct
name|passwd
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
name|temp_home
operator|=
name|entry
operator|->
name|pw_dir
expr_stmt|;
block|}
name|temp_name
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
operator|&
name|dirname
index|[
literal|1
index|]
argument_list|)
operator|+
operator|(
name|temp_home
condition|?
name|strlen
argument_list|(
name|temp_home
argument_list|)
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_home
condition|)
name|strcpy
argument_list|(
name|temp_name
argument_list|,
name|temp_home
argument_list|)
expr_stmt|;
else|else
name|temp_name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|temp_name
argument_list|,
operator|&
name|dirname
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|dirname
operator|=
name|xstrdup
argument_list|(
name|temp_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|passwd
modifier|*
name|user_entry
decl_stmt|;
name|char
modifier|*
name|username
init|=
name|xmalloc
argument_list|(
literal|257
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|(
name|c
operator|=
name|dirname
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IS_SLASH
argument_list|(
name|c
argument_list|)
condition|)
break|break;
else|else
name|username
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
block|}
name|username
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|user_entry
operator|=
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|getpwnam
argument_list|(
name|username
argument_list|)
operator|)
condition|)
block|{
comment|/* If the calling program has a special syntax for                  expanding tildes, and we couldn't find a standard                  expansion, then let them try. */
if|if
condition|(
name|tilde_expansion_failure_hook
condition|)
block|{
name|char
modifier|*
name|expansion
decl_stmt|;
name|expansion
operator|=
call|(
modifier|*
name|tilde_expansion_failure_hook
call|)
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|expansion
condition|)
block|{
name|temp_name
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|expansion
argument_list|)
operator|+
name|strlen
argument_list|(
operator|&
name|dirname
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp_name
argument_list|,
name|expansion
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp_name
argument_list|,
operator|&
name|dirname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expansion
argument_list|)
expr_stmt|;
goto|goto
name|return_name
goto|;
block|}
block|}
comment|/* We shouldn't report errors. */
block|}
else|else
block|{
name|temp_name
operator|=
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|user_entry
operator|->
name|pw_dir
argument_list|)
operator|+
name|strlen
argument_list|(
operator|&
name|dirname
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp_name
argument_list|,
name|user_entry
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp_name
argument_list|,
operator|&
name|dirname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|return_name
label|:
name|free
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|dirname
operator|=
name|xstrdup
argument_list|(
name|temp_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_name
argument_list|)
expr_stmt|;
block|}
name|endpwent
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|username
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|dirname
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TEST
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|result
decl_stmt|,
name|line
index|[
literal|512
index|]
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|printf
argument_list|(
literal|"~expand: "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gets
argument_list|(
name|line
argument_list|)
condition|)
name|strcpy
argument_list|(
name|line
argument_list|,
literal|"done"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"done"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"quit"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|line
argument_list|,
literal|"exit"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|result
operator|=
name|tilde_expand
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  --> %s\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|memory_error_and_abort
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
modifier|*
name|xmalloc
parameter_list|(
name|bytes
parameter_list|)
name|int
name|bytes
decl_stmt|;
block|{
name|void
modifier|*
name|temp
init|=
operator|(
name|void
operator|*
operator|)
name|malloc
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|memory_error_and_abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|xrealloc
parameter_list|(
name|pointer
parameter_list|,
name|bytes
parameter_list|)
name|void
modifier|*
name|pointer
decl_stmt|;
name|int
name|bytes
decl_stmt|;
block|{
name|void
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|pointer
condition|)
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|pointer
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|temp
condition|)
name|memory_error_and_abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|memory_error_and_abort
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"readline: Out of virtual memory!\n"
argument_list|)
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST */
end_comment

end_unit

