begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* filesys.c -- filesystem specific functions.    $Id: filesys.c,v 1.15 2002/03/23 20:45:24 karl Exp $     Copyright (C) 1993, 97, 98, 2000 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Written by Brian Fox (bfox@ai.mit.edu). */
end_comment

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_include
include|#
directive|include
file|"tilde.h"
end_include

begin_include
include|#
directive|include
file|"filesys.h"
end_include

begin_comment
comment|/* Local to this file. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|info_file_in_path
argument_list|()
decl_stmt|,
modifier|*
name|lookup_info_filename
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
name|info_absolute_file
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|remember_info_filename
argument_list|()
decl_stmt|,
name|maybe_initialize_infopath
argument_list|()
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|suffix
decl_stmt|;
name|char
modifier|*
name|decompressor
decl_stmt|;
block|}
name|COMPRESSION_ALIST
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|info_suffixes
index|[]
init|=
block|{
literal|".info"
block|,
literal|"-info"
block|,
literal|"/index"
block|,
literal|".inf"
block|,
comment|/* 8+3 file on filesystem which supports long file names */
ifdef|#
directive|ifdef
name|__MSDOS__
comment|/* 8+3 file names strike again...  */
literal|".in"
block|,
comment|/* for .inz, .igz etc. */
literal|".i"
block|,
endif|#
directive|endif
literal|""
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|COMPRESSION_ALIST
name|compress_suffixes
index|[]
init|=
block|{
block|{
literal|".gz"
block|,
literal|"gunzip"
block|}
block|,
block|{
literal|".bz2"
block|,
literal|"bunzip2"
block|}
block|,
block|{
literal|".z"
block|,
literal|"gunzip"
block|}
block|,
block|{
literal|".Z"
block|,
literal|"uncompress"
block|}
block|,
block|{
literal|".Y"
block|,
literal|"unyabba"
block|}
block|,
ifdef|#
directive|ifdef
name|__MSDOS__
block|{
literal|"gz"
block|,
literal|"gunzip"
block|}
block|,
block|{
literal|"z"
block|,
literal|"gunzip"
block|}
block|,
endif|#
directive|endif
block|{
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The path on which we look for info files.  You can initialize this    from the environment variable INFOPATH if there is one, or you can    call info_add_path () to add paths to the beginning or end of it.    You can call zap_infopath () to make the path go away. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|infopath
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|infopath_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Expand the filename in PARTIAL to make a real name for this operating    system.  This looks in INFO_PATHS in order to find the correct file.    If it can't find the file, it returns NULL. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|local_temp_filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|local_temp_filename_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|info_find_fullpath
parameter_list|(
name|partial
parameter_list|)
name|char
modifier|*
name|partial
decl_stmt|;
block|{
name|int
name|initial_character
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|filesys_error_number
operator|=
literal|0
expr_stmt|;
name|maybe_initialize_infopath
argument_list|()
expr_stmt|;
if|if
condition|(
name|partial
operator|&&
operator|(
name|initial_character
operator|=
operator|*
name|partial
operator|)
condition|)
block|{
name|char
modifier|*
name|expansion
decl_stmt|;
name|expansion
operator|=
name|lookup_info_filename
argument_list|(
name|partial
argument_list|)
expr_stmt|;
if|if
condition|(
name|expansion
condition|)
return|return
operator|(
name|expansion
operator|)
return|;
comment|/* If we have the full path to this file, we still may have to add          various extensions to it.  I guess we have to stat this file          after all. */
if|if
condition|(
name|IS_ABSOLUTE
argument_list|(
name|partial
argument_list|)
condition|)
name|temp
operator|=
name|info_absolute_file
argument_list|(
name|partial
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|initial_character
operator|==
literal|'~'
condition|)
block|{
name|expansion
operator|=
name|tilde_expand_word
argument_list|(
name|partial
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ABSOLUTE
argument_list|(
name|expansion
argument_list|)
condition|)
block|{
name|temp
operator|=
name|info_absolute_file
argument_list|(
name|expansion
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expansion
argument_list|)
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|expansion
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|initial_character
operator|==
literal|'.'
operator|&&
operator|(
name|IS_SLASH
argument_list|(
name|partial
index|[
literal|1
index|]
argument_list|)
operator|||
operator|(
name|partial
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|IS_SLASH
argument_list|(
name|partial
index|[
literal|2
index|]
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|local_temp_filename_size
operator|<
literal|1024
condition|)
name|local_temp_filename
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|local_temp_filename
argument_list|,
operator|(
name|local_temp_filename_size
operator|=
literal|1024
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GETCWD
argument_list|)
if|if
condition|(
operator|!
name|getcwd
argument_list|(
name|local_temp_filename
argument_list|,
name|local_temp_filename_size
argument_list|)
condition|)
else|#
directive|else
comment|/*  !HAVE_GETCWD */
if|if
condition|(
operator|!
name|getwd
argument_list|(
name|local_temp_filename
argument_list|)
condition|)
endif|#
directive|endif
comment|/* !HAVE_GETCWD */
block|{
name|filesys_error_number
operator|=
name|errno
expr_stmt|;
return|return
operator|(
name|partial
operator|)
return|;
block|}
name|strcat
argument_list|(
name|local_temp_filename
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|local_temp_filename
argument_list|,
name|partial
argument_list|)
expr_stmt|;
name|temp
operator|=
name|info_absolute_file
argument_list|(
name|local_temp_filename
argument_list|)
expr_stmt|;
comment|/* try extensions */
if|if
condition|(
operator|!
name|temp
condition|)
name|partial
operator|=
name|local_temp_filename
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|info_file_in_path
argument_list|(
name|partial
argument_list|,
name|infopath
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|remember_info_filename
argument_list|(
name|partial
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|temp
argument_list|)
operator|>
name|local_temp_filename_size
condition|)
name|local_temp_filename
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|local_temp_filename
argument_list|,
operator|(
name|local_temp_filename_size
operator|=
operator|(
literal|50
operator|+
name|strlen
argument_list|(
name|temp
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|local_temp_filename
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|local_temp_filename
operator|)
return|;
block|}
block|}
return|return
operator|(
name|partial
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Scan the list of directories in PATH looking for FILENAME.  If we find    one that is a regular file, return it as a new string.  Otherwise, return    a NULL pointer. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|info_file_in_path
parameter_list|(
name|filename
parameter_list|,
name|path
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|,
decl|*
name|path
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|stat
name|finfo
decl_stmt|;
name|char
modifier|*
name|temp_dirname
decl_stmt|;
name|int
name|statable
decl_stmt|,
name|dirname_index
decl_stmt|;
comment|/* Reject ridiculous cases up front, to prevent infinite recursion      later on.  E.g., someone might say "info '(.)foo'"...  */
if|if
condition|(
operator|!
operator|*
name|filename
operator|||
name|STREQ
argument_list|(
name|filename
argument_list|,
literal|"."
argument_list|)
operator|||
name|STREQ
argument_list|(
name|filename
argument_list|,
literal|".."
argument_list|)
condition|)
return|return
name|NULL
return|;
name|dirname_index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|temp_dirname
operator|=
name|extract_colon_unit
argument_list|(
name|path
argument_list|,
operator|&
name|dirname_index
argument_list|)
operator|)
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|pre_suffix_length
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
comment|/* Expand a leading tilde if one is present. */
if|if
condition|(
operator|*
name|temp_dirname
operator|==
literal|'~'
condition|)
block|{
name|char
modifier|*
name|expanded_dirname
decl_stmt|;
name|expanded_dirname
operator|=
name|tilde_expand_word
argument_list|(
name|temp_dirname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_dirname
argument_list|)
expr_stmt|;
name|temp_dirname
operator|=
name|expanded_dirname
expr_stmt|;
block|}
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|30
operator|+
name|strlen
argument_list|(
name|temp_dirname
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|temp_dirname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_SLASH
argument_list|(
name|temp
index|[
operator|(
name|strlen
argument_list|(
name|temp
argument_list|)
operator|)
operator|-
literal|1
index|]
argument_list|)
condition|)
name|strcat
argument_list|(
name|temp
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|pre_suffix_length
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_dirname
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|info_suffixes
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|strcpy
argument_list|(
name|temp
operator|+
name|pre_suffix_length
argument_list|,
name|info_suffixes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|statable
operator|=
operator|(
name|stat
argument_list|(
name|temp
argument_list|,
operator|&
name|finfo
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
comment|/* If we have found a regular file, then use that.  Else, if we              have found a directory, look in that directory for this file. */
if|if
condition|(
name|statable
condition|)
block|{
if|if
condition|(
name|S_ISREG
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
block|{
return|return
operator|(
name|temp
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|S_ISDIR
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|char
modifier|*
name|newpath
decl_stmt|,
modifier|*
name|filename_only
decl_stmt|,
modifier|*
name|newtemp
decl_stmt|;
name|newpath
operator|=
name|xstrdup
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|filename_only
operator|=
name|filename_non_directory
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|newtemp
operator|=
name|info_file_in_path
argument_list|(
name|filename_only
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|newtemp
condition|)
block|{
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|newtemp
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* Add various compression suffixes to the name to see if                  the file is present in compressed format. */
specifier|register
name|int
name|j
decl_stmt|,
name|pre_compress_suffix_length
decl_stmt|;
name|pre_compress_suffix_length
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|compress_suffixes
index|[
name|j
index|]
operator|.
name|suffix
condition|;
name|j
operator|++
control|)
block|{
name|strcpy
argument_list|(
name|temp
operator|+
name|pre_compress_suffix_length
argument_list|,
name|compress_suffixes
index|[
name|j
index|]
operator|.
name|suffix
argument_list|)
expr_stmt|;
name|statable
operator|=
operator|(
name|stat
argument_list|(
name|temp
argument_list|,
operator|&
name|finfo
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|statable
operator|&&
operator|(
name|S_ISREG
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
return|return
operator|(
name|temp
operator|)
return|;
block|}
block|}
block|}
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Assume FNAME is an absolute file name, and check whether it is    a regular file.  If it is, return it as a new string; otherwise    return a NULL pointer.  We do it by taking the file name apart    into its directory and basename parts, and calling info_file_in_path.*/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|info_absolute_file
parameter_list|(
name|fname
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|char
modifier|*
name|containing_dir
init|=
name|xstrdup
argument_list|(
name|fname
argument_list|)
decl_stmt|;
name|char
modifier|*
name|base
init|=
name|filename_non_directory
argument_list|(
name|containing_dir
argument_list|)
decl_stmt|;
if|if
condition|(
name|base
operator|>
name|containing_dir
condition|)
name|base
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|info_file_in_path
argument_list|(
name|filename_non_directory
argument_list|(
name|fname
argument_list|)
argument_list|,
name|containing_dir
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a string containing units of information separated by    the PATH_SEP character, return the next one pointed to by    IDX, or NULL if there are no more.    Advance IDX to the character after the colon. */
end_comment

begin_function
name|char
modifier|*
name|extract_colon_unit
parameter_list|(
name|string
parameter_list|,
name|idx
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|idx
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|start
decl_stmt|;
name|i
operator|=
name|start
operator|=
operator|*
name|idx
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|>=
name|strlen
argument_list|(
name|string
argument_list|)
operator|)
operator|||
operator|!
name|string
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
while|while
condition|(
name|string
index|[
name|i
index|]
operator|&&
name|string
index|[
name|i
index|]
operator|!=
name|PATH_SEP
index|[
literal|0
index|]
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|start
condition|)
block|{
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|char
modifier|*
name|value
decl_stmt|;
name|value
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
operator|(
name|i
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|value
argument_list|,
operator|&
name|string
index|[
name|start
index|]
argument_list|,
operator|(
name|i
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
name|value
index|[
name|i
operator|-
name|start
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|string
index|[
name|i
index|]
condition|)
operator|++
name|i
expr_stmt|;
operator|*
name|idx
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* A structure which associates a filename with its expansion. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|expansion
decl_stmt|;
block|}
name|FILENAME_LIST
typedef|;
end_typedef

begin_comment
comment|/* An array of remembered arguments and results. */
end_comment

begin_decl_stmt
specifier|static
name|FILENAME_LIST
modifier|*
modifier|*
name|names_and_files
init|=
operator|(
name|FILENAME_LIST
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|names_and_files_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|names_and_files_slots
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Find the result for having already called info_find_fullpath () with    FILENAME. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|lookup_info_filename
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
if|if
condition|(
name|filename
operator|&&
name|names_and_files
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|names_and_files
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|FILENAME_CMP
argument_list|(
name|names_and_files
index|[
name|i
index|]
operator|->
name|filename
argument_list|,
name|filename
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|names_and_files
index|[
name|i
index|]
operator|->
name|expansion
operator|)
return|;
block|}
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Add a filename and its expansion to our list. */
end_comment

begin_function
specifier|static
name|void
name|remember_info_filename
parameter_list|(
name|filename
parameter_list|,
name|expansion
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|,
decl|*
name|expansion
decl_stmt|;
end_function

begin_block
block|{
name|FILENAME_LIST
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|names_and_files_index
operator|+
literal|2
operator|>
name|names_and_files_slots
condition|)
block|{
name|int
name|alloc_size
decl_stmt|;
name|names_and_files_slots
operator|+=
literal|10
expr_stmt|;
name|alloc_size
operator|=
name|names_and_files_slots
operator|*
sizeof|sizeof
argument_list|(
name|FILENAME_LIST
operator|*
argument_list|)
expr_stmt|;
name|names_and_files
operator|=
operator|(
name|FILENAME_LIST
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|names_and_files
argument_list|,
name|alloc_size
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
operator|(
name|FILENAME_LIST
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FILENAME_LIST
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|filename
operator|=
name|xstrdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|new
operator|->
name|expansion
operator|=
name|expansion
condition|?
name|xstrdup
argument_list|(
name|expansion
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|names_and_files
index|[
name|names_and_files_index
operator|++
index|]
operator|=
name|new
expr_stmt|;
name|names_and_files
index|[
name|names_and_files_index
index|]
operator|=
operator|(
name|FILENAME_LIST
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|maybe_initialize_infopath
parameter_list|()
block|{
if|if
condition|(
operator|!
name|infopath_size
condition|)
block|{
name|infopath
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|infopath_size
operator|=
operator|(
literal|1
operator|+
name|strlen
argument_list|(
name|DEFAULT_INFOPATH
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|infopath
argument_list|,
name|DEFAULT_INFOPATH
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add PATH to the list of paths found in INFOPATH.  2nd argument says    whether to put PATH at the front or end of INFOPATH. */
end_comment

begin_function
name|void
name|info_add_path
parameter_list|(
name|path
parameter_list|,
name|where
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|where
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|infopath
condition|)
block|{
name|infopath
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|infopath_size
operator|=
literal|200
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|infopath
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
name|strlen
argument_list|(
name|infopath
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
literal|2
operator|>=
name|infopath_size
condition|)
name|infopath
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|infopath
argument_list|,
operator|(
name|infopath_size
operator|+=
operator|(
literal|2
operator|*
name|len
operator|)
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|infopath
condition|)
name|strcpy
argument_list|(
name|infopath
argument_list|,
name|path
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|where
operator|==
name|INFOPATH_APPEND
condition|)
block|{
name|strcat
argument_list|(
name|infopath
argument_list|,
name|PATH_SEP
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|infopath
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|where
operator|==
name|INFOPATH_PREPEND
condition|)
block|{
name|char
modifier|*
name|temp
init|=
name|xstrdup
argument_list|(
name|infopath
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|infopath
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|infopath
argument_list|,
name|PATH_SEP
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|infopath
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make INFOPATH have absolutely nothing in it. */
end_comment

begin_function
name|void
name|zap_infopath
parameter_list|()
block|{
if|if
condition|(
name|infopath
condition|)
name|free
argument_list|(
name|infopath
argument_list|)
expr_stmt|;
name|infopath
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|infopath_size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a chunk of text and its length, convert all CRLF pairs at every    end-of-line into a single Newline character.  Return the length of    produced text.     This is required because the rest of code is too entrenched in having    a single newline at each EOL; in particular, searching for various    Info headers and cookies can become extremely tricky if that assumption    breaks.     FIXME: this could also support Mac-style text files with a single CR    at the EOL, but what about random CR characters in non-Mac files?  Can    we afford converting them into newlines as well?  Maybe implement some    heuristics here, like in Emacs 20.     FIXME: is it a good idea to show the EOL type on the modeline?  */
end_comment

begin_function
name|long
name|convert_eols
parameter_list|(
name|text
parameter_list|,
name|textlen
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|long
name|textlen
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|text
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
init|=
name|text
decl_stmt|;
while|while
condition|(
name|textlen
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\r'
operator|&&
name|textlen
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|textlen
operator|--
expr_stmt|;
block|}
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
return|return
call|(
name|long
call|)
argument_list|(
name|d
operator|-
name|text
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read the contents of PATHNAME, returning a buffer with the contents of    that file in it, and returning the size of that buffer in FILESIZE.    FINFO is a stat struct which has already been filled in by the caller.    If the file turns out to be compressed, set IS_COMPRESSED to non-zero.    If the file cannot be read, return a NULL pointer. */
end_comment

begin_function
name|char
modifier|*
name|filesys_read_info_file
parameter_list|(
name|pathname
parameter_list|,
name|filesize
parameter_list|,
name|finfo
parameter_list|,
name|is_compressed
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
name|long
modifier|*
name|filesize
decl_stmt|;
name|struct
name|stat
modifier|*
name|finfo
decl_stmt|;
name|int
modifier|*
name|is_compressed
decl_stmt|;
block|{
name|long
name|st_size
decl_stmt|;
operator|*
name|filesize
operator|=
name|filesys_error_number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|compressed_filename_p
argument_list|(
name|pathname
argument_list|)
condition|)
block|{
operator|*
name|is_compressed
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|filesys_read_compressed
argument_list|(
name|pathname
argument_list|,
name|filesize
argument_list|,
name|finfo
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|int
name|descriptor
decl_stmt|;
name|char
modifier|*
name|contents
decl_stmt|;
operator|*
name|is_compressed
operator|=
literal|0
expr_stmt|;
name|descriptor
operator|=
name|open
argument_list|(
name|pathname
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
comment|/* If the file couldn't be opened, give up. */
if|if
condition|(
name|descriptor
operator|<
literal|0
condition|)
block|{
name|filesys_error_number
operator|=
name|errno
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
comment|/* Try to read the contents of this file. */
name|st_size
operator|=
operator|(
name|long
operator|)
name|finfo
operator|->
name|st_size
expr_stmt|;
name|contents
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|read
argument_list|(
name|descriptor
argument_list|,
name|contents
argument_list|,
name|st_size
argument_list|)
operator|)
operator|!=
name|st_size
condition|)
block|{
name|filesys_error_number
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|descriptor
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|close
argument_list|(
name|descriptor
argument_list|)
expr_stmt|;
comment|/* Convert any DOS-style CRLF EOLs into Unix-style NL. 	 Seems like a good idea to have even on Unix, in case the Info 	 files are coming from some Windows system across a network.  */
operator|*
name|filesize
operator|=
name|convert_eols
argument_list|(
name|contents
argument_list|,
name|st_size
argument_list|)
expr_stmt|;
comment|/* EOL conversion can shrink the text quite a bit.  We don't 	 want to waste storage.  */
if|if
condition|(
operator|*
name|filesize
operator|<
name|st_size
condition|)
name|contents
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|contents
argument_list|,
literal|1
operator|+
operator|*
name|filesize
argument_list|)
expr_stmt|;
name|contents
index|[
operator|*
name|filesize
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|contents
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Typically, pipe buffers are 4k. */
end_comment

begin_define
define|#
directive|define
name|BASIC_PIPE_BUFFER
value|(4 * 1024)
end_define

begin_comment
comment|/* We use some large multiple of that. */
end_comment

begin_define
define|#
directive|define
name|FILESYS_PIPE_BUFFER_SIZE
value|(16 * BASIC_PIPE_BUFFER)
end_define

begin_function
name|char
modifier|*
name|filesys_read_compressed
parameter_list|(
name|pathname
parameter_list|,
name|filesize
parameter_list|,
name|finfo
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
name|long
modifier|*
name|filesize
decl_stmt|;
name|struct
name|stat
modifier|*
name|finfo
decl_stmt|;
block|{
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|command
decl_stmt|,
modifier|*
name|decompressor
decl_stmt|;
name|char
modifier|*
name|contents
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
operator|*
name|filesize
operator|=
name|filesys_error_number
operator|=
literal|0
expr_stmt|;
name|decompressor
operator|=
name|filesys_decompressor_for_file
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decompressor
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
name|command
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|15
operator|+
name|strlen
argument_list|(
name|pathname
argument_list|)
operator|+
name|strlen
argument_list|(
name|decompressor
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Explicit .exe suffix makes the diagnostics of `popen'      better on systems where COMMAND.COM is the stock shell.  */
name|sprintf
argument_list|(
name|command
argument_list|,
literal|"%s%s< %s"
argument_list|,
name|decompressor
argument_list|,
name|STRIP_DOT_EXE
condition|?
literal|".exe"
else|:
literal|""
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BUILDING_LIBRARY
argument_list|)
if|if
condition|(
name|info_windows_initialized_p
condition|)
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|5
operator|+
name|strlen
argument_list|(
name|command
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s..."
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|message_in_echo_area
argument_list|(
literal|"%s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !BUILDING_LIBRARY */
name|stream
operator|=
name|popen
argument_list|(
name|command
argument_list|,
name|FOPEN_RBIN
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|command
argument_list|)
expr_stmt|;
comment|/* Read chunks from this file until there are none left to read. */
if|if
condition|(
name|stream
condition|)
block|{
name|long
name|offset
decl_stmt|,
name|size
decl_stmt|;
name|char
modifier|*
name|chunk
decl_stmt|;
name|offset
operator|=
name|size
operator|=
literal|0
expr_stmt|;
name|chunk
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|FILESYS_PIPE_BUFFER_SIZE
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|bytes_read
decl_stmt|;
name|bytes_read
operator|=
name|fread
argument_list|(
name|chunk
argument_list|,
literal|1
argument_list|,
name|FILESYS_PIPE_BUFFER_SIZE
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|+
name|offset
operator|>=
name|size
condition|)
name|contents
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|contents
argument_list|,
name|size
operator|+=
operator|(
literal|2
operator|*
name|FILESYS_PIPE_BUFFER_SIZE
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|contents
operator|+
name|offset
argument_list|,
name|chunk
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|!=
name|FILESYS_PIPE_BUFFER_SIZE
condition|)
break|break;
block|}
name|free
argument_list|(
name|chunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|pclose
argument_list|(
name|stream
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|contents
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
name|contents
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|filesys_error_number
operator|=
name|errno
expr_stmt|;
block|}
else|else
block|{
operator|*
name|filesize
operator|=
name|convert_eols
argument_list|(
name|contents
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|contents
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|contents
argument_list|,
literal|1
operator|+
operator|*
name|filesize
argument_list|)
expr_stmt|;
name|contents
index|[
operator|*
name|filesize
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
else|else
block|{
name|filesys_error_number
operator|=
name|errno
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BUILDING_LIBARARY
argument_list|)
if|if
condition|(
name|info_windows_initialized_p
condition|)
name|unmessage_in_echo_area
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* !BUILDING_LIBRARY */
return|return
operator|(
name|contents
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if FILENAME belongs to a compressed file. */
end_comment

begin_function
name|int
name|compressed_filename_p
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|decompressor
decl_stmt|;
comment|/* Find the final extension of this filename, and see if it matches one      of our known ones. */
name|decompressor
operator|=
name|filesys_decompressor_for_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|decompressor
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the command string that would be used to decompress FILENAME. */
end_comment

begin_function
name|char
modifier|*
name|filesys_decompressor_for_file
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|extension
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* Find the final extension of FILENAME, and see if it appears in our      list of known compression extensions. */
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|filename
index|[
name|i
index|]
operator|==
literal|'.'
condition|)
block|{
name|extension
operator|=
name|filename
operator|+
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|extension
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|compress_suffixes
index|[
name|i
index|]
operator|.
name|suffix
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|FILENAME_CMP
argument_list|(
name|extension
argument_list|,
name|compress_suffixes
index|[
name|i
index|]
operator|.
name|suffix
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|compress_suffixes
index|[
name|i
index|]
operator|.
name|decompressor
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
comment|/* If no other suffix matched, allow any extension which ends      with `z' to be decompressed by gunzip.  Due to limited 8+3 DOS      file namespace, we can expect many such cases, and supporting      every weird suffix thus produced would be a pain.  */
if|if
condition|(
name|extension
index|[
name|strlen
argument_list|(
name|extension
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'z'
operator|||
name|extension
index|[
name|strlen
argument_list|(
name|extension
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'Z'
condition|)
return|return
literal|"gunzip"
return|;
endif|#
directive|endif
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The number of the most recent file system error. */
end_comment

begin_decl_stmt
name|int
name|filesys_error_number
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A function which returns a pointer to a static buffer containing    an error message for FILENAME and ERROR_NUM. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|errmsg_buf
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|errmsg_buf_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|filesys_error_string
parameter_list|(
name|filename
parameter_list|,
name|error_num
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|error_num
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|error_num
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
name|result
operator|=
name|strerror
argument_list|(
name|error_num
argument_list|)
expr_stmt|;
name|len
operator|=
literal|4
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
name|strlen
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|errmsg_buf_size
condition|)
name|errmsg_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|errmsg_buf
argument_list|,
operator|(
name|errmsg_buf_size
operator|=
literal|2
operator|+
name|len
operator|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|errmsg_buf
argument_list|,
literal|"%s: %s"
argument_list|,
name|filename
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|errmsg_buf
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check for "dir" with all the possible info and compression suffixes,    in combination.  */
end_comment

begin_function
name|int
name|is_dir_name
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|info_suffixes
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|c
decl_stmt|;
name|char
name|trydir
index|[
literal|50
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|trydir
argument_list|,
literal|"dir"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|trydir
argument_list|,
name|info_suffixes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|filename
argument_list|,
name|trydir
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|compress_suffixes
index|[
name|c
index|]
operator|.
name|suffix
condition|;
name|c
operator|++
control|)
block|{
name|char
name|dir_compressed
index|[
literal|50
index|]
decl_stmt|;
comment|/* can be short */
name|strcpy
argument_list|(
name|dir_compressed
argument_list|,
name|trydir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dir_compressed
argument_list|,
name|compress_suffixes
index|[
name|c
index|]
operator|.
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|filename
argument_list|,
name|dir_compressed
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

