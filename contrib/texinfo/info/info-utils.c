begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* info-utils.c -- miscellanous.    $Id: info-utils.c,v 1.7 1998/08/10 18:07:47 karl Exp $     Copyright (C) 1993, 98 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Written by Brian Fox (bfox@ai.mit.edu). */
end_comment

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_include
include|#
directive|include
file|"info-utils.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MAN_PAGES
argument_list|)
end_if

begin_include
include|#
directive|include
file|"man.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HANDLE_MAN_PAGES */
end_comment

begin_comment
comment|/* When non-zero, various display and input functions handle ISO Latin    character sets correctly. */
end_comment

begin_decl_stmt
name|int
name|ISO_Latin_p
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variable which holds the most recent filename parsed as a result of    calling info_parse_xxx (). */
end_comment

begin_decl_stmt
name|char
modifier|*
name|info_parsed_filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variable which holds the most recent nodename parsed as a result of    calling info_parse_xxx (). */
end_comment

begin_decl_stmt
name|char
modifier|*
name|info_parsed_nodename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions to remember a filename or nodename for later return. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|save_filename
argument_list|()
decl_stmt|,
name|saven_filename
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|save_nodename
argument_list|()
decl_stmt|,
name|saven_nodename
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to get a reference (either menu or cross). */
end_comment

begin_function_decl
specifier|static
name|REFERENCE
modifier|*
modifier|*
name|info_references_internal
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Parse the filename and nodename out of STRING.  If STRING doesn't    contain a filename (i.e., it is NOT (FILENAME)NODENAME) then set    INFO_PARSED_FILENAME to NULL.  If second argument NEWLINES_OKAY is    non-zero, it says to allow the nodename specification to cross a    newline boundary (i.e., only `,', `.', or `TAB' can end the spec). */
end_comment

begin_function
name|void
name|info_parse_node
parameter_list|(
name|string
parameter_list|,
name|newlines_okay
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|newlines_okay
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Default the answer. */
name|save_filename
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|save_nodename
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* Special case of nothing passed.  Return nothing. */
if|if
condition|(
operator|!
name|string
operator|||
operator|!
operator|*
name|string
condition|)
return|return;
name|string
operator|+=
name|skip_whitespace
argument_list|(
name|string
argument_list|)
expr_stmt|;
comment|/* Check for (FILENAME)NODENAME. */
if|if
condition|(
operator|*
name|string
operator|==
literal|'('
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Advance past the opening paren. */
name|string
operator|++
expr_stmt|;
comment|/* Find the closing paren. */
while|while
condition|(
name|string
index|[
name|i
index|]
operator|&&
name|string
index|[
name|i
index|]
operator|!=
literal|')'
condition|)
name|i
operator|++
expr_stmt|;
comment|/* Remember parsed filename. */
name|saven_filename
argument_list|(
name|string
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Point directly at the nodename. */
name|string
operator|+=
name|i
expr_stmt|;
if|if
condition|(
operator|*
name|string
condition|)
name|string
operator|++
expr_stmt|;
block|}
comment|/* Parse out nodename. */
name|i
operator|=
name|skip_node_characters
argument_list|(
name|string
argument_list|,
name|newlines_okay
argument_list|)
expr_stmt|;
name|saven_nodename
argument_list|(
name|string
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|canonicalize_whitespace
argument_list|(
name|info_parsed_nodename
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_parsed_nodename
operator|&&
operator|!
operator|*
name|info_parsed_nodename
condition|)
block|{
name|free
argument_list|(
name|info_parsed_nodename
argument_list|)
expr_stmt|;
name|info_parsed_nodename
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the node addressed by LABEL in NODE (usually one of "Prev:",    "Next:", "Up:", "File:", or "Node:".  After a call to this function,    the global INFO_PARSED_NODENAME and INFO_PARSED_FILENAME contain    the information. */
end_comment

begin_function
name|void
name|info_parse_label
parameter_list|(
name|label
parameter_list|,
name|node
parameter_list|)
name|char
modifier|*
name|label
decl_stmt|;
name|NODE
modifier|*
name|node
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|nodeline
decl_stmt|;
comment|/* Default answer to failure. */
name|save_nodename
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|save_filename
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* Find the label in the first line of this node. */
name|nodeline
operator|=
name|node
operator|->
name|contents
expr_stmt|;
name|i
operator|=
name|string_in_line
argument_list|(
name|label
argument_list|,
name|nodeline
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
return|return;
name|nodeline
operator|+=
name|i
expr_stmt|;
name|nodeline
operator|+=
name|skip_whitespace
argument_list|(
name|nodeline
argument_list|)
expr_stmt|;
name|info_parse_node
argument_list|(
name|nodeline
argument_list|,
name|DONT_SKIP_NEWLINES
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/*                  Finding and Building Menus                      */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Return a NULL terminated array of REFERENCE * which represents the menu    found in NODE.  If there is no menu in NODE, just return a NULL pointer. */
end_comment

begin_function
name|REFERENCE
modifier|*
modifier|*
name|info_menu_of_node
parameter_list|(
name|node
parameter_list|)
name|NODE
modifier|*
name|node
decl_stmt|;
block|{
name|long
name|position
decl_stmt|;
name|SEARCH_BINDING
name|search
decl_stmt|;
name|REFERENCE
modifier|*
modifier|*
name|menu
init|=
operator|(
name|REFERENCE
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|search
operator|.
name|buffer
operator|=
name|node
operator|->
name|contents
expr_stmt|;
name|search
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|search
operator|.
name|end
operator|=
name|node
operator|->
name|nodelen
expr_stmt|;
name|search
operator|.
name|flags
operator|=
name|S_FoldCase
expr_stmt|;
comment|/* Find the start of the menu. */
name|position
operator|=
name|search_forward
argument_list|(
name|INFO_MENU_LABEL
argument_list|,
operator|&
name|search
argument_list|)
expr_stmt|;
if|if
condition|(
name|position
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|(
name|REFERENCE
operator|*
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* We have the start of the menu now.  Glean menu items from the rest      of the node. */
name|search
operator|.
name|start
operator|=
name|position
operator|+
name|strlen
argument_list|(
name|INFO_MENU_LABEL
argument_list|)
expr_stmt|;
name|search
operator|.
name|start
operator|+=
name|skip_line
argument_list|(
name|search
operator|.
name|buffer
operator|+
name|search
operator|.
name|start
argument_list|)
expr_stmt|;
name|search
operator|.
name|start
operator|--
expr_stmt|;
name|menu
operator|=
name|info_menu_items
argument_list|(
operator|&
name|search
argument_list|)
expr_stmt|;
return|return
operator|(
name|menu
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a NULL terminated array of REFERENCE * which represents the cross    refrences found in NODE.  If there are no cross references in NODE, just    return a NULL pointer. */
end_comment

begin_function
name|REFERENCE
modifier|*
modifier|*
name|info_xrefs_of_node
parameter_list|(
name|node
parameter_list|)
name|NODE
modifier|*
name|node
decl_stmt|;
block|{
name|SEARCH_BINDING
name|search
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HANDLE_MAN_PAGES
argument_list|)
if|if
condition|(
name|node
operator|->
name|flags
operator|&
name|N_IsManPage
condition|)
return|return
operator|(
name|xrefs_of_manpage
argument_list|(
name|node
argument_list|)
operator|)
return|;
endif|#
directive|endif
name|search
operator|.
name|buffer
operator|=
name|node
operator|->
name|contents
expr_stmt|;
name|search
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|search
operator|.
name|end
operator|=
name|node
operator|->
name|nodelen
expr_stmt|;
name|search
operator|.
name|flags
operator|=
name|S_FoldCase
expr_stmt|;
return|return
operator|(
name|info_xrefs
argument_list|(
operator|&
name|search
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Glean menu entries from BINDING->buffer + BINDING->start until we    have looked at the entire contents of BINDING.  Return an array    of REFERENCE * that represents each menu item in this range. */
end_comment

begin_function
name|REFERENCE
modifier|*
modifier|*
name|info_menu_items
parameter_list|(
name|binding
parameter_list|)
name|SEARCH_BINDING
modifier|*
name|binding
decl_stmt|;
block|{
return|return
operator|(
name|info_references_internal
argument_list|(
name|INFO_MENU_ENTRY_LABEL
argument_list|,
name|binding
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Glean cross references from BINDING->buffer + BINDING->start until    BINDING->end.  Return an array of REFERENCE * that represents each    cross reference in this range. */
end_comment

begin_function
name|REFERENCE
modifier|*
modifier|*
name|info_xrefs
parameter_list|(
name|binding
parameter_list|)
name|SEARCH_BINDING
modifier|*
name|binding
decl_stmt|;
block|{
return|return
operator|(
name|info_references_internal
argument_list|(
name|INFO_XREF_LABEL
argument_list|,
name|binding
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Glean cross references or menu items from BINDING.  Return an array    of REFERENCE * that represents the items found. */
end_comment

begin_function
specifier|static
name|REFERENCE
modifier|*
modifier|*
name|info_references_internal
parameter_list|(
name|label
parameter_list|,
name|binding
parameter_list|)
name|char
modifier|*
name|label
decl_stmt|;
name|SEARCH_BINDING
modifier|*
name|binding
decl_stmt|;
block|{
name|SEARCH_BINDING
name|search
decl_stmt|;
name|REFERENCE
modifier|*
modifier|*
name|refs
init|=
operator|(
name|REFERENCE
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|refs_index
init|=
literal|0
decl_stmt|,
name|refs_slots
init|=
literal|0
decl_stmt|;
name|int
name|searching_for_menu_items
init|=
literal|0
decl_stmt|;
name|long
name|position
decl_stmt|;
name|search
operator|.
name|buffer
operator|=
name|binding
operator|->
name|buffer
expr_stmt|;
name|search
operator|.
name|start
operator|=
name|binding
operator|->
name|start
expr_stmt|;
name|search
operator|.
name|end
operator|=
name|binding
operator|->
name|end
expr_stmt|;
name|search
operator|.
name|flags
operator|=
name|S_FoldCase
operator||
name|S_SkipDest
expr_stmt|;
name|searching_for_menu_items
operator|=
operator|(
name|strcasecmp
argument_list|(
name|label
argument_list|,
name|INFO_MENU_ENTRY_LABEL
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|position
operator|=
name|search_forward
argument_list|(
name|label
argument_list|,
operator|&
name|search
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|offset
decl_stmt|,
name|start
decl_stmt|;
name|char
modifier|*
name|refdef
decl_stmt|;
name|REFERENCE
modifier|*
name|entry
decl_stmt|;
name|search
operator|.
name|start
operator|=
name|position
expr_stmt|;
name|search
operator|.
name|start
operator|+=
name|skip_whitespace
argument_list|(
name|search
operator|.
name|buffer
operator|+
name|search
operator|.
name|start
argument_list|)
expr_stmt|;
name|start
operator|=
name|search
operator|.
name|start
operator|-
name|binding
operator|->
name|start
expr_stmt|;
name|refdef
operator|=
name|search
operator|.
name|buffer
operator|+
name|search
operator|.
name|start
expr_stmt|;
name|offset
operator|=
name|string_in_line
argument_list|(
literal|":"
argument_list|,
name|refdef
argument_list|)
expr_stmt|;
comment|/* When searching for menu items, if no colon, there is no          menu item on this line. */
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|searching_for_menu_items
condition|)
continue|continue;
else|else
block|{
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|skip_line
argument_list|(
name|refdef
argument_list|)
expr_stmt|;
name|offset
operator|=
name|string_in_line
argument_list|(
literal|":"
argument_list|,
name|refdef
operator|+
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|/* Give up? */
else|else
name|offset
operator|+=
name|temp
expr_stmt|;
block|}
block|}
name|entry
operator|=
operator|(
name|REFERENCE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|REFERENCE
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|entry
operator|->
name|nodename
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|entry
operator|->
name|label
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|entry
operator|->
name|label
argument_list|,
name|refdef
argument_list|,
name|offset
operator|-
literal|1
argument_list|)
expr_stmt|;
name|entry
operator|->
name|label
index|[
name|offset
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|canonicalize_whitespace
argument_list|(
name|entry
operator|->
name|label
argument_list|)
expr_stmt|;
name|refdef
operator|+=
name|offset
expr_stmt|;
name|entry
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|entry
operator|->
name|end
operator|=
name|refdef
operator|-
name|binding
operator|->
name|buffer
expr_stmt|;
comment|/* If this reference entry continues with another ':' then the          nodename is the same as the label. */
if|if
condition|(
operator|*
name|refdef
operator|==
literal|':'
condition|)
block|{
name|entry
operator|->
name|nodename
operator|=
name|xstrdup
argument_list|(
name|entry
operator|->
name|label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This entry continues with a specific nodename.  Parse the              nodename from the specification. */
name|refdef
operator|+=
name|skip_whitespace_and_newlines
argument_list|(
name|refdef
argument_list|)
expr_stmt|;
if|if
condition|(
name|searching_for_menu_items
condition|)
name|info_parse_node
argument_list|(
name|refdef
argument_list|,
name|DONT_SKIP_NEWLINES
argument_list|)
expr_stmt|;
else|else
name|info_parse_node
argument_list|(
name|refdef
argument_list|,
name|SKIP_NEWLINES
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_parsed_filename
condition|)
name|entry
operator|->
name|filename
operator|=
name|xstrdup
argument_list|(
name|info_parsed_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_parsed_nodename
condition|)
name|entry
operator|->
name|nodename
operator|=
name|xstrdup
argument_list|(
name|info_parsed_nodename
argument_list|)
expr_stmt|;
block|}
name|add_pointer_to_array
argument_list|(
name|entry
argument_list|,
name|refs_index
argument_list|,
name|refs
argument_list|,
name|refs_slots
argument_list|,
literal|50
argument_list|,
name|REFERENCE
operator|*
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|refs
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get the entry associated with LABEL in REFERENCES.  Return a pointer    to the ENTRY if found, or NULL. */
end_comment

begin_function
name|REFERENCE
modifier|*
name|info_get_labeled_reference
parameter_list|(
name|label
parameter_list|,
name|references
parameter_list|)
name|char
modifier|*
name|label
decl_stmt|;
name|REFERENCE
modifier|*
modifier|*
name|references
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|REFERENCE
modifier|*
name|entry
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|references
operator|&&
operator|(
name|entry
operator|=
name|references
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|label
argument_list|,
name|entry
operator|->
name|label
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|entry
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|REFERENCE
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A utility function for concatenating REFERENCE **.  Returns a new    REFERENCE ** which is the concatenation of REF1 and REF2.  The REF1    and REF2 arrays are freed, but their contents are not. */
end_comment

begin_function
name|REFERENCE
modifier|*
modifier|*
name|info_concatenate_references
parameter_list|(
name|ref1
parameter_list|,
name|ref2
parameter_list|)
name|REFERENCE
modifier|*
modifier|*
name|ref1
decl_stmt|,
decl|*
modifier|*
name|ref2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|REFERENCE
modifier|*
modifier|*
name|result
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* With one argument passed as NULL, simply return the other arg. */
if|if
condition|(
operator|!
name|ref1
condition|)
return|return
operator|(
name|ref2
operator|)
return|;
elseif|else
if|if
condition|(
operator|!
name|ref2
condition|)
return|return
operator|(
name|ref1
operator|)
return|;
comment|/* Get the total size of the slots that we will need. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ref1
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|size
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ref2
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|size
operator|+=
name|i
expr_stmt|;
name|result
operator|=
operator|(
name|REFERENCE
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
name|size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|REFERENCE
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the contents over. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ref1
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|result
index|[
name|i
index|]
operator|=
name|ref1
index|[
name|i
index|]
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ref2
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|result
index|[
name|j
operator|++
index|]
operator|=
name|ref2
index|[
name|i
index|]
expr_stmt|;
name|result
index|[
name|j
index|]
operator|=
operator|(
name|REFERENCE
operator|*
operator|)
name|NULL
expr_stmt|;
name|free
argument_list|(
name|ref1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ref2
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Free the data associated with REFERENCES. */
end_comment

begin_function
name|void
name|info_free_references
parameter_list|(
name|references
parameter_list|)
name|REFERENCE
modifier|*
modifier|*
name|references
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|REFERENCE
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
name|references
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|references
operator|&&
operator|(
name|entry
operator|=
name|references
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|maybe_free
argument_list|(
name|entry
operator|->
name|label
argument_list|)
expr_stmt|;
name|maybe_free
argument_list|(
name|entry
operator|->
name|filename
argument_list|)
expr_stmt|;
name|maybe_free
argument_list|(
name|entry
operator|->
name|nodename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|references
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Search for sequences of whitespace or newlines in STRING, replacing    all such sequences with just a single space.  Remove whitespace from    start and end of string. */
end_comment

begin_function
name|void
name|canonicalize_whitespace
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|len
decl_stmt|,
name|whitespace_found
decl_stmt|,
name|whitespace_loc
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|string
condition|)
return|return;
name|len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|len
argument_list|)
expr_stmt|;
comment|/* Search for sequences of whitespace or newlines.  Replace all such      sequences in the string with just a single space. */
name|whitespace_found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|whitespace_or_newline
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|whitespace_found
operator|++
expr_stmt|;
name|whitespace_loc
operator|=
name|i
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|whitespace_found
operator|&&
name|whitespace_loc
condition|)
block|{
name|whitespace_found
operator|=
literal|0
expr_stmt|;
comment|/* Suppress whitespace at start of string. */
if|if
condition|(
name|j
condition|)
name|temp
index|[
name|j
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
name|temp
index|[
name|j
operator|++
index|]
operator|=
name|string
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|/* Kill trailing whitespace. */
if|if
condition|(
name|j
operator|&&
name|whitespace
argument_list|(
name|temp
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
condition|)
name|j
operator|--
expr_stmt|;
name|temp
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|string
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* String representation of a char returned by printed_representation (). */
end_comment

begin_decl_stmt
specifier|static
name|char
name|the_rep
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a pointer to a string which is the printed representation    of CHARACTER if it were printed at HPOS. */
end_comment

begin_function
name|char
modifier|*
name|printed_representation
parameter_list|(
name|character
parameter_list|,
name|hpos
parameter_list|)
name|unsigned
name|char
name|character
decl_stmt|;
name|int
name|hpos
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|printable_limit
init|=
name|ISO_Latin_p
condition|?
literal|255
else|:
literal|127
decl_stmt|;
comment|/* Show CTRL-x as ^X.  */
if|if
condition|(
name|iscntrl
argument_list|(
name|character
argument_list|)
operator|&&
name|character
operator|<
literal|127
condition|)
block|{
switch|switch
condition|(
name|character
condition|)
block|{
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
name|the_rep
index|[
name|i
operator|++
index|]
operator|=
name|character
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
block|{
name|int
name|tw
decl_stmt|;
name|tw
operator|=
operator|(
operator|(
name|hpos
operator|+
literal|8
operator|)
operator|&
literal|0xf8
operator|)
operator|-
name|hpos
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|tw
condition|)
name|the_rep
index|[
name|i
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
break|break;
default|default:
name|the_rep
index|[
name|i
operator|++
index|]
operator|=
literal|'^'
expr_stmt|;
name|the_rep
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|character
operator||
literal|0x40
operator|)
expr_stmt|;
block|}
block|}
comment|/* Show META-x as 0370.  */
elseif|else
if|if
condition|(
name|character
operator|>
name|printable_limit
condition|)
block|{
name|sprintf
argument_list|(
name|the_rep
operator|+
name|i
argument_list|,
literal|"\\%0o"
argument_list|,
name|character
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|the_rep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|character
operator|==
name|DEL
condition|)
block|{
name|the_rep
index|[
name|i
operator|++
index|]
operator|=
literal|'^'
expr_stmt|;
name|the_rep
index|[
name|i
operator|++
index|]
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
name|the_rep
index|[
name|i
operator|++
index|]
operator|=
name|character
expr_stmt|;
name|the_rep
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|the_rep
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/*                  Functions Static To This File                   */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Amount of space allocated to INFO_PARSED_FILENAME via xmalloc (). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|parsed_filename_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Amount of space allocated to INFO_PARSED_NODENAME via xmalloc (). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|parsed_nodename_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|save_string
argument_list|()
decl_stmt|,
name|saven_string
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remember FILENAME in PARSED_FILENAME.  An empty FILENAME is translated    to a NULL pointer in PARSED_FILENAME. */
end_comment

begin_function
specifier|static
name|void
name|save_filename
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|save_string
argument_list|(
name|filename
argument_list|,
operator|&
name|info_parsed_filename
argument_list|,
operator|&
name|parsed_filename_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Just like save_filename (), but you pass the length of the string. */
end_comment

begin_function
specifier|static
name|void
name|saven_filename
parameter_list|(
name|filename
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|saven_string
argument_list|(
name|filename
argument_list|,
name|len
argument_list|,
operator|&
name|info_parsed_filename
argument_list|,
operator|&
name|parsed_filename_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remember NODENAME in PARSED_NODENAME.  An empty NODENAME is translated    to a NULL pointer in PARSED_NODENAME. */
end_comment

begin_function
specifier|static
name|void
name|save_nodename
parameter_list|(
name|nodename
parameter_list|)
name|char
modifier|*
name|nodename
decl_stmt|;
block|{
name|save_string
argument_list|(
name|nodename
argument_list|,
operator|&
name|info_parsed_nodename
argument_list|,
operator|&
name|parsed_nodename_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Just like save_nodename (), but you pass the length of the string. */
end_comment

begin_function
specifier|static
name|void
name|saven_nodename
parameter_list|(
name|nodename
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|nodename
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|saven_string
argument_list|(
name|nodename
argument_list|,
name|len
argument_list|,
operator|&
name|info_parsed_nodename
argument_list|,
operator|&
name|parsed_nodename_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remember STRING in STRING_P.  STRING_P should currently have STRING_SIZE_P    bytes allocated to it.  An empty STRING is translated to a NULL pointer    in STRING_P. */
end_comment

begin_function
specifier|static
name|void
name|save_string
parameter_list|(
name|string
parameter_list|,
name|string_p
parameter_list|,
name|string_size_p
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
modifier|*
name|string_p
decl_stmt|;
name|int
modifier|*
name|string_size_p
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|string
operator|||
operator|!
operator|*
name|string
condition|)
block|{
if|if
condition|(
operator|*
name|string_p
condition|)
name|free
argument_list|(
operator|*
name|string_p
argument_list|)
expr_stmt|;
operator|*
name|string_p
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|string_size_p
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|>=
operator|*
name|string_size_p
condition|)
operator|*
name|string_p
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
operator|*
name|string_p
argument_list|,
operator|(
operator|*
name|string_size_p
operator|=
literal|1
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|*
name|string_p
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Just like save_string (), but you also pass the length of STRING. */
end_comment

begin_function
specifier|static
name|void
name|saven_string
parameter_list|(
name|string
parameter_list|,
name|len
parameter_list|,
name|string_p
parameter_list|,
name|string_size_p
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
modifier|*
name|string_p
decl_stmt|;
name|int
modifier|*
name|string_size_p
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|string
condition|)
block|{
if|if
condition|(
operator|*
name|string_p
condition|)
name|free
argument_list|(
operator|*
name|string_p
argument_list|)
expr_stmt|;
operator|*
name|string_p
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|string_size_p
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|len
operator|>=
operator|*
name|string_size_p
condition|)
operator|*
name|string_p
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
operator|*
name|string_p
argument_list|,
operator|(
operator|*
name|string_size_p
operator|=
literal|1
operator|+
name|len
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|*
name|string_p
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
operator|*
name|string_p
operator|)
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a pointer to the part of PATHNAME that simply defines the file. */
end_comment

begin_function
name|char
modifier|*
name|filename_non_directory
parameter_list|(
name|pathname
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|filename
init|=
name|pathname
operator|+
name|strlen
argument_list|(
name|pathname
argument_list|)
decl_stmt|;
if|if
condition|(
name|HAVE_DRIVE
argument_list|(
name|pathname
argument_list|)
condition|)
name|pathname
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|filename
operator|>
name|pathname
operator|&&
operator|!
name|IS_SLASH
argument_list|(
name|filename
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|filename
operator|--
expr_stmt|;
return|return
operator|(
name|filename
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if NODE is one especially created by Info. */
end_comment

begin_function
name|int
name|internal_info_node_p
parameter_list|(
name|node
parameter_list|)
name|NODE
modifier|*
name|node
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|NEVER
argument_list|)
if|if
condition|(
name|node
operator|&&
operator|(
name|node
operator|->
name|filename
operator|&&
operator|!
operator|*
name|node
operator|->
name|filename
operator|)
operator|&&
operator|!
name|node
operator|->
name|parent
operator|&&
name|node
operator|->
name|nodename
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
return|return
operator|(
operator|(
name|node
operator|!=
operator|(
name|NODE
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|node
operator|->
name|flags
operator|&
name|N_IsInternal
operator|)
operator|!=
literal|0
operator|)
operator|)
return|;
endif|#
directive|endif
comment|/* !NEVER */
block|}
end_function

begin_comment
comment|/* Make NODE appear to be one especially created by Info. */
end_comment

begin_function
name|void
name|name_internal_node
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|)
name|NODE
modifier|*
name|node
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|node
condition|)
return|return;
name|node
operator|->
name|filename
operator|=
literal|""
expr_stmt|;
name|node
operator|->
name|parent
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|node
operator|->
name|nodename
operator|=
name|name
expr_stmt|;
name|node
operator|->
name|flags
operator||=
name|N_IsInternal
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the window displaying NAME, the name of an internally created    Info window. */
end_comment

begin_function
name|WINDOW
modifier|*
name|get_internal_info_window
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|WINDOW
modifier|*
name|win
decl_stmt|;
for|for
control|(
name|win
operator|=
name|windows
init|;
name|win
condition|;
name|win
operator|=
name|win
operator|->
name|next
control|)
if|if
condition|(
name|internal_info_node_p
argument_list|(
name|win
operator|->
name|node
argument_list|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|win
operator|->
name|node
operator|->
name|nodename
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
return|return
operator|(
name|win
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a window displaying the node NODE. */
end_comment

begin_function
name|WINDOW
modifier|*
name|get_window_of_node
parameter_list|(
name|node
parameter_list|)
name|NODE
modifier|*
name|node
decl_stmt|;
block|{
name|WINDOW
modifier|*
name|win
init|=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
decl_stmt|;
for|for
control|(
name|win
operator|=
name|windows
init|;
name|win
condition|;
name|win
operator|=
name|win
operator|->
name|next
control|)
if|if
condition|(
name|win
operator|->
name|node
operator|==
name|node
condition|)
break|break;
return|return
operator|(
name|win
operator|)
return|;
block|}
end_function

end_unit

