begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  man.c: How to read and format man files.     $Id: man.c,v 1.4 2004/04/11 17:56:46 karl Exp $     Copyright (C) 1995, 1997, 1998, 1999, 2000, 2002, 2003, 2004 Free Software    Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Written by Brian Fox Thu May  4 09:17:52 1995 (bfox@ai.mit.edu). */
end_comment

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|"signals.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_TIME_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_WAIT_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"tilde.h"
end_include

begin_include
include|#
directive|include
file|"man.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
end_if

begin_define
define|#
directive|define
name|pid_t
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|FD_SET
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|hpux
argument_list|)
end_if

begin_define
define|#
directive|define
name|fd_set_cast
parameter_list|(
name|x
parameter_list|)
value|(int *)(x)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|fd_set_cast
parameter_list|(
name|x
parameter_list|)
value|(fd_set *)(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !hpux */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FD_SET */
end_comment

begin_if
if|#
directive|if
name|STRIP_DOT_EXE
end_if

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|exec_extensions
index|[]
init|=
block|{
literal|".exe"
block|,
literal|".com"
block|,
literal|".bat"
block|,
literal|".btm"
block|,
literal|".sh"
block|,
literal|".ksh"
block|,
literal|".pl"
block|,
literal|".sed"
block|,
literal|""
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|exec_extensions
index|[]
init|=
block|{
literal|""
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|char
modifier|*
name|read_from_fd
parameter_list|(
name|int
name|fd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clean_manpage
parameter_list|(
name|char
modifier|*
name|manpage
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|NODE
modifier|*
name|manpage_node_of_file_buffer
parameter_list|(
name|FILE_BUFFER
modifier|*
name|file_buffer
parameter_list|,
name|char
modifier|*
name|pagename
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|get_manpage_contents
parameter_list|(
name|char
modifier|*
name|pagename
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|NODE
modifier|*
name|make_manpage_node
parameter_list|(
name|char
modifier|*
name|pagename
parameter_list|)
block|{
return|return
operator|(
name|info_get_node
argument_list|(
name|MANPAGE_FILE_BUFFER_NAME
argument_list|,
name|pagename
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|NODE
modifier|*
name|get_manpage_node
parameter_list|(
name|FILE_BUFFER
modifier|*
name|file_buffer
parameter_list|,
name|char
modifier|*
name|pagename
parameter_list|)
block|{
name|NODE
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|manpage_node_of_file_buffer
argument_list|(
name|file_buffer
argument_list|,
name|pagename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
block|{
name|char
modifier|*
name|page
decl_stmt|;
name|page
operator|=
name|get_manpage_contents
argument_list|(
name|pagename
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
condition|)
block|{
name|char
name|header
index|[
literal|1024
index|]
decl_stmt|;
name|long
name|oldsize
decl_stmt|,
name|newsize
decl_stmt|;
name|int
name|hlen
decl_stmt|,
name|plen
decl_stmt|;
name|char
modifier|*
name|old_contents
init|=
name|file_buffer
operator|->
name|contents
decl_stmt|;
name|sprintf
argument_list|(
name|header
argument_list|,
literal|"\n\n%c\n%s %s,  %s %s,  %s (dir)\n\n"
argument_list|,
name|INFO_COOKIE
argument_list|,
name|INFO_FILE_LABEL
argument_list|,
name|file_buffer
operator|->
name|filename
argument_list|,
name|INFO_NODE_LABEL
argument_list|,
name|pagename
argument_list|,
name|INFO_UP_LABEL
argument_list|)
expr_stmt|;
name|oldsize
operator|=
name|file_buffer
operator|->
name|filesize
expr_stmt|;
name|hlen
operator|=
name|strlen
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|plen
operator|=
name|strlen
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|newsize
operator|=
operator|(
name|oldsize
operator|+
name|hlen
operator|+
name|plen
operator|)
expr_stmt|;
name|file_buffer
operator|->
name|contents
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|file_buffer
operator|->
name|contents
argument_list|,
literal|1
operator|+
name|newsize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|file_buffer
operator|->
name|contents
operator|+
name|oldsize
argument_list|,
name|header
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|file_buffer
operator|->
name|contents
operator|+
name|oldsize
operator|+
name|hlen
argument_list|,
name|page
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|file_buffer
operator|->
name|contents
index|[
name|newsize
index|]
operator|=
literal|'\0'
expr_stmt|;
name|file_buffer
operator|->
name|filesize
operator|=
name|newsize
expr_stmt|;
name|file_buffer
operator|->
name|finfo
operator|.
name|st_size
operator|=
name|newsize
expr_stmt|;
name|build_tags_and_nodes
argument_list|(
name|file_buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|page
argument_list|)
expr_stmt|;
comment|/* We have just relocated file_buffer->contents from under 	     the feet of info_windows[] array.  Therefore, all the 	     nodes on that list which are showing man pages have their 	     contents member pointing into the blue.  Undo that harm.  */
if|if
condition|(
name|old_contents
operator|&&
name|oldsize
operator|&&
name|old_contents
operator|!=
name|file_buffer
operator|->
name|contents
condition|)
block|{
name|int
name|iw
decl_stmt|;
name|INFO_WINDOW
modifier|*
name|info_win
decl_stmt|;
name|char
modifier|*
name|old_contents_end
init|=
name|old_contents
operator|+
name|oldsize
decl_stmt|;
for|for
control|(
name|iw
operator|=
literal|0
init|;
operator|(
name|info_win
operator|=
name|info_windows
index|[
name|iw
index|]
operator|)
condition|;
name|iw
operator|++
control|)
block|{
name|int
name|in
decl_stmt|;
for|for
control|(
name|in
operator|=
literal|0
init|;
name|in
operator|<
name|info_win
operator|->
name|nodes_index
condition|;
name|in
operator|++
control|)
block|{
name|NODE
modifier|*
name|tmp_node
init|=
name|info_win
operator|->
name|nodes
index|[
name|in
index|]
decl_stmt|;
comment|/* It really only suffices to see that node->filename 			 is "*manpages*".  But after several hours of 			 debugging this, would you blame me for being a bit 			 paranoid?  */
if|if
condition|(
name|tmp_node
operator|&&
name|tmp_node
operator|->
name|filename
operator|&&
name|tmp_node
operator|->
name|contents
operator|&&
name|strcmp
argument_list|(
name|tmp_node
operator|->
name|filename
argument_list|,
name|MANPAGE_FILE_BUFFER_NAME
argument_list|)
operator|==
literal|0
operator|&&
name|tmp_node
operator|->
name|contents
operator|>=
name|old_contents
operator|&&
name|tmp_node
operator|->
name|contents
operator|+
name|tmp_node
operator|->
name|nodelen
operator|<=
name|old_contents_end
condition|)
block|{
name|info_win
operator|->
name|nodes
index|[
name|in
index|]
operator|=
name|manpage_node_of_file_buffer
argument_list|(
name|file_buffer
argument_list|,
name|tmp_node
operator|->
name|nodename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_node
operator|->
name|nodename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_node
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|node
operator|=
name|manpage_node_of_file_buffer
argument_list|(
name|file_buffer
argument_list|,
name|pagename
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|node
operator|)
return|;
block|}
end_function

begin_function
name|FILE_BUFFER
modifier|*
name|create_manpage_file_buffer
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE_BUFFER
modifier|*
name|file_buffer
init|=
name|make_file_buffer
argument_list|()
decl_stmt|;
name|file_buffer
operator|->
name|filename
operator|=
name|xstrdup
argument_list|(
name|MANPAGE_FILE_BUFFER_NAME
argument_list|)
expr_stmt|;
name|file_buffer
operator|->
name|fullpath
operator|=
name|xstrdup
argument_list|(
name|MANPAGE_FILE_BUFFER_NAME
argument_list|)
expr_stmt|;
name|file_buffer
operator|->
name|finfo
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|file_buffer
operator|->
name|filesize
operator|=
literal|0
expr_stmt|;
name|file_buffer
operator|->
name|contents
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|file_buffer
operator|->
name|flags
operator|=
operator|(
name|N_IsInternal
operator||
name|N_CannotGC
operator||
name|N_IsManPage
operator|)
expr_stmt|;
return|return
operator|(
name|file_buffer
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Scan the list of directories in PATH looking for FILENAME.  If we find    one that is an executable file, return it as a new string.  Otherwise,    return a NULL pointer. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|executable_file_in_path
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|stat
name|finfo
decl_stmt|;
name|char
modifier|*
name|temp_dirname
decl_stmt|;
name|int
name|statable
decl_stmt|,
name|dirname_index
decl_stmt|;
name|dirname_index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|temp_dirname
operator|=
name|extract_colon_unit
argument_list|(
name|path
argument_list|,
operator|&
name|dirname_index
argument_list|)
operator|)
condition|)
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|char
modifier|*
name|temp_end
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Expand a leading tilde if one is present. */
if|if
condition|(
operator|*
name|temp_dirname
operator|==
literal|'~'
condition|)
block|{
name|char
modifier|*
name|expanded_dirname
decl_stmt|;
name|expanded_dirname
operator|=
name|tilde_expand_word
argument_list|(
name|temp_dirname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_dirname
argument_list|)
expr_stmt|;
name|temp_dirname
operator|=
name|expanded_dirname
expr_stmt|;
block|}
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|34
operator|+
name|strlen
argument_list|(
name|temp_dirname
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|temp_dirname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_SLASH
argument_list|(
name|temp
index|[
operator|(
name|strlen
argument_list|(
name|temp
argument_list|)
operator|)
operator|-
literal|1
index|]
argument_list|)
condition|)
name|strcat
argument_list|(
name|temp
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|temp_end
operator|=
name|temp
operator|+
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_dirname
argument_list|)
expr_stmt|;
comment|/* Look for FILENAME, possibly with any of the extensions 	 in EXEC_EXTENSIONS[].  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|exec_extensions
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|exec_extensions
index|[
name|i
index|]
index|[
literal|0
index|]
condition|)
name|strcpy
argument_list|(
name|temp_end
argument_list|,
name|exec_extensions
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|statable
operator|=
operator|(
name|stat
argument_list|(
name|temp
argument_list|,
operator|&
name|finfo
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
comment|/* If we have found a regular executable file, then use it. */
if|if
condition|(
operator|(
name|statable
operator|)
operator|&&
operator|(
name|S_ISREG
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
operator|)
operator|&&
operator|(
name|access
argument_list|(
name|temp
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|temp
operator|)
return|;
block|}
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the full pathname of the system man page formatter. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|find_man_formatter
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|executable_file_in_path
argument_list|(
literal|"man"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|manpage_pagename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|manpage_section
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|get_page_and_section
parameter_list|(
name|char
modifier|*
name|pagename
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|manpage_pagename
condition|)
name|free
argument_list|(
name|manpage_pagename
argument_list|)
expr_stmt|;
if|if
condition|(
name|manpage_section
condition|)
name|free
argument_list|(
name|manpage_section
argument_list|)
expr_stmt|;
name|manpage_pagename
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|manpage_section
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pagename
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|&&
name|pagename
index|[
name|i
index|]
operator|!=
literal|'('
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|manpage_pagename
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|i
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|manpage_pagename
argument_list|,
name|pagename
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|manpage_pagename
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|pagename
index|[
name|i
index|]
operator|==
literal|'('
condition|)
block|{
name|int
name|start
decl_stmt|;
name|start
operator|=
name|i
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|pagename
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|&&
name|pagename
index|[
name|i
index|]
operator|!=
literal|')'
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|manpage_section
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
operator|(
name|i
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|manpage_section
argument_list|,
name|pagename
operator|+
name|start
argument_list|,
operator|(
name|i
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
name|manpage_section
index|[
name|i
operator|-
name|start
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|PIPE_USE_FORK
end_if

begin_function
specifier|static
name|void
name|reap_children
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|wait
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|char
modifier|*
name|get_manpage_contents
parameter_list|(
name|char
modifier|*
name|pagename
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|formatter_args
index|[
literal|4
index|]
init|=
block|{
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
name|int
name|pipes
index|[
literal|2
index|]
decl_stmt|;
name|pid_t
name|child
decl_stmt|;
name|RETSIGTYPE
function_decl|(
modifier|*
name|sigsave
function_decl|)
parameter_list|(
name|int
name|signum
parameter_list|)
function_decl|;
name|char
modifier|*
name|formatted_page
init|=
name|NULL
decl_stmt|;
name|int
name|arg_index
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|formatter_args
index|[
literal|0
index|]
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|formatter_args
index|[
literal|0
index|]
operator|=
name|find_man_formatter
argument_list|()
expr_stmt|;
if|if
condition|(
name|formatter_args
index|[
literal|0
index|]
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
name|get_page_and_section
argument_list|(
name|pagename
argument_list|)
expr_stmt|;
if|if
condition|(
name|manpage_section
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|formatter_args
index|[
name|arg_index
operator|++
index|]
operator|=
name|manpage_section
expr_stmt|;
name|formatter_args
index|[
name|arg_index
operator|++
index|]
operator|=
name|manpage_pagename
expr_stmt|;
name|formatter_args
index|[
name|arg_index
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* Open a pipe to this program, read the output, and save it away      in FORMATTED_PAGE.  The reader end of the pipe is pipes[0]; the      writer end is pipes[1]. */
if|#
directive|if
name|PIPE_USE_FORK
name|pipe
argument_list|(
name|pipes
argument_list|)
expr_stmt|;
name|sigsave
operator|=
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|reap_children
argument_list|)
expr_stmt|;
name|child
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|child
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
if|if
condition|(
name|child
operator|!=
literal|0
condition|)
block|{
comment|/* In the parent, close the writing end of the pipe, and read from          the exec'd child. */
name|close
argument_list|(
name|pipes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|formatted_page
operator|=
name|read_from_fd
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|sigsave
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* In the child, close the read end of the pipe, make the write end          of the pipe be stdout, and execute the man page formatter. */
name|close
argument_list|(
name|pipes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|freopen
argument_list|(
name|NULL_DEVICE
argument_list|,
literal|"w"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|freopen
argument_list|(
name|NULL_DEVICE
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|pipes
index|[
literal|1
index|]
argument_list|,
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|formatter_args
index|[
literal|0
index|]
argument_list|,
name|formatter_args
argument_list|)
expr_stmt|;
comment|/* If we get here, we couldn't exec, so close out the pipe and          exit. */
name|close
argument_list|(
name|pipes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !PIPE_USE_FORK */
comment|/* Cannot fork/exec, but can popen/pclose.  */
block|{
name|FILE
modifier|*
name|fpipe
decl_stmt|;
name|char
modifier|*
name|cmdline
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|formatter_args
index|[
literal|0
index|]
argument_list|)
operator|+
name|strlen
argument_list|(
name|manpage_pagename
argument_list|)
operator|+
operator|(
name|arg_index
operator|>
literal|2
condition|?
name|strlen
argument_list|(
name|manpage_section
argument_list|)
else|:
literal|0
operator|)
operator|+
literal|3
argument_list|)
decl_stmt|;
name|int
name|save_stderr
init|=
name|dup
argument_list|(
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|fd_err
init|=
name|open
argument_list|(
name|NULL_DEVICE
argument_list|,
name|O_WRONLY
argument_list|,
literal|0666
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd_err
operator|>
literal|2
condition|)
name|dup2
argument_list|(
name|fd_err
argument_list|,
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't print errors. */
name|sprintf
argument_list|(
name|cmdline
argument_list|,
literal|"%s %s %s"
argument_list|,
name|formatter_args
index|[
literal|0
index|]
argument_list|,
name|manpage_pagename
argument_list|,
name|arg_index
operator|>
literal|2
condition|?
name|manpage_section
else|:
literal|""
argument_list|)
expr_stmt|;
name|fpipe
operator|=
name|popen
argument_list|(
name|cmdline
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmdline
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd_err
operator|>
literal|2
condition|)
name|close
argument_list|(
name|fd_err
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|save_stderr
argument_list|,
name|fileno
argument_list|(
name|stderr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpipe
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
name|formatted_page
operator|=
name|read_from_fd
argument_list|(
name|fileno
argument_list|(
name|fpipe
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pclose
argument_list|(
name|fpipe
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|formatted_page
condition|)
name|free
argument_list|(
name|formatted_page
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* !PIPE_USE_FORK */
comment|/* If we have the page, then clean it up. */
if|if
condition|(
name|formatted_page
condition|)
name|clean_manpage
argument_list|(
name|formatted_page
argument_list|)
expr_stmt|;
return|return
operator|(
name|formatted_page
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clean_manpage
parameter_list|(
name|char
modifier|*
name|manpage
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|newline_count
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|newpage
decl_stmt|;
name|newpage
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|manpage
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
operator|(
name|newpage
index|[
name|j
index|]
operator|=
name|manpage
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|manpage
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
name|newline_count
operator|++
expr_stmt|;
else|else
name|newline_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|newline_count
operator|==
literal|3
condition|)
block|{
name|j
operator|--
expr_stmt|;
name|newline_count
operator|--
expr_stmt|;
block|}
comment|/* A malformed man page could have a \b as its first character,          in which case decrementing j by 2 will cause us to write into          newpage[-1], smashing the hidden info stored there by malloc.  */
if|if
condition|(
name|manpage
index|[
name|i
index|]
operator|==
literal|'\b'
operator|||
operator|(
name|manpage
index|[
name|i
index|]
operator|==
literal|'\f'
operator|&&
name|j
operator|>
literal|0
operator|)
condition|)
name|j
operator|-=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|raw_escapes_p
condition|)
block|{
comment|/* Remove the ANSI escape sequences for color, boldface, 	     underlining, and italics, generated by some versions of 	     Groff.  */
if|if
condition|(
name|manpage
index|[
name|i
index|]
operator|==
literal|'\033'
operator|&&
name|manpage
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'['
operator|&&
name|isdigit
argument_list|(
name|manpage
index|[
name|i
operator|+
literal|2
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|manpage
index|[
name|i
operator|+
literal|3
index|]
argument_list|)
operator|&&
name|manpage
index|[
name|i
operator|+
literal|4
index|]
operator|==
literal|'m'
condition|)
block|{
name|i
operator|+=
literal|4
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|manpage
index|[
name|i
operator|+
literal|3
index|]
operator|==
literal|'m'
condition|)
block|{
name|i
operator|+=
literal|3
expr_stmt|;
name|j
operator|--
expr_stmt|;
block|}
comment|/* Else do nothing: it's some unknown escape sequence, 		 so let's leave it alone.  */
block|}
block|}
block|}
name|newpage
index|[
name|j
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|manpage
argument_list|,
name|newpage
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newpage
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|NODE
modifier|*
name|manpage_node_of_file_buffer
parameter_list|(
name|FILE_BUFFER
modifier|*
name|file_buffer
parameter_list|,
name|char
modifier|*
name|pagename
parameter_list|)
block|{
name|NODE
modifier|*
name|node
init|=
operator|(
name|NODE
operator|*
operator|)
name|NULL
decl_stmt|;
name|TAG
modifier|*
name|tag
init|=
operator|(
name|TAG
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
name|file_buffer
operator|->
name|contents
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|tag
operator|=
name|file_buffer
operator|->
name|tags
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|pagename
argument_list|,
name|tag
operator|->
name|nodename
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|tag
condition|)
block|{
name|node
operator|=
operator|(
name|NODE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NODE
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|filename
operator|=
name|file_buffer
operator|->
name|filename
expr_stmt|;
name|node
operator|->
name|nodename
operator|=
name|xstrdup
argument_list|(
name|tag
operator|->
name|nodename
argument_list|)
expr_stmt|;
name|node
operator|->
name|contents
operator|=
name|file_buffer
operator|->
name|contents
operator|+
name|tag
operator|->
name|nodestart
expr_stmt|;
name|node
operator|->
name|nodelen
operator|=
name|tag
operator|->
name|nodelen
expr_stmt|;
name|node
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|display_pos
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|parent
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|node
operator|->
name|flags
operator|=
operator|(
name|N_HasTagsTable
operator||
name|N_IsManPage
operator|)
expr_stmt|;
name|node
operator|->
name|contents
operator|+=
name|skip_node_separator
argument_list|(
name|node
operator|->
name|contents
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|node
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|read_from_fd
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|struct
name|timeval
name|timeout
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|bsize
init|=
literal|0
decl_stmt|;
name|int
name|bindex
init|=
literal|0
decl_stmt|;
name|int
name|select_result
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FD_SET
argument_list|)
name|fd_set
name|read_fds
decl_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|15
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|read_fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|read_fds
argument_list|)
expr_stmt|;
name|select_result
operator|=
name|select
argument_list|(
name|fd
operator|+
literal|1
argument_list|,
name|fd_set_cast
argument_list|(
operator|&
name|read_fds
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !FD_SET */
name|select_result
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* !FD_SET */
switch|switch
condition|(
name|select_result
condition|)
block|{
case|case
literal|0
case|:
case|case
operator|-
literal|1
case|:
break|break;
default|default:
block|{
name|int
name|amount_read
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
while|while
condition|(
operator|(
name|bindex
operator|+
literal|1024
operator|)
operator|>
operator|(
name|bsize
operator|)
condition|)
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buffer
argument_list|,
operator|(
name|bsize
operator|+=
literal|1024
operator|)
argument_list|)
expr_stmt|;
name|buffer
index|[
name|bindex
index|]
operator|=
literal|'\0'
expr_stmt|;
name|amount_read
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buffer
operator|+
name|bindex
argument_list|,
literal|1023
argument_list|)
expr_stmt|;
if|if
condition|(
name|amount_read
operator|<
literal|0
condition|)
block|{
name|done
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|bindex
operator|+=
name|amount_read
expr_stmt|;
name|buffer
index|[
name|bindex
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|amount_read
operator|==
literal|0
condition|)
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|(
name|buffer
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|buffer
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|buffer
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reference_section_starters
index|[]
init|=
block|{
literal|"\nRELATED INFORMATION"
block|,
literal|"\nRELATED\tINFORMATION"
block|,
literal|"RELATED INFORMATION\n"
block|,
literal|"RELATED\tINFORMATION\n"
block|,
literal|"\nSEE ALSO"
block|,
literal|"\nSEE\tALSO"
block|,
literal|"SEE ALSO\n"
block|,
literal|"SEE\tALSO\n"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SEARCH_BINDING
name|frs_binding
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|SEARCH_BINDING
modifier|*
name|find_reference_section
parameter_list|(
name|NODE
modifier|*
name|node
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|long
name|position
init|=
operator|-
literal|1
decl_stmt|;
name|frs_binding
operator|.
name|buffer
operator|=
name|node
operator|->
name|contents
expr_stmt|;
name|frs_binding
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|frs_binding
operator|.
name|end
operator|=
name|node
operator|->
name|nodelen
expr_stmt|;
name|frs_binding
operator|.
name|flags
operator|=
name|S_SkipDest
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|reference_section_starters
index|[
name|i
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|position
operator|=
name|search_forward
argument_list|(
name|reference_section_starters
index|[
name|i
index|]
argument_list|,
operator|&
name|frs_binding
argument_list|)
expr_stmt|;
if|if
condition|(
name|position
operator|!=
operator|-
literal|1
condition|)
break|break;
block|}
if|if
condition|(
name|position
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|(
name|SEARCH_BINDING
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* We found the start of the reference section, and point is right after      the string which starts it.  The text from here to the next header      (or end of buffer) contains the only references in this manpage. */
name|frs_binding
operator|.
name|start
operator|=
name|position
expr_stmt|;
for|for
control|(
name|i
operator|=
name|frs_binding
operator|.
name|start
init|;
name|i
operator|<
name|frs_binding
operator|.
name|end
operator|-
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|frs_binding
operator|.
name|buffer
index|[
name|i
index|]
operator|==
literal|'\n'
operator|)
operator|&&
operator|(
operator|!
name|whitespace
argument_list|(
name|frs_binding
operator|.
name|buffer
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|frs_binding
operator|.
name|end
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
operator|&
name|frs_binding
operator|)
return|;
block|}
end_function

begin_function
name|REFERENCE
modifier|*
modifier|*
name|xrefs_of_manpage
parameter_list|(
name|NODE
modifier|*
name|node
parameter_list|)
block|{
name|SEARCH_BINDING
modifier|*
name|reference_section
decl_stmt|;
name|REFERENCE
modifier|*
modifier|*
name|refs
init|=
operator|(
name|REFERENCE
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|refs_index
init|=
literal|0
decl_stmt|;
name|int
name|refs_slots
init|=
literal|0
decl_stmt|;
name|long
name|position
decl_stmt|;
name|reference_section
operator|=
name|find_reference_section
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|reference_section
operator|==
operator|(
name|SEARCH_BINDING
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
operator|(
name|REFERENCE
operator|*
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* Grovel the reference section building a list of references found there.      A reference is alphabetic characters followed by non-whitespace text      within parenthesis. */
name|reference_section
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|position
operator|=
name|search_forward
argument_list|(
literal|"("
argument_list|,
name|reference_section
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
specifier|register
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
for|for
control|(
name|start
operator|=
name|position
init|;
name|start
operator|>
name|reference_section
operator|->
name|start
condition|;
name|start
operator|--
control|)
if|if
condition|(
name|whitespace
argument_list|(
name|reference_section
operator|->
name|buffer
index|[
name|start
index|]
argument_list|)
condition|)
break|break;
name|start
operator|++
expr_stmt|;
for|for
control|(
name|end
operator|=
name|position
init|;
name|end
operator|<
name|reference_section
operator|->
name|end
condition|;
name|end
operator|++
control|)
block|{
if|if
condition|(
name|whitespace
argument_list|(
name|reference_section
operator|->
name|buffer
index|[
name|end
index|]
argument_list|)
condition|)
block|{
name|end
operator|=
name|start
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reference_section
operator|->
name|buffer
index|[
name|end
index|]
operator|==
literal|')'
condition|)
block|{
name|end
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|end
operator|!=
name|start
condition|)
block|{
name|REFERENCE
modifier|*
name|entry
decl_stmt|;
name|int
name|len
init|=
name|end
operator|-
name|start
decl_stmt|;
name|entry
operator|=
operator|(
name|REFERENCE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|REFERENCE
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|label
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|entry
operator|->
name|label
argument_list|,
operator|(
name|reference_section
operator|->
name|buffer
operator|)
operator|+
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|entry
operator|->
name|label
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|entry
operator|->
name|filename
operator|=
name|xstrdup
argument_list|(
name|node
operator|->
name|filename
argument_list|)
expr_stmt|;
name|entry
operator|->
name|nodename
operator|=
name|xstrdup
argument_list|(
name|entry
operator|->
name|label
argument_list|)
expr_stmt|;
name|entry
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|entry
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|add_pointer_to_array
argument_list|(
name|entry
argument_list|,
name|refs_index
argument_list|,
name|refs
argument_list|,
name|refs_slots
argument_list|,
literal|10
argument_list|,
name|REFERENCE
operator|*
argument_list|)
expr_stmt|;
block|}
name|reference_section
operator|->
name|start
operator|=
name|position
operator|+
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|refs
operator|)
return|;
block|}
end_function

begin_function
name|long
name|locate_manpage_xref
parameter_list|(
name|NODE
modifier|*
name|node
parameter_list|,
name|long
name|int
name|start
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|REFERENCE
modifier|*
modifier|*
name|refs
decl_stmt|;
name|long
name|position
init|=
operator|-
literal|1
decl_stmt|;
name|refs
operator|=
name|xrefs_of_manpage
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|refs
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|REFERENCE
modifier|*
name|entry
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|refs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|count
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|entry
operator|=
name|refs
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|entry
operator|->
name|start
operator|>
name|start
condition|)
block|{
name|position
operator|=
name|entry
operator|->
name|start
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|count
operator|-
literal|1
init|;
name|i
operator|>
operator|-
literal|1
condition|;
name|i
operator|--
control|)
block|{
name|entry
operator|=
name|refs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|start
operator|<
name|start
condition|)
block|{
name|position
operator|=
name|entry
operator|->
name|start
expr_stmt|;
break|break;
block|}
block|}
block|}
name|info_free_references
argument_list|(
name|refs
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|position
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This one was a little tricky.  The binding buffer that is passed in has    a START and END value of 0 -- strlen (window-line-containing-point).    The BUFFER is a pointer to the start of that line. */
end_comment

begin_function
name|REFERENCE
modifier|*
modifier|*
name|manpage_xrefs_in_binding
parameter_list|(
name|NODE
modifier|*
name|node
parameter_list|,
name|SEARCH_BINDING
modifier|*
name|binding
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|REFERENCE
modifier|*
modifier|*
name|all_refs
init|=
name|xrefs_of_manpage
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|REFERENCE
modifier|*
modifier|*
name|brefs
init|=
operator|(
name|REFERENCE
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|REFERENCE
modifier|*
name|entry
decl_stmt|;
name|int
name|brefs_index
init|=
literal|0
decl_stmt|;
name|int
name|brefs_slots
init|=
literal|0
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
if|if
condition|(
operator|!
name|all_refs
condition|)
return|return
operator|(
operator|(
name|REFERENCE
operator|*
operator|*
operator|)
name|NULL
operator|)
return|;
name|start
operator|=
name|binding
operator|->
name|start
operator|+
operator|(
name|binding
operator|->
name|buffer
operator|-
name|node
operator|->
name|contents
operator|)
expr_stmt|;
name|end
operator|=
name|binding
operator|->
name|end
operator|+
operator|(
name|binding
operator|->
name|buffer
operator|-
name|node
operator|->
name|contents
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|entry
operator|=
name|all_refs
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|entry
operator|->
name|start
operator|>
name|start
operator|)
operator|&&
operator|(
name|entry
operator|->
name|end
operator|<
name|end
operator|)
condition|)
block|{
name|add_pointer_to_array
argument_list|(
name|entry
argument_list|,
name|brefs_index
argument_list|,
name|brefs
argument_list|,
name|brefs_slots
argument_list|,
literal|10
argument_list|,
name|REFERENCE
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|maybe_free
argument_list|(
name|entry
operator|->
name|label
argument_list|)
expr_stmt|;
name|maybe_free
argument_list|(
name|entry
operator|->
name|filename
argument_list|)
expr_stmt|;
name|maybe_free
argument_list|(
name|entry
operator|->
name|nodename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|all_refs
argument_list|)
expr_stmt|;
return|return
operator|(
name|brefs
operator|)
return|;
block|}
end_function

end_unit

