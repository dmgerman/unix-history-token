begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* infokey.c -- compile ~/.infokey to ~/.info.    $Id: infokey.c,v 1.4 2003/05/13 16:26:02 karl Exp $     Copyright (C) 1999, 2001, 2002, 2003 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Written by Andrew Bettison<andrewb@zip.com.au>. */
end_comment

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_include
include|#
directive|include
file|"infomap.h"
end_include

begin_include
include|#
directive|include
file|"infokey.h"
end_include

begin_include
include|#
directive|include
file|"key.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|program_name
init|=
literal|"infokey"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means print version info only. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_version_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means print a short description of the options. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_help_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String specifying the source file.  This is set by the user on the    command line, or a default is used. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|input_filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String specifying the name of the file to output to.  This is    set by the user on the command line, or a default is used. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|output_filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure describing the options that Infokey accepts.  We pass this    structure to getopt_long ().  If you add or otherwise change this    structure, you must also change the string which follows it. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"output"
block|,
literal|1
block|,
literal|0
block|,
literal|'o'
block|}
block|,
block|{
literal|"help"
block|,
literal|0
block|,
operator|&
name|print_help_p
block|,
literal|1
block|}
block|,
block|{
literal|"version"
block|,
literal|0
block|,
operator|&
name|print_version_p
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String describing the shorthand versions of the long options found above. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|short_options
init|=
literal|"o:"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure for holding the compiled sections. */
end_comment

begin_enum
enum|enum
name|sect_e
block|{
name|info
init|=
literal|0
block|,
name|ea
init|=
literal|1
block|,
name|var
init|=
literal|2
block|}
enum|;
end_enum

begin_struct
struct|struct
name|sect
block|{
name|unsigned
name|int
name|cur
decl_stmt|;
name|unsigned
name|char
name|data
index|[
name|INFOKEY_MAX_SECTIONLEN
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Some "forward" declarations. */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|mkpath
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|compile
argument_list|()
decl_stmt|,
name|write_infokey_file
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|syntax_error
argument_list|()
decl_stmt|,
name|error_message
argument_list|()
decl_stmt|,
name|suggest_help
argument_list|()
decl_stmt|,
name|short_help
argument_list|()
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/*             Main Entry Point to the Infokey Program              */
end_comment

begin_comment
comment|/*                                                                  */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|getopt_long_index
decl_stmt|;
comment|/* Index returned by getopt_long (). */
ifdef|#
directive|ifdef
name|HAVE_SETLOCALE
comment|/* Set locale via LC_ALL.  */
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set the text message domain.  */
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|option_character
decl_stmt|;
name|option_character
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|short_options
argument_list|,
name|long_options
argument_list|,
operator|&
name|getopt_long_index
argument_list|)
expr_stmt|;
comment|/* getopt_long () returns EOF when there are no more long options. */
if|if
condition|(
name|option_character
operator|==
name|EOF
condition|)
break|break;
comment|/* If this is a long option, then get the short version of it. */
if|if
condition|(
name|option_character
operator|==
literal|0
operator|&&
name|long_options
index|[
name|getopt_long_index
index|]
operator|.
name|flag
operator|==
literal|0
condition|)
name|option_character
operator|=
name|long_options
index|[
name|getopt_long_index
index|]
operator|.
name|val
expr_stmt|;
comment|/* Case on the option that we have received. */
switch|switch
condition|(
name|option_character
condition|)
block|{
case|case
literal|0
case|:
break|break;
comment|/* User is specifying the name of a file to output to. */
case|case
literal|'o'
case|:
if|if
condition|(
name|output_filename
condition|)
name|free
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
name|output_filename
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|suggest_help
argument_list|()
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the user specified --version, then show the version and exit. */
if|if
condition|(
name|print_version_p
condition|)
block|{
name|printf
argument_list|(
literal|"%s (GNU %s) %s\n"
argument_list|,
name|program_name
argument_list|,
name|PACKAGE
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"Copyright (C) %s Free Software Foundation, Inc.\n\ There is NO warranty.  You may redistribute this software\n\ under the terms of the GNU General Public License.\n\ For more information about these matters, see the files named COPYING.\n"
argument_list|)
argument_list|,
literal|"2003"
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If the `--help' option was present, show the help and exit. */
if|if
condition|(
name|print_help_p
condition|)
block|{
name|short_help
argument_list|()
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If there is one argument remaining, it is the name of the input      file. */
if|if
condition|(
name|optind
operator|==
name|argc
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|input_filename
condition|)
name|free
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optind
operator|!=
name|argc
condition|)
block|{
name|error_message
argument_list|(
literal|0
argument_list|,
name|_
argument_list|(
literal|"incorrect number of arguments"
argument_list|)
argument_list|)
expr_stmt|;
name|suggest_help
argument_list|()
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Use default filenames where none given. */
block|{
name|char
modifier|*
name|homedir
decl_stmt|;
name|homedir
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__MSDOS__
if|if
condition|(
operator|!
name|homedir
condition|)
name|homedir
operator|=
literal|"."
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|input_filename
condition|)
name|input_filename
operator|=
name|mkpath
argument_list|(
name|homedir
argument_list|,
name|INFOKEY_SRCFILE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|output_filename
condition|)
name|output_filename
operator|=
name|mkpath
argument_list|(
name|homedir
argument_list|,
name|INFOKEY_FILE
argument_list|)
expr_stmt|;
block|}
block|{
name|FILE
modifier|*
name|inf
decl_stmt|;
name|FILE
modifier|*
name|outf
decl_stmt|;
name|int
name|write_error
decl_stmt|;
specifier|static
name|struct
name|sect
name|sections
index|[
literal|3
index|]
decl_stmt|;
comment|/* Open the input file. */
name|inf
operator|=
name|fopen
argument_list|(
name|input_filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inf
condition|)
block|{
name|error_message
argument_list|(
name|errno
argument_list|,
name|_
argument_list|(
literal|"cannot open input file `%s'"
argument_list|)
argument_list|,
name|input_filename
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Compile the input file to its verious sections, then write the        section data to the output file. */
if|if
condition|(
name|compile
argument_list|(
name|inf
argument_list|,
name|input_filename
argument_list|,
name|sections
argument_list|)
condition|)
block|{
comment|/* Open the output file. */
name|outf
operator|=
name|fopen
argument_list|(
name|output_filename
argument_list|,
name|FOPEN_WBIN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outf
condition|)
block|{
name|error_message
argument_list|(
name|errno
argument_list|,
name|_
argument_list|(
literal|"cannot create output file `%s'"
argument_list|)
argument_list|,
name|output_filename
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Write the contents of the output file and close it.  If there is 	   an error writing to the file, delete it and exit with a failure 	   status.  */
name|write_error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|write_infokey_file
argument_list|(
name|outf
argument_list|,
name|sections
argument_list|)
condition|)
block|{
name|error_message
argument_list|(
name|errno
argument_list|,
name|_
argument_list|(
literal|"error writing to `%s'"
argument_list|)
argument_list|,
name|output_filename
argument_list|)
expr_stmt|;
name|write_error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|outf
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|error_message
argument_list|(
name|errno
argument_list|,
name|_
argument_list|(
literal|"error closing output file `%s'"
argument_list|)
argument_list|,
name|output_filename
argument_list|)
expr_stmt|;
name|write_error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|write_error
condition|)
block|{
name|unlink
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Close the input file. */
name|fclose
argument_list|(
name|inf
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|mkpath
parameter_list|(
name|dir
parameter_list|,
name|file
parameter_list|)
specifier|const
name|char
modifier|*
name|dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compilation - the real work.  	Source file syntax 	------------------ 	The source file is a line-based text file with the following 	structure:  		# comments 		# more comments  		#info 		u	prev-line 		d	next-line 		^a	invalid		# just beep 		\ku	prev-line 		#stop 		\kd	next-line 		q	quit		# of course!  		#echo-area 		^a	echo-area-beg-of-line 		^e	echo-area-end-of-line 		\kr	echo-area-forward 		\kl	echo-area-backward 		\kh	echo-area-beg-of-line 		\ke	echo-area-end-of-line  		#var 		scroll-step=1 		ISO-Latin=Off  	Lines starting with '#' are comments, and are ignored.  Blank 	lines are ignored.  Each section is introduced by one of the 	following lines:  		#info 		#echo-area 		#var  	The sections may occur in any order.  Each section may be 	omitted completely.  If the 'info' section is the first in the 	file, its '#info' line may be omitted.  	The 'info' and 'echo-area' sections 	----------------------------------- 	Each line in the 'info' or 'echo-area' sections has the 	following syntax:  		key-sequence SPACE action-name [ SPACE [ # comment ] ] \n  	Where SPACE is one or more white space characters excluding 	newline, "action-name" is the name of a GNU Info command, 	"comment" is any sequence of characters excluding newline, and 	"key-sequence" is a concatenation of one or more key definitions 	using the following syntax:  	   1.	A carat ^ followed by one character indicates a single 	   	control character;  	   2.	A backslash \ followed by one, two, or three octal 		digits indicates a single character having that ASCII 		code;  	   3.	\n indicates a single NEWLINE; 		\e indicates a single ESC; 		\r indicates a single CR; 		\t indicates a single TAB; 		\b indicates a single BACKSPACE;  	   4.	\ku indicates the Up Arrow key; 	   	\kd indicates the Down Arrow key; 	   	\kl indicates the Left Arrow key; 	   	\kr indicates the Right Arrow key; 	   	\kP indicates the Page Up (PRIOR) key; 	   	\kN indicates the Page Down (NEXT) key; 	   	\kh indicates the Home key; 	   	\ke indicates the End key; 	   	\kx indicates the DEL key; 		\k followed by any other character indicates a single 		control-K, and the following character is interpreted 		as in rules 1, 2, 3, 5 and 6.  	   5.	\m followed by any sequence defined in rules 1, 2, 3, 4 		or 6 indicates the "Meta" modification of that key.  	   6.	A backslash \ followed by any character not described 	   	above indicates that character itself.  In particular: 		\\ indicates a single backslash \, 		\  (backslash-space) indicates a single space, 		\^ indicates a single caret ^,  	If the following line:  		#stop  	occurs anywhere in an 'info' or 'echo-area' section, that 	indicates to GNU Info to suppress all of its default key 	bindings in that context.  	The 'var' section 	----------------- 	Each line in the 'var' section has the following syntax:  		variable-name = value \n  	Where "variable-name" is the name of a GNU Info variable and 	"value" is the value that GNU Info will assign to that variable 	when commencing execution.  There must be no white space in the 	variable name, nor between the variable name and the '='.  All 	characters immediately following the '=', up to but not 	including the terminating newline, are considered to be the 	value that will be assigned.  In other words, white space 	following the '=' is not ignored.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|add_to_section
argument_list|()
decl_stmt|,
name|lookup_action
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compile the input file into its various sections.  Return true if no    error was encountered.  */
end_comment

begin_function
specifier|static
name|int
name|compile
parameter_list|(
name|fp
parameter_list|,
name|filename
parameter_list|,
name|sections
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|sect
name|sections
index|[]
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|char
name|rescan
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|lnum
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* This parser is a true state machine, with no sneaky fetching      of input characters inside the main loop.  In other words, all      state is fully represented by the following variables:    */
enum|enum
block|{
name|start_of_line
block|,
name|start_of_comment
block|,
name|in_line_comment
block|,
name|in_trailing_comment
block|,
name|get_keyseq
block|,
name|got_keyseq
block|,
name|get_action
block|,
name|got_action
block|,
name|get_varname
block|,
name|got_varname
block|,
name|get_equals
block|,
name|got_equals
block|,
name|get_value
block|}
name|state
init|=
name|start_of_line
enum|;
name|enum
name|sect_e
name|section
init|=
name|info
decl_stmt|;
enum|enum
block|{
name|normal
block|,
name|slosh
block|,
name|control
block|,
name|octal
block|,
name|special_key
block|}
name|seqstate
enum|;
comment|/* used if state == get_keyseq */
name|char
name|meta
init|=
literal|0
decl_stmt|;
name|char
name|ocnt
decl_stmt|;
comment|/* used if state == get_keyseq&& seqstate == octal */
comment|/* Data is accumulated in the following variables.  The code      avoids overflowing these strings, and throws an error      where appropriate if a string limit is exceeded.  These string      lengths are arbitrary (and should be large enough) and their      lengths are not hard-coded anywhere else, so increasing them      here will not break anything.  */
name|char
name|oval
decl_stmt|;
name|char
name|comment
index|[
literal|10
index|]
decl_stmt|;
name|unsigned
name|int
name|clen
decl_stmt|;
name|char
name|seq
index|[
literal|20
index|]
decl_stmt|;
name|unsigned
name|int
name|slen
decl_stmt|;
name|char
name|act
index|[
literal|80
index|]
decl_stmt|;
name|unsigned
name|int
name|alen
decl_stmt|;
name|char
name|varn
index|[
literal|80
index|]
decl_stmt|;
name|unsigned
name|int
name|varlen
decl_stmt|;
name|char
name|val
index|[
literal|80
index|]
decl_stmt|;
name|unsigned
name|int
name|vallen
decl_stmt|;
define|#
directive|define
name|To_seq
parameter_list|(
name|c
parameter_list|)
define|\
value|do { \ 		    if (slen< sizeof seq) \ 		      seq[slen++] = meta ? Meta(c) : (c); \ 		    else \ 		      { \ 			syntax_error(filename, lnum, _("key sequence too long")); \ 			error = 1; \ 		      } \ 		    meta = 0; \ 		  } while (0)
name|sections
index|[
name|info
index|]
operator|.
name|cur
operator|=
literal|1
expr_stmt|;
name|sections
index|[
name|info
index|]
operator|.
name|data
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sections
index|[
name|ea
index|]
operator|.
name|cur
operator|=
literal|1
expr_stmt|;
name|sections
index|[
name|ea
index|]
operator|.
name|data
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sections
index|[
name|var
index|]
operator|.
name|cur
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|error
operator|&&
operator|(
name|rescan
operator|||
operator|(
name|c
operator|=
name|fgetc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|)
condition|)
block|{
name|rescan
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|start_of_line
case|:
name|lnum
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
name|state
operator|=
name|start_of_comment
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
switch|switch
condition|(
name|section
condition|)
block|{
case|case
name|info
case|:
case|case
name|ea
case|:
name|state
operator|=
name|get_keyseq
expr_stmt|;
name|seqstate
operator|=
name|normal
expr_stmt|;
name|slen
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|var
case|:
name|state
operator|=
name|get_varname
expr_stmt|;
name|varlen
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|rescan
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|start_of_comment
case|:
name|clen
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|in_line_comment
expr_stmt|;
comment|/* fall through */
case|case
name|in_line_comment
case|:
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|state
operator|=
name|start_of_line
expr_stmt|;
name|comment
index|[
name|clen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|comment
argument_list|,
literal|"info"
argument_list|)
operator|==
literal|0
condition|)
name|section
operator|=
name|info
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|comment
argument_list|,
literal|"echo-area"
argument_list|)
operator|==
literal|0
condition|)
name|section
operator|=
name|ea
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|comment
argument_list|,
literal|"var"
argument_list|)
operator|==
literal|0
condition|)
name|section
operator|=
name|var
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|comment
argument_list|,
literal|"stop"
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|section
operator|==
name|info
operator|||
name|section
operator|==
name|ea
operator|)
condition|)
name|sections
index|[
name|section
index|]
operator|.
name|data
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|clen
operator|<
sizeof|sizeof
name|comment
operator|-
literal|1
condition|)
name|comment
index|[
name|clen
operator|++
index|]
operator|=
name|c
expr_stmt|;
break|break;
case|case
name|in_trailing_comment
case|:
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|state
operator|=
name|start_of_line
expr_stmt|;
break|break;
case|case
name|get_keyseq
case|:
switch|switch
condition|(
name|seqstate
condition|)
block|{
case|case
name|normal
case|:
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|state
operator|=
name|got_keyseq
expr_stmt|;
name|rescan
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|slen
operator|==
literal|0
condition|)
block|{
name|syntax_error
argument_list|(
name|filename
argument_list|,
name|lnum
argument_list|,
name|_
argument_list|(
literal|"missing key sequence"
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|seqstate
operator|=
name|slosh
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'^'
condition|)
name|seqstate
operator|=
name|control
expr_stmt|;
else|else
name|To_seq
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|slosh
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|seqstate
operator|=
name|octal
expr_stmt|;
name|oval
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
name|ocnt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|To_seq
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
name|seqstate
operator|=
name|normal
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|To_seq
argument_list|(
literal|'\033'
argument_list|)
expr_stmt|;
name|seqstate
operator|=
name|normal
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|To_seq
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|seqstate
operator|=
name|normal
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|To_seq
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|seqstate
operator|=
name|normal
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|To_seq
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|seqstate
operator|=
name|normal
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|meta
operator|=
literal|1
expr_stmt|;
name|seqstate
operator|=
name|normal
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|seqstate
operator|=
name|special_key
expr_stmt|;
break|break;
default|default:
comment|/* Backslash followed by any other char 		     just means that char.  */
name|To_seq
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|seqstate
operator|=
name|normal
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|octal
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
if|if
condition|(
operator|++
name|ocnt
operator|<=
literal|3
condition|)
name|oval
operator|=
name|oval
operator|*
literal|8
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|ocnt
operator|==
literal|3
condition|)
name|seqstate
operator|=
name|normal
expr_stmt|;
break|break;
default|default:
name|ocnt
operator|=
literal|4
expr_stmt|;
name|seqstate
operator|=
name|normal
expr_stmt|;
name|rescan
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|seqstate
operator|!=
name|octal
condition|)
block|{
if|if
condition|(
name|oval
condition|)
name|To_seq
argument_list|(
name|oval
argument_list|)
expr_stmt|;
else|else
block|{
name|syntax_error
argument_list|(
name|filename
argument_list|,
name|lnum
argument_list|,
name|_
argument_list|(
literal|"NUL character (\\000) not permitted"
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|special_key
case|:
name|To_seq
argument_list|(
name|SK_ESCAPE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'u'
case|:
name|To_seq
argument_list|(
name|SK_UP_ARROW
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|To_seq
argument_list|(
name|SK_DOWN_ARROW
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|To_seq
argument_list|(
name|SK_RIGHT_ARROW
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|To_seq
argument_list|(
name|SK_LEFT_ARROW
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|To_seq
argument_list|(
name|SK_PAGE_UP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|To_seq
argument_list|(
name|SK_PAGE_DOWN
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|To_seq
argument_list|(
name|SK_HOME
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|To_seq
argument_list|(
name|SK_END
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|To_seq
argument_list|(
name|SK_DELETE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|To_seq
argument_list|(
name|SK_LITERAL
argument_list|)
expr_stmt|;
name|rescan
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|seqstate
operator|=
name|normal
expr_stmt|;
break|break;
case|case
name|control
case|:
if|if
condition|(
name|CONTROL
argument_list|(
name|c
argument_list|)
condition|)
name|To_seq
argument_list|(
name|CONTROL
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|syntax_error
argument_list|(
name|filename
argument_list|,
name|lnum
argument_list|,
name|_
argument_list|(
literal|"NUL character (^%c) not permitted"
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
name|seqstate
operator|=
name|normal
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|got_keyseq
case|:
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
break|break;
name|state
operator|=
name|get_action
expr_stmt|;
name|alen
operator|=
literal|0
expr_stmt|;
comment|/* fall through */
case|case
name|get_action
case|:
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|int
name|a
decl_stmt|;
name|state
operator|=
name|got_action
expr_stmt|;
name|rescan
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|alen
operator|==
literal|0
condition|)
block|{
name|syntax_error
argument_list|(
name|filename
argument_list|,
name|lnum
argument_list|,
name|_
argument_list|(
literal|"missing action name"
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|act
index|[
name|alen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|a
operator|=
name|lookup_action
argument_list|(
name|act
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|!=
operator|-
literal|1
condition|)
block|{
name|char
name|av
init|=
name|a
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|add_to_section
argument_list|(
operator|&
name|sections
index|[
name|section
index|]
argument_list|,
name|seq
argument_list|,
name|slen
argument_list|)
operator|&&
name|add_to_section
argument_list|(
operator|&
name|sections
index|[
name|section
index|]
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
operator|&&
name|add_to_section
argument_list|(
operator|&
name|sections
index|[
name|section
index|]
argument_list|,
operator|&
name|av
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|syntax_error
argument_list|(
name|filename
argument_list|,
name|lnum
argument_list|,
name|_
argument_list|(
literal|"section too long"
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|syntax_error
argument_list|(
name|filename
argument_list|,
name|lnum
argument_list|,
name|_
argument_list|(
literal|"unknown action `%s'"
argument_list|)
argument_list|,
name|act
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|alen
operator|<
sizeof|sizeof
name|act
operator|-
literal|1
condition|)
name|act
index|[
name|alen
operator|++
index|]
operator|=
name|c
expr_stmt|;
else|else
block|{
name|syntax_error
argument_list|(
name|filename
argument_list|,
name|lnum
argument_list|,
name|_
argument_list|(
literal|"action name too long"
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|got_action
case|:
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
name|state
operator|=
name|in_trailing_comment
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|state
operator|=
name|start_of_line
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|syntax_error
argument_list|(
name|filename
argument_list|,
name|lnum
argument_list|,
name|_
argument_list|(
literal|"extra characters following action `%s'"
argument_list|)
argument_list|,
name|act
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|get_varname
case|:
if|if
condition|(
name|c
operator|==
literal|'='
condition|)
block|{
if|if
condition|(
name|varlen
operator|==
literal|0
condition|)
block|{
name|syntax_error
argument_list|(
name|filename
argument_list|,
name|lnum
argument_list|,
name|_
argument_list|(
literal|"missing variable name"
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
name|state
operator|=
name|get_value
expr_stmt|;
name|vallen
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|syntax_error
argument_list|(
name|filename
argument_list|,
name|lnum
argument_list|,
name|_
argument_list|(
literal|"missing `=' immediately after variable name"
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|varlen
operator|<
sizeof|sizeof
name|varn
condition|)
name|varn
index|[
name|varlen
operator|++
index|]
operator|=
name|c
expr_stmt|;
else|else
block|{
name|syntax_error
argument_list|(
name|filename
argument_list|,
name|lnum
argument_list|,
name|_
argument_list|(
literal|"variable name too long"
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|get_value
case|:
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|state
operator|=
name|start_of_line
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|add_to_section
argument_list|(
operator|&
name|sections
index|[
name|section
index|]
argument_list|,
name|varn
argument_list|,
name|varlen
argument_list|)
operator|&&
name|add_to_section
argument_list|(
operator|&
name|sections
index|[
name|section
index|]
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
operator|&&
name|add_to_section
argument_list|(
operator|&
name|sections
index|[
name|section
index|]
argument_list|,
name|val
argument_list|,
name|vallen
argument_list|)
operator|&&
name|add_to_section
argument_list|(
operator|&
name|sections
index|[
name|section
index|]
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|syntax_error
argument_list|(
name|filename
argument_list|,
name|lnum
argument_list|,
name|_
argument_list|(
literal|"section too long"
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|vallen
operator|<
sizeof|sizeof
name|val
condition|)
name|val
index|[
name|vallen
operator|++
index|]
operator|=
name|c
expr_stmt|;
else|else
block|{
name|syntax_error
argument_list|(
name|filename
argument_list|,
name|lnum
argument_list|,
name|_
argument_list|(
literal|"value too long"
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
undef|#
directive|undef
name|To_seq
return|return
operator|!
name|error
return|;
block|}
end_function

begin_comment
comment|/* Add some characters to a section's data.  Return true if all the    characters fit, or false if the section's size limit was exceeded.  */
end_comment

begin_function
specifier|static
name|int
name|add_to_section
parameter_list|(
name|s
parameter_list|,
name|str
parameter_list|,
name|len
parameter_list|)
name|struct
name|sect
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|->
name|cur
operator|+
name|len
operator|>
sizeof|sizeof
name|s
operator|->
name|data
condition|)
return|return
literal|0
return|;
name|strncpy
argument_list|(
name|s
operator|->
name|data
operator|+
name|s
operator|->
name|cur
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|->
name|cur
operator|+=
name|len
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Translate from an action name to its numeric code.  This uses the    auto-generated array in key.c.  */
end_comment

begin_function
specifier|static
name|int
name|lookup_action
parameter_list|(
name|actname
parameter_list|)
specifier|const
name|char
modifier|*
name|actname
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
literal|"invalid"
argument_list|,
name|actname
argument_list|)
operator|==
literal|0
condition|)
return|return
name|A_INVALID
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|function_key_array
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|function_key_array
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|actname
argument_list|)
operator|==
literal|0
condition|)
return|return
name|function_key_array
index|[
name|i
index|]
operator|.
name|code
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Put an integer to an infokey file.    Integers are stored as two bytes, low order first,    in radix INFOKEY_RADIX.  */
end_comment

begin_function
specifier|static
name|int
name|putint
parameter_list|(
name|i
parameter_list|,
name|fp
parameter_list|)
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
return|return
name|fputc
argument_list|(
name|i
operator|%
name|INFOKEY_RADIX
argument_list|,
name|fp
argument_list|)
operator|!=
name|EOF
operator|&&
name|fputc
argument_list|(
operator|(
name|i
operator|/
name|INFOKEY_RADIX
operator|)
operator|%
name|INFOKEY_RADIX
argument_list|,
name|fp
argument_list|)
operator|!=
name|EOF
return|;
block|}
end_function

begin_comment
comment|/* Write an entire section to an infokey file.  If the section is    empty, simply omit it.  */
end_comment

begin_function
specifier|static
name|int
name|putsect
parameter_list|(
name|s
parameter_list|,
name|code
parameter_list|,
name|fp
parameter_list|)
name|struct
name|sect
modifier|*
name|s
decl_stmt|;
name|int
name|code
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|->
name|cur
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
name|fputc
argument_list|(
name|code
argument_list|,
name|fp
argument_list|)
operator|!=
name|EOF
operator|&&
name|putint
argument_list|(
name|s
operator|->
name|cur
argument_list|,
name|fp
argument_list|)
operator|&&
name|fwrite
argument_list|(
name|s
operator|->
name|data
argument_list|,
name|s
operator|->
name|cur
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
operator|==
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Write an entire infokey file, given an array containing its sections.  */
end_comment

begin_function
specifier|static
name|int
name|write_infokey_file
parameter_list|(
name|fp
parameter_list|,
name|sections
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|sect
name|sections
index|[]
decl_stmt|;
block|{
comment|/* Get rid of sections with no effect. */
if|if
condition|(
name|sections
index|[
name|info
index|]
operator|.
name|cur
operator|==
literal|1
operator|&&
name|sections
index|[
name|info
index|]
operator|.
name|data
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|sections
index|[
name|info
index|]
operator|.
name|cur
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sections
index|[
name|ea
index|]
operator|.
name|cur
operator|==
literal|1
operator|&&
name|sections
index|[
name|ea
index|]
operator|.
name|data
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|sections
index|[
name|ea
index|]
operator|.
name|cur
operator|=
literal|0
expr_stmt|;
comment|/* Write all parts of the file out in order (no lseeks),      checking for errors all the way. */
return|return
name|fputc
argument_list|(
name|INFOKEY_MAGIC_S0
argument_list|,
name|fp
argument_list|)
operator|!=
name|EOF
operator|&&
name|fputc
argument_list|(
name|INFOKEY_MAGIC_S1
argument_list|,
name|fp
argument_list|)
operator|!=
name|EOF
operator|&&
name|fputc
argument_list|(
name|INFOKEY_MAGIC_S2
argument_list|,
name|fp
argument_list|)
operator|!=
name|EOF
operator|&&
name|fputc
argument_list|(
name|INFOKEY_MAGIC_S3
argument_list|,
name|fp
argument_list|)
operator|!=
name|EOF
operator|&&
name|fputs
argument_list|(
name|VERSION
argument_list|,
name|fp
argument_list|)
operator|!=
name|EOF
operator|&&
name|fputc
argument_list|(
literal|'\0'
argument_list|,
name|fp
argument_list|)
operator|!=
name|EOF
operator|&&
name|putsect
argument_list|(
operator|&
name|sections
index|[
name|info
index|]
argument_list|,
name|INFOKEY_SECTION_INFO
argument_list|,
name|fp
argument_list|)
operator|&&
name|putsect
argument_list|(
operator|&
name|sections
index|[
name|ea
index|]
argument_list|,
name|INFOKEY_SECTION_EA
argument_list|,
name|fp
argument_list|)
operator|&&
name|putsect
argument_list|(
operator|&
name|sections
index|[
name|var
index|]
argument_list|,
name|INFOKEY_SECTION_VAR
argument_list|,
name|fp
argument_list|)
operator|&&
name|fputc
argument_list|(
name|INFOKEY_MAGIC_E0
argument_list|,
name|fp
argument_list|)
operator|!=
name|EOF
operator|&&
name|fputc
argument_list|(
name|INFOKEY_MAGIC_E1
argument_list|,
name|fp
argument_list|)
operator|!=
name|EOF
operator|&&
name|fputc
argument_list|(
name|INFOKEY_MAGIC_E2
argument_list|,
name|fp
argument_list|)
operator|!=
name|EOF
operator|&&
name|fputc
argument_list|(
name|INFOKEY_MAGIC_E3
argument_list|,
name|fp
argument_list|)
operator|!=
name|EOF
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Error handling. */
end_comment

begin_comment
comment|/* Give the user a "syntax error" message in the form 	progname: "filename", line N: message  */
end_comment

begin_function
specifier|static
name|void
name|error_message
parameter_list|(
name|error_code
parameter_list|,
name|fmt
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|,
name|a3
parameter_list|,
name|a4
parameter_list|)
name|int
name|error_code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|const
name|void
modifier|*
name|a1
decl_stmt|,
decl|*
name|a2
decl_stmt|,
modifier|*
name|a3
decl_stmt|,
modifier|*
name|a4
decl_stmt|;
end_function

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_code
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" - %s"
argument_list|,
name|strerror
argument_list|(
name|error_code
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Give the user a generic error message in the form 	progname: message  */
end_comment

begin_function
specifier|static
name|void
name|syntax_error
parameter_list|(
name|filename
parameter_list|,
name|linenum
parameter_list|,
name|fmt
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|,
name|a3
parameter_list|,
name|a4
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|unsigned
name|int
name|linenum
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|const
name|void
modifier|*
name|a1
decl_stmt|,
decl|*
name|a2
decl_stmt|,
modifier|*
name|a3
decl_stmt|,
modifier|*
name|a4
decl_stmt|;
end_function

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"\"%s\", line %u: "
argument_list|)
argument_list|,
name|filename
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Produce a gentle rtfm. */
end_comment

begin_function
specifier|static
name|void
name|suggest_help
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Try --help for more information.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Produce a scaled down description of the available options to Info. */
end_comment

begin_function
specifier|static
name|void
name|short_help
parameter_list|()
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ Usage: %s [OPTION]... [INPUT-FILE]\n\ \n\ Compile infokey source file to infokey file.  Reads INPUT-FILE (default\n\ $HOME/.infokey) and writes compiled key file to (by default) $HOME/.info.\n\ \n\ Options:\n\   --output FILE        output to FILE instead of $HOME/.info\n\   --help               display this help and exit.\n\   --version            display version information and exit.\n\ "
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|puts
argument_list|(
name|_
argument_list|(
literal|"\n\ Email bug reports to bug-texinfo@gnu.org,\n\ general questions and discussion to help-texinfo@gnu.org.\n\ Texinfo home page: http://www.gnu.org/software/texinfo/"
argument_list|)
argument_list|)
expr_stmt|;
name|xexit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

