begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002-2013 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 2004-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_sm_state_mgr_t.  * This file implements the SM State Manager object.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_passivelock.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_SM_STATE_MGR_C
end_define

begin_include
include|#
directive|include
file|<opensm/osm_sm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_madw.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_switch.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_subnet.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_msgdef.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_node.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_port.h>
end_include

begin_include
include|#
directive|include
file|<vendor/osm_vendor_api.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_function
name|void
name|osm_report_sm_state
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|state_str
init|=
name|osm_get_sm_mgr_state_str
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
argument_list|)
decl_stmt|;
name|osm_log_v2
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
name|FILE_ID
argument_list|,
literal|"Entering %s state\n"
argument_list|,
name|state_str
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"ENTERING SM %s STATE"
argument_list|,
name|state_str
argument_list|)
expr_stmt|;
name|OSM_LOG_MSG_BOX
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|sm_state_mgr_send_master_sm_info_req
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|uint8_t
name|sm_state
parameter_list|)
block|{
name|osm_madw_context_t
name|context
decl_stmt|;
specifier|const
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|osm_dr_path_t
name|dr_path
decl_stmt|;
name|ib_net64_t
name|guid
decl_stmt|;
name|boolean_t
name|sent_req
init|=
name|FALSE
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm_state
operator|==
name|IB_SMINFO_STATE_STANDBY
condition|)
block|{
comment|/* 		 * We are in STANDBY state - this means we need to poll the 		 * master SM (according to master_guid). 		 * Send a query of SubnGet(SMInfo) to the subn 		 * master_sm_base_lid object. 		 */
name|guid
operator|=
name|sm
operator|->
name|master_sm_guid
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We are not in STANDBY - this means we are in MASTER state - 		 * so we need to poll the SM that is saved in polling_sm_guid 		 * under sm. 		 * Send a query of SubnGet(SMInfo) to that SM. 		 */
name|guid
operator|=
name|sm
operator|->
name|polling_sm_guid
expr_stmt|;
block|}
comment|/* Verify that SM is not polling itself */
if|if
condition|(
name|guid
operator|==
name|sm
operator|->
name|p_subn
operator|->
name|sm_port_guid
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"OpenSM doesn't poll itself\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_port
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3203: "
literal|"No port object for GUID 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|guid
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|context
operator|.
name|smi_context
operator|.
name|port_guid
operator|=
name|guid
expr_stmt|;
name|context
operator|.
name|smi_context
operator|.
name|set_method
operator|=
name|FALSE
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|dr_path
argument_list|,
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_port
operator|->
name|p_physp
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|osm_dr_path_t
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
operator|&
name|dr_path
argument_list|,
name|IB_MAD_ATTR_SM_INFO
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|ib_port_info_get_m_key
argument_list|(
operator|&
name|p_port
operator|->
name|p_physp
operator|->
name|port_info
argument_list|)
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3204: "
literal|"Failure requesting SMInfo (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sent_req
operator|=
name|TRUE
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|sent_req
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sm_state_mgr_start_polling
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|uint32_t
name|timeout
decl_stmt|;
name|cl_status_t
name|cl_status
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	 * Init the retry_number back to zero - need to restart counting 	 */
name|sm
operator|->
name|retry_number
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Send a SubnGet(SMInfo) query to the current (or new) master found. 	 */
name|CL_PLOCK_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|timeout
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|sminfo_polling_timeout
expr_stmt|;
name|sm_state_mgr_send_master_sm_info_req
argument_list|(
name|sm
argument_list|,
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Start a timer that will wake up every sminfo_polling_timeout milliseconds. 	 * The callback of the timer will send a SubnGet(SMInfo) to the Master SM 	 * and restart the timer 	 */
name|cl_status
operator|=
name|cl_timer_start
argument_list|(
operator|&
name|sm
operator|->
name|polling_timer
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl_status
operator|!=
name|CL_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3210: "
literal|"Failed to start polling timer\n"
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_sm_state_mgr_polling_callback
parameter_list|(
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
name|osm_sm_t
modifier|*
name|sm
init|=
name|context
decl_stmt|;
name|uint32_t
name|timeout
decl_stmt|;
name|cl_status_t
name|cl_status
decl_stmt|;
name|uint8_t
name|sm_state
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|cl_spinlock_acquire
argument_list|(
operator|&
name|sm
operator|->
name|state_lock
argument_list|)
expr_stmt|;
name|sm_state
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
expr_stmt|;
name|cl_spinlock_release
argument_list|(
operator|&
name|sm
operator|->
name|state_lock
argument_list|)
expr_stmt|;
name|CL_PLOCK_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|timeout
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|sminfo_polling_timeout
expr_stmt|;
comment|/* 	 * We can be here in one of two cases: 	 * 1. We are a STANDBY sm polling on the master SM. 	 * 2. We are a MASTER sm, waiting for a handover from a remote master sm. 	 * If we are not in one of these cases - don't need to restart the poller. 	 */
if|if
condition|(
operator|!
operator|(
operator|(
name|sm_state
operator|==
name|IB_SMINFO_STATE_MASTER
operator|&&
name|sm
operator|->
name|polling_sm_guid
operator|!=
literal|0
operator|)
operator|||
name|sm_state
operator|==
name|IB_SMINFO_STATE_STANDBY
operator|)
condition|)
block|{
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	 * If we are a STANDBY sm and the osm_exit_flag is set, then let's 	 * signal the subnet_up. This is relevant for the case of running only 	 * once. In that case - the program is stuck until this signal is 	 * received. In other cases - it is not relevant whether or not the 	 * signal is on - since we are currently in exit flow 	 */
if|if
condition|(
name|sm_state
operator|==
name|IB_SMINFO_STATE_STANDBY
operator|&&
name|osm_exit_flag
condition|)
block|{
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Signalling subnet_up_event\n"
argument_list|)
expr_stmt|;
name|cl_event_signal
argument_list|(
operator|&
name|sm
operator|->
name|subnet_up_event
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	 * If retry number reached the max_retry_number in the subnet opt - call 	 * osm_sm_state_mgr_process with signal OSM_SM_SIGNAL_POLLING_TIMEOUT 	 */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"SM State %d (%s), Retry number:%d\n"
argument_list|,
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
argument_list|,
name|osm_get_sm_mgr_state_str
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
argument_list|)
argument_list|,
name|sm
operator|->
name|retry_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|retry_number
operator|>
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|polling_retry_number
condition|)
block|{
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Reached polling_retry_number value in retry_number. "
literal|"Go to DISCOVERY state\n"
argument_list|)
expr_stmt|;
name|osm_sm_state_mgr_process
argument_list|(
name|sm
argument_list|,
name|OSM_SM_SIGNAL_POLLING_TIMEOUT
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Send a SubnGet(SMInfo) request to the remote sm (depends on our state) */
if|if
condition|(
name|sm_state_mgr_send_master_sm_info_req
argument_list|(
name|sm
argument_list|,
name|sm_state
argument_list|)
condition|)
block|{
comment|/* Request sent, increment the retry number */
name|sm
operator|->
name|retry_number
operator|++
expr_stmt|;
block|}
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
comment|/* restart the timer */
name|cl_status
operator|=
name|cl_timer_start
argument_list|(
operator|&
name|sm
operator|->
name|polling_timer
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl_status
operator|!=
name|CL_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3211: "
literal|"Failed to restart polling timer\n"
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sm_state_mgr_signal_error
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_sm_signal_t
name|signal
parameter_list|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3207: "
literal|"Invalid signal %s in state %s\n"
argument_list|,
name|osm_get_sm_mgr_signal_str
argument_list|(
name|signal
argument_list|)
argument_list|,
name|osm_get_sm_mgr_state_str
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_sm_state_mgr_signal_master_is_alive
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|sm
operator|->
name|retry_number
operator|=
literal|0
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ib_api_status_t
name|osm_sm_state_mgr_process
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_sm_signal_t
name|signal
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	 * The state lock prevents many race conditions from screwing 	 * up the state transition process. 	 */
name|cl_spinlock_acquire
argument_list|(
operator|&
name|sm
operator|->
name|state_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Received signal %s in state %s\n"
argument_list|,
name|osm_get_sm_mgr_signal_str
argument_list|(
name|signal
argument_list|)
argument_list|,
name|osm_get_sm_mgr_state_str
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
condition|)
block|{
case|case
name|IB_SMINFO_STATE_DISCOVERING
case|:
switch|switch
condition|(
name|signal
condition|)
block|{
case|case
name|OSM_SM_SIGNAL_DISCOVERY_COMPLETED
case|:
comment|/* 			 * Update the state of the SM to MASTER 			 */
comment|/* Turn on the first_time_master_sweep flag */
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
operator|=
name|IB_SMINFO_STATE_MASTER
expr_stmt|;
name|osm_report_sm_state
argument_list|(
name|sm
argument_list|)
expr_stmt|;
comment|/* 			 * Make sure to set the subnet master_sm_base_lid 			 * to the sm_base_lid value 			 */
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|first_time_master_sweep
operator|=
name|TRUE
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|master_sm_base_lid
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|sm_base_lid
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|OSM_SM_SIGNAL_MASTER_OR_HIGHER_SM_DETECTED
case|:
comment|/* 			 * Finished all discovery actions - move to STANDBY 			 * start the polling 			 */
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
operator|=
name|IB_SMINFO_STATE_STANDBY
expr_stmt|;
name|osm_report_sm_state
argument_list|(
name|sm
argument_list|)
expr_stmt|;
comment|/* 			 * Since another SM is doing the LFT config - we should not 			 * ignore the results of it 			 */
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|ignore_existing_lfts
operator|=
name|FALSE
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|sm_state_mgr_start_polling
argument_list|(
name|sm
argument_list|)
expr_stmt|;
break|break;
case|case
name|OSM_SM_SIGNAL_HANDOVER
case|:
comment|/* 			 * Signal for a new sweep. We need to discover the other SM. 			 * If we already discovered this SM, and got the 			 * HANDOVER - this means the remote SM is of lower priority. 			 * In this case we will stop polling it (since it is a lower 			 * priority SM in STANDBY state). 			 */
name|osm_sm_signal
argument_list|(
name|sm
argument_list|,
name|OSM_SIGNAL_SWEEP
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sm_state_mgr_signal_error
argument_list|(
name|sm
argument_list|,
name|signal
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_INVALID_PARAMETER
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|IB_SMINFO_STATE_STANDBY
case|:
switch|switch
condition|(
name|signal
condition|)
block|{
case|case
name|OSM_SM_SIGNAL_POLLING_TIMEOUT
case|:
case|case
name|OSM_SM_SIGNAL_DISCOVER
case|:
comment|/* 			 * case 1: Polling timeout occured - this means that the Master SM 			 * is no longer alive. 			 * case 2: Got a signal to move to DISCOVERING 			 * Move to DISCOVERING state and start sweeping 			 */
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
operator|=
name|IB_SMINFO_STATE_DISCOVERING
expr_stmt|;
name|osm_report_sm_state
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|coming_out_of_standby
operator|=
name|TRUE
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|osm_sm_signal
argument_list|(
name|sm
argument_list|,
name|OSM_SIGNAL_SWEEP
argument_list|)
expr_stmt|;
break|break;
case|case
name|OSM_SM_SIGNAL_DISABLE
case|:
comment|/* 			 * Update the state to NOT_ACTIVE 			 */
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
operator|=
name|IB_SMINFO_STATE_NOTACTIVE
expr_stmt|;
name|osm_report_sm_state
argument_list|(
name|sm
argument_list|)
expr_stmt|;
break|break;
case|case
name|OSM_SM_SIGNAL_HANDOVER
case|:
comment|/* 			 * Update the state to MASTER, and start sweeping 			 * OPTIONAL: send ACKNOWLEDGE 			 */
comment|/* Turn on the force_first_time_master_sweep flag */
comment|/* We want full reconfiguration to occur on the first */
comment|/* master sweep of this SM */
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
comment|/* 			 * Make sure to set the subnet master_sm_base_lid 			 * to the sm_base_lid value 			 */
name|sm
operator|->
name|p_subn
operator|->
name|master_sm_base_lid
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|sm_base_lid
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|force_first_time_master_sweep
operator|=
name|TRUE
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
operator|=
name|IB_SMINFO_STATE_MASTER
expr_stmt|;
name|osm_report_sm_state
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|osm_sm_signal
argument_list|(
name|sm
argument_list|,
name|OSM_SIGNAL_SWEEP
argument_list|)
expr_stmt|;
break|break;
case|case
name|OSM_SM_SIGNAL_ACKNOWLEDGE
case|:
comment|/* 			 * Do nothing - already moved to STANDBY 			 */
break|break;
default|default:
name|sm_state_mgr_signal_error
argument_list|(
name|sm
argument_list|,
name|signal
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_INVALID_PARAMETER
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|IB_SMINFO_STATE_NOTACTIVE
case|:
switch|switch
condition|(
name|signal
condition|)
block|{
case|case
name|OSM_SM_SIGNAL_STANDBY
case|:
comment|/* 			 * Update the state to STANDBY 			 * start the polling 			 */
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
operator|=
name|IB_SMINFO_STATE_STANDBY
expr_stmt|;
name|osm_report_sm_state
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|sm_state_mgr_start_polling
argument_list|(
name|sm
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sm_state_mgr_signal_error
argument_list|(
name|sm
argument_list|,
name|signal
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_INVALID_PARAMETER
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|IB_SMINFO_STATE_MASTER
case|:
switch|switch
condition|(
name|signal
condition|)
block|{
case|case
name|OSM_SM_SIGNAL_POLLING_TIMEOUT
case|:
comment|/* 			 * We received a polling timeout - this means that we 			 * waited for a remote master sm to send us a handover, 			 * but didn't get it, and didn't get a response from 			 * that remote sm. 			 * We want to force a heavy sweep - hopefully this 			 * occurred because the remote sm died, and we'll find 			 * this out and configure the subnet after a heavy sweep. 			 * We also want to clear the polling_sm_guid - since 			 * we are done polling on that remote sm - we are 			 * sweeping again. 			 */
case|case
name|OSM_SM_SIGNAL_HANDOVER
case|:
comment|/* 			 * If we received a handover in a master state - then we 			 * want to force a heavy sweep. This means that either 			 * we are in a sweep currently - in this case - no 			 * change, or we are in idle state - since we 			 * recognized a master SM before - so we want to make a 			 * heavy sweep and reconfigure the new subnet. 			 * We also want to clear the polling_sm_guid - since 			 * we are done polling on that remote sm - we got a 			 * handover from it. 			 */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Forcing heavy sweep. Received signal %s\n"
argument_list|,
name|osm_get_sm_mgr_signal_str
argument_list|(
name|signal
argument_list|)
argument_list|)
expr_stmt|;
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|sm
operator|->
name|polling_sm_guid
operator|=
literal|0
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|force_first_time_master_sweep
operator|=
name|TRUE
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|osm_sm_signal
argument_list|(
name|sm
argument_list|,
name|OSM_SIGNAL_SWEEP
argument_list|)
expr_stmt|;
break|break;
case|case
name|OSM_SM_SIGNAL_HANDOVER_SENT
case|:
comment|/* 			 * Just sent a HANDOVER signal - move to STANDBY 			 * start the polling 			 */
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
operator|=
name|IB_SMINFO_STATE_STANDBY
expr_stmt|;
name|osm_report_sm_state
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|sm_state_mgr_start_polling
argument_list|(
name|sm
argument_list|)
expr_stmt|;
break|break;
case|case
name|OSM_SM_SIGNAL_WAIT_FOR_HANDOVER
case|:
comment|/* 			 * We found a remote master SM, and we are waiting for 			 * it to handover the mastership to us. Need to start 			 * polling that SM, to make sure it is alive, if it 			 * isn't - then we should move back to discovering, 			 * since something must have happened to it. 			 */
name|sm_state_mgr_start_polling
argument_list|(
name|sm
argument_list|)
expr_stmt|;
break|break;
case|case
name|OSM_SM_SIGNAL_DISCOVER
case|:
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
operator|=
name|IB_SMINFO_STATE_DISCOVERING
expr_stmt|;
name|osm_report_sm_state
argument_list|(
name|sm
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sm_state_mgr_signal_error
argument_list|(
name|sm
argument_list|,
name|signal
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_INVALID_PARAMETER
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3208: "
literal|"Invalid state %s\n"
argument_list|,
name|osm_get_sm_mgr_state_str
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cl_spinlock_release
argument_list|(
operator|&
name|sm
operator|->
name|state_lock
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|ib_api_status_t
name|osm_sm_state_mgr_check_legality
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_sm_signal_t
name|signal
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	 * The state lock prevents many race conditions from screwing 	 * up the state transition process. 	 */
name|cl_spinlock_acquire
argument_list|(
operator|&
name|sm
operator|->
name|state_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Received signal %s in state %s\n"
argument_list|,
name|osm_get_sm_mgr_signal_str
argument_list|(
name|signal
argument_list|)
argument_list|,
name|osm_get_sm_mgr_state_str
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
condition|)
block|{
case|case
name|IB_SMINFO_STATE_DISCOVERING
case|:
switch|switch
condition|(
name|signal
condition|)
block|{
case|case
name|OSM_SM_SIGNAL_DISCOVERY_COMPLETED
case|:
case|case
name|OSM_SM_SIGNAL_MASTER_OR_HIGHER_SM_DETECTED
case|:
case|case
name|OSM_SM_SIGNAL_HANDOVER
case|:
name|status
operator|=
name|IB_SUCCESS
expr_stmt|;
break|break;
default|default:
name|sm_state_mgr_signal_error
argument_list|(
name|sm
argument_list|,
name|signal
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_INVALID_PARAMETER
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|IB_SMINFO_STATE_STANDBY
case|:
switch|switch
condition|(
name|signal
condition|)
block|{
case|case
name|OSM_SM_SIGNAL_POLLING_TIMEOUT
case|:
case|case
name|OSM_SM_SIGNAL_DISCOVER
case|:
case|case
name|OSM_SM_SIGNAL_DISABLE
case|:
case|case
name|OSM_SM_SIGNAL_HANDOVER
case|:
case|case
name|OSM_SM_SIGNAL_ACKNOWLEDGE
case|:
name|status
operator|=
name|IB_SUCCESS
expr_stmt|;
break|break;
default|default:
name|sm_state_mgr_signal_error
argument_list|(
name|sm
argument_list|,
name|signal
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_INVALID_PARAMETER
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|IB_SMINFO_STATE_NOTACTIVE
case|:
switch|switch
condition|(
name|signal
condition|)
block|{
case|case
name|OSM_SM_SIGNAL_STANDBY
case|:
name|status
operator|=
name|IB_SUCCESS
expr_stmt|;
break|break;
default|default:
name|sm_state_mgr_signal_error
argument_list|(
name|sm
argument_list|,
name|signal
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_INVALID_PARAMETER
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|IB_SMINFO_STATE_MASTER
case|:
switch|switch
condition|(
name|signal
condition|)
block|{
case|case
name|OSM_SM_SIGNAL_HANDOVER
case|:
case|case
name|OSM_SM_SIGNAL_HANDOVER_SENT
case|:
name|status
operator|=
name|IB_SUCCESS
expr_stmt|;
break|break;
default|default:
name|sm_state_mgr_signal_error
argument_list|(
name|sm
argument_list|,
name|signal
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_INVALID_PARAMETER
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3209: "
literal|"Invalid state %s\n"
argument_list|,
name|osm_get_sm_mgr_state_str
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_INVALID_PARAMETER
expr_stmt|;
block|}
name|cl_spinlock_release
argument_list|(
operator|&
name|sm
operator|->
name|state_lock
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

end_unit

