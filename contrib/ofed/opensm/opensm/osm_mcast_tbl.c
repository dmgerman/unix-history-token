begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2009 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  * Copyright (c) 2009 HNR Consulting. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_mcast_tbl_t.  * This object represents a multicast forwarding table.  * This object is part of the opensm family of objects.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_math.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_MCAST_TBL_C
end_define

begin_include
include|#
directive|include
file|<opensm/osm_mcast_tbl.h>
end_include

begin_function
name|void
name|osm_mcast_tbl_init
parameter_list|(
name|IN
name|osm_mcast_tbl_t
modifier|*
name|p_tbl
parameter_list|,
name|IN
name|uint8_t
name|num_ports
parameter_list|,
name|IN
name|uint16_t
name|capacity
parameter_list|)
block|{
name|CL_ASSERT
argument_list|(
name|p_tbl
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|num_ports
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_tbl
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_tbl
argument_list|)
argument_list|)
expr_stmt|;
name|p_tbl
operator|->
name|max_block_in_use
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|capacity
operator|==
literal|0
condition|)
block|{
comment|/* 		   This switch apparently doesn't support multicast. 		   Everything is initialized to zero already, so return. 		 */
return|return;
block|}
name|p_tbl
operator|->
name|num_entries
operator|=
name|capacity
expr_stmt|;
name|p_tbl
operator|->
name|num_ports
operator|=
name|num_ports
expr_stmt|;
name|p_tbl
operator|->
name|max_position
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|ROUNDUP
argument_list|(
name|num_ports
argument_list|,
name|IB_MCAST_MASK_SIZE
argument_list|)
operator|/
name|IB_MCAST_MASK_SIZE
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p_tbl
operator|->
name|max_block
operator|=
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|ROUNDUP
argument_list|(
name|p_tbl
operator|->
name|num_entries
argument_list|,
name|IB_MCAST_BLOCK_SIZE
argument_list|)
operator|/
name|IB_MCAST_BLOCK_SIZE
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_mcast_tbl_destroy
parameter_list|(
name|IN
name|osm_mcast_tbl_t
modifier|*
name|p_tbl
parameter_list|)
block|{
name|free
argument_list|(
name|p_tbl
operator|->
name|p_mask_tbl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_mcast_tbl_set
parameter_list|(
name|IN
name|osm_mcast_tbl_t
modifier|*
name|p_tbl
parameter_list|,
name|IN
name|uint16_t
name|mlid_ho
parameter_list|,
name|IN
name|uint8_t
name|port
parameter_list|)
block|{
name|unsigned
name|mlid_offset
decl_stmt|,
name|mask_offset
decl_stmt|,
name|bit_mask
decl_stmt|;
name|int16_t
name|block_num
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_tbl
operator|&&
name|p_tbl
operator|->
name|p_mask_tbl
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|mlid_ho
operator|>=
name|IB_LID_MCAST_START_HO
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|mlid_ho
operator|<=
name|p_tbl
operator|->
name|max_mlid_ho
argument_list|)
expr_stmt|;
name|mlid_offset
operator|=
name|mlid_ho
operator|-
name|IB_LID_MCAST_START_HO
expr_stmt|;
name|mask_offset
operator|=
name|port
operator|/
name|IB_MCAST_MASK_SIZE
expr_stmt|;
name|bit_mask
operator|=
name|cl_ntoh16
argument_list|(
call|(
name|uint16_t
call|)
argument_list|(
literal|1
operator|<<
operator|(
name|port
operator|%
name|IB_MCAST_MASK_SIZE
operator|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|p_tbl
operator|->
name|p_mask_tbl
operator|)
index|[
name|mlid_offset
index|]
index|[
name|mask_offset
index|]
operator||=
name|bit_mask
expr_stmt|;
name|block_num
operator|=
call|(
name|int16_t
call|)
argument_list|(
name|mlid_offset
operator|/
name|IB_MCAST_BLOCK_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|block_num
operator|>
name|p_tbl
operator|->
name|max_block_in_use
condition|)
name|p_tbl
operator|->
name|max_block_in_use
operator|=
operator|(
name|uint16_t
operator|)
name|block_num
expr_stmt|;
block|}
end_function

begin_function
name|int
name|osm_mcast_tbl_realloc
parameter_list|(
name|IN
name|osm_mcast_tbl_t
modifier|*
name|p_tbl
parameter_list|,
name|IN
name|unsigned
name|mlid_offset
parameter_list|)
block|{
name|size_t
name|mft_depth
decl_stmt|,
name|size
decl_stmt|;
name|uint16_t
argument_list|(
operator|*
name|p_mask_tbl
argument_list|)
index|[]
index|[
name|IB_MCAST_POSITION_MAX
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|mlid_offset
operator|<
name|p_tbl
operator|->
name|mft_depth
condition|)
goto|goto
name|done
goto|;
comment|/* 	   The number of bytes needed in the mask table is: 	   The (maximum bit mask 'position' + 1) times the 	   number of bytes in each bit mask times the 	   number of MLIDs supported by the table.  	   We must always allocate the array with the maximum position 	   since it is (and must be) defined that way the table structure 	   in order to create a pointer to a two dimensional array. 	 */
name|mft_depth
operator|=
operator|(
name|mlid_offset
operator|/
name|IB_MCAST_BLOCK_SIZE
operator|+
literal|1
operator|)
operator|*
name|IB_MCAST_BLOCK_SIZE
expr_stmt|;
name|size
operator|=
name|mft_depth
operator|*
operator|(
name|IB_MCAST_POSITION_MAX
operator|+
literal|1
operator|)
operator|*
name|IB_MCAST_MASK_SIZE
operator|/
literal|8
expr_stmt|;
name|p_mask_tbl
operator|=
name|realloc
argument_list|(
name|p_tbl
operator|->
name|p_mask_tbl
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_mask_tbl
condition|)
return|return
operator|-
literal|1
return|;
name|memset
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|p_mask_tbl
operator|+
name|p_tbl
operator|->
name|mft_depth
operator|*
operator|(
name|IB_MCAST_POSITION_MAX
operator|+
literal|1
operator|)
operator|*
name|IB_MCAST_MASK_SIZE
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
name|size
operator|-
name|p_tbl
operator|->
name|mft_depth
operator|*
operator|(
name|IB_MCAST_POSITION_MAX
operator|+
literal|1
operator|)
operator|*
name|IB_MCAST_MASK_SIZE
operator|/
literal|8
argument_list|)
expr_stmt|;
name|p_tbl
operator|->
name|p_mask_tbl
operator|=
name|p_mask_tbl
expr_stmt|;
name|p_tbl
operator|->
name|mft_depth
operator|=
name|mft_depth
expr_stmt|;
name|done
label|:
name|p_tbl
operator|->
name|max_mlid_ho
operator|=
name|mlid_offset
operator|+
name|IB_LID_MCAST_START_HO
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|boolean_t
name|osm_mcast_tbl_is_port
parameter_list|(
name|IN
specifier|const
name|osm_mcast_tbl_t
modifier|*
name|p_tbl
parameter_list|,
name|IN
name|uint16_t
name|mlid_ho
parameter_list|,
name|IN
name|uint8_t
name|port_num
parameter_list|)
block|{
name|unsigned
name|mlid_offset
decl_stmt|,
name|mask_offset
decl_stmt|,
name|bit_mask
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_tbl
operator|->
name|p_mask_tbl
condition|)
block|{
name|CL_ASSERT
argument_list|(
name|port_num
operator|<=
operator|(
name|p_tbl
operator|->
name|max_position
operator|+
literal|1
operator|)
operator|*
name|IB_MCAST_MASK_SIZE
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|mlid_ho
operator|>=
name|IB_LID_MCAST_START_HO
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|mlid_ho
operator|<=
name|p_tbl
operator|->
name|max_mlid_ho
argument_list|)
expr_stmt|;
name|mlid_offset
operator|=
name|mlid_ho
operator|-
name|IB_LID_MCAST_START_HO
expr_stmt|;
name|mask_offset
operator|=
name|port_num
operator|/
name|IB_MCAST_MASK_SIZE
expr_stmt|;
name|bit_mask
operator|=
name|cl_ntoh16
argument_list|(
call|(
name|uint16_t
call|)
argument_list|(
literal|1
operator|<<
operator|(
name|port_num
operator|%
name|IB_MCAST_MASK_SIZE
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|(
operator|*
name|p_tbl
operator|->
name|p_mask_tbl
operator|)
index|[
name|mlid_offset
index|]
index|[
name|mask_offset
index|]
operator|&
name|bit_mask
operator|)
operator|==
name|bit_mask
operator|)
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|boolean_t
name|osm_mcast_tbl_is_any_port
parameter_list|(
name|IN
specifier|const
name|osm_mcast_tbl_t
modifier|*
name|p_tbl
parameter_list|,
name|IN
name|uint16_t
name|mlid_ho
parameter_list|)
block|{
name|unsigned
name|mlid_offset
decl_stmt|;
name|uint8_t
name|position
decl_stmt|;
name|uint16_t
name|result
init|=
literal|0
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_tbl
operator|->
name|p_mask_tbl
condition|)
block|{
name|CL_ASSERT
argument_list|(
name|mlid_ho
operator|>=
name|IB_LID_MCAST_START_HO
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|mlid_ho
operator|<=
name|p_tbl
operator|->
name|max_mlid_ho
argument_list|)
expr_stmt|;
name|mlid_offset
operator|=
name|mlid_ho
operator|-
name|IB_LID_MCAST_START_HO
expr_stmt|;
for|for
control|(
name|position
operator|=
literal|0
init|;
name|position
operator|<=
name|p_tbl
operator|->
name|max_position
condition|;
name|position
operator|++
control|)
name|result
operator||=
operator|(
operator|*
name|p_tbl
operator|->
name|p_mask_tbl
operator|)
index|[
name|mlid_offset
index|]
index|[
name|position
index|]
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|ib_api_status_t
name|osm_mcast_tbl_set_block
parameter_list|(
name|IN
name|osm_mcast_tbl_t
modifier|*
name|p_tbl
parameter_list|,
name|IN
specifier|const
name|ib_net16_t
modifier|*
name|p_block
parameter_list|,
name|IN
name|int16_t
name|block_num
parameter_list|,
name|IN
name|uint8_t
name|position
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint16_t
name|mlid_start_ho
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_tbl
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|block_num
operator|>
name|p_tbl
operator|->
name|max_block
condition|)
return|return
name|IB_INVALID_PARAMETER
return|;
if|if
condition|(
name|position
operator|>
name|p_tbl
operator|->
name|max_position
condition|)
return|return
name|IB_INVALID_PARAMETER
return|;
name|mlid_start_ho
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|block_num
operator|*
name|IB_MCAST_BLOCK_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlid_start_ho
operator|+
name|IB_MCAST_BLOCK_SIZE
operator|-
literal|1
operator|>
name|p_tbl
operator|->
name|mft_depth
condition|)
return|return
name|IB_INVALID_PARAMETER
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IB_MCAST_BLOCK_SIZE
condition|;
name|i
operator|++
control|)
operator|(
operator|*
name|p_tbl
operator|->
name|p_mask_tbl
operator|)
index|[
name|mlid_start_ho
operator|+
name|i
index|]
index|[
name|position
index|]
operator|=
name|p_block
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|block_num
operator|>
name|p_tbl
operator|->
name|max_block_in_use
condition|)
name|p_tbl
operator|->
name|max_block_in_use
operator|=
operator|(
name|uint16_t
operator|)
name|block_num
expr_stmt|;
return|return
name|IB_SUCCESS
return|;
block|}
end_function

begin_function
name|void
name|osm_mcast_tbl_clear_mlid
parameter_list|(
name|IN
name|osm_mcast_tbl_t
modifier|*
name|p_tbl
parameter_list|,
name|IN
name|uint16_t
name|mlid_ho
parameter_list|)
block|{
name|unsigned
name|mlid_offset
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_tbl
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|mlid_ho
operator|>=
name|IB_LID_MCAST_START_HO
argument_list|)
expr_stmt|;
name|mlid_offset
operator|=
name|mlid_ho
operator|-
name|IB_LID_MCAST_START_HO
expr_stmt|;
if|if
condition|(
name|p_tbl
operator|->
name|p_mask_tbl
operator|&&
name|mlid_offset
operator|<
name|p_tbl
operator|->
name|mft_depth
condition|)
name|memset
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|p_tbl
operator|->
name|p_mask_tbl
operator|+
name|mlid_offset
operator|*
operator|(
name|IB_MCAST_POSITION_MAX
operator|+
literal|1
operator|)
operator|*
name|IB_MCAST_MASK_SIZE
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
operator|(
name|IB_MCAST_POSITION_MAX
operator|+
literal|1
operator|)
operator|*
name|IB_MCAST_MASK_SIZE
operator|/
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|osm_mcast_tbl_get_block
parameter_list|(
name|IN
name|osm_mcast_tbl_t
modifier|*
name|p_tbl
parameter_list|,
name|IN
name|int16_t
name|block_num
parameter_list|,
name|IN
name|uint8_t
name|position
parameter_list|,
name|OUT
name|ib_net16_t
modifier|*
name|p_block
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint16_t
name|mlid_start_ho
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_tbl
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|block_num
operator|>
name|p_tbl
operator|->
name|max_block_in_use
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|position
operator|>
name|p_tbl
operator|->
name|max_position
condition|)
block|{
comment|/* 		   Caller shouldn't do this for efficiency's sake... 		 */
name|memset
argument_list|(
name|p_block
argument_list|,
literal|0
argument_list|,
name|IB_SMP_DATA_SIZE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|CL_ASSERT
argument_list|(
name|block_num
operator|*
name|IB_MCAST_BLOCK_SIZE
operator|<=
name|p_tbl
operator|->
name|mft_depth
argument_list|)
expr_stmt|;
name|mlid_start_ho
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|block_num
operator|*
name|IB_MCAST_BLOCK_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IB_MCAST_BLOCK_SIZE
condition|;
name|i
operator|++
control|)
name|p_block
index|[
name|i
index|]
operator|=
operator|(
operator|*
name|p_tbl
operator|->
name|p_mask_tbl
operator|)
index|[
name|mlid_start_ho
operator|+
name|i
index|]
index|[
name|position
index|]
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

end_unit

