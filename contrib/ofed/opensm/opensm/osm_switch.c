begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2015 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  * Copyright (c) 2009 HNR Consulting. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_switch_t.  * This object represents an Infiniband switch.  * This object is part of the opensm family of objects.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_math.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_SWITCH_C
end_define

begin_include
include|#
directive|include
file|<opensm/osm_switch.h>
end_include

begin_struct
struct|struct
name|switch_port_path
block|{
name|uint8_t
name|port_num
decl_stmt|;
name|uint32_t
name|path_count
decl_stmt|;
name|int
name|found_sys_guid
decl_stmt|;
name|int
name|found_node_guid
decl_stmt|;
name|uint32_t
name|forwarded_to
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|cl_status_t
name|osm_switch_set_hops
parameter_list|(
name|IN
name|osm_switch_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|uint16_t
name|lid_ho
parameter_list|,
name|IN
name|uint8_t
name|port_num
parameter_list|,
name|IN
name|uint8_t
name|num_hops
parameter_list|)
block|{
if|if
condition|(
operator|!
name|lid_ho
operator|||
name|lid_ho
operator|>
name|p_sw
operator|->
name|max_lid_ho
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|port_num
operator|>=
name|p_sw
operator|->
name|num_ports
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|p_sw
operator|->
name|hops
index|[
name|lid_ho
index|]
condition|)
block|{
name|p_sw
operator|->
name|hops
index|[
name|lid_ho
index|]
operator|=
name|malloc
argument_list|(
name|p_sw
operator|->
name|num_ports
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_sw
operator|->
name|hops
index|[
name|lid_ho
index|]
condition|)
return|return
operator|-
literal|1
return|;
name|memset
argument_list|(
name|p_sw
operator|->
name|hops
index|[
name|lid_ho
index|]
argument_list|,
name|OSM_NO_PATH
argument_list|,
name|p_sw
operator|->
name|num_ports
argument_list|)
expr_stmt|;
block|}
name|p_sw
operator|->
name|hops
index|[
name|lid_ho
index|]
index|[
name|port_num
index|]
operator|=
name|num_hops
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|hops
index|[
name|lid_ho
index|]
index|[
literal|0
index|]
operator|>
name|num_hops
condition|)
name|p_sw
operator|->
name|hops
index|[
name|lid_ho
index|]
index|[
literal|0
index|]
operator|=
name|num_hops
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|osm_switch_delete
parameter_list|(
name|IN
name|OUT
name|osm_switch_t
modifier|*
modifier|*
name|pp_sw
parameter_list|)
block|{
name|osm_switch_t
modifier|*
name|p_sw
init|=
operator|*
name|pp_sw
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|osm_mcast_tbl_destroy
argument_list|(
operator|&
name|p_sw
operator|->
name|mcast_tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|p_prof
condition|)
name|free
argument_list|(
name|p_sw
operator|->
name|p_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|search_ordering_ports
condition|)
name|free
argument_list|(
name|p_sw
operator|->
name|search_ordering_ports
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|lft
condition|)
name|free
argument_list|(
name|p_sw
operator|->
name|lft
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|new_lft
condition|)
name|free
argument_list|(
name|p_sw
operator|->
name|new_lft
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|hops
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|num_hops
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p_sw
operator|->
name|hops
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|p_sw
operator|->
name|hops
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_sw
operator|->
name|hops
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|*
name|pp_sw
argument_list|)
expr_stmt|;
operator|*
name|pp_sw
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|osm_switch_t
modifier|*
name|osm_switch_new
parameter_list|(
name|IN
name|osm_node_t
modifier|*
name|p_node
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|)
block|{
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|ib_switch_info_t
modifier|*
name|p_si
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|uint8_t
name|num_ports
decl_stmt|;
name|uint32_t
name|port_num
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_si
operator|=
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
name|num_ports
operator|=
name|osm_node_get_num_physp
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_smp
operator|->
name|attr_id
operator|==
name|IB_MAD_ATTR_SWITCH_INFO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_si
operator|->
name|lin_cap
condition|)
comment|/* The switch doesn't support LFT */
return|return
name|NULL
return|;
name|p_sw
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p_sw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_sw
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|p_sw
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_sw
argument_list|)
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|p_node
operator|=
name|p_node
expr_stmt|;
name|p_sw
operator|->
name|switch_info
operator|=
operator|*
name|p_si
expr_stmt|;
name|p_sw
operator|->
name|num_ports
operator|=
name|num_ports
expr_stmt|;
name|p_sw
operator|->
name|need_update
operator|=
literal|2
expr_stmt|;
name|p_sw
operator|->
name|p_prof
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p_sw
operator|->
name|p_prof
argument_list|)
operator|*
name|num_ports
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_sw
operator|->
name|p_prof
condition|)
goto|goto
name|err
goto|;
name|memset
argument_list|(
name|p_sw
operator|->
name|p_prof
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_sw
operator|->
name|p_prof
argument_list|)
operator|*
name|num_ports
argument_list|)
expr_stmt|;
name|osm_mcast_tbl_init
argument_list|(
operator|&
name|p_sw
operator|->
name|mcast_tbl
argument_list|,
name|osm_node_get_num_physp
argument_list|(
name|p_node
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_si
operator|->
name|mcast_cap
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|port_num
operator|=
literal|0
init|;
name|port_num
operator|<
name|num_ports
condition|;
name|port_num
operator|++
control|)
name|osm_port_prof_construct
argument_list|(
operator|&
name|p_sw
operator|->
name|p_prof
index|[
name|port_num
index|]
argument_list|)
expr_stmt|;
return|return
name|p_sw
return|;
name|err
label|:
name|osm_switch_delete
argument_list|(
operator|&
name|p_sw
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|boolean_t
name|osm_switch_get_lft_block
parameter_list|(
name|IN
specifier|const
name|osm_switch_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|uint16_t
name|block_id
parameter_list|,
name|OUT
name|uint8_t
modifier|*
name|p_block
parameter_list|)
block|{
name|uint16_t
name|base_lid_ho
init|=
name|block_id
operator|*
name|IB_SMP_DATA_SIZE
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_lid_ho
operator|>
name|p_sw
operator|->
name|max_lid_ho
condition|)
return|return
name|FALSE
return|;
name|CL_ASSERT
argument_list|(
name|base_lid_ho
operator|+
name|IB_SMP_DATA_SIZE
operator|-
literal|1
operator|<=
name|IB_LID_UCAST_END_HO
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p_block
argument_list|,
operator|&
operator|(
name|p_sw
operator|->
name|new_lft
index|[
name|base_lid_ho
index|]
operator|)
argument_list|,
name|IB_SMP_DATA_SIZE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|osm_remote_node
modifier|*
name|switch_find_guid_common
parameter_list|(
name|IN
specifier|const
name|osm_switch_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|struct
name|osm_remote_guids_count
modifier|*
name|r
parameter_list|,
name|IN
name|uint8_t
name|port_num
parameter_list|,
name|IN
name|int
name|find_sys_guid
parameter_list|,
name|IN
name|int
name|find_node_guid
parameter_list|)
block|{
name|struct
name|osm_remote_node
modifier|*
name|p_remote_guid
init|=
name|NULL
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_rem_physp
decl_stmt|;
name|osm_node_t
modifier|*
name|p_rem_node
decl_stmt|;
name|uint64_t
name|sys_guid
decl_stmt|;
name|uint64_t
name|node_guid
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
goto|goto
name|out
goto|;
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
condition|)
goto|goto
name|out
goto|;
name|p_rem_physp
operator|=
name|osm_physp_get_remote
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|p_rem_node
operator|=
name|osm_physp_get_node_ptr
argument_list|(
name|p_rem_physp
argument_list|)
expr_stmt|;
name|sys_guid
operator|=
name|p_rem_node
operator|->
name|node_info
operator|.
name|sys_guid
expr_stmt|;
name|node_guid
operator|=
name|p_rem_node
operator|->
name|node_info
operator|.
name|node_guid
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|!
name|find_sys_guid
operator|||
name|r
operator|->
name|guids
index|[
name|i
index|]
operator|.
name|node
operator|->
name|node_info
operator|.
name|sys_guid
operator|==
name|sys_guid
operator|)
operator|&&
operator|(
operator|!
name|find_node_guid
operator|||
name|r
operator|->
name|guids
index|[
name|i
index|]
operator|.
name|node
operator|->
name|node_info
operator|.
name|node_guid
operator|==
name|node_guid
operator|)
condition|)
block|{
name|p_remote_guid
operator|=
operator|&
name|r
operator|->
name|guids
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
name|out
label|:
return|return
name|p_remote_guid
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|osm_remote_node
modifier|*
name|switch_find_sys_guid_count
parameter_list|(
name|IN
specifier|const
name|osm_switch_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|struct
name|osm_remote_guids_count
modifier|*
name|r
parameter_list|,
name|IN
name|uint8_t
name|port_num
parameter_list|)
block|{
return|return
name|switch_find_guid_common
argument_list|(
name|p_sw
argument_list|,
name|r
argument_list|,
name|port_num
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|osm_remote_node
modifier|*
name|switch_find_node_guid_count
parameter_list|(
name|IN
specifier|const
name|osm_switch_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|struct
name|osm_remote_guids_count
modifier|*
name|r
parameter_list|,
name|IN
name|uint8_t
name|port_num
parameter_list|)
block|{
return|return
name|switch_find_guid_common
argument_list|(
name|p_sw
argument_list|,
name|r
argument_list|,
name|port_num
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|osm_switch_recommend_path
parameter_list|(
name|IN
specifier|const
name|osm_switch_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|osm_port_t
modifier|*
name|p_port
parameter_list|,
name|IN
name|uint16_t
name|lid_ho
parameter_list|,
name|IN
name|unsigned
name|start_from
parameter_list|,
name|IN
name|boolean_t
name|ignore_existing
parameter_list|,
name|IN
name|boolean_t
name|routing_for_lmc
parameter_list|,
name|IN
name|boolean_t
name|dor
parameter_list|,
name|IN
name|boolean_t
name|port_shifting
parameter_list|,
name|IN
name|uint32_t
name|scatter_ports
parameter_list|,
name|IN
name|osm_lft_type_enum
name|lft_enum
parameter_list|)
block|{
comment|/* 	   We support an enhanced LMC aware routing mode: 	   In the case of LMC> 0, we can track the remote side 	   system and node for all of the lids of the target 	   and try and avoid routing again through the same 	   system / node.  	   Assume if routing_for_lmc is true that this procedure was 	   provided the tracking array and counter via p_port->priv, 	   and we can conduct this algorithm. 	 */
name|uint16_t
name|base_lid
decl_stmt|;
name|uint8_t
name|hops
decl_stmt|;
name|uint8_t
name|least_hops
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|uint8_t
name|num_ports
decl_stmt|;
name|uint32_t
name|least_paths
init|=
literal|0xFFFFFFFF
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
comment|/* 	   The following will track the least paths if the 	   route should go through a new system/node 	 */
name|uint32_t
name|least_paths_other_sys
init|=
literal|0xFFFFFFFF
decl_stmt|;
name|uint32_t
name|least_paths_other_nodes
init|=
literal|0xFFFFFFFF
decl_stmt|;
name|uint32_t
name|least_forwarded_to
init|=
literal|0xFFFFFFFF
decl_stmt|;
name|uint32_t
name|check_count
decl_stmt|;
name|uint8_t
name|best_port
init|=
literal|0
decl_stmt|;
comment|/* 	   These vars track the best port if it connects to 	   not used system/node. 	 */
name|uint8_t
name|best_port_other_sys
init|=
literal|0
decl_stmt|;
name|uint8_t
name|best_port_other_node
init|=
literal|0
decl_stmt|;
name|boolean_t
name|port_found
init|=
name|FALSE
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_rem_physp
decl_stmt|;
name|osm_node_t
modifier|*
name|p_rem_node
decl_stmt|;
name|osm_node_t
modifier|*
name|p_rem_node_first
init|=
name|NULL
decl_stmt|;
name|struct
name|osm_remote_node
modifier|*
name|p_remote_guid
init|=
name|NULL
decl_stmt|;
name|struct
name|osm_remote_node
name|null_remote_node
init|=
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|struct
name|switch_port_path
name|port_paths
index|[
name|IB_NODE_NUM_PORTS_MAX
index|]
decl_stmt|;
name|unsigned
name|int
name|port_paths_total_paths
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|port_paths_count
init|=
literal|0
decl_stmt|;
name|uint8_t
name|scatter_possible_ports
index|[
name|IB_NODE_NUM_PORTS_MAX
index|]
decl_stmt|;
name|unsigned
name|int
name|scatter_possible_ports_count
init|=
literal|0
decl_stmt|;
name|int
name|found_sys_guid
init|=
literal|0
decl_stmt|;
name|int
name|found_node_guid
init|=
literal|0
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|lid_ho
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_port
operator|->
name|p_node
operator|->
name|sw
condition|)
block|{
if|if
condition|(
name|p_port
operator|->
name|p_node
operator|->
name|sw
operator|==
name|p_sw
condition|)
return|return
literal|0
return|;
name|base_lid
operator|=
name|osm_port_get_base_lid
argument_list|(
name|p_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p_physp
operator|=
name|p_port
operator|->
name|p_physp
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
operator|||
operator|!
name|p_physp
operator|->
name|p_remote_physp
operator|||
operator|!
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
condition|)
return|return
name|OSM_NO_PATH
return|;
if|if
condition|(
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
operator|==
name|p_sw
condition|)
return|return
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|port_num
return|;
name|base_lid
operator|=
name|osm_node_get_base_lid
argument_list|(
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|base_lid
operator|=
name|cl_ntoh16
argument_list|(
name|base_lid
argument_list|)
expr_stmt|;
name|num_ports
operator|=
name|p_sw
operator|->
name|num_ports
expr_stmt|;
name|least_hops
operator|=
name|osm_switch_get_least_hops
argument_list|(
name|p_sw
argument_list|,
name|base_lid
argument_list|)
expr_stmt|;
if|if
condition|(
name|least_hops
operator|==
name|OSM_NO_PATH
condition|)
return|return
name|OSM_NO_PATH
return|;
comment|/* 	   First, inquire with the forwarding table for an existing 	   route.  If one is found, honor it unless: 	   1. the ignore existing flag is set. 	   2. the physical port is not a valid one or not healthy 	   3. the physical port has a remote port (the link is up) 	   4. the port has min-hops to the target (avoid loops) 	 */
if|if
condition|(
operator|!
name|ignore_existing
condition|)
block|{
name|port_num
operator|=
name|osm_switch_get_port_by_lid
argument_list|(
name|p_sw
argument_list|,
name|lid_ho
argument_list|,
name|lft_enum
argument_list|)
expr_stmt|;
if|if
condition|(
name|port_num
operator|!=
name|OSM_NO_PATH
condition|)
block|{
name|CL_ASSERT
argument_list|(
name|port_num
operator|<
name|num_ports
argument_list|)
expr_stmt|;
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
comment|/* 			   Don't be too trusting of the current forwarding table! 			   Verify that the port number is legal and that the 			   LID is reachable through this port. 			 */
if|if
condition|(
name|p_physp
operator|&&
name|osm_physp_is_healthy
argument_list|(
name|p_physp
argument_list|)
operator|&&
name|osm_physp_get_remote
argument_list|(
name|p_physp
argument_list|)
condition|)
block|{
name|hops
operator|=
name|osm_switch_get_hop_count
argument_list|(
name|p_sw
argument_list|,
name|base_lid
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
comment|/* 				   If we aren't using pre-defined user routes 				   function, then we need to make sure that the 				   current path is the minimum one. In case of 				   having such a user function - this check will 				   not be done, and the old routing will be used. 				   Note: This means that it is the user's job to 				   clean all data in the forwarding tables that 				   he wants to be overridden by the minimum 				   hop function. 				 */
if|if
condition|(
name|hops
operator|==
name|least_hops
condition|)
return|return
name|port_num
return|;
block|}
block|}
block|}
comment|/* 	   This algorithm selects a port based on a static load balanced 	   selection across equal hop-count ports. 	   There is lots of room for improved sophistication here, 	   possibly guided by user configuration info. 	 */
comment|/* 	   OpenSM routing is "local" - not considering a full lid to lid 	   path. As such we can not guarantee a path will not loop if we 	   do not always follow least hops. 	   So we must abort if not least hops. 	 */
comment|/* port number starts with one and num_ports is 1 + num phys ports */
for|for
control|(
name|i
operator|=
name|start_from
init|;
name|i
operator|<
name|start_from
operator|+
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|port_num
operator|=
name|osm_switch_get_dimn_port
argument_list|(
name|p_sw
argument_list|,
name|i
operator|%
name|num_ports
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port_num
operator|||
name|osm_switch_get_hop_count
argument_list|(
name|p_sw
argument_list|,
name|base_lid
argument_list|,
name|port_num
argument_list|)
operator|!=
name|least_hops
condition|)
continue|continue;
comment|/* let us make sure it is not down or unhealthy */
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
operator|||
operator|!
name|osm_physp_is_healthy
argument_list|(
name|p_physp
argument_list|)
operator|||
comment|/* 		       we require all - non sma ports to be linked 		       to be routed through 		     */
operator|!
name|osm_physp_get_remote
argument_list|(
name|p_physp
argument_list|)
condition|)
continue|continue;
comment|/* 		   We located a least-hop port, possibly one of many. 		   For this port, check the running total count of 		   the number of paths through this port.  Select 		   the port routing the least number of paths. 		 */
name|check_count
operator|=
name|osm_port_prof_path_count_get
argument_list|(
operator|&
name|p_sw
operator|->
name|p_prof
index|[
name|port_num
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dor
condition|)
block|{
comment|/* Get the Remote Node */
name|p_rem_physp
operator|=
name|osm_physp_get_remote
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|p_rem_node
operator|=
name|osm_physp_get_node_ptr
argument_list|(
name|p_rem_physp
argument_list|)
expr_stmt|;
comment|/* use the first dimension, but spread traffic 			 * out among the group of ports representing 			 * that dimension */
if|if
condition|(
operator|!
name|p_rem_node_first
condition|)
name|p_rem_node_first
operator|=
name|p_rem_node
expr_stmt|;
elseif|else
if|if
condition|(
name|p_rem_node
operator|!=
name|p_rem_node_first
condition|)
continue|continue;
if|if
condition|(
name|routing_for_lmc
condition|)
block|{
name|struct
name|osm_remote_guids_count
modifier|*
name|r
init|=
name|p_port
operator|->
name|priv
decl_stmt|;
name|uint8_t
name|rem_port
init|=
name|osm_physp_get_port_num
argument_list|(
name|p_rem_physp
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|r
operator|->
name|count
condition|;
name|j
operator|++
control|)
block|{
name|p_remote_guid
operator|=
operator|&
name|r
operator|->
name|guids
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|p_remote_guid
operator|->
name|node
operator|==
name|p_rem_node
operator|)
operator|&&
operator|(
name|p_remote_guid
operator|->
name|port
operator|==
name|rem_port
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|r
operator|->
name|count
condition|)
name|p_remote_guid
operator|=
operator|&
name|null_remote_node
expr_stmt|;
block|}
comment|/* 		   Advanced LMC routing requires tracking of the 		   best port by the node connected to the other side of 		   it. 		 */
block|}
elseif|else
if|if
condition|(
name|routing_for_lmc
condition|)
block|{
comment|/* Is the sys guid already used ? */
name|p_remote_guid
operator|=
name|switch_find_sys_guid_count
argument_list|(
name|p_sw
argument_list|,
name|p_port
operator|->
name|priv
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
comment|/* If not update the least hops for this case */
if|if
condition|(
operator|!
name|p_remote_guid
condition|)
block|{
if|if
condition|(
name|check_count
operator|<
name|least_paths_other_sys
condition|)
block|{
name|least_paths_other_sys
operator|=
name|check_count
expr_stmt|;
name|best_port_other_sys
operator|=
name|port_num
expr_stmt|;
name|least_forwarded_to
operator|=
literal|0
expr_stmt|;
block|}
name|found_sys_guid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* same sys found - try node */
comment|/* Else is the node guid already used ? */
name|p_remote_guid
operator|=
name|switch_find_node_guid_count
argument_list|(
name|p_sw
argument_list|,
name|p_port
operator|->
name|priv
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
comment|/* If not update the least hops for this case */
if|if
condition|(
operator|!
name|p_remote_guid
operator|&&
name|check_count
operator|<
name|least_paths_other_nodes
condition|)
block|{
name|least_paths_other_nodes
operator|=
name|check_count
expr_stmt|;
name|best_port_other_node
operator|=
name|port_num
expr_stmt|;
name|least_forwarded_to
operator|=
literal|0
expr_stmt|;
block|}
comment|/* else prior sys and node guid already used */
if|if
condition|(
operator|!
name|p_remote_guid
condition|)
name|found_node_guid
operator|=
literal|0
expr_stmt|;
else|else
name|found_node_guid
operator|=
literal|1
expr_stmt|;
name|found_sys_guid
operator|=
literal|1
expr_stmt|;
block|}
comment|/* same sys found */
block|}
name|port_paths
index|[
name|port_paths_count
index|]
operator|.
name|port_num
operator|=
name|port_num
expr_stmt|;
name|port_paths
index|[
name|port_paths_count
index|]
operator|.
name|path_count
operator|=
name|check_count
expr_stmt|;
if|if
condition|(
name|routing_for_lmc
condition|)
block|{
name|port_paths
index|[
name|port_paths_count
index|]
operator|.
name|found_sys_guid
operator|=
name|found_sys_guid
expr_stmt|;
name|port_paths
index|[
name|port_paths_count
index|]
operator|.
name|found_node_guid
operator|=
name|found_node_guid
expr_stmt|;
block|}
if|if
condition|(
name|routing_for_lmc
operator|&&
name|p_remote_guid
condition|)
name|port_paths
index|[
name|port_paths_count
index|]
operator|.
name|forwarded_to
operator|=
name|p_remote_guid
operator|->
name|forwarded_to
expr_stmt|;
else|else
name|port_paths
index|[
name|port_paths_count
index|]
operator|.
name|forwarded_to
operator|=
literal|0
expr_stmt|;
name|port_paths_total_paths
operator|+=
name|check_count
expr_stmt|;
name|port_paths_count
operator|++
expr_stmt|;
comment|/* routing for LMC mode */
comment|/* 		   the count is min but also lower then the max subscribed 		 */
if|if
condition|(
name|check_count
operator|<
name|least_paths
condition|)
block|{
name|port_found
operator|=
name|TRUE
expr_stmt|;
name|best_port
operator|=
name|port_num
expr_stmt|;
name|least_paths
operator|=
name|check_count
expr_stmt|;
name|scatter_possible_ports_count
operator|=
literal|0
expr_stmt|;
name|scatter_possible_ports
index|[
name|scatter_possible_ports_count
operator|++
index|]
operator|=
name|port_num
expr_stmt|;
if|if
condition|(
name|routing_for_lmc
operator|&&
name|p_remote_guid
operator|&&
name|p_remote_guid
operator|->
name|forwarded_to
operator|<
name|least_forwarded_to
condition|)
name|least_forwarded_to
operator|=
name|p_remote_guid
operator|->
name|forwarded_to
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scatter_ports
operator|&&
name|check_count
operator|==
name|least_paths
condition|)
block|{
name|scatter_possible_ports
index|[
name|scatter_possible_ports_count
operator|++
index|]
operator|=
name|port_num
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|routing_for_lmc
operator|&&
name|p_remote_guid
operator|&&
name|check_count
operator|==
name|least_paths
operator|&&
name|p_remote_guid
operator|->
name|forwarded_to
operator|<
name|least_forwarded_to
condition|)
block|{
name|least_forwarded_to
operator|=
name|p_remote_guid
operator|->
name|forwarded_to
expr_stmt|;
name|best_port
operator|=
name|port_num
expr_stmt|;
block|}
block|}
if|if
condition|(
name|port_found
operator|==
name|FALSE
condition|)
return|return
name|OSM_NO_PATH
return|;
if|if
condition|(
name|port_shifting
operator|&&
name|port_paths_count
condition|)
block|{
comment|/* In the port_paths[] array, we now have all the ports that we 		 * can route out of.  Using some shifting math below, possibly 		 * select a different one so that lids won't align in LFTs 		 * 		 * If lmc> 0, we need to loop through these ports to find the 		 * least_forwarded_to port, best_port_other_sys, and 		 * best_port_other_node just like before but through the different 		 * ordering. 		 */
name|least_paths
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|least_paths_other_sys
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|least_paths_other_nodes
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|least_forwarded_to
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|best_port
operator|=
literal|0
expr_stmt|;
name|best_port_other_sys
operator|=
literal|0
expr_stmt|;
name|best_port_other_node
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|port_paths_count
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|idx
decl_stmt|;
name|idx
operator|=
operator|(
name|port_paths_total_paths
operator|/
name|port_paths_count
operator|+
name|i
operator|)
operator|%
name|port_paths_count
expr_stmt|;
if|if
condition|(
name|routing_for_lmc
condition|)
block|{
if|if
condition|(
operator|!
name|port_paths
index|[
name|idx
index|]
operator|.
name|found_sys_guid
operator|&&
name|port_paths
index|[
name|idx
index|]
operator|.
name|path_count
operator|<
name|least_paths_other_sys
condition|)
block|{
name|least_paths_other_sys
operator|=
name|port_paths
index|[
name|idx
index|]
operator|.
name|path_count
expr_stmt|;
name|best_port_other_sys
operator|=
name|port_paths
index|[
name|idx
index|]
operator|.
name|port_num
expr_stmt|;
name|least_forwarded_to
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|port_paths
index|[
name|idx
index|]
operator|.
name|found_node_guid
operator|&&
name|port_paths
index|[
name|idx
index|]
operator|.
name|path_count
operator|<
name|least_paths_other_nodes
condition|)
block|{
name|least_paths_other_nodes
operator|=
name|port_paths
index|[
name|idx
index|]
operator|.
name|path_count
expr_stmt|;
name|best_port_other_node
operator|=
name|port_paths
index|[
name|idx
index|]
operator|.
name|port_num
expr_stmt|;
name|least_forwarded_to
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|port_paths
index|[
name|idx
index|]
operator|.
name|path_count
operator|<
name|least_paths
condition|)
block|{
name|best_port
operator|=
name|port_paths
index|[
name|idx
index|]
operator|.
name|port_num
expr_stmt|;
name|least_paths
operator|=
name|port_paths
index|[
name|idx
index|]
operator|.
name|path_count
expr_stmt|;
if|if
condition|(
name|routing_for_lmc
operator|&&
operator|(
name|port_paths
index|[
name|idx
index|]
operator|.
name|found_sys_guid
operator|||
name|port_paths
index|[
name|idx
index|]
operator|.
name|found_node_guid
operator|)
operator|&&
name|port_paths
index|[
name|idx
index|]
operator|.
name|forwarded_to
operator|<
name|least_forwarded_to
condition|)
name|least_forwarded_to
operator|=
name|port_paths
index|[
name|idx
index|]
operator|.
name|forwarded_to
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|routing_for_lmc
operator|&&
operator|(
name|port_paths
index|[
name|idx
index|]
operator|.
name|found_sys_guid
operator|||
name|port_paths
index|[
name|idx
index|]
operator|.
name|found_node_guid
operator|)
operator|&&
name|port_paths
index|[
name|idx
index|]
operator|.
name|path_count
operator|==
name|least_paths
operator|&&
name|port_paths
index|[
name|idx
index|]
operator|.
name|forwarded_to
operator|<
name|least_forwarded_to
condition|)
block|{
name|least_forwarded_to
operator|=
name|port_paths
index|[
name|idx
index|]
operator|.
name|forwarded_to
expr_stmt|;
name|best_port
operator|=
name|port_paths
index|[
name|idx
index|]
operator|.
name|port_num
expr_stmt|;
block|}
block|}
block|}
comment|/* 	   if we are in enhanced routing mode and the best port is not 	   the local port 0 	 */
if|if
condition|(
name|routing_for_lmc
operator|&&
name|best_port
operator|&&
operator|!
name|scatter_ports
condition|)
block|{
comment|/* Select the least hop port of the non used sys first */
if|if
condition|(
name|best_port_other_sys
condition|)
name|best_port
operator|=
name|best_port_other_sys
expr_stmt|;
elseif|else
if|if
condition|(
name|best_port_other_node
condition|)
name|best_port
operator|=
name|best_port_other_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scatter_ports
condition|)
block|{
comment|/* 		 * There is some danger that this random could "rebalance" the routes 		 * every time, to combat this there is a global srandom that 		 * occurs at the start of every sweep. 		 */
name|unsigned
name|int
name|idx
init|=
name|random
argument_list|()
operator|%
name|scatter_possible_ports_count
decl_stmt|;
name|best_port
operator|=
name|scatter_possible_ports
index|[
name|idx
index|]
expr_stmt|;
block|}
return|return
name|best_port
return|;
block|}
end_function

begin_function
name|void
name|osm_switch_clear_hops
parameter_list|(
name|IN
name|osm_switch_t
modifier|*
name|p_sw
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|num_hops
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p_sw
operator|->
name|hops
index|[
name|i
index|]
condition|)
name|memset
argument_list|(
name|p_sw
operator|->
name|hops
index|[
name|i
index|]
argument_list|,
name|OSM_NO_PATH
argument_list|,
name|p_sw
operator|->
name|num_ports
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_lft
parameter_list|(
name|IN
name|osm_switch_t
modifier|*
name|p_sw
parameter_list|,
name|uint16_t
name|lids
parameter_list|)
block|{
name|uint16_t
name|lft_size
decl_stmt|;
comment|/* Ensure LFT is in units of LFT block size */
name|lft_size
operator|=
operator|(
name|lids
operator|/
name|IB_SMP_DATA_SIZE
operator|+
literal|1
operator|)
operator|*
name|IB_SMP_DATA_SIZE
expr_stmt|;
if|if
condition|(
name|lft_size
operator|>
name|p_sw
operator|->
name|lft_size
condition|)
block|{
name|uint8_t
modifier|*
name|new_lft
init|=
name|realloc
argument_list|(
name|p_sw
operator|->
name|lft
argument_list|,
name|lft_size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|new_lft
condition|)
return|return
operator|-
literal|1
return|;
name|memset
argument_list|(
name|new_lft
operator|+
name|p_sw
operator|->
name|lft_size
argument_list|,
name|OSM_NO_PATH
argument_list|,
name|lft_size
operator|-
name|p_sw
operator|->
name|lft_size
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|lft
operator|=
name|new_lft
expr_stmt|;
name|p_sw
operator|->
name|lft_size
operator|=
name|lft_size
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|osm_switch_prepare_path_rebuild
parameter_list|(
name|IN
name|osm_switch_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|uint16_t
name|max_lids
parameter_list|)
block|{
name|uint8_t
modifier|*
modifier|*
name|hops
decl_stmt|;
name|uint8_t
modifier|*
name|new_lft
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
name|alloc_lft
argument_list|(
name|p_sw
argument_list|,
name|max_lids
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
name|osm_port_prof_construct
argument_list|(
operator|&
name|p_sw
operator|->
name|p_prof
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|osm_switch_clear_hops
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|new_lft
operator|=
name|realloc
argument_list|(
name|p_sw
operator|->
name|new_lft
argument_list|,
name|p_sw
operator|->
name|lft_size
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|p_sw
operator|->
name|new_lft
operator|=
name|new_lft
expr_stmt|;
name|memset
argument_list|(
name|p_sw
operator|->
name|new_lft
argument_list|,
name|OSM_NO_PATH
argument_list|,
name|p_sw
operator|->
name|lft_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_sw
operator|->
name|hops
condition|)
block|{
name|hops
operator|=
name|malloc
argument_list|(
operator|(
name|max_lids
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|hops
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hops
condition|)
return|return
operator|-
literal|1
return|;
name|memset
argument_list|(
name|hops
argument_list|,
literal|0
argument_list|,
operator|(
name|max_lids
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|hops
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|hops
operator|=
name|hops
expr_stmt|;
name|p_sw
operator|->
name|num_hops
operator|=
name|max_lids
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|max_lids
operator|+
literal|1
operator|>
name|p_sw
operator|->
name|num_hops
condition|)
block|{
name|hops
operator|=
name|realloc
argument_list|(
name|p_sw
operator|->
name|hops
argument_list|,
operator|(
name|max_lids
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|hops
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hops
condition|)
return|return
operator|-
literal|1
return|;
name|memset
argument_list|(
name|hops
operator|+
name|p_sw
operator|->
name|num_hops
argument_list|,
literal|0
argument_list|,
operator|(
name|max_lids
operator|+
literal|1
operator|-
name|p_sw
operator|->
name|num_hops
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|hops
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|hops
operator|=
name|hops
expr_stmt|;
name|p_sw
operator|->
name|num_hops
operator|=
name|max_lids
operator|+
literal|1
expr_stmt|;
block|}
name|p_sw
operator|->
name|max_lid_ho
operator|=
name|max_lids
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|uint8_t
name|osm_switch_get_port_least_hops
parameter_list|(
name|IN
specifier|const
name|osm_switch_t
modifier|*
name|p_sw
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
name|p_port
parameter_list|)
block|{
name|uint16_t
name|lid
decl_stmt|;
if|if
condition|(
name|p_port
operator|->
name|p_node
operator|->
name|sw
condition|)
block|{
if|if
condition|(
name|p_port
operator|->
name|p_node
operator|->
name|sw
operator|==
name|p_sw
condition|)
return|return
literal|0
return|;
name|lid
operator|=
name|osm_node_get_base_lid
argument_list|(
name|p_port
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|osm_switch_get_least_hops
argument_list|(
name|p_sw
argument_list|,
name|cl_ntoh16
argument_list|(
name|lid
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|osm_physp_t
modifier|*
name|p
init|=
name|p_port
operator|->
name|p_physp
decl_stmt|;
name|uint8_t
name|hops
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|p
operator|->
name|p_remote_physp
operator|||
operator|!
name|p
operator|->
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
condition|)
return|return
name|OSM_NO_PATH
return|;
if|if
condition|(
name|p
operator|->
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
operator|==
name|p_sw
condition|)
return|return
literal|1
return|;
name|lid
operator|=
name|osm_node_get_base_lid
argument_list|(
name|p
operator|->
name|p_remote_physp
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hops
operator|=
name|osm_switch_get_least_hops
argument_list|(
name|p_sw
argument_list|,
name|cl_ntoh16
argument_list|(
name|lid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|hops
operator|!=
name|OSM_NO_PATH
condition|?
name|hops
operator|+
literal|1
else|:
name|OSM_NO_PATH
return|;
block|}
block|}
end_function

begin_function
name|uint8_t
name|osm_switch_recommend_mcast_path
parameter_list|(
name|IN
name|osm_switch_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|osm_port_t
modifier|*
name|p_port
parameter_list|,
name|IN
name|uint16_t
name|mlid_ho
parameter_list|,
name|IN
name|boolean_t
name|ignore_existing
parameter_list|)
block|{
name|uint16_t
name|base_lid
decl_stmt|;
name|uint8_t
name|hops
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|uint8_t
name|num_ports
decl_stmt|;
name|uint8_t
name|least_hops
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|mlid_ho
operator|>=
name|IB_LID_MCAST_START_HO
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_port
operator|->
name|p_node
operator|->
name|sw
condition|)
block|{
if|if
condition|(
name|p_port
operator|->
name|p_node
operator|->
name|sw
operator|==
name|p_sw
condition|)
return|return
literal|0
return|;
name|base_lid
operator|=
name|osm_port_get_base_lid
argument_list|(
name|p_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|osm_physp_t
modifier|*
name|p_physp
init|=
name|p_port
operator|->
name|p_physp
decl_stmt|;
if|if
condition|(
operator|!
name|p_physp
operator|||
operator|!
name|p_physp
operator|->
name|p_remote_physp
operator|||
operator|!
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
condition|)
return|return
name|OSM_NO_PATH
return|;
if|if
condition|(
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
operator|==
name|p_sw
condition|)
return|return
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|port_num
return|;
name|base_lid
operator|=
name|osm_node_get_base_lid
argument_list|(
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|base_lid
operator|=
name|cl_ntoh16
argument_list|(
name|base_lid
argument_list|)
expr_stmt|;
name|num_ports
operator|=
name|p_sw
operator|->
name|num_ports
expr_stmt|;
comment|/* 	   If the user wants us to ignore existing multicast routes, 	   then simply return the shortest hop count path to the 	   target port.  	   Otherwise, return the first port that has a path to the target, 	   picking from the ports that are already in the multicast group. 	 */
if|if
condition|(
operator|!
name|ignore_existing
condition|)
block|{
for|for
control|(
name|port_num
operator|=
literal|1
init|;
name|port_num
operator|<
name|num_ports
condition|;
name|port_num
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|osm_mcast_tbl_is_port
argument_list|(
operator|&
name|p_sw
operator|->
name|mcast_tbl
argument_list|,
name|mlid_ho
argument_list|,
name|port_num
argument_list|)
condition|)
continue|continue;
comment|/* 			   Don't be too trusting of the current forwarding table! 			   Verify that the LID is reachable through this port. 			 */
name|hops
operator|=
name|osm_switch_get_hop_count
argument_list|(
name|p_sw
argument_list|,
name|base_lid
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|hops
operator|!=
name|OSM_NO_PATH
condition|)
return|return
name|port_num
return|;
block|}
block|}
comment|/* 	   Either no existing mcast paths reach this port or we are 	   ignoring existing paths.  	   Determine the best multicast path to the target.  Note that this 	   algorithm is slightly different from the one used for unicast route 	   recommendation.  In this case (multicast), we must NOT 	   perform any sort of load balancing.  We MUST take the FIRST 	   port found that has<= the lowest hop count path.  This prevents 	   more than one multicast path to the same remote switch which 	   prevents a multicast loop.  Multicast loops are bad since the same 	   multicast packet will go around and around, inevitably creating 	   a black hole that will destroy the Earth in a firey conflagration. 	 */
name|least_hops
operator|=
name|osm_switch_get_least_hops
argument_list|(
name|p_sw
argument_list|,
name|base_lid
argument_list|)
expr_stmt|;
if|if
condition|(
name|least_hops
operator|==
name|OSM_NO_PATH
condition|)
return|return
name|OSM_NO_PATH
return|;
for|for
control|(
name|port_num
operator|=
literal|1
init|;
name|port_num
operator|<
name|num_ports
condition|;
name|port_num
operator|++
control|)
if|if
condition|(
name|osm_switch_get_hop_count
argument_list|(
name|p_sw
argument_list|,
name|base_lid
argument_list|,
name|port_num
argument_list|)
operator|==
name|least_hops
condition|)
break|break;
name|CL_ASSERT
argument_list|(
name|port_num
operator|<
name|num_ports
argument_list|)
expr_stmt|;
return|return
name|port_num
return|;
block|}
end_function

end_unit

