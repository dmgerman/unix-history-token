begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2015 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_physp_t.  * This object represents an Infiniband Port.  * This object is part of the opensm family of objects.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_PORT_C
end_define

begin_include
include|#
directive|include
file|<opensm/osm_port.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_node.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_madw.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_switch.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_db_pack.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_sm.h>
end_include

begin_function
name|void
name|osm_physp_construct
parameter_list|(
name|IN
name|osm_physp_t
modifier|*
name|p_physp
parameter_list|)
block|{
name|memset
argument_list|(
name|p_physp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_physp
argument_list|)
argument_list|)
expr_stmt|;
name|osm_dr_path_construct
argument_list|(
operator|&
name|p_physp
operator|->
name|dr_path
argument_list|)
expr_stmt|;
name|cl_ptr_vector_construct
argument_list|(
operator|&
name|p_physp
operator|->
name|slvl_by_port
argument_list|)
expr_stmt|;
name|osm_pkey_tbl_construct
argument_list|(
operator|&
name|p_physp
operator|->
name|pkeys
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_physp_destroy
parameter_list|(
name|IN
name|osm_physp_t
modifier|*
name|p_physp
parameter_list|)
block|{
name|size_t
name|num_slvl
decl_stmt|,
name|i
decl_stmt|;
comment|/* the physp might be uninitialized */
if|if
condition|(
name|p_physp
operator|->
name|port_guid
condition|)
block|{
if|if
condition|(
name|p_physp
operator|->
name|p_guids
condition|)
name|free
argument_list|(
name|p_physp
operator|->
name|p_guids
argument_list|)
expr_stmt|;
comment|/* free the SL2VL Tables */
name|num_slvl
operator|=
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_physp
operator|->
name|slvl_by_port
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_slvl
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|cl_ptr_vector_get
argument_list|(
operator|&
name|p_physp
operator|->
name|slvl_by_port
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|cl_ptr_vector_destroy
argument_list|(
operator|&
name|p_physp
operator|->
name|slvl_by_port
argument_list|)
expr_stmt|;
comment|/* free the P_Key Tables */
name|osm_pkey_tbl_destroy
argument_list|(
operator|&
name|p_physp
operator|->
name|pkeys
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_physp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_physp
argument_list|)
argument_list|)
expr_stmt|;
name|osm_dr_path_construct
argument_list|(
operator|&
name|p_physp
operator|->
name|dr_path
argument_list|)
expr_stmt|;
comment|/* clear dr_path */
block|}
block|}
end_function

begin_decl_stmt
name|void
name|osm_physp_init
argument_list|(
name|IN
name|osm_physp_t
operator|*
name|p_physp
argument_list|,
name|IN
name|ib_net64_t
name|port_guid
argument_list|,
name|IN
name|uint8_t
name|port_num
argument_list|,
name|IN
specifier|const
expr|struct
name|osm_node
operator|*
name|p_node
argument_list|,
name|IN
name|osm_bind_handle_t
name|h_bind
argument_list|,
name|IN
name|uint8_t
name|hop_count
argument_list|,
name|IN
specifier|const
name|uint8_t
operator|*
name|p_initial_path
argument_list|)
block|{
name|uint16_t
name|num_slvl
decl_stmt|,
name|i
decl_stmt|;
name|ib_slvl_table_t
modifier|*
name|p_slvl
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|osm_physp_construct
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|p_physp
operator|->
name|port_guid
operator|=
name|port_guid
expr_stmt|;
name|p_physp
operator|->
name|port_num
operator|=
name|port_num
expr_stmt|;
name|p_physp
operator|->
name|healthy
operator|=
name|TRUE
expr_stmt|;
name|p_physp
operator|->
name|need_update
operator|=
literal|2
expr_stmt|;
name|p_physp
operator|->
name|p_node
operator|=
operator|(
expr|struct
name|osm_node
operator|*
operator|)
name|p_node
expr_stmt|;
name|osm_dr_path_init
argument_list|(
operator|&
name|p_physp
operator|->
name|dr_path
argument_list|,
name|hop_count
argument_list|,
name|p_initial_path
argument_list|)
expr_stmt|;
comment|/* allocate enough SL2VL tables */
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|p_node
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
condition|)
comment|/* we need node num ports + 1 SL2VL tables */
name|num_slvl
operator|=
name|osm_node_get_num_physp
argument_list|(
name|p_node
argument_list|)
operator|+
literal|1
expr_stmt|;
else|else
comment|/* An end node - we need only one SL2VL */
name|num_slvl
operator|=
literal|1
expr_stmt|;
name|cl_ptr_vector_init
argument_list|(
operator|&
name|p_physp
operator|->
name|slvl_by_port
argument_list|,
name|num_slvl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_slvl
condition|;
name|i
operator|++
control|)
block|{
name|p_slvl
operator|=
operator|(
name|ib_slvl_table_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ib_slvl_table_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_slvl
condition|)
break|break;
name|memset
argument_list|(
name|p_slvl
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_slvl_table_t
argument_list|)
argument_list|)
expr_stmt|;
name|cl_ptr_vector_set
argument_list|(
operator|&
name|p_physp
operator|->
name|slvl_by_port
argument_list|,
name|i
argument_list|,
name|p_slvl
argument_list|)
expr_stmt|;
block|}
comment|/* initialize the pkey table */
name|osm_pkey_tbl_init
argument_list|(
operator|&
name|p_physp
operator|->
name|pkeys
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|osm_port_delete
parameter_list|(
name|IN
name|OUT
name|osm_port_t
modifier|*
modifier|*
name|pp_port
parameter_list|)
block|{
name|free
argument_list|(
operator|*
name|pp_port
argument_list|)
expr_stmt|;
operator|*
name|pp_port
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|osm_port_t
modifier|*
name|osm_port_new
parameter_list|(
name|IN
specifier|const
name|ib_node_info_t
modifier|*
name|p_ni
parameter_list|,
name|IN
name|osm_node_t
modifier|*
name|p_parent_node
parameter_list|)
block|{
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|ib_net64_t
name|port_guid
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|p_port
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|p_port
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_port
argument_list|)
argument_list|)
expr_stmt|;
name|cl_qlist_init
argument_list|(
operator|&
name|p_port
operator|->
name|mcm_list
argument_list|)
expr_stmt|;
name|p_port
operator|->
name|p_node
operator|=
operator|(
expr|struct
name|osm_node
operator|*
operator|)
name|p_parent_node
expr_stmt|;
name|port_guid
operator|=
name|p_ni
operator|->
name|port_guid
expr_stmt|;
name|p_port
operator|->
name|guid
operator|=
name|port_guid
expr_stmt|;
name|port_num
operator|=
name|p_ni
operator|->
name|node_type
operator|==
name|IB_NODE_TYPE_SWITCH
condition|?
literal|0
else|:
name|ib_node_info_get_local_port_num
argument_list|(
name|p_ni
argument_list|)
expr_stmt|;
comment|/* 	   Get the pointers to the physical node objects "owned" by this 	   logical port GUID. 	   For switches, port '0' is owned; for HCA's and routers, 	   only the singular part that has this GUID is owned. 	 */
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_parent_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
condition|)
return|return
name|NULL
return|;
name|CL_ASSERT
argument_list|(
name|port_guid
operator|==
name|osm_physp_get_port_guid
argument_list|(
name|p_physp
argument_list|)
argument_list|)
expr_stmt|;
name|p_port
operator|->
name|p_physp
operator|=
name|p_physp
expr_stmt|;
return|return
name|p_port
return|;
block|}
end_function

begin_function
name|void
name|osm_port_get_lid_range_ho
parameter_list|(
name|IN
specifier|const
name|osm_port_t
modifier|*
name|p_port
parameter_list|,
name|IN
name|uint16_t
modifier|*
name|p_min_lid
parameter_list|,
name|IN
name|uint16_t
modifier|*
name|p_max_lid
parameter_list|)
block|{
name|uint8_t
name|lmc
decl_stmt|;
operator|*
name|p_min_lid
operator|=
name|cl_ntoh16
argument_list|(
name|osm_port_get_base_lid
argument_list|(
name|p_port
argument_list|)
argument_list|)
expr_stmt|;
name|lmc
operator|=
name|osm_port_get_lmc
argument_list|(
name|p_port
argument_list|)
expr_stmt|;
operator|*
name|p_max_lid
operator|=
call|(
name|uint16_t
call|)
argument_list|(
operator|*
name|p_min_lid
operator|+
operator|(
literal|1
operator|<<
name|lmc
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint8_t
name|osm_physp_calc_link_mtu
parameter_list|(
name|IN
name|osm_log_t
modifier|*
name|p_log
parameter_list|,
name|IN
specifier|const
name|osm_physp_t
modifier|*
name|p_physp
parameter_list|,
name|IN
name|uint8_t
name|current_mtu
parameter_list|)
block|{
specifier|const
name|osm_physp_t
modifier|*
name|p_remote_physp
decl_stmt|;
name|uint8_t
name|mtu
decl_stmt|;
name|uint8_t
name|remote_mtu
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|p_remote_physp
operator|=
name|osm_physp_get_remote
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_remote_physp
condition|)
block|{
comment|/* use the available MTU */
name|mtu
operator|=
name|ib_port_info_get_mtu_cap
argument_list|(
operator|&
name|p_physp
operator|->
name|port_info
argument_list|)
expr_stmt|;
name|remote_mtu
operator|=
name|ib_port_info_get_mtu_cap
argument_list|(
operator|&
name|p_remote_physp
operator|->
name|port_info
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Remote port 0x%016"
name|PRIx64
literal|" port = %u : "
literal|"MTU = %u. This Port MTU: %u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_remote_physp
argument_list|)
argument_list|)
argument_list|,
name|osm_physp_get_port_num
argument_list|(
name|p_remote_physp
argument_list|)
argument_list|,
name|remote_mtu
argument_list|,
name|mtu
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtu
operator|!=
name|remote_mtu
condition|)
block|{
if|if
condition|(
name|mtu
operator|>
name|remote_mtu
condition|)
name|mtu
operator|=
name|remote_mtu
expr_stmt|;
if|if
condition|(
name|mtu
operator|!=
name|current_mtu
condition|)
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"MTU mismatch between ports."
literal|"\n\t\t\t\tPort 0x%016"
name|PRIx64
literal|", port %u"
literal|" and port 0x%016"
name|PRIx64
literal|", port %u."
literal|"\n\t\t\t\tUsing lower MTU of %u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_physp
argument_list|)
argument_list|)
argument_list|,
name|osm_physp_get_port_num
argument_list|(
name|p_physp
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_remote_physp
argument_list|)
argument_list|)
argument_list|,
name|osm_physp_get_port_num
argument_list|(
name|p_remote_physp
argument_list|)
argument_list|,
name|mtu
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|mtu
operator|=
name|ib_port_info_get_neighbor_mtu
argument_list|(
operator|&
name|p_physp
operator|->
name|port_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtu
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"ERR 4101: "
literal|"Invalid MTU = 0. Forcing correction to 256\n"
argument_list|)
expr_stmt|;
name|mtu
operator|=
literal|1
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
name|mtu
return|;
block|}
end_function

begin_function
name|uint8_t
name|osm_physp_calc_link_op_vls
parameter_list|(
name|IN
name|osm_log_t
modifier|*
name|p_log
parameter_list|,
name|IN
specifier|const
name|osm_subn_t
modifier|*
name|p_subn
parameter_list|,
name|IN
specifier|const
name|osm_physp_t
modifier|*
name|p_physp
parameter_list|,
name|IN
name|uint8_t
name|current_op_vls
parameter_list|)
block|{
specifier|const
name|osm_physp_t
modifier|*
name|p_remote_physp
decl_stmt|;
name|uint8_t
name|op_vls
decl_stmt|;
name|uint8_t
name|remote_op_vls
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|p_remote_physp
operator|=
name|osm_physp_get_remote
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_remote_physp
condition|)
block|{
comment|/* use the available VLCap */
name|op_vls
operator|=
name|ib_port_info_get_vl_cap
argument_list|(
operator|&
name|p_physp
operator|->
name|port_info
argument_list|)
expr_stmt|;
name|remote_op_vls
operator|=
name|ib_port_info_get_vl_cap
argument_list|(
operator|&
name|p_remote_physp
operator|->
name|port_info
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Remote port 0x%016"
name|PRIx64
literal|" port = 0x%X : "
literal|"VL_CAP = %u. This port VL_CAP = %u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_remote_physp
argument_list|)
argument_list|)
argument_list|,
name|osm_physp_get_port_num
argument_list|(
name|p_remote_physp
argument_list|)
argument_list|,
name|remote_op_vls
argument_list|,
name|op_vls
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_vls
operator|!=
name|remote_op_vls
condition|)
block|{
if|if
condition|(
name|op_vls
operator|>
name|remote_op_vls
condition|)
name|op_vls
operator|=
name|remote_op_vls
expr_stmt|;
if|if
condition|(
name|op_vls
operator|!=
name|current_op_vls
condition|)
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"OP_VLS mismatch between ports."
literal|"\n\t\t\t\tPort 0x%016"
name|PRIx64
literal|", port 0x%X"
literal|" and port 0x%016"
name|PRIx64
literal|", port 0x%X."
literal|"\n\t\t\t\tUsing lower OP_VLS of %u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_physp
argument_list|)
argument_list|)
argument_list|,
name|osm_physp_get_port_num
argument_list|(
name|p_physp
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_remote_physp
argument_list|)
argument_list|)
argument_list|,
name|osm_physp_get_port_num
argument_list|(
name|p_remote_physp
argument_list|)
argument_list|,
name|op_vls
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|op_vls
operator|=
name|ib_port_info_get_op_vls
argument_list|(
operator|&
name|p_physp
operator|->
name|port_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_vls
operator|==
literal|0
condition|)
block|{
comment|/* for non compliant implementations */
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Invalid OP_VLS = 0. Forcing correction to 1 (VL0)\n"
argument_list|)
expr_stmt|;
name|op_vls
operator|=
literal|1
expr_stmt|;
block|}
comment|/* support user limitation of max_op_vls */
if|if
condition|(
name|op_vls
operator|>
name|p_subn
operator|->
name|opt
operator|.
name|max_op_vls
condition|)
name|op_vls
operator|=
name|p_subn
operator|->
name|opt
operator|.
name|max_op_vls
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
name|op_vls
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|ptr_to_key
parameter_list|(
name|void
specifier|const
modifier|*
name|p
parameter_list|)
block|{
name|uint64_t
name|k
init|=
literal|0
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|k
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|k
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|key_to_ptr
parameter_list|(
name|uint64_t
name|k
parameter_list|)
block|{
name|void
modifier|*
name|p
init|=
literal|0
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|k
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Traverse the fabric from the SM node following the DR path given and  add every phys port traversed to the map. Avoid tracking the first and  last phys ports (going into the first switch and into the target port).  **********************************************************************/
end_comment

begin_function
specifier|static
name|cl_status_t
name|physp_get_dr_physp_set
parameter_list|(
name|IN
name|osm_log_t
modifier|*
name|p_log
parameter_list|,
name|IN
name|osm_subn_t
specifier|const
modifier|*
name|p_subn
parameter_list|,
name|IN
name|osm_dr_path_t
specifier|const
modifier|*
name|p_path
parameter_list|,
name|OUT
name|cl_map_t
modifier|*
name|p_physp_map
parameter_list|)
block|{
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|uint8_t
name|hop
decl_stmt|;
name|cl_status_t
name|status
init|=
name|CL_SUCCESS
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
comment|/* find the OSM node */
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|p_subn
argument_list|,
name|p_subn
operator|->
name|sm_port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4103: "
literal|"Failed to find the SM own port by guid\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|CL_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* get the node of the SM */
name|p_node
operator|=
name|p_port
operator|->
name|p_node
expr_stmt|;
comment|/* 	   traverse the path adding the nodes to the table 	   start after the first dummy hop and stop just before the 	   last one 	 */
for|for
control|(
name|hop
operator|=
literal|1
init|;
name|hop
operator|<
name|p_path
operator|->
name|hop_count
operator|-
literal|1
condition|;
name|hop
operator|++
control|)
block|{
comment|/* go out using the phys port of the path */
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|p_path
operator|->
name|path
index|[
name|hop
index|]
argument_list|)
expr_stmt|;
comment|/* make sure we got a valid port and it has a remote port */
if|if
condition|(
operator|!
name|p_physp
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4104: "
literal|"DR Traversal stopped on invalid port at hop:%u\n"
argument_list|,
name|hop
argument_list|)
expr_stmt|;
name|status
operator|=
name|CL_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* we track the ports we go out along the path */
if|if
condition|(
name|hop
operator|>
literal|1
condition|)
name|cl_map_insert
argument_list|(
name|p_physp_map
argument_list|,
name|ptr_to_key
argument_list|(
name|p_physp
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Traversed through node: 0x%016"
name|PRIx64
literal|" port:%u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|)
argument_list|,
name|p_path
operator|->
name|path
index|[
name|hop
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_physp
operator|=
name|osm_physp_get_remote
argument_list|(
name|p_physp
argument_list|)
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4106: "
literal|"DR Traversal stopped on missing remote physp at hop:%u\n"
argument_list|,
name|hop
argument_list|)
expr_stmt|;
name|status
operator|=
name|CL_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_node
operator|=
name|osm_physp_get_node_ptr
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|physp_update_new_dr_path
parameter_list|(
name|IN
name|osm_physp_t
specifier|const
modifier|*
name|p_dest_physp
parameter_list|,
name|IN
name|cl_map_t
modifier|*
name|p_visited_map
parameter_list|,
name|IN
name|osm_bind_handle_t
modifier|*
name|h_bind
parameter_list|)
block|{
name|cl_list_t
name|tmpPortsList
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|,
modifier|*
name|p_src_physp
init|=
name|NULL
decl_stmt|;
name|uint8_t
name|path_array
index|[
name|IB_SUBNET_PATH_HOPS_MAX
index|]
decl_stmt|;
name|uint8_t
name|i
init|=
literal|0
decl_stmt|;
name|osm_dr_path_t
modifier|*
name|p_dr_path
decl_stmt|;
name|cl_list_construct
argument_list|(
operator|&
name|tmpPortsList
argument_list|)
expr_stmt|;
name|cl_list_init
argument_list|(
operator|&
name|tmpPortsList
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|cl_list_insert_head
argument_list|(
operator|&
name|tmpPortsList
argument_list|,
name|p_dest_physp
argument_list|)
expr_stmt|;
comment|/* get the output port where we need to come from */
name|p_physp
operator|=
operator|(
name|osm_physp_t
operator|*
operator|)
name|cl_map_get
argument_list|(
name|p_visited_map
argument_list|,
name|ptr_to_key
argument_list|(
name|p_dest_physp
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_physp
operator|!=
name|NULL
condition|)
block|{
name|cl_list_insert_head
argument_list|(
operator|&
name|tmpPortsList
argument_list|,
name|p_physp
argument_list|)
expr_stmt|;
comment|/* get the input port through where we reached the output port */
name|p_src_physp
operator|=
name|p_physp
expr_stmt|;
name|p_physp
operator|=
operator|(
name|osm_physp_t
operator|*
operator|)
name|cl_map_get
argument_list|(
name|p_visited_map
argument_list|,
name|ptr_to_key
argument_list|(
name|p_physp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if we reached a null p_physp - this means we are at the begining 		   of the path. Break. */
if|if
condition|(
name|p_physp
operator|==
name|NULL
condition|)
break|break;
comment|/* get the output port */
name|p_physp
operator|=
operator|(
name|osm_physp_t
operator|*
operator|)
name|cl_map_get
argument_list|(
name|p_visited_map
argument_list|,
name|ptr_to_key
argument_list|(
name|p_physp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|path_array
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|path_array
argument_list|)
argument_list|)
expr_stmt|;
name|p_physp
operator|=
operator|(
name|osm_physp_t
operator|*
operator|)
name|cl_list_remove_head
argument_list|(
operator|&
name|tmpPortsList
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_physp
operator|!=
name|NULL
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|path_array
index|[
name|i
index|]
operator|=
name|p_physp
operator|->
name|port_num
expr_stmt|;
name|p_physp
operator|=
operator|(
name|osm_physp_t
operator|*
operator|)
name|cl_list_remove_head
argument_list|(
operator|&
name|tmpPortsList
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_src_physp
condition|)
block|{
name|p_dr_path
operator|=
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_src_physp
argument_list|)
expr_stmt|;
name|osm_dr_path_init
argument_list|(
name|p_dr_path
argument_list|,
name|i
argument_list|,
name|path_array
argument_list|)
expr_stmt|;
block|}
name|cl_list_destroy
argument_list|(
operator|&
name|tmpPortsList
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_physp_replace_dr_path_with_alternate_dr_path
parameter_list|(
name|IN
name|osm_log_t
modifier|*
name|p_log
parameter_list|,
name|IN
name|osm_subn_t
specifier|const
modifier|*
name|p_subn
parameter_list|,
name|IN
name|osm_physp_t
specifier|const
modifier|*
name|p_dest_physp
parameter_list|,
name|IN
name|osm_bind_handle_t
modifier|*
name|h_bind
parameter_list|)
block|{
name|cl_map_t
name|physp_map
decl_stmt|;
name|cl_map_t
name|visited_map
decl_stmt|;
name|osm_dr_path_t
modifier|*
name|p_dr_path
decl_stmt|;
name|cl_list_t
modifier|*
name|p_currPortsList
decl_stmt|;
name|cl_list_t
modifier|*
name|p_nextPortsList
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|,
modifier|*
name|p_remote_physp
decl_stmt|;
name|ib_net64_t
name|port_guid
decl_stmt|;
name|boolean_t
name|next_list_is_full
init|=
name|TRUE
decl_stmt|,
name|reached_dest
init|=
name|FALSE
decl_stmt|;
name|uint8_t
name|num_ports
decl_stmt|,
name|port_num
decl_stmt|;
name|p_nextPortsList
operator|=
operator|(
name|cl_list_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cl_list_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_nextPortsList
condition|)
return|return;
comment|/* 	   initialize the map of all port participating in current dr path 	   not including first and last switches 	 */
name|cl_map_construct
argument_list|(
operator|&
name|physp_map
argument_list|)
expr_stmt|;
name|cl_map_init
argument_list|(
operator|&
name|physp_map
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cl_map_construct
argument_list|(
operator|&
name|visited_map
argument_list|)
expr_stmt|;
name|cl_map_init
argument_list|(
operator|&
name|visited_map
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|p_dr_path
operator|=
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_dest_physp
argument_list|)
expr_stmt|;
name|physp_get_dr_physp_set
argument_list|(
name|p_log
argument_list|,
name|p_subn
argument_list|,
name|p_dr_path
argument_list|,
operator|&
name|physp_map
argument_list|)
expr_stmt|;
comment|/* 	   BFS from OSM port until we find the target physp but avoid 	   going through mapped ports 	 */
name|cl_list_construct
argument_list|(
name|p_nextPortsList
argument_list|)
expr_stmt|;
name|cl_list_init
argument_list|(
name|p_nextPortsList
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|port_guid
operator|=
name|p_subn
operator|->
name|sm_port_guid
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|port_guid
argument_list|)
expr_stmt|;
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|p_subn
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4105: No SM port object\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	   HACK: We are assuming SM is running on HCA, so when getting the default 	   port we'll get the port connected to the rest of the subnet. If SM is 	   running on SWITCH - we should try to get a dr path from all switch ports. 	 */
name|p_physp
operator|=
name|p_port
operator|->
name|p_physp
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|cl_list_insert_tail
argument_list|(
name|p_nextPortsList
argument_list|,
name|p_physp
argument_list|)
expr_stmt|;
while|while
condition|(
name|next_list_is_full
operator|==
name|TRUE
condition|)
block|{
name|next_list_is_full
operator|=
name|FALSE
expr_stmt|;
name|p_currPortsList
operator|=
name|p_nextPortsList
expr_stmt|;
name|p_nextPortsList
operator|=
operator|(
name|cl_list_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cl_list_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_nextPortsList
condition|)
block|{
name|p_nextPortsList
operator|=
name|p_currPortsList
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|cl_list_construct
argument_list|(
name|p_nextPortsList
argument_list|)
expr_stmt|;
name|cl_list_init
argument_list|(
name|p_nextPortsList
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|p_physp
operator|=
operator|(
name|osm_physp_t
operator|*
operator|)
name|cl_list_remove_head
argument_list|(
name|p_currPortsList
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_physp
operator|!=
name|NULL
condition|)
block|{
comment|/* If we are in a switch - need to go out through all 			   the other physical ports of the switch */
name|num_ports
operator|=
name|osm_node_get_num_physp
argument_list|(
name|p_physp
operator|->
name|p_node
argument_list|)
expr_stmt|;
for|for
control|(
name|port_num
operator|=
literal|1
init|;
name|port_num
operator|<
name|num_ports
condition|;
name|port_num
operator|++
control|)
block|{
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|p_physp
operator|->
name|p_node
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
condition|)
name|p_remote_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_physp
operator|->
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
else|else
comment|/* this is HCA or router - the remote port is just the port connected 					   on the other side */
name|p_remote_physp
operator|=
name|p_physp
operator|->
name|p_remote_physp
expr_stmt|;
comment|/* 				   make sure that all of the following occurred: 				   1. The port isn't NULL 				   2. This is not the port we came from 				   3. The port is not in the physp_map 				   4. This port haven't been visited before 				 */
if|if
condition|(
name|p_remote_physp
operator|&&
name|p_remote_physp
operator|!=
name|p_physp
operator|&&
name|cl_map_get
argument_list|(
operator|&
name|physp_map
argument_list|,
name|ptr_to_key
argument_list|(
name|p_remote_physp
argument_list|)
argument_list|)
operator|==
name|NULL
operator|&&
name|cl_map_get
argument_list|(
operator|&
name|visited_map
argument_list|,
name|ptr_to_key
argument_list|(
name|p_remote_physp
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* Insert the port into the visited_map, and save its source port */
name|cl_map_insert
argument_list|(
operator|&
name|visited_map
argument_list|,
name|ptr_to_key
argument_list|(
name|p_remote_physp
argument_list|)
argument_list|,
name|p_physp
argument_list|)
expr_stmt|;
comment|/* Is this the p_dest_physp? */
if|if
condition|(
name|p_remote_physp
operator|==
name|p_dest_physp
condition|)
block|{
comment|/* update the new dr path */
name|physp_update_new_dr_path
argument_list|(
name|p_dest_physp
argument_list|,
operator|&
name|visited_map
argument_list|,
name|h_bind
argument_list|)
expr_stmt|;
name|reached_dest
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* add the p_remote_physp to the nextPortsList */
name|cl_list_insert_tail
argument_list|(
name|p_nextPortsList
argument_list|,
name|p_remote_physp
argument_list|)
expr_stmt|;
name|next_list_is_full
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|p_physp
operator|=
operator|(
name|osm_physp_t
operator|*
operator|)
name|cl_list_remove_head
argument_list|(
name|p_currPortsList
argument_list|)
expr_stmt|;
if|if
condition|(
name|reached_dest
operator|==
name|TRUE
condition|)
block|{
comment|/* free the rest of the currPortsList */
while|while
condition|(
name|p_physp
operator|!=
name|NULL
condition|)
name|p_physp
operator|=
operator|(
name|osm_physp_t
operator|*
operator|)
name|cl_list_remove_head
argument_list|(
name|p_currPortsList
argument_list|)
expr_stmt|;
comment|/* free the nextPortsList, if items were added to it */
name|p_physp
operator|=
operator|(
name|osm_physp_t
operator|*
operator|)
name|cl_list_remove_head
argument_list|(
name|p_nextPortsList
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_physp
operator|!=
name|NULL
condition|)
name|p_physp
operator|=
operator|(
name|osm_physp_t
operator|*
operator|)
name|cl_list_remove_head
argument_list|(
name|p_nextPortsList
argument_list|)
expr_stmt|;
name|next_list_is_full
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|cl_list_destroy
argument_list|(
name|p_currPortsList
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_currPortsList
argument_list|)
expr_stmt|;
block|}
comment|/* cleanup */
name|Exit
label|:
name|cl_list_destroy
argument_list|(
name|p_nextPortsList
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_nextPortsList
argument_list|)
expr_stmt|;
name|cl_map_destroy
argument_list|(
operator|&
name|physp_map
argument_list|)
expr_stmt|;
name|cl_map_destroy
argument_list|(
operator|&
name|visited_map
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|osm_link_is_healthy
parameter_list|(
name|IN
specifier|const
name|osm_physp_t
modifier|*
name|p_physp
parameter_list|)
block|{
name|osm_physp_t
modifier|*
name|p_remote_physp
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|p_remote_physp
operator|=
name|p_physp
operator|->
name|p_remote_physp
expr_stmt|;
if|if
condition|(
name|p_remote_physp
operator|!=
name|NULL
condition|)
return|return
operator|(
operator|(
name|p_physp
operator|->
name|healthy
operator|)
operator|&
operator|(
name|p_remote_physp
operator|->
name|healthy
operator|)
operator|)
return|;
comment|/* the other side is not known - consider the link as healthy */
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
name|osm_physp_set_pkey_tbl
parameter_list|(
name|IN
name|osm_log_t
modifier|*
name|p_log
parameter_list|,
name|IN
specifier|const
name|osm_subn_t
modifier|*
name|p_subn
parameter_list|,
name|IN
name|osm_physp_t
modifier|*
name|p_physp
parameter_list|,
name|IN
name|ib_pkey_table_t
modifier|*
name|p_pkey_tbl
parameter_list|,
name|IN
name|uint16_t
name|block_num
parameter_list|,
name|IN
name|boolean_t
name|is_set
parameter_list|)
block|{
name|uint16_t
name|max_blocks
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_pkey_tbl
argument_list|)
expr_stmt|;
comment|/* 	   (14.2.5.7) - the block number valid values are 0-2047, and are 	   further limited by the size of the P_Key table specified by 	   the PartitionCap on the node. 	 */
if|if
condition|(
operator|!
name|p_physp
operator|->
name|p_node
operator|->
name|sw
operator|||
name|p_physp
operator|->
name|port_num
operator|==
literal|0
condition|)
comment|/* 		   The maximum blocks is defined in the node info: partition cap 		   for CA, router, and switch management ports. 		 */
name|max_blocks
operator|=
operator|(
name|cl_ntoh16
argument_list|(
name|p_physp
operator|->
name|p_node
operator|->
name|node_info
operator|.
name|partition_cap
argument_list|)
operator|+
name|IB_NUM_PKEY_ELEMENTS_IN_BLOCK
operator|-
literal|1
operator|)
operator|/
name|IB_NUM_PKEY_ELEMENTS_IN_BLOCK
expr_stmt|;
else|else
comment|/* 		   This is a switch, and not a management port. The maximum 		   blocks is defined in the switch info: partition enforcement 		   cap. 		 */
name|max_blocks
operator|=
operator|(
name|cl_ntoh16
argument_list|(
name|p_physp
operator|->
name|p_node
operator|->
name|sw
operator|->
name|switch_info
operator|.
name|enforce_cap
argument_list|)
operator|+
name|IB_NUM_PKEY_ELEMENTS_IN_BLOCK
operator|-
literal|1
operator|)
operator|/
name|IB_NUM_PKEY_ELEMENTS_IN_BLOCK
expr_stmt|;
if|if
condition|(
name|block_num
operator|>=
name|max_blocks
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4108: "
literal|"Got illegal update for block number:%u max:%u "
literal|"for GUID: %"
name|PRIx64
literal|" port number:%u\n"
argument_list|,
name|block_num
argument_list|,
name|max_blocks
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_physp
operator|->
name|p_node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|)
argument_list|,
name|p_physp
operator|->
name|port_num
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* decrement block received counter */
if|if
condition|(
operator|!
name|is_set
condition|)
name|p_physp
operator|->
name|pkeys
operator|.
name|rcv_blocks_cnt
operator|--
expr_stmt|;
name|osm_pkey_tbl_set
argument_list|(
operator|&
name|p_physp
operator|->
name|pkeys
argument_list|,
name|block_num
argument_list|,
name|p_pkey_tbl
argument_list|,
name|p_subn
operator|->
name|opt
operator|.
name|allow_both_pkeys
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|osm_alias_guid_t
modifier|*
name|osm_alias_guid_new
parameter_list|(
name|IN
specifier|const
name|ib_net64_t
name|alias_guid
parameter_list|,
name|IN
name|osm_port_t
modifier|*
name|p_base_port
parameter_list|)
block|{
name|osm_alias_guid_t
modifier|*
name|p_alias_guid
decl_stmt|;
name|p_alias_guid
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_alias_guid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_alias_guid
condition|)
block|{
name|p_alias_guid
operator|->
name|alias_guid
operator|=
name|alias_guid
expr_stmt|;
name|p_alias_guid
operator|->
name|p_base_port
operator|=
name|p_base_port
expr_stmt|;
block|}
return|return
name|p_alias_guid
return|;
block|}
end_function

begin_function
name|void
name|osm_alias_guid_delete
parameter_list|(
name|IN
name|OUT
name|osm_alias_guid_t
modifier|*
modifier|*
name|pp_alias_guid
parameter_list|)
block|{
name|free
argument_list|(
operator|*
name|pp_alias_guid
argument_list|)
expr_stmt|;
operator|*
name|pp_alias_guid
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|osm_physp_set_port_info
argument_list|(
name|IN
name|osm_physp_t
operator|*
name|p_physp
argument_list|,
name|IN
specifier|const
name|ib_port_info_t
operator|*
name|p_pi
argument_list|,
name|IN
specifier|const
expr|struct
name|osm_sm
operator|*
name|p_sm
argument_list|)
block|{
name|CL_ASSERT
argument_list|(
name|p_pi
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|osm_physp_is_valid
argument_list|(
name|p_physp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_port_info_get_port_state
argument_list|(
name|p_pi
argument_list|)
operator|==
name|IB_LINK_DOWN
condition|)
block|{
comment|/* If PortState is down, only copy PortState */
comment|/* and PortPhysicalState per C14-24-2.1 */
name|ib_port_info_set_port_state
argument_list|(
operator|&
name|p_physp
operator|->
name|port_info
argument_list|,
name|IB_LINK_DOWN
argument_list|)
expr_stmt|;
name|ib_port_info_set_port_phys_state
argument_list|(
name|ib_port_info_get_port_phys_state
argument_list|(
name|p_pi
argument_list|)
argument_list|,
operator|&
name|p_physp
operator|->
name|port_info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p_physp
operator|->
name|port_info
operator|=
operator|*
name|p_pi
expr_stmt|;
comment|/* The MKey in p_pi can only be considered valid if it's 		 * for a HCA/router or switch port 0, and it's either 		 * non-zero or the MKeyProtect bits are also zero. 		 */
if|if
condition|(
operator|(
name|osm_node_get_type
argument_list|(
name|p_physp
operator|->
name|p_node
argument_list|)
operator|!=
name|IB_NODE_TYPE_SWITCH
operator|||
name|p_physp
operator|->
name|port_num
operator|==
literal|0
operator|)
operator|&&
operator|(
name|p_pi
operator|->
name|m_key
operator|!=
literal|0
operator|||
name|ib_port_info_get_mpb
argument_list|(
name|p_pi
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|osm_db_guid2mkey_set
argument_list|(
name|p_sm
operator|->
name|p_subn
operator|->
name|p_g2m
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_physp
operator|->
name|port_guid
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_pi
operator|->
name|m_key
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

end_unit

