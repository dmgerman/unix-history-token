begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2005 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  * Copyright (c) 2013 Oracle and/or its affiliates. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_sminfo_rcv_t.  * This object represents the SMInfo Receiver object.  * This object is part of the opensm family of objects.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qmap.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_passivelock.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_SMINFO_RCV_C
end_define

begin_include
include|#
directive|include
file|<opensm/osm_madw.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_node.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_subnet.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_sm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_comment
comment|/**********************************************************************  Return TRUE if the remote sm given (by ib_sm_info_t) is higher,  return FALSE otherwise.  By higher - we mean: SM with higher priority or with same priority  and lower GUID. **********************************************************************/
end_comment

begin_function
specifier|static
name|boolean_t
name|smi_rcv_remote_sm_is_higher
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
specifier|const
name|ib_sm_info_t
modifier|*
name|p_rem_smi
parameter_list|)
block|{
return|return
name|osm_sm_is_greater_than
argument_list|(
name|ib_sminfo_get_priority
argument_list|(
name|p_rem_smi
argument_list|)
argument_list|,
name|p_rem_smi
operator|->
name|guid
argument_list|,
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|sm_priority
argument_list|,
name|sm
operator|->
name|p_subn
operator|->
name|sm_port_guid
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|smi_rcv_process_get_request
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|,
name|IN
name|boolean_t
name|fill_sm_key
parameter_list|)
block|{
name|uint8_t
name|payload
index|[
name|IB_SMP_DATA_SIZE
index|]
decl_stmt|;
name|ib_sm_info_t
modifier|*
name|p_smi
init|=
operator|(
name|ib_sm_info_t
operator|*
operator|)
name|payload
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
comment|/* No real need to grab the lock for this function. */
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
operator|->
name|method
operator|==
name|IB_MAD_METHOD_GET
argument_list|)
expr_stmt|;
name|p_smi
operator|->
name|guid
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|sm_port_guid
expr_stmt|;
name|p_smi
operator|->
name|act_count
operator|=
name|cl_hton32
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
operator|->
name|stats
operator|.
name|qp0_mads_sent
argument_list|)
expr_stmt|;
name|p_smi
operator|->
name|pri_state
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
operator||
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|sm_priority
operator|<<
literal|4
argument_list|)
expr_stmt|;
name|p_smi
operator|->
name|sm_key
operator|=
name|fill_sm_key
condition|?
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|sm_key
else|:
literal|0
expr_stmt|;
name|status
operator|=
name|osm_resp_send
argument_list|(
name|sm
argument_list|,
name|p_madw
argument_list|,
literal|0
argument_list|,
name|payload
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 2F02: "
literal|"Error sending SMInfo response (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Check if the p_smp received is legal.  * Current checks:  *   MADHeader:AttributeModifier of ACKNOWLEDGE that was not sent by a  *             Standby SM.  *   MADHeader:AttributeModifiers of HANDOVER/DISABLE/STANDBY/DISCOVER  *             that was not sent by a Master SM.  * FUTURE - TO DO:  *   Check that the SM_Key matches.  **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|smi_rcv_check_set_req_legality
parameter_list|(
name|IN
specifier|const
name|ib_smp_t
modifier|*
name|p_smp
parameter_list|)
block|{
name|ib_sm_info_t
modifier|*
name|p_smi
decl_stmt|;
name|p_smi
operator|=
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_smp
operator|->
name|attr_mod
operator|==
name|IB_SMINFO_ATTR_MOD_ACKNOWLEDGE
condition|)
block|{
if|if
condition|(
name|ib_sminfo_get_state
argument_list|(
name|p_smi
argument_list|)
operator|==
name|IB_SMINFO_STATE_STANDBY
condition|)
return|return
name|IB_SUCCESS
return|;
block|}
elseif|else
if|if
condition|(
name|p_smp
operator|->
name|attr_mod
operator|==
name|IB_SMINFO_ATTR_MOD_HANDOVER
operator|||
name|p_smp
operator|->
name|attr_mod
operator|==
name|IB_SMINFO_ATTR_MOD_DISABLE
operator|||
name|p_smp
operator|->
name|attr_mod
operator|==
name|IB_SMINFO_ATTR_MOD_STANDBY
operator|||
name|p_smp
operator|->
name|attr_mod
operator|==
name|IB_SMINFO_ATTR_MOD_DISCOVER
condition|)
block|{
if|if
condition|(
name|ib_sminfo_get_state
argument_list|(
name|p_smi
argument_list|)
operator|==
name|IB_SMINFO_STATE_MASTER
condition|)
return|return
name|IB_SUCCESS
return|;
block|}
return|return
name|IB_INVALID_PARAMETER
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|smi_rcv_process_set_request
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|)
block|{
name|uint8_t
name|payload
index|[
name|IB_SMP_DATA_SIZE
index|]
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|ib_sm_info_t
modifier|*
name|p_smi
init|=
operator|(
name|ib_sm_info_t
operator|*
operator|)
name|payload
decl_stmt|;
name|ib_sm_info_t
modifier|*
name|sm_smi
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|osm_sm_signal_t
name|sm_signal
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|sm_smi
operator|=
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_smp
operator|->
name|method
operator|!=
name|IB_MAD_METHOD_SET
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 2F03: "
literal|"Unsupported set method 0x%X\n"
argument_list|,
name|p_smp
operator|->
name|method
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|CL_PLOCK_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|p_smi
operator|->
name|guid
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|sm_port_guid
expr_stmt|;
name|p_smi
operator|->
name|act_count
operator|=
name|cl_hton32
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
operator|->
name|stats
operator|.
name|qp0_mads_sent
argument_list|)
expr_stmt|;
name|p_smi
operator|->
name|pri_state
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
operator||
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|sm_priority
operator|<<
literal|4
argument_list|)
expr_stmt|;
name|p_smi
operator|->
name|sm_key
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|sm_key
expr_stmt|;
comment|/* Check the legality of the packet */
name|status
operator|=
name|smi_rcv_check_set_req_legality
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 2F04: "
literal|"Check legality failed. AttributeModifier:0x%X RemoteState:%s\n"
argument_list|,
name|p_smp
operator|->
name|attr_mod
argument_list|,
name|osm_get_sm_mgr_state_str
argument_list|(
name|ib_sminfo_get_state
argument_list|(
name|sm_smi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_resp_send
argument_list|(
name|sm
argument_list|,
name|p_madw
argument_list|,
literal|7
argument_list|,
name|payload
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 2F05: "
literal|"Error sending SMInfo response (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* translate from IB_SMINFO_ATTR to OSM_SM_SIGNAL */
switch|switch
condition|(
name|p_smp
operator|->
name|attr_mod
condition|)
block|{
case|case
name|IB_SMINFO_ATTR_MOD_HANDOVER
case|:
name|sm_signal
operator|=
name|OSM_SM_SIGNAL_HANDOVER
expr_stmt|;
break|break;
case|case
name|IB_SMINFO_ATTR_MOD_ACKNOWLEDGE
case|:
name|sm_signal
operator|=
name|OSM_SM_SIGNAL_ACKNOWLEDGE
expr_stmt|;
break|break;
case|case
name|IB_SMINFO_ATTR_MOD_DISABLE
case|:
name|sm_signal
operator|=
name|OSM_SM_SIGNAL_DISABLE
expr_stmt|;
break|break;
case|case
name|IB_SMINFO_ATTR_MOD_STANDBY
case|:
name|sm_signal
operator|=
name|OSM_SM_SIGNAL_STANDBY
expr_stmt|;
break|break;
case|case
name|IB_SMINFO_ATTR_MOD_DISCOVER
case|:
name|sm_signal
operator|=
name|OSM_SM_SIGNAL_DISCOVER
expr_stmt|;
break|break;
default|default:
comment|/* 		   This code shouldn't be reached - checked in the 		   check legality 		 */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 2F06: "
literal|"THIS CODE SHOULD NOT BE REACHED!!\n"
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
comment|/* check legality of the needed transition in the SM state machine */
name|status
operator|=
name|osm_sm_state_mgr_check_legality
argument_list|(
name|sm
argument_list|,
name|sm_signal
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 2F07: "
literal|"Failed check of legality of needed SM transition. "
literal|"AttributeModifier:0x%X RemoteState:%s\n"
argument_list|,
name|p_smp
operator|->
name|attr_mod
argument_list|,
name|osm_get_sm_mgr_state_str
argument_list|(
name|ib_sminfo_get_state
argument_list|(
name|sm_smi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_resp_send
argument_list|(
name|sm
argument_list|,
name|p_madw
argument_list|,
literal|7
argument_list|,
name|payload
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 2F08: "
literal|"Error sending SMInfo response (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* the SubnSet(SMInfo) command is ok. Send a response. */
name|status
operator|=
name|osm_resp_send
argument_list|(
name|sm
argument_list|,
name|p_madw
argument_list|,
literal|0
argument_list|,
name|payload
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 2F09: "
literal|"Error sending SMInfo response (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
comment|/* it is a legal packet - act according to it */
comment|/* if the AttributeModifier is STANDBY - need to save on the sm in */
comment|/* the master_sm_guid variable - the guid of the current master. */
if|if
condition|(
name|p_smp
operator|->
name|attr_mod
operator|==
name|IB_SMINFO_ATTR_MOD_STANDBY
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Received a STANDBY signal. Updating "
literal|"sm_state_mgr master_guid: 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|sm_smi
operator|->
name|guid
argument_list|)
argument_list|)
expr_stmt|;
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|sm
operator|->
name|master_sm_guid
operator|=
name|sm_smi
operator|->
name|guid
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|osm_sm_state_mgr_process
argument_list|(
name|sm
argument_list|,
name|sm_signal
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 2F10: "
literal|"Error in SM state transition (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|smi_rcv_process_get_sm
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
specifier|const
name|osm_remote_sm_t
modifier|*
name|p_sm
parameter_list|,
name|boolean_t
name|light_sweep
parameter_list|)
block|{
specifier|const
name|ib_sm_info_t
modifier|*
name|p_smi
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_smi
operator|=
operator|&
name|p_sm
operator|->
name|smi
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Detected SM 0x%016"
name|PRIx64
literal|" in state %u (%s)\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_smi
operator|->
name|guid
argument_list|)
argument_list|,
name|ib_sminfo_get_state
argument_list|(
name|p_smi
argument_list|)
argument_list|,
name|osm_get_sm_mgr_state_str
argument_list|(
name|ib_sminfo_get_state
argument_list|(
name|p_smi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check the state of this SM vs. our own. */
switch|switch
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
condition|)
block|{
case|case
name|IB_SMINFO_STATE_NOTACTIVE
case|:
break|break;
case|case
name|IB_SMINFO_STATE_DISCOVERING
case|:
switch|switch
condition|(
name|ib_sminfo_get_state
argument_list|(
name|p_smi
argument_list|)
condition|)
block|{
case|case
name|IB_SMINFO_STATE_NOTACTIVE
case|:
break|break;
case|case
name|IB_SMINFO_STATE_MASTER
case|:
name|sm
operator|->
name|master_sm_found
operator|=
literal|1
expr_stmt|;
comment|/* save on the sm the guid of the current master. */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Found master SM. Updating sm_state_mgr master_guid: 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_smi
operator|->
name|guid
argument_list|)
argument_list|)
expr_stmt|;
name|sm
operator|->
name|master_sm_guid
operator|=
name|p_smi
operator|->
name|guid
expr_stmt|;
break|break;
case|case
name|IB_SMINFO_STATE_DISCOVERING
case|:
case|case
name|IB_SMINFO_STATE_STANDBY
case|:
if|if
condition|(
name|smi_rcv_remote_sm_is_higher
argument_list|(
name|sm
argument_list|,
name|p_smi
argument_list|)
condition|)
block|{
comment|/* the remote is a higher sm - need to stop sweeping */
name|sm
operator|->
name|master_sm_found
operator|=
literal|1
expr_stmt|;
comment|/* save on the sm the guid of the higher SM we found - */
comment|/* we will poll it - as long as it lives - we should be in Standby. */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Found higher SM. Updating sm_state_mgr master_guid:"
literal|" 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_smi
operator|->
name|guid
argument_list|)
argument_list|)
expr_stmt|;
name|sm
operator|->
name|master_sm_guid
operator|=
name|p_smi
operator|->
name|guid
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|IB_SMINFO_STATE_STANDBY
case|:
comment|/* if the guid of the SM that sent us this response is equal to the */
comment|/* p_sm_mgr->master_guid - then this is a signal that the polling */
switch|switch
condition|(
name|ib_sminfo_get_state
argument_list|(
name|p_smi
argument_list|)
condition|)
block|{
case|case
name|IB_SMINFO_STATE_MASTER
case|:
comment|/* This means the master is alive */
comment|/* Signal that to the SM state mgr */
name|osm_sm_state_mgr_signal_master_is_alive
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|smi_rcv_remote_sm_is_higher
argument_list|(
name|sm
argument_list|,
name|p_smi
argument_list|)
condition|)
name|osm_send_trap144
argument_list|(
name|sm
argument_list|,
name|TRAP_144_MASK_SM_PRIORITY_CHANGE
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_SMINFO_STATE_STANDBY
case|:
comment|/* This should be the response from the sm we are polling. */
comment|/* If it is - then signal master is alive */
if|if
condition|(
name|sm
operator|->
name|master_sm_guid
operator|==
name|p_sm
operator|->
name|smi
operator|.
name|guid
condition|)
block|{
comment|/* Make sure that it is an SM with higher priority than us. 				   If we started polling it when it was master, and it moved 				   to standby - then it might be with a lower priority than 				   us - and then we don't want to continue polling it. */
if|if
condition|(
name|smi_rcv_remote_sm_is_higher
argument_list|(
name|sm
argument_list|,
name|p_smi
argument_list|)
condition|)
name|osm_sm_state_mgr_signal_master_is_alive
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* any other state - do nothing */
break|break;
block|}
break|break;
case|case
name|IB_SMINFO_STATE_MASTER
case|:
switch|switch
condition|(
name|ib_sminfo_get_state
argument_list|(
name|p_smi
argument_list|)
condition|)
block|{
case|case
name|IB_SMINFO_STATE_MASTER
case|:
comment|/* If this is a response due to our polling, this means that we are 			 * waiting for a handover from this SM, and it is still alive - 			 * signal that. If we detected the remote SM with higher priority 			 * we should init a heavy sweep in order to go STANDBY. If we 			 * detected a remote SM with lower priority, we should resend trap144 			 * as it might not get it and we don't want to wait for a HANDOVER 			 * forever. 			 */
if|if
condition|(
name|sm
operator|->
name|polling_sm_guid
condition|)
block|{
if|if
condition|(
name|smi_rcv_remote_sm_is_higher
argument_list|(
name|sm
argument_list|,
name|p_smi
argument_list|)
condition|)
name|sm
operator|->
name|p_subn
operator|->
name|force_heavy_sweep
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
comment|/* Update master_sm_guid to the GUID of the newly 					 * found MASTER SM and send trap 144 to it. 					 */
name|sm
operator|->
name|master_sm_guid
operator|=
name|sm
operator|->
name|polling_sm_guid
expr_stmt|;
name|osm_send_trap144
argument_list|(
name|sm
argument_list|,
name|TRAP_144_MASK_SM_PRIORITY_CHANGE
argument_list|)
expr_stmt|;
block|}
name|osm_sm_state_mgr_signal_master_is_alive
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a response we got while sweeping the subnet. 				 * 				 * If this is during a heavy sweep, we will handle a case of 				 * handover needed later on, when the sweep is done and all 				 * SMs are recognized. 				 * 				 * If this is during a light sweep, initiate a heavy sweep 				 * to initiate handover scenarios. 				 * 				 * Note that it does not matter if the remote SM is lower 				 * or higher priority.  If it is lower priority, we must 				 * wait for it HANDOVER.  If it is higher priority, we need 				 * to HANDOVER to it.  Both cases are handled after doing 				 * a heavy sweep. 				 */
if|if
condition|(
name|light_sweep
condition|)
name|sm
operator|->
name|p_subn
operator|->
name|force_heavy_sweep
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|IB_SMINFO_STATE_STANDBY
case|:
if|if
condition|(
name|light_sweep
operator|&&
name|smi_rcv_remote_sm_is_higher
argument_list|(
name|sm
argument_list|,
name|p_smi
argument_list|)
condition|)
name|sm
operator|->
name|p_subn
operator|->
name|force_heavy_sweep
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
comment|/* any other state - do nothing */
break|break;
block|}
break|break;
default|default:
break|break;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|smi_rcv_process_get_response
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|)
block|{
specifier|const
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
specifier|const
name|ib_sm_info_t
modifier|*
name|p_smi
decl_stmt|;
name|cl_qmap_t
modifier|*
name|p_sm_tbl
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|ib_net64_t
name|port_guid
decl_stmt|;
name|osm_remote_sm_t
modifier|*
name|p_sm
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_smp
operator|->
name|method
operator|!=
name|IB_MAD_METHOD_GET_RESP
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 2F11: "
literal|"Unsupported response method 0x%X\n"
argument_list|,
name|p_smp
operator|->
name|method
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_smi
operator|=
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
name|p_sm_tbl
operator|=
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sm_guid_tbl
expr_stmt|;
name|port_guid
operator|=
name|p_smi
operator|->
name|guid
expr_stmt|;
name|osm_dump_sm_info_v2
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|p_smi
argument_list|,
name|FILE_ID
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
expr_stmt|;
comment|/* Check that the sm_key of the found SM is the same as ours, 	   or is zero. If not - OpenSM should ignore this SM */
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|sm_key
operator|!=
literal|0
operator|&&
name|p_smi
operator|->
name|sm_key
operator|!=
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|sm_key
condition|)
block|{
if|if
condition|(
name|p_smp
operator|->
name|mgmt_class
operator|==
name|IB_MCLASS_SUBN_DIR
condition|)
name|sprint_uint8_arr
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|p_smp
operator|->
name|initial_path
argument_list|,
name|p_smp
operator|->
name|hop_count
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"LID %u"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_madw
operator|->
name|mad_addr
operator|.
name|addr_type
operator|.
name|smi
operator|.
name|source_lid
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 2F18: "
literal|"Got SM (%s) with sm_key 0x%016"
name|PRIx64
literal|" that doesn't match our "
literal|"local sm_key. Ignoring SMInfo\n"
argument_list|,
name|buf
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_smi
operator|->
name|sm_key
argument_list|)
argument_list|)
expr_stmt|;
name|osm_log_v2
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
name|FILE_ID
argument_list|,
literal|"Found remote SM (%s) with non-matching sm_key\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Determine if we already have another SM object for this SM. */
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 2F12: "
literal|"No port object for this SM\n"
argument_list|)
expr_stmt|;
goto|goto
name|_unlock_and_exit
goto|;
block|}
if|if
condition|(
name|osm_port_get_guid
argument_list|(
name|p_port
argument_list|)
operator|!=
name|p_smi
operator|->
name|guid
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 2F13: "
literal|"Bogus SM port GUID, Expected 0x%016"
name|PRIx64
literal|", Received 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_port_get_guid
argument_list|(
name|p_port
argument_list|)
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_smi
operator|->
name|guid
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|_unlock_and_exit
goto|;
block|}
if|if
condition|(
name|port_guid
operator|==
name|sm
operator|->
name|p_subn
operator|->
name|sm_port_guid
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Self query response received - SM port 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|_unlock_and_exit
goto|;
block|}
name|p_sm
operator|=
operator|(
name|osm_remote_sm_t
operator|*
operator|)
name|cl_qmap_get
argument_list|(
name|p_sm_tbl
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sm
operator|==
operator|(
name|osm_remote_sm_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_sm_tbl
argument_list|)
condition|)
block|{
name|p_sm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p_sm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sm
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 2F14: "
literal|"Unable to allocate SM object\n"
argument_list|)
expr_stmt|;
goto|goto
name|_unlock_and_exit
goto|;
block|}
name|osm_remote_sm_init
argument_list|(
name|p_sm
argument_list|,
name|p_smi
argument_list|)
expr_stmt|;
name|cl_qmap_insert
argument_list|(
name|p_sm_tbl
argument_list|,
name|port_guid
argument_list|,
operator|&
name|p_sm
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We already know this SM. Update the SMInfo attribute. */
name|p_sm
operator|->
name|smi
operator|=
operator|*
name|p_smi
expr_stmt|;
name|smi_rcv_process_get_sm
argument_list|(
name|sm
argument_list|,
name|p_sm
argument_list|,
name|osm_madw_get_smi_context_ptr
argument_list|(
name|p_madw
argument_list|)
operator|->
name|light_sweep
argument_list|)
expr_stmt|;
name|_unlock_and_exit
label|:
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|smi_rcv_process_set_response
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|)
block|{
specifier|const
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
specifier|const
name|ib_sm_info_t
modifier|*
name|p_smi
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_smp_get_status
argument_list|(
name|p_smp
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"MAD status 0x%x received\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|ib_smp_get_status
argument_list|(
name|p_smp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|p_smp
operator|->
name|method
operator|!=
name|IB_MAD_METHOD_GET_RESP
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 2F16: "
literal|"Unsupported response method 0x%X\n"
argument_list|,
name|p_smp
operator|->
name|method
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_smi
operator|=
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
name|osm_dump_sm_info_v2
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|p_smi
argument_list|,
name|FILE_ID
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
expr_stmt|;
comment|/* Check the AttributeModifier */
if|if
condition|(
name|p_smp
operator|->
name|attr_mod
operator|!=
name|IB_SMINFO_ATTR_MOD_HANDOVER
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 2F17: "
literal|"Unsupported attribute modifier 0x%X, "
literal|"expected ATTR_MOD_HANDOVER\n"
argument_list|,
name|p_smp
operator|->
name|attr_mod
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* This is a response on a HANDOVER request - Nothing to do. */
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_sminfo_rcv_process
parameter_list|(
name|IN
name|void
modifier|*
name|context
parameter_list|,
name|IN
name|void
modifier|*
name|data
parameter_list|)
block|{
name|osm_sm_t
modifier|*
name|sm
init|=
name|context
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_madw
init|=
name|data
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|osm_smi_context_t
modifier|*
name|p_smi_context
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_smp_get_status
argument_list|(
name|p_smp
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"MAD status 0x%x received\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|ib_smp_get_status
argument_list|(
name|p_smp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Determine if this is a request for our own SMInfo or if 	   this is a response to our request for another SM's SMInfo. */
if|if
condition|(
name|ib_smp_is_response
argument_list|(
name|p_smp
argument_list|)
condition|)
block|{
specifier|const
name|ib_sm_info_t
modifier|*
name|p_smi
init|=
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
decl_stmt|;
comment|/* Get the context - to see if this is a response to a Get or Set method */
name|p_smi_context
operator|=
name|osm_madw_get_smi_context_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
comment|/* Verify that response is from expected port and there is 		   no port moving issue. */
if|if
condition|(
name|p_smi_context
operator|->
name|port_guid
operator|!=
name|p_smi
operator|->
name|guid
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 2F19: "
literal|"Unexpected SM port GUID in response"
literal|", Expected 0x%016"
name|PRIx64
literal|", Received 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_smi_context
operator|->
name|port_guid
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_smi
operator|->
name|guid
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|p_smi_context
operator|->
name|set_method
operator|==
name|FALSE
condition|)
comment|/* this is a response to a Get method */
name|smi_rcv_process_get_response
argument_list|(
name|sm
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
else|else
comment|/* this is a response to a Set method */
name|smi_rcv_process_set_response
argument_list|(
name|sm
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|ib_net64_t
name|my_mkey
decl_stmt|;
name|uint8_t
name|mpb
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|sm
operator|->
name|p_subn
operator|->
name|sm_port_guid
argument_list|)
operator|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
operator|!
name|p_port
operator|->
name|p_physp
condition|)
goto|goto
name|Exit
goto|;
name|my_mkey
operator|=
name|ib_port_info_get_m_key
argument_list|(
operator|&
name|p_port
operator|->
name|p_physp
operator|->
name|port_info
argument_list|)
expr_stmt|;
name|mpb
operator|=
name|my_mkey
condition|?
name|ib_port_info_get_mpb
argument_list|(
operator|&
name|p_port
operator|->
name|p_physp
operator|->
name|port_info
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|p_smp
operator|->
name|method
operator|==
name|IB_MAD_METHOD_GET
condition|)
block|{
comment|/* M-Key Authentication */
if|if
condition|(
name|my_mkey
operator|&&
name|mpb
operator|>
literal|1
operator|&&
name|my_mkey
operator|!=
name|p_smp
operator|->
name|m_key
condition|)
block|{
if|if
condition|(
name|p_smp
operator|->
name|mgmt_class
operator|==
name|IB_MCLASS_SUBN_DIR
condition|)
name|sprint_uint8_arr
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|p_smp
operator|->
name|return_path
argument_list|,
name|p_smp
operator|->
name|hop_count
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"LID %u"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_madw
operator|->
name|mad_addr
operator|.
name|addr_type
operator|.
name|smi
operator|.
name|source_lid
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 2F1A: "
literal|"SMInfo(GET) sender (%s) authentication failure."
literal|"Ignoring SMInfo\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* If protection bits == 1 but MKEY mismatch, return SM-KEY = 0 */
if|if
condition|(
name|my_mkey
operator|&&
name|mpb
operator|==
literal|1
operator|&&
name|my_mkey
operator|!=
name|p_smp
operator|->
name|m_key
condition|)
name|smi_rcv_process_get_request
argument_list|(
name|sm
argument_list|,
name|p_madw
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
name|smi_rcv_process_get_request
argument_list|(
name|sm
argument_list|,
name|p_madw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* M-Key Authentication */
if|if
condition|(
name|my_mkey
operator|&&
name|my_mkey
operator|!=
name|p_smp
operator|->
name|m_key
condition|)
block|{
if|if
condition|(
name|p_smp
operator|->
name|mgmt_class
operator|==
name|IB_MCLASS_SUBN_DIR
condition|)
name|sprint_uint8_arr
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|p_smp
operator|->
name|return_path
argument_list|,
name|p_smp
operator|->
name|hop_count
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"LID %u"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_madw
operator|->
name|mad_addr
operator|.
name|addr_type
operator|.
name|smi
operator|.
name|source_lid
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 2F1B: "
literal|"SMInfo(SET) sender (%s) authentication failure."
literal|"Ignoring SMInfo\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* This should be a SubnSet request */
name|smi_rcv_process_set_request
argument_list|(
name|sm
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
block|}
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

