begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2005 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  * Copyright (c) 2013 Oracle and/or its affiliates. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qmap.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_passivelock.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qlist.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_SA_PKEY_RECORD_C
end_define

begin_include
include|#
directive|include
file|<vendor/osm_vendor_api.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_port.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_node.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_pkey.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_sa.h>
end_include

begin_define
define|#
directive|define
name|SA_PKEY_RESP_SIZE
value|SA_ITEM_RESP_SIZE(pkey_rec)
end_define

begin_typedef
typedef|typedef
struct|struct
name|osm_pkey_search_ctxt
block|{
specifier|const
name|ib_pkey_table_record_t
modifier|*
name|p_rcvd_rec
decl_stmt|;
name|ib_net64_t
name|comp_mask
decl_stmt|;
name|uint16_t
name|block_num
decl_stmt|;
name|cl_qlist_t
modifier|*
name|p_list
decl_stmt|;
name|osm_sa_t
modifier|*
name|sa
decl_stmt|;
specifier|const
name|osm_physp_t
modifier|*
name|p_req_physp
decl_stmt|;
block|}
name|osm_pkey_search_ctxt_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|sa_pkey_create
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
name|osm_physp_t
modifier|*
name|p_physp
parameter_list|,
name|IN
name|osm_pkey_search_ctxt_t
modifier|*
name|p_ctxt
parameter_list|,
name|IN
name|uint16_t
name|block
parameter_list|)
block|{
name|osm_sa_item_t
modifier|*
name|p_rec_item
decl_stmt|;
name|uint16_t
name|lid
decl_stmt|;
name|ib_pkey_table_t
modifier|*
name|tbl
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_rec_item
operator|=
name|malloc
argument_list|(
name|SA_PKEY_RESP_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_rec_item
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4602: "
literal|"rec_item alloc failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|p_physp
operator|->
name|p_node
operator|->
name|node_info
operator|.
name|node_type
operator|!=
name|IB_NODE_TYPE_SWITCH
condition|)
name|lid
operator|=
name|p_physp
operator|->
name|port_info
operator|.
name|base_lid
expr_stmt|;
else|else
name|lid
operator|=
name|osm_node_get_base_lid
argument_list|(
name|p_physp
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"New P_Key table for: port 0x%016"
name|PRIx64
literal|", lid %u, port %u Block:%u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_physp
argument_list|)
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|lid
argument_list|)
argument_list|,
name|osm_physp_get_port_num
argument_list|(
name|p_physp
argument_list|)
argument_list|,
name|block
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_rec_item
argument_list|,
literal|0
argument_list|,
name|SA_PKEY_RESP_SIZE
argument_list|)
expr_stmt|;
name|p_rec_item
operator|->
name|resp
operator|.
name|pkey_rec
operator|.
name|lid
operator|=
name|lid
expr_stmt|;
name|p_rec_item
operator|->
name|resp
operator|.
name|pkey_rec
operator|.
name|block_num
operator|=
name|block
expr_stmt|;
name|p_rec_item
operator|->
name|resp
operator|.
name|pkey_rec
operator|.
name|port_num
operator|=
name|osm_physp_get_port_num
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
comment|/* FIXME: There are ninf.PartitionCap or swinf.PartitionEnforcementCap 	   pkey entries so everything in that range is a valid block number 	   even if opensm is not using it. Return 0. However things outside 	   that range should return no entries. Not sure how to figure that 	   here? The range of pkey_tbl can be less than the cap, so 	   this falsely triggers. */
name|tbl
operator|=
name|osm_pkey_tbl_block_get
argument_list|(
name|osm_physp_get_pkey_tbl
argument_list|(
name|p_physp
argument_list|)
argument_list|,
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|tbl
condition|)
name|p_rec_item
operator|->
name|resp
operator|.
name|pkey_rec
operator|.
name|pkey_tbl
operator|=
operator|*
name|tbl
expr_stmt|;
name|cl_qlist_insert_tail
argument_list|(
name|p_ctxt
operator|->
name|p_list
argument_list|,
operator|&
name|p_rec_item
operator|->
name|list_item
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sa_pkey_check_physp
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
name|osm_physp_t
modifier|*
name|p_physp
parameter_list|,
name|osm_pkey_search_ctxt_t
modifier|*
name|p_ctxt
parameter_list|)
block|{
name|ib_net64_t
name|comp_mask
init|=
name|p_ctxt
operator|->
name|comp_mask
decl_stmt|;
name|uint16_t
name|block
decl_stmt|,
name|num_blocks
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* we got here with the phys port - all is left is to get the right block */
if|if
condition|(
name|comp_mask
operator|&
name|IB_PKEY_COMPMASK_BLOCK
condition|)
block|{
name|sa_pkey_create
argument_list|(
name|sa
argument_list|,
name|p_physp
argument_list|,
name|p_ctxt
argument_list|,
name|p_ctxt
operator|->
name|block_num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|num_blocks
operator|=
name|osm_pkey_tbl_get_num_blocks
argument_list|(
name|osm_physp_get_pkey_tbl
argument_list|(
name|p_physp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|block
operator|=
literal|0
init|;
name|block
operator|<
name|num_blocks
condition|;
name|block
operator|++
control|)
name|sa_pkey_create
argument_list|(
name|sa
argument_list|,
name|p_physp
argument_list|,
name|p_ctxt
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sa_pkey_by_comp_mask
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
name|p_port
parameter_list|,
name|osm_pkey_search_ctxt_t
modifier|*
name|p_ctxt
parameter_list|)
block|{
specifier|const
name|ib_pkey_table_record_t
modifier|*
name|p_rcvd_rec
decl_stmt|;
name|ib_net64_t
name|comp_mask
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|uint8_t
name|num_ports
decl_stmt|;
specifier|const
name|osm_physp_t
modifier|*
name|p_req_physp
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_rcvd_rec
operator|=
name|p_ctxt
operator|->
name|p_rcvd_rec
expr_stmt|;
name|comp_mask
operator|=
name|p_ctxt
operator|->
name|comp_mask
expr_stmt|;
name|port_num
operator|=
name|p_rcvd_rec
operator|->
name|port_num
expr_stmt|;
name|p_req_physp
operator|=
name|p_ctxt
operator|->
name|p_req_physp
expr_stmt|;
comment|/* if this is a switch port we can search all ports 	   otherwise we must be looking on port 0 */
if|if
condition|(
name|p_port
operator|->
name|p_node
operator|->
name|node_info
operator|.
name|node_type
operator|!=
name|IB_NODE_TYPE_SWITCH
condition|)
block|{
comment|/* we put it in the comp mask and port num */
name|port_num
operator|=
name|p_port
operator|->
name|p_physp
operator|->
name|port_num
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Using Physical Default Port Number: 0x%X (for End Node)\n"
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|comp_mask
operator||=
name|IB_PKEY_COMPMASK_PORT
expr_stmt|;
block|}
if|if
condition|(
name|comp_mask
operator|&
name|IB_PKEY_COMPMASK_PORT
condition|)
block|{
if|if
condition|(
name|port_num
operator|<
name|osm_node_get_num_physp
argument_list|(
name|p_port
operator|->
name|p_node
argument_list|)
condition|)
block|{
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_port
operator|->
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
comment|/* Check that the p_physp is valid, and that is shares a pkey 			   with the p_req_physp. */
if|if
condition|(
name|p_physp
operator|&&
name|osm_physp_share_pkey
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_req_physp
argument_list|,
name|p_physp
argument_list|,
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|allow_both_pkeys
argument_list|)
condition|)
name|sa_pkey_check_physp
argument_list|(
name|sa
argument_list|,
name|p_physp
argument_list|,
name|p_ctxt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4603: "
literal|"Given Physical Port Number: 0x%X is out of range should be< 0x%X\n"
argument_list|,
name|port_num
argument_list|,
name|osm_node_get_num_physp
argument_list|(
name|p_port
operator|->
name|p_node
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
else|else
block|{
name|num_ports
operator|=
name|osm_node_get_num_physp
argument_list|(
name|p_port
operator|->
name|p_node
argument_list|)
expr_stmt|;
for|for
control|(
name|port_num
operator|=
literal|0
init|;
name|port_num
operator|<
name|num_ports
condition|;
name|port_num
operator|++
control|)
block|{
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_port
operator|->
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
condition|)
continue|continue;
comment|/* if the requester and the p_physp don't share a pkey - 			   continue */
if|if
condition|(
operator|!
name|osm_physp_share_pkey
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_req_physp
argument_list|,
name|p_physp
argument_list|,
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|allow_both_pkeys
argument_list|)
condition|)
continue|continue;
name|sa_pkey_check_physp
argument_list|(
name|sa
argument_list|,
name|p_physp
argument_list|,
name|p_ctxt
argument_list|)
expr_stmt|;
block|}
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sa_pkey_by_comp_mask_cb
parameter_list|(
name|IN
name|cl_map_item_t
modifier|*
name|p_map_item
parameter_list|,
name|IN
name|void
modifier|*
name|cxt
parameter_list|)
block|{
specifier|const
name|osm_port_t
modifier|*
name|p_port
init|=
operator|(
name|osm_port_t
operator|*
operator|)
name|p_map_item
decl_stmt|;
name|osm_pkey_search_ctxt_t
modifier|*
name|p_ctxt
init|=
name|cxt
decl_stmt|;
name|sa_pkey_by_comp_mask
argument_list|(
name|p_ctxt
operator|->
name|sa
argument_list|,
name|p_port
argument_list|,
name|p_ctxt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_pkey_rec_rcv_process
parameter_list|(
name|IN
name|void
modifier|*
name|ctx
parameter_list|,
name|IN
name|void
modifier|*
name|data
parameter_list|)
block|{
name|osm_sa_t
modifier|*
name|sa
init|=
name|ctx
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_madw
init|=
name|data
decl_stmt|;
specifier|const
name|ib_sa_mad_t
modifier|*
name|p_rcvd_mad
decl_stmt|;
specifier|const
name|ib_pkey_table_record_t
modifier|*
name|p_rcvd_rec
decl_stmt|;
specifier|const
name|osm_port_t
modifier|*
name|p_port
init|=
name|NULL
decl_stmt|;
name|cl_qlist_t
name|rec_list
decl_stmt|;
name|osm_pkey_search_ctxt_t
name|context
decl_stmt|;
name|ib_net64_t
name|comp_mask
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_req_physp
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|sa
argument_list|)
expr_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_rcvd_mad
operator|=
name|osm_madw_get_sa_mad_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_rcvd_rec
operator|=
operator|(
name|ib_pkey_table_record_t
operator|*
operator|)
name|ib_sa_mad_get_payload_ptr
argument_list|(
name|p_rcvd_mad
argument_list|)
expr_stmt|;
name|comp_mask
operator|=
name|p_rcvd_mad
operator|->
name|comp_mask
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_rcvd_mad
operator|->
name|attr_id
operator|==
name|IB_MAD_ATTR_PKEY_TBL_RECORD
argument_list|)
expr_stmt|;
comment|/* we only support SubnAdmGet and SubnAdmGetTable methods */
if|if
condition|(
name|p_rcvd_mad
operator|->
name|method
operator|!=
name|IB_MAD_METHOD_GET
operator|&&
name|p_rcvd_mad
operator|->
name|method
operator|!=
name|IB_MAD_METHOD_GETTABLE
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4605: "
literal|"Unsupported Method (%s) for PKeyRecord request\n"
argument_list|,
name|ib_get_sa_method_str
argument_list|(
name|p_rcvd_mad
operator|->
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_MAD_STATUS_UNSUP_METHOD_ATTR
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	   p922 - P_KeyTableRecords shall only be provided in response 	   to trusted requests. 	   Check that the requester is a trusted one. 	 */
if|if
condition|(
name|p_rcvd_mad
operator|->
name|sm_key
operator|!=
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|sa_key
condition|)
block|{
comment|/* This is not a trusted requester! */
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4608: "
literal|"Ignoring PKeyRecord request from non-trusted requester"
literal|" with SM_Key 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_rcvd_mad
operator|->
name|sm_key
argument_list|)
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|cl_plock_acquire
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
comment|/* update the requester physical port */
name|p_req_physp
operator|=
name|osm_get_physp_by_mad_addr
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|sa
operator|->
name|p_subn
argument_list|,
name|osm_madw_get_mad_addr_ptr
argument_list|(
name|p_madw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_req_physp
operator|==
name|NULL
condition|)
block|{
name|cl_plock_release
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4604: "
literal|"Cannot find requester physical port\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Requester port GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_req_physp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cl_qlist_init
argument_list|(
operator|&
name|rec_list
argument_list|)
expr_stmt|;
name|context
operator|.
name|p_rcvd_rec
operator|=
name|p_rcvd_rec
expr_stmt|;
name|context
operator|.
name|p_list
operator|=
operator|&
name|rec_list
expr_stmt|;
name|context
operator|.
name|comp_mask
operator|=
name|p_rcvd_mad
operator|->
name|comp_mask
expr_stmt|;
name|context
operator|.
name|sa
operator|=
name|sa
expr_stmt|;
name|context
operator|.
name|block_num
operator|=
name|cl_ntoh16
argument_list|(
name|p_rcvd_rec
operator|->
name|block_num
argument_list|)
expr_stmt|;
name|context
operator|.
name|p_req_physp
operator|=
name|p_req_physp
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Got Query Lid:%u(%02X), Block:0x%02X(%02X), Port:0x%02X(%02X)\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_rcvd_rec
operator|->
name|lid
argument_list|)
argument_list|,
operator|(
name|comp_mask
operator|&
name|IB_PKEY_COMPMASK_LID
operator|)
operator|!=
literal|0
argument_list|,
name|p_rcvd_rec
operator|->
name|port_num
argument_list|,
operator|(
name|comp_mask
operator|&
name|IB_PKEY_COMPMASK_PORT
operator|)
operator|!=
literal|0
argument_list|,
name|context
operator|.
name|block_num
argument_list|,
operator|(
name|comp_mask
operator|&
name|IB_PKEY_COMPMASK_BLOCK
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	   If the user specified a LID, it obviously narrows our 	   work load, since we don't have to search every port 	 */
if|if
condition|(
name|comp_mask
operator|&
name|IB_PKEY_COMPMASK_LID
condition|)
block|{
name|p_port
operator|=
name|osm_get_port_by_lid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|p_rcvd_rec
operator|->
name|lid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 460B: "
literal|"No port found with LID %u\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_rcvd_rec
operator|->
name|lid
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sa_pkey_by_comp_mask
argument_list|(
name|sa
argument_list|,
name|p_port
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
block|}
else|else
name|cl_qmap_apply_func
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|port_guid_tbl
argument_list|,
name|sa_pkey_by_comp_mask_cb
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
name|cl_plock_release
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|osm_sa_respond
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_pkey_table_record_t
argument_list|)
argument_list|,
operator|&
name|rec_list
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

