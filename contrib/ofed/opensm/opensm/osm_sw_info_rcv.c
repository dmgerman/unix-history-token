begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2005,2008 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  * Copyright (c) 2009 HNR Consulting. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_si_rcv_t.  * This object represents the SwitchInfo Receiver object.  * This object is part of the opensm family of objects.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qmap.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_passivelock.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_SW_INFO_RCV_C
end_define

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_switch.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_subnet.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/**********************************************************************  The plock must be held before calling this function. **********************************************************************/
end_comment

begin_comment
unit|static void si_rcv_get_fwd_tbl(IN osm_sm_t * sm, IN osm_switch_t * p_sw) { 	osm_madw_context_t context; 	osm_dr_path_t *p_dr_path; 	osm_physp_t *p_physp; 	osm_node_t *p_node; 	uint32_t block_id_ho; 	uint32_t max_block_id_ho; 	ib_api_status_t status = IB_SUCCESS;  	OSM_LOG_ENTER(sm->p_log);  	CL_ASSERT(p_sw);  	p_node = p_sw->p_node;  	CL_ASSERT(osm_node_get_type(p_node) == IB_NODE_TYPE_SWITCH);  	context.lft_context.node_guid = osm_node_get_node_guid(p_node); 	context.lft_context.set_method = FALSE;  	max_block_id_ho = osm_switch_get_max_block_id_in_use(p_sw);  	p_physp = osm_node_get_physp_ptr(p_node, 0); 	p_dr_path = osm_physp_get_dr_path_ptr(p_physp);  	for (block_id_ho = 0; block_id_ho<= max_block_id_ho; block_id_ho++) { 		OSM_LOG(sm->p_log, OSM_LOG_DEBUG, 			"Retrieving FT block %u\n", block_id_ho);  		status = osm_req_get(sm, p_dr_path, IB_MAD_ATTR_LIN_FWD_TBL, 				     cl_hton32(block_id_ho), TRUE, 0, 				     CL_DISP_MSGID_NONE,&context); 		if (status != IB_SUCCESS)
comment|/* continue the loop despite the error */
end_comment

begin_comment
unit|OSM_LOG(sm->p_log, OSM_LOG_ERROR, "ERR 3603: " 				"Failure initiating PortInfo request (%s)\n", 				ib_get_err_str(status)); 	}  	OSM_LOG_EXIT(sm->p_log); }
comment|/**********************************************************************  The plock must be held before calling this function. **********************************************************************/
end_comment

begin_comment
unit|static void si_rcv_get_mcast_fwd_tbl(IN osm_sm_t * sm, IN osm_switch_t * p_sw) { 	osm_madw_context_t context; 	osm_dr_path_t *p_dr_path; 	osm_physp_t *p_physp; 	osm_node_t *p_node; 	osm_mcast_tbl_t *p_tbl; 	uint32_t block_id_ho; 	uint32_t max_block_id_ho; 	uint32_t position; 	uint32_t max_position; 	uint32_t attr_mod_ho; 	ib_api_status_t status = IB_SUCCESS;  	OSM_LOG_ENTER(sm->p_log);  	CL_ASSERT(p_sw);  	p_node = p_sw->p_node;  	CL_ASSERT(osm_node_get_type(p_node) == IB_NODE_TYPE_SWITCH);  	if (osm_switch_get_mcast_fwd_tbl_size(p_sw) == 0) { 		OSM_LOG(sm->p_log, OSM_LOG_DEBUG, 			"Multicast not supported by switch 0x%016" PRIx64 "\n", 			cl_ntoh64(osm_node_get_node_guid(p_node))); 		goto Exit; 	}  	context.mft_context.node_guid = osm_node_get_node_guid(p_node); 	context.mft_context.set_method = FALSE;  	p_tbl = osm_switch_get_mcast_tbl_ptr(p_sw); 	max_block_id_ho = osm_mcast_tbl_get_max_block(p_tbl);  	if (max_block_id_ho> IB_MCAST_MAX_BLOCK_ID) { 		OSM_LOG(sm->p_log, OSM_LOG_ERROR, "ERR 3609: " 			"Out-of-range mcast block size = %u on switch 0x%016" 			PRIx64 "\n", max_block_id_ho, 			cl_ntoh64(osm_node_get_node_guid(p_node))); 		goto Exit; 	}  	max_position = osm_mcast_tbl_get_max_position(p_tbl);  	CL_ASSERT(max_position<= IB_MCAST_POSITION_MAX);  	OSM_LOG(sm->p_log, OSM_LOG_DEBUG, 		"Max MFT block = %u, Max position = %u\n", max_block_id_ho, 		max_position);  	p_physp = osm_node_get_physp_ptr(p_node, 0); 	p_dr_path = osm_physp_get_dr_path_ptr(p_physp);  	for (block_id_ho = 0; block_id_ho<= max_block_id_ho; block_id_ho++) { 		OSM_LOG(sm->p_log, OSM_LOG_DEBUG, 			"Retrieving MFT block %u\n", block_id_ho);  		for (position = 0; position<= max_position; position++) { 			OSM_LOG(sm->p_log, OSM_LOG_DEBUG, 				"Retrieving MFT position %u\n", position);  			attr_mod_ho = 			    block_id_ho | position<< IB_MCAST_POSITION_SHIFT; 			status = 			    osm_req_get(sm, p_dr_path, 					IB_MAD_ATTR_MCAST_FWD_TBL, 					cl_hton32(attr_mod_ho), TRUE, 0, 					CL_DISP_MSGID_NONE,&context); 			if (status != IB_SUCCESS)
comment|/* continue the loop despite the error */
end_comment

begin_endif
unit|OSM_LOG(sm->p_log, OSM_LOG_ERROR, "ERR 3607: " 					"Failure initiating PortInfo request (%s)\n", 					ib_get_err_str(status)); 		} 	}  Exit: 	OSM_LOG_EXIT(sm->p_log); }
endif|#
directive|endif
end_endif

begin_comment
comment|/**********************************************************************    Lock must be held on entry to this function. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|si_rcv_process_new
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
name|p_node
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|)
block|{
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_check
decl_stmt|;
name|ib_switch_info_t
modifier|*
name|p_si
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|cl_qmap_t
modifier|*
name|p_sw_guid_tbl
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_sw_guid_tbl
operator|=
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_si
operator|=
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
name|osm_dump_switch_info_v2
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|p_si
argument_list|,
name|FILE_ID
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
expr_stmt|;
name|p_sw
operator|=
name|osm_switch_new
argument_list|(
name|p_node
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3608: "
literal|"Unable to allocate new switch object\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* set subnet max mlid to the minimum MulticastFDBCap of all switches */
if|if
condition|(
name|p_si
operator|->
name|mcast_cap
operator|&&
name|cl_ntoh16
argument_list|(
name|p_si
operator|->
name|mcast_cap
argument_list|)
operator|+
name|IB_LID_MCAST_START_HO
operator|-
literal|1
operator|<
name|sm
operator|->
name|p_subn
operator|->
name|max_mcast_lid_ho
condition|)
block|{
name|sm
operator|->
name|p_subn
operator|->
name|max_mcast_lid_ho
operator|=
name|cl_ntoh16
argument_list|(
name|p_si
operator|->
name|mcast_cap
argument_list|)
operator|+
name|IB_LID_MCAST_START_HO
operator|-
literal|1
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Subnet max multicast lid is 0x%X\n"
argument_list|,
name|sm
operator|->
name|p_subn
operator|->
name|max_mcast_lid_ho
argument_list|)
expr_stmt|;
block|}
comment|/* set subnet max unicast lid to the minimum LinearFDBCap of all switches */
if|if
condition|(
name|cl_ntoh16
argument_list|(
name|p_si
operator|->
name|lin_cap
argument_list|)
operator|<
name|sm
operator|->
name|p_subn
operator|->
name|max_ucast_lid_ho
condition|)
block|{
name|sm
operator|->
name|p_subn
operator|->
name|max_ucast_lid_ho
operator|=
name|cl_ntoh16
argument_list|(
name|p_si
operator|->
name|lin_cap
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Subnet max unicast lid is 0x%X\n"
argument_list|,
name|sm
operator|->
name|p_subn
operator|->
name|max_ucast_lid_ho
argument_list|)
expr_stmt|;
block|}
name|p_check
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_insert
argument_list|(
name|p_sw_guid_tbl
argument_list|,
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|,
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_check
operator|!=
name|p_sw
condition|)
block|{
comment|/* This shouldn't happen since we hold the lock! */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3605: "
literal|"Unable to add new switch object to database\n"
argument_list|)
expr_stmt|;
name|osm_switch_delete
argument_list|(
operator|&
name|p_sw
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_node
operator|->
name|sw
operator|=
name|p_sw
expr_stmt|;
comment|/* Update the switch info according to the info we just received. */
name|osm_switch_set_switch_info
argument_list|(
name|p_sw
argument_list|,
name|p_si
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Don't bother retrieving the current unicast and multicast tables 	   from the switches.  The current version of SM does 	   not support silent take-over of an existing multicast 	   configuration.  	   Gathering the multicast tables can also generate large amounts 	   of extra subnet-init traffic.  	   The code to retrieve the tables was fully debugged. */
block|si_rcv_get_fwd_tbl(sm, p_sw); 	if (!sm->p_subn->opt.disable_multicast) 		si_rcv_get_mcast_fwd_tbl(sm, p_sw);
endif|#
directive|endif
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************    Lock must be held on entry to this function.    Return 1 if the caller is expected to send a change_detected event.    this can not be done internally as the event needs the lock... **********************************************************************/
end_comment

begin_function
specifier|static
name|boolean_t
name|si_rcv_process_existing
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
name|p_node
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|)
block|{
name|osm_switch_t
modifier|*
name|p_sw
init|=
name|p_node
operator|->
name|sw
decl_stmt|;
name|ib_switch_info_t
modifier|*
name|p_si
decl_stmt|;
name|osm_si_context_t
modifier|*
name|p_si_context
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|osm_epi_lft_change_event_t
name|lft_change
decl_stmt|;
name|boolean_t
name|is_change_detected
init|=
name|FALSE
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_si
operator|=
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
name|p_si_context
operator|=
name|osm_madw_get_si_context_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Received logical %cetResp()\n"
argument_list|,
name|p_si_context
operator|->
name|set_method
condition|?
literal|'S'
else|:
literal|'G'
argument_list|)
expr_stmt|;
name|osm_switch_set_switch_info
argument_list|(
name|p_sw
argument_list|,
name|p_si
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_si_context
operator|->
name|light_sweep
operator|==
name|TRUE
operator|&&
operator|!
name|p_si_context
operator|->
name|set_method
condition|)
block|{
comment|/* If state changed bit is on the mad was returned with an 		   error - signal a change to the state manager. */
if|if
condition|(
name|ib_smp_get_status
argument_list|(
name|p_smp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"GetResp() received with error in light sweep. "
literal|"Commencing heavy sweep\n"
argument_list|)
expr_stmt|;
name|is_change_detected
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ib_switch_info_get_state_change
argument_list|(
name|p_si
argument_list|)
condition|)
block|{
name|osm_dump_switch_info_v2
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|p_si
argument_list|,
name|FILE_ID
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
expr_stmt|;
name|is_change_detected
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|first_time_master_sweep
operator|==
name|FALSE
operator|&&
name|p_si_context
operator|->
name|set_method
operator|&&
name|p_si_context
operator|->
name|lft_top_change
condition|)
block|{
name|lft_change
operator|.
name|p_sw
operator|=
name|p_sw
expr_stmt|;
name|lft_change
operator|.
name|flags
operator|=
name|LFT_CHANGED_LFT_TOP
expr_stmt|;
name|lft_change
operator|.
name|lft_top
operator|=
name|cl_ntoh16
argument_list|(
name|p_si
operator|->
name|lin_top
argument_list|)
expr_stmt|;
name|lft_change
operator|.
name|block_num
operator|=
literal|0
expr_stmt|;
name|osm_opensm_report_event
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
argument_list|,
name|OSM_EVENT_ID_LFT_CHANGE
argument_list|,
operator|&
name|lft_change
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|is_change_detected
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|si_rcv_get_sp0_info
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
name|node
parameter_list|)
block|{
name|osm_madw_context_t
name|context
decl_stmt|;
name|osm_physp_t
modifier|*
name|physp
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|int
name|mlnx_epi_supported
init|=
literal|0
decl_stmt|;
name|physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|port_guid
operator|=
name|osm_physp_get_port_guid
argument_list|(
name|physp
argument_list|)
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|set_method
operator|=
name|FALSE
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|light_sweep
operator|=
name|FALSE
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|active_transition
operator|=
name|FALSE
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|client_rereg
operator|=
name|FALSE
expr_stmt|;
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
name|osm_physp_get_dr_path_ptr
argument_list|(
name|physp
argument_list|)
argument_list|,
name|IB_MAD_ATTR_PORT_INFO
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3611: "
literal|"Failure initiating PortInfo request (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_switch_info_is_enhanced_port0
argument_list|(
operator|&
name|node
operator|->
name|sw
operator|->
name|switch_info
argument_list|)
operator|&&
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|fdr10
condition|)
block|{
name|mlnx_epi_supported
operator|=
name|is_mlnx_ext_port_info_supported
argument_list|(
name|ib_node_info_get_vendor_id
argument_list|(
operator|&
name|node
operator|->
name|node_info
argument_list|)
argument_list|,
name|node
operator|->
name|node_info
operator|.
name|device_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlnx_epi_supported
condition|)
block|{
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
name|osm_physp_get_dr_path_ptr
argument_list|(
name|physp
argument_list|)
argument_list|,
name|IB_MAD_ATTR_MLNX_EXTENDED_PORT_INFO
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3616: "
literal|"Failure initiating MLNX ExtPortInfo request (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|osm_si_rcv_process
parameter_list|(
name|IN
name|void
modifier|*
name|context
parameter_list|,
name|IN
name|void
modifier|*
name|data
parameter_list|)
block|{
name|osm_sm_t
modifier|*
name|sm
init|=
name|context
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_madw
init|=
name|data
decl_stmt|;
name|ib_switch_info_t
modifier|*
name|p_si
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|ib_net64_t
name|node_guid
decl_stmt|;
name|osm_si_context_t
modifier|*
name|p_context
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_si
operator|=
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
name|p_context
operator|=
name|osm_madw_get_si_context_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|node_guid
operator|=
name|p_context
operator|->
name|node_guid
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Switch GUID 0x%016"
name|PRIx64
literal|", TID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|node_guid
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_smp
operator|->
name|trans_id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_smp_get_status
argument_list|(
name|p_smp
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"MAD status 0x%x received\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|ib_smp_get_status
argument_list|(
name|p_smp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit2
goto|;
block|}
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|p_node
operator|=
name|osm_get_node_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|node_guid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_node
condition|)
block|{
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3606: "
literal|"SwitchInfo received for nonexistent node "
literal|"with GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|node_guid
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Hack for bad value in Mellanox switch */
if|if
condition|(
name|cl_ntoh16
argument_list|(
name|p_si
operator|->
name|lin_top
argument_list|)
operator|>
name|IB_LID_UCAST_END_HO
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3610: "
literal|"\n\t\t\t\tBad LinearFDBTop value = 0x%X "
literal|"on switch 0x%"
name|PRIx64
literal|"\n\t\t\t\tForcing internal correction to 0x%X\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_si
operator|->
name|lin_top
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p_si
operator|->
name|lin_top
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Acquire the switch object for this switch. */
if|if
condition|(
operator|!
name|p_node
operator|->
name|sw
condition|)
block|{
name|si_rcv_process_new
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
comment|/* A new switch was found during the sweep so we need 		   to ignore the current LFT settings. */
name|sm
operator|->
name|p_subn
operator|->
name|ignore_existing_lfts
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|si_rcv_process_existing
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_madw
argument_list|)
condition|)
comment|/* we might get back a request for signaling change was detected */
name|sm
operator|->
name|p_subn
operator|->
name|force_heavy_sweep
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|p_context
operator|->
name|light_sweep
operator|||
name|p_context
operator|->
name|set_method
condition|)
goto|goto
name|Exit
goto|;
name|si_rcv_get_sp0_info
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|)
expr_stmt|;
name|Exit
label|:
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|Exit2
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

