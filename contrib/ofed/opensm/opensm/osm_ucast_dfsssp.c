begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2008 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2015 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  * Copyright (c) 2009-2015 ZIH, TU Dresden, Federal Republic of Germany. All rights reserved.  * Copyright (C) 2012-2017 Tokyo Institute of Technology. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of OpenSM (deadlock-free) single-source-shortest-path routing  *    (with dijkstra algorithm)  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_UCAST_DFSSSP_C
end_define

begin_include
include|#
directive|include
file|<opensm/osm_ucast_mgr.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_node.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_multicast.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_mcast_mgr.h>
end_include

begin_comment
comment|/* "infinity" for dijkstra */
end_comment

begin_define
define|#
directive|define
name|INF
value|0x7FFFFFFF
end_define

begin_enum
enum|enum
block|{
name|UNDISCOVERED
init|=
literal|0
block|,
name|DISCOVERED
block|}
enum|;
end_enum

begin_enum
enum|enum
block|{
name|UNKNOWN
init|=
literal|0
block|,
name|GRAY
block|,
name|BLACK
block|, }
enum|;
end_enum

begin_typedef
typedef|typedef
struct|struct
name|link
block|{
name|uint64_t
name|guid
decl_stmt|;
comment|/* guid of the neighbor behind the link */
name|uint32_t
name|from
decl_stmt|;
comment|/* base_index in the adjazenz list (start of the link) */
name|uint8_t
name|from_port
decl_stmt|;
comment|/* port on the base_side (needed for weight update to identify the correct link for multigraphs) */
name|uint32_t
name|to
decl_stmt|;
comment|/* index of the neighbor in the adjazenz list (end of the link) */
name|uint8_t
name|to_port
decl_stmt|;
comment|/* port on the side of the neighbor (needed for the LFT) */
name|uint64_t
name|weight
decl_stmt|;
comment|/* link weight */
name|struct
name|link
modifier|*
name|next
decl_stmt|;
block|}
name|link_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|vertex
block|{
comment|/* informations of the fabric */
name|uint64_t
name|guid
decl_stmt|;
name|uint16_t
name|lid
decl_stmt|;
comment|/* for lft filling */
name|uint32_t
name|num_hca
decl_stmt|;
comment|/* numbers of Hca/LIDs on the switch, for weight calculation */
name|link_t
modifier|*
name|links
decl_stmt|;
name|uint8_t
name|hops
decl_stmt|;
comment|/* for dijkstra routing */
name|link_t
modifier|*
name|used_link
decl_stmt|;
comment|/* link between the vertex discovered before and this vertex */
name|uint64_t
name|distance
decl_stmt|;
comment|/* distance from source to this vertex */
name|uint8_t
name|state
decl_stmt|;
comment|/* for the binary heap */
name|uint32_t
name|heap_id
decl_stmt|;
comment|/* for LFT writing and debug */
name|osm_switch_t
modifier|*
name|sw
decl_stmt|;
comment|/* selfpointer */
name|boolean_t
name|dropped
decl_stmt|;
comment|/* indicate dropped switches (w/ ucast cache) */
block|}
name|vertex_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|binary_heap
block|{
name|uint32_t
name|size
decl_stmt|;
comment|/* size of the heap */
name|vertex_t
modifier|*
modifier|*
name|nodes
decl_stmt|;
comment|/* array with pointers to elements of the adj_list */
block|}
name|binary_heap_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|vltable
block|{
name|uint64_t
name|num_lids
decl_stmt|;
comment|/* size of the lids array */
name|uint16_t
modifier|*
name|lids
decl_stmt|;
comment|/* sorted array of all lids in the subnet */
name|uint8_t
modifier|*
name|vls
decl_stmt|;
comment|/* matrix form assignment lid X lid -> virtual lane */
block|}
name|vltable_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|cdg_link
block|{
name|struct
name|cdg_node
modifier|*
name|node
decl_stmt|;
name|uint32_t
name|num_pairs
decl_stmt|;
comment|/* number of src->dest pairs incremented in path adding step */
name|uint32_t
name|max_len
decl_stmt|;
comment|/* length of the srcdest array */
name|uint32_t
name|removed
decl_stmt|;
comment|/* number of pairs removed in path deletion step */
name|uint32_t
modifier|*
name|srcdest_pairs
decl_stmt|;
name|struct
name|cdg_link
modifier|*
name|next
decl_stmt|;
block|}
name|cdg_link_t
typedef|;
end_typedef

begin_comment
comment|/* struct for a node of a binary tree with additional parent pointer */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|cdg_node
block|{
name|uint64_t
name|channelID
decl_stmt|;
comment|/* unique key consist of src lid + port + dest lid + port */
name|cdg_link_t
modifier|*
name|linklist
decl_stmt|;
comment|/* edges to adjazent nodes */
name|uint8_t
name|status
decl_stmt|;
comment|/* node status in cycle search to avoid recursive function */
name|uint8_t
name|visited
decl_stmt|;
comment|/* needed to traverse the binary tree */
name|struct
name|cdg_node
modifier|*
name|pre
decl_stmt|;
comment|/* to save the path in cycle detection algorithm */
name|struct
name|cdg_node
modifier|*
name|left
decl_stmt|,
modifier|*
name|right
decl_stmt|,
modifier|*
name|parent
decl_stmt|;
block|}
name|cdg_node_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|dfsssp_context
block|{
name|osm_routing_engine_type_t
name|routing_type
decl_stmt|;
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
decl_stmt|;
name|vertex_t
modifier|*
name|adj_list
decl_stmt|;
name|uint32_t
name|adj_list_size
decl_stmt|;
name|vltable_t
modifier|*
name|srcdest2vl_table
decl_stmt|;
name|uint8_t
modifier|*
name|vl_split_count
decl_stmt|;
block|}
name|dfsssp_context_t
typedef|;
end_typedef

begin_comment
comment|/**************** set initial values for structs **********************  **********************************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_default_link
parameter_list|(
name|link_t
modifier|*
name|link
parameter_list|)
block|{
name|link
operator|->
name|guid
operator|=
literal|0
expr_stmt|;
name|link
operator|->
name|from
operator|=
literal|0
expr_stmt|;
name|link
operator|->
name|from_port
operator|=
literal|0
expr_stmt|;
name|link
operator|->
name|to
operator|=
literal|0
expr_stmt|;
name|link
operator|->
name|to_port
operator|=
literal|0
expr_stmt|;
name|link
operator|->
name|weight
operator|=
literal|0
expr_stmt|;
name|link
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|set_default_vertex
parameter_list|(
name|vertex_t
modifier|*
name|vertex
parameter_list|)
block|{
name|vertex
operator|->
name|guid
operator|=
literal|0
expr_stmt|;
name|vertex
operator|->
name|lid
operator|=
literal|0
expr_stmt|;
name|vertex
operator|->
name|num_hca
operator|=
literal|0
expr_stmt|;
name|vertex
operator|->
name|links
operator|=
name|NULL
expr_stmt|;
name|vertex
operator|->
name|hops
operator|=
literal|0
expr_stmt|;
name|vertex
operator|->
name|used_link
operator|=
name|NULL
expr_stmt|;
name|vertex
operator|->
name|distance
operator|=
literal|0
expr_stmt|;
name|vertex
operator|->
name|state
operator|=
name|UNDISCOVERED
expr_stmt|;
name|vertex
operator|->
name|heap_id
operator|=
literal|0
expr_stmt|;
name|vertex
operator|->
name|sw
operator|=
name|NULL
expr_stmt|;
name|vertex
operator|->
name|dropped
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|set_default_cdg_node
parameter_list|(
name|cdg_node_t
modifier|*
name|node
parameter_list|)
block|{
name|node
operator|->
name|channelID
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|linklist
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|status
operator|=
name|UNKNOWN
expr_stmt|;
name|node
operator|->
name|visited
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|pre
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|left
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|right
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_comment
comment|/************ helper functions for heap in dijkstra *******************  **********************************************************************/
end_comment

begin_comment
comment|/* returns true if element 1 is smaller than element 2 */
end_comment

begin_function
specifier|static
specifier|inline
name|uint32_t
name|heap_smaller
parameter_list|(
name|binary_heap_t
modifier|*
name|heap
parameter_list|,
name|uint32_t
name|i
parameter_list|,
name|uint32_t
name|j
parameter_list|)
block|{
return|return
operator|(
name|heap
operator|->
name|nodes
index|[
name|i
index|]
operator|->
name|distance
operator|<
name|heap
operator|->
name|nodes
index|[
name|j
index|]
operator|->
name|distance
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* swap two elements */
end_comment

begin_function
specifier|static
name|void
name|heap_exchange
parameter_list|(
name|binary_heap_t
modifier|*
name|heap
parameter_list|,
name|uint32_t
name|i
parameter_list|,
name|uint32_t
name|j
parameter_list|)
block|{
name|uint32_t
name|tmp_heap_id
init|=
literal|0
decl_stmt|;
name|vertex_t
modifier|*
name|tmp_node
init|=
name|NULL
decl_stmt|;
comment|/* 1. swap the heap_id */
name|tmp_heap_id
operator|=
name|heap
operator|->
name|nodes
index|[
name|i
index|]
operator|->
name|heap_id
expr_stmt|;
name|heap
operator|->
name|nodes
index|[
name|i
index|]
operator|->
name|heap_id
operator|=
name|heap
operator|->
name|nodes
index|[
name|j
index|]
operator|->
name|heap_id
expr_stmt|;
name|heap
operator|->
name|nodes
index|[
name|j
index|]
operator|->
name|heap_id
operator|=
name|tmp_heap_id
expr_stmt|;
comment|/* 2. swap pointers */
name|tmp_node
operator|=
name|heap
operator|->
name|nodes
index|[
name|i
index|]
expr_stmt|;
name|heap
operator|->
name|nodes
index|[
name|i
index|]
operator|=
name|heap
operator|->
name|nodes
index|[
name|j
index|]
expr_stmt|;
name|heap
operator|->
name|nodes
index|[
name|j
index|]
operator|=
name|tmp_node
expr_stmt|;
block|}
end_function

begin_comment
comment|/* changes position of element with parent until children are bigger */
end_comment

begin_function
specifier|static
name|uint32_t
name|heap_up
parameter_list|(
name|binary_heap_t
modifier|*
name|heap
parameter_list|,
name|uint32_t
name|i
parameter_list|)
block|{
name|uint32_t
name|curr
init|=
name|i
decl_stmt|,
name|father
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|curr
operator|>
literal|0
condition|)
block|{
name|father
operator|=
operator|(
name|curr
operator|-
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
while|while
condition|(
name|heap_smaller
argument_list|(
name|heap
argument_list|,
name|curr
argument_list|,
name|father
argument_list|)
condition|)
block|{
name|heap_exchange
argument_list|(
name|heap
argument_list|,
name|curr
argument_list|,
name|father
argument_list|)
expr_stmt|;
comment|/* try to go up when we arent already root */
name|curr
operator|=
name|father
expr_stmt|;
if|if
condition|(
name|curr
operator|>
literal|0
condition|)
name|father
operator|=
operator|(
name|curr
operator|-
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
block|}
return|return
name|curr
return|;
block|}
end_function

begin_comment
comment|/* changes position of element with children until parent is smaller */
end_comment

begin_function
specifier|static
name|uint32_t
name|heap_down
parameter_list|(
name|binary_heap_t
modifier|*
name|heap
parameter_list|,
name|uint32_t
name|i
parameter_list|)
block|{
name|uint32_t
name|curr
init|=
name|i
decl_stmt|;
name|uint32_t
name|son1
init|=
literal|0
decl_stmt|,
name|son2
init|=
literal|0
decl_stmt|,
name|smaller_son
init|=
literal|0
decl_stmt|;
name|uint32_t
name|exchanged
init|=
literal|0
decl_stmt|;
do|do
block|{
name|son1
operator|=
operator|(
operator|(
name|curr
operator|+
literal|1
operator|)
operator|<<
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
name|son2
operator|=
operator|(
name|curr
operator|+
literal|1
operator|)
operator|<<
literal|1
expr_stmt|;
name|exchanged
operator|=
literal|0
expr_stmt|;
comment|/* exchange with smaller son */
if|if
condition|(
name|son1
operator|<
name|heap
operator|->
name|size
operator|&&
name|son2
operator|<
name|heap
operator|->
name|size
condition|)
block|{
if|if
condition|(
name|heap_smaller
argument_list|(
name|heap
argument_list|,
name|son1
argument_list|,
name|son2
argument_list|)
condition|)
name|smaller_son
operator|=
name|son1
expr_stmt|;
else|else
name|smaller_son
operator|=
name|son2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|son1
operator|<
name|heap
operator|->
name|size
condition|)
block|{
comment|/* only one son */
name|smaller_son
operator|=
name|son1
expr_stmt|;
block|}
else|else
block|{
comment|/* finished */
break|break;
block|}
comment|/* only exchange when smaller */
if|if
condition|(
name|heap_smaller
argument_list|(
name|heap
argument_list|,
name|smaller_son
argument_list|,
name|curr
argument_list|)
condition|)
block|{
name|heap_exchange
argument_list|(
name|heap
argument_list|,
name|curr
argument_list|,
name|smaller_son
argument_list|)
expr_stmt|;
name|exchanged
operator|=
literal|1
expr_stmt|;
name|curr
operator|=
name|smaller_son
expr_stmt|;
block|}
block|}
do|while
condition|(
name|exchanged
condition|)
do|;
return|return
name|curr
return|;
block|}
end_function

begin_comment
comment|/* reheapify element */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|heap_heapify
parameter_list|(
name|binary_heap_t
modifier|*
name|heap
parameter_list|,
name|uint32_t
name|i
parameter_list|)
block|{
name|heap_down
argument_list|(
name|heap
argument_list|,
name|heap_up
argument_list|(
name|heap
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* creates heap for graph */
end_comment

begin_function
specifier|static
name|int
name|heap_create
parameter_list|(
name|vertex_t
modifier|*
name|adj_list
parameter_list|,
name|uint32_t
name|adj_list_size
parameter_list|,
name|binary_heap_t
modifier|*
modifier|*
name|binheap
parameter_list|)
block|{
name|binary_heap_t
modifier|*
name|heap
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|i
init|=
literal|0
decl_stmt|;
comment|/* allocate the memory for the heap object */
name|heap
operator|=
operator|(
name|binary_heap_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|binary_heap_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|heap
condition|)
return|return
literal|1
return|;
comment|/* the heap size is equivalent to the size of the adj_list */
name|heap
operator|->
name|size
operator|=
name|adj_list_size
expr_stmt|;
comment|/* allocate the pointer array, fill with the pointers to the elements of the adj_list and set the initial heap_id */
name|heap
operator|->
name|nodes
operator|=
operator|(
name|vertex_t
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|heap
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|vertex_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|heap
operator|->
name|nodes
condition|)
block|{
name|free
argument_list|(
name|heap
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|heap
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|heap
operator|->
name|nodes
index|[
name|i
index|]
operator|=
operator|&
name|adj_list
index|[
name|i
index|]
expr_stmt|;
name|heap
operator|->
name|nodes
index|[
name|i
index|]
operator|->
name|heap_id
operator|=
name|i
expr_stmt|;
block|}
comment|/* sort elements */
for|for
control|(
name|i
operator|=
name|heap
operator|->
name|size
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|heap_down
argument_list|(
name|heap
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|binheap
operator|=
name|heap
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* returns current minimum and removes it from heap */
end_comment

begin_function
specifier|static
name|vertex_t
modifier|*
name|heap_getmin
parameter_list|(
name|binary_heap_t
modifier|*
name|heap
parameter_list|)
block|{
name|vertex_t
modifier|*
name|min
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|heap
operator|->
name|size
operator|>
literal|0
condition|)
name|min
operator|=
name|heap
operator|->
name|nodes
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|min
operator|==
name|NULL
condition|)
return|return
name|min
return|;
if|if
condition|(
name|heap
operator|->
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|heap
operator|->
name|size
operator|>
literal|1
condition|)
block|{
name|heap_exchange
argument_list|(
name|heap
argument_list|,
literal|0
argument_list|,
name|heap
operator|->
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|heap
operator|->
name|size
operator|--
expr_stmt|;
name|heap_down
argument_list|(
name|heap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|heap
operator|->
name|size
operator|--
expr_stmt|;
block|}
block|}
return|return
name|min
return|;
block|}
end_function

begin_comment
comment|/* cleanup heap */
end_comment

begin_function
specifier|static
name|void
name|heap_free
parameter_list|(
name|binary_heap_t
modifier|*
name|heap
parameter_list|)
block|{
if|if
condition|(
name|heap
condition|)
block|{
if|if
condition|(
name|heap
operator|->
name|nodes
condition|)
block|{
name|free
argument_list|(
name|heap
operator|->
name|nodes
argument_list|)
expr_stmt|;
name|heap
operator|->
name|nodes
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|heap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_comment
comment|/************ helper functions to save src/dest X vl combination ******  **********************************************************************/
end_comment

begin_comment
comment|/* compare function of two lids for stdlib qsort */
end_comment

begin_function
specifier|static
name|int
name|cmp_lids
parameter_list|(
specifier|const
name|void
modifier|*
name|l1
parameter_list|,
specifier|const
name|void
modifier|*
name|l2
parameter_list|)
block|{
name|ib_net16_t
name|lid1
init|=
operator|*
operator|(
operator|(
name|ib_net16_t
operator|*
operator|)
name|l1
operator|)
decl_stmt|,
name|lid2
init|=
operator|*
operator|(
operator|(
name|ib_net16_t
operator|*
operator|)
name|l2
operator|)
decl_stmt|;
if|if
condition|(
name|lid1
operator|<
name|lid2
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|lid1
operator|>
name|lid2
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* use stdlib to sort the lid array */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|vltable_sort_lids
parameter_list|(
name|vltable_t
modifier|*
name|vltable
parameter_list|)
block|{
name|qsort
argument_list|(
name|vltable
operator|->
name|lids
argument_list|,
name|vltable
operator|->
name|num_lids
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_net16_t
argument_list|)
argument_list|,
name|cmp_lids
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* use stdlib to get index of key in lid array;    return -1 if lid isn't found in lids array */
end_comment

begin_function
specifier|static
specifier|inline
name|int64_t
name|vltable_get_lidindex
parameter_list|(
name|ib_net16_t
modifier|*
name|key
parameter_list|,
name|vltable_t
modifier|*
name|vltable
parameter_list|)
block|{
name|ib_net16_t
modifier|*
name|found_lid
init|=
name|NULL
decl_stmt|;
name|found_lid
operator|=
operator|(
name|ib_net16_t
operator|*
operator|)
name|bsearch
argument_list|(
name|key
argument_list|,
name|vltable
operator|->
name|lids
argument_list|,
name|vltable
operator|->
name|num_lids
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_net16_t
argument_list|)
argument_list|,
name|cmp_lids
argument_list|)
expr_stmt|;
if|if
condition|(
name|found_lid
condition|)
return|return
name|found_lid
operator|-
name|vltable
operator|->
name|lids
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* get virtual lane from src lid X dest lid combination;    return -1 for invalid lids */
end_comment

begin_function
specifier|static
name|int32_t
name|vltable_get_vl
parameter_list|(
name|vltable_t
modifier|*
name|vltable
parameter_list|,
name|ib_net16_t
name|slid
parameter_list|,
name|ib_net16_t
name|dlid
parameter_list|)
block|{
name|int64_t
name|ind1
init|=
name|vltable_get_lidindex
argument_list|(
operator|&
name|slid
argument_list|,
name|vltable
argument_list|)
decl_stmt|;
name|int64_t
name|ind2
init|=
name|vltable_get_lidindex
argument_list|(
operator|&
name|dlid
argument_list|,
name|vltable
argument_list|)
decl_stmt|;
if|if
condition|(
name|ind1
operator|>
operator|-
literal|1
operator|&&
name|ind2
operator|>
operator|-
literal|1
condition|)
return|return
call|(
name|int32_t
call|)
argument_list|(
name|vltable
operator|->
name|vls
index|[
name|ind1
operator|+
name|ind2
operator|*
name|vltable
operator|->
name|num_lids
index|]
argument_list|)
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* set a virtual lane in the matrix */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|vltable_insert
parameter_list|(
name|vltable_t
modifier|*
name|vltable
parameter_list|,
name|ib_net16_t
name|slid
parameter_list|,
name|ib_net16_t
name|dlid
parameter_list|,
name|uint8_t
name|vl
parameter_list|)
block|{
name|int64_t
name|ind1
init|=
name|vltable_get_lidindex
argument_list|(
operator|&
name|slid
argument_list|,
name|vltable
argument_list|)
decl_stmt|;
name|int64_t
name|ind2
init|=
name|vltable_get_lidindex
argument_list|(
operator|&
name|dlid
argument_list|,
name|vltable
argument_list|)
decl_stmt|;
if|if
condition|(
name|ind1
operator|>
operator|-
literal|1
operator|&&
name|ind2
operator|>
operator|-
literal|1
condition|)
name|vltable
operator|->
name|vls
index|[
name|ind1
operator|+
name|ind2
operator|*
name|vltable
operator|->
name|num_lids
index|]
operator|=
name|vl
expr_stmt|;
block|}
end_function

begin_comment
comment|/* change a number of lanes from lane xy to lane yz */
end_comment

begin_function
specifier|static
name|void
name|vltable_change_vl
parameter_list|(
name|vltable_t
modifier|*
name|vltable
parameter_list|,
name|uint8_t
name|from
parameter_list|,
name|uint8_t
name|to
parameter_list|,
name|uint64_t
name|count
parameter_list|)
block|{
name|uint64_t
name|set
init|=
literal|0
decl_stmt|,
name|stop
init|=
literal|0
decl_stmt|;
name|uint64_t
name|ind1
init|=
literal|0
decl_stmt|,
name|ind2
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ind1
operator|=
literal|0
init|;
name|ind1
operator|<
name|vltable
operator|->
name|num_lids
condition|;
name|ind1
operator|++
control|)
block|{
for|for
control|(
name|ind2
operator|=
literal|0
init|;
name|ind2
operator|<
name|vltable
operator|->
name|num_lids
condition|;
name|ind2
operator|++
control|)
block|{
if|if
condition|(
name|set
operator|==
name|count
condition|)
block|{
name|stop
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ind1
operator|!=
name|ind2
condition|)
block|{
if|if
condition|(
name|vltable
operator|->
name|vls
index|[
name|ind1
operator|+
name|ind2
operator|*
name|vltable
operator|->
name|num_lids
index|]
operator|==
name|from
condition|)
block|{
name|vltable
operator|->
name|vls
index|[
name|ind1
operator|+
name|ind2
operator|*
name|vltable
operator|->
name|num_lids
index|]
operator|=
name|to
expr_stmt|;
name|set
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|stop
condition|)
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vltable_print
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|,
name|vltable_t
modifier|*
name|vltable
parameter_list|)
block|{
name|uint64_t
name|ind1
init|=
literal|0
decl_stmt|,
name|ind2
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ind1
operator|=
literal|0
init|;
name|ind1
operator|<
name|vltable
operator|->
name|num_lids
condition|;
name|ind1
operator|++
control|)
block|{
for|for
control|(
name|ind2
operator|=
literal|0
init|;
name|ind2
operator|<
name|vltable
operator|->
name|num_lids
condition|;
name|ind2
operator|++
control|)
block|{
if|if
condition|(
name|ind1
operator|!=
name|ind2
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"   route from src_lid=%"
name|PRIu16
literal|" to dest_lid=%"
name|PRIu16
literal|" on vl=%"
name|PRIu8
literal|"\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|vltable
operator|->
name|lids
index|[
name|ind1
index|]
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|vltable
operator|->
name|lids
index|[
name|ind2
index|]
argument_list|)
argument_list|,
name|vltable
operator|->
name|vls
index|[
name|ind1
operator|+
name|ind2
operator|*
name|vltable
operator|->
name|num_lids
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vltable_dealloc
parameter_list|(
name|vltable_t
modifier|*
modifier|*
name|vltable
parameter_list|)
block|{
if|if
condition|(
operator|*
name|vltable
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|vltable
operator|)
operator|->
name|lids
condition|)
name|free
argument_list|(
operator|(
operator|*
name|vltable
operator|)
operator|->
name|lids
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|vltable
operator|)
operator|->
name|vls
condition|)
name|free
argument_list|(
operator|(
operator|*
name|vltable
operator|)
operator|->
name|vls
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|vltable
argument_list|)
expr_stmt|;
operator|*
name|vltable
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|vltable_alloc
parameter_list|(
name|vltable_t
modifier|*
modifier|*
name|vltable
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
comment|/* allocate VL table and indexing array */
operator|*
name|vltable
operator|=
operator|(
name|vltable_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vltable_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|vltable
operator|)
condition|)
goto|goto
name|ERROR
goto|;
operator|(
operator|*
name|vltable
operator|)
operator|->
name|num_lids
operator|=
name|size
expr_stmt|;
operator|(
operator|*
name|vltable
operator|)
operator|->
name|lids
operator|=
operator|(
name|ib_net16_t
operator|*
operator|)
name|malloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|ib_net16_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|vltable
operator|)
operator|->
name|lids
operator|)
condition|)
goto|goto
name|ERROR
goto|;
operator|(
operator|*
name|vltable
operator|)
operator|->
name|vls
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|malloc
argument_list|(
name|size
operator|*
name|size
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|vltable
operator|)
operator|->
name|vls
operator|)
condition|)
goto|goto
name|ERROR
goto|;
name|memset
argument_list|(
operator|(
operator|*
name|vltable
operator|)
operator|->
name|vls
argument_list|,
name|OSM_DEFAULT_SL
argument_list|,
name|size
operator|*
name|size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|ERROR
label|:
name|vltable_dealloc
argument_list|(
name|vltable
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_comment
comment|/************ helper functions to save/manage the channel dep. graph **  **********************************************************************/
end_comment

begin_comment
comment|/* update the srcdest array;    realloc array (double the size) if size is not large enough */
end_comment

begin_function
specifier|static
name|void
name|set_next_srcdest_pair
parameter_list|(
name|cdg_link_t
modifier|*
name|link
parameter_list|,
name|uint32_t
name|srcdest
parameter_list|)
block|{
name|uint32_t
name|new_size
init|=
literal|0
decl_stmt|,
name|start_size
init|=
literal|2
decl_stmt|;
name|uint32_t
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|,
modifier|*
name|tmp2
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|link
operator|->
name|num_pairs
operator|==
literal|0
condition|)
block|{
name|link
operator|->
name|srcdest_pairs
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|malloc
argument_list|(
name|start_size
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|->
name|srcdest_pairs
index|[
name|link
operator|->
name|num_pairs
index|]
operator|=
name|srcdest
expr_stmt|;
name|link
operator|->
name|max_len
operator|=
name|start_size
expr_stmt|;
name|link
operator|->
name|removed
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|link
operator|->
name|num_pairs
operator|==
name|link
operator|->
name|max_len
condition|)
block|{
name|new_size
operator|=
name|link
operator|->
name|max_len
operator|<<
literal|1
expr_stmt|;
name|tmp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|malloc
argument_list|(
name|new_size
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|link
operator|->
name|srcdest_pairs
argument_list|,
name|link
operator|->
name|max_len
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|link
operator|->
name|srcdest_pairs
expr_stmt|;
name|link
operator|->
name|srcdest_pairs
operator|=
name|tmp
expr_stmt|;
name|link
operator|->
name|srcdest_pairs
index|[
name|link
operator|->
name|num_pairs
index|]
operator|=
name|srcdest
expr_stmt|;
name|free
argument_list|(
name|tmp2
argument_list|)
expr_stmt|;
name|link
operator|->
name|max_len
operator|=
name|new_size
expr_stmt|;
block|}
else|else
block|{
name|link
operator|->
name|srcdest_pairs
index|[
name|link
operator|->
name|num_pairs
index|]
operator|=
name|srcdest
expr_stmt|;
block|}
name|link
operator|->
name|num_pairs
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|get_next_srcdest_pair
parameter_list|(
name|cdg_link_t
modifier|*
name|link
parameter_list|,
name|uint32_t
name|index
parameter_list|)
block|{
return|return
name|link
operator|->
name|srcdest_pairs
index|[
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/* traverse binary tree to find a node */
end_comment

begin_function
specifier|static
name|cdg_node_t
modifier|*
name|cdg_search
parameter_list|(
name|cdg_node_t
modifier|*
name|root
parameter_list|,
name|uint64_t
name|channelID
parameter_list|)
block|{
while|while
condition|(
name|root
condition|)
block|{
if|if
condition|(
name|channelID
operator|<
name|root
operator|->
name|channelID
condition|)
name|root
operator|=
name|root
operator|->
name|left
expr_stmt|;
elseif|else
if|if
condition|(
name|channelID
operator|>
name|root
operator|->
name|channelID
condition|)
name|root
operator|=
name|root
operator|->
name|right
expr_stmt|;
elseif|else
if|if
condition|(
name|channelID
operator|==
name|root
operator|->
name|channelID
condition|)
return|return
name|root
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* insert new node into the binary tree */
end_comment

begin_function
specifier|static
name|void
name|cdg_insert
parameter_list|(
name|cdg_node_t
modifier|*
modifier|*
name|root
parameter_list|,
name|cdg_node_t
modifier|*
name|new_node
parameter_list|)
block|{
name|cdg_node_t
modifier|*
name|current
init|=
operator|*
name|root
decl_stmt|;
if|if
condition|(
operator|!
name|current
condition|)
block|{
name|current
operator|=
name|new_node
expr_stmt|;
operator|*
name|root
operator|=
name|current
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|current
condition|)
block|{
if|if
condition|(
name|new_node
operator|->
name|channelID
operator|<
name|current
operator|->
name|channelID
condition|)
block|{
if|if
condition|(
name|current
operator|->
name|left
condition|)
block|{
name|current
operator|=
name|current
operator|->
name|left
expr_stmt|;
block|}
else|else
block|{
name|current
operator|->
name|left
operator|=
name|new_node
expr_stmt|;
name|new_node
operator|->
name|parent
operator|=
name|current
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|new_node
operator|->
name|channelID
operator|>
name|current
operator|->
name|channelID
condition|)
block|{
if|if
condition|(
name|current
operator|->
name|right
condition|)
block|{
name|current
operator|=
name|current
operator|->
name|right
expr_stmt|;
block|}
else|else
block|{
name|current
operator|->
name|right
operator|=
name|new_node
expr_stmt|;
name|new_node
operator|->
name|parent
operator|=
name|current
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|new_node
operator|->
name|channelID
operator|==
name|current
operator|->
name|channelID
condition|)
block|{
comment|/* not really possible, maybe programming error */
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cdg_node_dealloc
parameter_list|(
name|cdg_node_t
modifier|*
name|node
parameter_list|)
block|{
name|cdg_link_t
modifier|*
name|link
init|=
name|node
operator|->
name|linklist
decl_stmt|,
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
comment|/* dealloc linklist */
while|while
condition|(
name|link
condition|)
block|{
name|tmp
operator|=
name|link
expr_stmt|;
name|link
operator|=
name|link
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|tmp
operator|->
name|num_pairs
condition|)
name|free
argument_list|(
name|tmp
operator|->
name|srcdest_pairs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* dealloc node */
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cdg_dealloc
parameter_list|(
name|cdg_node_t
modifier|*
modifier|*
name|root
parameter_list|)
block|{
name|cdg_node_t
modifier|*
name|current
init|=
operator|*
name|root
decl_stmt|;
while|while
condition|(
name|current
condition|)
block|{
if|if
condition|(
name|current
operator|->
name|left
condition|)
block|{
name|current
operator|=
name|current
operator|->
name|left
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current
operator|->
name|right
condition|)
block|{
name|current
operator|=
name|current
operator|->
name|right
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|current
operator|->
name|parent
operator|==
name|NULL
condition|)
block|{
name|cdg_node_dealloc
argument_list|(
name|current
argument_list|)
expr_stmt|;
operator|*
name|root
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|current
operator|->
name|parent
operator|->
name|left
operator|==
name|current
condition|)
block|{
name|current
operator|=
name|current
operator|->
name|parent
expr_stmt|;
name|cdg_node_dealloc
argument_list|(
name|current
operator|->
name|left
argument_list|)
expr_stmt|;
name|current
operator|->
name|left
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current
operator|->
name|parent
operator|->
name|right
operator|==
name|current
condition|)
block|{
name|current
operator|=
name|current
operator|->
name|parent
expr_stmt|;
name|cdg_node_dealloc
argument_list|(
name|current
operator|->
name|right
argument_list|)
expr_stmt|;
name|current
operator|->
name|right
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* search for a edge in the cdg which should be removed to break a cycle */
end_comment

begin_function
specifier|static
name|cdg_link_t
modifier|*
name|get_weakest_link_in_cycle
parameter_list|(
name|cdg_node_t
modifier|*
name|cycle
parameter_list|)
block|{
name|cdg_node_t
modifier|*
name|current
init|=
name|cycle
decl_stmt|,
modifier|*
name|node_with_weakest_link
init|=
name|NULL
decl_stmt|;
name|cdg_link_t
modifier|*
name|link
init|=
name|NULL
decl_stmt|,
modifier|*
name|weakest_link
init|=
name|NULL
decl_stmt|;
name|link
operator|=
name|current
operator|->
name|linklist
expr_stmt|;
while|while
condition|(
name|link
condition|)
block|{
if|if
condition|(
name|link
operator|->
name|node
operator|->
name|status
operator|==
name|GRAY
condition|)
block|{
name|weakest_link
operator|=
name|link
expr_stmt|;
name|node_with_weakest_link
operator|=
name|current
expr_stmt|;
name|current
operator|=
name|link
operator|->
name|node
expr_stmt|;
break|break;
block|}
name|link
operator|=
name|link
operator|->
name|next
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|current
operator|->
name|status
operator|=
name|UNKNOWN
expr_stmt|;
name|link
operator|=
name|current
operator|->
name|linklist
expr_stmt|;
while|while
condition|(
name|link
condition|)
block|{
if|if
condition|(
name|link
operator|->
name|node
operator|->
name|status
operator|==
name|GRAY
condition|)
block|{
if|if
condition|(
operator|(
name|link
operator|->
name|num_pairs
operator|-
name|link
operator|->
name|removed
operator|)
operator|<
operator|(
name|weakest_link
operator|->
name|num_pairs
operator|-
name|weakest_link
operator|->
name|removed
operator|)
condition|)
block|{
name|weakest_link
operator|=
name|link
expr_stmt|;
name|node_with_weakest_link
operator|=
name|current
expr_stmt|;
block|}
name|current
operator|=
name|link
operator|->
name|node
expr_stmt|;
break|break;
block|}
name|link
operator|=
name|link
operator|->
name|next
expr_stmt|;
block|}
comment|/* if complete cycle is traversed */
if|if
condition|(
name|current
operator|==
name|cycle
condition|)
block|{
name|current
operator|->
name|status
operator|=
name|UNKNOWN
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|node_with_weakest_link
operator|->
name|linklist
operator|==
name|weakest_link
condition|)
block|{
name|node_with_weakest_link
operator|->
name|linklist
operator|=
name|weakest_link
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|link
operator|=
name|node_with_weakest_link
operator|->
name|linklist
expr_stmt|;
while|while
condition|(
name|link
condition|)
block|{
if|if
condition|(
name|link
operator|->
name|next
operator|==
name|weakest_link
condition|)
block|{
name|link
operator|->
name|next
operator|=
name|weakest_link
operator|->
name|next
expr_stmt|;
break|break;
block|}
name|link
operator|=
name|link
operator|->
name|next
expr_stmt|;
block|}
block|}
return|return
name|weakest_link
return|;
block|}
end_function

begin_comment
comment|/* search for nodes in the cdg not yet reached in the cycle search process;    (some nodes are unreachable, e.g. a node is a source or the cdg has not connected parts) */
end_comment

begin_function
specifier|static
name|cdg_node_t
modifier|*
name|get_next_cdg_node
parameter_list|(
name|cdg_node_t
modifier|*
name|root
parameter_list|)
block|{
name|cdg_node_t
modifier|*
name|current
init|=
name|root
decl_stmt|,
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|current
condition|)
block|{
name|current
operator|->
name|visited
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|status
operator|==
name|UNKNOWN
condition|)
block|{
name|res
operator|=
name|current
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|current
operator|->
name|left
operator|&&
operator|!
name|current
operator|->
name|left
operator|->
name|visited
condition|)
block|{
name|current
operator|=
name|current
operator|->
name|left
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current
operator|->
name|right
operator|&&
operator|!
name|current
operator|->
name|right
operator|->
name|visited
condition|)
block|{
name|current
operator|=
name|current
operator|->
name|right
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|current
operator|->
name|left
condition|)
name|current
operator|->
name|left
operator|->
name|visited
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|right
condition|)
name|current
operator|->
name|right
operator|->
name|visited
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|parent
operator|==
name|NULL
condition|)
break|break;
else|else
name|current
operator|=
name|current
operator|->
name|parent
expr_stmt|;
block|}
block|}
comment|/* Clean up */
while|while
condition|(
name|current
condition|)
block|{
name|current
operator|->
name|visited
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|left
condition|)
name|current
operator|->
name|left
operator|->
name|visited
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|right
condition|)
name|current
operator|->
name|right
operator|->
name|visited
operator|=
literal|0
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|parent
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* make a DFS on the cdg to check for a cycle */
end_comment

begin_function
specifier|static
name|cdg_node_t
modifier|*
name|search_cycle_in_channel_dep_graph
parameter_list|(
name|cdg_node_t
modifier|*
name|cdg
parameter_list|,
name|cdg_node_t
modifier|*
name|start_node
parameter_list|)
block|{
name|cdg_node_t
modifier|*
name|cycle
init|=
name|NULL
decl_stmt|;
name|cdg_node_t
modifier|*
name|current
init|=
name|start_node
decl_stmt|,
modifier|*
name|next_node
init|=
name|NULL
decl_stmt|,
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
name|cdg_link_t
modifier|*
name|link
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|current
condition|)
block|{
name|current
operator|->
name|status
operator|=
name|GRAY
expr_stmt|;
name|link
operator|=
name|current
operator|->
name|linklist
expr_stmt|;
name|next_node
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|link
condition|)
block|{
if|if
condition|(
name|link
operator|->
name|node
operator|->
name|status
operator|==
name|UNKNOWN
condition|)
block|{
name|next_node
operator|=
name|link
operator|->
name|node
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|link
operator|->
name|node
operator|->
name|status
operator|==
name|GRAY
condition|)
block|{
name|cycle
operator|=
name|link
operator|->
name|node
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|link
operator|=
name|link
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|next_node
condition|)
block|{
name|next_node
operator|->
name|pre
operator|=
name|current
expr_stmt|;
name|current
operator|=
name|next_node
expr_stmt|;
block|}
else|else
block|{
comment|/* found a sink in the graph, go to last node */
name|current
operator|->
name|status
operator|=
name|BLACK
expr_stmt|;
comment|/* srcdest_pairs of this node aren't relevant, free the allocated memory */
name|link
operator|=
name|current
operator|->
name|linklist
expr_stmt|;
while|while
condition|(
name|link
condition|)
block|{
if|if
condition|(
name|link
operator|->
name|num_pairs
condition|)
name|free
argument_list|(
name|link
operator|->
name|srcdest_pairs
argument_list|)
expr_stmt|;
name|link
operator|->
name|srcdest_pairs
operator|=
name|NULL
expr_stmt|;
name|link
operator|->
name|num_pairs
operator|=
literal|0
expr_stmt|;
name|link
operator|->
name|removed
operator|=
literal|0
expr_stmt|;
name|link
operator|=
name|link
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|current
operator|->
name|pre
condition|)
block|{
name|tmp
operator|=
name|current
expr_stmt|;
name|current
operator|=
name|current
operator|->
name|pre
expr_stmt|;
name|tmp
operator|->
name|pre
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* search for other subgraphs in cdg */
name|current
operator|=
name|get_next_cdg_node
argument_list|(
name|cdg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current
condition|)
break|break;
comment|/* all relevant nodes traversed, no more cycles found */
block|}
block|}
block|}
name|Exit
label|:
return|return
name|cycle
return|;
block|}
end_function

begin_comment
comment|/* calculate the path from source to destination port;    new channels are added directly to the cdg */
end_comment

begin_function
specifier|static
name|int
name|update_channel_dep_graph
parameter_list|(
name|cdg_node_t
modifier|*
modifier|*
name|cdg_root
parameter_list|,
name|osm_port_t
modifier|*
name|src_port
parameter_list|,
name|uint16_t
name|slid
parameter_list|,
name|osm_port_t
modifier|*
name|dest_port
parameter_list|,
name|uint16_t
name|dlid
parameter_list|)
block|{
name|osm_node_t
modifier|*
name|local_node
init|=
name|NULL
decl_stmt|,
modifier|*
name|remote_node
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|local_lid
init|=
literal|0
decl_stmt|,
name|remote_lid
init|=
literal|0
decl_stmt|;
name|uint32_t
name|srcdest
init|=
literal|0
decl_stmt|;
name|uint8_t
name|local_port
init|=
literal|0
decl_stmt|,
name|remote_port
init|=
literal|0
decl_stmt|;
name|uint64_t
name|channelID
init|=
literal|0
decl_stmt|;
name|cdg_node_t
modifier|*
name|channel_head
init|=
name|NULL
decl_stmt|,
modifier|*
name|channel
init|=
name|NULL
decl_stmt|,
modifier|*
name|last_channel
init|=
name|NULL
decl_stmt|;
name|cdg_link_t
modifier|*
name|linklist
init|=
name|NULL
decl_stmt|;
comment|/* set the identifier for the src/dest pair to save this on each edge of the cdg */
name|srcdest
operator|=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|slid
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|uint32_t
operator|)
name|dlid
operator|)
expr_stmt|;
name|channel_head
operator|=
operator|(
name|cdg_node_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cdg_node_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|channel_head
condition|)
goto|goto
name|ERROR
goto|;
name|set_default_cdg_node
argument_list|(
name|channel_head
argument_list|)
expr_stmt|;
name|last_channel
operator|=
name|channel_head
expr_stmt|;
comment|/* if src is a Hca, then the channel from Hca to switch would be a source in the graph 	   sources can't be part of a cycle -> skip this channel 	 */
name|remote_node
operator|=
name|osm_node_get_remote_node
argument_list|(
name|src_port
operator|->
name|p_node
argument_list|,
name|src_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|,
operator|&
name|remote_port
argument_list|)
expr_stmt|;
while|while
condition|(
name|remote_node
operator|&&
name|remote_node
operator|->
name|sw
condition|)
block|{
name|local_node
operator|=
name|remote_node
expr_stmt|;
name|local_port
operator|=
name|local_node
operator|->
name|sw
operator|->
name|new_lft
index|[
name|dlid
index|]
expr_stmt|;
comment|/* sanity check: local_port must be set or routing is broken */
if|if
condition|(
name|local_port
operator|==
name|OSM_NO_PATH
condition|)
goto|goto
name|ERROR
goto|;
name|local_lid
operator|=
name|cl_ntoh16
argument_list|(
name|osm_node_get_base_lid
argument_list|(
name|local_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* each port belonging to a switch has lmc==0 -> get_base_lid is fine 		   (local/remote port in this function are always part of a switch) 		 */
name|remote_node
operator|=
name|osm_node_get_remote_node
argument_list|(
name|local_node
argument_list|,
name|local_port
argument_list|,
operator|&
name|remote_port
argument_list|)
expr_stmt|;
comment|/* if remote_node is a Hca, then the last channel from switch to Hca would be a sink in the cdg -> skip */
if|if
condition|(
operator|!
name|remote_node
operator|||
operator|!
name|remote_node
operator|->
name|sw
condition|)
break|break;
name|remote_lid
operator|=
name|cl_ntoh16
argument_list|(
name|osm_node_get_base_lid
argument_list|(
name|remote_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|channelID
operator|=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|local_lid
operator|)
operator|<<
literal|48
operator|)
operator|+
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|local_port
operator|)
operator|<<
literal|32
operator|)
operator|+
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|remote_lid
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|uint64_t
operator|)
name|remote_port
operator|)
expr_stmt|;
name|channel
operator|=
name|cdg_search
argument_list|(
operator|*
name|cdg_root
argument_list|,
name|channelID
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
condition|)
block|{
comment|/* check whether last channel has connection to this channel, i.e. subpath already exists in cdg */
name|linklist
operator|=
name|last_channel
operator|->
name|linklist
expr_stmt|;
while|while
condition|(
name|linklist
operator|&&
name|linklist
operator|->
name|node
operator|!=
name|channel
operator|&&
name|linklist
operator|->
name|next
condition|)
name|linklist
operator|=
name|linklist
operator|->
name|next
expr_stmt|;
comment|/* if there is no connection, add one */
if|if
condition|(
name|linklist
condition|)
block|{
if|if
condition|(
name|linklist
operator|->
name|node
operator|==
name|channel
condition|)
block|{
name|set_next_srcdest_pair
argument_list|(
name|linklist
argument_list|,
name|srcdest
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|linklist
operator|->
name|next
operator|=
operator|(
name|cdg_link_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cdg_link_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linklist
operator|->
name|next
condition|)
goto|goto
name|ERROR
goto|;
name|linklist
operator|=
name|linklist
operator|->
name|next
expr_stmt|;
name|linklist
operator|->
name|node
operator|=
name|channel
expr_stmt|;
name|linklist
operator|->
name|num_pairs
operator|=
literal|0
expr_stmt|;
name|linklist
operator|->
name|srcdest_pairs
operator|=
name|NULL
expr_stmt|;
name|set_next_srcdest_pair
argument_list|(
name|linklist
argument_list|,
name|srcdest
argument_list|)
expr_stmt|;
name|linklist
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* either this is the first channel of the path, or the last channel was a new channel, or last channel was a sink */
name|last_channel
operator|->
name|linklist
operator|=
operator|(
name|cdg_link_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cdg_link_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|last_channel
operator|->
name|linklist
condition|)
goto|goto
name|ERROR
goto|;
name|last_channel
operator|->
name|linklist
operator|->
name|node
operator|=
name|channel
expr_stmt|;
name|last_channel
operator|->
name|linklist
operator|->
name|num_pairs
operator|=
literal|0
expr_stmt|;
name|last_channel
operator|->
name|linklist
operator|->
name|srcdest_pairs
operator|=
name|NULL
expr_stmt|;
name|set_next_srcdest_pair
argument_list|(
name|last_channel
operator|->
name|linklist
argument_list|,
name|srcdest
argument_list|)
expr_stmt|;
name|last_channel
operator|->
name|linklist
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* create new channel */
name|channel
operator|=
operator|(
name|cdg_node_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cdg_node_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|channel
condition|)
goto|goto
name|ERROR
goto|;
name|set_default_cdg_node
argument_list|(
name|channel
argument_list|)
expr_stmt|;
name|channel
operator|->
name|channelID
operator|=
name|channelID
expr_stmt|;
name|cdg_insert
argument_list|(
name|cdg_root
argument_list|,
name|channel
argument_list|)
expr_stmt|;
comment|/* go to end of link list of last channel */
name|linklist
operator|=
name|last_channel
operator|->
name|linklist
expr_stmt|;
while|while
condition|(
name|linklist
operator|&&
name|linklist
operator|->
name|next
condition|)
name|linklist
operator|=
name|linklist
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|linklist
condition|)
block|{
comment|/* update last link of an existing channel */
name|linklist
operator|->
name|next
operator|=
operator|(
name|cdg_link_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cdg_link_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|linklist
operator|->
name|next
condition|)
goto|goto
name|ERROR
goto|;
name|linklist
operator|=
name|linklist
operator|->
name|next
expr_stmt|;
name|linklist
operator|->
name|node
operator|=
name|channel
expr_stmt|;
name|linklist
operator|->
name|num_pairs
operator|=
literal|0
expr_stmt|;
name|linklist
operator|->
name|srcdest_pairs
operator|=
name|NULL
expr_stmt|;
name|set_next_srcdest_pair
argument_list|(
name|linklist
argument_list|,
name|srcdest
argument_list|)
expr_stmt|;
name|linklist
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* either this is the first channel of the path, or the last channel was a new channel, or last channel was a sink */
name|last_channel
operator|->
name|linklist
operator|=
operator|(
name|cdg_link_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cdg_link_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|last_channel
operator|->
name|linklist
condition|)
goto|goto
name|ERROR
goto|;
name|last_channel
operator|->
name|linklist
operator|->
name|node
operator|=
name|channel
expr_stmt|;
name|last_channel
operator|->
name|linklist
operator|->
name|num_pairs
operator|=
literal|0
expr_stmt|;
name|last_channel
operator|->
name|linklist
operator|->
name|srcdest_pairs
operator|=
name|NULL
expr_stmt|;
name|set_next_srcdest_pair
argument_list|(
name|last_channel
operator|->
name|linklist
argument_list|,
name|srcdest
argument_list|)
expr_stmt|;
name|last_channel
operator|->
name|linklist
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|last_channel
operator|=
name|channel
expr_stmt|;
block|}
if|if
condition|(
name|channel_head
operator|->
name|linklist
condition|)
block|{
if|if
condition|(
name|channel_head
operator|->
name|linklist
operator|->
name|srcdest_pairs
condition|)
name|free
argument_list|(
name|channel_head
operator|->
name|linklist
operator|->
name|srcdest_pairs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|channel_head
operator|->
name|linklist
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|channel_head
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|ERROR
label|:
comment|/* cleanup data and exit */
if|if
condition|(
name|channel_head
condition|)
block|{
if|if
condition|(
name|channel_head
operator|->
name|linklist
condition|)
name|free
argument_list|(
name|channel_head
operator|->
name|linklist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|channel_head
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* calculate the path from source to destination port;    the links in the cdg representing this path are decremented to simulate the removal */
end_comment

begin_function
specifier|static
name|int
name|remove_path_from_cdg
parameter_list|(
name|cdg_node_t
modifier|*
modifier|*
name|cdg_root
parameter_list|,
name|osm_port_t
modifier|*
name|src_port
parameter_list|,
name|uint16_t
name|slid
parameter_list|,
name|osm_port_t
modifier|*
name|dest_port
parameter_list|,
name|uint16_t
name|dlid
parameter_list|)
block|{
name|osm_node_t
modifier|*
name|local_node
init|=
name|NULL
decl_stmt|,
modifier|*
name|remote_node
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|local_lid
init|=
literal|0
decl_stmt|,
name|remote_lid
init|=
literal|0
decl_stmt|;
name|uint8_t
name|local_port
init|=
literal|0
decl_stmt|,
name|remote_port
init|=
literal|0
decl_stmt|;
name|uint64_t
name|channelID
init|=
literal|0
decl_stmt|;
name|cdg_node_t
modifier|*
name|channel_head
init|=
name|NULL
decl_stmt|,
modifier|*
name|channel
init|=
name|NULL
decl_stmt|,
modifier|*
name|last_channel
init|=
name|NULL
decl_stmt|;
name|cdg_link_t
modifier|*
name|linklist
init|=
name|NULL
decl_stmt|;
name|channel_head
operator|=
operator|(
name|cdg_node_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cdg_node_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|channel_head
condition|)
goto|goto
name|ERROR
goto|;
name|set_default_cdg_node
argument_list|(
name|channel_head
argument_list|)
expr_stmt|;
name|last_channel
operator|=
name|channel_head
expr_stmt|;
comment|/* if src is a Hca, then the channel from Hca to switch would be a source in the graph 	   sources can't be part of a cycle -> skip this channel 	 */
name|remote_node
operator|=
name|osm_node_get_remote_node
argument_list|(
name|src_port
operator|->
name|p_node
argument_list|,
name|src_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|,
operator|&
name|remote_port
argument_list|)
expr_stmt|;
while|while
condition|(
name|remote_node
operator|&&
name|remote_node
operator|->
name|sw
condition|)
block|{
name|local_node
operator|=
name|remote_node
expr_stmt|;
name|local_port
operator|=
name|local_node
operator|->
name|sw
operator|->
name|new_lft
index|[
name|dlid
index|]
expr_stmt|;
comment|/* sanity check: local_port must be set or routing is broken */
if|if
condition|(
name|local_port
operator|==
name|OSM_NO_PATH
condition|)
goto|goto
name|ERROR
goto|;
name|local_lid
operator|=
name|cl_ntoh16
argument_list|(
name|osm_node_get_base_lid
argument_list|(
name|local_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|remote_node
operator|=
name|osm_node_get_remote_node
argument_list|(
name|local_node
argument_list|,
name|local_port
argument_list|,
operator|&
name|remote_port
argument_list|)
expr_stmt|;
comment|/* if remote_node is a Hca, then the last channel from switch to Hca would be a sink in the cdg -> skip */
if|if
condition|(
operator|!
name|remote_node
operator|||
operator|!
name|remote_node
operator|->
name|sw
condition|)
break|break;
name|remote_lid
operator|=
name|cl_ntoh16
argument_list|(
name|osm_node_get_base_lid
argument_list|(
name|remote_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|channelID
operator|=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|local_lid
operator|)
operator|<<
literal|48
operator|)
operator|+
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|local_port
operator|)
operator|<<
literal|32
operator|)
operator|+
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|remote_lid
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|uint64_t
operator|)
name|remote_port
operator|)
expr_stmt|;
name|channel
operator|=
name|cdg_search
argument_list|(
operator|*
name|cdg_root
argument_list|,
name|channelID
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
condition|)
block|{
comment|/* check whether last channel has connection to this channel, i.e. subpath already exists in cdg */
name|linklist
operator|=
name|last_channel
operator|->
name|linklist
expr_stmt|;
while|while
condition|(
name|linklist
operator|&&
name|linklist
operator|->
name|node
operator|!=
name|channel
operator|&&
name|linklist
operator|->
name|next
condition|)
name|linklist
operator|=
name|linklist
operator|->
name|next
expr_stmt|;
comment|/* remove the srcdest from the link */
if|if
condition|(
name|linklist
condition|)
block|{
if|if
condition|(
name|linklist
operator|->
name|node
operator|==
name|channel
condition|)
block|{
name|linklist
operator|->
name|removed
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* may happen if the link is missing (thru cycle detect algorithm) */
block|}
block|}
else|else
block|{
comment|/* may happen if the link is missing (thru cycle detect algorithm or last_channel==channel_head (dummy channel)) */
block|}
block|}
else|else
block|{
comment|/* must be an error, channels for the path are added before, so a missing channel would be a corrupt data structure */
goto|goto
name|ERROR
goto|;
block|}
name|last_channel
operator|=
name|channel
expr_stmt|;
block|}
if|if
condition|(
name|channel_head
operator|->
name|linklist
condition|)
name|free
argument_list|(
name|channel_head
operator|->
name|linklist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|channel_head
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|ERROR
label|:
comment|/* cleanup data and exit */
if|if
condition|(
name|channel_head
condition|)
block|{
if|if
condition|(
name|channel_head
operator|->
name|linklist
condition|)
name|free
argument_list|(
name|channel_head
operator|->
name|linklist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|channel_head
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_comment
comment|/************ helper functions to generate an ordered list of ports ***  ************ (functions copied from osm_ucast_mgr.c and modified) ****  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|add_sw_endports_to_order_list
parameter_list|(
name|osm_switch_t
modifier|*
name|sw
parameter_list|,
name|osm_ucast_mgr_t
modifier|*
name|m
parameter_list|,
name|cl_qmap_t
modifier|*
name|guid_tbl
parameter_list|,
name|boolean_t
name|add_guids
parameter_list|)
block|{
name|osm_port_t
modifier|*
name|port
decl_stmt|;
name|ib_net64_t
name|port_guid
decl_stmt|;
name|uint64_t
name|sw_guid
decl_stmt|;
name|osm_physp_t
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|boolean_t
name|found
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sw
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|sw
operator|->
name|p_node
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|p_remote_physp
operator|&&
operator|!
name|p
operator|->
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
condition|)
block|{
name|port_guid
operator|=
name|p
operator|->
name|p_remote_physp
operator|->
name|port_guid
expr_stmt|;
comment|/* check if link is healthy, otherwise ignore CA */
if|if
condition|(
operator|!
name|osm_link_is_healthy
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|sw_guid
operator|=
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|sw
operator|->
name|p_node
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|m
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"WRN AD40: ignoring CA due to unhealthy"
literal|" link from switch 0x%016"
name|PRIx64
literal|" port %"
name|PRIu8
literal|" to CA 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|sw_guid
argument_list|,
name|i
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|m
operator|->
name|p_subn
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port
condition|)
continue|continue;
if|if
condition|(
operator|!
name|cl_is_qmap_empty
argument_list|(
name|guid_tbl
argument_list|)
condition|)
block|{
name|found
operator|=
operator|(
name|cl_qmap_get
argument_list|(
name|guid_tbl
argument_list|,
name|port_guid
argument_list|)
operator|!=
name|cl_qmap_end
argument_list|(
name|guid_tbl
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|add_guids
operator|&&
operator|!
name|found
operator|)
operator|||
operator|(
operator|!
name|add_guids
operator|&&
name|found
operator|)
condition|)
continue|continue;
block|}
if|if
condition|(
operator|!
name|cl_is_item_in_qlist
argument_list|(
operator|&
name|m
operator|->
name|port_order_list
argument_list|,
operator|&
name|port
operator|->
name|list_item
argument_list|)
condition|)
name|cl_qlist_insert_tail
argument_list|(
operator|&
name|m
operator|->
name|port_order_list
argument_list|,
operator|&
name|port
operator|->
name|list_item
argument_list|)
expr_stmt|;
else|else
name|OSM_LOG
argument_list|(
name|m
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"WRN AD37: guid 0x%016"
name|PRIx64
literal|" already in list\n"
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|add_guid_to_order_list
parameter_list|(
name|uint64_t
name|guid
parameter_list|,
name|osm_ucast_mgr_t
modifier|*
name|m
parameter_list|)
block|{
name|osm_port_t
modifier|*
name|port
init|=
name|osm_get_port_by_guid
argument_list|(
name|m
operator|->
name|p_subn
argument_list|,
name|cl_hton64
argument_list|(
name|guid
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|port
condition|)
block|{
name|OSM_LOG
argument_list|(
name|m
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"port guid not found: 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|guid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cl_is_item_in_qlist
argument_list|(
operator|&
name|m
operator|->
name|port_order_list
argument_list|,
operator|&
name|port
operator|->
name|list_item
argument_list|)
condition|)
name|cl_qlist_insert_tail
argument_list|(
operator|&
name|m
operator|->
name|port_order_list
argument_list|,
operator|&
name|port
operator|->
name|list_item
argument_list|)
expr_stmt|;
else|else
name|OSM_LOG
argument_list|(
name|m
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"WRN AD38: guid 0x%016"
name|PRIx64
literal|" already in list\n"
argument_list|,
name|guid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* compare function of #Hca attached to a switch for stdlib qsort */
end_comment

begin_function
specifier|static
name|int
name|cmp_num_hca
parameter_list|(
specifier|const
name|void
modifier|*
name|l1
parameter_list|,
specifier|const
name|void
modifier|*
name|l2
parameter_list|)
block|{
name|vertex_t
modifier|*
name|sw1
init|=
operator|*
operator|(
operator|(
name|vertex_t
operator|*
operator|*
operator|)
name|l1
operator|)
decl_stmt|;
name|vertex_t
modifier|*
name|sw2
init|=
operator|*
operator|(
operator|(
name|vertex_t
operator|*
operator|*
operator|)
name|l2
operator|)
decl_stmt|;
name|uint32_t
name|num_hca1
init|=
literal|0
decl_stmt|,
name|num_hca2
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sw1
condition|)
name|num_hca1
operator|=
name|sw1
operator|->
name|num_hca
expr_stmt|;
if|if
condition|(
name|sw2
condition|)
name|num_hca2
operator|=
name|sw2
operator|->
name|num_hca
expr_stmt|;
if|if
condition|(
name|num_hca1
operator|>
name|num_hca2
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|num_hca1
operator|<
name|num_hca2
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* use stdlib to sort the switch array depending on num_hca */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|sw_list_sort_by_num_hca
parameter_list|(
name|vertex_t
modifier|*
modifier|*
name|sw_list
parameter_list|,
name|uint32_t
name|sw_list_size
parameter_list|)
block|{
name|qsort
argument_list|(
name|sw_list
argument_list|,
name|sw_list_size
argument_list|,
sizeof|sizeof
argument_list|(
name|vertex_t
operator|*
argument_list|)
argument_list|,
name|cmp_num_hca
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_comment
comment|/************ helper functions to manage a map of CN and I/O guids ****  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|add_guid_to_map
parameter_list|(
name|void
modifier|*
name|cxt
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
name|cl_qmap_t
modifier|*
name|map
init|=
name|cxt
decl_stmt|;
name|name_map_item_t
modifier|*
name|item
decl_stmt|;
name|name_map_item_t
modifier|*
name|inserted_item
decl_stmt|;
name|item
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
return|return
operator|-
literal|1
return|;
name|item
operator|->
name|guid
operator|=
name|cl_hton64
argument_list|(
name|guid
argument_list|)
expr_stmt|;
comment|/* internal: network byte order */
name|item
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
comment|/* name isn't needed */
name|inserted_item
operator|=
operator|(
name|name_map_item_t
operator|*
operator|)
name|cl_qmap_insert
argument_list|(
name|map
argument_list|,
name|item
operator|->
name|guid
argument_list|,
operator|&
name|item
operator|->
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|inserted_item
operator|!=
name|item
condition|)
name|free
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_guid_map
parameter_list|(
name|cl_qmap_t
modifier|*
name|guid_tbl
parameter_list|)
block|{
name|name_map_item_t
modifier|*
name|p_guid
init|=
name|NULL
decl_stmt|,
modifier|*
name|p_next_guid
init|=
name|NULL
decl_stmt|;
name|p_next_guid
operator|=
operator|(
name|name_map_item_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|guid_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_guid
operator|!=
operator|(
name|name_map_item_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|guid_tbl
argument_list|)
condition|)
block|{
name|p_guid
operator|=
name|p_next_guid
expr_stmt|;
name|p_next_guid
operator|=
operator|(
name|name_map_item_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_guid
operator|->
name|item
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_guid
argument_list|)
expr_stmt|;
block|}
name|cl_qmap_remove_all
argument_list|(
name|guid_tbl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|dfsssp_print_graph
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|,
name|vertex_t
modifier|*
name|adj_list
parameter_list|,
name|uint32_t
name|size
parameter_list|)
block|{
name|uint32_t
name|i
init|=
literal|0
decl_stmt|,
name|c
init|=
literal|0
decl_stmt|;
name|link_t
modifier|*
name|link
init|=
name|NULL
decl_stmt|;
comment|/* index 0 is for the source in dijkstra -> ignore */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"adj_list[%"
name|PRIu32
literal|"]:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"   guid = 0x%"
name|PRIx64
literal|" lid = %"
name|PRIu16
literal|" (%s)\n"
argument_list|,
name|adj_list
index|[
name|i
index|]
operator|.
name|guid
argument_list|,
name|adj_list
index|[
name|i
index|]
operator|.
name|lid
argument_list|,
name|adj_list
index|[
name|i
index|]
operator|.
name|sw
operator|->
name|p_node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"   num_hca = %"
name|PRIu32
literal|"\n"
argument_list|,
name|adj_list
index|[
name|i
index|]
operator|.
name|num_hca
argument_list|)
expr_stmt|;
name|c
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|link
operator|=
name|adj_list
index|[
name|i
index|]
operator|.
name|links
init|;
name|link
operator|!=
name|NULL
condition|;
name|link
operator|=
name|link
operator|->
name|next
operator|,
name|c
operator|++
control|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"   link[%"
name|PRIu32
literal|"]:\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"      to guid = 0x%"
name|PRIx64
literal|" (%s) port %"
name|PRIu8
literal|"\n"
argument_list|,
name|link
operator|->
name|guid
argument_list|,
name|adj_list
index|[
name|link
operator|->
name|to
index|]
operator|.
name|sw
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|link
operator|->
name|to_port
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"      weight on this link = %"
name|PRIu64
literal|"\n"
argument_list|,
name|link
operator|->
name|weight
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* predefine, to use this in next function */
end_comment

begin_function_decl
specifier|static
name|void
name|dfsssp_context_destroy
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dijkstra
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|,
name|vertex_t
modifier|*
name|adj_list
parameter_list|,
name|uint32_t
name|adj_list_size
parameter_list|,
name|osm_port_t
modifier|*
name|port
parameter_list|,
name|uint16_t
name|lid
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* traverse subnet to gather information about the connected switches */
end_comment

begin_function
specifier|static
name|int
name|dfsssp_build_graph
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|dfsssp_context_t
modifier|*
name|dfsssp_ctx
init|=
operator|(
name|dfsssp_context_t
operator|*
operator|)
name|context
decl_stmt|;
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
init|=
operator|(
name|osm_ucast_mgr_t
operator|*
operator|)
operator|(
name|dfsssp_ctx
operator|->
name|p_mgr
operator|)
decl_stmt|;
name|cl_qmap_t
modifier|*
name|port_tbl
init|=
operator|&
name|p_mgr
operator|->
name|p_subn
operator|->
name|port_guid_tbl
decl_stmt|;
comment|/* 1 management port per switch + 1 or 2 ports for each Hca */
name|osm_port_t
modifier|*
name|p_port
init|=
name|NULL
decl_stmt|;
name|cl_qmap_t
modifier|*
name|sw_tbl
init|=
operator|&
name|p_mgr
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
decl_stmt|;
name|cl_map_item_t
modifier|*
name|item
init|=
name|NULL
decl_stmt|;
name|osm_switch_t
modifier|*
name|sw
init|=
name|NULL
decl_stmt|;
name|osm_node_t
modifier|*
name|remote_node
init|=
name|NULL
decl_stmt|;
name|uint8_t
name|port
init|=
literal|0
decl_stmt|,
name|remote_port
init|=
literal|0
decl_stmt|;
name|uint32_t
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|,
name|undiscov
init|=
literal|0
decl_stmt|,
name|max_num_undiscov
init|=
literal|0
decl_stmt|;
name|uint64_t
name|total_num_hca
init|=
literal|0
decl_stmt|;
name|vertex_t
modifier|*
name|adj_list
init|=
name|NULL
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
init|=
name|NULL
decl_stmt|;
name|link_t
modifier|*
name|link
init|=
name|NULL
decl_stmt|,
modifier|*
name|head
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|num_sw
init|=
literal|0
decl_stmt|,
name|adj_list_size
init|=
literal|0
decl_stmt|;
name|uint8_t
name|lmc
init|=
literal|0
decl_stmt|;
name|uint16_t
name|sm_lid
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Building graph for df-/sssp routing\n"
argument_list|)
expr_stmt|;
comment|/* if this pointer isn't NULL, this is a reroute step; 	   old context will be destroyed (adj_list and srcdest2vl_table) 	 */
if|if
condition|(
name|dfsssp_ctx
operator|->
name|adj_list
condition|)
name|dfsssp_context_destroy
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|num_sw
operator|=
name|cl_qmap_count
argument_list|(
name|sw_tbl
argument_list|)
expr_stmt|;
name|adj_list_size
operator|=
name|num_sw
operator|+
literal|1
expr_stmt|;
comment|/* allocate an adjazenz list (array), 0. element is reserved for the source (Hca) in the routing algo, others are switches */
name|adj_list
operator|=
operator|(
name|vertex_t
operator|*
operator|)
name|malloc
argument_list|(
name|adj_list_size
operator|*
sizeof|sizeof
argument_list|(
name|vertex_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|adj_list
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD02: cannot allocate memory for adj_list\n"
argument_list|)
expr_stmt|;
goto|goto
name|ERROR
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adj_list_size
condition|;
name|i
operator|++
control|)
name|set_default_vertex
argument_list|(
operator|&
name|adj_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dfsssp_ctx
operator|->
name|adj_list
operator|=
name|adj_list
expr_stmt|;
name|dfsssp_ctx
operator|->
name|adj_list_size
operator|=
name|adj_list_size
expr_stmt|;
comment|/* count the total number of Hca / LIDs (for lmc>0) in the fabric; 	   even include base/enhanced switch port 0; base SP0 will have lmc=0 	 */
for|for
control|(
name|item
operator|=
name|cl_qmap_head
argument_list|(
name|port_tbl
argument_list|)
init|;
name|item
operator|!=
name|cl_qmap_end
argument_list|(
name|port_tbl
argument_list|)
condition|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
control|)
block|{
name|p_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|item
expr_stmt|;
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|p_port
operator|->
name|p_node
argument_list|)
operator|==
name|IB_NODE_TYPE_CA
operator|||
name|osm_node_get_type
argument_list|(
name|p_port
operator|->
name|p_node
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
condition|)
block|{
name|lmc
operator|=
name|osm_port_get_lmc
argument_list|(
name|p_port
argument_list|)
expr_stmt|;
name|total_num_hca
operator|+=
operator|(
literal|1
operator|<<
name|lmc
operator|)
expr_stmt|;
block|}
block|}
name|i
operator|=
literal|1
expr_stmt|;
comment|/* fill adj_list -> start with index 1 */
for|for
control|(
name|item
operator|=
name|cl_qmap_head
argument_list|(
name|sw_tbl
argument_list|)
init|;
name|item
operator|!=
name|cl_qmap_end
argument_list|(
name|sw_tbl
argument_list|)
condition|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
operator|,
name|i
operator|++
control|)
block|{
name|sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|item
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Processing switch with GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|sw
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|adj_list
index|[
name|i
index|]
operator|.
name|guid
operator|=
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|sw
operator|->
name|p_node
argument_list|)
argument_list|)
expr_stmt|;
name|adj_list
index|[
name|i
index|]
operator|.
name|lid
operator|=
name|cl_ntoh16
argument_list|(
name|osm_node_get_base_lid
argument_list|(
name|sw
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|adj_list
index|[
name|i
index|]
operator|.
name|sw
operator|=
name|sw
expr_stmt|;
name|link
operator|=
operator|(
name|link_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|link_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|link
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD03: cannot allocate memory for a link\n"
argument_list|)
expr_stmt|;
goto|goto
name|ERROR
goto|;
block|}
name|head
operator|=
name|link
expr_stmt|;
name|head
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* add SP0 to number of CA connected to a switch */
name|lmc
operator|=
name|osm_node_get_lmc
argument_list|(
name|sw
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|adj_list
index|[
name|i
index|]
operator|.
name|num_hca
operator|+=
operator|(
literal|1
operator|<<
name|lmc
operator|)
expr_stmt|;
comment|/* iterate over all ports in the switch, start with port 1 (port 0 is a management port) */
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<
name|sw
operator|->
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
comment|/* get the node behind the port */
name|remote_node
operator|=
name|osm_node_get_remote_node
argument_list|(
name|sw
operator|->
name|p_node
argument_list|,
name|port
argument_list|,
operator|&
name|remote_port
argument_list|)
expr_stmt|;
comment|/* if there is no remote node on this port or it's the same switch -> try next port */
if|if
condition|(
operator|!
name|remote_node
operator|||
name|remote_node
operator|->
name|sw
operator|==
name|sw
condition|)
continue|continue;
comment|/* make sure the link is healthy */
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|sw
operator|->
name|p_node
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
operator|||
operator|!
name|osm_link_is_healthy
argument_list|(
name|p_physp
argument_list|)
condition|)
continue|continue;
comment|/* if there is a Hca connected -> count and cycle */
if|if
condition|(
operator|!
name|remote_node
operator|->
name|sw
condition|)
block|{
name|lmc
operator|=
name|osm_node_get_lmc
argument_list|(
name|remote_node
argument_list|,
operator|(
name|uint32_t
operator|)
name|remote_port
argument_list|)
expr_stmt|;
name|adj_list
index|[
name|i
index|]
operator|.
name|num_hca
operator|+=
operator|(
literal|1
operator|<<
name|lmc
operator|)
expr_stmt|;
continue|continue;
block|}
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Node 0x%"
name|PRIx64
literal|", remote node 0x%"
name|PRIx64
literal|", port %"
name|PRIu8
literal|", remote port %"
name|PRIu8
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|sw
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|remote_node
argument_list|)
argument_list|)
argument_list|,
name|port
argument_list|,
name|remote_port
argument_list|)
expr_stmt|;
name|link
operator|->
name|next
operator|=
operator|(
name|link_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|link_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|link
operator|->
name|next
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD08: cannot allocate memory for a link\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|head
condition|)
block|{
name|link
operator|=
name|head
expr_stmt|;
name|head
operator|=
name|head
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|link
argument_list|)
expr_stmt|;
block|}
goto|goto
name|ERROR
goto|;
block|}
name|link
operator|=
name|link
operator|->
name|next
expr_stmt|;
name|set_default_link
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|link
operator|->
name|guid
operator|=
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|remote_node
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|->
name|from
operator|=
name|i
expr_stmt|;
name|link
operator|->
name|from_port
operator|=
name|port
expr_stmt|;
name|link
operator|->
name|to_port
operator|=
name|remote_port
expr_stmt|;
name|link
operator|->
name|weight
operator|=
name|total_num_hca
operator|*
name|total_num_hca
expr_stmt|;
comment|/* initialize with P^2 to force shortest paths */
block|}
name|adj_list
index|[
name|i
index|]
operator|.
name|links
operator|=
name|head
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
comment|/* connect the links with it's second adjacent node in the list */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|adj_list_size
condition|;
name|i
operator|++
control|)
block|{
name|link
operator|=
name|adj_list
index|[
name|i
index|]
operator|.
name|links
expr_stmt|;
while|while
condition|(
name|link
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|adj_list_size
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|link
operator|->
name|guid
operator|==
name|adj_list
index|[
name|j
index|]
operator|.
name|guid
condition|)
block|{
name|link
operator|->
name|to
operator|=
name|j
expr_stmt|;
break|break;
block|}
block|}
name|link
operator|=
name|link
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* do one dry run to determine connectivity issues */
name|sm_lid
operator|=
name|p_mgr
operator|->
name|p_subn
operator|->
name|master_sm_base_lid
expr_stmt|;
name|p_port
operator|=
name|osm_get_port_by_lid
argument_list|(
name|p_mgr
operator|->
name|p_subn
argument_list|,
name|sm_lid
argument_list|)
expr_stmt|;
name|err
operator|=
name|dijkstra
argument_list|(
name|p_mgr
argument_list|,
name|adj_list
argument_list|,
name|adj_list_size
argument_list|,
name|p_port
argument_list|,
name|sm_lid
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|ERROR
goto|;
block|}
else|else
block|{
comment|/* if sm is running on a switch, then dijkstra doesn't 		   initialize the used_link for this switch 		 */
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|p_port
operator|->
name|p_node
argument_list|)
operator|!=
name|IB_NODE_TYPE_CA
condition|)
name|max_num_undiscov
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|adj_list_size
condition|;
name|i
operator|++
control|)
name|undiscov
operator|+=
operator|(
name|adj_list
index|[
name|i
index|]
operator|.
name|used_link
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|max_num_undiscov
operator|<
name|undiscov
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD0C: unsupported network state (detached"
literal|" and inaccessible switches found; gracefully"
literal|" shutdown this routing engine)\n"
argument_list|)
expr_stmt|;
goto|goto
name|ERROR
goto|;
block|}
block|}
comment|/* print the discovered graph */
if|if
condition|(
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
name|dfsssp_print_graph
argument_list|(
name|p_mgr
argument_list|,
name|adj_list
argument_list|,
name|adj_list_size
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|ERROR
label|:
name|dfsssp_context_destroy
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_routes
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|,
name|vertex_t
modifier|*
name|adj_list
parameter_list|,
name|uint32_t
name|adj_list_size
parameter_list|,
name|osm_port_t
modifier|*
name|port
parameter_list|)
block|{
name|uint32_t
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|adj_list_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|adj_list
index|[
name|i
index|]
operator|.
name|state
operator|==
name|DISCOVERED
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Route from 0x%"
name|PRIx64
literal|" (%s) to 0x%"
name|PRIx64
literal|" (%s):\n"
argument_list|,
name|adj_list
index|[
name|i
index|]
operator|.
name|guid
argument_list|,
name|adj_list
index|[
name|i
index|]
operator|.
name|sw
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|port
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|adj_list
index|[
name|j
index|]
operator|.
name|used_link
condition|)
block|{
if|if
condition|(
name|j
operator|>
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"   0x%"
name|PRIx64
literal|" (%s) routes thru port %"
name|PRIu8
literal|"\n"
argument_list|,
name|adj_list
index|[
name|j
index|]
operator|.
name|guid
argument_list|,
name|adj_list
index|[
name|j
index|]
operator|.
name|sw
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|adj_list
index|[
name|j
index|]
operator|.
name|used_link
operator|->
name|to_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"   0x%"
name|PRIx64
literal|" (%s) routes thru port %"
name|PRIu8
literal|"\n"
argument_list|,
name|adj_list
index|[
name|j
index|]
operator|.
name|guid
argument_list|,
name|port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|adj_list
index|[
name|j
index|]
operator|.
name|used_link
operator|->
name|to_port
argument_list|)
expr_stmt|;
block|}
name|j
operator|=
name|adj_list
index|[
name|j
index|]
operator|.
name|used_link
operator|->
name|from
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* dijkstra step from one source to all switches in the df-/sssp graph */
end_comment

begin_function
specifier|static
name|int
name|dijkstra
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|,
name|vertex_t
modifier|*
name|adj_list
parameter_list|,
name|uint32_t
name|adj_list_size
parameter_list|,
name|osm_port_t
modifier|*
name|port
parameter_list|,
name|uint16_t
name|lid
parameter_list|)
block|{
name|uint32_t
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|,
name|index
init|=
literal|0
decl_stmt|;
name|osm_node_t
modifier|*
name|remote_node
init|=
name|NULL
decl_stmt|;
name|uint8_t
name|remote_port
init|=
literal|0
decl_stmt|;
name|vertex_t
modifier|*
name|current
init|=
name|NULL
decl_stmt|;
name|link_t
modifier|*
name|link
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|guid
init|=
literal|0
decl_stmt|;
name|binary_heap_t
modifier|*
name|heap
init|=
name|NULL
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* reset all switches for new round with a new source for dijkstra */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|adj_list_size
condition|;
name|i
operator|++
control|)
block|{
name|adj_list
index|[
name|i
index|]
operator|.
name|hops
operator|=
literal|0
expr_stmt|;
name|adj_list
index|[
name|i
index|]
operator|.
name|used_link
operator|=
name|NULL
expr_stmt|;
name|adj_list
index|[
name|i
index|]
operator|.
name|distance
operator|=
name|INF
expr_stmt|;
name|adj_list
index|[
name|i
index|]
operator|.
name|state
operator|=
name|UNDISCOVERED
expr_stmt|;
block|}
comment|/* if behind port is a Hca -> set adj_list[0] */
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|port
operator|->
name|p_node
argument_list|)
operator|==
name|IB_NODE_TYPE_CA
condition|)
block|{
comment|/* save old link to prevent many mallocs after set_default_... */
name|link
operator|=
name|adj_list
index|[
literal|0
index|]
operator|.
name|links
expr_stmt|;
comment|/* initialize adj_list[0] (the source for the routing, a Hca) */
name|set_default_vertex
argument_list|(
operator|&
name|adj_list
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|adj_list
index|[
literal|0
index|]
operator|.
name|guid
operator|=
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|port
operator|->
name|p_node
argument_list|)
argument_list|)
expr_stmt|;
name|adj_list
index|[
literal|0
index|]
operator|.
name|lid
operator|=
name|lid
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
comment|/* write saved link back to new adj_list[0] */
name|adj_list
index|[
literal|0
index|]
operator|.
name|links
operator|=
name|link
expr_stmt|;
comment|/* initialize link to neighbor for adj_list[0]; 		   make sure the link is healthy 		 */
if|if
condition|(
name|port
operator|->
name|p_physp
operator|&&
name|osm_link_is_healthy
argument_list|(
name|port
operator|->
name|p_physp
argument_list|)
condition|)
block|{
name|remote_node
operator|=
name|osm_node_get_remote_node
argument_list|(
name|port
operator|->
name|p_node
argument_list|,
name|port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|,
operator|&
name|remote_port
argument_list|)
expr_stmt|;
comment|/* if there is no remote node on this port or it's the same Hca -> ignore */
if|if
condition|(
name|remote_node
operator|&&
operator|(
name|osm_node_get_type
argument_list|(
name|remote_node
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|adj_list
index|[
literal|0
index|]
operator|.
name|links
operator|)
condition|)
block|{
name|adj_list
index|[
literal|0
index|]
operator|.
name|links
operator|=
operator|(
name|link_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|link_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|adj_list
index|[
literal|0
index|]
operator|.
name|links
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD07: cannot allocate memory for a link\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|set_default_link
argument_list|(
name|adj_list
index|[
literal|0
index|]
operator|.
name|links
argument_list|)
expr_stmt|;
name|adj_list
index|[
literal|0
index|]
operator|.
name|links
operator|->
name|guid
operator|=
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|remote_node
argument_list|)
argument_list|)
expr_stmt|;
name|adj_list
index|[
literal|0
index|]
operator|.
name|links
operator|->
name|from_port
operator|=
name|port
operator|->
name|p_physp
operator|->
name|port_num
expr_stmt|;
name|adj_list
index|[
literal|0
index|]
operator|.
name|links
operator|->
name|to_port
operator|=
name|remote_port
expr_stmt|;
name|adj_list
index|[
literal|0
index|]
operator|.
name|links
operator|->
name|weight
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|adj_list_size
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|adj_list
index|[
literal|0
index|]
operator|.
name|links
operator|->
name|guid
operator|==
name|adj_list
index|[
name|j
index|]
operator|.
name|guid
condition|)
block|{
name|adj_list
index|[
literal|0
index|]
operator|.
name|links
operator|->
name|to
operator|=
name|j
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* if link is unhealthy then there's a severe issue */
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD0B: unsupported network state (CA with"
literal|" unhealthy link state discovered; should have"
literal|" been filtered out before already; gracefully"
literal|" shutdown this routing engine)\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* if behind port is a switch -> search switch in adj_list */
block|}
else|else
block|{
comment|/* reset adj_list[0], if links=NULL reset was done before, then skip */
if|if
condition|(
name|adj_list
index|[
literal|0
index|]
operator|.
name|links
condition|)
block|{
name|free
argument_list|(
name|adj_list
index|[
literal|0
index|]
operator|.
name|links
argument_list|)
expr_stmt|;
name|set_default_vertex
argument_list|(
operator|&
name|adj_list
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* search for the switch which is the source in this round */
name|guid
operator|=
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|port
operator|->
name|p_node
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|adj_list_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|guid
operator|==
name|adj_list
index|[
name|i
index|]
operator|.
name|guid
condition|)
block|{
name|index
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* source in dijkstra */
name|adj_list
index|[
name|index
index|]
operator|.
name|distance
operator|=
literal|0
expr_stmt|;
name|adj_list
index|[
name|index
index|]
operator|.
name|state
operator|=
name|DISCOVERED
expr_stmt|;
name|adj_list
index|[
name|index
index|]
operator|.
name|hops
operator|=
literal|0
expr_stmt|;
comment|/* the source has hop count = 0 */
comment|/* create a heap to find (efficient) the node with the smallest distance */
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|port
operator|->
name|p_node
argument_list|)
operator|==
name|IB_NODE_TYPE_CA
condition|)
name|err
operator|=
name|heap_create
argument_list|(
name|adj_list
argument_list|,
name|adj_list_size
argument_list|,
operator|&
name|heap
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|heap_create
argument_list|(
operator|&
name|adj_list
index|[
literal|1
index|]
argument_list|,
name|adj_list_size
operator|-
literal|1
argument_list|,
operator|&
name|heap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD09: cannot allocate memory for heap or heap->node in heap_create(...)\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|current
operator|=
name|heap_getmin
argument_list|(
name|heap
argument_list|)
expr_stmt|;
while|while
condition|(
name|current
condition|)
block|{
name|current
operator|->
name|state
operator|=
name|DISCOVERED
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|used_link
condition|)
comment|/* increment the number of hops to the source for each new node */
name|current
operator|->
name|hops
operator|=
name|adj_list
index|[
name|current
operator|->
name|used_link
operator|->
name|from
index|]
operator|.
name|hops
operator|+
literal|1
expr_stmt|;
comment|/* add/update nodes which aren't discovered but accessible */
for|for
control|(
name|link
operator|=
name|current
operator|->
name|links
init|;
name|link
operator|!=
name|NULL
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|adj_list
index|[
name|link
operator|->
name|to
index|]
operator|.
name|state
operator|!=
name|DISCOVERED
operator|)
operator|&&
operator|(
name|current
operator|->
name|distance
operator|+
name|link
operator|->
name|weight
operator|<
name|adj_list
index|[
name|link
operator|->
name|to
index|]
operator|.
name|distance
operator|)
condition|)
block|{
name|adj_list
index|[
name|link
operator|->
name|to
index|]
operator|.
name|used_link
operator|=
name|link
expr_stmt|;
name|adj_list
index|[
name|link
operator|->
name|to
index|]
operator|.
name|distance
operator|=
name|current
operator|->
name|distance
operator|+
name|link
operator|->
name|weight
expr_stmt|;
name|heap_heapify
argument_list|(
name|heap
argument_list|,
name|adj_list
index|[
name|link
operator|->
name|to
index|]
operator|.
name|heap_id
argument_list|)
expr_stmt|;
block|}
block|}
name|current
operator|=
name|heap_getmin
argument_list|(
name|heap
argument_list|)
expr_stmt|;
block|}
comment|/* destroy the heap */
name|heap_free
argument_list|(
name|heap
argument_list|)
expr_stmt|;
name|heap
operator|=
name|NULL
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* update the linear forwarding tables of all switches with the informations    from the last dijsktra step */
end_comment

begin_function
specifier|static
name|int
name|update_lft
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|,
name|vertex_t
modifier|*
name|adj_list
parameter_list|,
name|uint32_t
name|adj_list_size
parameter_list|,
name|osm_port_t
modifier|*
name|p_port
parameter_list|,
name|uint16_t
name|lid
parameter_list|)
block|{
name|uint32_t
name|i
init|=
literal|0
decl_stmt|;
name|uint8_t
name|port
init|=
literal|0
decl_stmt|;
name|uint8_t
name|hops
init|=
literal|0
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_sw
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|is_ignored_by_port_prof
init|=
name|FALSE
decl_stmt|;
name|osm_physp_t
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|cl_status_t
name|ret
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|adj_list_size
condition|;
name|i
operator|++
control|)
block|{
comment|/* if no route goes thru this switch -> cycle */
if|if
condition|(
operator|!
operator|(
name|adj_list
index|[
name|i
index|]
operator|.
name|used_link
operator|)
condition|)
continue|continue;
name|p_sw
operator|=
name|adj_list
index|[
name|i
index|]
operator|.
name|sw
expr_stmt|;
name|hops
operator|=
name|adj_list
index|[
name|i
index|]
operator|.
name|hops
expr_stmt|;
name|port
operator|=
name|adj_list
index|[
name|i
index|]
operator|.
name|used_link
operator|->
name|to_port
expr_stmt|;
comment|/* the used_link is the link that was used in dijkstra to reach this node, 		   so the to_port is the local port on this node 		 */
if|if
condition|(
name|port
operator|==
name|OSM_NO_PATH
condition|)
block|{
comment|/* if clause shouldn't be possible in this routing, but who cares */
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD06: No path to get to LID %"
name|PRIu16
literal|" from switch 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|lid
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* do not try to overwrite the ppro of non existing port ... */
name|is_ignored_by_port_prof
operator|=
name|TRUE
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Routing LID %"
name|PRIu16
literal|" to port %"
name|PRIu8
literal|" for switch 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|lid
argument_list|,
name|port
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD0A: Physical port %d of Node GUID 0x%"
name|PRIx64
literal|"not found\n"
argument_list|,
name|port
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* we would like to optionally ignore this port in equalization 			   as in the case of the Mellanox Anafa Internal PCI TCA port 			 */
name|is_ignored_by_port_prof
operator|=
name|p
operator|->
name|is_prof_ignored
expr_stmt|;
comment|/* We also would ignore this route if the target lid is of 			   a switch and the port_profile_switch_node is not TRUE 			 */
if|if
condition|(
operator|!
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|port_profile_switch_nodes
condition|)
name|is_ignored_by_port_prof
operator||=
operator|(
name|osm_node_get_type
argument_list|(
name|p_port
operator|->
name|p_node
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
operator|)
expr_stmt|;
block|}
comment|/* to support lmc> 0 the functions alloc_ports_priv, free_ports_priv, find_and_add_remote_sys 		   from minhop aren't needed cause osm_switch_recommend_path is implicitly calculated 		   for each LID pair thru dijkstra; 		   for each port the dijkstra algorithm calculates (max_lid_ho - min_lid_ho)-times maybe 		   disjoint routes to spread the bandwidth -> diffent routes for one port and lmc>0 		 */
comment|/* set port in LFT */
name|p_sw
operator|->
name|new_lft
index|[
name|lid
index|]
operator|=
name|port
expr_stmt|;
if|if
condition|(
operator|!
name|is_ignored_by_port_prof
condition|)
block|{
comment|/* update the number of path routing thru this port */
name|osm_switch_count_path
argument_list|(
name|p_sw
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
comment|/* set the hop count from this switch to the lid */
name|ret
operator|=
name|osm_switch_set_hops
argument_list|(
name|p_sw
argument_list|,
name|lid
argument_list|,
name|port
argument_list|,
name|hops
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|CL_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD05: cannot set hops for LID %"
name|PRIu16
literal|" at switch 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|lid
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* the function updates the multicast group membership information    similar to create_mgrp_switch_map (osm_mcast_mgr.c)    => with it we can identify if a switch needs to be processed    or not in update_mcft */
end_comment

begin_function
specifier|static
name|void
name|update_mgrp_membership
parameter_list|(
name|cl_qlist_t
modifier|*
name|port_list
parameter_list|)
block|{
name|osm_mcast_work_obj_t
modifier|*
name|wobj
init|=
name|NULL
decl_stmt|;
name|osm_port_t
modifier|*
name|port
init|=
name|NULL
decl_stmt|;
name|osm_switch_t
modifier|*
name|sw
init|=
name|NULL
decl_stmt|;
name|cl_list_item_t
modifier|*
name|i
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
name|cl_qlist_head
argument_list|(
name|port_list
argument_list|)
init|;
name|i
operator|!=
name|cl_qlist_end
argument_list|(
name|port_list
argument_list|)
condition|;
name|i
operator|=
name|cl_qlist_next
argument_list|(
name|i
argument_list|)
control|)
block|{
name|wobj
operator|=
name|cl_item_obj
argument_list|(
name|i
argument_list|,
name|wobj
argument_list|,
name|list_item
argument_list|)
expr_stmt|;
name|port
operator|=
name|wobj
operator|->
name|p_port
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|p_node
operator|->
name|sw
condition|)
block|{
name|sw
operator|=
name|port
operator|->
name|p_node
operator|->
name|sw
expr_stmt|;
name|sw
operator|->
name|is_mc_member
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sw
operator|=
name|port
operator|->
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
expr_stmt|;
name|sw
operator|->
name|num_of_mcm
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* reset is_mc_member and num_of_mcm for future computations */
end_comment

begin_function
specifier|static
name|void
name|reset_mgrp_membership
parameter_list|(
name|vertex_t
modifier|*
name|adj_list
parameter_list|,
name|uint32_t
name|adj_list_size
parameter_list|)
block|{
name|uint32_t
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|adj_list_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|adj_list
index|[
name|i
index|]
operator|.
name|dropped
condition|)
continue|continue;
name|adj_list
index|[
name|i
index|]
operator|.
name|sw
operator|->
name|is_mc_member
operator|=
literal|0
expr_stmt|;
name|adj_list
index|[
name|i
index|]
operator|.
name|sw
operator|->
name|num_of_mcm
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* update the multicast forwarding tables of all switches with the informations    from the previous dijsktra step for the current mlid */
end_comment

begin_function
specifier|static
name|int
name|update_mcft
parameter_list|(
name|osm_sm_t
modifier|*
name|p_sm
parameter_list|,
name|vertex_t
modifier|*
name|adj_list
parameter_list|,
name|uint32_t
name|adj_list_size
parameter_list|,
name|uint16_t
name|mlid_ho
parameter_list|,
name|cl_qmap_t
modifier|*
name|port_map
parameter_list|,
name|osm_switch_t
modifier|*
name|root_sw
parameter_list|)
block|{
name|uint32_t
name|i
init|=
literal|0
decl_stmt|;
name|uint8_t
name|port
init|=
literal|0
decl_stmt|,
name|remote_port
init|=
literal|0
decl_stmt|;
name|uint8_t
name|upstream_port
init|=
literal|0
decl_stmt|,
name|downstream_port
init|=
literal|0
decl_stmt|;
name|ib_net64_t
name|guid
init|=
literal|0
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_sw
init|=
name|NULL
decl_stmt|;
name|osm_node_t
modifier|*
name|remote_node
init|=
name|NULL
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
init|=
name|NULL
decl_stmt|;
name|osm_mcast_tbl_t
modifier|*
name|p_tbl
init|=
name|NULL
decl_stmt|;
name|vertex_t
modifier|*
name|curr_adj
init|=
name|NULL
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|adj_list_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|adj_list
index|[
name|i
index|]
operator|.
name|dropped
condition|)
continue|continue;
name|p_sw
operator|=
name|adj_list
index|[
name|i
index|]
operator|.
name|sw
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Processing switch 0x%016"
name|PRIx64
literal|" (%s) for MLID 0x%X\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|adj_list
index|[
name|i
index|]
operator|.
name|guid
argument_list|)
argument_list|,
name|p_sw
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|mlid_ho
argument_list|)
expr_stmt|;
comment|/* if a) the switch does not support mcast  or 		      b) no ports of this switch are part or the mcast group 		   then cycle 		 */
if|if
condition|(
name|osm_switch_supports_mcast
argument_list|(
name|p_sw
argument_list|)
operator|==
name|FALSE
operator|||
operator|(
name|p_sw
operator|->
name|num_of_mcm
operator|==
literal|0
operator|&&
operator|!
operator|(
name|p_sw
operator|->
name|is_mc_member
operator|)
operator|)
condition|)
continue|continue;
name|p_tbl
operator|=
name|osm_switch_get_mcast_tbl_ptr
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
comment|/* add all ports of this sw to the mcast table, 		   if they are part of the mcast grp 		 */
if|if
condition|(
name|p_sw
operator|->
name|is_mc_member
condition|)
name|osm_mcast_tbl_set
argument_list|(
name|p_tbl
argument_list|,
name|mlid_ho
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<
name|p_sw
operator|->
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
comment|/* get the node behind the port */
name|remote_node
operator|=
name|osm_node_get_remote_node
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|,
name|port
argument_list|,
operator|&
name|remote_port
argument_list|)
expr_stmt|;
comment|/* check if connected and its not the same switch */
if|if
condition|(
operator|!
name|remote_node
operator|||
name|remote_node
operator|->
name|sw
operator|==
name|p_sw
condition|)
continue|continue;
comment|/* make sure the link is healthy */
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
operator|||
operator|!
name|osm_link_is_healthy
argument_list|(
name|p_physp
argument_list|)
condition|)
continue|continue;
comment|/* we don't add upstream ports in this step */
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|remote_node
argument_list|)
operator|!=
name|IB_NODE_TYPE_CA
condition|)
continue|continue;
name|guid
operator|=
name|osm_physp_get_port_guid
argument_list|(
name|osm_node_get_physp_ptr
argument_list|(
name|remote_node
argument_list|,
name|remote_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl_qmap_get
argument_list|(
name|port_map
argument_list|,
name|guid
argument_list|)
operator|!=
name|cl_qmap_end
argument_list|(
name|port_map
argument_list|)
condition|)
name|osm_mcast_tbl_set
argument_list|(
name|p_tbl
argument_list|,
name|mlid_ho
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
comment|/* now we have to add the upstream port of 'this' switch and 		   the downstream port of the next switch to the mcast table 		   until we reach the root_sw 		 */
name|curr_adj
operator|=
operator|&
name|adj_list
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|curr_adj
operator|->
name|sw
operator|!=
name|root_sw
condition|)
block|{
comment|/* the used_link is the link that was used in dijkstra to reach this node, 			   so the to_port is the local (upstream) port on curr_adj->sw 			 */
name|upstream_port
operator|=
name|curr_adj
operator|->
name|used_link
operator|->
name|to_port
expr_stmt|;
name|osm_mcast_tbl_set
argument_list|(
name|p_tbl
argument_list|,
name|mlid_ho
argument_list|,
name|upstream_port
argument_list|)
expr_stmt|;
comment|/* now we go one step in direction root_sw and add the 			   downstream port for the spanning tree 			 */
name|downstream_port
operator|=
name|curr_adj
operator|->
name|used_link
operator|->
name|from_port
expr_stmt|;
name|p_tbl
operator|=
name|osm_switch_get_mcast_tbl_ptr
argument_list|(
name|adj_list
index|[
name|curr_adj
operator|->
name|used_link
operator|->
name|from
index|]
operator|.
name|sw
argument_list|)
expr_stmt|;
name|osm_mcast_tbl_set
argument_list|(
name|p_tbl
argument_list|,
name|mlid_ho
argument_list|,
name|downstream_port
argument_list|)
expr_stmt|;
name|curr_adj
operator|=
operator|&
name|adj_list
index|[
name|curr_adj
operator|->
name|used_link
operator|->
name|from
index|]
expr_stmt|;
block|}
block|}
name|OSM_LOG_EXIT
argument_list|(
name|p_sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* increment the edge weights of the df-/sssp graph which represent the number    of paths on this link */
end_comment

begin_function
specifier|static
name|void
name|update_weights
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|,
name|vertex_t
modifier|*
name|adj_list
parameter_list|,
name|uint32_t
name|adj_list_size
parameter_list|)
block|{
name|uint32_t
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|uint32_t
name|additional_weight
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|adj_list_size
condition|;
name|i
operator|++
control|)
block|{
comment|/* if no route goes thru this switch -> cycle */
if|if
condition|(
operator|!
operator|(
name|adj_list
index|[
name|i
index|]
operator|.
name|used_link
operator|)
condition|)
continue|continue;
name|additional_weight
operator|=
name|adj_list
index|[
name|i
index|]
operator|.
name|num_hca
expr_stmt|;
name|j
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|adj_list
index|[
name|j
index|]
operator|.
name|used_link
condition|)
block|{
comment|/* update the link from pre to this node */
name|adj_list
index|[
name|j
index|]
operator|.
name|used_link
operator|->
name|weight
operator|+=
name|additional_weight
expr_stmt|;
name|j
operator|=
name|adj_list
index|[
name|j
index|]
operator|.
name|used_link
operator|->
name|from
expr_stmt|;
block|}
block|}
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get the largest number of virtual lanes which is supported by all switches    in the subnet */
end_comment

begin_function
specifier|static
name|uint8_t
name|get_avail_vl_in_subn
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|)
block|{
name|uint32_t
name|i
init|=
literal|0
decl_stmt|;
name|uint8_t
name|vls_avail
init|=
literal|0xFF
decl_stmt|,
name|port_vls_avail
init|=
literal|0
decl_stmt|;
name|cl_qmap_t
modifier|*
name|sw_tbl
init|=
operator|&
name|p_mgr
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
decl_stmt|;
name|cl_map_item_t
modifier|*
name|item
init|=
name|NULL
decl_stmt|;
name|osm_switch_t
modifier|*
name|sw
init|=
name|NULL
decl_stmt|;
comment|/* traverse all switches to get the number of available virtual lanes in the subnet */
for|for
control|(
name|item
operator|=
name|cl_qmap_head
argument_list|(
name|sw_tbl
argument_list|)
init|;
name|item
operator|!=
name|cl_qmap_end
argument_list|(
name|sw_tbl
argument_list|)
condition|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
control|)
block|{
name|sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|item
expr_stmt|;
comment|/* ignore management port 0 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|osm_node_get_num_physp
argument_list|(
name|sw
operator|->
name|p_node
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|osm_physp_t
modifier|*
name|p_physp
init|=
name|osm_node_get_physp_ptr
argument_list|(
name|sw
operator|->
name|p_node
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|p_physp
operator|&&
name|p_physp
operator|->
name|p_remote_physp
condition|)
block|{
name|port_vls_avail
operator|=
name|ib_port_info_get_op_vls
argument_list|(
operator|&
name|p_physp
operator|->
name|port_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|port_vls_avail
operator|&&
name|port_vls_avail
operator|<
name|vls_avail
condition|)
name|vls_avail
operator|=
name|port_vls_avail
expr_stmt|;
block|}
block|}
block|}
comment|/* ib_port_info_get_op_vls gives values 1 ... 5 (s. IBAS 14.2.5.6) */
name|vls_avail
operator|=
literal|1
operator|<<
operator|(
name|vls_avail
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* set boundaries (s. IBAS 3.5.7) */
if|if
condition|(
name|vls_avail
operator|>
literal|15
condition|)
name|vls_avail
operator|=
literal|15
expr_stmt|;
if|if
condition|(
name|vls_avail
operator|<
literal|1
condition|)
name|vls_avail
operator|=
literal|1
expr_stmt|;
return|return
name|vls_avail
return|;
block|}
end_function

begin_comment
comment|/* search for cycles in the channel dependency graph to identify possible    deadlocks in the network;    assign new virtual lanes to some paths to break the deadlocks */
end_comment

begin_function
specifier|static
name|int
name|dfsssp_remove_deadlocks
parameter_list|(
name|dfsssp_context_t
modifier|*
name|dfsssp_ctx
parameter_list|)
block|{
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
init|=
operator|(
name|osm_ucast_mgr_t
operator|*
operator|)
name|dfsssp_ctx
operator|->
name|p_mgr
decl_stmt|;
name|cl_qlist_t
modifier|*
name|port_tbl
init|=
operator|&
name|p_mgr
operator|->
name|port_order_list
decl_stmt|;
comment|/* 1 management port per switch + 1 or 2 ports for each Hca */
name|cl_list_item_t
modifier|*
name|item1
init|=
name|NULL
decl_stmt|,
modifier|*
name|item2
init|=
name|NULL
decl_stmt|;
name|osm_port_t
modifier|*
name|src_port
init|=
name|NULL
decl_stmt|,
modifier|*
name|dest_port
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|uint8_t
name|vl
init|=
literal|0
decl_stmt|,
name|test_vl
init|=
literal|0
decl_stmt|,
name|vl_avail
init|=
literal|0
decl_stmt|,
name|vl_needed
init|=
literal|1
decl_stmt|;
name|double
name|most_avg_paths
init|=
literal|0.0
decl_stmt|;
name|cdg_node_t
modifier|*
modifier|*
name|cdg
init|=
name|NULL
decl_stmt|,
modifier|*
name|start_here
init|=
name|NULL
decl_stmt|,
modifier|*
name|cycle
init|=
name|NULL
decl_stmt|;
name|cdg_link_t
modifier|*
name|weakest_link
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|srcdest
init|=
literal|0
decl_stmt|;
name|vltable_t
modifier|*
name|srcdest2vl_table
init|=
name|NULL
decl_stmt|;
name|uint8_t
name|lmc
init|=
literal|0
decl_stmt|;
name|uint16_t
name|slid
init|=
literal|0
decl_stmt|,
name|dlid
init|=
literal|0
decl_stmt|,
name|min_lid_ho
init|=
literal|0
decl_stmt|,
name|max_lid_ho
init|=
literal|0
decl_stmt|,
name|min_lid_ho2
init|=
literal|0
decl_stmt|,
name|max_lid_ho2
init|=
literal|0
decl_stmt|;
empty_stmt|;
name|uint64_t
modifier|*
name|paths_per_vl
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|from
init|=
literal|0
decl_stmt|,
name|to
init|=
literal|0
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|split_count
init|=
name|NULL
decl_stmt|;
name|uint8_t
name|ntype
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Assign each src/dest pair a Virtual Lanes, to remove deadlocks in the routing\n"
argument_list|)
expr_stmt|;
name|vl_avail
operator|=
name|get_avail_vl_in_subn
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Virtual Lanes available: %"
name|PRIu8
literal|"\n"
argument_list|,
name|vl_avail
argument_list|)
expr_stmt|;
name|paths_per_vl
operator|=
operator|(
name|uint64_t
operator|*
operator|)
name|malloc
argument_list|(
name|vl_avail
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|paths_per_vl
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD22: cannot allocate memory for paths_per_vl\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|memset
argument_list|(
name|paths_per_vl
argument_list|,
literal|0
argument_list|,
name|vl_avail
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|cdg
operator|=
operator|(
name|cdg_node_t
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|vl_avail
operator|*
sizeof|sizeof
argument_list|(
name|cdg_node_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cdg
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD23: cannot allocate memory for cdg\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|paths_per_vl
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vl_avail
condition|;
name|i
operator|++
control|)
name|cdg
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* count all ports (also multiple LIDs) of type CA or SP0 for size of VL table */
for|for
control|(
name|item1
operator|=
name|cl_qlist_head
argument_list|(
name|port_tbl
argument_list|)
init|;
name|item1
operator|!=
name|cl_qlist_end
argument_list|(
name|port_tbl
argument_list|)
condition|;
name|item1
operator|=
name|cl_qlist_next
argument_list|(
name|item1
argument_list|)
control|)
block|{
name|dest_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_item_obj
argument_list|(
name|item1
argument_list|,
name|dest_port
argument_list|,
name|list_item
argument_list|)
expr_stmt|;
name|ntype
operator|=
name|osm_node_get_type
argument_list|(
name|dest_port
operator|->
name|p_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntype
operator|==
name|IB_NODE_TYPE_CA
operator|||
name|ntype
operator|==
name|IB_NODE_TYPE_SWITCH
condition|)
block|{
comment|/* only SP0 with SLtoVLMapping support will be processed */
if|if
condition|(
name|ntype
operator|==
name|IB_NODE_TYPE_SWITCH
operator|&&
operator|!
operator|(
name|dest_port
operator|->
name|p_physp
operator|->
name|port_info
operator|.
name|capability_mask
operator|&
name|IB_PORT_CAP_HAS_SL_MAP
operator|)
condition|)
continue|continue;
name|lmc
operator|=
name|osm_port_get_lmc
argument_list|(
name|dest_port
argument_list|)
expr_stmt|;
name|count
operator|+=
operator|(
literal|1
operator|<<
name|lmc
operator|)
expr_stmt|;
block|}
block|}
comment|/* allocate VL table and indexing array */
name|err
operator|=
name|vltable_alloc
argument_list|(
operator|&
name|srcdest2vl_table
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD26: cannot allocate memory for srcdest2vl_table\n"
argument_list|)
expr_stmt|;
goto|goto
name|ERROR
goto|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
comment|/* fill lids into indexing array */
for|for
control|(
name|item1
operator|=
name|cl_qlist_head
argument_list|(
name|port_tbl
argument_list|)
init|;
name|item1
operator|!=
name|cl_qlist_end
argument_list|(
name|port_tbl
argument_list|)
condition|;
name|item1
operator|=
name|cl_qlist_next
argument_list|(
name|item1
argument_list|)
control|)
block|{
name|dest_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_item_obj
argument_list|(
name|item1
argument_list|,
name|dest_port
argument_list|,
name|list_item
argument_list|)
expr_stmt|;
name|ntype
operator|=
name|osm_node_get_type
argument_list|(
name|dest_port
operator|->
name|p_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntype
operator|==
name|IB_NODE_TYPE_CA
operator|||
name|ntype
operator|==
name|IB_NODE_TYPE_SWITCH
condition|)
block|{
comment|/* only SP0 with SLtoVLMapping support will be processed */
if|if
condition|(
name|ntype
operator|==
name|IB_NODE_TYPE_SWITCH
operator|&&
operator|!
operator|(
name|dest_port
operator|->
name|p_physp
operator|->
name|port_info
operator|.
name|capability_mask
operator|&
name|IB_PORT_CAP_HAS_SL_MAP
operator|)
condition|)
continue|continue;
name|osm_port_get_lid_range_ho
argument_list|(
name|dest_port
argument_list|,
operator|&
name|min_lid_ho
argument_list|,
operator|&
name|max_lid_ho
argument_list|)
expr_stmt|;
for|for
control|(
name|dlid
operator|=
name|min_lid_ho
init|;
name|dlid
operator|<=
name|max_lid_ho
condition|;
name|dlid
operator|++
operator|,
name|i
operator|++
control|)
name|srcdest2vl_table
operator|->
name|lids
index|[
name|i
index|]
operator|=
name|cl_hton16
argument_list|(
name|dlid
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* sort lids */
name|vltable_sort_lids
argument_list|(
name|srcdest2vl_table
argument_list|)
expr_stmt|;
name|test_vl
operator|=
literal|0
expr_stmt|;
comment|/* fill cdg[0] with routes from each src/dest port combination for all Hca/SP0 in the subnet */
for|for
control|(
name|item1
operator|=
name|cl_qlist_head
argument_list|(
name|port_tbl
argument_list|)
init|;
name|item1
operator|!=
name|cl_qlist_end
argument_list|(
name|port_tbl
argument_list|)
condition|;
name|item1
operator|=
name|cl_qlist_next
argument_list|(
name|item1
argument_list|)
control|)
block|{
name|dest_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_item_obj
argument_list|(
name|item1
argument_list|,
name|dest_port
argument_list|,
name|list_item
argument_list|)
expr_stmt|;
name|ntype
operator|=
name|osm_node_get_type
argument_list|(
name|dest_port
operator|->
name|p_node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ntype
operator|!=
name|IB_NODE_TYPE_CA
operator|&&
name|ntype
operator|!=
name|IB_NODE_TYPE_SWITCH
operator|)
operator|||
operator|!
operator|(
name|dest_port
operator|->
name|p_physp
operator|->
name|port_info
operator|.
name|capability_mask
operator|&
name|IB_PORT_CAP_HAS_SL_MAP
operator|)
condition|)
continue|continue;
for|for
control|(
name|item2
operator|=
name|cl_qlist_head
argument_list|(
name|port_tbl
argument_list|)
init|;
name|item2
operator|!=
name|cl_qlist_end
argument_list|(
name|port_tbl
argument_list|)
condition|;
name|item2
operator|=
name|cl_qlist_next
argument_list|(
name|item2
argument_list|)
control|)
block|{
name|src_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_item_obj
argument_list|(
name|item2
argument_list|,
name|src_port
argument_list|,
name|list_item
argument_list|)
expr_stmt|;
name|ntype
operator|=
name|osm_node_get_type
argument_list|(
name|src_port
operator|->
name|p_node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ntype
operator|!=
name|IB_NODE_TYPE_CA
operator|&&
name|ntype
operator|!=
name|IB_NODE_TYPE_SWITCH
operator|)
operator|||
operator|!
operator|(
name|src_port
operator|->
name|p_physp
operator|->
name|port_info
operator|.
name|capability_mask
operator|&
name|IB_PORT_CAP_HAS_SL_MAP
operator|)
condition|)
continue|continue;
if|if
condition|(
name|src_port
operator|!=
name|dest_port
condition|)
block|{
comment|/* iterate over LIDs of src and dest port */
name|osm_port_get_lid_range_ho
argument_list|(
name|src_port
argument_list|,
operator|&
name|min_lid_ho
argument_list|,
operator|&
name|max_lid_ho
argument_list|)
expr_stmt|;
for|for
control|(
name|slid
operator|=
name|min_lid_ho
init|;
name|slid
operator|<=
name|max_lid_ho
condition|;
name|slid
operator|++
control|)
block|{
name|osm_port_get_lid_range_ho
argument_list|(
name|dest_port
argument_list|,
operator|&
name|min_lid_ho2
argument_list|,
operator|&
name|max_lid_ho2
argument_list|)
expr_stmt|;
for|for
control|(
name|dlid
operator|=
name|min_lid_ho2
init|;
name|dlid
operator|<=
name|max_lid_ho2
condition|;
name|dlid
operator|++
control|)
block|{
comment|/* try to add the path to cdg[0] */
name|err
operator|=
name|update_channel_dep_graph
argument_list|(
operator|&
operator|(
name|cdg
index|[
name|test_vl
index|]
operator|)
argument_list|,
name|src_port
argument_list|,
name|slid
argument_list|,
name|dest_port
argument_list|,
name|dlid
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD14: cannot allocate memory for cdg node or link in update_channel_dep_graph(...)\n"
argument_list|)
expr_stmt|;
goto|goto
name|ERROR
goto|;
block|}
comment|/* add the<s,d> combination / corresponding virtual lane to the VL table */
name|vltable_insert
argument_list|(
name|srcdest2vl_table
argument_list|,
name|cl_hton16
argument_list|(
name|slid
argument_list|)
argument_list|,
name|cl_hton16
argument_list|(
name|dlid
argument_list|)
argument_list|,
name|test_vl
argument_list|)
expr_stmt|;
name|paths_per_vl
index|[
name|test_vl
index|]
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|dfsssp_ctx
operator|->
name|srcdest2vl_table
operator|=
name|srcdest2vl_table
expr_stmt|;
comment|/* test all cdg for cycles and break the cycles by moving paths on the weakest link to the next cdg */
for|for
control|(
name|test_vl
operator|=
literal|0
init|;
name|test_vl
operator|<
name|vl_avail
operator|-
literal|1
condition|;
name|test_vl
operator|++
control|)
block|{
name|start_here
operator|=
name|cdg
index|[
name|test_vl
index|]
expr_stmt|;
while|while
condition|(
name|start_here
condition|)
block|{
name|cycle
operator|=
name|search_cycle_in_channel_dep_graph
argument_list|(
name|cdg
index|[
name|test_vl
index|]
argument_list|,
name|start_here
argument_list|)
expr_stmt|;
if|if
condition|(
name|cycle
condition|)
block|{
name|vl_needed
operator|=
name|test_vl
operator|+
literal|2
expr_stmt|;
comment|/* calc weakest link n cycle */
name|weakest_link
operator|=
name|get_weakest_link_in_cycle
argument_list|(
name|cycle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|weakest_link
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD27: something went wrong in get_weakest_link_in_cycle(...)\n"
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
goto|goto
name|ERROR
goto|;
block|}
name|paths_per_vl
index|[
name|test_vl
index|]
operator|-=
name|weakest_link
operator|->
name|num_pairs
expr_stmt|;
name|paths_per_vl
index|[
name|test_vl
operator|+
literal|1
index|]
operator|+=
name|weakest_link
operator|->
name|num_pairs
expr_stmt|;
comment|/* move all<s,d> paths on this link to the next cdg */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|weakest_link
operator|->
name|num_pairs
condition|;
name|i
operator|++
control|)
block|{
name|srcdest
operator|=
name|get_next_srcdest_pair
argument_list|(
name|weakest_link
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|slid
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|srcdest
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|dlid
operator|=
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|srcdest
operator|<<
literal|16
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
comment|/* only move if not moved in a previous step */
if|if
condition|(
name|test_vl
operator|!=
operator|(
name|uint8_t
operator|)
name|vltable_get_vl
argument_list|(
name|srcdest2vl_table
argument_list|,
name|cl_hton16
argument_list|(
name|slid
argument_list|)
argument_list|,
name|cl_hton16
argument_list|(
name|dlid
argument_list|)
argument_list|)
condition|)
block|{
comment|/* this path has been moved 						   before -> don't count 						 */
name|paths_per_vl
index|[
name|test_vl
index|]
operator|++
expr_stmt|;
name|paths_per_vl
index|[
name|test_vl
operator|+
literal|1
index|]
operator|--
expr_stmt|;
continue|continue;
block|}
name|src_port
operator|=
name|osm_get_port_by_lid
argument_list|(
name|p_mgr
operator|->
name|p_subn
argument_list|,
name|cl_hton16
argument_list|(
name|slid
argument_list|)
argument_list|)
expr_stmt|;
name|dest_port
operator|=
name|osm_get_port_by_lid
argument_list|(
name|p_mgr
operator|->
name|p_subn
argument_list|,
name|cl_hton16
argument_list|(
name|dlid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* remove path from current cdg / vl */
name|err
operator|=
name|remove_path_from_cdg
argument_list|(
operator|&
operator|(
name|cdg
index|[
name|test_vl
index|]
operator|)
argument_list|,
name|src_port
argument_list|,
name|slid
argument_list|,
name|dest_port
argument_list|,
name|dlid
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD44: something went wrong in remove_path_from_cdg(...)\n"
argument_list|)
expr_stmt|;
goto|goto
name|ERROR
goto|;
block|}
comment|/* add path to next cdg / vl */
name|err
operator|=
name|update_channel_dep_graph
argument_list|(
operator|&
operator|(
name|cdg
index|[
name|test_vl
operator|+
literal|1
index|]
operator|)
argument_list|,
name|src_port
argument_list|,
name|slid
argument_list|,
name|dest_port
argument_list|,
name|dlid
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD14: cannot allocate memory for cdg node or link in update_channel_dep_graph(...)\n"
argument_list|)
expr_stmt|;
goto|goto
name|ERROR
goto|;
block|}
name|vltable_insert
argument_list|(
name|srcdest2vl_table
argument_list|,
name|cl_hton16
argument_list|(
name|slid
argument_list|)
argument_list|,
name|cl_hton16
argument_list|(
name|dlid
argument_list|)
argument_list|,
name|test_vl
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|weakest_link
operator|->
name|num_pairs
condition|)
name|free
argument_list|(
name|weakest_link
operator|->
name|srcdest_pairs
argument_list|)
expr_stmt|;
if|if
condition|(
name|weakest_link
condition|)
name|free
argument_list|(
name|weakest_link
argument_list|)
expr_stmt|;
block|}
name|start_here
operator|=
name|cycle
expr_stmt|;
block|}
block|}
comment|/* test the last avail cdg for a cycle; 	   if there is one, than vl_needed> vl_avail 	 */
name|start_here
operator|=
name|cdg
index|[
name|vl_avail
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|start_here
condition|)
block|{
name|cycle
operator|=
name|search_cycle_in_channel_dep_graph
argument_list|(
name|cdg
index|[
name|vl_avail
operator|-
literal|1
index|]
argument_list|,
name|start_here
argument_list|)
expr_stmt|;
if|if
condition|(
name|cycle
condition|)
block|{
name|vl_needed
operator|=
name|vl_avail
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Virtual Lanes needed: %"
name|PRIu8
literal|"\n"
argument_list|,
name|vl_needed
argument_list|)
expr_stmt|;
if|if
condition|(
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Paths per VL (before balancing):\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vl_avail
condition|;
name|i
operator|++
control|)
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"   %"
name|PRIu32
literal|". lane: %"
name|PRIu64
literal|"\n"
argument_list|,
name|i
argument_list|,
name|paths_per_vl
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Balancing the paths on the available Virtual Lanes\n"
argument_list|)
expr_stmt|;
comment|/* optimal balancing virtual lanes, under condition: no additional cycle checks; 	   sl/vl != 0 might be assigned to loopback packets (i.e. slid/dlid on the 	   same port for lmc>0), but thats no problem, see IBAS 10.2.2.3 	 */
name|split_count
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|calloc
argument_list|(
name|vl_avail
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|split_count
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD24: cannot allocate memory for split_count, skip balancing\n"
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
goto|goto
name|ERROR
goto|;
block|}
comment|/* initial state: paths for VLs won't be separated */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
operator|(
name|vl_needed
operator|<
name|vl_avail
operator|)
condition|?
name|vl_needed
else|:
name|vl_avail
operator|)
condition|;
name|i
operator|++
control|)
name|split_count
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|dfsssp_ctx
operator|->
name|vl_split_count
operator|=
name|split_count
expr_stmt|;
comment|/* balancing is necessary if we have empty VLs */
if|if
condition|(
name|vl_needed
operator|<
name|vl_avail
condition|)
block|{
comment|/* split paths of VLs until we find an equal distribution */
for|for
control|(
name|i
operator|=
name|vl_needed
init|;
name|i
operator|<
name|vl_avail
condition|;
name|i
operator|++
control|)
block|{
comment|/* find VL with most paths in it */
name|vl
operator|=
literal|0
expr_stmt|;
name|most_avg_paths
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|test_vl
operator|=
literal|0
init|;
name|test_vl
operator|<
name|vl_needed
condition|;
name|test_vl
operator|++
control|)
block|{
if|if
condition|(
name|most_avg_paths
operator|<
operator|(
operator|(
name|double
operator|)
name|paths_per_vl
index|[
name|test_vl
index|]
operator|/
name|split_count
index|[
name|test_vl
index|]
operator|)
condition|)
block|{
name|vl
operator|=
name|test_vl
expr_stmt|;
name|most_avg_paths
operator|=
operator|(
name|double
operator|)
name|paths_per_vl
index|[
name|test_vl
index|]
operator|/
name|split_count
index|[
name|test_vl
index|]
expr_stmt|;
block|}
block|}
name|split_count
index|[
name|vl
index|]
operator|++
expr_stmt|;
block|}
comment|/* change the VL assignment depending on split_count for 		   all VLs except VL 0 		 */
for|for
control|(
name|from
operator|=
name|vl_needed
operator|-
literal|1
init|;
name|from
operator|>
literal|0
condition|;
name|from
operator|--
control|)
block|{
comment|/* how much space needed for others? */
name|to
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|from
condition|;
name|i
operator|++
control|)
name|to
operator|+=
name|split_count
index|[
name|i
index|]
expr_stmt|;
name|count
operator|=
name|paths_per_vl
index|[
name|from
index|]
expr_stmt|;
name|vltable_change_vl
argument_list|(
name|srcdest2vl_table
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* change also the information within the split_count 			   array; this is important for fast calculation later 			 */
name|split_count
index|[
name|to
index|]
operator|=
name|split_count
index|[
name|from
index|]
expr_stmt|;
name|split_count
index|[
name|from
index|]
operator|=
literal|0
expr_stmt|;
name|paths_per_vl
index|[
name|to
index|]
operator|=
name|paths_per_vl
index|[
name|from
index|]
expr_stmt|;
name|paths_per_vl
index|[
name|from
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|vl_needed
operator|>
name|vl_avail
condition|)
block|{
comment|/* routing not possible, a further development would be the LASH-TOR approach (update: LASH-TOR isn't possible, there is a mistake in the theory) */
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD25: Not enough VLs available (avail=%d, needed=%d); Stopping dfsssp routing!\n"
argument_list|,
name|vl_avail
argument_list|,
name|vl_needed
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
goto|goto
name|ERROR
goto|;
block|}
comment|/* else { no balancing } */
if|if
condition|(
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Virtual Lanes per src/dest combination after balancing:\n"
argument_list|)
expr_stmt|;
name|vltable_print
argument_list|(
name|p_mgr
argument_list|,
name|srcdest2vl_table
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Approx. #paths per VL (after balancing):\n"
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
comment|/* to prevent div. by 0 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vl_avail
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|split_count
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
name|j
operator|=
name|i
expr_stmt|;
name|count
operator|=
name|split_count
index|[
name|i
index|]
expr_stmt|;
block|}
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"   %"
name|PRIu32
literal|". lane: %"
name|PRIu64
literal|"\n"
argument_list|,
name|i
argument_list|,
name|paths_per_vl
index|[
name|j
index|]
operator|/
name|count
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|paths_per_vl
argument_list|)
expr_stmt|;
comment|/* deallocate channel dependency graphs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vl_avail
condition|;
name|i
operator|++
control|)
name|cdg_dealloc
argument_list|(
operator|&
name|cdg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cdg
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|ERROR
label|:
name|free
argument_list|(
name|paths_per_vl
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vl_avail
condition|;
name|i
operator|++
control|)
name|cdg_dealloc
argument_list|(
operator|&
name|cdg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cdg
argument_list|)
expr_stmt|;
name|vltable_dealloc
argument_list|(
operator|&
name|srcdest2vl_table
argument_list|)
expr_stmt|;
name|dfsssp_ctx
operator|->
name|srcdest2vl_table
operator|=
name|NULL
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* meta function which calls subfunctions for dijkstra, update lft and weights,    (and remove deadlocks) to calculate the routing for the subnet */
end_comment

begin_function
specifier|static
name|int
name|dfsssp_do_dijkstra_routing
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|dfsssp_context_t
modifier|*
name|dfsssp_ctx
init|=
operator|(
name|dfsssp_context_t
operator|*
operator|)
name|context
decl_stmt|;
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
init|=
operator|(
name|osm_ucast_mgr_t
operator|*
operator|)
name|dfsssp_ctx
operator|->
name|p_mgr
decl_stmt|;
name|vertex_t
modifier|*
name|adj_list
init|=
operator|(
name|vertex_t
operator|*
operator|)
name|dfsssp_ctx
operator|->
name|adj_list
decl_stmt|;
name|uint32_t
name|adj_list_size
init|=
name|dfsssp_ctx
operator|->
name|adj_list_size
decl_stmt|;
name|vertex_t
modifier|*
modifier|*
name|sw_list
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|sw_list_size
init|=
literal|0
decl_stmt|;
name|uint64_t
name|guid
init|=
literal|0
decl_stmt|;
name|cl_qlist_t
modifier|*
name|qlist
init|=
name|NULL
decl_stmt|;
name|cl_list_item_t
modifier|*
name|qlist_item
init|=
name|NULL
decl_stmt|;
name|cl_qmap_t
modifier|*
name|sw_tbl
init|=
operator|&
name|p_mgr
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
decl_stmt|;
name|cl_qmap_t
name|cn_tbl
decl_stmt|,
name|io_tbl
decl_stmt|,
modifier|*
name|p_mixed_tbl
init|=
name|NULL
decl_stmt|;
name|cl_map_item_t
modifier|*
name|item
init|=
name|NULL
decl_stmt|;
name|osm_switch_t
modifier|*
name|sw
init|=
name|NULL
decl_stmt|;
name|osm_port_t
modifier|*
name|port
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|i
init|=
literal|0
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|uint16_t
name|lid
init|=
literal|0
decl_stmt|,
name|min_lid_ho
init|=
literal|0
decl_stmt|,
name|max_lid_ho
init|=
literal|0
decl_stmt|;
name|uint8_t
name|lmc
init|=
literal|0
decl_stmt|;
name|boolean_t
name|cn_nodes_provided
init|=
name|FALSE
decl_stmt|,
name|io_nodes_provided
init|=
name|FALSE
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Calculating shortest path from all Hca/switches to all\n"
argument_list|)
expr_stmt|;
name|cl_qmap_init
argument_list|(
operator|&
name|cn_tbl
argument_list|)
expr_stmt|;
name|cl_qmap_init
argument_list|(
operator|&
name|io_tbl
argument_list|)
expr_stmt|;
name|p_mixed_tbl
operator|=
operator|&
name|cn_tbl
expr_stmt|;
name|cl_qlist_init
argument_list|(
operator|&
name|p_mgr
operator|->
name|port_order_list
argument_list|)
expr_stmt|;
comment|/* reset the new_lft for each switch */
for|for
control|(
name|item
operator|=
name|cl_qmap_head
argument_list|(
name|sw_tbl
argument_list|)
init|;
name|item
operator|!=
name|cl_qmap_end
argument_list|(
name|sw_tbl
argument_list|)
condition|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
control|)
block|{
name|sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|item
expr_stmt|;
comment|/* initialize LIDs in buffer to invalid port number */
name|memset
argument_list|(
name|sw
operator|->
name|new_lft
argument_list|,
name|OSM_NO_PATH
argument_list|,
name|sw
operator|->
name|max_lid_ho
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* initialize LFT and hop count for bsp0/esp0 of the switch */
name|min_lid_ho
operator|=
name|cl_ntoh16
argument_list|(
name|osm_node_get_base_lid
argument_list|(
name|sw
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|lmc
operator|=
name|osm_node_get_lmc
argument_list|(
name|sw
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|min_lid_ho
init|;
name|i
operator|<
name|min_lid_ho
operator|+
operator|(
literal|1
operator|<<
name|lmc
operator|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* for each switch the port to the 'self'lid is the management port 0 */
name|sw
operator|->
name|new_lft
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* the hop count to the 'self'lid is 0 for each switch */
name|osm_switch_set_hops
argument_list|(
name|sw
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* we need an intermediate array of pointers to switches in adj_list; 	   this array will be sorted in respect to num_hca (descending) 	 */
name|sw_list_size
operator|=
name|adj_list_size
operator|-
literal|1
expr_stmt|;
name|sw_list
operator|=
operator|(
name|vertex_t
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|sw_list_size
operator|*
sizeof|sizeof
argument_list|(
name|vertex_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sw_list
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD29: cannot allocate memory for sw_list in dfsssp_do_dijkstra_routing\n"
argument_list|)
expr_stmt|;
goto|goto
name|ERROR
goto|;
block|}
name|memset
argument_list|(
name|sw_list
argument_list|,
literal|0
argument_list|,
name|sw_list_size
operator|*
sizeof|sizeof
argument_list|(
name|vertex_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fill the array with references to the 'real' sw in adj_list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sw_list_size
condition|;
name|i
operator|++
control|)
name|sw_list
index|[
name|i
index|]
operator|=
operator|&
operator|(
name|adj_list
index|[
name|i
operator|+
literal|1
index|]
operator|)
expr_stmt|;
comment|/* sort the sw_list in descending order */
name|sw_list_sort_by_num_hca
argument_list|(
name|sw_list
argument_list|,
name|sw_list_size
argument_list|)
expr_stmt|;
comment|/* parse compute node guid file, if provided by the user */
if|if
condition|(
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|cn_guid_file
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Parsing compute nodes from file %s\n"
argument_list|,
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|cn_guid_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_node_map
argument_list|(
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|cn_guid_file
argument_list|,
name|add_guid_to_map
argument_list|,
operator|&
name|cn_tbl
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD33: Problem parsing compute node guid file\n"
argument_list|)
expr_stmt|;
goto|goto
name|ERROR
goto|;
block|}
if|if
condition|(
name|cl_is_qmap_empty
argument_list|(
operator|&
name|cn_tbl
argument_list|)
condition|)
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"WRN AD34: compute node guids file contains no valid guids\n"
argument_list|)
expr_stmt|;
else|else
name|cn_nodes_provided
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* parse I/O guid file, if provided by the user */
if|if
condition|(
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|io_guid_file
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Parsing I/O nodes from file %s\n"
argument_list|,
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|io_guid_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_node_map
argument_list|(
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|io_guid_file
argument_list|,
name|add_guid_to_map
argument_list|,
operator|&
name|io_tbl
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD35: Problem parsing I/O guid file\n"
argument_list|)
expr_stmt|;
goto|goto
name|ERROR
goto|;
block|}
if|if
condition|(
name|cl_is_qmap_empty
argument_list|(
operator|&
name|io_tbl
argument_list|)
condition|)
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"WRN AD36: I/O node guids file contains no valid guids\n"
argument_list|)
expr_stmt|;
else|else
name|io_nodes_provided
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* if we mix Hca/Tca/SP0 during the dijkstra routing, we might end up 	   in rare cases with a bad balancing for Hca<->Hca connections, i.e. 	   some inter-switch links get oversubscribed with paths; 	   therefore: add Hca ports first to ensure good Hca<->Hca balancing 	 */
if|if
condition|(
name|cn_nodes_provided
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adj_list_size
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sw_list
index|[
name|i
index|]
operator|&&
name|sw_list
index|[
name|i
index|]
operator|->
name|sw
condition|)
block|{
name|sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
operator|(
name|sw_list
index|[
name|i
index|]
operator|->
name|sw
operator|)
expr_stmt|;
name|add_sw_endports_to_order_list
argument_list|(
name|sw
argument_list|,
name|p_mgr
argument_list|,
operator|&
name|cn_tbl
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD30: corrupted sw_list array in dfsssp_do_dijkstra_routing\n"
argument_list|)
expr_stmt|;
goto|goto
name|ERROR
goto|;
block|}
block|}
block|}
comment|/* then: add Tca ports to ensure good Hca->Tca balancing and separate 	   paths towards I/O nodes on the same switch (if possible) 	 */
if|if
condition|(
name|io_nodes_provided
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adj_list_size
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sw_list
index|[
name|i
index|]
operator|&&
name|sw_list
index|[
name|i
index|]
operator|->
name|sw
condition|)
block|{
name|sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
operator|(
name|sw_list
index|[
name|i
index|]
operator|->
name|sw
operator|)
expr_stmt|;
name|add_sw_endports_to_order_list
argument_list|(
name|sw
argument_list|,
name|p_mgr
argument_list|,
operator|&
name|io_tbl
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD32: corrupted sw_list array in dfsssp_do_dijkstra_routing\n"
argument_list|)
expr_stmt|;
goto|goto
name|ERROR
goto|;
block|}
block|}
block|}
comment|/* then: add anything else, such as administration nodes, ... */
if|if
condition|(
name|cn_nodes_provided
operator|&&
name|io_nodes_provided
condition|)
block|{
name|cl_qmap_merge
argument_list|(
operator|&
name|cn_tbl
argument_list|,
operator|&
name|io_tbl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|io_nodes_provided
condition|)
block|{
name|p_mixed_tbl
operator|=
operator|&
name|io_tbl
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adj_list_size
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sw_list
index|[
name|i
index|]
operator|&&
name|sw_list
index|[
name|i
index|]
operator|->
name|sw
condition|)
block|{
name|sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
operator|(
name|sw_list
index|[
name|i
index|]
operator|->
name|sw
operator|)
expr_stmt|;
name|add_sw_endports_to_order_list
argument_list|(
name|sw
argument_list|,
name|p_mgr
argument_list|,
name|p_mixed_tbl
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD39: corrupted sw_list array in dfsssp_do_dijkstra_routing\n"
argument_list|)
expr_stmt|;
goto|goto
name|ERROR
goto|;
block|}
block|}
comment|/* last: add SP0 afterwards which have lower priority for balancing */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sw_list_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sw_list
index|[
name|i
index|]
operator|&&
name|sw_list
index|[
name|i
index|]
operator|->
name|sw
condition|)
block|{
name|sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
operator|(
name|sw_list
index|[
name|i
index|]
operator|->
name|sw
operator|)
expr_stmt|;
name|guid
operator|=
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|sw
operator|->
name|p_node
argument_list|)
argument_list|)
expr_stmt|;
name|add_guid_to_order_list
argument_list|(
name|guid
argument_list|,
name|p_mgr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD31: corrupted sw_list array in dfsssp_do_dijkstra_routing\n"
argument_list|)
expr_stmt|;
goto|goto
name|ERROR
goto|;
block|}
block|}
comment|/* the intermediate array lived long enough */
name|free
argument_list|(
name|sw_list
argument_list|)
expr_stmt|;
name|sw_list
operator|=
name|NULL
expr_stmt|;
comment|/* same is true for the compute node and I/O guid map */
name|destroy_guid_map
argument_list|(
operator|&
name|cn_tbl
argument_list|)
expr_stmt|;
name|cn_nodes_provided
operator|=
name|FALSE
expr_stmt|;
name|destroy_guid_map
argument_list|(
operator|&
name|io_tbl
argument_list|)
expr_stmt|;
name|io_nodes_provided
operator|=
name|FALSE
expr_stmt|;
comment|/* do the routing for the each Hca in the subnet and each switch 	   in the subnet (to add the routes to base/enhanced SP0) 	 */
name|qlist
operator|=
operator|&
name|p_mgr
operator|->
name|port_order_list
expr_stmt|;
for|for
control|(
name|qlist_item
operator|=
name|cl_qlist_head
argument_list|(
name|qlist
argument_list|)
init|;
name|qlist_item
operator|!=
name|cl_qlist_end
argument_list|(
name|qlist
argument_list|)
condition|;
name|qlist_item
operator|=
name|cl_qlist_next
argument_list|(
name|qlist_item
argument_list|)
control|)
block|{
name|port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_item_obj
argument_list|(
name|qlist_item
argument_list|,
name|port
argument_list|,
name|list_item
argument_list|)
expr_stmt|;
comment|/* calculate shortest path with dijkstra from node to all switches/Hca */
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|port
operator|->
name|p_node
argument_list|)
operator|==
name|IB_NODE_TYPE_CA
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Processing Hca with GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|port
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|port
operator|->
name|p_node
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Processing switch with GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|port
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* we don't handle routers, in case they show up */
continue|continue;
block|}
comment|/* distribute the LID range across the ports that can reach those LIDs 		   to have disjoint paths for one destination port with lmc>0; 		   for switches with bsp0: min=max; with esp0: max>min if lmc>0 		 */
name|osm_port_get_lid_range_ho
argument_list|(
name|port
argument_list|,
operator|&
name|min_lid_ho
argument_list|,
operator|&
name|max_lid_ho
argument_list|)
expr_stmt|;
for|for
control|(
name|lid
operator|=
name|min_lid_ho
init|;
name|lid
operator|<=
name|max_lid_ho
condition|;
name|lid
operator|++
control|)
block|{
comment|/* do dijkstra from this Hca/LID/SP0 to each switch */
name|err
operator|=
name|dijkstra
argument_list|(
name|p_mgr
argument_list|,
name|adj_list
argument_list|,
name|adj_list_size
argument_list|,
name|port
argument_list|,
name|lid
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|ERROR
goto|;
if|if
condition|(
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
name|print_routes
argument_list|(
name|p_mgr
argument_list|,
name|adj_list
argument_list|,
name|adj_list_size
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/* make an update for the linear forwarding tables of the switches */
name|err
operator|=
name|update_lft
argument_list|(
name|p_mgr
argument_list|,
name|adj_list
argument_list|,
name|adj_list_size
argument_list|,
name|port
argument_list|,
name|lid
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|ERROR
goto|;
comment|/* add weights for calculated routes to adjust the weights for the next cycle */
name|update_weights
argument_list|(
name|p_mgr
argument_list|,
name|adj_list
argument_list|,
name|adj_list_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
name|dfsssp_print_graph
argument_list|(
name|p_mgr
argument_list|,
name|adj_list
argument_list|,
name|adj_list_size
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* try deadlock removal only for the dfsssp routing (not for the sssp case, which is a subset of the dfsssp algorithm) */
if|if
condition|(
name|dfsssp_ctx
operator|->
name|routing_type
operator|==
name|OSM_ROUTING_ENGINE_TYPE_DFSSSP
condition|)
block|{
comment|/* remove potential deadlocks by assigning different virtual lanes to src/dest paths and balance the lanes */
name|err
operator|=
name|dfsssp_remove_deadlocks
argument_list|(
name|dfsssp_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|ERROR
goto|;
block|}
elseif|else
if|if
condition|(
name|dfsssp_ctx
operator|->
name|routing_type
operator|==
name|OSM_ROUTING_ENGINE_TYPE_SSSP
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"SSSP routing specified -> skipping deadlock removal thru dfsssp_remove_deadlocks(...)\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD28: wrong routing engine specified in dfsssp_ctx\n"
argument_list|)
expr_stmt|;
goto|goto
name|ERROR
goto|;
block|}
comment|/* list not needed after the dijkstra steps and deadlock removal */
name|cl_qlist_remove_all
argument_list|(
operator|&
name|p_mgr
operator|->
name|port_order_list
argument_list|)
expr_stmt|;
comment|/* print the new_lft for each switch after routing is done */
if|if
condition|(
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
block|{
for|for
control|(
name|item
operator|=
name|cl_qmap_head
argument_list|(
name|sw_tbl
argument_list|)
init|;
name|item
operator|!=
name|cl_qmap_end
argument_list|(
name|sw_tbl
argument_list|)
condition|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
control|)
block|{
name|sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|item
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Summary of the (new) LFT for switch 0x%"
name|PRIx64
literal|" (%s):\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|sw
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|sw
operator|->
name|p_node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sw
operator|->
name|max_lid_ho
operator|+
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sw
operator|->
name|new_lft
index|[
name|i
index|]
operator|!=
name|OSM_NO_PATH
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"   for LID=%"
name|PRIu32
literal|" use port=%"
name|PRIu8
literal|"\n"
argument_list|,
name|i
argument_list|,
name|sw
operator|->
name|new_lft
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|ERROR
label|:
if|if
condition|(
operator|!
name|cl_is_qlist_empty
argument_list|(
operator|&
name|p_mgr
operator|->
name|port_order_list
argument_list|)
condition|)
name|cl_qlist_remove_all
argument_list|(
operator|&
name|p_mgr
operator|->
name|port_order_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|cn_nodes_provided
condition|)
name|destroy_guid_map
argument_list|(
operator|&
name|cn_tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|io_nodes_provided
condition|)
name|destroy_guid_map
argument_list|(
operator|&
name|io_tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw_list
condition|)
name|free
argument_list|(
name|sw_list
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* meta function which calls subfunctions for finding the optimal switch    for the spanning tree, performing a dijkstra step with this sw as root,    and calculating the mcast table for MLID */
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|dfsssp_do_mcast_routing
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|osm_mgrp_box_t
modifier|*
name|mbox
parameter_list|)
block|{
name|dfsssp_context_t
modifier|*
name|dfsssp_ctx
init|=
operator|(
name|dfsssp_context_t
operator|*
operator|)
name|context
decl_stmt|;
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
init|=
operator|(
name|osm_ucast_mgr_t
operator|*
operator|)
name|dfsssp_ctx
operator|->
name|p_mgr
decl_stmt|;
name|osm_sm_t
modifier|*
name|sm
init|=
operator|(
name|osm_sm_t
operator|*
operator|)
name|p_mgr
operator|->
name|sm
decl_stmt|;
name|vertex_t
modifier|*
name|adj_list
init|=
operator|(
name|vertex_t
operator|*
operator|)
name|dfsssp_ctx
operator|->
name|adj_list
decl_stmt|;
name|uint32_t
name|adj_list_size
init|=
name|dfsssp_ctx
operator|->
name|adj_list_size
decl_stmt|;
name|cl_qlist_t
name|mcastgrp_port_list
decl_stmt|;
name|cl_qmap_t
name|mcastgrp_port_map
decl_stmt|;
name|osm_switch_t
modifier|*
name|root_sw
init|=
name|NULL
decl_stmt|,
modifier|*
name|p_sw
init|=
name|NULL
decl_stmt|;
name|osm_port_t
modifier|*
name|port
init|=
name|NULL
decl_stmt|;
name|ib_net16_t
name|lid
init|=
literal|0
decl_stmt|;
name|uint32_t
name|err
init|=
literal|0
decl_stmt|,
name|num_ports
init|=
literal|0
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|ib_net64_t
name|guid
init|=
literal|0
decl_stmt|;
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* using the ucast cache feature with dfsssp might mean that a leaf sw 	   got removed (and got back) without calling dfsssp_build_graph 	   and therefore the adj_list (and pointers to osm's internal switches) 	   could be outdated (here we have no knowledge if it has happened, so 	   unfortunately a check is necessary... still better than rebuilding 	   adj_list every time we arrive here) 	 */
if|if
condition|(
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|use_ucast_cache
operator|&&
name|p_mgr
operator|->
name|cache_valid
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|adj_list_size
condition|;
name|i
operator|++
control|)
block|{
name|guid
operator|=
name|cl_hton64
argument_list|(
name|adj_list
index|[
name|i
index|]
operator|.
name|guid
argument_list|)
expr_stmt|;
name|p_sw
operator|=
name|osm_get_switch_by_guid
argument_list|(
name|p_mgr
operator|->
name|p_subn
argument_list|,
name|guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
condition|)
block|{
comment|/* check if switch came back from the dead */
if|if
condition|(
name|adj_list
index|[
name|i
index|]
operator|.
name|dropped
condition|)
name|adj_list
index|[
name|i
index|]
operator|.
name|dropped
operator|=
name|FALSE
expr_stmt|;
comment|/* verify that sw object has not been moved 				   (this can happen for a leaf switch, if it 				   was dropped and came back later without a 				   rerouting), otherwise we have to update 				   dfsssp's internal switch list with the new 				   sw pointer 				 */
if|if
condition|(
name|p_sw
operator|==
name|adj_list
index|[
name|i
index|]
operator|.
name|sw
condition|)
continue|continue;
else|else
name|adj_list
index|[
name|i
index|]
operator|.
name|sw
operator|=
name|p_sw
expr_stmt|;
block|}
else|else
block|{
comment|/* if a switch from adj_list is not in the 				   sw_guid_tbl anymore, then the only reason is 				   that it was a leaf switch and opensm dropped 				   it without calling a rerouting 				   -> calling dijkstra is no problem, since it 				      is a leaf and different from root_sw 				   -> only update_mcft and reset_mgrp_membership 				      need to be aware of these dropped switches 				 */
if|if
condition|(
operator|!
name|adj_list
index|[
name|i
index|]
operator|.
name|dropped
condition|)
name|adj_list
index|[
name|i
index|]
operator|.
name|dropped
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
comment|/* create a map and a list of all ports which are member in the mcast 	   group; map for searching elements and list for iteration 	 */
if|if
condition|(
name|osm_mcast_make_port_list_and_map
argument_list|(
operator|&
name|mcastgrp_port_list
argument_list|,
operator|&
name|mcastgrp_port_map
argument_list|,
name|mbox
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD50: "
literal|"Insufficient memory to make port list\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|num_ports
operator|=
name|cl_qlist_count
argument_list|(
operator|&
name|mcastgrp_port_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_ports
operator|<
literal|2
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"MLID 0x%X has %u members - nothing to do\n"
argument_list|,
name|mbox
operator|->
name|mlid
argument_list|,
name|num_ports
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* find the root switch for the spanning tree, which has the smallest 	   hops count to all LIDs in the mcast group 	 */
name|root_sw
operator|=
name|osm_mcast_mgr_find_root_switch
argument_list|(
name|sm
argument_list|,
operator|&
name|mcastgrp_port_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|root_sw
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD51: "
literal|"Unable to locate a suitable switch for group 0x%X\n"
argument_list|,
name|mbox
operator|->
name|mlid
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* a) start one dijkstra step from the root switch to generate a 	   spanning tree 	   b) this might be a bit of an overkill to span the whole 	   network, if there are only a few ports in the mcast group, but 	   its only one dijkstra step for each mcast group and we did many 	   steps before in the ucast routing for each LID in the subnet; 	   c) we can use the subnet structure from the ucast routing, and 	   don't even have to reset the link weights (=> therefore the mcast 	   spanning tree will use less 'growded' links in the network) 	   d) the mcast dfsssp algorithm will not change the link weights 	 */
name|lid
operator|=
name|osm_node_get_base_lid
argument_list|(
name|root_sw
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|port
operator|=
name|osm_get_port_by_lid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|lid
argument_list|)
expr_stmt|;
name|err
operator|=
name|dijkstra
argument_list|(
name|p_mgr
argument_list|,
name|adj_list
argument_list|,
name|adj_list_size
argument_list|,
name|port
argument_list|,
name|lid
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD52: "
literal|"Dijkstra step for mcast failed for group 0x%X\n"
argument_list|,
name|mbox
operator|->
name|mlid
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* set mcast group membership again for update_mcft 	   (unfortunately: osm_mcast_mgr_find_root_switch resets it) 	 */
name|update_mgrp_membership
argument_list|(
operator|&
name|mcastgrp_port_list
argument_list|)
expr_stmt|;
comment|/* update the mcast forwarding tables of the switches */
name|err
operator|=
name|update_mcft
argument_list|(
name|sm
argument_list|,
name|adj_list
argument_list|,
name|adj_list_size
argument_list|,
name|mbox
operator|->
name|mlid
argument_list|,
operator|&
name|mcastgrp_port_map
argument_list|,
name|root_sw
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD53: "
literal|"Update of mcast forwarding tables failed for group 0x%X\n"
argument_list|,
name|mbox
operator|->
name|mlid
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|Exit
label|:
name|reset_mgrp_membership
argument_list|(
name|adj_list
argument_list|,
name|adj_list_size
argument_list|)
expr_stmt|;
name|osm_mcast_drop_port_list
argument_list|(
operator|&
name|mcastgrp_port_list
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* called from extern in QP creation process to gain the the service level and    the virtual lane respectively for a<s,d> pair */
end_comment

begin_function
specifier|static
name|uint8_t
name|get_dfsssp_sl
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|uint8_t
name|hint_for_default_sl
parameter_list|,
specifier|const
name|ib_net16_t
name|slid
parameter_list|,
specifier|const
name|ib_net16_t
name|dlid
parameter_list|)
block|{
name|dfsssp_context_t
modifier|*
name|dfsssp_ctx
init|=
operator|(
name|dfsssp_context_t
operator|*
operator|)
name|context
decl_stmt|;
name|osm_port_t
modifier|*
name|src_port
decl_stmt|,
modifier|*
name|dest_port
decl_stmt|;
name|vltable_t
modifier|*
name|srcdest2vl_table
init|=
name|NULL
decl_stmt|;
name|uint8_t
modifier|*
name|vl_split_count
init|=
name|NULL
decl_stmt|;
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
init|=
name|NULL
decl_stmt|;
name|int32_t
name|res
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dfsssp_ctx
operator|&&
name|dfsssp_ctx
operator|->
name|routing_type
operator|==
name|OSM_ROUTING_ENGINE_TYPE_DFSSSP
condition|)
block|{
name|p_mgr
operator|=
operator|(
name|osm_ucast_mgr_t
operator|*
operator|)
name|dfsssp_ctx
operator|->
name|p_mgr
expr_stmt|;
name|srcdest2vl_table
operator|=
operator|(
name|vltable_t
operator|*
operator|)
operator|(
name|dfsssp_ctx
operator|->
name|srcdest2vl_table
operator|)
expr_stmt|;
name|vl_split_count
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|dfsssp_ctx
operator|->
name|vl_split_count
operator|)
expr_stmt|;
block|}
else|else
return|return
name|hint_for_default_sl
return|;
name|src_port
operator|=
name|osm_get_port_by_lid
argument_list|(
name|p_mgr
operator|->
name|p_subn
argument_list|,
name|slid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|src_port
condition|)
return|return
name|hint_for_default_sl
return|;
name|dest_port
operator|=
name|osm_get_port_by_lid
argument_list|(
name|p_mgr
operator|->
name|p_subn
argument_list|,
name|dlid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dest_port
condition|)
return|return
name|hint_for_default_sl
return|;
if|if
condition|(
operator|!
name|srcdest2vl_table
condition|)
return|return
name|hint_for_default_sl
return|;
name|res
operator|=
name|vltable_get_vl
argument_list|(
name|srcdest2vl_table
argument_list|,
name|slid
argument_list|,
name|dlid
argument_list|)
expr_stmt|;
comment|/* we will randomly distribute the traffic over multiple VLs if 	   necessary for good balancing; therefore vl_split_count provides 	   the number of VLs to use for certain traffic 	 */
if|if
condition|(
name|res
operator|>
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|vl_split_count
index|[
name|res
index|]
operator|>
literal|1
condition|)
return|return
call|(
name|uint8_t
call|)
argument_list|(
name|res
operator|+
name|rand
argument_list|()
operator|%
operator|(
name|vl_split_count
index|[
name|res
index|]
operator|)
argument_list|)
return|;
else|else
return|return
operator|(
name|uint8_t
operator|)
name|res
return|;
block|}
else|else
return|return
name|hint_for_default_sl
return|;
block|}
end_function

begin_function
specifier|static
name|dfsssp_context_t
modifier|*
name|dfsssp_context_create
parameter_list|(
name|osm_opensm_t
modifier|*
name|p_osm
parameter_list|,
name|osm_routing_engine_type_t
name|routing_type
parameter_list|)
block|{
name|dfsssp_context_t
modifier|*
name|dfsssp_ctx
init|=
name|NULL
decl_stmt|;
comment|/* allocate memory */
name|dfsssp_ctx
operator|=
operator|(
name|dfsssp_context_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dfsssp_context_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfsssp_ctx
condition|)
block|{
comment|/* set initial values */
name|dfsssp_ctx
operator|->
name|routing_type
operator|=
name|routing_type
expr_stmt|;
name|dfsssp_ctx
operator|->
name|p_mgr
operator|=
operator|(
name|osm_ucast_mgr_t
operator|*
operator|)
operator|&
operator|(
name|p_osm
operator|->
name|sm
operator|.
name|ucast_mgr
operator|)
expr_stmt|;
name|dfsssp_ctx
operator|->
name|adj_list
operator|=
name|NULL
expr_stmt|;
name|dfsssp_ctx
operator|->
name|adj_list_size
operator|=
literal|0
expr_stmt|;
name|dfsssp_ctx
operator|->
name|srcdest2vl_table
operator|=
name|NULL
expr_stmt|;
name|dfsssp_ctx
operator|->
name|vl_split_count
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
name|p_osm
operator|->
name|sm
operator|.
name|ucast_mgr
operator|.
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD04: cannot allocate memory for dfsssp_ctx in dfsssp_context_create\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|dfsssp_ctx
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfsssp_context_destroy
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|dfsssp_context_t
modifier|*
name|dfsssp_ctx
init|=
operator|(
name|dfsssp_context_t
operator|*
operator|)
name|context
decl_stmt|;
name|vertex_t
modifier|*
name|adj_list
init|=
operator|(
name|vertex_t
operator|*
operator|)
operator|(
name|dfsssp_ctx
operator|->
name|adj_list
operator|)
decl_stmt|;
name|uint32_t
name|i
init|=
literal|0
decl_stmt|;
name|link_t
modifier|*
name|link
init|=
name|NULL
decl_stmt|,
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
comment|/* free adj_list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dfsssp_ctx
operator|->
name|adj_list_size
condition|;
name|i
operator|++
control|)
block|{
name|link
operator|=
name|adj_list
index|[
name|i
index|]
operator|.
name|links
expr_stmt|;
while|while
condition|(
name|link
condition|)
block|{
name|tmp
operator|=
name|link
expr_stmt|;
name|link
operator|=
name|link
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|adj_list
argument_list|)
expr_stmt|;
name|dfsssp_ctx
operator|->
name|adj_list
operator|=
name|NULL
expr_stmt|;
name|dfsssp_ctx
operator|->
name|adj_list_size
operator|=
literal|0
expr_stmt|;
comment|/* free srcdest2vl table and the split count information table 	   (can be done, because dfsssp_context_destroy is called after 	    osm_get_dfsssp_sl) 	 */
name|vltable_dealloc
argument_list|(
operator|&
operator|(
name|dfsssp_ctx
operator|->
name|srcdest2vl_table
operator|)
argument_list|)
expr_stmt|;
name|dfsssp_ctx
operator|->
name|srcdest2vl_table
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dfsssp_ctx
operator|->
name|vl_split_count
condition|)
block|{
name|free
argument_list|(
name|dfsssp_ctx
operator|->
name|vl_split_count
argument_list|)
expr_stmt|;
name|dfsssp_ctx
operator|->
name|vl_split_count
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|delete
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
if|if
condition|(
operator|!
name|context
condition|)
return|return;
name|dfsssp_context_destroy
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|osm_ucast_dfsssp_setup
parameter_list|(
name|struct
name|osm_routing_engine
modifier|*
name|r
parameter_list|,
name|osm_opensm_t
modifier|*
name|p_osm
parameter_list|)
block|{
comment|/* create context container and add ucast management object */
name|dfsssp_context_t
modifier|*
name|dfsssp_context
init|=
name|dfsssp_context_create
argument_list|(
name|p_osm
argument_list|,
name|OSM_ROUTING_ENGINE_TYPE_DFSSSP
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dfsssp_context
condition|)
block|{
return|return
literal|1
return|;
comment|/* alloc failed -> skip this routing */
block|}
comment|/* reset function pointers to dfsssp routines */
name|r
operator|->
name|context
operator|=
operator|(
name|void
operator|*
operator|)
name|dfsssp_context
expr_stmt|;
name|r
operator|->
name|build_lid_matrices
operator|=
name|dfsssp_build_graph
expr_stmt|;
name|r
operator|->
name|ucast_build_fwd_tables
operator|=
name|dfsssp_do_dijkstra_routing
expr_stmt|;
name|r
operator|->
name|mcast_build_stree
operator|=
name|dfsssp_do_mcast_routing
expr_stmt|;
name|r
operator|->
name|path_sl
operator|=
name|get_dfsssp_sl
expr_stmt|;
name|r
operator|->
name|destroy
operator|=
name|delete
expr_stmt|;
comment|/* we initialize with the current time to achieve a 'good' randomized 	   assignment in get_dfsssp_sl(...) 	 */
name|srand
argument_list|(
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|osm_ucast_sssp_setup
parameter_list|(
name|struct
name|osm_routing_engine
modifier|*
name|r
parameter_list|,
name|osm_opensm_t
modifier|*
name|p_osm
parameter_list|)
block|{
comment|/* create context container and add ucast management object */
name|dfsssp_context_t
modifier|*
name|dfsssp_context
init|=
name|dfsssp_context_create
argument_list|(
name|p_osm
argument_list|,
name|OSM_ROUTING_ENGINE_TYPE_SSSP
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dfsssp_context
condition|)
block|{
return|return
literal|1
return|;
comment|/* alloc failed -> skip this routing */
block|}
comment|/* reset function pointers to sssp routines */
name|r
operator|->
name|context
operator|=
operator|(
name|void
operator|*
operator|)
name|dfsssp_context
expr_stmt|;
name|r
operator|->
name|build_lid_matrices
operator|=
name|dfsssp_build_graph
expr_stmt|;
name|r
operator|->
name|ucast_build_fwd_tables
operator|=
name|dfsssp_do_dijkstra_routing
expr_stmt|;
name|r
operator|->
name|mcast_build_stree
operator|=
name|dfsssp_do_mcast_routing
expr_stmt|;
name|r
operator|->
name|destroy
operator|=
name|delete
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

