begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2015 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_ucast_mgr_t.  * This file implements the Unicast Manager object.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qmap.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qlist.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_UCAST_MGR_C
end_define

begin_include
include|#
directive|include
file|<opensm/osm_ucast_mgr.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_sm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_node.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_switch.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_msgdef.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_function
name|void
name|osm_ucast_mgr_construct
parameter_list|(
name|IN
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|)
block|{
name|memset
argument_list|(
name|p_mgr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_mgr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_ucast_mgr_destroy
parameter_list|(
name|IN
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|)
block|{
name|CL_ASSERT
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_mgr
operator|->
name|cache_valid
condition|)
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ib_api_status_t
name|osm_ucast_mgr_init
parameter_list|(
name|IN
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|,
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|osm_ucast_mgr_construct
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
name|p_mgr
operator|->
name|sm
operator|=
name|sm
expr_stmt|;
name|p_mgr
operator|->
name|p_log
operator|=
name|sm
operator|->
name|p_log
expr_stmt|;
name|p_mgr
operator|->
name|p_subn
operator|=
name|sm
operator|->
name|p_subn
expr_stmt|;
name|p_mgr
operator|->
name|p_lock
operator|=
name|sm
operator|->
name|p_lock
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|use_ucast_cache
condition|)
name|cl_qmap_init
argument_list|(
operator|&
name|p_mgr
operator|->
name|cache_sw_tbl
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Add each switch's own and neighbor LIDs to its LID matrix **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ucast_mgr_process_hop_0_1
parameter_list|(
name|IN
name|cl_map_item_t
modifier|*
name|p_map_item
parameter_list|,
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
name|osm_switch_t
modifier|*
name|p_sw
init|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|p_map_item
decl_stmt|;
name|osm_node_t
modifier|*
name|p_remote_node
decl_stmt|;
name|uint16_t
name|lid
decl_stmt|,
name|remote_lid
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|lid
operator|=
name|cl_ntoh16
argument_list|(
name|osm_node_get_base_lid
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|osm_switch_set_hops
argument_list|(
name|p_sw
argument_list|,
name|lid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|p_sw
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|osm_physp_t
modifier|*
name|p
init|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|p_remote_node
operator|=
operator|(
name|p
operator|&&
name|p
operator|->
name|p_remote_physp
operator|)
condition|?
name|p
operator|->
name|p_remote_physp
operator|->
name|p_node
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|p_remote_node
operator|&&
name|p_remote_node
operator|->
name|sw
operator|&&
name|p_remote_node
operator|!=
name|p_sw
operator|->
name|p_node
condition|)
block|{
name|remote_lid
operator|=
name|osm_node_get_base_lid
argument_list|(
name|p_remote_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|remote_lid
operator|=
name|cl_ntoh16
argument_list|(
name|remote_lid
argument_list|)
expr_stmt|;
name|osm_switch_set_hops
argument_list|(
name|p_sw
argument_list|,
name|remote_lid
argument_list|,
name|i
argument_list|,
name|p
operator|->
name|hop_wf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ucast_mgr_process_neighbor
parameter_list|(
name|IN
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|,
name|IN
name|osm_switch_t
modifier|*
name|p_this_sw
parameter_list|,
name|IN
name|osm_switch_t
modifier|*
name|p_remote_sw
parameter_list|,
name|IN
name|uint8_t
name|port_num
parameter_list|,
name|IN
name|uint8_t
name|remote_port_num
parameter_list|)
block|{
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|cl_map_item_t
modifier|*
name|item
decl_stmt|;
name|uint16_t
name|lid_ho
decl_stmt|;
name|uint16_t
name|hops
decl_stmt|;
name|osm_physp_t
modifier|*
name|p
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Node 0x%"
name|PRIx64
literal|", remote node 0x%"
name|PRIx64
literal|", port %u, remote port %u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_this_sw
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_remote_sw
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|port_num
argument_list|,
name|remote_port_num
argument_list|)
expr_stmt|;
name|p
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_this_sw
operator|->
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
name|cl_qmap_head
argument_list|(
operator|&
name|p_mgr
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|)
init|;
name|item
operator|!=
name|cl_qmap_end
argument_list|(
operator|&
name|p_mgr
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|)
condition|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
control|)
block|{
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|item
expr_stmt|;
name|lid_ho
operator|=
name|cl_ntoh16
argument_list|(
name|osm_node_get_base_lid
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|hops
operator|=
name|osm_switch_get_least_hops
argument_list|(
name|p_remote_sw
argument_list|,
name|lid_ho
argument_list|)
expr_stmt|;
if|if
condition|(
name|hops
operator|==
name|OSM_NO_PATH
condition|)
continue|continue;
name|hops
operator|+=
name|p
operator|->
name|hop_wf
expr_stmt|;
if|if
condition|(
name|hops
operator|<
name|osm_switch_get_hop_count
argument_list|(
name|p_this_sw
argument_list|,
name|lid_ho
argument_list|,
name|port_num
argument_list|)
condition|)
block|{
if|if
condition|(
name|osm_switch_set_hops
argument_list|(
name|p_this_sw
argument_list|,
name|lid_ho
argument_list|,
name|port_num
argument_list|,
operator|(
name|uint8_t
operator|)
name|hops
argument_list|)
operator|!=
literal|0
condition|)
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3A03: "
literal|"cannot set hops for lid %u at switch 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|lid_ho
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_this_sw
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|p_mgr
operator|->
name|some_hop_count_set
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|osm_remote_node
modifier|*
name|find_and_add_remote_sys
parameter_list|(
name|osm_switch_t
modifier|*
name|sw
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|boolean_t
name|dor
parameter_list|,
name|struct
name|osm_remote_guids_count
modifier|*
name|r
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|osm_physp_t
modifier|*
name|p
init|=
name|osm_node_get_physp_ptr
argument_list|(
name|sw
operator|->
name|p_node
argument_list|,
name|port
argument_list|)
decl_stmt|;
name|osm_node_t
modifier|*
name|node
init|=
name|p
operator|->
name|p_remote_physp
operator|->
name|p_node
decl_stmt|;
name|uint8_t
name|rem_port
init|=
name|osm_physp_get_port_num
argument_list|(
name|p
operator|->
name|p_remote_physp
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r
operator|->
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|r
operator|->
name|guids
index|[
name|i
index|]
operator|.
name|node
operator|==
name|node
condition|)
if|if
condition|(
operator|!
name|dor
operator|||
operator|(
name|r
operator|->
name|guids
index|[
name|i
index|]
operator|.
name|port
operator|==
name|rem_port
operator|)
condition|)
return|return
operator|&
name|r
operator|->
name|guids
index|[
name|i
index|]
return|;
name|r
operator|->
name|guids
index|[
name|i
index|]
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|r
operator|->
name|guids
index|[
name|i
index|]
operator|.
name|forwarded_to
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|guids
index|[
name|i
index|]
operator|.
name|port
operator|=
name|rem_port
expr_stmt|;
name|r
operator|->
name|count
operator|++
expr_stmt|;
return|return
operator|&
name|r
operator|->
name|guids
index|[
name|i
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ucast_mgr_process_port
parameter_list|(
name|IN
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|,
name|IN
name|osm_switch_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|osm_port_t
modifier|*
name|p_port
parameter_list|,
name|IN
name|unsigned
name|lid_offset
parameter_list|)
block|{
name|uint16_t
name|min_lid_ho
decl_stmt|;
name|uint16_t
name|max_lid_ho
decl_stmt|;
name|uint16_t
name|lid_ho
decl_stmt|;
name|uint8_t
name|port
decl_stmt|;
name|boolean_t
name|is_ignored_by_port_prof
decl_stmt|;
name|ib_net64_t
name|node_guid
decl_stmt|;
name|unsigned
name|start_from
init|=
literal|1
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|osm_port_get_lid_range_ho
argument_list|(
name|p_port
argument_list|,
operator|&
name|min_lid_ho
argument_list|,
operator|&
name|max_lid_ho
argument_list|)
expr_stmt|;
comment|/* If the lids are zero - then there was some problem with 	 * the initialization. Don't handle this port. */
if|if
condition|(
name|min_lid_ho
operator|==
literal|0
operator|||
name|max_lid_ho
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3A04: "
literal|"Port 0x%"
name|PRIx64
literal|" (%s port %d) has LID 0. An "
literal|"initialization error occurred. Ignoring port\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_port_get_guid
argument_list|(
name|p_port
argument_list|)
argument_list|)
argument_list|,
name|p_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|lid_ho
operator|=
name|min_lid_ho
operator|+
name|lid_offset
expr_stmt|;
if|if
condition|(
name|lid_ho
operator|>
name|max_lid_ho
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|lid_offset
operator|&&
operator|!
name|p_mgr
operator|->
name|is_dor
condition|)
comment|/* ignore potential overflow - it is handled in osm_switch.c */
name|start_from
operator|=
name|osm_switch_get_port_by_lid
argument_list|(
name|p_sw
argument_list|,
name|lid_ho
operator|-
literal|1
argument_list|,
name|OSM_NEW_LFT
argument_list|)
operator|+
literal|1
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Processing port 0x%"
name|PRIx64
literal|" (\'%s\' port %u), LID %u [%u,%u]\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_port_get_guid
argument_list|(
name|p_port
argument_list|)
argument_list|)
argument_list|,
name|p_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|,
name|lid_ho
argument_list|,
name|min_lid_ho
argument_list|,
name|max_lid_ho
argument_list|)
expr_stmt|;
comment|/* TODO - This should be runtime error, not a CL_ASSERT() */
name|CL_ASSERT
argument_list|(
name|max_lid_ho
operator|<=
name|IB_LID_UCAST_END_HO
argument_list|)
expr_stmt|;
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|)
expr_stmt|;
comment|/* 	   The lid matrix contains the number of hops to each 	   lid from each port.  From this information we determine 	   how best to distribute the LID range across the ports 	   that can reach those LIDs. 	 */
name|port
operator|=
name|osm_switch_recommend_path
argument_list|(
name|p_sw
argument_list|,
name|p_port
argument_list|,
name|lid_ho
argument_list|,
name|start_from
argument_list|,
name|p_mgr
operator|->
name|p_subn
operator|->
name|ignore_existing_lfts
argument_list|,
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|lmc
argument_list|,
name|p_mgr
operator|->
name|is_dor
argument_list|,
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|port_shifting
argument_list|,
operator|!
name|lid_offset
operator|&&
name|p_port
operator|->
name|use_scatter
argument_list|,
name|OSM_LFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|==
name|OSM_NO_PATH
condition|)
block|{
comment|/* do not try to overwrite the ppro of non existing port ... */
name|is_ignored_by_port_prof
operator|=
name|TRUE
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"No path to get to LID %u from switch 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|lid_ho
argument_list|,
name|cl_ntoh64
argument_list|(
name|node_guid
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|osm_physp_t
modifier|*
name|p
init|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|,
name|port
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
goto|goto
name|Exit
goto|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Routing LID %u to port %u for switch 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|lid_ho
argument_list|,
name|port
argument_list|,
name|cl_ntoh64
argument_list|(
name|node_guid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		   we would like to optionally ignore this port in equalization 		   as in the case of the Mellanox Anafa Internal PCI TCA port 		 */
name|is_ignored_by_port_prof
operator|=
name|p
operator|->
name|is_prof_ignored
expr_stmt|;
comment|/* 		   We also would ignore this route if the target lid is of 		   a switch and the port_profile_switch_node is not TRUE 		 */
if|if
condition|(
operator|!
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|port_profile_switch_nodes
condition|)
name|is_ignored_by_port_prof
operator||=
operator|(
name|osm_node_get_type
argument_list|(
name|p_port
operator|->
name|p_node
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
operator|)
expr_stmt|;
block|}
comment|/* 	   We have selected the port for this LID. 	   Write it to the forwarding tables. 	 */
name|p_sw
operator|->
name|new_lft
index|[
name|lid_ho
index|]
operator|=
name|port
expr_stmt|;
if|if
condition|(
operator|!
name|is_ignored_by_port_prof
condition|)
block|{
name|struct
name|osm_remote_node
modifier|*
name|rem_node_used
decl_stmt|;
name|osm_switch_count_path
argument_list|(
name|p_sw
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|>
literal|0
operator|&&
name|p_port
operator|->
name|priv
operator|&&
operator|(
name|rem_node_used
operator|=
name|find_and_add_remote_sys
argument_list|(
name|p_sw
argument_list|,
name|port
argument_list|,
name|p_mgr
operator|->
name|is_dor
argument_list|,
name|p_port
operator|->
name|priv
argument_list|)
operator|)
condition|)
name|rem_node_used
operator|->
name|forwarded_to
operator|++
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|alloc_ports_priv
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|mgr
parameter_list|)
block|{
name|cl_qmap_t
modifier|*
name|port_tbl
init|=
operator|&
name|mgr
operator|->
name|p_subn
operator|->
name|port_guid_tbl
decl_stmt|;
name|struct
name|osm_remote_guids_count
modifier|*
name|r
decl_stmt|;
name|osm_port_t
modifier|*
name|port
decl_stmt|;
name|cl_map_item_t
modifier|*
name|item
decl_stmt|;
name|unsigned
name|lmc
decl_stmt|;
for|for
control|(
name|item
operator|=
name|cl_qmap_head
argument_list|(
name|port_tbl
argument_list|)
init|;
name|item
operator|!=
name|cl_qmap_end
argument_list|(
name|port_tbl
argument_list|)
condition|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
control|)
block|{
name|port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|item
expr_stmt|;
name|lmc
operator|=
name|ib_port_info_get_lmc
argument_list|(
operator|&
name|port
operator|->
name|p_physp
operator|->
name|port_info
argument_list|)
expr_stmt|;
name|r
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|r
operator|->
name|guids
index|[
literal|0
index|]
argument_list|)
operator|*
operator|(
literal|1
operator|<<
name|lmc
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|OSM_LOG
argument_list|(
name|mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3A09: "
literal|"cannot allocate memory to track remote"
literal|" systems for lmc> 0\n"
argument_list|)
expr_stmt|;
name|port
operator|->
name|priv
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
name|memset
argument_list|(
name|r
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|r
operator|->
name|guids
index|[
literal|0
index|]
argument_list|)
operator|*
operator|(
literal|1
operator|<<
name|lmc
operator|)
argument_list|)
expr_stmt|;
name|port
operator|->
name|priv
operator|=
name|r
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|free_ports_priv
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|mgr
parameter_list|)
block|{
name|cl_qmap_t
modifier|*
name|port_tbl
init|=
operator|&
name|mgr
operator|->
name|p_subn
operator|->
name|port_guid_tbl
decl_stmt|;
name|osm_port_t
modifier|*
name|port
decl_stmt|;
name|cl_map_item_t
modifier|*
name|item
decl_stmt|;
for|for
control|(
name|item
operator|=
name|cl_qmap_head
argument_list|(
name|port_tbl
argument_list|)
init|;
name|item
operator|!=
name|cl_qmap_end
argument_list|(
name|port_tbl
argument_list|)
condition|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
control|)
block|{
name|port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|item
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|priv
condition|)
block|{
name|free
argument_list|(
name|port
operator|->
name|priv
argument_list|)
expr_stmt|;
name|port
operator|->
name|priv
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ucast_mgr_process_tbl
parameter_list|(
name|IN
name|cl_map_item_t
modifier|*
name|p_map_item
parameter_list|,
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
init|=
name|context
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_sw
init|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|p_map_item
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|lids_per_port
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_sw
operator|&&
name|p_sw
operator|->
name|p_node
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Processing switch 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize LIDs in buffer to invalid port number. */
name|memset
argument_list|(
name|p_sw
operator|->
name|new_lft
argument_list|,
name|OSM_NO_PATH
argument_list|,
name|p_sw
operator|->
name|max_lid_ho
operator|+
literal|1
argument_list|)
expr_stmt|;
name|alloc_ports_priv
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
comment|/* 	   Iterate through every port setting LID routes for each 	   port based on base LID and LMC value. 	 */
name|lids_per_port
operator|=
literal|1
operator|<<
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|lmc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lids_per_port
condition|;
name|i
operator|++
control|)
block|{
name|cl_qlist_t
modifier|*
name|list
init|=
operator|&
name|p_mgr
operator|->
name|port_order_list
decl_stmt|;
name|cl_list_item_t
modifier|*
name|item
decl_stmt|;
for|for
control|(
name|item
operator|=
name|cl_qlist_head
argument_list|(
name|list
argument_list|)
init|;
name|item
operator|!=
name|cl_qlist_end
argument_list|(
name|list
argument_list|)
condition|;
name|item
operator|=
name|cl_qlist_next
argument_list|(
name|item
argument_list|)
control|)
block|{
name|osm_port_t
modifier|*
name|port
init|=
name|cl_item_obj
argument_list|(
name|item
argument_list|,
name|port
argument_list|,
name|list_item
argument_list|)
decl_stmt|;
name|ucast_mgr_process_port
argument_list|(
name|p_mgr
argument_list|,
name|p_sw
argument_list|,
name|port
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|free_ports_priv
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ucast_mgr_process_neighbors
parameter_list|(
name|IN
name|cl_map_item_t
modifier|*
name|p_map_item
parameter_list|,
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
name|osm_switch_t
modifier|*
name|p_sw
init|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|p_map_item
decl_stmt|;
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
init|=
name|context
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|osm_node_t
modifier|*
name|p_remote_node
decl_stmt|;
name|uint32_t
name|port_num
decl_stmt|;
name|uint8_t
name|remote_port_num
decl_stmt|;
name|uint32_t
name|num_ports
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_node
operator|=
name|p_sw
operator|->
name|p_node
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|osm_node_get_type
argument_list|(
name|p_node
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Processing switch with GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|num_ports
operator|=
name|osm_node_get_num_physp
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
comment|/* 	   Start with port 1 to skip the switch's management port. 	 */
for|for
control|(
name|port_num
operator|=
literal|1
init|;
name|port_num
operator|<
name|num_ports
condition|;
name|port_num
operator|++
control|)
block|{
name|p_remote_node
operator|=
name|osm_node_get_remote_node
argument_list|(
name|p_node
argument_list|,
operator|(
name|uint8_t
operator|)
name|port_num
argument_list|,
operator|&
name|remote_port_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_remote_node
operator|&&
name|p_remote_node
operator|->
name|sw
operator|&&
operator|(
name|p_remote_node
operator|!=
name|p_node
operator|)
condition|)
block|{
comment|/* make sure the link is healthy. If it is not - don't 			   propagate through it. */
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
operator|||
operator|!
name|osm_link_is_healthy
argument_list|(
name|p_physp
argument_list|)
condition|)
continue|continue;
name|ucast_mgr_process_neighbor
argument_list|(
name|p_mgr
argument_list|,
name|p_sw
argument_list|,
name|p_remote_node
operator|->
name|sw
argument_list|,
operator|(
name|uint8_t
operator|)
name|port_num
argument_list|,
name|remote_port_num
argument_list|)
expr_stmt|;
block|}
block|}
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_hop_wf
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
name|osm_ucast_mgr_t
modifier|*
name|m
init|=
name|ctx
decl_stmt|;
name|osm_node_t
modifier|*
name|node
init|=
name|osm_get_node_by_guid
argument_list|(
name|m
operator|->
name|p_subn
argument_list|,
name|cl_hton64
argument_list|(
name|guid
argument_list|)
argument_list|)
decl_stmt|;
name|osm_physp_t
modifier|*
name|physp
decl_stmt|;
name|unsigned
name|port
decl_stmt|,
name|hop_wf
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|||
operator|!
name|node
operator|->
name|sw
condition|)
block|{
name|OSM_LOG
argument_list|(
name|m
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"switch with guid 0x%016"
name|PRIx64
literal|" is not found\n"
argument_list|,
name|guid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|p
operator|||
operator|!
operator|*
name|p
operator|||
operator|!
operator|(
name|port
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|e
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
operator|(
name|p
operator|==
name|e
operator|)
operator|||
name|port
operator|>=
name|node
operator|->
name|sw
operator|->
name|num_ports
condition|)
block|{
name|OSM_LOG
argument_list|(
name|m
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"bad port specified for guid 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|guid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|p
operator|=
name|e
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
operator|||
operator|!
operator|(
name|hop_wf
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|e
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
name|p
operator|==
name|e
operator|||
name|hop_wf
operator|>=
literal|0x100
condition|)
block|{
name|OSM_LOG
argument_list|(
name|m
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"bad hop weight factor specified for guid 0x%016"
name|PRIx64
literal|"port %u\n"
argument_list|,
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|node
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|physp
condition|)
return|return
literal|0
return|;
name|physp
operator|->
name|hop_wf
operator|=
name|hop_wf
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_default_hop_wf
parameter_list|(
name|cl_map_item_t
modifier|*
name|p_map_item
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|osm_switch_t
modifier|*
name|sw
init|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|p_map_item
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sw
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|osm_physp_t
modifier|*
name|p
init|=
name|osm_node_get_physp_ptr
argument_list|(
name|sw
operator|->
name|p_node
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
name|p
operator|->
name|hop_wf
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|set_search_ordering_ports
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
name|osm_subn_t
modifier|*
name|p_subn
init|=
name|ctx
decl_stmt|;
name|osm_node_t
modifier|*
name|node
init|=
name|osm_get_node_by_guid
argument_list|(
name|p_subn
argument_list|,
name|cl_hton64
argument_list|(
name|guid
argument_list|)
argument_list|)
decl_stmt|;
name|osm_switch_t
modifier|*
name|sw
decl_stmt|;
name|uint8_t
modifier|*
name|search_ordering_ports
init|=
name|NULL
decl_stmt|;
name|uint8_t
name|port
decl_stmt|;
name|unsigned
name|int
modifier|*
name|ports
init|=
name|NULL
decl_stmt|;
specifier|const
name|int
name|bpw
init|=
sizeof|sizeof
argument_list|(
operator|*
name|ports
argument_list|)
operator|*
literal|8
decl_stmt|;
name|int
name|words
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
comment|/* port 0 maps to port 0 */
if|if
condition|(
operator|!
name|node
operator|||
operator|!
operator|(
name|sw
operator|=
name|node
operator|->
name|sw
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_subn
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"switch with guid 0x%016"
name|PRIx64
literal|" is not found\n"
argument_list|,
name|guid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|sw
operator|->
name|search_ordering_ports
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_subn
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"switch with guid 0x%016"
name|PRIx64
literal|" already listed\n"
argument_list|,
name|guid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|search_ordering_ports
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|search_ordering_ports
argument_list|)
operator|*
name|sw
operator|->
name|num_ports
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|search_ordering_ports
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_subn
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3A07: cannot allocate memory for search_ordering_ports\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|memset
argument_list|(
name|search_ordering_ports
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|search_ordering_ports
argument_list|)
operator|*
name|sw
operator|->
name|num_ports
argument_list|)
expr_stmt|;
comment|/* the ports array is for record keeping of which ports have 	 * been seen */
name|words
operator|=
operator|(
name|sw
operator|->
name|num_ports
operator|+
name|bpw
operator|-
literal|1
operator|)
operator|/
name|bpw
expr_stmt|;
name|ports
operator|=
name|malloc
argument_list|(
name|words
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ports
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ports
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_subn
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3A08: cannot allocate memory for ports\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|search_ordering_ports
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|memset
argument_list|(
name|ports
argument_list|,
literal|0
argument_list|,
name|words
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ports
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|p
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'#'
operator|)
condition|)
block|{
name|char
modifier|*
name|e
decl_stmt|;
name|port
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|==
name|e
operator|)
operator|||
operator|(
name|port
operator|==
literal|0
operator|)
operator|||
operator|(
name|port
operator|>=
name|sw
operator|->
name|num_ports
operator|)
operator|||
operator|!
name|osm_node_get_physp_ptr
argument_list|(
name|node
argument_list|,
name|port
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_subn
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"bad port %d specified for guid 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|port
argument_list|,
name|guid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|search_ordering_ports
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ports
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ports
index|[
name|port
operator|/
name|bpw
index|]
operator|&
operator|(
literal|1u
operator|<<
operator|(
name|port
operator|%
name|bpw
operator|)
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_subn
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"port %d already specified for guid 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|port
argument_list|,
name|guid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|search_ordering_ports
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ports
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ports
index|[
name|port
operator|/
name|bpw
index|]
operator||=
operator|(
literal|1u
operator|<<
operator|(
name|port
operator|%
name|bpw
operator|)
operator|)
expr_stmt|;
name|search_ordering_ports
index|[
name|i
operator|++
index|]
operator|=
name|port
expr_stmt|;
name|p
operator|=
name|e
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<
name|sw
operator|->
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
comment|/* fill out the rest of the search_ordering_ports array 			 * in sequence using the remaining unspecified 			 * ports. 			 */
if|if
condition|(
operator|!
operator|(
name|ports
index|[
name|port
operator|/
name|bpw
index|]
operator|&
operator|(
literal|1u
operator|<<
operator|(
name|port
operator|%
name|bpw
operator|)
operator|)
operator|)
condition|)
block|{
name|search_ordering_ports
index|[
name|i
operator|++
index|]
operator|=
name|port
expr_stmt|;
block|}
block|}
name|sw
operator|->
name|search_ordering_ports
operator|=
name|search_ordering_ports
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|search_ordering_ports
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ports
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|osm_ucast_mgr_build_lid_matrices
parameter_list|(
name|IN
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|iteration_max
decl_stmt|;
name|cl_qmap_t
modifier|*
name|p_sw_guid_tbl
decl_stmt|;
name|p_sw_guid_tbl
operator|=
operator|&
name|p_mgr
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Starting switches' Min Hop Table Assignment\n"
argument_list|)
expr_stmt|;
comment|/* 	   Set up the weighting factors for the routing. 	 */
name|cl_qmap_apply_func
argument_list|(
name|p_sw_guid_tbl
argument_list|,
name|set_default_hop_wf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|hop_weights_file
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Fetching hop weight factor file \'%s\'\n"
argument_list|,
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|hop_weights_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_node_map
argument_list|(
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|hop_weights_file
argument_list|,
name|set_hop_wf
argument_list|,
name|p_mgr
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3A05: "
literal|"cannot parse hop_weights_file \'%s\'\n"
argument_list|,
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|hop_weights_file
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	   Set the switch matrices for each switch's own port 0 LID(s) 	   then set the lid matrices for the each switch's leaf nodes. 	 */
name|cl_qmap_apply_func
argument_list|(
name|p_sw_guid_tbl
argument_list|,
name|ucast_mgr_process_hop_0_1
argument_list|,
name|p_mgr
argument_list|)
expr_stmt|;
comment|/* 	   Get the switch matrices for each switch's neighbors. 	   This process requires a number of iterations equal to 	   the number of switches in the subnet minus 1.  	   In each iteration, a switch learns the lid/port/hop 	   information (as contained by a switch's lid matrix) from 	   its immediate neighbors.  After each iteration, a switch 	   (and it's neighbors) know more routing information than 	   it did on the previous iteration. 	   Thus, by repeatedly absorbing the routing information of 	   neighbor switches, every switch eventually learns how to 	   route all LIDs on the subnet.  	   Note that there may not be any switches in the subnet if 	   we are in simple p2p configuration. 	 */
name|iteration_max
operator|=
name|cl_qmap_count
argument_list|(
name|p_sw_guid_tbl
argument_list|)
expr_stmt|;
comment|/* 	   If there are switches in the subnet, iterate until the lid 	   matrix has been constructed.  Otherwise, just immediately 	   indicate we're done if no switches exist. 	 */
if|if
condition|(
name|iteration_max
condition|)
block|{
name|iteration_max
operator|--
expr_stmt|;
comment|/* 		   we need to find out when the propagation of 		   hop counts has relaxed. So this global variable 		   is preset to 0 on each iteration and if 		   if non of the switches was set will exit the 		   while loop 		 */
name|p_mgr
operator|->
name|some_hop_count_set
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|iteration_max
operator|)
operator|&&
name|p_mgr
operator|->
name|some_hop_count_set
condition|;
name|i
operator|++
control|)
block|{
name|p_mgr
operator|->
name|some_hop_count_set
operator|=
name|FALSE
expr_stmt|;
name|cl_qmap_apply_func
argument_list|(
name|p_sw_guid_tbl
argument_list|,
name|ucast_mgr_process_neighbors
argument_list|,
name|p_mgr
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Min-hop propagated in %d steps\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ucast_mgr_setup_all_switches
parameter_list|(
name|osm_subn_t
modifier|*
name|p_subn
parameter_list|)
block|{
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|uint16_t
name|lids
decl_stmt|;
name|lids
operator|=
operator|(
name|uint16_t
operator|)
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_subn
operator|->
name|port_lid_tbl
argument_list|)
expr_stmt|;
name|lids
operator|=
name|lids
condition|?
name|lids
operator|-
literal|1
else|:
literal|0
expr_stmt|;
for|for
control|(
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|)
init|;
name|p_sw
operator|!=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|)
condition|;
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
control|)
block|{
if|if
condition|(
name|osm_switch_prepare_path_rebuild
argument_list|(
name|p_sw
argument_list|,
name|lids
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_subn
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3A0B: "
literal|"cannot setup switch 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|p_sw
operator|->
name|search_ordering_ports
condition|)
block|{
name|free
argument_list|(
name|p_sw
operator|->
name|search_ordering_ports
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|search_ordering_ports
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_subn
operator|->
name|opt
operator|.
name|port_search_ordering_file
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_subn
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Fetching dimension ports file \'%s\'\n"
argument_list|,
name|p_subn
operator|->
name|opt
operator|.
name|port_search_ordering_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_node_map
argument_list|(
name|p_subn
operator|->
name|opt
operator|.
name|port_search_ordering_file
argument_list|,
name|set_search_ordering_ports
argument_list|,
name|p_subn
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_subn
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3A0F: "
literal|"cannot parse port_search_ordering_file \'%s\'\n"
argument_list|,
name|p_subn
operator|->
name|opt
operator|.
name|port_search_ordering_file
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_guid_to_order_list
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
name|osm_ucast_mgr_t
modifier|*
name|m
init|=
name|ctx
decl_stmt|;
name|osm_port_t
modifier|*
name|port
init|=
name|osm_get_port_by_guid
argument_list|(
name|m
operator|->
name|p_subn
argument_list|,
name|cl_hton64
argument_list|(
name|guid
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|port
condition|)
block|{
name|OSM_LOG
argument_list|(
name|m
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"port guid not found: 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|guid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|port
operator|->
name|flag
condition|)
block|{
name|OSM_LOG
argument_list|(
name|m
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"port guid specified multiple times 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|guid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cl_qlist_insert_tail
argument_list|(
operator|&
name|m
operator|->
name|port_order_list
argument_list|,
operator|&
name|port
operator|->
name|list_item
argument_list|)
expr_stmt|;
name|port
operator|->
name|flag
operator|=
literal|1
expr_stmt|;
name|port
operator|->
name|use_scatter
operator|=
operator|(
name|m
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|guid_routing_order_no_scatter
operator|==
name|TRUE
operator|)
condition|?
literal|0
else|:
name|m
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|scatter_ports
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_port_to_order_list
parameter_list|(
name|cl_map_item_t
modifier|*
name|p_map_item
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|osm_port_t
modifier|*
name|port
init|=
operator|(
name|osm_port_t
operator|*
operator|)
name|p_map_item
decl_stmt|;
name|osm_ucast_mgr_t
modifier|*
name|m
init|=
name|ctx
decl_stmt|;
if|if
condition|(
operator|!
name|port
operator|->
name|flag
condition|)
block|{
name|port
operator|->
name|use_scatter
operator|=
name|m
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|scatter_ports
expr_stmt|;
name|cl_qlist_insert_tail
argument_list|(
operator|&
name|m
operator|->
name|port_order_list
argument_list|,
operator|&
name|port
operator|->
name|list_item
argument_list|)
expr_stmt|;
block|}
else|else
name|port
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mark_ignored_port
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
name|osm_ucast_mgr_t
modifier|*
name|m
init|=
name|ctx
decl_stmt|;
name|osm_node_t
modifier|*
name|node
init|=
name|osm_get_node_by_guid
argument_list|(
name|m
operator|->
name|p_subn
argument_list|,
name|cl_hton64
argument_list|(
name|guid
argument_list|)
argument_list|)
decl_stmt|;
name|osm_physp_t
modifier|*
name|physp
decl_stmt|;
name|unsigned
name|port
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|||
operator|!
name|node
operator|->
name|sw
condition|)
block|{
name|OSM_LOG
argument_list|(
name|m
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"switch with guid 0x%016"
name|PRIx64
literal|" is not found\n"
argument_list|,
name|guid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|p
operator|||
operator|!
operator|*
name|p
operator|||
operator|!
operator|(
name|port
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
name|port
operator|>=
name|node
operator|->
name|sw
operator|->
name|num_ports
condition|)
block|{
name|OSM_LOG
argument_list|(
name|m
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"bad port specified for guid 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|guid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|node
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|physp
condition|)
return|return
literal|0
return|;
name|physp
operator|->
name|is_prof_ignored
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_prof_ignore_flag
parameter_list|(
name|cl_map_item_t
modifier|*
name|p_map_item
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|osm_switch_t
modifier|*
name|sw
init|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|p_map_item
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sw
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|osm_physp_t
modifier|*
name|p
init|=
name|osm_node_get_physp_ptr
argument_list|(
name|sw
operator|->
name|p_node
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
name|p
operator|->
name|is_prof_ignored
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|add_sw_endports_to_order_list
parameter_list|(
name|osm_switch_t
modifier|*
name|sw
parameter_list|,
name|osm_ucast_mgr_t
modifier|*
name|m
parameter_list|)
block|{
name|osm_port_t
modifier|*
name|port
decl_stmt|;
name|osm_physp_t
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sw
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|sw
operator|->
name|p_node
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|p_remote_physp
operator|&&
operator|!
name|p
operator|->
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
condition|)
block|{
name|port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|m
operator|->
name|p_subn
argument_list|,
name|p
operator|->
name|p_remote_physp
operator|->
name|port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port
operator|||
name|port
operator|->
name|flag
condition|)
continue|continue;
name|cl_qlist_insert_tail
argument_list|(
operator|&
name|m
operator|->
name|port_order_list
argument_list|,
operator|&
name|port
operator|->
name|list_item
argument_list|)
expr_stmt|;
name|port
operator|->
name|flag
operator|=
literal|1
expr_stmt|;
name|port
operator|->
name|use_scatter
operator|=
name|m
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|scatter_ports
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sw_count_endport_links
parameter_list|(
name|osm_switch_t
modifier|*
name|sw
parameter_list|)
block|{
name|osm_physp_t
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sw
operator|->
name|endport_links
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sw
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|sw
operator|->
name|p_node
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|p_remote_physp
operator|&&
operator|!
name|p
operator|->
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
condition|)
name|sw
operator|->
name|endport_links
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|compar_sw_load
parameter_list|(
specifier|const
name|void
modifier|*
name|s1
parameter_list|,
specifier|const
name|void
modifier|*
name|s2
parameter_list|)
block|{
define|#
directive|define
name|get_sw_endport_links
parameter_list|(
name|s
parameter_list|)
value|(*(osm_switch_t **)s)->endport_links
return|return
name|get_sw_endport_links
argument_list|(
name|s2
argument_list|)
operator|-
name|get_sw_endport_links
argument_list|(
name|s1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sort_ports_by_switch_load
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|m
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|num
init|=
name|cl_qmap_count
argument_list|(
operator|&
name|m
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|)
decl_stmt|;
name|void
modifier|*
modifier|*
name|s
init|=
name|malloc
argument_list|(
name|num
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|OSM_LOG
argument_list|(
name|m
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3A0C: "
literal|"No memory, skip by switch load sorting.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
index|[
literal|0
index|]
operator|=
name|cl_qmap_head
argument_list|(
operator|&
name|m
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|s
index|[
name|i
index|]
operator|=
name|cl_qmap_next
argument_list|(
name|s
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|sw_count_endport_links
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|s
argument_list|,
name|num
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|,
name|compar_sw_load
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|add_sw_endports_to_order_list
argument_list|(
name|s
index|[
name|i
index|]
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ucast_mgr_build_lfts
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|)
block|{
name|cl_qlist_init
argument_list|(
operator|&
name|p_mgr
operator|->
name|port_order_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|guid_routing_order_file
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Fetching guid routing order file \'%s\'\n"
argument_list|,
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|guid_routing_order_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_node_map
argument_list|(
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|guid_routing_order_file
argument_list|,
name|add_guid_to_order_list
argument_list|,
name|p_mgr
argument_list|)
condition|)
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3A0D: "
literal|"cannot parse guid routing order file \'%s\'\n"
argument_list|,
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|guid_routing_order_file
argument_list|)
expr_stmt|;
block|}
name|sort_ports_by_switch_load
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|port_prof_ignore_file
condition|)
block|{
name|cl_qmap_apply_func
argument_list|(
operator|&
name|p_mgr
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|,
name|clear_prof_ignore_flag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_node_map
argument_list|(
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|port_prof_ignore_file
argument_list|,
name|mark_ignored_port
argument_list|,
name|p_mgr
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3A0E: "
literal|"cannot parse port prof ignore file \'%s\'\n"
argument_list|,
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|port_prof_ignore_file
argument_list|)
expr_stmt|;
block|}
block|}
name|cl_qmap_apply_func
argument_list|(
operator|&
name|p_mgr
operator|->
name|p_subn
operator|->
name|port_guid_tbl
argument_list|,
name|add_port_to_order_list
argument_list|,
name|p_mgr
argument_list|)
expr_stmt|;
name|cl_qmap_apply_func
argument_list|(
operator|&
name|p_mgr
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|,
name|ucast_mgr_process_tbl
argument_list|,
name|p_mgr
argument_list|)
expr_stmt|;
name|cl_qlist_remove_all
argument_list|(
operator|&
name|p_mgr
operator|->
name|port_order_list
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ucast_mgr_set_fwd_top
parameter_list|(
name|IN
name|cl_map_item_t
modifier|*
name|p_map_item
parameter_list|,
name|IN
name|void
modifier|*
name|cxt
parameter_list|)
block|{
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
init|=
name|cxt
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_sw
init|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|p_map_item
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|osm_dr_path_t
modifier|*
name|p_path
decl_stmt|;
name|osm_madw_context_t
name|context
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|ib_switch_info_t
name|si
decl_stmt|;
name|boolean_t
name|set_swinfo_require
init|=
name|FALSE
decl_stmt|;
name|uint16_t
name|lin_top
decl_stmt|;
name|uint8_t
name|life_state
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_sw
operator|&&
name|p_sw
operator|->
name|max_lid_ho
argument_list|)
expr_stmt|;
name|p_node
operator|=
name|p_sw
operator|->
name|p_node
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_mgr
operator|->
name|max_lid
operator|<
name|p_sw
operator|->
name|max_lid_ho
condition|)
name|p_mgr
operator|->
name|max_lid
operator|=
name|p_sw
operator|->
name|max_lid_ho
expr_stmt|;
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|p_path
operator|=
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
comment|/* 	   Set the top of the unicast forwarding table. 	 */
name|si
operator|=
name|p_sw
operator|->
name|switch_info
expr_stmt|;
name|lin_top
operator|=
name|cl_hton16
argument_list|(
name|p_sw
operator|->
name|max_lid_ho
argument_list|)
expr_stmt|;
if|if
condition|(
name|lin_top
operator|!=
name|si
operator|.
name|lin_top
condition|)
block|{
name|set_swinfo_require
operator|=
name|TRUE
expr_stmt|;
name|si
operator|.
name|lin_top
operator|=
name|lin_top
expr_stmt|;
name|context
operator|.
name|si_context
operator|.
name|lft_top_change
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|context
operator|.
name|si_context
operator|.
name|lft_top_change
operator|=
name|FALSE
expr_stmt|;
name|life_state
operator|=
name|si
operator|.
name|life_state
expr_stmt|;
name|ib_switch_info_set_life_time
argument_list|(
operator|&
name|si
argument_list|,
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|packet_life_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|life_state
operator|!=
name|si
operator|.
name|life_state
condition|)
name|set_swinfo_require
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|set_swinfo_require
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Setting switch FT top to LID %u\n"
argument_list|,
name|p_sw
operator|->
name|max_lid_ho
argument_list|)
expr_stmt|;
name|context
operator|.
name|si_context
operator|.
name|light_sweep
operator|=
name|FALSE
expr_stmt|;
name|context
operator|.
name|si_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|context
operator|.
name|si_context
operator|.
name|set_method
operator|=
name|TRUE
expr_stmt|;
name|status
operator|=
name|osm_req_set
argument_list|(
name|p_mgr
operator|->
name|sm
argument_list|,
name|p_path
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|si
argument_list|,
sizeof|sizeof
argument_list|(
name|si
argument_list|)
argument_list|,
name|IB_MAD_ATTR_SWITCH_INFO
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|ib_port_info_get_m_key
argument_list|(
operator|&
name|p_physp
operator|->
name|port_info
argument_list|)
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3A06: "
literal|"Sending SwitchInfo attribute failed (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_lft_block
parameter_list|(
name|IN
name|osm_switch_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|,
name|IN
name|uint16_t
name|block_id_ho
parameter_list|)
block|{
name|osm_madw_context_t
name|context
decl_stmt|;
name|osm_dr_path_t
modifier|*
name|p_path
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
comment|/* 	   Send linear forwarding table blocks to the switch 	   as long as the switch indicates it has blocks needing 	   configuration. 	 */
if|if
condition|(
operator|!
name|p_sw
operator|->
name|new_lft
condition|)
block|{
comment|/* any routing should provide the new_lft */
name|CL_ASSERT
argument_list|(
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|use_ucast_cache
operator|&&
name|p_mgr
operator|->
name|cache_valid
operator|&&
operator|!
name|p_sw
operator|->
name|need_update
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
condition|)
return|return
operator|-
literal|1
return|;
name|p_path
operator|=
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|context
operator|.
name|lft_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|)
expr_stmt|;
name|context
operator|.
name|lft_context
operator|.
name|set_method
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|p_sw
operator|->
name|need_update
operator|&&
operator|!
name|p_mgr
operator|->
name|p_subn
operator|->
name|need_update
operator|&&
operator|!
name|memcmp
argument_list|(
name|p_sw
operator|->
name|new_lft
operator|+
name|block_id_ho
operator|*
name|IB_SMP_DATA_SIZE
argument_list|,
name|p_sw
operator|->
name|lft
operator|+
name|block_id_ho
operator|*
name|IB_SMP_DATA_SIZE
argument_list|,
name|IB_SMP_DATA_SIZE
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* 	 * Zero the stored LFT block, so in case the MAD will end up 	 * with error, we will resend it in the next sweep. 	 */
name|memset
argument_list|(
name|p_sw
operator|->
name|lft
operator|+
name|block_id_ho
operator|*
name|IB_SMP_DATA_SIZE
argument_list|,
literal|0
argument_list|,
name|IB_SMP_DATA_SIZE
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Writing FT block %u to switch 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|block_id_ho
argument_list|,
name|cl_ntoh64
argument_list|(
name|context
operator|.
name|lft_context
operator|.
name|node_guid
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_req_set
argument_list|(
name|p_mgr
operator|->
name|sm
argument_list|,
name|p_path
argument_list|,
name|p_sw
operator|->
name|new_lft
operator|+
name|block_id_ho
operator|*
name|IB_SMP_DATA_SIZE
argument_list|,
name|IB_SMP_DATA_SIZE
argument_list|,
name|IB_MAD_ATTR_LIN_FWD_TBL
argument_list|,
name|cl_hton32
argument_list|(
name|block_id_ho
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|ib_port_info_get_m_key
argument_list|(
operator|&
name|p_physp
operator|->
name|port_info
argument_list|)
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3A10: "
literal|"Sending linear fwd. tbl. block failed (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ucast_mgr_pipeline_fwd_tbl
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|)
block|{
name|cl_qmap_t
modifier|*
name|tbl
decl_stmt|;
name|cl_map_item_t
modifier|*
name|item
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|max_block
init|=
name|p_mgr
operator|->
name|max_lid
operator|/
name|IB_SMP_DATA_SIZE
operator|+
literal|1
decl_stmt|;
name|tbl
operator|=
operator|&
name|p_mgr
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_block
condition|;
name|i
operator|++
control|)
for|for
control|(
name|item
operator|=
name|cl_qmap_head
argument_list|(
name|tbl
argument_list|)
init|;
name|item
operator|!=
name|cl_qmap_end
argument_list|(
name|tbl
argument_list|)
condition|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
control|)
name|set_lft_block
argument_list|(
operator|(
name|osm_switch_t
operator|*
operator|)
name|item
argument_list|,
name|p_mgr
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_ucast_mgr_set_fwd_tables
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|)
block|{
name|p_mgr
operator|->
name|max_lid
operator|=
literal|0
expr_stmt|;
name|cl_qmap_apply_func
argument_list|(
operator|&
name|p_mgr
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|,
name|ucast_mgr_set_fwd_top
argument_list|,
name|p_mgr
argument_list|)
expr_stmt|;
name|ucast_mgr_pipeline_fwd_tbl
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ucast_mgr_route
parameter_list|(
name|struct
name|osm_routing_engine
modifier|*
name|r
parameter_list|,
name|osm_opensm_t
modifier|*
name|osm
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"building routing with \'%s\' routing algorithm...\n"
argument_list|,
name|r
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Set the before each lft build to keep the routes in place between sweeps */
if|if
condition|(
name|osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|scatter_ports
condition|)
name|srandom
argument_list|(
name|osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|scatter_ports
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|->
name|build_lid_matrices
operator|||
operator|(
name|ret
operator|=
name|r
operator|->
name|build_lid_matrices
argument_list|(
name|r
operator|->
name|context
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|ret
operator|=
name|osm_ucast_mgr_build_lid_matrices
argument_list|(
operator|&
name|osm
operator|->
name|sm
operator|.
name|ucast_mgr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"%s: cannot build lid matrices\n"
argument_list|,
name|r
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
operator|!
name|r
operator|->
name|ucast_build_fwd_tables
operator|||
operator|(
name|ret
operator|=
name|r
operator|->
name|ucast_build_fwd_tables
argument_list|(
name|r
operator|->
name|context
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|ret
operator|=
name|ucast_mgr_build_lfts
argument_list|(
operator|&
name|osm
operator|->
name|sm
operator|.
name|ucast_mgr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"%s: cannot build fwd tables\n"
argument_list|,
name|r
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|osm
operator|->
name|routing_engine_used
operator|=
name|r
expr_stmt|;
name|osm_ucast_mgr_set_fwd_tables
argument_list|(
operator|&
name|osm
operator|->
name|sm
operator|.
name|ucast_mgr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|osm_ucast_mgr_process
parameter_list|(
name|IN
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|)
block|{
name|osm_opensm_t
modifier|*
name|p_osm
decl_stmt|;
name|struct
name|osm_routing_engine
modifier|*
name|p_routing_eng
decl_stmt|;
name|cl_qmap_t
modifier|*
name|p_sw_guid_tbl
decl_stmt|;
name|int
name|failed
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_sw_guid_tbl
operator|=
operator|&
name|p_mgr
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
expr_stmt|;
name|p_osm
operator|=
name|p_mgr
operator|->
name|p_subn
operator|->
name|p_osm
expr_stmt|;
name|p_routing_eng
operator|=
name|p_osm
operator|->
name|routing_engine_list
expr_stmt|;
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|p_mgr
operator|->
name|p_lock
argument_list|)
expr_stmt|;
comment|/* 	   If there are no switches in the subnet, we are done. 	 */
if|if
condition|(
name|cl_qmap_count
argument_list|(
name|p_sw_guid_tbl
argument_list|)
operator|==
literal|0
operator|||
name|ucast_mgr_setup_all_switches
argument_list|(
name|p_mgr
operator|->
name|p_subn
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|Exit
goto|;
name|failed
operator|=
operator|-
literal|1
expr_stmt|;
name|p_osm
operator|->
name|routing_engine_used
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|p_routing_eng
condition|)
block|{
name|failed
operator|=
name|ucast_mgr_route
argument_list|(
name|p_routing_eng
argument_list|,
name|p_osm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|failed
condition|)
break|break;
name|p_routing_eng
operator|=
name|p_routing_eng
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p_osm
operator|->
name|routing_engine_used
operator|&&
name|p_osm
operator|->
name|no_fallback_routing_engine
operator|!=
name|TRUE
condition|)
block|{
comment|/* If configured routing algorithm failed, use default MinHop */
name|failed
operator|=
name|ucast_mgr_route
argument_list|(
name|p_osm
operator|->
name|default_routing_engine
argument_list|,
name|p_osm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_osm
operator|->
name|routing_engine_used
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"%s tables configured on all switches\n"
argument_list|,
name|osm_routing_engine_type_str
argument_list|(
name|p_osm
operator|->
name|routing_engine_used
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|use_ucast_cache
condition|)
name|p_mgr
operator|->
name|cache_valid
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|p_mgr
operator|->
name|p_subn
operator|->
name|subnet_initialization_error
operator|=
name|TRUE
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"No routing engine able to successfully configure "
literal|" switch tables on current fabric\n"
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|CL_PLOCK_RELEASE
argument_list|(
name|p_mgr
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|failed
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ucast_build_lid_matrices
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
return|return
name|osm_ucast_mgr_build_lid_matrices
argument_list|(
name|context
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ucast_build_lfts
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
return|return
name|ucast_mgr_build_lfts
argument_list|(
name|context
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|osm_ucast_minhop_setup
parameter_list|(
name|struct
name|osm_routing_engine
modifier|*
name|r
parameter_list|,
name|osm_opensm_t
modifier|*
name|osm
parameter_list|)
block|{
name|r
operator|->
name|context
operator|=
operator|&
name|osm
operator|->
name|sm
operator|.
name|ucast_mgr
expr_stmt|;
name|r
operator|->
name|build_lid_matrices
operator|=
name|ucast_build_lid_matrices
expr_stmt|;
name|r
operator|->
name|ucast_build_fwd_tables
operator|=
name|ucast_build_lfts
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ucast_dor_build_lfts
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|osm_ucast_mgr_t
modifier|*
name|mgr
init|=
name|context
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|mgr
operator|->
name|is_dor
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|ucast_mgr_build_lfts
argument_list|(
name|mgr
argument_list|)
expr_stmt|;
name|mgr
operator|->
name|is_dor
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|osm_ucast_dor_setup
parameter_list|(
name|struct
name|osm_routing_engine
modifier|*
name|r
parameter_list|,
name|osm_opensm_t
modifier|*
name|osm
parameter_list|)
block|{
name|r
operator|->
name|context
operator|=
operator|&
name|osm
operator|->
name|sm
operator|.
name|ucast_mgr
expr_stmt|;
name|r
operator|->
name|build_lid_matrices
operator|=
name|ucast_build_lid_matrices
expr_stmt|;
name|r
operator|->
name|ucast_build_fwd_tables
operator|=
name|ucast_dor_build_lfts
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ucast_dummy_build_lid_matrices
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

end_unit

