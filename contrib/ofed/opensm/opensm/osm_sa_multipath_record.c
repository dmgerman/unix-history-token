begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2006-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2011 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  * Copyright (c) 2013 Oracle and/or its affiliates. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  * 	Implementation of osm_mpr_rcv_t.  *	This object represents the MultiPath Record Receiver object.  *	This object is part of the opensm family of objects.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VENDOR_RMPP_SUPPORT
argument_list|)
operator|&&
name|defined
argument_list|(
name|DUAL_SIDED_RMPP
argument_list|)
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qmap.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_passivelock.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qlist.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_SA_MULTIPATH_RECORD_C
end_define

begin_include
include|#
directive|include
file|<vendor/osm_vendor_api.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_port.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_node.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_switch.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_partition.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_qos_policy.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_sa.h>
end_include

begin_define
define|#
directive|define
name|OSM_SA_MPR_MAX_NUM_PATH
value|127
end_define

begin_define
define|#
directive|define
name|MAX_HOPS
value|64
end_define

begin_define
define|#
directive|define
name|SA_MPR_RESP_SIZE
value|SA_ITEM_RESP_SIZE(mpr_rec)
end_define

begin_function
specifier|static
name|boolean_t
name|sa_multipath_rec_is_tavor_port
parameter_list|(
name|IN
specifier|const
name|osm_port_t
modifier|*
name|p_port
parameter_list|)
block|{
name|osm_node_t
specifier|const
modifier|*
name|p_node
decl_stmt|;
name|ib_net32_t
name|vend_id
decl_stmt|;
name|p_node
operator|=
name|p_port
operator|->
name|p_node
expr_stmt|;
name|vend_id
operator|=
name|ib_node_info_get_vendor_id
argument_list|(
operator|&
name|p_node
operator|->
name|node_info
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|p_node
operator|->
name|node_info
operator|.
name|device_id
operator|==
name|CL_HTON16
argument_list|(
literal|23108
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|vend_id
operator|==
name|CL_HTON32
argument_list|(
name|OSM_VENDOR_ID_MELLANOX
argument_list|)
operator|)
operator|||
operator|(
name|vend_id
operator|==
name|CL_HTON32
argument_list|(
name|OSM_VENDOR_ID_TOPSPIN
argument_list|)
operator|)
operator|||
operator|(
name|vend_id
operator|==
name|CL_HTON32
argument_list|(
name|OSM_VENDOR_ID_SILVERSTORM
argument_list|)
operator|)
operator|||
operator|(
name|vend_id
operator|==
name|CL_HTON32
argument_list|(
name|OSM_VENDOR_ID_VOLTAIRE
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|sa_multipath_rec_apply_tavor_mtu_limit
parameter_list|(
name|IN
specifier|const
name|ib_multipath_rec_t
modifier|*
name|p_mpr
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
name|p_src_port
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
name|p_dest_port
parameter_list|,
name|IN
specifier|const
name|ib_net64_t
name|comp_mask
parameter_list|)
block|{
name|uint8_t
name|required_mtu
decl_stmt|;
comment|/* only if at least one of the ports is a Tavor device */
if|if
condition|(
operator|!
name|sa_multipath_rec_is_tavor_port
argument_list|(
name|p_src_port
argument_list|)
operator|&&
operator|!
name|sa_multipath_rec_is_tavor_port
argument_list|(
name|p_dest_port
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* 	   we can apply the patch if either: 	   1. No MTU required 	   2. Required MTU< 	   3. Required MTU = 1K or 512 or 256 	   4. Required MTU> 256 or 512 	 */
name|required_mtu
operator|=
name|ib_multipath_rec_mtu
argument_list|(
name|p_mpr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|comp_mask
operator|&
name|IB_MPR_COMPMASK_MTUSELEC
operator|)
operator|&&
operator|(
name|comp_mask
operator|&
name|IB_MPR_COMPMASK_MTU
operator|)
condition|)
block|{
switch|switch
condition|(
name|ib_multipath_rec_mtu_sel
argument_list|(
name|p_mpr
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* must be greater than */
case|case
literal|2
case|:
comment|/* exact match */
if|if
condition|(
name|IB_MTU_LEN_1024
operator|<
name|required_mtu
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
literal|1
case|:
comment|/* must be less than */
comment|/* can't be disqualified by this one */
break|break;
case|case
literal|3
case|:
comment|/* largest available */
comment|/* the ULP intentionally requested */
comment|/* the largest MTU possible */
return|return
name|FALSE
return|;
break|break;
default|default:
comment|/* if we're here, there's a bug in ib_multipath_rec_mtu_sel() */
name|CL_ASSERT
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|ib_api_status_t
name|mpr_rcv_get_path_parms
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|ib_multipath_rec_t
modifier|*
name|p_mpr
parameter_list|,
name|IN
specifier|const
name|osm_alias_guid_t
modifier|*
name|p_src_alias_guid
parameter_list|,
name|IN
specifier|const
name|osm_alias_guid_t
modifier|*
name|p_dest_alias_guid
parameter_list|,
name|IN
specifier|const
name|uint16_t
name|src_lid_ho
parameter_list|,
name|IN
specifier|const
name|uint16_t
name|dest_lid_ho
parameter_list|,
name|IN
specifier|const
name|ib_net64_t
name|comp_mask
parameter_list|,
name|OUT
name|osm_path_parms_t
modifier|*
name|p_parms
parameter_list|)
block|{
specifier|const
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
specifier|const
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|,
modifier|*
name|p_physp0
decl_stmt|;
specifier|const
name|osm_physp_t
modifier|*
name|p_src_physp
decl_stmt|;
specifier|const
name|osm_physp_t
modifier|*
name|p_dest_physp
decl_stmt|;
specifier|const
name|osm_prtn_t
modifier|*
name|p_prtn
init|=
name|NULL
decl_stmt|;
specifier|const
name|ib_port_info_t
modifier|*
name|p_pi
decl_stmt|,
modifier|*
name|p_pi0
decl_stmt|;
name|ib_slvl_table_t
modifier|*
name|p_slvl_tbl
decl_stmt|;
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|uint8_t
name|mtu
decl_stmt|;
name|uint8_t
name|rate
decl_stmt|,
name|p0_extended_rate
decl_stmt|,
name|dest_rate
decl_stmt|;
name|uint8_t
name|pkt_life
decl_stmt|;
name|uint8_t
name|required_mtu
decl_stmt|;
name|uint8_t
name|required_rate
decl_stmt|;
name|ib_net16_t
name|required_pkey
decl_stmt|;
name|uint8_t
name|required_sl
decl_stmt|;
name|uint8_t
name|required_pkt_life
decl_stmt|;
name|ib_net16_t
name|dest_lid
decl_stmt|;
name|int
name|hops
init|=
literal|0
decl_stmt|;
name|int
name|in_port_num
init|=
literal|0
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|osm_qos_level_t
modifier|*
name|p_qos_level
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|valid_sl_mask
init|=
literal|0xffff
decl_stmt|;
name|int
name|extended
decl_stmt|,
name|p0_extended
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|dest_lid
operator|=
name|cl_hton16
argument_list|(
name|dest_lid_ho
argument_list|)
expr_stmt|;
name|p_dest_physp
operator|=
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
expr_stmt|;
name|p_physp
operator|=
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
expr_stmt|;
name|p_src_physp
operator|=
name|p_physp
expr_stmt|;
name|p_pi
operator|=
operator|&
name|p_physp
operator|->
name|port_info
expr_stmt|;
name|mtu
operator|=
name|ib_port_info_get_mtu_cap
argument_list|(
name|p_pi
argument_list|)
expr_stmt|;
name|extended
operator|=
name|p_pi
operator|->
name|capability_mask
operator|&
name|IB_PORT_CAP_HAS_EXT_SPEEDS
expr_stmt|;
name|rate
operator|=
name|ib_port_info_compute_rate
argument_list|(
name|p_pi
argument_list|,
name|extended
argument_list|)
expr_stmt|;
comment|/* 	   Mellanox Tavor device performance is better using 1K MTU. 	   If required MTU and MTU selector are such that 1K is OK 	   and at least one end of the path is Tavor we override the 	   port MTU with 1K. 	 */
if|if
condition|(
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|enable_quirks
operator|&&
name|sa_multipath_rec_apply_tavor_mtu_limit
argument_list|(
name|p_mpr
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
argument_list|,
name|comp_mask
argument_list|)
condition|)
if|if
condition|(
name|mtu
operator|>
name|IB_MTU_LEN_1024
condition|)
block|{
name|mtu
operator|=
name|IB_MTU_LEN_1024
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Optimized Path MTU to 1K for Mellanox Tavor device\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	   Walk the subnet object from source to destination, 	   tracking the most restrictive rate and mtu values along the way...  	   If source port node is a switch, then p_physp should 	   point to the port that routes the destination lid 	 */
name|p_node
operator|=
name|osm_physp_get_node_ptr
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_node
operator|->
name|sw
condition|)
block|{
comment|/* 		 * Source node is a switch. 		 * Make sure that p_physp points to the out port of the 		 * switch that routes to the destination lid (dest_lid_ho) 		 */
name|p_physp
operator|=
name|osm_switch_get_route_by_lid
argument_list|(
name|p_node
operator|->
name|sw
argument_list|,
name|dest_lid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_physp
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4514: "
literal|"Can't find routing from LID %u to LID %u on "
literal|"switch %s (GUID 0x%016"
name|PRIx64
literal|")\n"
argument_list|,
name|src_lid_ho
argument_list|,
name|dest_lid_ho
argument_list|,
name|p_node
operator|->
name|print_desc
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
if|if
condition|(
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|qos
condition|)
block|{
comment|/* 		 * Whether this node is switch or CA, the IN port for 		 * the sl2vl table is 0, because this is a source node. 		 */
name|p_slvl_tbl
operator|=
name|osm_physp_get_slvl_tbl
argument_list|(
name|p_physp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* update valid SLs that still exist on this route */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IB_MAX_NUM_VLS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|valid_sl_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|&&
name|ib_slvl_table_get
argument_list|(
name|p_slvl_tbl
argument_list|,
name|i
argument_list|)
operator|==
name|IB_DROP_VL
condition|)
name|valid_sl_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|valid_sl_mask
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"All the SLs lead to VL15 on this path\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/* 	 * Same as above 	 */
name|p_node
operator|=
name|osm_physp_get_node_ptr
argument_list|(
name|p_dest_physp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_node
operator|->
name|sw
condition|)
block|{
comment|/* 		 * if destination is switch, we want p_dest_physp to point to port 0 		 */
name|p_dest_physp
operator|=
name|osm_switch_get_route_by_lid
argument_list|(
name|p_node
operator|->
name|sw
argument_list|,
name|dest_lid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_dest_physp
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4515: "
literal|"Can't find routing from LID %u to LID %u on "
literal|"switch %s (GUID 0x%016"
name|PRIx64
literal|")\n"
argument_list|,
name|src_lid_ho
argument_list|,
name|dest_lid_ho
argument_list|,
name|p_node
operator|->
name|print_desc
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/* 	 * Now go through the path step by step 	 */
while|while
condition|(
name|p_physp
operator|!=
name|p_dest_physp
condition|)
block|{
name|int
name|tmp_pnum
init|=
name|p_physp
operator|->
name|port_num
decl_stmt|;
name|p_node
operator|=
name|osm_physp_get_node_ptr
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|p_physp
operator|=
name|osm_physp_get_remote
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_physp
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4505: "
literal|"Can't find remote phys port of %s (GUID "
literal|"0x%016"
name|PRIx64
literal|") port %d "
literal|"while routing from LID %u to LID %u"
argument_list|,
name|p_node
operator|->
name|print_desc
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|tmp_pnum
argument_list|,
name|src_lid_ho
argument_list|,
name|dest_lid_ho
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* update number of hops traversed */
name|hops
operator|++
expr_stmt|;
if|if
condition|(
name|hops
operator|>
name|MAX_HOPS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4520: "
literal|"Path from GUID 0x%016"
name|PRIx64
literal|" (%s) to"
literal|" lid %u GUID 0x%016"
name|PRIx64
literal|" (%s) needs"
literal|" more than %d hops, max %d hops allowed\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_src_physp
argument_list|)
argument_list|)
argument_list|,
name|p_src_physp
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|dest_lid_ho
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_dest_physp
argument_list|)
argument_list|)
argument_list|,
name|p_dest_physp
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|hops
argument_list|,
name|MAX_HOPS
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|in_port_num
operator|=
name|osm_physp_get_port_num
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
comment|/* 		   This is point to point case (no switch in between) 		 */
if|if
condition|(
name|p_physp
operator|==
name|p_dest_physp
condition|)
break|break;
name|p_node
operator|=
name|osm_physp_get_node_ptr
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_node
operator|->
name|sw
condition|)
block|{
comment|/* 			   There is some sort of problem in the subnet object! 			   If this isn't a switch, we should have reached 			   the destination by now! 			 */
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4503: "
literal|"Internal error, bad path while routing "
literal|"from %s (GUID: 0x%016"
name|PRIx64
literal|") port %d "
literal|"to %s (GUID: 0x%016"
name|PRIx64
literal|") port %d; "
literal|"ended at %s port %d\n"
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|)
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|)
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|,
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_physp
operator|->
name|port_num
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 		   Check parameters for the ingress port in this switch. 		 */
name|p_pi
operator|=
operator|&
name|p_physp
operator|->
name|port_info
expr_stmt|;
if|if
condition|(
name|mtu
operator|>
name|ib_port_info_get_mtu_cap
argument_list|(
name|p_pi
argument_list|)
condition|)
name|mtu
operator|=
name|ib_port_info_get_mtu_cap
argument_list|(
name|p_pi
argument_list|)
expr_stmt|;
name|p_physp0
operator|=
name|osm_node_get_physp_ptr
argument_list|(
operator|(
name|osm_node_t
operator|*
operator|)
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p_pi0
operator|=
operator|&
name|p_physp0
operator|->
name|port_info
expr_stmt|;
name|p0_extended
operator|=
name|p_pi0
operator|->
name|capability_mask
operator|&
name|IB_PORT_CAP_HAS_EXT_SPEEDS
expr_stmt|;
name|p0_extended_rate
operator|=
name|ib_port_info_compute_rate
argument_list|(
name|p_pi
argument_list|,
name|p0_extended
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_path_compare_rates
argument_list|(
name|rate
argument_list|,
name|p0_extended_rate
argument_list|)
operator|>
literal|0
condition|)
name|rate
operator|=
name|p0_extended_rate
expr_stmt|;
comment|/* 		   Continue with the egress port on this switch. 		 */
name|p_physp
operator|=
name|osm_switch_get_route_by_lid
argument_list|(
name|p_node
operator|->
name|sw
argument_list|,
name|dest_lid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_physp
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4516: "
literal|"Dead end path on switch "
literal|"%s (GUID: 0x%016"
name|PRIx64
literal|") to LID %u\n"
argument_list|,
name|p_node
operator|->
name|print_desc
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|dest_lid_ho
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_pi
operator|=
operator|&
name|p_physp
operator|->
name|port_info
expr_stmt|;
if|if
condition|(
name|mtu
operator|>
name|ib_port_info_get_mtu_cap
argument_list|(
name|p_pi
argument_list|)
condition|)
name|mtu
operator|=
name|ib_port_info_get_mtu_cap
argument_list|(
name|p_pi
argument_list|)
expr_stmt|;
name|p_physp0
operator|=
name|osm_node_get_physp_ptr
argument_list|(
operator|(
name|osm_node_t
operator|*
operator|)
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p_pi0
operator|=
operator|&
name|p_physp0
operator|->
name|port_info
expr_stmt|;
name|p0_extended
operator|=
name|p_pi0
operator|->
name|capability_mask
operator|&
name|IB_PORT_CAP_HAS_EXT_SPEEDS
expr_stmt|;
name|p0_extended_rate
operator|=
name|ib_port_info_compute_rate
argument_list|(
name|p_pi
argument_list|,
name|p0_extended
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_path_compare_rates
argument_list|(
name|rate
argument_list|,
name|p0_extended_rate
argument_list|)
operator|>
literal|0
condition|)
name|rate
operator|=
name|p0_extended_rate
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|qos
condition|)
block|{
comment|/* 			 * Check SL2VL table of the switch and update valid SLs 			 */
name|p_slvl_tbl
operator|=
name|osm_physp_get_slvl_tbl
argument_list|(
name|p_physp
argument_list|,
name|in_port_num
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IB_MAX_NUM_VLS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|valid_sl_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|&&
name|ib_slvl_table_get
argument_list|(
name|p_slvl_tbl
argument_list|,
name|i
argument_list|)
operator|==
name|IB_DROP_VL
condition|)
name|valid_sl_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|valid_sl_mask
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"All the SLs lead to VL15 "
literal|"on this path\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
block|}
comment|/* 	   p_physp now points to the destination 	 */
name|p_pi
operator|=
operator|&
name|p_physp
operator|->
name|port_info
expr_stmt|;
if|if
condition|(
name|mtu
operator|>
name|ib_port_info_get_mtu_cap
argument_list|(
name|p_pi
argument_list|)
condition|)
name|mtu
operator|=
name|ib_port_info_get_mtu_cap
argument_list|(
name|p_pi
argument_list|)
expr_stmt|;
name|extended
operator|=
name|p_pi
operator|->
name|capability_mask
operator|&
name|IB_PORT_CAP_HAS_EXT_SPEEDS
expr_stmt|;
name|dest_rate
operator|=
name|ib_port_info_compute_rate
argument_list|(
name|p_pi
argument_list|,
name|extended
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_path_compare_rates
argument_list|(
name|rate
argument_list|,
name|dest_rate
argument_list|)
operator|>
literal|0
condition|)
name|rate
operator|=
name|dest_rate
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Path min MTU = %u, min rate = %u\n"
argument_list|,
name|mtu
argument_list|,
name|rate
argument_list|)
expr_stmt|;
comment|/* 	 * Get QoS Level object according to the MultiPath request 	 * and adjust MultiPath parameters according to QoS settings 	 */
if|if
condition|(
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|qos
operator|&&
name|sa
operator|->
name|p_subn
operator|->
name|p_qos_policy
operator|&&
operator|(
name|p_qos_level
operator|=
name|osm_qos_policy_get_qos_level_by_mpr
argument_list|(
name|sa
operator|->
name|p_subn
operator|->
name|p_qos_policy
argument_list|,
name|p_mpr
argument_list|,
name|p_src_physp
argument_list|,
name|p_dest_physp
argument_list|,
name|comp_mask
argument_list|)
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"MultiPathRecord request matches QoS Level '%s' (%s)\n"
argument_list|,
name|p_qos_level
operator|->
name|name
argument_list|,
name|p_qos_level
operator|->
name|use
condition|?
name|p_qos_level
operator|->
name|use
else|:
literal|"no description"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_qos_level
operator|->
name|mtu_limit_set
operator|&&
operator|(
name|mtu
operator|>
name|p_qos_level
operator|->
name|mtu_limit
operator|)
condition|)
name|mtu
operator|=
name|p_qos_level
operator|->
name|mtu_limit
expr_stmt|;
if|if
condition|(
name|p_qos_level
operator|->
name|rate_limit_set
operator|&&
operator|(
name|ib_path_compare_rates
argument_list|(
name|rate
argument_list|,
name|p_qos_level
operator|->
name|rate_limit
argument_list|)
operator|>
literal|0
operator|)
condition|)
name|rate
operator|=
name|p_qos_level
operator|->
name|rate_limit
expr_stmt|;
if|if
condition|(
name|p_qos_level
operator|->
name|sl_set
condition|)
block|{
name|required_sl
operator|=
name|p_qos_level
operator|->
name|sl
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|valid_sl_mask
operator|&
operator|(
literal|1
operator|<<
name|required_sl
operator|)
operator|)
condition|)
block|{
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
block|}
comment|/* 	   Determine if these values meet the user criteria 	 */
comment|/* we silently ignore cases where only the MTU selector is defined */
if|if
condition|(
operator|(
name|comp_mask
operator|&
name|IB_MPR_COMPMASK_MTUSELEC
operator|)
operator|&&
operator|(
name|comp_mask
operator|&
name|IB_MPR_COMPMASK_MTU
operator|)
condition|)
block|{
name|required_mtu
operator|=
name|ib_multipath_rec_mtu
argument_list|(
name|p_mpr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ib_multipath_rec_mtu_sel
argument_list|(
name|p_mpr
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* must be greater than */
if|if
condition|(
name|mtu
operator|<=
name|required_mtu
condition|)
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* must be less than */
if|if
condition|(
name|mtu
operator|>=
name|required_mtu
condition|)
block|{
comment|/* adjust to use the highest mtu 				   lower then the required one */
if|if
condition|(
name|required_mtu
operator|>
literal|1
condition|)
name|mtu
operator|=
name|required_mtu
operator|-
literal|1
expr_stmt|;
else|else
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* exact match */
if|if
condition|(
name|mtu
operator|<
name|required_mtu
condition|)
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
else|else
name|mtu
operator|=
name|required_mtu
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* largest available */
comment|/* can't be disqualified by this one */
break|break;
default|default:
comment|/* if we're here, there's a bug in ib_multipath_rec_mtu_sel() */
name|CL_ASSERT
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
comment|/* we silently ignore cases where only the Rate selector is defined */
if|if
condition|(
operator|(
name|comp_mask
operator|&
name|IB_MPR_COMPMASK_RATESELEC
operator|)
operator|&&
operator|(
name|comp_mask
operator|&
name|IB_MPR_COMPMASK_RATE
operator|)
condition|)
block|{
name|required_rate
operator|=
name|ib_multipath_rec_rate
argument_list|(
name|p_mpr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ib_multipath_rec_rate_sel
argument_list|(
name|p_mpr
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* must be greater than */
if|if
condition|(
name|ib_path_compare_rates
argument_list|(
name|rate
argument_list|,
name|required_rate
argument_list|)
operator|<=
literal|0
condition|)
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* must be less than */
if|if
condition|(
name|ib_path_compare_rates
argument_list|(
name|rate
argument_list|,
name|required_rate
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* adjust the rate to use the highest rate 				   lower then the required one */
name|rate
operator|=
name|ib_path_rate_get_prev
argument_list|(
name|required_rate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rate
condition|)
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* exact match */
if|if
condition|(
name|ib_path_compare_rates
argument_list|(
name|rate
argument_list|,
name|required_rate
argument_list|)
condition|)
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
else|else
name|rate
operator|=
name|required_rate
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* largest available */
comment|/* can't be disqualified by this one */
break|break;
default|default:
comment|/* if we're here, there's a bug in ib_multipath_rec_mtu_sel() */
name|CL_ASSERT
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
comment|/* Verify the pkt_life_time */
comment|/* According to spec definition IBA 1.2 Table 205 PacketLifeTime description, 	   for loopback paths, packetLifeTime shall be zero. */
if|if
condition|(
name|p_src_alias_guid
operator|->
name|p_base_port
operator|==
name|p_dest_alias_guid
operator|->
name|p_base_port
condition|)
name|pkt_life
operator|=
literal|0
expr_stmt|;
comment|/* loopback */
elseif|else
if|if
condition|(
name|p_qos_level
operator|&&
name|p_qos_level
operator|->
name|pkt_life_set
condition|)
name|pkt_life
operator|=
name|p_qos_level
operator|->
name|pkt_life
expr_stmt|;
else|else
name|pkt_life
operator|=
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|subnet_timeout
expr_stmt|;
comment|/* we silently ignore cases where only the PktLife selector is defined */
if|if
condition|(
operator|(
name|comp_mask
operator|&
name|IB_MPR_COMPMASK_PKTLIFETIMESELEC
operator|)
operator|&&
operator|(
name|comp_mask
operator|&
name|IB_MPR_COMPMASK_PKTLIFETIME
operator|)
condition|)
block|{
name|required_pkt_life
operator|=
name|ib_multipath_rec_pkt_life
argument_list|(
name|p_mpr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ib_multipath_rec_pkt_life_sel
argument_list|(
name|p_mpr
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* must be greater than */
if|if
condition|(
name|pkt_life
operator|<=
name|required_pkt_life
condition|)
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* must be less than */
if|if
condition|(
name|pkt_life
operator|>=
name|required_pkt_life
condition|)
block|{
comment|/* adjust the lifetime to use the highest possible 				   lower then the required one */
if|if
condition|(
name|required_pkt_life
operator|>
literal|1
condition|)
name|pkt_life
operator|=
name|required_pkt_life
operator|-
literal|1
expr_stmt|;
else|else
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* exact match */
if|if
condition|(
name|pkt_life
operator|<
name|required_pkt_life
condition|)
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
else|else
name|pkt_life
operator|=
name|required_pkt_life
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* smallest available */
comment|/* can't be disqualified by this one */
break|break;
default|default:
comment|/* if we're here, there's a bug in ib_path_rec_pkt_life_sel() */
name|CL_ASSERT
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
comment|/* 	 * set Pkey for this MultiPath record request 	 */
if|if
condition|(
name|comp_mask
operator|&
name|IB_MPR_COMPMASK_RAWTRAFFIC
operator|&&
name|cl_ntoh32
argument_list|(
name|p_mpr
operator|->
name|hop_flow_raw
argument_list|)
operator|&
operator|(
literal|1
operator|<<
literal|31
operator|)
condition|)
name|required_pkey
operator|=
name|osm_physp_find_common_pkey
argument_list|(
name|p_src_physp
argument_list|,
name|p_dest_physp
argument_list|,
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|allow_both_pkeys
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|comp_mask
operator|&
name|IB_MPR_COMPMASK_PKEY
condition|)
block|{
comment|/* 		 * MPR request has a specific pkey: 		 * Check that source and destination share this pkey. 		 * If QoS level has pkeys, check that this pkey exists 		 * in the QoS level pkeys. 		 * MPR returned pkey is the requested pkey. 		 */
name|required_pkey
operator|=
name|p_mpr
operator|->
name|pkey
expr_stmt|;
if|if
condition|(
operator|!
name|osm_physp_share_this_pkey
argument_list|(
name|p_src_physp
argument_list|,
name|p_dest_physp
argument_list|,
name|required_pkey
argument_list|,
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|allow_both_pkeys
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4518: "
literal|"Ports src 0x%016"
name|PRIx64
literal|" (%s port %d) "
literal|"and dst 0x%016"
name|PRIx64
literal|" (%s port %d) "
literal|"do not share the specified PKey 0x%04x\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_src_physp
argument_list|)
argument_list|)
argument_list|,
name|p_src_physp
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_src_physp
operator|->
name|port_num
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_dest_physp
argument_list|)
argument_list|)
argument_list|,
name|p_dest_physp
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_dest_physp
operator|->
name|port_num
argument_list|,
name|cl_ntoh16
argument_list|(
name|required_pkey
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|p_qos_level
operator|&&
name|p_qos_level
operator|->
name|pkey_range_len
operator|&&
operator|!
name|osm_qos_level_has_pkey
argument_list|(
name|p_qos_level
argument_list|,
name|required_pkey
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 451C: "
literal|"Ports src 0x%016"
name|PRIx64
literal|" (%s port %d) "
literal|"and dst 0x%016"
name|PRIx64
literal|" (%s port %d) "
literal|"do not share specified PKey (0x%04x) as "
literal|"defined by QoS level \"%s\"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_src_physp
argument_list|)
argument_list|)
argument_list|,
name|p_src_physp
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_src_physp
operator|->
name|port_num
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_dest_physp
argument_list|)
argument_list|)
argument_list|,
name|p_dest_physp
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_dest_physp
operator|->
name|port_num
argument_list|,
name|cl_ntoh16
argument_list|(
name|required_pkey
argument_list|)
argument_list|,
name|p_qos_level
operator|->
name|name
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|p_qos_level
operator|&&
name|p_qos_level
operator|->
name|pkey_range_len
condition|)
block|{
comment|/* 		 * MPR request doesn't have a specific pkey, but QoS level 		 * has pkeys - get shared pkey from QoS level pkeys 		 */
name|required_pkey
operator|=
name|osm_qos_level_get_shared_pkey
argument_list|(
name|p_qos_level
argument_list|,
name|p_src_physp
argument_list|,
name|p_dest_physp
argument_list|,
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|allow_both_pkeys
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|required_pkey
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 451D: "
literal|"Ports src 0x%016"
name|PRIx64
literal|" (%s port %d) "
literal|"and dst 0x%016"
name|PRIx64
literal|" (%s port %d) "
literal|"do not share a PKey as defined by QoS "
literal|"level \"%s\"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_src_physp
argument_list|)
argument_list|)
argument_list|,
name|p_src_physp
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_src_physp
operator|->
name|port_num
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_dest_physp
argument_list|)
argument_list|)
argument_list|,
name|p_dest_physp
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_dest_physp
operator|->
name|port_num
argument_list|,
name|p_qos_level
operator|->
name|name
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
else|else
block|{
comment|/* 		 * Neither MPR request nor QoS level have pkey. 		 * Just get any shared pkey. 		 */
name|required_pkey
operator|=
name|osm_physp_find_common_pkey
argument_list|(
name|p_src_physp
argument_list|,
name|p_dest_physp
argument_list|,
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|allow_both_pkeys
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|required_pkey
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4519: "
literal|"Ports src 0x%016"
name|PRIx64
literal|" (%s port %d) "
literal|"and dst 0x%016"
name|PRIx64
literal|" (%s port %d) "
literal|"do not have any shared PKeys\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_src_physp
argument_list|)
argument_list|)
argument_list|,
name|p_src_physp
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_src_physp
operator|->
name|port_num
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_dest_physp
argument_list|)
argument_list|)
argument_list|,
name|p_dest_physp
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_dest_physp
operator|->
name|port_num
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
if|if
condition|(
name|required_pkey
condition|)
block|{
name|p_prtn
operator|=
operator|(
name|osm_prtn_t
operator|*
operator|)
name|cl_qmap_get
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|prtn_pkey_tbl
argument_list|,
name|required_pkey
operator|&
name|cl_ntoh16
argument_list|(
operator|(
name|uint16_t
operator|)
operator|~
literal|0x8000
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_prtn
operator|==
operator|(
name|osm_prtn_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|prtn_pkey_tbl
argument_list|)
condition|)
name|p_prtn
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Set MultiPathRecord SL. 	 */
if|if
condition|(
name|comp_mask
operator|&
name|IB_MPR_COMPMASK_SL
condition|)
block|{
comment|/* 		 * Specific SL was requested 		 */
name|required_sl
operator|=
name|ib_multipath_rec_sl
argument_list|(
name|p_mpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_qos_level
operator|&&
name|p_qos_level
operator|->
name|sl_set
operator|&&
name|p_qos_level
operator|->
name|sl
operator|!=
name|required_sl
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 451E: "
literal|"QoS constraints: required MultiPathRecord SL "
literal|"(%u) doesn't match QoS policy \"%s\" SL (%u) "
literal|"[%s port %d<-> %s port %d]\n"
argument_list|,
name|required_sl
argument_list|,
name|p_qos_level
operator|->
name|name
argument_list|,
name|p_qos_level
operator|->
name|sl
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|p_qos_level
operator|&&
name|p_qos_level
operator|->
name|sl_set
condition|)
block|{
comment|/* 		 * No specific SL was requested, 		 * but there is an SL in QoS level. 		 */
name|required_sl
operator|=
name|p_qos_level
operator|->
name|sl
expr_stmt|;
if|if
condition|(
name|required_pkey
operator|&&
name|p_prtn
operator|&&
name|p_prtn
operator|->
name|sl
operator|!=
name|p_qos_level
operator|->
name|sl
condition|)
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"QoS level SL (%u) overrides partition SL (%u)\n"
argument_list|,
name|p_qos_level
operator|->
name|sl
argument_list|,
name|p_prtn
operator|->
name|sl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|required_pkey
condition|)
block|{
comment|/* 		 * No specific SL in request or in QoS level - use partition SL 		 */
name|p_prtn
operator|=
operator|(
name|osm_prtn_t
operator|*
operator|)
name|cl_qmap_get
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|prtn_pkey_tbl
argument_list|,
name|required_pkey
operator|&
name|cl_ntoh16
argument_list|(
operator|(
name|uint16_t
operator|)
operator|~
literal|0x8000
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_prtn
condition|)
block|{
name|required_sl
operator|=
name|OSM_DEFAULT_SL
expr_stmt|;
comment|/* this may be possible when pkey tables are created somehow in 			   previous runs or things are going wrong here */
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 451A: "
literal|"No partition found for PKey 0x%04x - "
literal|"using default SL %d "
literal|"[%s port %d<-> %s port %d]\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|required_pkey
argument_list|)
argument_list|,
name|required_sl
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|)
expr_stmt|;
block|}
else|else
name|required_sl
operator|=
name|p_prtn
operator|->
name|sl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|qos
condition|)
block|{
if|if
condition|(
name|valid_sl_mask
operator|&
operator|(
literal|1
operator|<<
name|OSM_DEFAULT_SL
operator|)
condition|)
name|required_sl
operator|=
name|OSM_DEFAULT_SL
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IB_MAX_NUM_VLS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|valid_sl_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
break|break;
name|required_sl
operator|=
name|i
expr_stmt|;
block|}
block|}
else|else
name|required_sl
operator|=
name|OSM_DEFAULT_SL
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|qos
operator|&&
operator|!
operator|(
name|valid_sl_mask
operator|&
operator|(
literal|1
operator|<<
name|required_sl
operator|)
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 451F: "
literal|"Selected SL (%u) leads to VL15 "
literal|"[%s port %d<-> %s port %d]\n"
argument_list|,
name|required_sl
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* reset pkey when raw traffic */
if|if
condition|(
name|comp_mask
operator|&
name|IB_MPR_COMPMASK_RAWTRAFFIC
operator|&&
name|cl_ntoh32
argument_list|(
name|p_mpr
operator|->
name|hop_flow_raw
argument_list|)
operator|&
operator|(
literal|1
operator|<<
literal|31
operator|)
condition|)
name|required_pkey
operator|=
literal|0
expr_stmt|;
name|p_parms
operator|->
name|mtu
operator|=
name|mtu
expr_stmt|;
name|p_parms
operator|->
name|rate
operator|=
name|rate
expr_stmt|;
name|p_parms
operator|->
name|pkey
operator|=
name|required_pkey
expr_stmt|;
name|p_parms
operator|->
name|pkt_life
operator|=
name|pkt_life
expr_stmt|;
name|p_parms
operator|->
name|sl
operator|=
name|required_sl
expr_stmt|;
name|p_parms
operator|->
name|hops
operator|=
name|hops
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"MultiPath params:"
literal|" mtu = %u, rate = %u, packet lifetime = %u,"
literal|" pkey = 0x%04X, sl = %u, hops = %u\n"
argument_list|,
name|mtu
argument_list|,
name|rate
argument_list|,
name|pkt_life
argument_list|,
name|cl_ntoh16
argument_list|(
name|required_pkey
argument_list|)
argument_list|,
name|required_sl
argument_list|,
name|hops
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpr_rcv_build_pr
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|osm_alias_guid_t
modifier|*
name|p_src_alias_guid
parameter_list|,
name|IN
specifier|const
name|osm_alias_guid_t
modifier|*
name|p_dest_alias_guid
parameter_list|,
name|IN
name|uint16_t
name|src_lid_ho
parameter_list|,
name|IN
name|uint16_t
name|dest_lid_ho
parameter_list|,
name|IN
name|uint8_t
name|preference
parameter_list|,
name|IN
specifier|const
name|osm_path_parms_t
modifier|*
name|p_parms
parameter_list|,
name|OUT
name|ib_path_rec_t
modifier|*
name|p_pr
parameter_list|)
block|{
specifier|const
name|osm_physp_t
modifier|*
name|p_src_physp
decl_stmt|,
modifier|*
name|p_dest_physp
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_src_physp
operator|=
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
expr_stmt|;
name|p_dest_physp
operator|=
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
expr_stmt|;
name|p_pr
operator|->
name|dgid
operator|.
name|unicast
operator|.
name|prefix
operator|=
name|osm_physp_get_subnet_prefix
argument_list|(
name|p_dest_physp
argument_list|)
expr_stmt|;
name|p_pr
operator|->
name|dgid
operator|.
name|unicast
operator|.
name|interface_id
operator|=
name|p_dest_alias_guid
operator|->
name|alias_guid
expr_stmt|;
name|p_pr
operator|->
name|sgid
operator|.
name|unicast
operator|.
name|prefix
operator|=
name|osm_physp_get_subnet_prefix
argument_list|(
name|p_src_physp
argument_list|)
expr_stmt|;
name|p_pr
operator|->
name|sgid
operator|.
name|unicast
operator|.
name|interface_id
operator|=
name|p_src_alias_guid
operator|->
name|alias_guid
expr_stmt|;
name|p_pr
operator|->
name|dlid
operator|=
name|cl_hton16
argument_list|(
name|dest_lid_ho
argument_list|)
expr_stmt|;
name|p_pr
operator|->
name|slid
operator|=
name|cl_hton16
argument_list|(
name|src_lid_ho
argument_list|)
expr_stmt|;
name|p_pr
operator|->
name|hop_flow_raw
operator|&=
name|cl_hton32
argument_list|(
literal|1
operator|<<
literal|31
argument_list|)
expr_stmt|;
name|p_pr
operator|->
name|pkey
operator|=
name|p_parms
operator|->
name|pkey
expr_stmt|;
name|ib_path_rec_set_qos_class
argument_list|(
name|p_pr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ib_path_rec_set_sl
argument_list|(
name|p_pr
argument_list|,
name|p_parms
operator|->
name|sl
argument_list|)
expr_stmt|;
name|p_pr
operator|->
name|mtu
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_parms
operator|->
name|mtu
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|p_pr
operator|->
name|rate
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_parms
operator|->
name|rate
operator||
literal|0x80
argument_list|)
expr_stmt|;
comment|/* According to 1.2 spec definition Table 205 PacketLifeTime description, 	   for loopback paths, packetLifeTime shall be zero. */
if|if
condition|(
name|p_src_alias_guid
operator|->
name|p_base_port
operator|==
name|p_dest_alias_guid
operator|->
name|p_base_port
condition|)
name|p_pr
operator|->
name|pkt_life
operator|=
literal|0x80
expr_stmt|;
comment|/* loopback */
else|else
name|p_pr
operator|->
name|pkt_life
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_parms
operator|->
name|pkt_life
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|p_pr
operator|->
name|preference
operator|=
name|preference
expr_stmt|;
comment|/* always return num_path = 0 so this is only the reversible component */
if|if
condition|(
name|p_parms
operator|->
name|reversible
condition|)
name|p_pr
operator|->
name|num_path
operator|=
literal|0x80
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|osm_sa_item_t
modifier|*
name|mpr_rcv_get_lid_pair_path
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|ib_multipath_rec_t
modifier|*
name|p_mpr
parameter_list|,
name|IN
specifier|const
name|osm_alias_guid_t
modifier|*
name|p_src_alias_guid
parameter_list|,
name|IN
specifier|const
name|osm_alias_guid_t
modifier|*
name|p_dest_alias_guid
parameter_list|,
name|IN
specifier|const
name|uint16_t
name|src_lid_ho
parameter_list|,
name|IN
specifier|const
name|uint16_t
name|dest_lid_ho
parameter_list|,
name|IN
specifier|const
name|ib_net64_t
name|comp_mask
parameter_list|,
name|IN
specifier|const
name|uint8_t
name|preference
parameter_list|)
block|{
name|osm_path_parms_t
name|path_parms
decl_stmt|;
name|osm_path_parms_t
name|rev_path_parms
decl_stmt|;
name|osm_sa_item_t
modifier|*
name|p_pr_item
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|,
name|rev_path_status
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Src LID %u, Dest LID %u\n"
argument_list|,
name|src_lid_ho
argument_list|,
name|dest_lid_ho
argument_list|)
expr_stmt|;
name|p_pr_item
operator|=
name|malloc
argument_list|(
name|SA_MPR_RESP_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_pr_item
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4501: "
literal|"Unable to allocate path record\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|memset
argument_list|(
name|p_pr_item
argument_list|,
literal|0
argument_list|,
name|SA_MPR_RESP_SIZE
argument_list|)
expr_stmt|;
name|status
operator|=
name|mpr_rcv_get_path_parms
argument_list|(
name|sa
argument_list|,
name|p_mpr
argument_list|,
name|p_src_alias_guid
argument_list|,
name|p_dest_alias_guid
argument_list|,
name|src_lid_ho
argument_list|,
name|dest_lid_ho
argument_list|,
name|comp_mask
argument_list|,
operator|&
name|path_parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|free
argument_list|(
name|p_pr_item
argument_list|)
expr_stmt|;
name|p_pr_item
operator|=
name|NULL
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* now try the reversible path */
name|rev_path_status
operator|=
name|mpr_rcv_get_path_parms
argument_list|(
name|sa
argument_list|,
name|p_mpr
argument_list|,
name|p_dest_alias_guid
argument_list|,
name|p_src_alias_guid
argument_list|,
name|dest_lid_ho
argument_list|,
name|src_lid_ho
argument_list|,
name|comp_mask
argument_list|,
operator|&
name|rev_path_parms
argument_list|)
expr_stmt|;
name|path_parms
operator|.
name|reversible
operator|=
operator|(
name|rev_path_status
operator|==
name|IB_SUCCESS
operator|)
expr_stmt|;
comment|/* did we get a Reversible Path compmask ? */
comment|/* 	   NOTE that if the reversible component = 0, it is a don't care 	   rather then requiring non-reversible paths ... 	   see Vol1 Ver1.2 p900 l16 	 */
if|if
condition|(
name|comp_mask
operator|&
name|IB_MPR_COMPMASK_REVERSIBLE
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|path_parms
operator|.
name|reversible
operator|&&
operator|(
name|p_mpr
operator|->
name|num_path
operator|&
literal|0x80
operator|)
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Requested reversible path but failed to get one\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_pr_item
argument_list|)
expr_stmt|;
name|p_pr_item
operator|=
name|NULL
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
name|p_pr_item
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|p_src_port
operator|=
name|p_src_alias_guid
operator|->
name|p_base_port
expr_stmt|;
name|p_pr_item
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|p_dest_port
operator|=
name|p_dest_alias_guid
operator|->
name|p_base_port
expr_stmt|;
name|p_pr_item
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|hops
operator|=
name|path_parms
operator|.
name|hops
expr_stmt|;
name|mpr_rcv_build_pr
argument_list|(
name|sa
argument_list|,
name|p_src_alias_guid
argument_list|,
name|p_dest_alias_guid
argument_list|,
name|src_lid_ho
argument_list|,
name|dest_lid_ho
argument_list|,
name|preference
argument_list|,
operator|&
name|path_parms
argument_list|,
operator|&
name|p_pr_item
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|path_rec
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|p_pr_item
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|mpr_rcv_get_port_pair_paths
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|ib_multipath_rec_t
modifier|*
name|p_mpr
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
name|p_req_port
parameter_list|,
name|IN
specifier|const
name|osm_alias_guid_t
modifier|*
name|p_src_alias_guid
parameter_list|,
name|IN
specifier|const
name|osm_alias_guid_t
modifier|*
name|p_dest_alias_guid
parameter_list|,
name|IN
specifier|const
name|uint32_t
name|rem_paths
parameter_list|,
name|IN
specifier|const
name|ib_net64_t
name|comp_mask
parameter_list|,
name|IN
name|cl_qlist_t
modifier|*
name|p_list
parameter_list|)
block|{
name|osm_sa_item_t
modifier|*
name|p_pr_item
decl_stmt|;
name|uint16_t
name|src_lid_min_ho
decl_stmt|;
name|uint16_t
name|src_lid_max_ho
decl_stmt|;
name|uint16_t
name|dest_lid_min_ho
decl_stmt|;
name|uint16_t
name|dest_lid_max_ho
decl_stmt|;
name|uint16_t
name|src_lid_ho
decl_stmt|;
name|uint16_t
name|dest_lid_ho
decl_stmt|;
name|uint32_t
name|path_num
init|=
literal|0
decl_stmt|;
name|uint8_t
name|preference
decl_stmt|;
name|unsigned
name|src_offset
decl_stmt|,
name|dest_offset
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Src port 0x%016"
name|PRIx64
literal|", Dst port 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_src_alias_guid
operator|->
name|alias_guid
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_dest_alias_guid
operator|->
name|alias_guid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check that the req_port, src_port and dest_port all share a 	   pkey. The check is done on the default physical port of the ports. */
if|if
condition|(
name|osm_port_share_pkey
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_req_port
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
argument_list|,
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|allow_both_pkeys
argument_list|)
operator|==
name|FALSE
operator|||
name|osm_port_share_pkey
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_req_port
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
argument_list|,
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|allow_both_pkeys
argument_list|)
operator|==
name|FALSE
operator|||
name|osm_port_share_pkey
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
argument_list|,
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|allow_both_pkeys
argument_list|)
operator|==
name|FALSE
condition|)
comment|/* One of the pairs doesn't share a pkey so the path is disqualified. */
goto|goto
name|Exit
goto|;
comment|/* 	   We shouldn't be here if the paths are disqualified in some way... 	   Thus, we assume every possible connection is valid.  	   We desire to return high-quality paths first. 	   In OpenSM, higher quality mean least overlap with other paths. 	   This is acheived in practice by returning paths with 	   different LID value on each end, which means these 	   paths are more redundant that paths with the same LID repeated 	   on one side.  For example, in OpenSM the paths between two 	   endpoints with LMC = 1 might be as follows:  	   Port A, LID 1<-> Port B, LID 3 	   Port A, LID 1<-> Port B, LID 4 	   Port A, LID 2<-> Port B, LID 3 	   Port A, LID 2<-> Port B, LID 4  	   The OpenSM unicast routing algorithms attempt to disperse each path 	   to as varied a physical path as is reasonable.  1<->3 and 1<->4 have 	   more physical overlap (hence less redundancy) than 1<->3 and 2<->4.  	   OpenSM ranks paths in three preference groups:  	   Preference Value           Description 	   ----------------           ------------------------------------------- 	   0                  Redundant in both directions with other 	   pref value = 0 paths  	   1                  Redundant in one direction with other 	   pref value = 0 and pref value = 1 paths  	   2                  Not redundant in either direction with 	   other paths  	   3-FF                       Unused  	   SA clients don't need to know these details, only that the lower 	   preference paths are preferred, as stated in the spec.  The paths 	   may not actually be physically redundant depending on the topology 	   of the subnet, but the point of LMC> 0 is to offer redundancy, 	   so I assume the subnet is physically appropriate for the specified 	   LMC value.  A more advanced implementation could inspect for physical 	   redundancy, but I'm not going to bother with that now. 	 */
name|osm_port_get_lid_range_ho
argument_list|(
name|p_src_alias_guid
operator|->
name|p_base_port
argument_list|,
operator|&
name|src_lid_min_ho
argument_list|,
operator|&
name|src_lid_max_ho
argument_list|)
expr_stmt|;
name|osm_port_get_lid_range_ho
argument_list|(
name|p_dest_alias_guid
operator|->
name|p_base_port
argument_list|,
operator|&
name|dest_lid_min_ho
argument_list|,
operator|&
name|dest_lid_max_ho
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Src LID [%u-%u], Dest LID [%u-%u]\n"
argument_list|,
name|src_lid_min_ho
argument_list|,
name|src_lid_max_ho
argument_list|,
name|dest_lid_min_ho
argument_list|,
name|dest_lid_max_ho
argument_list|)
expr_stmt|;
name|src_lid_ho
operator|=
name|src_lid_min_ho
expr_stmt|;
name|dest_lid_ho
operator|=
name|dest_lid_min_ho
expr_stmt|;
comment|/* 	   Preferred paths come first in OpenSM 	 */
name|preference
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|path_num
operator|<
name|rem_paths
condition|)
block|{
comment|/* 		   These paths are "fully redundant" 		 */
name|p_pr_item
operator|=
name|mpr_rcv_get_lid_pair_path
argument_list|(
name|sa
argument_list|,
name|p_mpr
argument_list|,
name|p_src_alias_guid
argument_list|,
name|p_dest_alias_guid
argument_list|,
name|src_lid_ho
argument_list|,
name|dest_lid_ho
argument_list|,
name|comp_mask
argument_list|,
name|preference
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_pr_item
condition|)
block|{
name|cl_qlist_insert_tail
argument_list|(
name|p_list
argument_list|,
operator|&
name|p_pr_item
operator|->
name|list_item
argument_list|)
expr_stmt|;
operator|++
name|path_num
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|src_lid_ho
operator|>
name|src_lid_max_ho
condition|)
break|break;
if|if
condition|(
operator|++
name|dest_lid_ho
operator|>
name|dest_lid_max_ho
condition|)
break|break;
block|}
comment|/* 	   Check if we've accumulated all the paths that the user cares to see 	 */
if|if
condition|(
name|path_num
operator|==
name|rem_paths
condition|)
goto|goto
name|Exit
goto|;
comment|/* 	   Don't bother reporting preference 1 paths for now. 	   It's more trouble than it's worth and can only occur 	   if ports have different LMC values, which isn't supported 	   by OpenSM right now anyway. 	 */
name|preference
operator|=
literal|2
expr_stmt|;
name|src_lid_ho
operator|=
name|src_lid_min_ho
expr_stmt|;
name|dest_lid_ho
operator|=
name|dest_lid_min_ho
expr_stmt|;
name|src_offset
operator|=
literal|0
expr_stmt|;
name|dest_offset
operator|=
literal|0
expr_stmt|;
comment|/* 	   Iterate over the remaining paths 	 */
while|while
condition|(
name|path_num
operator|<
name|rem_paths
condition|)
block|{
name|dest_offset
operator|++
expr_stmt|;
name|dest_lid_ho
operator|++
expr_stmt|;
if|if
condition|(
name|dest_lid_ho
operator|>
name|dest_lid_max_ho
condition|)
block|{
name|src_offset
operator|++
expr_stmt|;
name|src_lid_ho
operator|++
expr_stmt|;
if|if
condition|(
name|src_lid_ho
operator|>
name|src_lid_max_ho
condition|)
break|break;
comment|/* done */
name|dest_offset
operator|=
literal|0
expr_stmt|;
name|dest_lid_ho
operator|=
name|dest_lid_min_ho
expr_stmt|;
block|}
comment|/* 		   These paths are "fully non-redundant" with paths already 		   identified above and consequently not of much value.  		   Don't return paths we already identified above, as indicated 		   by the offset values being equal. 		 */
if|if
condition|(
name|src_offset
operator|==
name|dest_offset
condition|)
continue|continue;
comment|/* already reported */
name|p_pr_item
operator|=
name|mpr_rcv_get_lid_pair_path
argument_list|(
name|sa
argument_list|,
name|p_mpr
argument_list|,
name|p_src_alias_guid
argument_list|,
name|p_dest_alias_guid
argument_list|,
name|src_lid_ho
argument_list|,
name|dest_lid_ho
argument_list|,
name|comp_mask
argument_list|,
name|preference
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_pr_item
condition|)
block|{
name|cl_qlist_insert_tail
argument_list|(
name|p_list
argument_list|,
operator|&
name|p_pr_item
operator|->
name|list_item
argument_list|)
expr_stmt|;
operator|++
name|path_num
expr_stmt|;
block|}
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|path_num
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|min
end_undef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x)< (y)) ? (x) : (y))
end_define

begin_function
specifier|static
name|osm_sa_item_t
modifier|*
name|mpr_rcv_get_apm_port_pair_paths
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|ib_multipath_rec_t
modifier|*
name|p_mpr
parameter_list|,
name|IN
specifier|const
name|osm_alias_guid_t
modifier|*
name|p_src_alias_guid
parameter_list|,
name|IN
specifier|const
name|osm_alias_guid_t
modifier|*
name|p_dest_alias_guid
parameter_list|,
name|IN
name|int
name|base_offs
parameter_list|,
name|IN
specifier|const
name|ib_net64_t
name|comp_mask
parameter_list|,
name|IN
name|cl_qlist_t
modifier|*
name|p_list
parameter_list|)
block|{
name|osm_sa_item_t
modifier|*
name|p_pr_item
init|=
literal|0
decl_stmt|;
name|uint16_t
name|src_lid_min_ho
decl_stmt|;
name|uint16_t
name|src_lid_max_ho
decl_stmt|;
name|uint16_t
name|dest_lid_min_ho
decl_stmt|;
name|uint16_t
name|dest_lid_max_ho
decl_stmt|;
name|uint16_t
name|src_lid_ho
decl_stmt|;
name|uint16_t
name|dest_lid_ho
decl_stmt|;
name|unsigned
name|iterations
decl_stmt|;
name|int
name|src_lids
decl_stmt|,
name|dest_lids
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Src port 0x%016"
name|PRIx64
literal|", "
literal|"Dst port 0x%016"
name|PRIx64
literal|", base offs %d\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_src_alias_guid
operator|->
name|alias_guid
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_dest_alias_guid
operator|->
name|alias_guid
argument_list|)
argument_list|,
name|base_offs
argument_list|)
expr_stmt|;
name|osm_port_get_lid_range_ho
argument_list|(
name|p_src_alias_guid
operator|->
name|p_base_port
argument_list|,
operator|&
name|src_lid_min_ho
argument_list|,
operator|&
name|src_lid_max_ho
argument_list|)
expr_stmt|;
name|osm_port_get_lid_range_ho
argument_list|(
name|p_dest_alias_guid
operator|->
name|p_base_port
argument_list|,
operator|&
name|dest_lid_min_ho
argument_list|,
operator|&
name|dest_lid_max_ho
argument_list|)
expr_stmt|;
name|src_lid_ho
operator|=
name|src_lid_min_ho
expr_stmt|;
name|dest_lid_ho
operator|=
name|dest_lid_min_ho
expr_stmt|;
name|src_lids
operator|=
name|src_lid_max_ho
operator|-
name|src_lid_min_ho
operator|+
literal|1
expr_stmt|;
name|dest_lids
operator|=
name|dest_lid_max_ho
operator|-
name|dest_lid_min_ho
operator|+
literal|1
expr_stmt|;
name|src_lid_ho
operator|+=
name|base_offs
operator|%
name|src_lids
expr_stmt|;
name|dest_lid_ho
operator|+=
name|base_offs
operator|%
name|dest_lids
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Src LIDs [%u-%u] hashed %u, "
literal|"Dest LIDs [%u-%u] hashed %u\n"
argument_list|,
name|src_lid_min_ho
argument_list|,
name|src_lid_max_ho
argument_list|,
name|src_lid_ho
argument_list|,
name|dest_lid_min_ho
argument_list|,
name|dest_lid_max_ho
argument_list|,
name|dest_lid_ho
argument_list|)
expr_stmt|;
name|iterations
operator|=
name|min
argument_list|(
name|src_lids
argument_list|,
name|dest_lids
argument_list|)
expr_stmt|;
while|while
condition|(
name|iterations
operator|--
condition|)
block|{
comment|/* 		   These paths are "fully redundant" 		 */
name|p_pr_item
operator|=
name|mpr_rcv_get_lid_pair_path
argument_list|(
name|sa
argument_list|,
name|p_mpr
argument_list|,
name|p_src_alias_guid
argument_list|,
name|p_dest_alias_guid
argument_list|,
name|src_lid_ho
argument_list|,
name|dest_lid_ho
argument_list|,
name|comp_mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_pr_item
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Found matching path from Src LID %u to Dest LID %u with %d hops\n"
argument_list|,
name|src_lid_ho
argument_list|,
name|dest_lid_ho
argument_list|,
name|p_pr_item
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|hops
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|++
name|src_lid_ho
operator|>
name|src_lid_max_ho
condition|)
name|src_lid_ho
operator|=
name|src_lid_min_ho
expr_stmt|;
if|if
condition|(
operator|++
name|dest_lid_ho
operator|>
name|dest_lid_max_ho
condition|)
name|dest_lid_ho
operator|=
name|dest_lid_min_ho
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|p_pr_item
return|;
block|}
end_function

begin_function
specifier|static
name|ib_net16_t
name|mpr_rcv_get_gids
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|ib_gid_t
modifier|*
name|gids
parameter_list|,
name|IN
name|int
name|ngids
parameter_list|,
name|IN
name|int
name|is_sgid
parameter_list|,
name|OUT
name|osm_alias_guid_t
modifier|*
modifier|*
name|pp_alias_guid
parameter_list|)
block|{
name|osm_alias_guid_t
modifier|*
name|p_alias_guid
decl_stmt|;
name|ib_net16_t
name|ib_status
init|=
name|IB_SUCCESS
decl_stmt|;
name|int
name|i
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngids
condition|;
name|i
operator|++
operator|,
name|gids
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ib_gid_is_link_local
argument_list|(
name|gids
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|is_sgid
operator|&&
name|ib_gid_is_multicast
argument_list|(
name|gids
argument_list|)
operator|)
operator|||
operator|(
name|ib_gid_get_subnet_prefix
argument_list|(
name|gids
argument_list|)
operator|!=
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|subnet_prefix
operator|)
condition|)
block|{
comment|/* 				   This 'error' is the client's fault (bad gid) 				   so don't enter it as an error in our own log. 				   Return an error response to the client. 				 */
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"ERR 451B: "
literal|"%sGID 0x%016"
name|PRIx64
literal|" is multicast or non local subnet prefix\n"
argument_list|,
name|is_sgid
condition|?
literal|"S"
else|:
literal|"D"
argument_list|,
name|cl_ntoh64
argument_list|(
name|gids
operator|->
name|unicast
operator|.
name|prefix
argument_list|)
argument_list|)
expr_stmt|;
name|ib_status
operator|=
name|IB_SA_MAD_STATUS_INVALID_GID
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
name|p_alias_guid
operator|=
name|osm_get_alias_guid_by_guid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|gids
operator|->
name|unicast
operator|.
name|interface_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_alias_guid
condition|)
block|{
comment|/* 			   This 'error' is the client's fault (bad gid) so 			   don't enter it as an error in our own log. 			   Return an error response to the client. 			 */
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4506: "
literal|"No port with GUID 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|gids
operator|->
name|unicast
operator|.
name|interface_id
argument_list|)
argument_list|)
expr_stmt|;
name|ib_status
operator|=
name|IB_SA_MAD_STATUS_INVALID_GID
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|pp_alias_guid
index|[
name|i
index|]
operator|=
name|p_alias_guid
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|ib_status
return|;
block|}
end_function

begin_function
specifier|static
name|ib_net16_t
name|mpr_rcv_get_end_points
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|,
name|OUT
name|osm_alias_guid_t
modifier|*
modifier|*
name|pp_alias_guids
parameter_list|,
name|OUT
name|int
modifier|*
name|nsrc
parameter_list|,
name|OUT
name|int
modifier|*
name|ndest
parameter_list|)
block|{
specifier|const
name|ib_multipath_rec_t
modifier|*
name|p_mpr
decl_stmt|;
specifier|const
name|ib_sa_mad_t
modifier|*
name|p_sa_mad
decl_stmt|;
name|ib_net64_t
name|comp_mask
decl_stmt|;
name|ib_net16_t
name|sa_status
init|=
name|IB_SA_MAD_STATUS_SUCCESS
decl_stmt|;
name|ib_gid_t
modifier|*
name|gids
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	   Determine what fields are valid and then get a pointer 	   to the source and destination port objects, if possible. 	 */
name|p_sa_mad
operator|=
name|osm_madw_get_sa_mad_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_mpr
operator|=
operator|(
name|ib_multipath_rec_t
operator|*
operator|)
name|ib_sa_mad_get_payload_ptr
argument_list|(
name|p_sa_mad
argument_list|)
expr_stmt|;
name|gids
operator|=
operator|(
name|ib_gid_t
operator|*
operator|)
name|p_mpr
operator|->
name|gids
expr_stmt|;
name|comp_mask
operator|=
name|p_sa_mad
operator|->
name|comp_mask
expr_stmt|;
comment|/* 	   Check a few easy disqualifying cases up front before getting 	   into the endpoints. 	 */
operator|*
name|nsrc
operator|=
operator|*
name|ndest
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|comp_mask
operator|&
name|IB_MPR_COMPMASK_SGIDCOUNT
condition|)
block|{
operator|*
name|nsrc
operator|=
name|p_mpr
operator|->
name|sgid_count
expr_stmt|;
if|if
condition|(
operator|*
name|nsrc
operator|>
name|IB_MULTIPATH_MAX_GIDS
condition|)
operator|*
name|nsrc
operator|=
name|IB_MULTIPATH_MAX_GIDS
expr_stmt|;
name|sa_status
operator|=
name|mpr_rcv_get_gids
argument_list|(
name|sa
argument_list|,
name|gids
argument_list|,
operator|*
name|nsrc
argument_list|,
literal|1
argument_list|,
name|pp_alias_guids
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa_status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|comp_mask
operator|&
name|IB_MPR_COMPMASK_DGIDCOUNT
condition|)
block|{
operator|*
name|ndest
operator|=
name|p_mpr
operator|->
name|dgid_count
expr_stmt|;
if|if
condition|(
operator|*
name|ndest
operator|+
operator|*
name|nsrc
operator|>
name|IB_MULTIPATH_MAX_GIDS
condition|)
operator|*
name|ndest
operator|=
name|IB_MULTIPATH_MAX_GIDS
operator|-
operator|*
name|nsrc
expr_stmt|;
name|sa_status
operator|=
name|mpr_rcv_get_gids
argument_list|(
name|sa
argument_list|,
name|gids
operator|+
operator|*
name|nsrc
argument_list|,
operator|*
name|ndest
argument_list|,
literal|0
argument_list|,
name|pp_alias_guids
operator|+
operator|*
name|nsrc
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|sa_status
return|;
block|}
end_function

begin_define
define|#
directive|define
name|hash_lids
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|lmc
parameter_list|)
define|\
value|(((((a)>> (lmc))<< 4) | ((b)>> (lmc))) % 103)
end_define

begin_function
specifier|static
name|void
name|mpr_rcv_get_apm_paths
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|ib_multipath_rec_t
modifier|*
name|p_mpr
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
name|p_req_port
parameter_list|,
name|IN
name|osm_alias_guid_t
modifier|*
modifier|*
name|_pp_alias_guids
parameter_list|,
name|IN
specifier|const
name|ib_net64_t
name|comp_mask
parameter_list|,
name|IN
name|cl_qlist_t
modifier|*
name|p_list
parameter_list|)
block|{
name|osm_alias_guid_t
modifier|*
name|pp_alias_guids
index|[
literal|4
index|]
decl_stmt|;
name|osm_sa_item_t
modifier|*
name|matrix
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
name|int
name|base_offs
decl_stmt|,
name|src_lid_ho
decl_stmt|,
name|dest_lid_ho
decl_stmt|;
name|int
name|sumA
decl_stmt|,
name|sumB
decl_stmt|,
name|minA
decl_stmt|,
name|minB
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	 * We want to: 	 *    1. use different lid offsets (from base) for the resultant paths 	 *    to increase the probability of redundant paths or in case 	 *    of Clos - to ensure it (different offset => different spine!) 	 *    2. keep consistent paths no matter of direction and order of ports 	 *    3. distibute the lid offsets to balance the load 	 * So, we sort the ports (within the srcs, and within the dests), 	 * hash the lids of S0, D0 (after the sort), and call mpr_rcv_get_apm_port_pair_paths 	 * with base_lid for S0, D0 and base_lid + 1 for S1, D1. This way we will get 	 * always the same offsets - order independent, and make sure different spines are used. 	 * Note that the diagonals on a Clos have the same number of hops, so it doesn't 	 * really matter which diagonal we use. 	 */
if|if
condition|(
name|_pp_alias_guids
index|[
literal|0
index|]
operator|->
name|p_base_port
operator|->
name|guid
operator|<
name|_pp_alias_guids
index|[
literal|1
index|]
operator|->
name|p_base_port
operator|->
name|guid
condition|)
block|{
name|pp_alias_guids
index|[
literal|0
index|]
operator|=
name|_pp_alias_guids
index|[
literal|0
index|]
expr_stmt|;
name|pp_alias_guids
index|[
literal|1
index|]
operator|=
name|_pp_alias_guids
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|pp_alias_guids
index|[
literal|0
index|]
operator|=
name|_pp_alias_guids
index|[
literal|1
index|]
expr_stmt|;
name|pp_alias_guids
index|[
literal|1
index|]
operator|=
name|_pp_alias_guids
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
name|_pp_alias_guids
index|[
literal|2
index|]
operator|->
name|p_base_port
operator|->
name|guid
operator|<
name|_pp_alias_guids
index|[
literal|3
index|]
operator|->
name|p_base_port
operator|->
name|guid
condition|)
block|{
name|pp_alias_guids
index|[
literal|2
index|]
operator|=
name|_pp_alias_guids
index|[
literal|2
index|]
expr_stmt|;
name|pp_alias_guids
index|[
literal|3
index|]
operator|=
name|_pp_alias_guids
index|[
literal|3
index|]
expr_stmt|;
block|}
else|else
block|{
name|pp_alias_guids
index|[
literal|2
index|]
operator|=
name|_pp_alias_guids
index|[
literal|3
index|]
expr_stmt|;
name|pp_alias_guids
index|[
literal|3
index|]
operator|=
name|_pp_alias_guids
index|[
literal|2
index|]
expr_stmt|;
block|}
name|src_lid_ho
operator|=
name|osm_port_get_base_lid
argument_list|(
name|pp_alias_guids
index|[
literal|0
index|]
operator|->
name|p_base_port
argument_list|)
expr_stmt|;
name|dest_lid_ho
operator|=
name|osm_port_get_base_lid
argument_list|(
name|pp_alias_guids
index|[
literal|2
index|]
operator|->
name|p_base_port
argument_list|)
expr_stmt|;
name|base_offs
operator|=
name|src_lid_ho
operator|<
name|dest_lid_ho
condition|?
name|hash_lids
argument_list|(
name|src_lid_ho
argument_list|,
name|dest_lid_ho
argument_list|,
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|lmc
argument_list|)
else|:
name|hash_lids
argument_list|(
name|dest_lid_ho
argument_list|,
name|src_lid_ho
argument_list|,
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|lmc
argument_list|)
expr_stmt|;
name|matrix
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|mpr_rcv_get_apm_port_pair_paths
argument_list|(
name|sa
argument_list|,
name|p_mpr
argument_list|,
name|pp_alias_guids
index|[
literal|0
index|]
argument_list|,
name|pp_alias_guids
index|[
literal|2
index|]
argument_list|,
name|base_offs
argument_list|,
name|comp_mask
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
name|matrix
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|mpr_rcv_get_apm_port_pair_paths
argument_list|(
name|sa
argument_list|,
name|p_mpr
argument_list|,
name|pp_alias_guids
index|[
literal|0
index|]
argument_list|,
name|pp_alias_guids
index|[
literal|3
index|]
argument_list|,
name|base_offs
argument_list|,
name|comp_mask
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
name|matrix
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|mpr_rcv_get_apm_port_pair_paths
argument_list|(
name|sa
argument_list|,
name|p_mpr
argument_list|,
name|pp_alias_guids
index|[
literal|1
index|]
argument_list|,
name|pp_alias_guids
index|[
literal|2
index|]
argument_list|,
name|base_offs
operator|+
literal|1
argument_list|,
name|comp_mask
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
name|matrix
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|mpr_rcv_get_apm_port_pair_paths
argument_list|(
name|sa
argument_list|,
name|p_mpr
argument_list|,
name|pp_alias_guids
index|[
literal|1
index|]
argument_list|,
name|pp_alias_guids
index|[
literal|3
index|]
argument_list|,
name|base_offs
operator|+
literal|1
argument_list|,
name|comp_mask
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"APM matrix:\n"
literal|"\t{0,0} 0x%X->0x%X (%d)\t| {0,1} 0x%X->0x%X (%d)\n"
literal|"\t{1,0} 0x%X->0x%X (%d)\t| {1,1} 0x%X->0x%X (%d)\n"
argument_list|,
name|matrix
index|[
literal|0
index|]
index|[
literal|0
index|]
condition|?
name|matrix
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|path_rec
operator|.
name|slid
else|:
literal|0
argument_list|,
name|matrix
index|[
literal|0
index|]
index|[
literal|0
index|]
condition|?
name|matrix
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|path_rec
operator|.
name|dlid
else|:
literal|0
argument_list|,
name|matrix
index|[
literal|0
index|]
index|[
literal|0
index|]
condition|?
name|matrix
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|hops
else|:
literal|0
argument_list|,
name|matrix
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|?
name|matrix
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|path_rec
operator|.
name|slid
else|:
literal|0
argument_list|,
name|matrix
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|?
name|matrix
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|path_rec
operator|.
name|dlid
else|:
literal|0
argument_list|,
name|matrix
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|?
name|matrix
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|hops
else|:
literal|0
argument_list|,
name|matrix
index|[
literal|1
index|]
index|[
literal|0
index|]
condition|?
name|matrix
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|path_rec
operator|.
name|slid
else|:
literal|0
argument_list|,
name|matrix
index|[
literal|1
index|]
index|[
literal|0
index|]
condition|?
name|matrix
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|path_rec
operator|.
name|dlid
else|:
literal|0
argument_list|,
name|matrix
index|[
literal|1
index|]
index|[
literal|0
index|]
condition|?
name|matrix
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|hops
else|:
literal|0
argument_list|,
name|matrix
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|?
name|matrix
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|path_rec
operator|.
name|slid
else|:
literal|0
argument_list|,
name|matrix
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|?
name|matrix
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|path_rec
operator|.
name|dlid
else|:
literal|0
argument_list|,
name|matrix
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|?
name|matrix
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|hops
else|:
literal|0
argument_list|)
expr_stmt|;
name|sumA
operator|=
name|minA
operator|=
name|sumB
operator|=
name|minB
operator|=
literal|0
expr_stmt|;
comment|/* check diagonal A {(0,0), (1,1)} */
if|if
condition|(
name|matrix
index|[
literal|0
index|]
index|[
literal|0
index|]
condition|)
block|{
name|sumA
operator|+=
name|matrix
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|hops
expr_stmt|;
name|minA
operator|=
name|matrix
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|hops
expr_stmt|;
block|}
if|if
condition|(
name|matrix
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|)
block|{
name|sumA
operator|+=
name|matrix
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|hops
expr_stmt|;
if|if
condition|(
name|minA
condition|)
name|minA
operator|=
name|min
argument_list|(
name|minA
argument_list|,
name|matrix
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|hops
argument_list|)
expr_stmt|;
else|else
name|minA
operator|=
name|matrix
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|hops
expr_stmt|;
block|}
comment|/* check diagonal B {(0,1), (1,0)} */
if|if
condition|(
name|matrix
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|)
block|{
name|sumB
operator|+=
name|matrix
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|hops
expr_stmt|;
name|minB
operator|=
name|matrix
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|hops
expr_stmt|;
block|}
if|if
condition|(
name|matrix
index|[
literal|1
index|]
index|[
literal|0
index|]
condition|)
block|{
name|sumB
operator|+=
name|matrix
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|hops
expr_stmt|;
if|if
condition|(
name|minB
condition|)
name|minB
operator|=
name|min
argument_list|(
name|minB
argument_list|,
name|matrix
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|hops
argument_list|)
expr_stmt|;
else|else
name|minB
operator|=
name|matrix
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|hops
expr_stmt|;
block|}
comment|/* and the winner is... */
if|if
condition|(
name|minA
operator|<=
name|minB
operator|||
operator|(
name|minA
operator|==
name|minB
operator|&&
name|sumA
operator|<
name|sumB
operator|)
condition|)
block|{
comment|/* Diag A */
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Diag {0,0}& {1,1} is the best:\n"
literal|"\t{0,0} 0x%X->0x%X (%d)\t& {1,1} 0x%X->0x%X (%d)\n"
argument_list|,
name|matrix
index|[
literal|0
index|]
index|[
literal|0
index|]
condition|?
name|matrix
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|path_rec
operator|.
name|slid
else|:
literal|0
argument_list|,
name|matrix
index|[
literal|0
index|]
index|[
literal|0
index|]
condition|?
name|matrix
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|path_rec
operator|.
name|dlid
else|:
literal|0
argument_list|,
name|matrix
index|[
literal|0
index|]
index|[
literal|0
index|]
condition|?
name|matrix
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|hops
else|:
literal|0
argument_list|,
name|matrix
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|?
name|matrix
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|path_rec
operator|.
name|slid
else|:
literal|0
argument_list|,
name|matrix
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|?
name|matrix
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|path_rec
operator|.
name|dlid
else|:
literal|0
argument_list|,
name|matrix
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|?
name|matrix
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|hops
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|matrix
index|[
literal|0
index|]
index|[
literal|0
index|]
condition|)
name|cl_qlist_insert_tail
argument_list|(
name|p_list
argument_list|,
operator|&
name|matrix
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|->
name|list_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|matrix
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|)
name|cl_qlist_insert_tail
argument_list|(
name|p_list
argument_list|,
operator|&
name|matrix
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|->
name|list_item
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matrix
index|[
literal|0
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matrix
index|[
literal|1
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Diag B */
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Diag {0,1}& {1,0} is the best:\n"
literal|"\t{0,1} 0x%X->0x%X (%d)\t& {1,0} 0x%X->0x%X (%d)\n"
argument_list|,
name|matrix
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|?
name|matrix
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|path_rec
operator|.
name|slid
else|:
literal|0
argument_list|,
name|matrix
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|?
name|matrix
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|path_rec
operator|.
name|dlid
else|:
literal|0
argument_list|,
name|matrix
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|?
name|matrix
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|hops
else|:
literal|0
argument_list|,
name|matrix
index|[
literal|1
index|]
index|[
literal|0
index|]
condition|?
name|matrix
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|path_rec
operator|.
name|slid
else|:
literal|0
argument_list|,
name|matrix
index|[
literal|1
index|]
index|[
literal|0
index|]
condition|?
name|matrix
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|path_rec
operator|.
name|dlid
else|:
literal|0
argument_list|,
name|matrix
index|[
literal|1
index|]
index|[
literal|0
index|]
condition|?
name|matrix
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|->
name|resp
operator|.
name|mpr_rec
operator|.
name|hops
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|matrix
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|)
name|cl_qlist_insert_tail
argument_list|(
name|p_list
argument_list|,
operator|&
name|matrix
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|->
name|list_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|matrix
index|[
literal|1
index|]
index|[
literal|0
index|]
condition|)
name|cl_qlist_insert_tail
argument_list|(
name|p_list
argument_list|,
operator|&
name|matrix
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|->
name|list_item
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matrix
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|matrix
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpr_rcv_process_pairs
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|ib_multipath_rec_t
modifier|*
name|p_mpr
parameter_list|,
name|IN
name|osm_port_t
modifier|*
name|p_req_port
parameter_list|,
name|IN
name|osm_alias_guid_t
modifier|*
modifier|*
name|pp_alias_guids
parameter_list|,
name|IN
specifier|const
name|int
name|nsrc
parameter_list|,
name|IN
name|int
name|ndest
parameter_list|,
name|IN
name|ib_net64_t
name|comp_mask
parameter_list|,
name|IN
name|cl_qlist_t
modifier|*
name|p_list
parameter_list|)
block|{
name|osm_alias_guid_t
modifier|*
modifier|*
name|pp_src_alias_guid
decl_stmt|,
modifier|*
modifier|*
name|pp_es
decl_stmt|;
name|osm_alias_guid_t
modifier|*
modifier|*
name|pp_dest_alias_guid
decl_stmt|,
modifier|*
modifier|*
name|pp_ed
decl_stmt|;
name|uint32_t
name|max_paths
decl_stmt|,
name|num_paths
decl_stmt|,
name|total_paths
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp_mask
operator|&
name|IB_MPR_COMPMASK_NUMBPATH
condition|)
name|max_paths
operator|=
name|p_mpr
operator|->
name|num_path
operator|&
literal|0x7F
expr_stmt|;
else|else
name|max_paths
operator|=
name|OSM_SA_MPR_MAX_NUM_PATH
expr_stmt|;
for|for
control|(
name|pp_src_alias_guid
operator|=
name|pp_alias_guids
operator|,
name|pp_es
operator|=
name|pp_alias_guids
operator|+
name|nsrc
init|;
name|pp_src_alias_guid
operator|<
name|pp_es
condition|;
name|pp_src_alias_guid
operator|++
control|)
block|{
for|for
control|(
name|pp_dest_alias_guid
operator|=
name|pp_es
operator|,
name|pp_ed
operator|=
name|pp_es
operator|+
name|ndest
init|;
name|pp_dest_alias_guid
operator|<
name|pp_ed
condition|;
name|pp_dest_alias_guid
operator|++
control|)
block|{
name|num_paths
operator|=
name|mpr_rcv_get_port_pair_paths
argument_list|(
name|sa
argument_list|,
name|p_mpr
argument_list|,
name|p_req_port
argument_list|,
operator|*
name|pp_src_alias_guid
argument_list|,
operator|*
name|pp_dest_alias_guid
argument_list|,
name|max_paths
operator|-
name|total_paths
argument_list|,
name|comp_mask
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
name|total_paths
operator|+=
name|num_paths
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"%d paths %d total paths %d max paths\n"
argument_list|,
name|num_paths
argument_list|,
name|total_paths
argument_list|,
name|max_paths
argument_list|)
expr_stmt|;
comment|/* Just take first NumbPaths found */
if|if
condition|(
name|total_paths
operator|>=
name|max_paths
condition|)
goto|goto
name|Exit
goto|;
block|}
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_mpr_rcv_process
parameter_list|(
name|IN
name|void
modifier|*
name|context
parameter_list|,
name|IN
name|void
modifier|*
name|data
parameter_list|)
block|{
name|osm_sa_t
modifier|*
name|sa
init|=
name|context
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_madw
init|=
name|data
decl_stmt|;
specifier|const
name|ib_multipath_rec_t
modifier|*
name|p_mpr
decl_stmt|;
name|ib_sa_mad_t
modifier|*
name|p_sa_mad
decl_stmt|;
name|osm_port_t
modifier|*
name|requester_port
decl_stmt|;
name|osm_alias_guid_t
modifier|*
name|pp_alias_guids
index|[
name|IB_MULTIPATH_MAX_GIDS
index|]
decl_stmt|;
name|cl_qlist_t
name|pr_list
decl_stmt|;
name|ib_net16_t
name|sa_status
decl_stmt|;
name|int
name|nsrc
decl_stmt|,
name|ndest
decl_stmt|;
name|uint8_t
name|rate
decl_stmt|,
name|mtu
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_sa_mad
operator|=
name|osm_madw_get_sa_mad_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_mpr
operator|=
operator|(
name|ib_multipath_rec_t
operator|*
operator|)
name|ib_sa_mad_get_payload_ptr
argument_list|(
name|p_sa_mad
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_sa_mad
operator|->
name|attr_id
operator|==
name|IB_MAD_ATTR_MULTIPATH_RECORD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_sa_mad
operator|->
name|rmpp_flags
operator|&
name|IB_RMPP_FLAG_ACTIVE
operator|)
operator|!=
name|IB_RMPP_FLAG_ACTIVE
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4510: "
literal|"Invalid request since RMPP_FLAG_ACTIVE is not set\n"
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* we only support SubnAdmGetMulti method */
if|if
condition|(
name|p_sa_mad
operator|->
name|method
operator|!=
name|IB_MAD_METHOD_GETMULTI
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4513: "
literal|"Unsupported Method (%s) for MultiPathRecord request\n"
argument_list|,
name|ib_get_sa_method_str
argument_list|(
name|p_sa_mad
operator|->
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_MAD_STATUS_UNSUP_METHOD_ATTR
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
name|osm_dump_multipath_record_v2
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_mpr
argument_list|,
name|FILE_ID
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
expr_stmt|;
comment|/* Make sure required components (S/DGIDCount) are supplied */
if|if
condition|(
operator|!
operator|(
name|p_sa_mad
operator|->
name|comp_mask
operator|&
name|IB_MPR_COMPMASK_SGIDCOUNT
operator|)
operator|||
operator|!
operator|(
name|p_sa_mad
operator|->
name|comp_mask
operator|&
name|IB_MPR_COMPMASK_DGIDCOUNT
operator|)
condition|)
block|{
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_INSUF_COMPS
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Validate rate if supplied */
if|if
condition|(
operator|(
name|p_sa_mad
operator|->
name|comp_mask
operator|&
name|IB_MPR_COMPMASK_RATESELEC
operator|)
operator|&&
operator|(
name|p_sa_mad
operator|->
name|comp_mask
operator|&
name|IB_MPR_COMPMASK_RATE
operator|)
condition|)
block|{
name|rate
operator|=
name|ib_multipath_rec_rate
argument_list|(
name|p_mpr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ib_rate_is_valid
argument_list|(
name|rate
argument_list|)
condition|)
block|{
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/* Validate MTU if supplied */
if|if
condition|(
operator|(
name|p_sa_mad
operator|->
name|comp_mask
operator|&
name|IB_MPR_COMPMASK_MTUSELEC
operator|)
operator|&&
operator|(
name|p_sa_mad
operator|->
name|comp_mask
operator|&
name|IB_MPR_COMPMASK_MTU
operator|)
condition|)
block|{
name|mtu
operator|=
name|ib_multipath_rec_mtu
argument_list|(
name|p_mpr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ib_mtu_is_valid
argument_list|(
name|mtu
argument_list|)
condition|)
block|{
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/* Make sure either none or both ServiceID parameters are supplied */
if|if
condition|(
operator|(
name|p_sa_mad
operator|->
name|comp_mask
operator|&
name|IB_MPR_COMPMASK_SERVICEID
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|p_sa_mad
operator|->
name|comp_mask
operator|&
name|IB_MPR_COMPMASK_SERVICEID
operator|)
operator|!=
name|IB_MPR_COMPMASK_SERVICEID
condition|)
block|{
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_INSUF_COMPS
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|cl_qlist_init
argument_list|(
operator|&
name|pr_list
argument_list|)
expr_stmt|;
comment|/* 	   Most SA functions (including this one) are read-only on the 	   subnet object, so we grab the lock non-exclusively. 	 */
name|cl_plock_acquire
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
comment|/* update the requester physical port */
name|requester_port
operator|=
name|osm_get_port_by_mad_addr
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|sa
operator|->
name|p_subn
argument_list|,
name|osm_madw_get_mad_addr_ptr
argument_list|(
name|p_madw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|requester_port
operator|==
name|NULL
condition|)
block|{
name|cl_plock_release
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4517: "
literal|"Cannot find requester physical port\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Requester port GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_port_get_guid
argument_list|(
name|requester_port
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sa_status
operator|=
name|mpr_rcv_get_end_points
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|pp_alias_guids
argument_list|,
operator|&
name|nsrc
argument_list|,
operator|&
name|ndest
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa_status
operator|!=
name|IB_SA_MAD_STATUS_SUCCESS
operator|||
operator|!
name|nsrc
operator|||
operator|!
name|ndest
condition|)
block|{
name|cl_plock_release
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa_status
operator|==
name|IB_SA_MAD_STATUS_SUCCESS
operator|&&
operator|(
operator|!
name|nsrc
operator|||
operator|!
name|ndest
operator|)
condition|)
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4512: "
literal|"mpr_rcv_get_end_points failed, # GIDs found; "
literal|"src %d; dest %d)\n"
argument_list|,
name|nsrc
argument_list|,
name|ndest
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa_status
operator|==
name|IB_SA_MAD_STATUS_SUCCESS
condition|)
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
else|else
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|sa_status
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* APM request */
if|if
condition|(
name|nsrc
operator|==
literal|2
operator|&&
name|ndest
operator|==
literal|2
operator|&&
operator|(
name|p_mpr
operator|->
name|num_path
operator|&
literal|0x7F
operator|)
operator|==
literal|2
condition|)
name|mpr_rcv_get_apm_paths
argument_list|(
name|sa
argument_list|,
name|p_mpr
argument_list|,
name|requester_port
argument_list|,
name|pp_alias_guids
argument_list|,
name|p_sa_mad
operator|->
name|comp_mask
argument_list|,
operator|&
name|pr_list
argument_list|)
expr_stmt|;
else|else
name|mpr_rcv_process_pairs
argument_list|(
name|sa
argument_list|,
name|p_mpr
argument_list|,
name|requester_port
argument_list|,
name|pp_alias_guids
argument_list|,
name|nsrc
argument_list|,
name|ndest
argument_list|,
name|p_sa_mad
operator|->
name|comp_mask
argument_list|,
operator|&
name|pr_list
argument_list|)
expr_stmt|;
name|cl_plock_release
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
comment|/* o15-0.2.7: If MultiPath is supported, then SA shall respond to a 	   SubnAdmGetMulti() containing a valid MultiPathRecord attribute with 	   a set of zero or more PathRecords satisfying the constraints 	   indicated in the MultiPathRecord received. The PathRecord Attribute 	   ID shall be used in the response. 	 */
name|p_sa_mad
operator|->
name|attr_id
operator|=
name|IB_MAD_ATTR_PATH_RECORD
expr_stmt|;
name|osm_sa_respond
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_path_rec_t
argument_list|)
argument_list|,
operator|&
name|pr_list
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

