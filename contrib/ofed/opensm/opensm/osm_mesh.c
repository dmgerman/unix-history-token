begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2008-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 2008,2009      System Fabric Works, Inc. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *      routines to analyze certain meshes  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_MESH_C
end_define

begin_include
include|#
directive|include
file|<opensm/osm_switch.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_mesh.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_ucast_lash.h>
end_include

begin_define
define|#
directive|define
name|MAX_DEGREE
value|(8)
end_define

begin_define
define|#
directive|define
name|MAX_DIMENSION
value|(8)
end_define

begin_define
define|#
directive|define
name|LARGE
value|(0x7fffffff)
end_define

begin_comment
comment|/*  * characteristic polynomials for selected 1d through 8d tori  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
name|mesh_info
block|{
name|int
name|dimension
decl_stmt|;
comment|/* dimension of the torus */
name|int
name|size
index|[
name|MAX_DIMENSION
index|]
decl_stmt|;
comment|/* size of the torus */
name|unsigned
name|int
name|degree
decl_stmt|;
comment|/* degree of polynomial */
name|int
name|poly
index|[
name|MAX_DEGREE
operator|+
literal|1
index|]
decl_stmt|;
comment|/* polynomial */
block|}
name|mesh_info
index|[]
init|=
block|{
block|{
literal|0
block|,
block|{
literal|0
block|}
block|,
literal|0
block|,
block|{
literal|0
block|}
block|,					}
block|,
block|{
literal|1
block|,
block|{
literal|2
block|}
block|,
literal|1
block|,
block|{
literal|0
block|,
operator|-
literal|1
block|}
block|,				}
block|,
block|{
literal|1
block|,
block|{
literal|3
block|}
block|,
literal|2
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|1
block|}
block|,				}
block|,
block|{
literal|1
block|,
block|{
literal|5
block|}
block|,
literal|2
block|,
block|{
operator|-
literal|9
block|,
literal|0
block|,
literal|1
block|}
block|,				}
block|,
block|{
literal|1
block|,
block|{
literal|6
block|}
block|,
literal|2
block|,
block|{
operator|-
literal|36
block|,
literal|0
block|,
literal|1
block|}
block|,				}
block|,
block|{
literal|2
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
literal|2
block|,
block|{
operator|-
literal|4
block|,
literal|0
block|,
literal|1
block|}
block|,				}
block|,
block|{
literal|2
block|,
block|{
literal|3
block|,
literal|2
block|}
block|,
literal|3
block|,
block|{
literal|8
block|,
literal|9
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,			}
block|,
block|{
literal|2
block|,
block|{
literal|5
block|,
literal|2
block|}
block|,
literal|3
block|,
block|{
literal|24
block|,
literal|17
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,			}
block|,
block|{
literal|2
block|,
block|{
literal|6
block|,
literal|2
block|}
block|,
literal|3
block|,
block|{
literal|32
block|,
literal|24
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,			}
block|,
block|{
literal|2
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
literal|4
block|,
block|{
operator|-
literal|15
block|,
operator|-
literal|32
block|,
operator|-
literal|18
block|,
literal|0
block|,
literal|1
block|}
block|,		}
block|,
block|{
literal|2
block|,
block|{
literal|5
block|,
literal|3
block|}
block|,
literal|4
block|,
block|{
operator|-
literal|39
block|,
operator|-
literal|64
block|,
operator|-
literal|26
block|,
literal|0
block|,
literal|1
block|}
block|,		}
block|,
block|{
literal|2
block|,
block|{
literal|6
block|,
literal|3
block|}
block|,
literal|4
block|,
block|{
operator|-
literal|48
block|,
operator|-
literal|80
block|,
operator|-
literal|33
block|,
literal|0
block|,
literal|1
block|}
block|,		}
block|,
block|{
literal|2
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
literal|4
block|,
block|{
operator|-
literal|63
block|,
operator|-
literal|96
block|,
operator|-
literal|34
block|,
literal|0
block|,
literal|1
block|}
block|,		}
block|,
block|{
literal|2
block|,
block|{
literal|6
block|,
literal|5
block|}
block|,
literal|4
block|,
block|{
operator|-
literal|48
block|,
operator|-
literal|112
block|,
operator|-
literal|41
block|,
literal|0
block|,
literal|1
block|}
block|,		}
block|,
block|{
literal|2
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
literal|4
block|,
block|{
literal|0
block|,
operator|-
literal|128
block|,
operator|-
literal|48
block|,
literal|0
block|,
literal|1
block|}
block|,			}
block|,
block|{
literal|3
block|,
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|3
block|,
block|{
literal|16
block|,
literal|12
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,			}
block|,
block|{
literal|3
block|,
block|{
literal|3
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|4
block|,
block|{
operator|-
literal|28
block|,
operator|-
literal|48
block|,
operator|-
literal|21
block|,
literal|0
block|,
literal|1
block|}
block|,		}
block|,
block|{
literal|3
block|,
block|{
literal|5
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|4
block|,
block|{
operator|-
literal|60
block|,
operator|-
literal|80
block|,
operator|-
literal|29
block|,
literal|0
block|,
literal|1
block|}
block|,		}
block|,
block|{
literal|3
block|,
block|{
literal|6
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|4
block|,
block|{
operator|-
literal|64
block|,
operator|-
literal|96
block|,
operator|-
literal|36
block|,
literal|0
block|,
literal|1
block|}
block|,		}
block|,
block|{
literal|3
block|,
block|{
literal|3
block|,
literal|3
block|,
literal|2
block|}
block|,
literal|5
block|,
block|{
literal|48
block|,
literal|127
block|,
literal|112
block|,
literal|34
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,		}
block|,
block|{
literal|3
block|,
block|{
literal|5
block|,
literal|3
block|,
literal|2
block|}
block|,
literal|5
block|,
block|{
literal|96
block|,
literal|215
block|,
literal|160
block|,
literal|42
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,		}
block|,
block|{
literal|3
block|,
block|{
literal|6
block|,
literal|3
block|,
literal|2
block|}
block|,
literal|5
block|,
block|{
literal|96
block|,
literal|232
block|,
literal|184
block|,
literal|49
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,		}
block|,
block|{
literal|3
block|,
block|{
literal|5
block|,
literal|5
block|,
literal|2
block|}
block|,
literal|5
block|,
block|{
literal|144
block|,
literal|303
block|,
literal|208
block|,
literal|50
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,		}
block|,
block|{
literal|3
block|,
block|{
literal|6
block|,
literal|5
block|,
literal|2
block|}
block|,
literal|5
block|,
block|{
literal|96
block|,
literal|296
block|,
literal|232
block|,
literal|57
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,		}
block|,
block|{
literal|3
block|,
block|{
literal|6
block|,
literal|6
block|,
literal|2
block|}
block|,
literal|5
block|,
block|{
literal|0
block|,
literal|256
block|,
literal|256
block|,
literal|64
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,		}
block|,
block|{
literal|3
block|,
block|{
literal|3
block|,
literal|3
block|,
literal|3
block|}
block|,
literal|6
block|,
block|{
operator|-
literal|81
block|,
operator|-
literal|288
block|,
operator|-
literal|381
block|,
operator|-
literal|224
block|,
operator|-
literal|51
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|3
block|,
block|{
literal|5
block|,
literal|3
block|,
literal|3
block|}
block|,
literal|6
block|,
block|{
operator|-
literal|153
block|,
operator|-
literal|480
block|,
operator|-
literal|557
block|,
operator|-
literal|288
block|,
operator|-
literal|59
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|3
block|,
block|{
literal|6
block|,
literal|3
block|,
literal|3
block|}
block|,
literal|6
block|,
block|{
operator|-
literal|144
block|,
operator|-
literal|480
block|,
operator|-
literal|591
block|,
operator|-
literal|320
block|,
operator|-
literal|66
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|3
block|,
block|{
literal|5
block|,
literal|5
block|,
literal|3
block|}
block|,
literal|6
block|,
block|{
operator|-
literal|225
block|,
operator|-
literal|672
block|,
operator|-
literal|733
block|,
operator|-
literal|352
block|,
operator|-
literal|67
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|3
block|,
block|{
literal|6
block|,
literal|5
block|,
literal|3
block|}
block|,
literal|6
block|,
block|{
operator|-
literal|144
block|,
operator|-
literal|576
block|,
operator|-
literal|743
block|,
operator|-
literal|384
block|,
operator|-
literal|74
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|3
block|,
block|{
literal|6
block|,
literal|6
block|,
literal|3
block|}
block|,
literal|6
block|,
block|{
literal|0
block|,
operator|-
literal|384
block|,
operator|-
literal|720
block|,
operator|-
literal|416
block|,
operator|-
literal|81
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|3
block|,
block|{
literal|5
block|,
literal|5
block|,
literal|5
block|}
block|,
literal|6
block|,
block|{
operator|-
literal|297
block|,
operator|-
literal|864
block|,
operator|-
literal|909
block|,
operator|-
literal|416
block|,
operator|-
literal|75
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|3
block|,
block|{
literal|6
block|,
literal|5
block|,
literal|5
block|}
block|,
literal|6
block|,
block|{
operator|-
literal|144
block|,
operator|-
literal|672
block|,
operator|-
literal|895
block|,
operator|-
literal|448
block|,
operator|-
literal|82
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|3
block|,
block|{
literal|6
block|,
literal|6
block|,
literal|5
block|}
block|,
literal|6
block|,
block|{
literal|0
block|,
operator|-
literal|384
block|,
operator|-
literal|848
block|,
operator|-
literal|480
block|,
operator|-
literal|89
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|3
block|,
block|{
literal|6
block|,
literal|6
block|,
literal|6
block|}
block|,
literal|6
block|,
block|{
literal|0
block|,
literal|0
block|,
operator|-
literal|768
block|,
operator|-
literal|512
block|,
operator|-
literal|96
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|4
block|,
block|{
operator|-
literal|48
block|,
operator|-
literal|64
block|,
operator|-
literal|24
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|5
block|,
block|{
literal|80
block|,
literal|180
block|,
literal|136
block|,
literal|37
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|5
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|5
block|,
block|{
literal|144
block|,
literal|276
block|,
literal|184
block|,
literal|45
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|6
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|5
block|,
block|{
literal|128
block|,
literal|288
block|,
literal|208
block|,
literal|52
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|3
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|6
block|,
block|{
operator|-
literal|132
block|,
operator|-
literal|416
block|,
operator|-
literal|487
block|,
operator|-
literal|256
block|,
operator|-
literal|54
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|5
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|6
block|,
block|{
operator|-
literal|228
block|,
operator|-
literal|640
block|,
operator|-
literal|671
block|,
operator|-
literal|320
block|,
operator|-
literal|62
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|6
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|6
block|,
block|{
operator|-
literal|192
block|,
operator|-
literal|608
block|,
operator|-
literal|700
block|,
operator|-
literal|352
block|,
operator|-
literal|69
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|5
block|,
literal|5
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|6
block|,
block|{
operator|-
literal|324
block|,
operator|-
literal|864
block|,
operator|-
literal|855
block|,
operator|-
literal|384
block|,
operator|-
literal|70
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|6
block|,
literal|5
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|6
block|,
block|{
operator|-
literal|192
block|,
operator|-
literal|736
block|,
operator|-
literal|860
block|,
operator|-
literal|416
block|,
operator|-
literal|77
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|6
block|,
literal|6
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|6
block|,
block|{
literal|0
block|,
operator|-
literal|512
block|,
operator|-
literal|832
block|,
operator|-
literal|448
block|,
operator|-
literal|84
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|2
block|}
block|,
literal|7
block|,
block|{
literal|216
block|,
literal|873
block|,
literal|1392
block|,
literal|1101
block|,
literal|440
block|,
literal|75
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|5
block|,
literal|3
block|,
literal|3
block|,
literal|2
block|}
block|,
literal|7
block|,
block|{
literal|360
block|,
literal|1329
block|,
literal|1936
block|,
literal|1405
block|,
literal|520
block|,
literal|83
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|6
block|,
literal|3
block|,
literal|3
block|,
literal|2
block|}
block|,
literal|7
block|,
block|{
literal|288
block|,
literal|1176
block|,
literal|1872
block|,
literal|1455
block|,
literal|560
block|,
literal|90
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|5
block|,
literal|5
block|,
literal|3
block|,
literal|2
block|}
block|,
literal|7
block|,
block|{
literal|504
block|,
literal|1785
block|,
literal|2480
block|,
literal|1709
block|,
literal|600
block|,
literal|91
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|6
block|,
literal|5
block|,
literal|3
block|,
literal|2
block|}
block|,
literal|7
block|,
block|{
literal|288
block|,
literal|1368
block|,
literal|2272
block|,
literal|1735
block|,
literal|640
block|,
literal|98
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|6
block|,
literal|6
block|,
literal|3
block|,
literal|2
block|}
block|,
literal|7
block|,
block|{
literal|0
block|,
literal|768
block|,
literal|1920
block|,
literal|1728
block|,
literal|680
block|,
literal|105
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|2
block|}
block|,
literal|7
block|,
block|{
literal|648
block|,
literal|2241
block|,
literal|3024
block|,
literal|2013
block|,
literal|680
block|,
literal|99
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|6
block|,
literal|5
block|,
literal|5
block|,
literal|2
block|}
block|,
literal|7
block|,
block|{
literal|288
block|,
literal|1560
block|,
literal|2672
block|,
literal|2015
block|,
literal|720
block|,
literal|106
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|6
block|,
literal|6
block|,
literal|5
block|,
literal|2
block|}
block|,
literal|7
block|,
block|{
literal|0
block|,
literal|768
block|,
literal|2176
block|,
literal|1984
block|,
literal|760
block|,
literal|113
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|2
block|}
block|,
literal|7
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1536
block|,
literal|1920
block|,
literal|800
block|,
literal|120
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|}
block|,
literal|8
block|,
block|{
operator|-
literal|351
block|,
operator|-
literal|1728
block|,
operator|-
literal|3492
block|,
operator|-
literal|3712
block|,
operator|-
literal|2202
block|,
operator|-
literal|704
block|,
operator|-
literal|100
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|5
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|}
block|,
literal|8
block|,
block|{
operator|-
literal|567
block|,
operator|-
literal|2592
block|,
operator|-
literal|4860
block|,
operator|-
literal|4800
block|,
operator|-
literal|2658
block|,
operator|-
literal|800
block|,
operator|-
literal|108
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|6
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|}
block|,
literal|8
block|,
block|{
operator|-
literal|432
block|,
operator|-
literal|2160
block|,
operator|-
literal|4401
block|,
operator|-
literal|4672
block|,
operator|-
literal|2733
block|,
operator|-
literal|848
block|,
operator|-
literal|115
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|5
block|,
literal|5
block|,
literal|3
block|,
literal|3
block|}
block|,
literal|8
block|,
block|{
operator|-
literal|783
block|,
operator|-
literal|3456
block|,
operator|-
literal|6228
block|,
operator|-
literal|5888
block|,
operator|-
literal|3114
block|,
operator|-
literal|896
block|,
operator|-
literal|116
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|6
block|,
literal|5
block|,
literal|3
block|,
literal|3
block|}
block|,
literal|8
block|,
block|{
operator|-
literal|432
block|,
operator|-
literal|2448
block|,
operator|-
literal|5241
block|,
operator|-
literal|5568
block|,
operator|-
literal|3165
block|,
operator|-
literal|944
block|,
operator|-
literal|123
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|6
block|,
literal|6
block|,
literal|3
block|,
literal|3
block|}
block|,
literal|8
block|,
block|{
literal|0
block|,
operator|-
literal|1152
block|,
operator|-
literal|3888
block|,
operator|-
literal|5056
block|,
operator|-
literal|3183
block|,
operator|-
literal|992
block|,
operator|-
literal|130
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|3
block|}
block|,
literal|8
block|,
block|{
operator|-
literal|999
block|,
operator|-
literal|4320
block|,
operator|-
literal|7596
block|,
operator|-
literal|6976
block|,
operator|-
literal|3570
block|,
operator|-
literal|992
block|,
operator|-
literal|124
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|6
block|,
literal|5
block|,
literal|5
block|,
literal|3
block|}
block|,
literal|8
block|,
block|{
operator|-
literal|432
block|,
operator|-
literal|2736
block|,
operator|-
literal|6081
block|,
operator|-
literal|6464
block|,
operator|-
literal|3597
block|,
operator|-
literal|1040
block|,
operator|-
literal|131
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|6
block|,
literal|6
block|,
literal|5
block|,
literal|3
block|}
block|,
literal|8
block|,
block|{
literal|0
block|,
operator|-
literal|1152
block|,
operator|-
literal|4272
block|,
operator|-
literal|5760
block|,
operator|-
literal|3591
block|,
operator|-
literal|1088
block|,
operator|-
literal|138
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|4
block|,
block|{
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|3
block|}
block|,
literal|8
block|,
block|{
literal|0
block|,
literal|0
block|,
operator|-
literal|2304
block|,
operator|-
literal|4864
block|,
operator|-
literal|3552
block|,
operator|-
literal|1136
block|,
operator|-
literal|145
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|5
block|,
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|5
block|,
block|{
literal|128
block|,
literal|240
block|,
literal|160
block|,
literal|40
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,	}
block|,
block|{
literal|5
block|,
block|{
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|6
block|,
block|{
operator|-
literal|208
block|,
operator|-
literal|576
block|,
operator|-
literal|600
block|,
operator|-
literal|288
block|,
operator|-
literal|57
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|5
block|,
block|{
literal|5
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|6
block|,
block|{
operator|-
literal|336
block|,
operator|-
literal|832
block|,
operator|-
literal|792
block|,
operator|-
literal|352
block|,
operator|-
literal|65
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|5
block|,
block|{
literal|6
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|6
block|,
block|{
operator|-
literal|256
block|,
operator|-
literal|768
block|,
operator|-
literal|816
block|,
operator|-
literal|384
block|,
operator|-
literal|72
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|5
block|,
block|{
literal|3
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|7
block|,
block|{
literal|336
block|,
literal|1228
block|,
literal|1776
block|,
literal|1287
block|,
literal|480
block|,
literal|78
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,	}
block|,
block|{
literal|5
block|,
block|{
literal|5
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|7
block|,
block|{
literal|528
block|,
literal|1772
block|,
literal|2368
block|,
literal|1599
block|,
literal|560
block|,
literal|86
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,	}
block|,
block|{
literal|5
block|,
block|{
literal|6
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|7
block|,
block|{
literal|384
block|,
literal|1504
block|,
literal|2256
block|,
literal|1644
block|,
literal|600
block|,
literal|93
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,	}
block|,
block|{
literal|5
block|,
block|{
literal|5
block|,
literal|5
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|7
block|,
block|{
literal|720
block|,
literal|2316
block|,
literal|2960
block|,
literal|1911
block|,
literal|640
block|,
literal|94
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,	}
block|,
block|{
literal|5
block|,
block|{
literal|6
block|,
literal|5
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|7
block|,
block|{
literal|384
block|,
literal|1760
block|,
literal|2704
block|,
literal|1932
block|,
literal|680
block|,
literal|101
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,	}
block|,
block|{
literal|5
block|,
block|{
literal|6
block|,
literal|6
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|7
block|,
block|{
literal|0
block|,
literal|1024
block|,
literal|2304
block|,
literal|1920
block|,
literal|720
block|,
literal|108
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,	}
block|,
block|{
literal|5
block|,
block|{
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|8
block|,
block|{
operator|-
literal|540
block|,
operator|-
literal|2448
block|,
operator|-
literal|4557
block|,
operator|-
literal|4480
block|,
operator|-
literal|2481
block|,
operator|-
literal|752
block|,
operator|-
literal|103
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|5
block|,
block|{
literal|5
block|,
literal|3
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|8
block|,
block|{
operator|-
literal|828
block|,
operator|-
literal|3504
block|,
operator|-
literal|6101
block|,
operator|-
literal|5632
block|,
operator|-
literal|2945
block|,
operator|-
literal|848
block|,
operator|-
literal|111
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|5
block|,
block|{
literal|6
block|,
literal|3
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|8
block|,
block|{
operator|-
literal|576
block|,
operator|-
literal|2784
block|,
operator|-
literal|5412
block|,
operator|-
literal|5440
block|,
operator|-
literal|3015
block|,
operator|-
literal|896
block|,
operator|-
literal|118
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|5
block|,
block|{
literal|5
block|,
literal|5
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|8
block|,
block|{
operator|-
literal|1116
block|,
operator|-
literal|4560
block|,
operator|-
literal|7645
block|,
operator|-
literal|6784
block|,
operator|-
literal|3409
block|,
operator|-
literal|944
block|,
operator|-
literal|119
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|5
block|,
block|{
literal|6
block|,
literal|5
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|8
block|,
block|{
operator|-
literal|576
block|,
operator|-
literal|3168
block|,
operator|-
literal|6404
block|,
operator|-
literal|6400
block|,
operator|-
literal|3455
block|,
operator|-
literal|992
block|,
operator|-
literal|126
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|5
block|,
block|{
literal|6
block|,
literal|6
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|8
block|,
block|{
literal|0
block|,
operator|-
literal|1536
block|,
operator|-
literal|4800
block|,
operator|-
literal|5824
block|,
operator|-
literal|3468
block|,
operator|-
literal|1040
block|,
operator|-
literal|133
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|5
block|,
block|{
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|8
block|,
block|{
operator|-
literal|1404
block|,
operator|-
literal|5616
block|,
operator|-
literal|9189
block|,
operator|-
literal|7936
block|,
operator|-
literal|3873
block|,
operator|-
literal|1040
block|,
operator|-
literal|127
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|5
block|,
block|{
literal|6
block|,
literal|5
block|,
literal|5
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|8
block|,
block|{
operator|-
literal|576
block|,
operator|-
literal|3552
block|,
operator|-
literal|7396
block|,
operator|-
literal|7360
block|,
operator|-
literal|3895
block|,
operator|-
literal|1088
block|,
operator|-
literal|134
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|5
block|,
block|{
literal|6
block|,
literal|6
block|,
literal|5
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|8
block|,
block|{
literal|0
block|,
operator|-
literal|1536
block|,
operator|-
literal|5312
block|,
operator|-
literal|6592
block|,
operator|-
literal|3884
block|,
operator|-
literal|1136
block|,
operator|-
literal|141
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|5
block|,
block|{
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|8
block|,
block|{
literal|0
block|,
literal|0
block|,
operator|-
literal|3072
block|,
operator|-
literal|5632
block|,
operator|-
literal|3840
block|,
operator|-
literal|1184
block|,
operator|-
literal|148
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|6
block|,
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|6
block|,
block|{
operator|-
literal|320
block|,
operator|-
literal|768
block|,
operator|-
literal|720
block|,
operator|-
literal|320
block|,
operator|-
literal|60
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|6
block|,
block|{
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|7
block|,
block|{
literal|512
block|,
literal|1680
block|,
literal|2208
block|,
literal|1480
block|,
literal|520
block|,
literal|81
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,	}
block|,
block|{
literal|6
block|,
block|{
literal|5
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|7
block|,
block|{
literal|768
block|,
literal|2320
block|,
literal|2848
block|,
literal|1800
block|,
literal|600
block|,
literal|89
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,	}
block|,
block|{
literal|6
block|,
block|{
literal|6
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|7
block|,
block|{
literal|512
block|,
literal|1920
block|,
literal|2688
block|,
literal|1840
block|,
literal|640
block|,
literal|96
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,	}
block|,
block|{
literal|6
block|,
block|{
literal|3
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|8
block|,
block|{
operator|-
literal|816
block|,
operator|-
literal|3392
block|,
operator|-
literal|5816
block|,
operator|-
literal|5312
block|,
operator|-
literal|2767
block|,
operator|-
literal|800
block|,
operator|-
literal|106
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|6
block|,
block|{
literal|5
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|8
block|,
block|{
operator|-
literal|1200
block|,
operator|-
literal|4672
block|,
operator|-
literal|7544
block|,
operator|-
literal|6528
block|,
operator|-
literal|3239
block|,
operator|-
literal|896
block|,
operator|-
literal|114
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|6
block|,
block|{
literal|6
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|8
block|,
block|{
operator|-
literal|768
block|,
operator|-
literal|3584
block|,
operator|-
literal|6608
block|,
operator|-
literal|6272
block|,
operator|-
literal|3304
block|,
operator|-
literal|944
block|,
operator|-
literal|121
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|6
block|,
block|{
literal|5
block|,
literal|5
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|8
block|,
block|{
operator|-
literal|1584
block|,
operator|-
literal|5952
block|,
operator|-
literal|9272
block|,
operator|-
literal|7744
block|,
operator|-
literal|3711
block|,
operator|-
literal|992
block|,
operator|-
literal|122
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|6
block|,
block|{
literal|6
block|,
literal|5
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|8
block|,
block|{
operator|-
literal|768
block|,
operator|-
literal|4096
block|,
operator|-
literal|7760
block|,
operator|-
literal|7296
block|,
operator|-
literal|3752
block|,
operator|-
literal|1040
block|,
operator|-
literal|129
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|6
block|,
block|{
literal|6
block|,
literal|6
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|8
block|,
block|{
literal|0
block|,
operator|-
literal|2048
block|,
operator|-
literal|5888
block|,
operator|-
literal|6656
block|,
operator|-
literal|3760
block|,
operator|-
literal|1088
block|,
operator|-
literal|136
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|7
block|,
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|7
block|,
block|{
literal|768
block|,
literal|2240
block|,
literal|2688
block|,
literal|1680
block|,
literal|560
block|,
literal|84
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,	}
block|,
block|{
literal|7
block|,
block|{
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|8
block|,
block|{
operator|-
literal|1216
block|,
operator|-
literal|4608
block|,
operator|-
literal|7280
block|,
operator|-
literal|6208
block|,
operator|-
literal|3060
block|,
operator|-
literal|848
block|,
operator|-
literal|109
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|7
block|,
block|{
literal|5
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|8
block|,
block|{
operator|-
literal|1728
block|,
operator|-
literal|6144
block|,
operator|-
literal|9200
block|,
operator|-
literal|7488
block|,
operator|-
literal|3540
block|,
operator|-
literal|944
block|,
operator|-
literal|117
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|7
block|,
block|{
literal|6
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|8
block|,
block|{
operator|-
literal|1024
block|,
operator|-
literal|4608
block|,
operator|-
literal|8000
block|,
operator|-
literal|7168
block|,
operator|-
literal|3600
block|,
operator|-
literal|992
block|,
operator|-
literal|124
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
block|{
literal|8
block|,
block|{
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
literal|8
block|,
block|{
operator|-
literal|1792
block|,
operator|-
literal|6144
block|,
operator|-
literal|8960
block|,
operator|-
literal|7168
block|,
operator|-
literal|3360
block|,
operator|-
literal|896
block|,
operator|-
literal|112
block|,
literal|0
block|,
literal|1
block|}
block|,	}
block|,
comment|/* 	 * mesh errors 	 */
block|{
literal|2
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
literal|4
block|,
block|{
operator|-
literal|192
block|,
operator|-
literal|256
block|,
operator|-
literal|80
block|,
literal|0
block|,
literal|1
block|}
block|, }
block|,
block|{
operator|-
literal|1
block|,
block|{
literal|0
block|,}
block|,
literal|0
block|,
block|{
literal|0
block|, }
block|,					}
block|, }
struct|;
end_struct

begin_comment
comment|/*  * per fabric mesh info  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_mesh
block|{
name|int
name|num_class
decl_stmt|;
comment|/* number of switch classes */
name|int
modifier|*
name|class_type
decl_stmt|;
comment|/* index of first switch found for each class */
name|int
modifier|*
name|class_count
decl_stmt|;
comment|/* population of each class */
name|int
name|dimension
decl_stmt|;
comment|/* mesh dimension */
name|int
modifier|*
name|size
decl_stmt|;
comment|/* an array to hold size of mesh */
name|int
name|dim_order
index|[
name|MAX_DIMENSION
index|]
decl_stmt|;
block|}
name|mesh_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|sort_ctx
block|{
name|lash_t
modifier|*
name|p_lash
decl_stmt|;
name|mesh_t
modifier|*
name|mesh
decl_stmt|;
block|}
name|sort_ctx_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|comp
block|{
name|int
name|index
decl_stmt|;
name|sort_ctx_t
name|ctx
decl_stmt|;
block|}
name|comp_t
typedef|;
end_typedef

begin_comment
comment|/*  * poly_alloc  *  * allocate a polynomial of degree n  */
end_comment

begin_function
specifier|static
name|int
modifier|*
name|poly_alloc
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|int
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|calloc
argument_list|(
name|n
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
condition|)
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"Failed allocating poly - out of memory\n"
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * print a polynomial  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|poly_print
parameter_list|(
name|int
name|n
parameter_list|,
name|int
modifier|*
name|coeff
parameter_list|)
block|{
specifier|static
name|char
name|str
index|[
operator|(
name|MAX_DEGREE
operator|+
literal|1
operator|)
operator|*
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|str
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
name|int
name|t
decl_stmt|;
name|int
name|sign
decl_stmt|;
name|str
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|coeff
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
name|coeff
index|[
name|i
index|]
operator|<
literal|0
condition|)
block|{
name|sign
operator|=
literal|1
expr_stmt|;
name|t
operator|=
operator|-
name|coeff
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|sign
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|coeff
index|[
name|i
index|]
expr_stmt|;
block|}
name|p
operator|+=
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s"
argument_list|,
name|sign
condition|?
literal|"-"
else|:
operator|(
name|first
condition|?
literal|""
else|:
literal|"+"
operator|)
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|1
operator|||
name|i
operator|==
literal|0
condition|)
name|p
operator|+=
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%d"
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|p
operator|+=
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
name|p
operator|+=
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"^%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/*  * poly_diff  *  * return a nonzero value if polynomials differ else 0  */
end_comment

begin_function
specifier|static
name|int
name|poly_diff
parameter_list|(
name|unsigned
name|int
name|n
parameter_list|,
specifier|const
name|int
modifier|*
name|p
parameter_list|,
name|switch_t
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|->
name|node
operator|->
name|num_links
operator|!=
name|n
condition|)
return|return
literal|1
return|;
return|return
name|memcmp
argument_list|(
name|p
argument_list|,
name|s
operator|->
name|node
operator|->
name|poly
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * m_free  *  * free a square matrix of rank l  */
end_comment

begin_function
specifier|static
name|void
name|m_free
parameter_list|(
name|int
modifier|*
modifier|*
name|m
parameter_list|,
name|int
name|l
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|m
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|m
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * m_alloc  *  * allocate a square matrix of rank l  */
end_comment

begin_function
specifier|static
name|int
modifier|*
modifier|*
name|m_alloc
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|int
name|l
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
modifier|*
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
operator|(
name|m
operator|=
name|calloc
argument_list|(
name|l
argument_list|,
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|m
index|[
name|i
index|]
operator|=
name|calloc
argument_list|(
name|l
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|!=
name|l
condition|)
break|break;
return|return
name|m
return|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"Failed allocating matrix - out of memory\n"
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * pm_free  *  * free a square matrix of rank l of polynomials  */
end_comment

begin_function
specifier|static
name|void
name|pm_free
parameter_list|(
name|int
modifier|*
modifier|*
modifier|*
name|m
parameter_list|,
name|int
name|l
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|m
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|m
index|[
name|i
index|]
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|l
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|m
index|[
name|i
index|]
index|[
name|j
index|]
condition|)
name|free
argument_list|(
name|m
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * pm_alloc  *  * allocate a square matrix of rank l of polynomials of degree n  */
end_comment

begin_function
specifier|static
name|int
modifier|*
modifier|*
modifier|*
name|pm_alloc
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|int
name|l
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
modifier|*
modifier|*
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
operator|(
name|m
operator|=
name|calloc
argument_list|(
name|l
argument_list|,
sizeof|sizeof
argument_list|(
name|int
operator|*
operator|*
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|m
index|[
name|i
index|]
operator|=
name|calloc
argument_list|(
name|l
argument_list|,
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|l
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|m
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|calloc
argument_list|(
name|n
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|!=
name|l
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|!=
name|l
condition|)
break|break;
return|return
name|m
return|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"Failed allocating matrix - out of memory\n"
argument_list|)
expr_stmt|;
name|pm_free
argument_list|(
name|m
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|determinant
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|rank
parameter_list|,
name|int
modifier|*
modifier|*
modifier|*
name|m
parameter_list|,
name|int
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * sub_determinant  *  * compute the determinant of a submatrix of matrix of rank l of polynomials of degree n  * with row and col removed in poly. caller must free poly  */
end_comment

begin_function
specifier|static
name|int
name|sub_determinant
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|l
parameter_list|,
name|int
name|row
parameter_list|,
name|int
name|col
parameter_list|,
name|int
modifier|*
modifier|*
modifier|*
name|matrix
parameter_list|,
name|int
modifier|*
modifier|*
name|poly
parameter_list|)
block|{
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|int
modifier|*
modifier|*
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|int
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|rank
init|=
name|l
operator|-
literal|1
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|poly_alloc
argument_list|(
name|p_lash
argument_list|,
name|n
argument_list|)
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|rank
operator|<=
literal|0
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|m
operator|=
name|pm_alloc
argument_list|(
name|p_lash
argument_list|,
name|rank
argument_list|,
name|n
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|x
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|row
condition|)
continue|continue;
name|y
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|l
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
name|col
condition|)
continue|continue;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|n
condition|;
name|k
operator|++
control|)
name|m
index|[
name|x
index|]
index|[
name|y
index|]
index|[
name|k
index|]
operator|=
name|matrix
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
expr_stmt|;
name|y
operator|++
expr_stmt|;
block|}
name|x
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|determinant
argument_list|(
name|p_lash
argument_list|,
name|n
argument_list|,
name|rank
argument_list|,
name|m
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|pm_free
argument_list|(
name|m
argument_list|,
name|rank
argument_list|)
expr_stmt|;
operator|*
name|poly
operator|=
name|p
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * determinant  *  * compute the determinant of matrix m of rank of polynomials of degree deg  * and add the result to polynomial p allocated by caller  */
end_comment

begin_function
specifier|static
name|int
name|determinant
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|int
name|deg
parameter_list|,
name|int
name|rank
parameter_list|,
name|int
modifier|*
modifier|*
modifier|*
name|m
parameter_list|,
name|int
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
modifier|*
name|q
decl_stmt|;
name|int
name|sign
init|=
literal|1
decl_stmt|;
comment|/* 	 * handle simple case of 1x1 matrix 	 */
if|if
condition|(
name|rank
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|deg
condition|;
name|i
operator|++
control|)
name|p
index|[
name|i
index|]
operator|+=
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* 	 * handle simple case of 2x2 matrix 	 */
elseif|else
if|if
condition|(
name|rank
operator|==
literal|2
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|deg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|deg
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
index|[
name|j
index|]
operator|==
literal|0
condition|)
continue|continue;
name|p
index|[
name|i
operator|+
name|j
index|]
operator|+=
name|m
index|[
literal|0
index|]
index|[
literal|0
index|]
index|[
name|i
index|]
operator|*
name|m
index|[
literal|1
index|]
index|[
literal|1
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|deg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|deg
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
index|[
name|j
index|]
operator|==
literal|0
condition|)
continue|continue;
name|p
index|[
name|i
operator|+
name|j
index|]
operator|-=
name|m
index|[
literal|0
index|]
index|[
literal|1
index|]
index|[
name|i
index|]
operator|*
name|m
index|[
literal|1
index|]
index|[
literal|0
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * handle the general case 	 */
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rank
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sub_determinant
argument_list|(
name|p_lash
argument_list|,
name|deg
argument_list|,
name|rank
argument_list|,
literal|0
argument_list|,
name|i
argument_list|,
name|m
argument_list|,
operator|&
name|q
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|deg
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|m
index|[
literal|0
index|]
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|deg
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|q
index|[
name|k
index|]
operator|==
literal|0
condition|)
continue|continue;
name|p
index|[
name|j
operator|+
name|k
index|]
operator|+=
name|sign
operator|*
name|m
index|[
literal|0
index|]
index|[
name|i
index|]
index|[
name|j
index|]
operator|*
name|q
index|[
name|k
index|]
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|sign
operator|=
operator|-
name|sign
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * char_poly  *  * compute the characteristic polynomial of matrix of rank  * by computing the determinant of m-x*I and return in poly  * as an array. caller must free poly  */
end_comment

begin_function
specifier|static
name|int
name|char_poly
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|int
name|rank
parameter_list|,
name|int
modifier|*
modifier|*
name|matrix
parameter_list|,
name|int
modifier|*
modifier|*
name|poly
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
modifier|*
modifier|*
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|int
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|int
name|deg
init|=
name|rank
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|matrix
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|poly_alloc
argument_list|(
name|p_lash
argument_list|,
name|deg
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|m
operator|=
name|pm_alloc
argument_list|(
name|p_lash
argument_list|,
name|rank
argument_list|,
name|deg
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rank
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|rank
condition|;
name|j
operator|++
control|)
block|{
name|m
index|[
name|i
index|]
index|[
name|j
index|]
index|[
literal|0
index|]
operator|=
name|matrix
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
name|m
index|[
name|i
index|]
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|determinant
argument_list|(
name|p_lash
argument_list|,
name|deg
argument_list|,
name|rank
argument_list|,
name|m
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|pm_free
argument_list|(
name|m
argument_list|,
name|rank
argument_list|)
expr_stmt|;
operator|*
name|poly
operator|=
name|p
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * get_switch_metric  *  * compute the matrix of minimum distances between each of  * the adjacent switch nodes to sw along paths  * that do not go through sw. do calculation by  * relaxation method  * allocate space for the matrix and save in node_t structure  */
end_comment

begin_function
specifier|static
name|int
name|get_switch_metric
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|int
name|sw
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|change
decl_stmt|;
name|int
name|sw1
decl_stmt|,
name|sw2
decl_stmt|,
name|sw3
decl_stmt|;
name|switch_t
modifier|*
name|s
init|=
name|p_lash
operator|->
name|switches
index|[
name|sw
index|]
decl_stmt|;
name|switch_t
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
name|int
modifier|*
modifier|*
name|m
decl_stmt|;
name|mesh_node_t
modifier|*
name|node
init|=
name|s
operator|->
name|node
decl_stmt|;
name|unsigned
name|int
name|num_links
init|=
name|node
operator|->
name|num_links
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
operator|(
name|m
operator|=
name|m_alloc
argument_list|(
name|p_lash
argument_list|,
name|num_links
argument_list|)
operator|)
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_links
condition|;
name|i
operator|++
control|)
block|{
name|sw1
operator|=
name|node
operator|->
name|links
index|[
name|i
index|]
operator|->
name|switch_id
expr_stmt|;
name|s1
operator|=
name|p_lash
operator|->
name|switches
index|[
name|sw1
index|]
expr_stmt|;
comment|/* make all distances big except s1 to itself */
for|for
control|(
name|sw2
operator|=
literal|0
init|;
name|sw2
operator|<
name|p_lash
operator|->
name|num_switches
condition|;
name|sw2
operator|++
control|)
name|p_lash
operator|->
name|switches
index|[
name|sw2
index|]
operator|->
name|node
operator|->
name|temp
operator|=
name|LARGE
expr_stmt|;
name|s1
operator|->
name|node
operator|->
name|temp
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|change
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sw2
operator|=
literal|0
init|;
name|sw2
operator|<
name|p_lash
operator|->
name|num_switches
condition|;
name|sw2
operator|++
control|)
block|{
name|s2
operator|=
name|p_lash
operator|->
name|switches
index|[
name|sw2
index|]
expr_stmt|;
if|if
condition|(
name|s2
operator|->
name|node
operator|->
name|temp
operator|==
name|LARGE
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|s2
operator|->
name|node
operator|->
name|num_links
condition|;
name|j
operator|++
control|)
block|{
name|sw3
operator|=
name|s2
operator|->
name|node
operator|->
name|links
index|[
name|j
index|]
operator|->
name|switch_id
expr_stmt|;
name|s3
operator|=
name|p_lash
operator|->
name|switches
index|[
name|sw3
index|]
expr_stmt|;
if|if
condition|(
name|sw3
operator|==
name|sw
condition|)
continue|continue;
if|if
condition|(
operator|(
name|s2
operator|->
name|node
operator|->
name|temp
operator|+
literal|1
operator|)
operator|<
name|s3
operator|->
name|node
operator|->
name|temp
condition|)
block|{
name|s3
operator|->
name|node
operator|->
name|temp
operator|=
name|s2
operator|->
name|node
operator|->
name|temp
operator|+
literal|1
expr_stmt|;
name|change
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
do|while
condition|(
name|change
condition|)
do|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_links
condition|;
name|j
operator|++
control|)
block|{
name|sw2
operator|=
name|node
operator|->
name|links
index|[
name|j
index|]
operator|->
name|switch_id
expr_stmt|;
name|s2
operator|=
name|p_lash
operator|->
name|switches
index|[
name|sw2
index|]
expr_stmt|;
name|m
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|s2
operator|->
name|node
operator|->
name|temp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|char_poly
argument_list|(
name|p_lash
argument_list|,
name|num_links
argument_list|,
name|m
argument_list|,
operator|&
name|node
operator|->
name|poly
argument_list|)
condition|)
block|{
name|m_free
argument_list|(
name|m
argument_list|,
name|num_links
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|node
operator|->
name|matrix
operator|=
name|m
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * classify_switch  *  * add switch to histogram of switch types  * we keep a reference to the first switch  * found of each type as an exemplar  */
end_comment

begin_function
specifier|static
name|void
name|classify_switch
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|mesh_t
modifier|*
name|mesh
parameter_list|,
name|int
name|sw
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|int
name|i
decl_stmt|;
name|switch_t
modifier|*
name|s
init|=
name|p_lash
operator|->
name|switches
index|[
name|sw
index|]
decl_stmt|;
name|switch_t
modifier|*
name|s1
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|node
operator|->
name|poly
condition|)
goto|goto
name|done
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mesh
operator|->
name|num_class
condition|;
name|i
operator|++
control|)
block|{
name|s1
operator|=
name|p_lash
operator|->
name|switches
index|[
name|mesh
operator|->
name|class_type
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
name|poly_diff
argument_list|(
name|s
operator|->
name|node
operator|->
name|num_links
argument_list|,
name|s
operator|->
name|node
operator|->
name|poly
argument_list|,
name|s1
argument_list|)
condition|)
continue|continue;
name|mesh
operator|->
name|class_count
index|[
name|i
index|]
operator|++
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|mesh
operator|->
name|class_type
index|[
name|mesh
operator|->
name|num_class
index|]
operator|=
name|sw
expr_stmt|;
name|mesh
operator|->
name|class_count
index|[
name|mesh
operator|->
name|num_class
index|]
operator|=
literal|1
expr_stmt|;
name|mesh
operator|->
name|num_class
operator|++
expr_stmt|;
name|done
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * classify_mesh_type  *  * try to look up node polynomial in table  */
end_comment

begin_function
specifier|static
name|void
name|classify_mesh_type
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|int
name|sw
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|int
name|i
decl_stmt|;
name|switch_t
modifier|*
name|s
init|=
name|p_lash
operator|->
name|switches
index|[
name|sw
index|]
decl_stmt|;
specifier|const
name|struct
name|mesh_info
modifier|*
name|t
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|node
operator|->
name|poly
condition|)
goto|goto
name|done
goto|;
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|(
name|t
operator|=
operator|&
name|mesh_info
index|[
name|i
index|]
operator|)
operator|->
name|dimension
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|poly_diff
argument_list|(
name|t
operator|->
name|degree
argument_list|,
name|t
operator|->
name|poly
argument_list|,
name|s
argument_list|)
condition|)
continue|continue;
name|s
operator|->
name|node
operator|->
name|type
operator|=
name|i
expr_stmt|;
name|s
operator|->
name|node
operator|->
name|dimension
operator|=
name|t
operator|->
name|dimension
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return;
block|}
name|done
label|:
name|s
operator|->
name|node
operator|->
name|type
operator|=
literal|0
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * remove_edges  *  * remove type from nodes that have fewer links  * than adjacent nodes  */
end_comment

begin_function
specifier|static
name|void
name|remove_edges
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|int
name|sw
decl_stmt|;
name|mesh_node_t
modifier|*
name|n
decl_stmt|,
modifier|*
name|nn
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
for|for
control|(
name|sw
operator|=
literal|0
init|;
name|sw
operator|<
name|p_lash
operator|->
name|num_switches
condition|;
name|sw
operator|++
control|)
block|{
name|n
operator|=
name|p_lash
operator|->
name|switches
index|[
name|sw
index|]
operator|->
name|node
expr_stmt|;
if|if
condition|(
operator|!
name|n
operator|->
name|type
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|->
name|num_links
condition|;
name|i
operator|++
control|)
block|{
name|nn
operator|=
name|p_lash
operator|->
name|switches
index|[
name|n
operator|->
name|links
index|[
name|i
index|]
operator|->
name|switch_id
index|]
operator|->
name|node
expr_stmt|;
if|if
condition|(
name|nn
operator|->
name|num_links
operator|>
name|n
operator|->
name|num_links
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"removed edge switch %s\n"
argument_list|,
name|p_lash
operator|->
name|switches
index|[
name|sw
index|]
operator|->
name|p_sw
operator|->
name|p_node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
name|n
operator|->
name|type
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get_local_geometry  *  * analyze the local geometry around each switch  */
end_comment

begin_function
specifier|static
name|int
name|get_local_geometry
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|mesh_t
modifier|*
name|mesh
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|int
name|sw
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
for|for
control|(
name|sw
operator|=
literal|0
init|;
name|sw
operator|<
name|p_lash
operator|->
name|num_switches
condition|;
name|sw
operator|++
control|)
block|{
comment|/* 		 * skip switches with more links than MAX_DEGREE 		 * since they will never match a known case 		 */
if|if
condition|(
name|p_lash
operator|->
name|switches
index|[
name|sw
index|]
operator|->
name|node
operator|->
name|num_links
operator|>
name|MAX_DEGREE
condition|)
continue|continue;
if|if
condition|(
name|get_switch_metric
argument_list|(
name|p_lash
argument_list|,
name|sw
argument_list|)
condition|)
block|{
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|classify_mesh_type
argument_list|(
name|p_lash
argument_list|,
name|sw
argument_list|)
expr_stmt|;
block|}
name|remove_edges
argument_list|(
name|p_lash
argument_list|)
expr_stmt|;
for|for
control|(
name|sw
operator|=
literal|0
init|;
name|sw
operator|<
name|p_lash
operator|->
name|num_switches
condition|;
name|sw
operator|++
control|)
block|{
if|if
condition|(
name|p_lash
operator|->
name|switches
index|[
name|sw
index|]
operator|->
name|node
operator|->
name|type
operator|<
literal|0
condition|)
continue|continue;
name|classify_switch
argument_list|(
name|p_lash
argument_list|,
name|mesh
argument_list|,
name|sw
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_axis
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|int
name|sw
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|mesh_node_t
modifier|*
name|node
init|=
name|p_lash
operator|->
name|switches
index|[
name|sw
index|]
operator|->
name|node
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|p_lash
operator|->
name|switches
index|[
name|sw
index|]
operator|->
name|p_sw
operator|->
name|p_node
operator|->
name|print_desc
decl_stmt|;
name|int
name|c
init|=
name|node
operator|->
name|axes
index|[
name|port
index|]
decl_stmt|;
name|p
operator|+=
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s[%d] = "
argument_list|,
name|name
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
name|p
operator|+=
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s%c -> "
argument_list|,
operator|(
operator|(
name|c
operator|-
literal|1
operator|)
operator|&
literal|1
operator|)
condition|?
literal|"-"
else|:
literal|"+"
argument_list|,
literal|'X'
operator|+
operator|(
name|c
operator|-
literal|1
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
else|else
name|p
operator|+=
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"N/A -> "
argument_list|)
expr_stmt|;
name|p
operator|+=
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s\n"
argument_list|,
name|p_lash
operator|->
name|switches
index|[
name|node
operator|->
name|links
index|[
name|port
index|]
operator|->
name|switch_id
index|]
operator|->
name|p_sw
operator|->
name|p_node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * seed_axes  *  * assign axes to the links of the seed switch  * assumes switch is of type cartesian mesh  * axes are numbered 1 to n i.e. +x => 1 -x => 2 etc.  * this assumes that if all distances are 2 that  * an axis has only 2 nodes so +A and -A collapse to +A  */
end_comment

begin_function
specifier|static
name|void
name|seed_axes
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|int
name|sw
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|mesh_node_t
modifier|*
name|node
init|=
name|p_lash
operator|->
name|switches
index|[
name|sw
index|]
operator|->
name|node
decl_stmt|;
name|int
name|n
init|=
name|node
operator|->
name|num_links
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|c
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|matrix
operator|||
operator|!
name|node
operator|->
name|dimension
condition|)
goto|goto
name|done
goto|;
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<=
literal|2
operator|*
name|node
operator|->
name|dimension
condition|;
name|c
operator|++
control|)
block|{
comment|/* 		 * find the next unassigned axis 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|axes
index|[
name|i
index|]
condition|)
break|break;
block|}
name|node
operator|->
name|axes
index|[
name|i
index|]
operator|=
name|c
operator|++
expr_stmt|;
comment|/* 		 * find the matching opposite direction 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|node
operator|->
name|axes
index|[
name|j
index|]
operator|||
name|j
operator|==
name|i
condition|)
continue|continue;
if|if
condition|(
name|node
operator|->
name|matrix
index|[
name|i
index|]
index|[
name|j
index|]
operator|!=
literal|2
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|!=
name|n
condition|)
block|{
name|node
operator|->
name|axes
index|[
name|j
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
if|if
condition|(
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|buf
expr_stmt|;
name|print_axis
argument_list|(
name|p_lash
argument_list|,
name|p
argument_list|,
name|sw
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
name|done
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * opposite  *  * compute the opposite of axis for switch  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|opposite
parameter_list|(
name|switch_t
modifier|*
name|s
parameter_list|,
name|int
name|axis
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|negaxis
init|=
literal|1
operator|+
operator|(
literal|1
operator|^
operator|(
name|axis
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|node
operator|->
name|matrix
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|node
operator|->
name|num_links
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|->
name|node
operator|->
name|axes
index|[
name|i
index|]
operator|==
name|axis
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|s
operator|->
name|node
operator|->
name|num_links
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
name|i
condition|)
continue|continue;
if|if
condition|(
name|s
operator|->
name|node
operator|->
name|matrix
index|[
name|i
index|]
index|[
name|j
index|]
operator|!=
literal|2
condition|)
return|return
name|negaxis
return|;
block|}
return|return
name|axis
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * make_geometry  *  * induce a geometry on the switches  */
end_comment

begin_function
specifier|static
name|void
name|make_geometry
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|int
name|sw
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|int
name|num_switches
init|=
name|p_lash
operator|->
name|num_switches
decl_stmt|;
name|int
name|sw1
decl_stmt|,
name|sw2
decl_stmt|;
name|switch_t
modifier|*
name|s
decl_stmt|,
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|,
modifier|*
name|seed
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|l
decl_stmt|,
name|n
decl_stmt|,
name|m
decl_stmt|;
name|unsigned
name|int
name|change
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|s
operator|=
name|p_lash
operator|->
name|switches
index|[
name|sw
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|node
operator|->
name|matrix
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * assign axes to seed switch 	 */
name|seed_axes
argument_list|(
name|p_lash
argument_list|,
name|sw
argument_list|)
expr_stmt|;
name|seed
operator|=
name|p_lash
operator|->
name|switches
index|[
name|sw
index|]
expr_stmt|;
comment|/* 	 * induce axes in other switches until 	 * there is no more change 	 */
do|do
block|{
name|change
operator|=
literal|0
expr_stmt|;
comment|/* phase 1 opposites */
for|for
control|(
name|sw1
operator|=
literal|0
init|;
name|sw1
operator|<
name|num_switches
condition|;
name|sw1
operator|++
control|)
block|{
name|s1
operator|=
name|p_lash
operator|->
name|switches
index|[
name|sw1
index|]
expr_stmt|;
name|n
operator|=
name|s1
operator|->
name|node
operator|->
name|num_links
expr_stmt|;
comment|/* 			 * ignore chain fragments 			 */
if|if
condition|(
name|n
operator|<
name|seed
operator|->
name|node
operator|->
name|num_links
operator|&&
name|n
operator|<=
literal|2
condition|)
continue|continue;
comment|/* 			 * only process 'mesh' switches 			 */
if|if
condition|(
operator|!
name|s1
operator|->
name|node
operator|->
name|matrix
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|s1
operator|->
name|node
operator|->
name|axes
index|[
name|i
index|]
condition|)
continue|continue;
comment|/* 				 * can't tell across if more than one 				 * likely looking link 				 */
name|m
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
name|i
condition|)
continue|continue;
if|if
condition|(
name|s1
operator|->
name|node
operator|->
name|matrix
index|[
name|i
index|]
index|[
name|j
index|]
operator|!=
literal|2
condition|)
name|m
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|!=
literal|1
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
name|i
condition|)
continue|continue;
comment|/* Rule out opposite nodes when distance greater than 4 */
if|if
condition|(
name|s1
operator|->
name|node
operator|->
name|matrix
index|[
name|i
index|]
index|[
name|j
index|]
operator|!=
literal|2
operator|&&
name|s1
operator|->
name|node
operator|->
name|matrix
index|[
name|i
index|]
index|[
name|j
index|]
operator|<=
literal|4
condition|)
block|{
if|if
condition|(
name|s1
operator|->
name|node
operator|->
name|axes
index|[
name|j
index|]
condition|)
block|{
if|if
condition|(
name|s1
operator|->
name|node
operator|->
name|axes
index|[
name|j
index|]
operator|!=
name|opposite
argument_list|(
name|seed
argument_list|,
name|s1
operator|->
name|node
operator|->
name|axes
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"phase 1 mismatch\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|s1
operator|->
name|node
operator|->
name|axes
index|[
name|j
index|]
operator|=
name|opposite
argument_list|(
name|seed
argument_list|,
name|s1
operator|->
name|node
operator|->
name|axes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|change
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* phase 2 switch to switch */
for|for
control|(
name|sw1
operator|=
literal|0
init|;
name|sw1
operator|<
name|num_switches
condition|;
name|sw1
operator|++
control|)
block|{
name|s1
operator|=
name|p_lash
operator|->
name|switches
index|[
name|sw1
index|]
expr_stmt|;
name|n
operator|=
name|s1
operator|->
name|node
operator|->
name|num_links
expr_stmt|;
if|if
condition|(
operator|!
name|s1
operator|->
name|node
operator|->
name|matrix
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|int
name|l2
init|=
name|s1
operator|->
name|node
operator|->
name|links
index|[
name|i
index|]
operator|->
name|link_id
decl_stmt|;
if|if
condition|(
operator|!
name|s1
operator|->
name|node
operator|->
name|axes
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
name|l2
operator|==
operator|-
literal|1
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"no reverse link\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sw2
operator|=
name|s1
operator|->
name|node
operator|->
name|links
index|[
name|i
index|]
operator|->
name|switch_id
expr_stmt|;
name|s2
operator|=
name|p_lash
operator|->
name|switches
index|[
name|sw2
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|s2
operator|->
name|node
operator|->
name|matrix
condition|)
continue|continue;
if|if
condition|(
operator|!
name|s2
operator|->
name|node
operator|->
name|axes
index|[
name|l2
index|]
condition|)
block|{
comment|/* 					 * set axis to opposite of s1->axes[i] 					 */
name|s2
operator|->
name|node
operator|->
name|axes
index|[
name|l2
index|]
operator|=
name|opposite
argument_list|(
name|seed
argument_list|,
name|s1
operator|->
name|node
operator|->
name|axes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|change
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|s2
operator|->
name|node
operator|->
name|axes
index|[
name|l2
index|]
operator|!=
name|opposite
argument_list|(
name|seed
argument_list|,
name|s1
operator|->
name|node
operator|->
name|axes
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"phase 2 mismatch\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Phase 3 corners */
for|for
control|(
name|sw1
operator|=
literal|0
init|;
name|sw1
operator|<
name|num_switches
condition|;
name|sw1
operator|++
control|)
block|{
name|s
operator|=
name|p_lash
operator|->
name|switches
index|[
name|sw1
index|]
expr_stmt|;
name|n
operator|=
name|s
operator|->
name|node
operator|->
name|num_links
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|node
operator|->
name|matrix
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|s
operator|->
name|node
operator|->
name|axes
index|[
name|i
index|]
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|j
operator|||
operator|!
name|s
operator|->
name|node
operator|->
name|axes
index|[
name|j
index|]
operator|||
name|s
operator|->
name|node
operator|->
name|matrix
index|[
name|i
index|]
index|[
name|j
index|]
operator|!=
literal|2
condition|)
continue|continue;
name|s1
operator|=
name|p_lash
operator|->
name|switches
index|[
name|s
operator|->
name|node
operator|->
name|links
index|[
name|i
index|]
operator|->
name|switch_id
index|]
expr_stmt|;
name|s2
operator|=
name|p_lash
operator|->
name|switches
index|[
name|s
operator|->
name|node
operator|->
name|links
index|[
name|j
index|]
operator|->
name|switch_id
index|]
expr_stmt|;
comment|/* 					 * find switch (other than s1) that neighbors i and j 					 * have in common 					 */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|s1
operator|->
name|node
operator|->
name|num_links
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|s1
operator|->
name|node
operator|->
name|links
index|[
name|k
index|]
operator|->
name|switch_id
operator|==
name|sw1
condition|)
continue|continue;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|s2
operator|->
name|node
operator|->
name|num_links
condition|;
name|l
operator|++
control|)
block|{
if|if
condition|(
name|s2
operator|->
name|node
operator|->
name|links
index|[
name|l
index|]
operator|->
name|switch_id
operator|==
name|sw1
condition|)
continue|continue;
if|if
condition|(
name|s1
operator|->
name|node
operator|->
name|links
index|[
name|k
index|]
operator|->
name|switch_id
operator|==
name|s2
operator|->
name|node
operator|->
name|links
index|[
name|l
index|]
operator|->
name|switch_id
condition|)
block|{
if|if
condition|(
name|s1
operator|->
name|node
operator|->
name|axes
index|[
name|k
index|]
condition|)
block|{
if|if
condition|(
name|s1
operator|->
name|node
operator|->
name|axes
index|[
name|k
index|]
operator|!=
name|s
operator|->
name|node
operator|->
name|axes
index|[
name|j
index|]
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"phase 3 mismatch\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|s1
operator|->
name|node
operator|->
name|axes
index|[
name|k
index|]
operator|=
name|s
operator|->
name|node
operator|->
name|axes
index|[
name|j
index|]
expr_stmt|;
name|change
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|s2
operator|->
name|node
operator|->
name|axes
index|[
name|l
index|]
condition|)
block|{
if|if
condition|(
name|s2
operator|->
name|node
operator|->
name|axes
index|[
name|l
index|]
operator|!=
name|s
operator|->
name|node
operator|->
name|axes
index|[
name|i
index|]
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"phase 3 mismatch\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|s2
operator|->
name|node
operator|->
name|axes
index|[
name|l
index|]
operator|=
name|s
operator|->
name|node
operator|->
name|axes
index|[
name|i
index|]
expr_stmt|;
name|change
operator|++
expr_stmt|;
block|}
goto|goto
name|next_j
goto|;
block|}
block|}
block|}
name|next_j
label|:
empty_stmt|;
block|}
block|}
block|}
block|}
do|while
condition|(
name|change
condition|)
do|;
name|done
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * return |a|< |b|  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ltmag
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
name|int
name|a1
init|=
operator|(
name|a
operator|>=
literal|0
operator|)
condition|?
name|a
else|:
operator|-
name|a
decl_stmt|;
name|int
name|b1
init|=
operator|(
name|b
operator|>=
literal|0
operator|)
condition|?
name|b
else|:
operator|-
name|b
decl_stmt|;
return|return
operator|(
name|a1
operator|<
name|b1
operator|)
operator|||
operator|(
name|a1
operator|==
name|b1
operator|&&
name|a
operator|>
name|b
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * reorder_node_links  *  * reorder the links out of a switch in sign/dimension order  */
end_comment

begin_function
specifier|static
name|int
name|reorder_node_links
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|mesh_t
modifier|*
name|mesh
parameter_list|,
name|int
name|sw
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|switch_t
modifier|*
name|s
init|=
name|p_lash
operator|->
name|switches
index|[
name|sw
index|]
decl_stmt|;
name|mesh_node_t
modifier|*
name|node
init|=
name|s
operator|->
name|node
decl_stmt|;
name|int
name|n
init|=
name|node
operator|->
name|num_links
decl_stmt|;
name|link_t
modifier|*
modifier|*
name|links
decl_stmt|;
name|int
modifier|*
name|axes
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|l
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|next
init|=
literal|0
decl_stmt|;
name|int
name|dimension
init|=
name|mesh
operator|->
name|dimension
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|links
operator|=
name|calloc
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|link_t
operator|*
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"Failed allocating links array - out of memory\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|axes
operator|=
name|calloc
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|links
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"Failed allocating axes array - out of memory\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * find the links with axes 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dimension
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|mesh
operator|->
name|dim_order
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<=
literal|2
condition|;
name|k
operator|++
control|)
block|{
name|c
operator|=
literal|2
operator|*
name|j
operator|+
name|k
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|coord
index|[
name|j
index|]
operator|>
literal|0
condition|)
name|c
operator|=
name|opposite
argument_list|(
name|s
argument_list|,
name|c
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|n
condition|;
name|l
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|links
index|[
name|l
index|]
condition|)
continue|continue;
if|if
condition|(
name|node
operator|->
name|axes
index|[
name|l
index|]
operator|==
name|c
condition|)
block|{
name|links
index|[
name|next
index|]
operator|=
name|node
operator|->
name|links
index|[
name|l
index|]
expr_stmt|;
name|axes
index|[
name|next
index|]
operator|=
name|node
operator|->
name|axes
index|[
name|l
index|]
expr_stmt|;
name|node
operator|->
name|links
index|[
name|l
index|]
operator|=
name|NULL
expr_stmt|;
name|next
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * get the rest 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|links
index|[
name|i
index|]
condition|)
continue|continue;
name|links
index|[
name|next
index|]
operator|=
name|node
operator|->
name|links
index|[
name|i
index|]
expr_stmt|;
name|axes
index|[
name|next
index|]
operator|=
name|node
operator|->
name|axes
index|[
name|i
index|]
expr_stmt|;
name|node
operator|->
name|links
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|next
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|node
operator|->
name|links
index|[
name|i
index|]
operator|=
name|links
index|[
name|i
index|]
expr_stmt|;
name|node
operator|->
name|axes
index|[
name|i
index|]
operator|=
name|axes
index|[
name|i
index|]
expr_stmt|;
block|}
name|free
argument_list|(
name|links
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|axes
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * make_coord  */
end_comment

begin_function
specifier|static
name|int
name|make_coord
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|mesh_t
modifier|*
name|mesh
parameter_list|,
name|int
name|seed
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|sw
decl_stmt|;
name|switch_t
modifier|*
name|s
decl_stmt|,
modifier|*
name|s1
decl_stmt|;
name|unsigned
name|int
name|change
decl_stmt|;
name|unsigned
name|int
name|dimension
init|=
name|mesh
operator|->
name|dimension
decl_stmt|;
name|int
name|num_switches
init|=
name|p_lash
operator|->
name|num_switches
decl_stmt|;
name|int
name|assigned_axes
init|=
literal|0
decl_stmt|,
name|unassigned_axes
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
for|for
control|(
name|sw
operator|=
literal|0
init|;
name|sw
operator|<
name|num_switches
condition|;
name|sw
operator|++
control|)
block|{
name|s
operator|=
name|p_lash
operator|->
name|switches
index|[
name|sw
index|]
expr_stmt|;
name|s
operator|->
name|node
operator|->
name|coord
operator|=
name|calloc
argument_list|(
name|dimension
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|node
operator|->
name|coord
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"Failed allocating coord - out of memory\n"
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dimension
condition|;
name|i
operator|++
control|)
name|s
operator|->
name|node
operator|->
name|coord
index|[
name|i
index|]
operator|=
operator|(
name|sw
operator|==
name|seed
operator|)
condition|?
literal|0
else|:
name|LARGE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|node
operator|->
name|num_links
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|s
operator|->
name|node
operator|->
name|axes
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|unassigned_axes
operator|++
expr_stmt|;
else|else
name|assigned_axes
operator|++
expr_stmt|;
block|}
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"%d/%d unassigned/assigned axes\n"
argument_list|,
name|unassigned_axes
argument_list|,
name|assigned_axes
argument_list|)
expr_stmt|;
do|do
block|{
name|change
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sw
operator|=
literal|0
init|;
name|sw
operator|<
name|num_switches
condition|;
name|sw
operator|++
control|)
block|{
name|s
operator|=
name|p_lash
operator|->
name|switches
index|[
name|sw
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|node
operator|->
name|coord
index|[
literal|0
index|]
operator|==
name|LARGE
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|s
operator|->
name|node
operator|->
name|num_links
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|s
operator|->
name|node
operator|->
name|axes
index|[
name|j
index|]
condition|)
continue|continue;
name|s1
operator|=
name|p_lash
operator|->
name|switches
index|[
name|s
operator|->
name|node
operator|->
name|links
index|[
name|j
index|]
operator|->
name|switch_id
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|dimension
condition|;
name|k
operator|++
control|)
block|{
name|int
name|coord
init|=
name|s
operator|->
name|node
operator|->
name|coord
index|[
name|k
index|]
decl_stmt|;
name|unsigned
name|axis
init|=
name|s
operator|->
name|node
operator|->
name|axes
index|[
name|j
index|]
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|k
operator|==
name|axis
operator|/
literal|2
condition|)
name|coord
operator|+=
operator|(
name|axis
operator|&
literal|1
operator|)
condition|?
operator|-
literal|1
else|:
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ltmag
argument_list|(
name|coord
argument_list|,
name|s1
operator|->
name|node
operator|->
name|coord
index|[
name|k
index|]
argument_list|)
condition|)
block|{
name|s1
operator|->
name|node
operator|->
name|coord
index|[
name|k
index|]
operator|=
name|coord
expr_stmt|;
name|change
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
do|while
condition|(
name|change
condition|)
do|;
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * measure geometry  */
end_comment

begin_function
specifier|static
name|int
name|measure_geometry
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|mesh_t
modifier|*
name|mesh
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|sw
decl_stmt|;
name|switch_t
modifier|*
name|s
decl_stmt|;
name|int
name|dimension
init|=
name|mesh
operator|->
name|dimension
decl_stmt|;
name|int
name|num_switches
init|=
name|p_lash
operator|->
name|num_switches
decl_stmt|;
name|int
name|max
index|[
name|MAX_DIMENSION
index|]
decl_stmt|;
name|int
name|min
index|[
name|MAX_DIMENSION
index|]
decl_stmt|;
name|int
name|size
index|[
name|MAX_DIMENSION
index|]
decl_stmt|;
name|int
name|max_size
decl_stmt|;
name|int
name|max_index
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|mesh
operator|->
name|size
operator|=
name|calloc
argument_list|(
name|dimension
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mesh
operator|->
name|size
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"Failed allocating size - out of memory\n"
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dimension
condition|;
name|i
operator|++
control|)
block|{
name|max
index|[
name|i
index|]
operator|=
operator|-
name|LARGE
expr_stmt|;
name|min
index|[
name|i
index|]
operator|=
name|LARGE
expr_stmt|;
block|}
for|for
control|(
name|sw
operator|=
literal|0
init|;
name|sw
operator|<
name|num_switches
condition|;
name|sw
operator|++
control|)
block|{
name|s
operator|=
name|p_lash
operator|->
name|switches
index|[
name|sw
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dimension
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|s
operator|->
name|node
operator|->
name|coord
index|[
name|i
index|]
operator|==
name|LARGE
condition|)
continue|continue;
if|if
condition|(
name|s
operator|->
name|node
operator|->
name|coord
index|[
name|i
index|]
operator|>
name|max
index|[
name|i
index|]
condition|)
name|max
index|[
name|i
index|]
operator|=
name|s
operator|->
name|node
operator|->
name|coord
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|node
operator|->
name|coord
index|[
name|i
index|]
operator|<
name|min
index|[
name|i
index|]
condition|)
name|min
index|[
name|i
index|]
operator|=
name|s
operator|->
name|node
operator|->
name|coord
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dimension
condition|;
name|i
operator|++
control|)
name|mesh
operator|->
name|size
index|[
name|i
index|]
operator|=
name|size
index|[
name|i
index|]
operator|=
name|max
index|[
name|i
index|]
operator|-
name|min
index|[
name|i
index|]
operator|+
literal|1
expr_stmt|;
comment|/* 	 * find an order of dimensions that places largest 	 * sizes first since this seems to work best with LASH 	 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|dimension
condition|;
name|j
operator|++
control|)
block|{
name|max_size
operator|=
operator|-
literal|1
expr_stmt|;
name|max_index
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dimension
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|size
index|[
name|i
index|]
operator|>
name|max_size
condition|)
block|{
name|max_size
operator|=
name|size
index|[
name|i
index|]
expr_stmt|;
name|max_index
operator|=
name|i
expr_stmt|;
block|}
block|}
name|mesh
operator|->
name|dim_order
index|[
name|j
index|]
operator|=
name|max_index
expr_stmt|;
name|size
index|[
name|max_index
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * reorder links  */
end_comment

begin_function
specifier|static
name|int
name|reorder_links
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|mesh_t
modifier|*
name|mesh
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|int
name|sw
decl_stmt|;
name|int
name|num_switches
init|=
name|p_lash
operator|->
name|num_switches
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
for|for
control|(
name|sw
operator|=
literal|0
init|;
name|sw
operator|<
name|num_switches
condition|;
name|sw
operator|++
control|)
block|{
if|if
condition|(
name|reorder_node_links
argument_list|(
name|p_lash
argument_list|,
name|mesh
argument_list|,
name|sw
argument_list|)
condition|)
block|{
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * compare two switches in a sort  */
end_comment

begin_function
specifier|static
name|int
name|compare_switches
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|comp_t
modifier|*
name|cp1
init|=
name|p1
decl_stmt|,
modifier|*
name|cp2
init|=
name|p2
decl_stmt|;
specifier|const
name|sort_ctx_t
modifier|*
name|ctx
init|=
operator|&
name|cp1
operator|->
name|ctx
decl_stmt|;
name|switch_t
modifier|*
name|s1
init|=
name|ctx
operator|->
name|p_lash
operator|->
name|switches
index|[
name|cp1
operator|->
name|index
index|]
decl_stmt|;
name|switch_t
modifier|*
name|s2
init|=
name|ctx
operator|->
name|p_lash
operator|->
name|switches
index|[
name|cp2
operator|->
name|index
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|ret
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctx
operator|->
name|mesh
operator|->
name|dimension
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|ctx
operator|->
name|mesh
operator|->
name|dim_order
index|[
name|i
index|]
expr_stmt|;
name|ret
operator|=
name|s1
operator|->
name|node
operator|->
name|coord
index|[
name|j
index|]
operator|-
name|s2
operator|->
name|node
operator|->
name|coord
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * sort_switches - reorder switch array  */
end_comment

begin_function
specifier|static
name|void
name|sort_switches
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|mesh_t
modifier|*
name|mesh
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|int
name|num_switches
init|=
name|p_lash
operator|->
name|num_switches
decl_stmt|;
name|comp_t
modifier|*
name|comp
decl_stmt|;
name|int
modifier|*
name|reverse
decl_stmt|;
name|switch_t
modifier|*
name|s
decl_stmt|;
name|switch_t
modifier|*
modifier|*
name|switches
decl_stmt|;
name|comp
operator|=
name|malloc
argument_list|(
name|num_switches
operator|*
sizeof|sizeof
argument_list|(
name|comp_t
argument_list|)
argument_list|)
expr_stmt|;
name|reverse
operator|=
name|malloc
argument_list|(
name|num_switches
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|switches
operator|=
name|malloc
argument_list|(
name|num_switches
operator|*
sizeof|sizeof
argument_list|(
name|switch_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|comp
operator|||
operator|!
name|reverse
operator|||
operator|!
name|switches
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"Failed memory allocation - switches not sorted!\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_switches
condition|;
name|i
operator|++
control|)
block|{
name|comp
index|[
name|i
index|]
operator|.
name|index
operator|=
name|i
expr_stmt|;
name|comp
index|[
name|i
index|]
operator|.
name|ctx
operator|.
name|mesh
operator|=
name|mesh
expr_stmt|;
name|comp
index|[
name|i
index|]
operator|.
name|ctx
operator|.
name|p_lash
operator|=
name|p_lash
expr_stmt|;
block|}
name|qsort
argument_list|(
name|comp
argument_list|,
name|num_switches
argument_list|,
sizeof|sizeof
argument_list|(
name|comp_t
argument_list|)
argument_list|,
name|compare_switches
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_switches
condition|;
name|i
operator|++
control|)
name|reverse
index|[
name|comp
index|[
name|i
index|]
operator|.
name|index
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_switches
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|p_lash
operator|->
name|switches
index|[
name|comp
index|[
name|i
index|]
operator|.
name|index
index|]
expr_stmt|;
name|switches
index|[
name|i
index|]
operator|=
name|s
expr_stmt|;
name|s
operator|->
name|id
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|s
operator|->
name|node
operator|->
name|num_links
condition|;
name|j
operator|++
control|)
name|s
operator|->
name|node
operator|->
name|links
index|[
name|j
index|]
operator|->
name|switch_id
operator|=
name|reverse
index|[
name|s
operator|->
name|node
operator|->
name|links
index|[
name|j
index|]
operator|->
name|switch_id
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_switches
condition|;
name|i
operator|++
control|)
name|p_lash
operator|->
name|switches
index|[
name|i
index|]
operator|=
name|switches
index|[
name|i
index|]
expr_stmt|;
name|Exit
label|:
if|if
condition|(
name|switches
condition|)
name|free
argument_list|(
name|switches
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
condition|)
name|free
argument_list|(
name|comp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reverse
condition|)
name|free
argument_list|(
name|reverse
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * osm_mesh_delete - free per mesh resources  */
end_comment

begin_function
specifier|static
name|void
name|mesh_delete
parameter_list|(
name|mesh_t
modifier|*
name|mesh
parameter_list|)
block|{
if|if
condition|(
name|mesh
condition|)
block|{
if|if
condition|(
name|mesh
operator|->
name|class_type
condition|)
name|free
argument_list|(
name|mesh
operator|->
name|class_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|mesh
operator|->
name|class_count
condition|)
name|free
argument_list|(
name|mesh
operator|->
name|class_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|mesh
operator|->
name|size
condition|)
name|free
argument_list|(
name|mesh
operator|->
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mesh
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * osm_mesh_create - allocate per mesh resources  */
end_comment

begin_function
specifier|static
name|mesh_t
modifier|*
name|mesh_create
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|mesh_t
modifier|*
name|mesh
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mesh
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|mesh_t
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
operator|(
name|mesh
operator|->
name|class_type
operator|=
name|calloc
argument_list|(
name|p_lash
operator|->
name|num_switches
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
operator|(
name|mesh
operator|->
name|class_count
operator|=
name|calloc
argument_list|(
name|p_lash
operator|->
name|num_switches
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
return|return
name|mesh
return|;
name|err
label|:
name|mesh_delete
argument_list|(
name|mesh
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"Failed allocating mesh - out of memory\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * osm_mesh_node_delete - cleanup per switch resources  */
end_comment

begin_function
name|void
name|osm_mesh_node_delete
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|switch_t
modifier|*
name|sw
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|mesh_node_t
modifier|*
name|node
init|=
name|sw
operator|->
name|node
decl_stmt|;
name|unsigned
name|num_ports
init|=
name|sw
operator|->
name|p_sw
operator|->
name|num_ports
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ports
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|node
operator|->
name|links
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|node
operator|->
name|links
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|poly
condition|)
name|free
argument_list|(
name|node
operator|->
name|poly
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|matrix
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node
operator|->
name|num_links
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|node
operator|->
name|matrix
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|node
operator|->
name|matrix
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|node
operator|->
name|matrix
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|axes
condition|)
name|free
argument_list|(
name|node
operator|->
name|axes
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|coord
condition|)
name|free
argument_list|(
name|node
operator|->
name|coord
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|sw
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * osm_mesh_node_create - allocate per switch resources  */
end_comment

begin_function
name|int
name|osm_mesh_node_create
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|switch_t
modifier|*
name|sw
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|mesh_node_t
modifier|*
name|node
decl_stmt|;
name|unsigned
name|num_ports
init|=
name|sw
operator|->
name|p_sw
operator|->
name|num_ports
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|node
operator|=
name|sw
operator|->
name|node
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|mesh_node_t
argument_list|)
operator|+
name|num_ports
operator|*
sizeof|sizeof
argument_list|(
name|link_t
operator|*
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ports
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|node
operator|->
name|links
index|[
name|i
index|]
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|link_t
argument_list|)
operator|+
name|num_ports
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
operator|(
name|node
operator|->
name|axes
operator|=
name|calloc
argument_list|(
name|num_ports
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|node
operator|->
name|links
index|[
name|i
index|]
operator|->
name|switch_id
operator|=
name|NONE
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err
label|:
name|osm_mesh_node_delete
argument_list|(
name|p_lash
argument_list|,
name|sw
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"Failed allocating mesh node - out of memory\n"
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_mesh
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|int
name|sw
decl_stmt|;
name|int
name|num_switches
init|=
name|p_lash
operator|->
name|num_switches
decl_stmt|;
name|int
name|dimension
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|;
name|switch_t
modifier|*
name|s
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
for|for
control|(
name|sw
operator|=
literal|0
init|;
name|sw
operator|<
name|num_switches
condition|;
name|sw
operator|++
control|)
block|{
name|s
operator|=
name|p_lash
operator|->
name|switches
index|[
name|sw
index|]
expr_stmt|;
name|dimension
operator|=
name|s
operator|->
name|node
operator|->
name|dimension
expr_stmt|;
name|n
operator|=
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dimension
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|n
argument_list|,
literal|"%2d"
argument_list|,
name|s
operator|->
name|node
operator|->
name|coord
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|n
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|dimension
operator|-
literal|1
condition|)
block|{
name|n
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|n
argument_list|,
literal|"%s"
argument_list|,
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|n
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
name|n
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|n
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|n
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|s
operator|->
name|node
operator|->
name|num_links
condition|;
name|j
operator|++
control|)
block|{
name|s2
operator|=
name|p_lash
operator|->
name|switches
index|[
name|s
operator|->
name|node
operator|->
name|links
index|[
name|j
index|]
operator|->
name|switch_id
index|]
expr_stmt|;
name|n
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|n
argument_list|,
literal|" [%d]->["
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|n
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|dimension
condition|;
name|k
operator|++
control|)
block|{
name|n
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|n
argument_list|,
literal|"%2d"
argument_list|,
name|s2
operator|->
name|node
operator|->
name|coord
index|[
name|k
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|n
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|!=
name|dimension
operator|-
literal|1
condition|)
block|{
name|n
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|n
argument_list|,
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|n
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
name|n
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|n
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|n
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * osm_do_mesh_analysis  */
end_comment

begin_function
name|int
name|osm_do_mesh_analysis
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|mesh_t
modifier|*
name|mesh
decl_stmt|;
name|int
name|max_class_num
init|=
literal|0
decl_stmt|;
name|int
name|max_class_type
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|switch_t
modifier|*
name|s
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|mesh
operator|=
name|mesh_create
argument_list|(
name|p_lash
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mesh
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|get_local_geometry
argument_list|(
name|p_lash
argument_list|,
name|mesh
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|mesh
operator|->
name|num_class
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"found no likely mesh nodes - done\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * find dominant switch class 	 */
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"found %d node class%s\n"
argument_list|,
name|mesh
operator|->
name|num_class
argument_list|,
operator|(
name|mesh
operator|->
name|num_class
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"es"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mesh
operator|->
name|num_class
condition|;
name|i
operator|++
control|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"class[%d] has %d members with type = %d\n"
argument_list|,
name|i
argument_list|,
name|mesh
operator|->
name|class_count
index|[
name|i
index|]
argument_list|,
name|p_lash
operator|->
name|switches
index|[
name|mesh
operator|->
name|class_type
index|[
name|i
index|]
index|]
operator|->
name|node
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|mesh
operator|->
name|class_count
index|[
name|i
index|]
operator|>
name|max_class_num
condition|)
block|{
name|max_class_num
operator|=
name|mesh
operator|->
name|class_count
index|[
name|i
index|]
expr_stmt|;
name|max_class_type
operator|=
name|mesh
operator|->
name|class_type
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|s
operator|=
name|p_lash
operator|->
name|switches
index|[
name|max_class_type
index|]
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
name|p
operator|+=
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%snode shape is "
argument_list|,
operator|(
name|mesh
operator|->
name|num_class
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"most common "
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|node
operator|->
name|type
condition|)
block|{
specifier|const
name|struct
name|mesh_info
modifier|*
name|t
init|=
operator|&
name|mesh_info
index|[
name|s
operator|->
name|node
operator|->
name|type
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|dimension
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|+=
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s%d%s"
argument_list|,
name|i
condition|?
literal|" x "
else|:
literal|""
argument_list|,
name|t
operator|->
name|size
index|[
name|i
index|]
argument_list|,
operator|(
name|t
operator|->
name|size
index|[
name|i
index|]
operator|==
literal|6
operator|)
condition|?
literal|"+"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|p
operator|+=
name|sprintf
argument_list|(
name|p
argument_list|,
literal|" mesh\n"
argument_list|)
expr_stmt|;
name|mesh
operator|->
name|dimension
operator|=
name|t
operator|->
name|dimension
expr_stmt|;
block|}
else|else
block|{
name|p
operator|+=
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"unknown geometry\n"
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"poly = %s\n"
argument_list|,
name|poly_print
argument_list|(
name|s
operator|->
name|node
operator|->
name|num_links
argument_list|,
name|s
operator|->
name|node
operator|->
name|poly
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|node
operator|->
name|type
condition|)
block|{
name|make_geometry
argument_list|(
name|p_lash
argument_list|,
name|max_class_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_coord
argument_list|(
name|p_lash
argument_list|,
name|mesh
argument_list|,
name|max_class_type
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|measure_geometry
argument_list|(
name|p_lash
argument_list|,
name|mesh
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|reorder_links
argument_list|(
name|p_lash
argument_list|,
name|mesh
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|sort_switches
argument_list|(
name|p_lash
argument_list|,
name|mesh
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
name|p
operator|+=
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"found "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mesh
operator|->
name|dimension
condition|;
name|i
operator|++
control|)
name|p
operator|+=
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s%d"
argument_list|,
name|i
condition|?
literal|" x "
else|:
literal|""
argument_list|,
name|mesh
operator|->
name|size
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
name|sprintf
argument_list|(
name|p
argument_list|,
literal|" mesh\n"
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
name|dump_mesh
argument_list|(
name|p_lash
argument_list|)
expr_stmt|;
name|done
label|:
name|mesh_delete
argument_list|(
name|mesh
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err
label|:
name|mesh_delete
argument_list|(
name|mesh
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

end_unit

