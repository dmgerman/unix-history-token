begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2009 Sun Microsystems, Inc. All rights reserved.  * Copyright (c) 2004-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2010 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_vl15_t.  * This object represents the VL15 Interface object.  * This object is part of the opensm family of objects.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_thread.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_VL15INTF_C
end_define

begin_include
include|#
directive|include
file|<vendor/osm_vendor_api.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_vl15intf.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_madw.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_function
specifier|static
name|void
name|vl15_send_mad
parameter_list|(
name|osm_vl15_t
modifier|*
name|p_vl
parameter_list|,
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|)
block|{
name|ib_api_status_t
name|status
decl_stmt|;
name|boolean_t
name|resp_expected
init|=
name|p_madw
operator|->
name|resp_expected
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|ib_net16_t
name|attr_id
decl_stmt|;
name|uint8_t
name|method
decl_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|method
operator|=
name|p_smp
operator|->
name|method
expr_stmt|;
name|attr_id
operator|=
name|p_smp
operator|->
name|attr_id
expr_stmt|;
comment|/* 	   Non-response-expected mads are not throttled on the wire 	   since we can have no confirmation that they arrived 	   at their destination. 	 */
if|if
condition|(
name|resp_expected
condition|)
comment|/* 		   Note that other threads may not see the response MAD 		   arrive before send() even returns. 		   In that case, the wire count would temporarily go negative. 		   To avoid this confusion, preincrement the counts on the 		   assumption that send() will succeed. 		 */
name|cl_atomic_inc
argument_list|(
operator|&
name|p_vl
operator|->
name|p_stats
operator|->
name|qp0_mads_outstanding_on_wire
argument_list|)
expr_stmt|;
else|else
name|cl_atomic_inc
argument_list|(
operator|&
name|p_vl
operator|->
name|p_stats
operator|->
name|qp0_unicasts_sent
argument_list|)
expr_stmt|;
name|cl_atomic_inc
argument_list|(
operator|&
name|p_vl
operator|->
name|p_stats
operator|->
name|qp0_mads_sent
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_vendor_send
argument_list|(
name|osm_madw_get_bind_handle
argument_list|(
name|p_madw
argument_list|)
argument_list|,
name|p_madw
argument_list|,
name|p_madw
operator|->
name|resp_expected
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_vl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"%u QP0 MADs on wire, %u outstanding, "
literal|"%u unicasts sent, %u total sent\n"
argument_list|,
name|p_vl
operator|->
name|p_stats
operator|->
name|qp0_mads_outstanding_on_wire
argument_list|,
name|p_vl
operator|->
name|p_stats
operator|->
name|qp0_mads_outstanding
argument_list|,
name|p_vl
operator|->
name|p_stats
operator|->
name|qp0_unicasts_sent
argument_list|,
name|p_vl
operator|->
name|p_stats
operator|->
name|qp0_mads_sent
argument_list|)
expr_stmt|;
return|return;
block|}
name|OSM_LOG
argument_list|(
name|p_vl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3E03: "
literal|"MAD send failed (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	   The MAD was never successfully sent, so 	   fix up the pre-incremented count values. 	 */
comment|/* Decrement qp0_mads_sent that were incremented in the code above. 	   qp0_mads_outstanding will be decremented by send error callback 	   (called by osm_vendor_send() */
name|cl_atomic_dec
argument_list|(
operator|&
name|p_vl
operator|->
name|p_stats
operator|->
name|qp0_mads_sent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resp_expected
condition|)
block|{
name|cl_atomic_dec
argument_list|(
operator|&
name|p_vl
operator|->
name|p_stats
operator|->
name|qp0_unicasts_sent
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* need to cause heavy-sweep if resp_expected MAD sending failed */
name|OSM_LOG
argument_list|(
name|p_vl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3E04: "
literal|"%s method failed for attribute 0x%X (%s)\n"
argument_list|,
name|method
operator|==
name|IB_MAD_METHOD_SET
condition|?
literal|"SET"
else|:
literal|"GET"
argument_list|,
name|cl_ntoh16
argument_list|(
name|attr_id
argument_list|)
argument_list|,
name|ib_get_sm_attr_str
argument_list|(
name|attr_id
argument_list|)
argument_list|)
expr_stmt|;
name|p_vl
operator|->
name|p_subn
operator|->
name|subnet_initialization_error
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vl15_poller
parameter_list|(
name|IN
name|void
modifier|*
name|p_ptr
parameter_list|)
block|{
name|ib_api_status_t
name|status
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_madw
decl_stmt|;
name|osm_vl15_t
modifier|*
name|p_vl
init|=
name|p_ptr
decl_stmt|;
name|cl_qlist_t
modifier|*
name|p_fifo
decl_stmt|;
name|int32_t
name|max_smps
init|=
name|p_vl
operator|->
name|max_wire_smps
decl_stmt|;
name|int32_t
name|max_smps2
init|=
name|p_vl
operator|->
name|max_wire_smps2
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_vl
operator|->
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_vl
operator|->
name|thread_state
operator|==
name|OSM_THREAD_STATE_NONE
condition|)
name|p_vl
operator|->
name|thread_state
operator|=
name|OSM_THREAD_STATE_RUN
expr_stmt|;
while|while
condition|(
name|p_vl
operator|->
name|thread_state
operator|==
name|OSM_THREAD_STATE_RUN
condition|)
block|{
comment|/* 		   Start servicing the FIFOs by pulling off MAD wrappers 		   and passing them to the transport interface. 		   There are lots of corner cases here so tread carefully.  		   The unicast FIFO has priority, since somebody is waiting 		   for a timely response. 		 */
name|cl_spinlock_acquire
argument_list|(
operator|&
name|p_vl
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl_qlist_count
argument_list|(
operator|&
name|p_vl
operator|->
name|ufifo
argument_list|)
operator|!=
literal|0
condition|)
name|p_fifo
operator|=
operator|&
name|p_vl
operator|->
name|ufifo
expr_stmt|;
else|else
name|p_fifo
operator|=
operator|&
name|p_vl
operator|->
name|rfifo
expr_stmt|;
name|p_madw
operator|=
operator|(
name|osm_madw_t
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
name|p_fifo
argument_list|)
expr_stmt|;
name|cl_spinlock_release
argument_list|(
operator|&
name|p_vl
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_madw
operator|!=
operator|(
name|osm_madw_t
operator|*
operator|)
name|cl_qlist_end
argument_list|(
name|p_fifo
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_vl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Servicing p_madw = %p\n"
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
if|if
condition|(
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
name|p_vl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_FRAMES
argument_list|)
condition|)
name|osm_dump_dr_smp_v2
argument_list|(
name|p_vl
operator|->
name|p_log
argument_list|,
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
argument_list|,
name|FILE_ID
argument_list|,
name|OSM_LOG_FRAMES
argument_list|)
expr_stmt|;
name|vl15_send_mad
argument_list|(
name|p_vl
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* 			   The VL15 FIFO is empty, so we have nothing left to do. 			 */
name|status
operator|=
name|cl_event_wait_on
argument_list|(
operator|&
name|p_vl
operator|->
name|signal
argument_list|,
name|EVENT_NO_TIMEOUT
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_vl
operator|->
name|p_stats
operator|->
name|qp0_mads_outstanding_on_wire
operator|>=
name|max_smps
operator|&&
name|p_vl
operator|->
name|thread_state
operator|==
name|OSM_THREAD_STATE_RUN
condition|)
block|{
name|status
operator|=
name|cl_event_wait_on
argument_list|(
operator|&
name|p_vl
operator|->
name|signal
argument_list|,
name|p_vl
operator|->
name|max_smps_timeout
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|CL_TIMEOUT
condition|)
block|{
if|if
condition|(
name|max_smps
operator|<
name|max_smps2
condition|)
name|max_smps
operator|++
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|status
operator|!=
name|CL_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_vl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3E02: "
literal|"Event wait failed (%s)\n"
argument_list|,
name|CL_STATUS_MSG
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|max_smps
operator|=
name|p_vl
operator|->
name|max_wire_smps
expr_stmt|;
block|}
block|}
comment|/* 	   since we abort immediately when the state != OSM_THREAD_STATE_RUN 	   we might have some mads on the queues. After the thread exits 	   the vl15 destroy routine should put these mads back... 	 */
name|OSM_LOG_EXIT
argument_list|(
name|p_vl
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_vl15_construct
parameter_list|(
name|IN
name|osm_vl15_t
modifier|*
name|p_vl
parameter_list|)
block|{
name|memset
argument_list|(
name|p_vl
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_vl
argument_list|)
argument_list|)
expr_stmt|;
name|p_vl
operator|->
name|state
operator|=
name|OSM_VL15_STATE_INIT
expr_stmt|;
name|p_vl
operator|->
name|thread_state
operator|=
name|OSM_THREAD_STATE_NONE
expr_stmt|;
name|cl_event_construct
argument_list|(
operator|&
name|p_vl
operator|->
name|signal
argument_list|)
expr_stmt|;
name|cl_spinlock_construct
argument_list|(
operator|&
name|p_vl
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cl_qlist_init
argument_list|(
operator|&
name|p_vl
operator|->
name|rfifo
argument_list|)
expr_stmt|;
name|cl_qlist_init
argument_list|(
operator|&
name|p_vl
operator|->
name|ufifo
argument_list|)
expr_stmt|;
name|cl_thread_construct
argument_list|(
operator|&
name|p_vl
operator|->
name|poller
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_vl15_destroy
parameter_list|(
name|IN
name|osm_vl15_t
modifier|*
name|p_vl
parameter_list|,
name|IN
name|struct
name|osm_mad_pool
modifier|*
name|p_pool
parameter_list|)
block|{
name|osm_madw_t
modifier|*
name|p_madw
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_vl
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	   Signal our threads that we're leaving. 	 */
name|p_vl
operator|->
name|thread_state
operator|=
name|OSM_THREAD_STATE_EXIT
expr_stmt|;
comment|/* 	   Don't trigger unless event has been initialized. 	   Destroy the thread before we tear down the other objects. 	 */
if|if
condition|(
name|p_vl
operator|->
name|state
operator|!=
name|OSM_VL15_STATE_INIT
condition|)
name|cl_event_signal
argument_list|(
operator|&
name|p_vl
operator|->
name|signal
argument_list|)
expr_stmt|;
name|cl_thread_destroy
argument_list|(
operator|&
name|p_vl
operator|->
name|poller
argument_list|)
expr_stmt|;
comment|/* 	   Return the outstanding messages to the pool 	 */
name|cl_spinlock_acquire
argument_list|(
operator|&
name|p_vl
operator|->
name|lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|cl_is_qlist_empty
argument_list|(
operator|&
name|p_vl
operator|->
name|rfifo
argument_list|)
condition|)
block|{
name|p_madw
operator|=
operator|(
name|osm_madw_t
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
operator|&
name|p_vl
operator|->
name|rfifo
argument_list|)
expr_stmt|;
name|osm_mad_pool_put
argument_list|(
name|p_pool
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|cl_is_qlist_empty
argument_list|(
operator|&
name|p_vl
operator|->
name|ufifo
argument_list|)
condition|)
block|{
name|p_madw
operator|=
operator|(
name|osm_madw_t
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
operator|&
name|p_vl
operator|->
name|ufifo
argument_list|)
expr_stmt|;
name|osm_mad_pool_put
argument_list|(
name|p_pool
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
block|}
name|cl_spinlock_release
argument_list|(
operator|&
name|p_vl
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cl_event_destroy
argument_list|(
operator|&
name|p_vl
operator|->
name|signal
argument_list|)
expr_stmt|;
name|p_vl
operator|->
name|state
operator|=
name|OSM_VL15_STATE_INIT
expr_stmt|;
name|cl_spinlock_destroy
argument_list|(
operator|&
name|p_vl
operator|->
name|lock
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_vl
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ib_api_status_t
name|osm_vl15_init
parameter_list|(
name|IN
name|osm_vl15_t
modifier|*
name|p_vl
parameter_list|,
name|IN
name|osm_vendor_t
modifier|*
name|p_vend
parameter_list|,
name|IN
name|osm_log_t
modifier|*
name|p_log
parameter_list|,
name|IN
name|osm_stats_t
modifier|*
name|p_stats
parameter_list|,
name|IN
name|osm_subn_t
modifier|*
name|p_subn
parameter_list|,
name|IN
name|int32_t
name|max_wire_smps
parameter_list|,
name|IN
name|int32_t
name|max_wire_smps2
parameter_list|,
name|IN
name|uint32_t
name|max_smps_timeout
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|p_vl
operator|->
name|p_vend
operator|=
name|p_vend
expr_stmt|;
name|p_vl
operator|->
name|p_log
operator|=
name|p_log
expr_stmt|;
name|p_vl
operator|->
name|p_stats
operator|=
name|p_stats
expr_stmt|;
name|p_vl
operator|->
name|p_subn
operator|=
name|p_subn
expr_stmt|;
name|p_vl
operator|->
name|max_wire_smps
operator|=
name|max_wire_smps
expr_stmt|;
name|p_vl
operator|->
name|max_wire_smps2
operator|=
name|max_wire_smps2
expr_stmt|;
name|p_vl
operator|->
name|max_smps_timeout
operator|=
name|max_wire_smps
operator|<
name|max_wire_smps2
condition|?
name|max_smps_timeout
else|:
name|EVENT_NO_TIMEOUT
expr_stmt|;
name|status
operator|=
name|cl_event_init
argument_list|(
operator|&
name|p_vl
operator|->
name|signal
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
name|p_vl
operator|->
name|state
operator|=
name|OSM_VL15_STATE_READY
expr_stmt|;
name|status
operator|=
name|cl_spinlock_init
argument_list|(
operator|&
name|p_vl
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
comment|/* 	   Initialize the thread after all other dependent objects 	   have been initialized. 	 */
name|status
operator|=
name|cl_thread_init
argument_list|(
operator|&
name|p_vl
operator|->
name|poller
argument_list|,
name|vl15_poller
argument_list|,
name|p_vl
argument_list|,
literal|"opensm poller"
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|void
name|osm_vl15_poll
parameter_list|(
name|IN
name|osm_vl15_t
modifier|*
name|p_vl
parameter_list|)
block|{
name|OSM_LOG_ENTER
argument_list|(
name|p_vl
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_vl
operator|->
name|state
operator|==
name|OSM_VL15_STATE_READY
argument_list|)
expr_stmt|;
comment|/* 	   If we have room for more VL15 MADs on the wire, 	   then signal the poller thread.  	   This is not an airtight check, since the poller thread 	   could be just about to send another MAD as we signal 	   the event here.  To cover this rare case, the poller 	   thread checks for a spurious wake-up. 	 */
if|if
condition|(
name|p_vl
operator|->
name|p_stats
operator|->
name|qp0_mads_outstanding_on_wire
operator|<
operator|(
name|int32_t
operator|)
name|p_vl
operator|->
name|max_wire_smps
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_vl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Signalling poller thread\n"
argument_list|)
expr_stmt|;
name|cl_event_signal
argument_list|(
operator|&
name|p_vl
operator|->
name|signal
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|p_vl
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_vl15_post
parameter_list|(
name|IN
name|osm_vl15_t
modifier|*
name|p_vl
parameter_list|,
name|IN
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|)
block|{
name|OSM_LOG_ENTER
argument_list|(
name|p_vl
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_vl
operator|->
name|state
operator|==
name|OSM_VL15_STATE_READY
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_vl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Posting p_madw = %p\n"
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
comment|/* 	   Determine in which fifo to place the pending madw. 	 */
name|cl_spinlock_acquire
argument_list|(
operator|&
name|p_vl
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_madw
operator|->
name|resp_expected
operator|==
name|TRUE
condition|)
block|{
name|cl_qlist_insert_tail
argument_list|(
operator|&
name|p_vl
operator|->
name|rfifo
argument_list|,
operator|&
name|p_madw
operator|->
name|list_item
argument_list|)
expr_stmt|;
name|osm_stats_inc_qp0_outstanding
argument_list|(
name|p_vl
operator|->
name|p_stats
argument_list|)
expr_stmt|;
block|}
else|else
name|cl_qlist_insert_tail
argument_list|(
operator|&
name|p_vl
operator|->
name|ufifo
argument_list|,
operator|&
name|p_madw
operator|->
name|list_item
argument_list|)
expr_stmt|;
name|cl_spinlock_release
argument_list|(
operator|&
name|p_vl
operator|->
name|lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_vl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"%u QP0 MADs on wire, %u QP0 MADs outstanding\n"
argument_list|,
name|p_vl
operator|->
name|p_stats
operator|->
name|qp0_mads_outstanding_on_wire
argument_list|,
name|p_vl
operator|->
name|p_stats
operator|->
name|qp0_mads_outstanding
argument_list|)
expr_stmt|;
name|osm_vl15_poll
argument_list|(
name|p_vl
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_vl
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_vl15_shutdown
parameter_list|(
name|IN
name|osm_vl15_t
modifier|*
name|p_vl
parameter_list|,
name|IN
name|osm_mad_pool_t
modifier|*
name|p_mad_pool
parameter_list|)
block|{
name|osm_madw_t
modifier|*
name|p_madw
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_vl
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* we only should get here after the VL15 interface was initialized */
name|CL_ASSERT
argument_list|(
name|p_vl
operator|->
name|state
operator|==
name|OSM_VL15_STATE_READY
argument_list|)
expr_stmt|;
comment|/* grab a lock on the object */
name|cl_spinlock_acquire
argument_list|(
operator|&
name|p_vl
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* go over all outstanding MADs and retire their transactions */
comment|/* first we handle the list of response MADs */
name|p_madw
operator|=
operator|(
name|osm_madw_t
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
operator|&
name|p_vl
operator|->
name|ufifo
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_madw
operator|!=
operator|(
name|osm_madw_t
operator|*
operator|)
name|cl_qlist_end
argument_list|(
operator|&
name|p_vl
operator|->
name|ufifo
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_vl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Releasing Response p_madw = %p\n"
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
name|osm_mad_pool_put
argument_list|(
name|p_mad_pool
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
name|p_madw
operator|=
operator|(
name|osm_madw_t
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
operator|&
name|p_vl
operator|->
name|ufifo
argument_list|)
expr_stmt|;
block|}
comment|/* Request MADs we send out */
name|p_madw
operator|=
operator|(
name|osm_madw_t
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
operator|&
name|p_vl
operator|->
name|rfifo
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_madw
operator|!=
operator|(
name|osm_madw_t
operator|*
operator|)
name|cl_qlist_end
argument_list|(
operator|&
name|p_vl
operator|->
name|rfifo
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_vl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Releasing Request p_madw = %p\n"
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
name|osm_mad_pool_put
argument_list|(
name|p_mad_pool
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
name|osm_stats_dec_qp0_outstanding
argument_list|(
name|p_vl
operator|->
name|p_stats
argument_list|)
expr_stmt|;
name|p_madw
operator|=
operator|(
name|osm_madw_t
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
operator|&
name|p_vl
operator|->
name|rfifo
argument_list|)
expr_stmt|;
block|}
comment|/* free the lock */
name|cl_spinlock_release
argument_list|(
operator|&
name|p_vl
operator|->
name|lock
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_vl
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

