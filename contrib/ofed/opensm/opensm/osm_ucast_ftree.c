begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2009 Simula Research Laboratory. All rights reserved.  * Copyright (c) 2009 Sun Microsystems, Inc. All rights reserved.  * Copyright (c) 2004-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2011 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of OpenSM FatTree routing  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qmap.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_UCAST_FTREE_C
end_define

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_switch.h>
end_include

begin_comment
comment|/*  * FatTree rank is bounded between 2 and 8:  *  - Tree of rank 1 has only trivial routing paths,  *    so no need to use FatTree routing.  *  - Why maximum rank is 8:  *    Each node (switch) is assigned a unique tuple.  *    Switches are stored in two cl_qmaps - one is  *    ordered by guid, and the other by a key that is  *    generated from tuple. Since cl_qmap supports only  *    a 64-bit key, the maximal tuple length is 8 bytes.  *    which means that maximal tree rank is 8.  * Note that the above also implies that each switch  * can have at max 255 up/down ports.  */
end_comment

begin_define
define|#
directive|define
name|FAT_TREE_MIN_RANK
value|2
end_define

begin_define
define|#
directive|define
name|FAT_TREE_MAX_RANK
value|8
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|FTREE_DIRECTION_DOWN
init|=
operator|-
literal|1
block|,
name|FTREE_DIRECTION_SAME
block|,
name|FTREE_DIRECTION_UP
block|}
name|ftree_direction_t
typedef|;
end_typedef

begin_comment
comment|/***************************************************  **  **  Forward references  **  ***************************************************/
end_comment

begin_struct_decl
struct_decl|struct
name|ftree_sw_t_
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|ftree_hca_t_
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|ftree_port_t_
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|ftree_port_group_t_
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|ftree_fabric_t_
struct_decl|;
end_struct_decl

begin_comment
comment|/***************************************************  **  **  ftree_tuple_t definition  **  ***************************************************/
end_comment

begin_define
define|#
directive|define
name|FTREE_TUPLE_BUFF_LEN
value|1024
end_define

begin_define
define|#
directive|define
name|FTREE_TUPLE_LEN
value|8
end_define

begin_typedef
typedef|typedef
name|uint8_t
name|ftree_tuple_t
index|[
name|FTREE_TUPLE_LEN
index|]
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint64_t
name|ftree_tuple_key_t
typedef|;
end_typedef

begin_comment
comment|/***************************************************  **  **  ftree_sw_table_element_t definition  **  ***************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|cl_map_item_t
name|map_item
decl_stmt|;
name|struct
name|ftree_sw_t_
modifier|*
name|p_sw
decl_stmt|;
block|}
name|ftree_sw_tbl_element_t
typedef|;
end_typedef

begin_comment
comment|/***************************************************  **  **  ftree_port_t definition  **  ***************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ftree_port_t_
block|{
name|cl_map_item_t
name|map_item
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
comment|/* port number on the current node */
name|uint8_t
name|remote_port_num
decl_stmt|;
comment|/* port number on the remote node */
name|uint32_t
name|counter_up
decl_stmt|;
comment|/* number of allocated routes upwards */
name|uint32_t
name|counter_down
decl_stmt|;
comment|/* number of allocated routes downwards */
block|}
name|ftree_port_t
typedef|;
end_typedef

begin_comment
comment|/***************************************************  **  **  ftree_port_group_t definition  **  ***************************************************/
end_comment

begin_typedef
typedef|typedef
union|union
name|ftree_hca_or_sw_
block|{
name|struct
name|ftree_hca_t_
modifier|*
name|p_hca
decl_stmt|;
name|struct
name|ftree_sw_t_
modifier|*
name|p_sw
decl_stmt|;
block|}
name|ftree_hca_or_sw
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|ftree_port_group_t_
block|{
name|cl_map_item_t
name|map_item
decl_stmt|;
name|uint16_t
name|lid
decl_stmt|;
comment|/* lid of the current node */
name|uint16_t
name|remote_lid
decl_stmt|;
comment|/* lid of the remote node */
name|ib_net64_t
name|port_guid
decl_stmt|;
comment|/* port guid of this port */
name|ib_net64_t
name|node_guid
decl_stmt|;
comment|/* this node's guid */
name|uint8_t
name|node_type
decl_stmt|;
comment|/* this node's type */
name|ib_net64_t
name|remote_port_guid
decl_stmt|;
comment|/* port guid of the remote port */
name|ib_net64_t
name|remote_node_guid
decl_stmt|;
comment|/* node guid of the remote node */
name|uint8_t
name|remote_node_type
decl_stmt|;
comment|/* IB_NODE_TYPE_{CA,SWITCH,ROUTER,...} */
name|ftree_hca_or_sw
name|hca_or_sw
decl_stmt|;
comment|/* pointer to this hca/switch */
name|ftree_hca_or_sw
name|remote_hca_or_sw
decl_stmt|;
comment|/* pointer to remote hca/switch */
name|cl_ptr_vector_t
name|ports
decl_stmt|;
comment|/* vector of ports to the same lid */
name|boolean_t
name|is_cn
decl_stmt|;
comment|/* whether this port is a compute node */
name|boolean_t
name|is_io
decl_stmt|;
comment|/* whether this port is an I/O node */
name|uint32_t
name|counter_down
decl_stmt|;
comment|/* number of allocated routes downwards */
name|uint32_t
name|counter_up
decl_stmt|;
comment|/* number of allocated routes upwards */
block|}
name|ftree_port_group_t
typedef|;
end_typedef

begin_comment
comment|/***************************************************  **  **  ftree_sw_t definition  **  ***************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ftree_sw_t_
block|{
name|cl_map_item_t
name|map_item
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_osm_sw
decl_stmt|;
name|uint32_t
name|rank
decl_stmt|;
name|ftree_tuple_t
name|tuple
decl_stmt|;
name|uint16_t
name|lid
decl_stmt|;
name|ftree_port_group_t
modifier|*
modifier|*
name|down_port_groups
decl_stmt|;
name|uint8_t
name|down_port_groups_num
decl_stmt|;
name|ftree_port_group_t
modifier|*
modifier|*
name|sibling_port_groups
decl_stmt|;
name|uint8_t
name|sibling_port_groups_num
decl_stmt|;
name|ftree_port_group_t
modifier|*
modifier|*
name|up_port_groups
decl_stmt|;
name|uint8_t
name|up_port_groups_num
decl_stmt|;
name|boolean_t
name|is_leaf
decl_stmt|;
name|unsigned
name|down_port_groups_idx
decl_stmt|;
name|uint8_t
modifier|*
name|hops
decl_stmt|;
name|uint32_t
name|min_counter_down
decl_stmt|;
name|boolean_t
name|counter_up_changed
decl_stmt|;
block|}
name|ftree_sw_t
typedef|;
end_typedef

begin_comment
comment|/***************************************************  **  **  ftree_hca_t definition  **  ***************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ftree_hca_t_
block|{
name|cl_map_item_t
name|map_item
decl_stmt|;
name|osm_node_t
modifier|*
name|p_osm_node
decl_stmt|;
name|ftree_port_group_t
modifier|*
modifier|*
name|up_port_groups
decl_stmt|;
name|uint8_t
modifier|*
name|disconnected_ports
decl_stmt|;
name|uint16_t
name|up_port_groups_num
decl_stmt|;
name|unsigned
name|cn_num
decl_stmt|;
block|}
name|ftree_hca_t
typedef|;
end_typedef

begin_comment
comment|/***************************************************  **  **  ftree_fabric_t definition  **  ***************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ftree_fabric_t_
block|{
name|osm_opensm_t
modifier|*
name|p_osm
decl_stmt|;
name|osm_subn_t
modifier|*
name|p_subn
decl_stmt|;
name|cl_qmap_t
name|hca_tbl
decl_stmt|;
name|cl_qmap_t
name|sw_tbl
decl_stmt|;
name|cl_qmap_t
name|sw_by_tuple_tbl
decl_stmt|;
name|cl_qmap_t
name|cn_guid_tbl
decl_stmt|;
name|cl_qmap_t
name|io_guid_tbl
decl_stmt|;
name|unsigned
name|cn_num
decl_stmt|;
name|unsigned
name|ca_ports
decl_stmt|;
name|uint8_t
name|leaf_switch_rank
decl_stmt|;
name|uint8_t
name|max_switch_rank
decl_stmt|;
name|ftree_sw_t
modifier|*
modifier|*
name|leaf_switches
decl_stmt|;
name|uint32_t
name|leaf_switches_num
decl_stmt|;
name|uint16_t
name|max_cn_per_leaf
decl_stmt|;
name|uint16_t
name|lft_max_lid
decl_stmt|;
name|boolean_t
name|fabric_built
decl_stmt|;
block|}
name|ftree_fabric_t
typedef|;
end_typedef

begin_function
specifier|static
specifier|inline
name|osm_subn_t
modifier|*
name|ftree_get_subnet
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
return|return
name|p_ftree
operator|->
name|p_subn
return|;
block|}
end_function

begin_comment
comment|/***************************************************  **  ** comparators  **  ***************************************************/
end_comment

begin_function
specifier|static
name|int
name|compare_switches_by_index
parameter_list|(
name|IN
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
name|IN
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
modifier|*
name|pp_sw1
init|=
operator|(
name|ftree_sw_t
operator|*
operator|*
operator|)
name|p1
decl_stmt|;
name|ftree_sw_t
modifier|*
modifier|*
name|pp_sw2
init|=
operator|(
name|ftree_sw_t
operator|*
operator|*
operator|)
name|p2
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FTREE_TUPLE_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|pp_sw1
operator|)
operator|->
name|tuple
index|[
name|i
index|]
operator|>
operator|(
operator|*
name|pp_sw2
operator|)
operator|->
name|tuple
index|[
name|i
index|]
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
operator|*
name|pp_sw1
operator|)
operator|->
name|tuple
index|[
name|i
index|]
operator|<
operator|(
operator|*
name|pp_sw2
operator|)
operator|->
name|tuple
index|[
name|i
index|]
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|int
name|compare_port_groups_by_remote_switch_index
parameter_list|(
name|IN
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
name|IN
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
name|ftree_port_group_t
modifier|*
modifier|*
name|pp_g1
init|=
operator|(
name|ftree_port_group_t
operator|*
operator|*
operator|)
name|p1
decl_stmt|;
name|ftree_port_group_t
modifier|*
modifier|*
name|pp_g2
init|=
operator|(
name|ftree_port_group_t
operator|*
operator|*
operator|)
name|p2
decl_stmt|;
return|return
name|compare_switches_by_index
argument_list|(
operator|&
operator|(
operator|(
operator|*
name|pp_g1
operator|)
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
operator|)
argument_list|,
operator|&
operator|(
operator|(
operator|*
name|pp_g2
operator|)
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************  **  ** ftree_tuple_t functions  **  ***************************************************/
end_comment

begin_function
specifier|static
name|void
name|tuple_init
parameter_list|(
name|IN
name|ftree_tuple_t
name|tuple
parameter_list|)
block|{
name|memset
argument_list|(
name|tuple
argument_list|,
literal|0xFF
argument_list|,
name|FTREE_TUPLE_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|boolean_t
name|tuple_assigned
parameter_list|(
name|IN
name|ftree_tuple_t
name|tuple
parameter_list|)
block|{
return|return
operator|(
name|tuple
index|[
literal|0
index|]
operator|!=
literal|0xFF
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_define
define|#
directive|define
name|FTREE_TUPLE_BUFFERS_NUM
value|6
end_define

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|tuple_to_str
parameter_list|(
name|IN
name|ftree_tuple_t
name|tuple
parameter_list|)
block|{
specifier|static
name|char
name|buffer
index|[
name|FTREE_TUPLE_BUFFERS_NUM
index|]
index|[
name|FTREE_TUPLE_BUFF_LEN
index|]
decl_stmt|;
specifier|static
name|uint8_t
name|ind
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|ret_buffer
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|tuple_assigned
argument_list|(
name|tuple
argument_list|)
condition|)
return|return
literal|"INDEX.NOT.ASSIGNED"
return|;
name|buffer
index|[
name|ind
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|FTREE_TUPLE_LEN
operator|)
operator|&&
operator|(
name|tuple
index|[
name|i
index|]
operator|!=
literal|0xFF
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|buffer
index|[
name|ind
index|]
argument_list|)
operator|+
literal|10
operator|)
operator|>
name|FTREE_TUPLE_BUFF_LEN
condition|)
return|return
literal|"INDEX.TOO.LONG"
return|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|strcat
argument_list|(
name|buffer
index|[
name|ind
index|]
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|&
name|buffer
index|[
name|ind
index|]
index|[
name|strlen
argument_list|(
name|buffer
index|[
name|ind
index|]
argument_list|)
index|]
argument_list|,
literal|"%u"
argument_list|,
name|tuple
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|ret_buffer
operator|=
name|buffer
index|[
name|ind
index|]
expr_stmt|;
name|ind
operator|=
operator|(
name|ind
operator|+
literal|1
operator|)
operator|%
name|FTREE_TUPLE_BUFFERS_NUM
expr_stmt|;
return|return
name|ret_buffer
return|;
block|}
end_function

begin_comment
comment|/* tuple_to_str() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|ftree_tuple_key_t
name|tuple_to_key
parameter_list|(
name|IN
name|ftree_tuple_t
name|tuple
parameter_list|)
block|{
name|ftree_tuple_key_t
name|key
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|key
argument_list|,
name|tuple
argument_list|,
name|FTREE_TUPLE_LEN
argument_list|)
expr_stmt|;
return|return
name|key
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|tuple_from_key
parameter_list|(
name|IN
name|ftree_tuple_t
name|tuple
parameter_list|,
name|IN
name|ftree_tuple_key_t
name|key
parameter_list|)
block|{
name|memcpy
argument_list|(
name|tuple
argument_list|,
operator|&
name|key
argument_list|,
name|FTREE_TUPLE_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  **  ** ftree_sw_tbl_element_t functions  **  ***************************************************/
end_comment

begin_function
specifier|static
name|ftree_sw_tbl_element_t
modifier|*
name|sw_tbl_element_create
parameter_list|(
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|)
block|{
name|ftree_sw_tbl_element_t
modifier|*
name|p_element
init|=
operator|(
name|ftree_sw_tbl_element_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ftree_sw_tbl_element_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p_element
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|p_element
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ftree_sw_tbl_element_t
argument_list|)
argument_list|)
expr_stmt|;
name|p_element
operator|->
name|p_sw
operator|=
name|p_sw
expr_stmt|;
return|return
name|p_element
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|sw_tbl_element_destroy
parameter_list|(
name|IN
name|ftree_sw_tbl_element_t
modifier|*
name|p_element
parameter_list|)
block|{
name|free
argument_list|(
name|p_element
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  **  ** ftree_port_t functions  **  ***************************************************/
end_comment

begin_function
specifier|static
name|ftree_port_t
modifier|*
name|port_create
parameter_list|(
name|IN
name|uint8_t
name|port_num
parameter_list|,
name|IN
name|uint8_t
name|remote_port_num
parameter_list|)
block|{
name|ftree_port_t
modifier|*
name|p_port
init|=
operator|(
name|ftree_port_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ftree_port_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|p_port
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ftree_port_t
argument_list|)
argument_list|)
expr_stmt|;
name|p_port
operator|->
name|port_num
operator|=
name|port_num
expr_stmt|;
name|p_port
operator|->
name|remote_port_num
operator|=
name|remote_port_num
expr_stmt|;
return|return
name|p_port
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|port_destroy
parameter_list|(
name|IN
name|ftree_port_t
modifier|*
name|p_port
parameter_list|)
block|{
name|free
argument_list|(
name|p_port
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  **  ** ftree_port_group_t functions  **  ***************************************************/
end_comment

begin_function
specifier|static
name|ftree_port_group_t
modifier|*
name|port_group_create
parameter_list|(
name|IN
name|uint16_t
name|lid
parameter_list|,
name|IN
name|uint16_t
name|remote_lid
parameter_list|,
name|IN
name|ib_net64_t
name|port_guid
parameter_list|,
name|IN
name|ib_net64_t
name|node_guid
parameter_list|,
name|IN
name|uint8_t
name|node_type
parameter_list|,
name|IN
name|void
modifier|*
name|p_hca_or_sw
parameter_list|,
name|IN
name|ib_net64_t
name|remote_port_guid
parameter_list|,
name|IN
name|ib_net64_t
name|remote_node_guid
parameter_list|,
name|IN
name|uint8_t
name|remote_node_type
parameter_list|,
name|IN
name|void
modifier|*
name|p_remote_hca_or_sw
parameter_list|,
name|IN
name|boolean_t
name|is_cn
parameter_list|,
name|IN
name|boolean_t
name|is_io
parameter_list|)
block|{
name|ftree_port_group_t
modifier|*
name|p_group
init|=
operator|(
name|ftree_port_group_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ftree_port_group_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|p_group
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|p_group
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ftree_port_group_t
argument_list|)
argument_list|)
expr_stmt|;
name|p_group
operator|->
name|lid
operator|=
name|lid
expr_stmt|;
name|p_group
operator|->
name|remote_lid
operator|=
name|remote_lid
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_group
operator|->
name|port_guid
argument_list|,
operator|&
name|port_guid
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_net64_t
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_group
operator|->
name|node_guid
argument_list|,
operator|&
name|node_guid
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_net64_t
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_group
operator|->
name|remote_port_guid
argument_list|,
operator|&
name|remote_port_guid
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_net64_t
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_group
operator|->
name|remote_node_guid
argument_list|,
operator|&
name|remote_node_guid
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_net64_t
argument_list|)
argument_list|)
expr_stmt|;
name|p_group
operator|->
name|node_type
operator|=
name|node_type
expr_stmt|;
switch|switch
condition|(
name|node_type
condition|)
block|{
case|case
name|IB_NODE_TYPE_CA
case|:
name|p_group
operator|->
name|hca_or_sw
operator|.
name|p_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|p_hca_or_sw
expr_stmt|;
break|break;
case|case
name|IB_NODE_TYPE_SWITCH
case|:
name|p_group
operator|->
name|hca_or_sw
operator|.
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|p_hca_or_sw
expr_stmt|;
break|break;
default|default:
comment|/* we shouldn't get here - port is created only in hca or switch */
name|CL_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|p_group
operator|->
name|remote_node_type
operator|=
name|remote_node_type
expr_stmt|;
switch|switch
condition|(
name|remote_node_type
condition|)
block|{
case|case
name|IB_NODE_TYPE_CA
case|:
name|p_group
operator|->
name|remote_hca_or_sw
operator|.
name|p_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|p_remote_hca_or_sw
expr_stmt|;
break|break;
case|case
name|IB_NODE_TYPE_SWITCH
case|:
name|p_group
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|p_remote_hca_or_sw
expr_stmt|;
break|break;
default|default:
comment|/* we shouldn't get here - port is created only in hca or switch */
name|CL_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|cl_ptr_vector_init
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|,
literal|0
argument_list|,
comment|/* min size */
literal|8
argument_list|)
expr_stmt|;
comment|/* grow size */
name|p_group
operator|->
name|is_cn
operator|=
name|is_cn
expr_stmt|;
name|p_group
operator|->
name|is_io
operator|=
name|is_io
expr_stmt|;
return|return
name|p_group
return|;
block|}
end_function

begin_comment
comment|/* port_group_create() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|port_group_destroy
parameter_list|(
name|IN
name|ftree_port_group_t
modifier|*
name|p_group
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
name|ftree_port_t
modifier|*
name|p_port
decl_stmt|;
if|if
condition|(
operator|!
name|p_group
condition|)
return|return;
comment|/* remove all the elements of p_group->ports vector */
name|size
operator|=
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cl_ptr_vector_at
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|,
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_port
argument_list|)
operator|==
name|CL_SUCCESS
condition|)
name|port_destroy
argument_list|(
name|p_port
argument_list|)
expr_stmt|;
name|cl_ptr_vector_destroy
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_group
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* port_group_destroy() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|port_group_dump
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_port_group_t
modifier|*
name|p_group
parameter_list|,
name|IN
name|ftree_direction_t
name|direction
parameter_list|)
block|{
name|ftree_port_t
modifier|*
name|p_port
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|;
if|if
condition|(
operator|!
name|p_group
condition|)
return|return;
if|if
condition|(
operator|!
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
return|return;
name|size
operator|=
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|)
expr_stmt|;
name|buff
operator|=
name|calloc
argument_list|(
literal|10
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buff
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB33: "
literal|"Failed to allocate buffer\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|cl_ptr_vector_at
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|,
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_port
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|strcat
argument_list|(
name|buff
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buff
operator|+
name|strlen
argument_list|(
name|buff
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
name|p_port
operator|->
name|port_num
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"    Port Group of size %u, port(s): %s, direction: %s\n"
literal|"                  Local<--> Remote GUID (LID):"
literal|"0x%016"
name|PRIx64
literal|" (0x%04x)<--> 0x%016"
name|PRIx64
literal|" (0x%04x)\n"
argument_list|,
name|size
argument_list|,
name|buff
argument_list|,
operator|(
name|direction
operator|==
name|FTREE_DIRECTION_DOWN
operator|)
condition|?
literal|"DOWN"
else|:
operator|(
name|direction
operator|==
name|FTREE_DIRECTION_SAME
operator|)
condition|?
literal|"SIBLING"
else|:
literal|"UP"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_group
operator|->
name|port_guid
argument_list|)
argument_list|,
name|p_group
operator|->
name|lid
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_group
operator|->
name|remote_port_guid
argument_list|)
argument_list|,
name|p_group
operator|->
name|remote_lid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* port_group_dump() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|port_group_add_port
parameter_list|(
name|IN
name|ftree_port_group_t
modifier|*
name|p_group
parameter_list|,
name|IN
name|uint8_t
name|port_num
parameter_list|,
name|IN
name|uint8_t
name|remote_port_num
parameter_list|)
block|{
name|uint16_t
name|i
decl_stmt|;
name|ftree_port_t
modifier|*
name|p_port
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|cl_ptr_vector_at
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|,
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_port
operator|->
name|port_num
operator|==
name|port_num
condition|)
return|return;
block|}
name|p_port
operator|=
name|port_create
argument_list|(
name|port_num
argument_list|,
name|remote_port_num
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_port
argument_list|)
expr_stmt|;
name|cl_ptr_vector_insert
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|,
name|p_port
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  **  ** ftree_sw_t functions  **  ***************************************************/
end_comment

begin_function
specifier|static
name|ftree_sw_t
modifier|*
name|sw_create
parameter_list|(
name|IN
name|osm_switch_t
modifier|*
name|p_osm_sw
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|uint8_t
name|ports_num
decl_stmt|;
comment|/* make sure that the switch has ports */
if|if
condition|(
name|p_osm_sw
operator|->
name|num_ports
operator|==
literal|1
condition|)
return|return
name|NULL
return|;
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ftree_sw_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|p_sw
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ftree_sw_t
argument_list|)
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|p_osm_sw
operator|=
name|p_osm_sw
expr_stmt|;
name|p_sw
operator|->
name|rank
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|tuple_init
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|lid
operator|=
name|cl_ntoh16
argument_list|(
name|osm_node_get_base_lid
argument_list|(
name|p_sw
operator|->
name|p_osm_sw
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ports_num
operator|=
name|osm_node_get_num_physp
argument_list|(
name|p_sw
operator|->
name|p_osm_sw
operator|->
name|p_node
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|down_port_groups
operator|=
operator|(
name|ftree_port_group_t
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|ports_num
operator|*
sizeof|sizeof
argument_list|(
name|ftree_port_group_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|down_port_groups
operator|==
name|NULL
condition|)
goto|goto
name|FREE_P_SW
goto|;
name|memset
argument_list|(
name|p_sw
operator|->
name|down_port_groups
argument_list|,
literal|0
argument_list|,
name|ports_num
operator|*
sizeof|sizeof
argument_list|(
name|ftree_port_group_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|up_port_groups
operator|=
operator|(
name|ftree_port_group_t
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|ports_num
operator|*
sizeof|sizeof
argument_list|(
name|ftree_port_group_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|up_port_groups
operator|==
name|NULL
condition|)
goto|goto
name|FREE_DOWN
goto|;
name|memset
argument_list|(
name|p_sw
operator|->
name|up_port_groups
argument_list|,
literal|0
argument_list|,
name|ports_num
operator|*
sizeof|sizeof
argument_list|(
name|ftree_port_group_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|sibling_port_groups
operator|=
operator|(
name|ftree_port_group_t
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|ports_num
operator|*
sizeof|sizeof
argument_list|(
name|ftree_port_group_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|sibling_port_groups
operator|==
name|NULL
condition|)
goto|goto
name|FREE_UP
goto|;
name|memset
argument_list|(
name|p_sw
operator|->
name|sibling_port_groups
argument_list|,
literal|0
argument_list|,
name|ports_num
operator|*
sizeof|sizeof
argument_list|(
name|ftree_port_group_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* initialize lft buffer */
name|memset
argument_list|(
name|p_osm_sw
operator|->
name|new_lft
argument_list|,
name|OSM_NO_PATH
argument_list|,
name|p_osm_sw
operator|->
name|lft_size
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|hops
operator|=
name|malloc
argument_list|(
operator|(
name|p_osm_sw
operator|->
name|max_lid_ho
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|p_sw
operator|->
name|hops
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|hops
operator|==
name|NULL
condition|)
goto|goto
name|FREE_SIBLING
goto|;
name|memset
argument_list|(
name|p_sw
operator|->
name|hops
argument_list|,
name|OSM_NO_PATH
argument_list|,
name|p_osm_sw
operator|->
name|max_lid_ho
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|p_sw
return|;
name|FREE_SIBLING
label|:
name|free
argument_list|(
name|p_sw
operator|->
name|sibling_port_groups
argument_list|)
expr_stmt|;
name|FREE_UP
label|:
name|free
argument_list|(
name|p_sw
operator|->
name|up_port_groups
argument_list|)
expr_stmt|;
name|FREE_DOWN
label|:
name|free
argument_list|(
name|p_sw
operator|->
name|down_port_groups
argument_list|)
expr_stmt|;
name|FREE_P_SW
label|:
name|free
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* sw_create() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|sw_destroy
parameter_list|(
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|)
block|{
name|uint8_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|p_sw
condition|)
return|return;
name|free
argument_list|(
name|p_sw
operator|->
name|hops
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|down_port_groups_num
condition|;
name|i
operator|++
control|)
name|port_group_destroy
argument_list|(
name|p_sw
operator|->
name|down_port_groups
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|sibling_port_groups_num
condition|;
name|i
operator|++
control|)
name|port_group_destroy
argument_list|(
name|p_sw
operator|->
name|sibling_port_groups
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|up_port_groups_num
condition|;
name|i
operator|++
control|)
name|port_group_destroy
argument_list|(
name|p_sw
operator|->
name|up_port_groups
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_sw
operator|->
name|down_port_groups
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_sw
operator|->
name|sibling_port_groups
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_sw
operator|->
name|up_port_groups
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* sw_destroy() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|uint64_t
name|sw_get_guid_no
parameter_list|(
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p_sw
condition|)
return|return
literal|0
return|;
return|return
name|osm_node_get_node_guid
argument_list|(
name|p_sw
operator|->
name|p_osm_sw
operator|->
name|p_node
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|uint64_t
name|sw_get_guid_ho
parameter_list|(
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|)
block|{
return|return
name|cl_ntoh64
argument_list|(
name|sw_get_guid_no
argument_list|(
name|p_sw
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|sw_dump
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|p_sw
condition|)
return|return;
if|if
condition|(
operator|!
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
return|return;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Switch index: %s, GUID: 0x%016"
name|PRIx64
literal|", Ports: %u DOWN, %u SIBLINGS, %u UP\n"
argument_list|,
name|tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|sw_get_guid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|,
name|p_sw
operator|->
name|down_port_groups_num
argument_list|,
name|p_sw
operator|->
name|sibling_port_groups_num
argument_list|,
name|p_sw
operator|->
name|up_port_groups_num
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|down_port_groups_num
condition|;
name|i
operator|++
control|)
name|port_group_dump
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
operator|->
name|down_port_groups
index|[
name|i
index|]
argument_list|,
name|FTREE_DIRECTION_DOWN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|sibling_port_groups_num
condition|;
name|i
operator|++
control|)
name|port_group_dump
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
operator|->
name|sibling_port_groups
index|[
name|i
index|]
argument_list|,
name|FTREE_DIRECTION_SAME
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|up_port_groups_num
condition|;
name|i
operator|++
control|)
name|port_group_dump
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
operator|->
name|up_port_groups
index|[
name|i
index|]
argument_list|,
name|FTREE_DIRECTION_UP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* sw_dump() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|boolean_t
name|sw_ranked
parameter_list|(
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|)
block|{
return|return
operator|(
name|p_sw
operator|->
name|rank
operator|!=
literal|0xFFFFFFFF
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|ftree_port_group_t
modifier|*
name|sw_get_port_group_by_remote_lid
parameter_list|(
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|uint16_t
name|remote_lid
parameter_list|,
name|IN
name|ftree_direction_t
name|direction
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
name|ftree_port_group_t
modifier|*
modifier|*
name|port_groups
decl_stmt|;
if|if
condition|(
name|direction
operator|==
name|FTREE_DIRECTION_UP
condition|)
block|{
name|port_groups
operator|=
name|p_sw
operator|->
name|up_port_groups
expr_stmt|;
name|size
operator|=
name|p_sw
operator|->
name|up_port_groups_num
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|direction
operator|==
name|FTREE_DIRECTION_SAME
condition|)
block|{
name|port_groups
operator|=
name|p_sw
operator|->
name|sibling_port_groups
expr_stmt|;
name|size
operator|=
name|p_sw
operator|->
name|sibling_port_groups_num
expr_stmt|;
block|}
else|else
block|{
name|port_groups
operator|=
name|p_sw
operator|->
name|down_port_groups
expr_stmt|;
name|size
operator|=
name|p_sw
operator|->
name|down_port_groups_num
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|remote_lid
operator|==
name|port_groups
index|[
name|i
index|]
operator|->
name|remote_lid
condition|)
return|return
name|port_groups
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* sw_get_port_group_by_remote_lid() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|sw_add_port
parameter_list|(
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|uint8_t
name|port_num
parameter_list|,
name|IN
name|uint8_t
name|remote_port_num
parameter_list|,
name|IN
name|uint16_t
name|lid
parameter_list|,
name|IN
name|uint16_t
name|remote_lid
parameter_list|,
name|IN
name|ib_net64_t
name|port_guid
parameter_list|,
name|IN
name|ib_net64_t
name|remote_port_guid
parameter_list|,
name|IN
name|ib_net64_t
name|remote_node_guid
parameter_list|,
name|IN
name|uint8_t
name|remote_node_type
parameter_list|,
name|IN
name|void
modifier|*
name|p_remote_hca_or_sw
parameter_list|,
name|IN
name|ftree_direction_t
name|direction
parameter_list|)
block|{
name|ftree_port_group_t
modifier|*
name|p_group
init|=
name|sw_get_port_group_by_remote_lid
argument_list|(
name|p_sw
argument_list|,
name|remote_lid
argument_list|,
name|direction
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p_group
condition|)
block|{
name|p_group
operator|=
name|port_group_create
argument_list|(
name|lid
argument_list|,
name|remote_lid
argument_list|,
name|port_guid
argument_list|,
name|sw_get_guid_no
argument_list|(
name|p_sw
argument_list|)
argument_list|,
name|IB_NODE_TYPE_SWITCH
argument_list|,
name|p_sw
argument_list|,
name|remote_port_guid
argument_list|,
name|remote_node_guid
argument_list|,
name|remote_node_type
argument_list|,
name|p_remote_hca_or_sw
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_group
argument_list|)
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|FTREE_DIRECTION_UP
condition|)
block|{
name|p_sw
operator|->
name|up_port_groups
index|[
name|p_sw
operator|->
name|up_port_groups_num
operator|++
index|]
operator|=
name|p_group
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|direction
operator|==
name|FTREE_DIRECTION_SAME
condition|)
block|{
name|p_sw
operator|->
name|sibling_port_groups
index|[
name|p_sw
operator|->
name|sibling_port_groups_num
operator|++
index|]
operator|=
name|p_group
expr_stmt|;
block|}
else|else
name|p_sw
operator|->
name|down_port_groups
index|[
name|p_sw
operator|->
name|down_port_groups_num
operator|++
index|]
operator|=
name|p_group
expr_stmt|;
block|}
name|port_group_add_port
argument_list|(
name|p_group
argument_list|,
name|port_num
argument_list|,
name|remote_port_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* sw_add_port() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|cl_status_t
name|sw_set_hops
parameter_list|(
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|uint16_t
name|lid
parameter_list|,
name|IN
name|uint8_t
name|port_num
parameter_list|,
name|IN
name|uint8_t
name|hops
parameter_list|,
name|IN
name|boolean_t
name|is_target_sw
parameter_list|)
block|{
comment|/* set local min hop table(LID) */
name|p_sw
operator|->
name|hops
index|[
name|lid
index|]
operator|=
name|hops
expr_stmt|;
if|if
condition|(
name|is_target_sw
condition|)
return|return
name|osm_switch_set_hops
argument_list|(
name|p_sw
operator|->
name|p_osm_sw
argument_list|,
name|lid
argument_list|,
name|port_num
argument_list|,
name|hops
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|int
name|set_hops_on_remote_sw
parameter_list|(
name|IN
name|ftree_port_group_t
modifier|*
name|p_group
parameter_list|,
name|IN
name|uint16_t
name|target_lid
parameter_list|,
name|IN
name|uint8_t
name|hops
parameter_list|,
name|IN
name|boolean_t
name|is_target_sw
parameter_list|)
block|{
name|ftree_port_t
modifier|*
name|p_port
decl_stmt|;
name|uint8_t
name|i
decl_stmt|,
name|ports_num
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_remote_sw
init|=
name|p_group
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
decl_stmt|;
comment|/* if lid is a switch, we set the min hop table in the osm_switch struct */
name|CL_ASSERT
argument_list|(
name|p_group
operator|->
name|remote_node_type
operator|==
name|IB_NODE_TYPE_SWITCH
argument_list|)
expr_stmt|;
name|p_remote_sw
operator|->
name|hops
index|[
name|target_lid
index|]
operator|=
name|hops
expr_stmt|;
comment|/* If target lid is a switch we set the min hop table values 	 * for each port on the associated osm_sw struct */
if|if
condition|(
operator|!
name|is_target_sw
condition|)
return|return
literal|0
return|;
name|ports_num
operator|=
operator|(
name|uint8_t
operator|)
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ports_num
condition|;
name|i
operator|++
control|)
block|{
name|cl_ptr_vector_at
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|,
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw_set_hops
argument_list|(
name|p_remote_sw
argument_list|,
name|target_lid
argument_list|,
name|p_port
operator|->
name|remote_port_num
argument_list|,
name|hops
argument_list|,
name|is_target_sw
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|uint8_t
name|sw_get_least_hops
parameter_list|(
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|uint16_t
name|target_lid
parameter_list|)
block|{
name|CL_ASSERT
argument_list|(
name|p_sw
operator|->
name|hops
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|p_sw
operator|->
name|hops
index|[
name|target_lid
index|]
return|;
block|}
end_function

begin_comment
comment|/***************************************************  **  ** ftree_hca_t functions  **  ***************************************************/
end_comment

begin_function
specifier|static
name|ftree_hca_t
modifier|*
name|hca_create
parameter_list|(
name|IN
name|osm_node_t
modifier|*
name|p_osm_node
parameter_list|)
block|{
name|ftree_hca_t
modifier|*
name|p_hca
init|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ftree_hca_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|p_hca
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|p_hca
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ftree_hca_t
argument_list|)
argument_list|)
expr_stmt|;
name|p_hca
operator|->
name|p_osm_node
operator|=
name|p_osm_node
expr_stmt|;
name|p_hca
operator|->
name|up_port_groups
operator|=
operator|(
name|ftree_port_group_t
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|osm_node_get_num_physp
argument_list|(
name|p_hca
operator|->
name|p_osm_node
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|ftree_port_group_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_hca
operator|->
name|up_port_groups
condition|)
block|{
name|free
argument_list|(
name|p_hca
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_hca
operator|->
name|up_port_groups
argument_list|,
literal|0
argument_list|,
name|osm_node_get_num_physp
argument_list|(
name|p_hca
operator|->
name|p_osm_node
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|ftree_port_group_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|p_hca
operator|->
name|disconnected_ports
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|calloc
argument_list|(
name|osm_node_get_num_physp
argument_list|(
name|p_hca
operator|->
name|p_osm_node
argument_list|)
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_hca
operator|->
name|disconnected_ports
condition|)
block|{
name|free
argument_list|(
name|p_hca
operator|->
name|up_port_groups
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_hca
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p_hca
operator|->
name|up_port_groups_num
operator|=
literal|0
expr_stmt|;
return|return
name|p_hca
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|hca_destroy
parameter_list|(
name|IN
name|ftree_hca_t
modifier|*
name|p_hca
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|p_hca
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_hca
operator|->
name|up_port_groups_num
condition|;
name|i
operator|++
control|)
name|port_group_destroy
argument_list|(
name|p_hca
operator|->
name|up_port_groups
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_hca
operator|->
name|up_port_groups
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_hca
operator|->
name|disconnected_ports
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_hca
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|uint64_t
name|hca_get_guid_no
parameter_list|(
name|IN
name|ftree_hca_t
modifier|*
name|p_hca
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p_hca
condition|)
return|return
literal|0
return|;
return|return
name|osm_node_get_node_guid
argument_list|(
name|p_hca
operator|->
name|p_osm_node
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|uint64_t
name|hca_get_guid_ho
parameter_list|(
name|IN
name|ftree_hca_t
modifier|*
name|p_hca
parameter_list|)
block|{
return|return
name|cl_ntoh64
argument_list|(
name|hca_get_guid_no
argument_list|(
name|p_hca
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|hca_dump
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_hca_t
modifier|*
name|p_hca
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|p_hca
condition|)
return|return;
if|if
condition|(
operator|!
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
return|return;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"CA GUID: 0x%016"
name|PRIx64
literal|", Ports: %u UP\n"
argument_list|,
name|hca_get_guid_ho
argument_list|(
name|p_hca
argument_list|)
argument_list|,
name|p_hca
operator|->
name|up_port_groups_num
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_hca
operator|->
name|up_port_groups_num
condition|;
name|i
operator|++
control|)
name|port_group_dump
argument_list|(
name|p_ftree
argument_list|,
name|p_hca
operator|->
name|up_port_groups
index|[
name|i
index|]
argument_list|,
name|FTREE_DIRECTION_UP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ftree_port_group_t
modifier|*
name|hca_get_port_group_by_lid
parameter_list|(
name|IN
name|ftree_hca_t
modifier|*
name|p_hca
parameter_list|,
name|IN
name|uint16_t
name|lid
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_hca
operator|->
name|up_port_groups_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|lid
operator|==
name|p_hca
operator|->
name|up_port_groups
index|[
name|i
index|]
operator|->
name|lid
condition|)
return|return
name|p_hca
operator|->
name|up_port_groups
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|hca_add_port
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_hca_t
modifier|*
name|p_hca
parameter_list|,
name|IN
name|uint8_t
name|port_num
parameter_list|,
name|IN
name|uint8_t
name|remote_port_num
parameter_list|,
name|IN
name|uint16_t
name|lid
parameter_list|,
name|IN
name|uint16_t
name|remote_lid
parameter_list|,
name|IN
name|ib_net64_t
name|port_guid
parameter_list|,
name|IN
name|ib_net64_t
name|remote_port_guid
parameter_list|,
name|IN
name|ib_net64_t
name|remote_node_guid
parameter_list|,
name|IN
name|uint8_t
name|remote_node_type
parameter_list|,
name|IN
name|void
modifier|*
name|p_remote_hca_or_sw
parameter_list|,
name|IN
name|boolean_t
name|is_cn
parameter_list|,
name|IN
name|boolean_t
name|is_io
parameter_list|)
block|{
name|ftree_port_group_t
modifier|*
name|p_group
decl_stmt|;
comment|/* this function is supposed to be called only for adding ports 	   in hca's that lead to switches */
name|CL_ASSERT
argument_list|(
name|remote_node_type
operator|==
name|IB_NODE_TYPE_SWITCH
argument_list|)
expr_stmt|;
name|p_group
operator|=
name|hca_get_port_group_by_lid
argument_list|(
name|p_hca
argument_list|,
name|lid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_group
condition|)
block|{
name|p_group
operator|=
name|port_group_create
argument_list|(
name|lid
argument_list|,
name|remote_lid
argument_list|,
name|port_guid
argument_list|,
name|hca_get_guid_no
argument_list|(
name|p_hca
argument_list|)
argument_list|,
name|IB_NODE_TYPE_CA
argument_list|,
name|p_hca
argument_list|,
name|remote_port_guid
argument_list|,
name|remote_node_guid
argument_list|,
name|remote_node_type
argument_list|,
name|p_remote_hca_or_sw
argument_list|,
name|is_cn
argument_list|,
name|is_io
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_group
argument_list|)
expr_stmt|;
name|p_hca
operator|->
name|up_port_groups
index|[
name|p_hca
operator|->
name|up_port_groups_num
operator|++
index|]
operator|=
name|p_group
expr_stmt|;
name|port_group_add_port
argument_list|(
name|p_group
argument_list|,
name|port_num
argument_list|,
name|remote_port_num
argument_list|)
expr_stmt|;
block|}
else|else
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB32: Duplicated LID for CA GUID: 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* hca_add_port() */
end_comment

begin_comment
comment|/***************************************************  **  ** ftree_fabric_t functions  **  ***************************************************/
end_comment

begin_function
specifier|static
name|ftree_fabric_t
modifier|*
name|fabric_create
parameter_list|()
block|{
name|ftree_fabric_t
modifier|*
name|p_ftree
init|=
operator|(
name|ftree_fabric_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ftree_fabric_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|p_ftree
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|p_ftree
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ftree_fabric_t
argument_list|)
argument_list|)
expr_stmt|;
name|cl_qmap_init
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
expr_stmt|;
name|cl_qmap_init
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
expr_stmt|;
name|cl_qmap_init
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_by_tuple_tbl
argument_list|)
expr_stmt|;
name|cl_qmap_init
argument_list|(
operator|&
name|p_ftree
operator|->
name|cn_guid_tbl
argument_list|)
expr_stmt|;
name|cl_qmap_init
argument_list|(
operator|&
name|p_ftree
operator|->
name|io_guid_tbl
argument_list|)
expr_stmt|;
return|return
name|p_ftree
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|fabric_clear
parameter_list|(
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|ftree_hca_t
modifier|*
name|p_hca
decl_stmt|;
name|ftree_hca_t
modifier|*
name|p_next_hca
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_next_sw
decl_stmt|;
name|ftree_sw_tbl_element_t
modifier|*
name|p_element
decl_stmt|;
name|ftree_sw_tbl_element_t
modifier|*
name|p_next_element
decl_stmt|;
name|name_map_item_t
modifier|*
name|p_guid_element
decl_stmt|,
modifier|*
name|p_next_guid_element
decl_stmt|;
if|if
condition|(
operator|!
name|p_ftree
condition|)
return|return;
comment|/* remove all the elements of hca_tbl */
name|p_next_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_hca
operator|!=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
condition|)
block|{
name|p_hca
operator|=
name|p_next_hca
expr_stmt|;
name|p_next_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_hca
operator|->
name|map_item
argument_list|)
expr_stmt|;
name|hca_destroy
argument_list|(
name|p_hca
argument_list|)
expr_stmt|;
block|}
name|cl_qmap_remove_all
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
expr_stmt|;
comment|/* remove all the elements of sw_tbl */
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_sw
operator|!=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
condition|)
block|{
name|p_sw
operator|=
name|p_next_sw
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
name|sw_destroy
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
block|}
name|cl_qmap_remove_all
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
expr_stmt|;
comment|/* remove all the elements of sw_by_tuple_tbl */
name|p_next_element
operator|=
operator|(
name|ftree_sw_tbl_element_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_by_tuple_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_element
operator|!=
operator|(
name|ftree_sw_tbl_element_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_by_tuple_tbl
argument_list|)
condition|)
block|{
name|p_element
operator|=
name|p_next_element
expr_stmt|;
name|p_next_element
operator|=
operator|(
name|ftree_sw_tbl_element_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_element
operator|->
name|map_item
argument_list|)
expr_stmt|;
name|sw_tbl_element_destroy
argument_list|(
name|p_element
argument_list|)
expr_stmt|;
block|}
name|cl_qmap_remove_all
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_by_tuple_tbl
argument_list|)
expr_stmt|;
comment|/* remove all the elements of cn_guid_tbl */
name|p_next_guid_element
operator|=
operator|(
name|name_map_item_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|cn_guid_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_guid_element
operator|!=
operator|(
name|name_map_item_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|cn_guid_tbl
argument_list|)
condition|)
block|{
name|p_guid_element
operator|=
name|p_next_guid_element
expr_stmt|;
name|p_next_guid_element
operator|=
operator|(
name|name_map_item_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_guid_element
operator|->
name|item
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_guid_element
argument_list|)
expr_stmt|;
block|}
name|cl_qmap_remove_all
argument_list|(
operator|&
name|p_ftree
operator|->
name|cn_guid_tbl
argument_list|)
expr_stmt|;
comment|/* remove all the elements of io_guid_tbl */
name|p_next_guid_element
operator|=
operator|(
name|name_map_item_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|io_guid_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_guid_element
operator|!=
operator|(
name|name_map_item_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|io_guid_tbl
argument_list|)
condition|)
block|{
name|p_guid_element
operator|=
name|p_next_guid_element
expr_stmt|;
name|p_next_guid_element
operator|=
operator|(
name|name_map_item_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_guid_element
operator|->
name|item
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_guid_element
argument_list|)
expr_stmt|;
block|}
name|cl_qmap_remove_all
argument_list|(
operator|&
name|p_ftree
operator|->
name|io_guid_tbl
argument_list|)
expr_stmt|;
comment|/* free the leaf switches array */
if|if
condition|(
operator|(
name|p_ftree
operator|->
name|leaf_switches_num
operator|>
literal|0
operator|)
operator|&&
operator|(
name|p_ftree
operator|->
name|leaf_switches
operator|)
condition|)
name|free
argument_list|(
name|p_ftree
operator|->
name|leaf_switches
argument_list|)
expr_stmt|;
name|p_ftree
operator|->
name|leaf_switches_num
operator|=
literal|0
expr_stmt|;
name|p_ftree
operator|->
name|cn_num
operator|=
literal|0
expr_stmt|;
name|p_ftree
operator|->
name|ca_ports
operator|=
literal|0
expr_stmt|;
name|p_ftree
operator|->
name|leaf_switch_rank
operator|=
literal|0
expr_stmt|;
name|p_ftree
operator|->
name|max_switch_rank
operator|=
literal|0
expr_stmt|;
name|p_ftree
operator|->
name|max_cn_per_leaf
operator|=
literal|0
expr_stmt|;
name|p_ftree
operator|->
name|lft_max_lid
operator|=
literal|0
expr_stmt|;
name|p_ftree
operator|->
name|leaf_switches
operator|=
name|NULL
expr_stmt|;
name|p_ftree
operator|->
name|fabric_built
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* fabric_destroy() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|fabric_destroy
parameter_list|(
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p_ftree
condition|)
return|return;
name|fabric_clear
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|uint8_t
name|fabric_get_rank
parameter_list|(
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
return|return
name|p_ftree
operator|->
name|leaf_switch_rank
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|fabric_add_hca
parameter_list|(
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|osm_node_t
modifier|*
name|p_osm_node
parameter_list|)
block|{
name|ftree_hca_t
modifier|*
name|p_hca
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|osm_node_get_type
argument_list|(
name|p_osm_node
argument_list|)
operator|==
name|IB_NODE_TYPE_CA
argument_list|)
expr_stmt|;
name|p_hca
operator|=
name|hca_create
argument_list|(
name|p_osm_node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_hca
condition|)
return|return;
name|cl_qmap_insert
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|,
name|p_osm_node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|,
operator|&
name|p_hca
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|fabric_add_sw
parameter_list|(
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|osm_switch_t
modifier|*
name|p_osm_sw
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|osm_node_get_type
argument_list|(
name|p_osm_sw
operator|->
name|p_node
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
argument_list|)
expr_stmt|;
name|p_sw
operator|=
name|sw_create
argument_list|(
name|p_osm_sw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_sw
condition|)
return|return;
name|cl_qmap_insert
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|,
name|p_osm_sw
operator|->
name|p_node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|,
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
comment|/* track the max lid (in host order) that exists in the fabric */
if|if
condition|(
name|p_sw
operator|->
name|lid
operator|>
name|p_ftree
operator|->
name|lft_max_lid
condition|)
name|p_ftree
operator|->
name|lft_max_lid
operator|=
name|p_sw
operator|->
name|lid
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|fabric_add_sw_by_tuple
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|)
block|{
name|CL_ASSERT
argument_list|(
name|tuple_assigned
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|)
expr_stmt|;
name|cl_qmap_insert
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_by_tuple_tbl
argument_list|,
name|tuple_to_key
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
operator|&
name|sw_tbl_element_create
argument_list|(
name|p_sw
argument_list|)
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|ftree_sw_t
modifier|*
name|fabric_get_sw_by_tuple
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_tuple_t
name|tuple
parameter_list|)
block|{
name|ftree_sw_tbl_element_t
modifier|*
name|p_element
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|tuple_assigned
argument_list|(
name|tuple
argument_list|)
argument_list|)
expr_stmt|;
name|tuple_to_key
argument_list|(
name|tuple
argument_list|)
expr_stmt|;
name|p_element
operator|=
operator|(
name|ftree_sw_tbl_element_t
operator|*
operator|)
name|cl_qmap_get
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_by_tuple_tbl
argument_list|,
name|tuple_to_key
argument_list|(
name|tuple
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_element
operator|==
operator|(
name|ftree_sw_tbl_element_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_by_tuple_tbl
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|p_element
operator|->
name|p_sw
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|ftree_sw_t
modifier|*
name|fabric_get_sw_by_guid
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|uint64_t
name|guid
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_get
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|,
name|guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|==
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|p_sw
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|ftree_hca_t
modifier|*
name|fabric_get_hca_by_guid
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|uint64_t
name|guid
parameter_list|)
block|{
name|ftree_hca_t
modifier|*
name|p_hca
decl_stmt|;
name|p_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_get
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|,
name|guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_hca
operator|==
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|p_hca
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|fabric_dump
parameter_list|(
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|ftree_hca_t
modifier|*
name|p_hca
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
if|if
condition|(
operator|!
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
return|return;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"\n"
literal|"                       |-------------------------------|\n"
literal|"                       |-  Full fabric topology dump  -|\n"
literal|"                       |-------------------------------|\n\n"
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"-- CAs:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|p_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
init|;
name|p_hca
operator|!=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
condition|;
name|p_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_hca
operator|->
name|map_item
argument_list|)
control|)
block|{
name|hca_dump
argument_list|(
name|p_ftree
argument_list|,
name|p_hca
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|p_ftree
operator|->
name|max_switch_rank
condition|;
name|i
operator|++
control|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"-- Rank %u switches\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
init|;
name|p_sw
operator|!=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
condition|;
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
control|)
block|{
if|if
condition|(
name|p_sw
operator|->
name|rank
operator|==
name|i
condition|)
name|sw_dump
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
argument_list|)
expr_stmt|;
block|}
block|}
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"\n"
literal|"                       |---------------------------------------|\n"
literal|"                       |- Full fabric topology dump completed -|\n"
literal|"                       |---------------------------------------|\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* fabric_dump() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|fabric_dump_general_info
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"General fabric topology info\n"
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"============================\n"
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"  - FatTree rank (roots to leaf switches): %u\n"
argument_list|,
name|p_ftree
operator|->
name|leaf_switch_rank
operator|+
literal|1
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"  - FatTree max switch rank: %u\n"
argument_list|,
name|p_ftree
operator|->
name|max_switch_rank
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"  - Fabric has %u CAs, %u CA ports (%u of them CNs), %u switches\n"
argument_list|,
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
argument_list|,
name|p_ftree
operator|->
name|ca_ports
argument_list|,
name|p_ftree
operator|->
name|cn_num
argument_list|,
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_ftree
operator|->
name|ca_ports
operator|>=
name|p_ftree
operator|->
name|cn_num
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|p_ftree
operator|->
name|max_switch_rank
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
init|;
name|p_sw
operator|!=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
condition|;
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
control|)
block|{
if|if
condition|(
name|p_sw
operator|->
name|rank
operator|==
name|i
condition|)
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"  - Fabric has %u switches at rank %u (roots)\n"
argument_list|,
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|p_ftree
operator|->
name|leaf_switch_rank
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"  - Fabric has %u switches at rank %u (%u of them leafs)\n"
argument_list|,
name|j
argument_list|,
name|i
argument_list|,
name|p_ftree
operator|->
name|leaf_switches_num
argument_list|)
expr_stmt|;
else|else
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"  - Fabric has %u switches at rank %u\n"
argument_list|,
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"  - Root switches:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
init|;
name|p_sw
operator|!=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
condition|;
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
control|)
block|{
if|if
condition|(
name|p_sw
operator|->
name|rank
operator|==
literal|0
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"      GUID: 0x%016"
name|PRIx64
literal|", LID: %u, Index %s\n"
argument_list|,
name|sw_get_guid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|,
name|p_sw
operator|->
name|lid
argument_list|,
name|tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"  - Leaf switches (sorted by index):\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_ftree
operator|->
name|leaf_switches_num
condition|;
name|i
operator|++
control|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"      GUID: 0x%016"
name|PRIx64
literal|", LID: %u, Index %s\n"
argument_list|,
name|sw_get_guid_ho
argument_list|(
name|p_ftree
operator|->
name|leaf_switches
index|[
name|i
index|]
argument_list|)
argument_list|,
name|p_ftree
operator|->
name|leaf_switches
index|[
name|i
index|]
operator|->
name|lid
argument_list|,
name|tuple_to_str
argument_list|(
name|p_ftree
operator|->
name|leaf_switches
index|[
name|i
index|]
operator|->
name|tuple
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* fabric_dump_general_info() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|fabric_dump_hca_ordering
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|ftree_hca_t
modifier|*
name|p_hca
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_port_group_t
modifier|*
name|p_group_on_sw
decl_stmt|;
name|ftree_port_group_t
modifier|*
name|p_group_on_hca
decl_stmt|;
name|int
name|rename_status
init|=
literal|0
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|j
decl_stmt|;
name|unsigned
name|printed_hcas_on_leaf
decl_stmt|;
name|char
name|path
index|[
literal|1024
index|]
decl_stmt|,
name|path_tmp
index|[
literal|1032
index|]
decl_stmt|;
name|FILE
modifier|*
name|p_hca_ordering_file
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
init|=
literal|"opensm-ftree-ca-order.dump"
decl_stmt|;
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|dump_files_dir
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|path_tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|path_tmp
argument_list|)
argument_list|,
literal|"%s.tmp"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|p_hca_ordering_file
operator|=
name|fopen
argument_list|(
name|path_tmp
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_hca_ordering_file
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB01: "
literal|"cannot open file \'%s\': %s\n"
argument_list|,
name|path_tmp
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* for each leaf switch (in indexing order) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_ftree
operator|->
name|leaf_switches_num
condition|;
name|i
operator|++
control|)
block|{
name|p_sw
operator|=
name|p_ftree
operator|->
name|leaf_switches
index|[
name|i
index|]
expr_stmt|;
name|printed_hcas_on_leaf
operator|=
literal|0
expr_stmt|;
comment|/* for each real CA (CNs and not) connected to this switch */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p_sw
operator|->
name|down_port_groups_num
condition|;
name|j
operator|++
control|)
block|{
name|p_group_on_sw
operator|=
name|p_sw
operator|->
name|down_port_groups
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|p_group_on_sw
operator|->
name|remote_node_type
operator|!=
name|IB_NODE_TYPE_CA
condition|)
continue|continue;
name|p_hca
operator|=
name|p_group_on_sw
operator|->
name|remote_hca_or_sw
operator|.
name|p_hca
expr_stmt|;
name|p_group_on_hca
operator|=
name|hca_get_port_group_by_lid
argument_list|(
name|p_hca
argument_list|,
name|p_group_on_sw
operator|->
name|remote_lid
argument_list|)
expr_stmt|;
comment|/* treat non-compute nodes as dummies */
if|if
condition|(
operator|!
name|p_group_on_hca
operator|->
name|is_cn
condition|)
continue|continue;
name|fprintf
argument_list|(
name|p_hca_ordering_file
argument_list|,
literal|"0x%04x\t%s\n"
argument_list|,
name|p_group_on_hca
operator|->
name|lid
argument_list|,
name|p_hca
operator|->
name|p_osm_node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
name|printed_hcas_on_leaf
operator|++
expr_stmt|;
block|}
comment|/* now print missing HCAs */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|p_ftree
operator|->
name|max_cn_per_leaf
operator|-
name|printed_hcas_on_leaf
operator|)
condition|;
name|j
operator|++
control|)
name|fprintf
argument_list|(
name|p_hca_ordering_file
argument_list|,
literal|"0xFFFF\tDUMMY\n"
argument_list|)
expr_stmt|;
block|}
comment|/* done going through all the leaf switches */
name|fclose
argument_list|(
name|p_hca_ordering_file
argument_list|)
expr_stmt|;
name|rename_status
operator|=
name|rename
argument_list|(
name|path_tmp
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename_status
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB03: "
literal|"cannot rename file \'%s\': %s\n"
argument_list|,
name|path_tmp
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* fabric_dump_hca_ordering() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|fabric_assign_tuple
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|ftree_tuple_t
name|new_tuple
parameter_list|)
block|{
name|memcpy
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|,
name|new_tuple
argument_list|,
name|FTREE_TUPLE_LEN
argument_list|)
expr_stmt|;
name|fabric_add_sw_by_tuple
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|fabric_assign_first_tuple
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|unsigned
name|int
name|subtree
parameter_list|)
block|{
name|uint8_t
name|i
decl_stmt|;
name|ftree_tuple_t
name|new_tuple
decl_stmt|;
if|if
condition|(
name|p_ftree
operator|->
name|leaf_switch_rank
operator|>=
name|FTREE_TUPLE_LEN
condition|)
return|return;
name|tuple_init
argument_list|(
name|new_tuple
argument_list|)
expr_stmt|;
name|new_tuple
index|[
literal|0
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|p_sw
operator|->
name|rank
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|p_ftree
operator|->
name|leaf_switch_rank
condition|;
name|i
operator|++
control|)
name|new_tuple
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|rank
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p_ftree
operator|->
name|leaf_switch_rank
operator|>
literal|1
condition|)
name|new_tuple
index|[
name|p_ftree
operator|->
name|leaf_switch_rank
index|]
operator|=
name|subtree
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0xFF
condition|;
name|i
operator|++
control|)
block|{
name|new_tuple
index|[
literal|1
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|fabric_get_sw_by_tuple
argument_list|(
name|p_ftree
argument_list|,
name|new_tuple
argument_list|)
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0xFF
condition|)
block|{
comment|/* new tuple not found - there are more than 255 ports in one direction */
return|return;
block|}
block|}
name|fabric_assign_tuple
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
argument_list|,
name|new_tuple
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|fabric_get_new_tuple
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|OUT
name|ftree_tuple_t
name|new_tuple
parameter_list|,
name|IN
name|ftree_tuple_t
name|from_tuple
parameter_list|,
name|IN
name|ftree_direction_t
name|direction
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_tuple_t
name|temp_tuple
decl_stmt|;
name|uint8_t
name|var_index
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|tuple_init
argument_list|(
name|new_tuple
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|temp_tuple
argument_list|,
name|from_tuple
argument_list|,
name|FTREE_TUPLE_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|FTREE_DIRECTION_DOWN
condition|)
block|{
name|temp_tuple
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|var_index
operator|=
name|from_tuple
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|temp_tuple
index|[
literal|0
index|]
operator|--
expr_stmt|;
name|var_index
operator|=
name|from_tuple
index|[
literal|0
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0xFF
condition|;
name|i
operator|++
control|)
block|{
name|temp_tuple
index|[
name|var_index
index|]
operator|=
name|i
expr_stmt|;
name|p_sw
operator|=
name|fabric_get_sw_by_tuple
argument_list|(
name|p_ftree
argument_list|,
name|temp_tuple
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|==
name|NULL
condition|)
comment|/* found free tuple */
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0xFF
condition|)
block|{
comment|/* new tuple not found - there are more than 255 ports in one direction */
return|return;
block|}
name|memcpy
argument_list|(
name|new_tuple
argument_list|,
name|temp_tuple
argument_list|,
name|FTREE_TUPLE_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* fabric_get_new_tuple() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|boolean_t
name|fabric_roots_provided
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
return|return
operator|(
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|root_guid_file
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|boolean_t
name|fabric_cns_provided
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
return|return
operator|(
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|cn_guid_file
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|boolean_t
name|fabric_ios_provided
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
return|return
operator|(
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|io_guid_file
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|int
name|fabric_mark_leaf_switches
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_hca_t
modifier|*
name|p_hca
decl_stmt|;
name|ftree_hca_t
modifier|*
name|p_next_hca
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Marking leaf switches in fabric\n"
argument_list|)
expr_stmt|;
comment|/* Scan all the CAs, if they have CNs - find CN port and mark switch 	   that is connected to this port as leaf switch. 	   Also, ensure that this marked leaf has rank of p_ftree->leaf_switch_rank. */
name|p_next_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_hca
operator|!=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
condition|)
block|{
name|p_hca
operator|=
name|p_next_hca
expr_stmt|;
name|p_next_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_hca
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_hca
operator|->
name|cn_num
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_hca
operator|->
name|up_port_groups_num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|p_hca
operator|->
name|up_port_groups
index|[
name|i
index|]
operator|->
name|is_cn
condition|)
continue|continue;
comment|/* In CAs, port group alway has one port, and since this 			   port group is CN, we know that this port is compute node */
name|CL_ASSERT
argument_list|(
name|p_hca
operator|->
name|up_port_groups
index|[
name|i
index|]
operator|->
name|remote_node_type
operator|==
name|IB_NODE_TYPE_SWITCH
argument_list|)
expr_stmt|;
name|p_sw
operator|=
name|p_hca
operator|->
name|up_port_groups
index|[
name|i
index|]
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
expr_stmt|;
comment|/* check if this switch was already processed */
if|if
condition|(
name|p_sw
operator|->
name|is_leaf
condition|)
continue|continue;
name|p_sw
operator|->
name|is_leaf
operator|=
name|TRUE
expr_stmt|;
comment|/* ensure that this leaf switch is at the correct tree level */
if|if
condition|(
name|p_sw
operator|->
name|rank
operator|!=
name|p_ftree
operator|->
name|leaf_switch_rank
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB26: CN port 0x%"
name|PRIx64
literal|" is connected to switch 0x%"
name|PRIx64
literal|" with rank %u, "
literal|"while FatTree leaf rank is %u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_hca
operator|->
name|up_port_groups
index|[
name|i
index|]
operator|->
name|port_guid
argument_list|)
argument_list|,
name|sw_get_guid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|,
name|p_sw
operator|->
name|rank
argument_list|,
name|p_ftree
operator|->
name|leaf_switch_rank
argument_list|)
expr_stmt|;
name|res
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* fabric_mark_leaf_switches() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|bfs_fabric_indexing
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_sw_t
modifier|*
name|p_first_sw
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_remote_sw
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_sw
init|=
name|NULL
decl_stmt|;
name|ftree_tuple_t
name|new_tuple
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|cl_list_t
name|bfs_list
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|cl_list_init
argument_list|(
operator|&
name|bfs_list
argument_list|,
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Now run BFS and assign indexes to all switches 	 * Pseudo code of the algorithm is as follows: 	 * 	 *  * Add first switch to BFS queue 	 *  * While (BFS queue not empty) 	 *      - Pop the switch from the head of the queue 	 *      - Scan all the downward and upward ports 	 *      - For each port 	 *          + Get the remote switch 	 *          + Assign index to the remote switch 	 *          + Add remote switch to the BFS queue 	 */
name|cl_list_insert_tail
argument_list|(
operator|&
name|bfs_list
argument_list|,
name|p_first_sw
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|cl_is_list_empty
argument_list|(
operator|&
name|bfs_list
argument_list|)
condition|)
block|{
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_list_remove_head
argument_list|(
operator|&
name|bfs_list
argument_list|)
expr_stmt|;
comment|/* Discover all the nodes from ports that are pointing down */
if|if
condition|(
name|p_sw
operator|->
name|rank
operator|>=
name|p_ftree
operator|->
name|leaf_switch_rank
condition|)
block|{
comment|/* whether downward ports are pointing to CAs or switches, 			   we don't assign indexes to switches that are located 			   lower than leaf switches */
block|}
else|else
block|{
comment|/* This is not the leaf switch */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|down_port_groups_num
condition|;
name|i
operator|++
control|)
block|{
comment|/* Work with port groups that are pointing to switches only. 				   No need to assign indexing to HCAs */
if|if
condition|(
name|p_sw
operator|->
name|down_port_groups
index|[
name|i
index|]
operator|->
name|remote_node_type
operator|!=
name|IB_NODE_TYPE_SWITCH
condition|)
continue|continue;
name|p_remote_sw
operator|=
name|p_sw
operator|->
name|down_port_groups
index|[
name|i
index|]
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
expr_stmt|;
if|if
condition|(
name|tuple_assigned
argument_list|(
name|p_remote_sw
operator|->
name|tuple
argument_list|)
condition|)
block|{
comment|/* this switch has been already indexed */
continue|continue;
block|}
comment|/* allocate new tuple */
name|fabric_get_new_tuple
argument_list|(
name|p_ftree
argument_list|,
name|new_tuple
argument_list|,
name|p_sw
operator|->
name|tuple
argument_list|,
name|FTREE_DIRECTION_DOWN
argument_list|)
expr_stmt|;
comment|/* Assign the new tuple to the remote switch. 				   This fuction also adds the switch into the switch_by_tuple table. */
name|fabric_assign_tuple
argument_list|(
name|p_ftree
argument_list|,
name|p_remote_sw
argument_list|,
name|new_tuple
argument_list|)
expr_stmt|;
comment|/* add the newly discovered switch to the BFS queue */
name|cl_list_insert_tail
argument_list|(
operator|&
name|bfs_list
argument_list|,
name|p_remote_sw
argument_list|)
expr_stmt|;
block|}
comment|/* Done assigning indexes to all the remote switches 			   that are pointed by the downgoing ports. 			   Now sort port groups according to remote index. */
name|qsort
argument_list|(
name|p_sw
operator|->
name|down_port_groups
argument_list|,
comment|/* array */
name|p_sw
operator|->
name|down_port_groups_num
argument_list|,
comment|/* number of elements */
sizeof|sizeof
argument_list|(
name|ftree_port_group_t
operator|*
argument_list|)
argument_list|,
comment|/* size of each element */
name|compare_port_groups_by_remote_switch_index
argument_list|)
expr_stmt|;
comment|/* comparator */
block|}
comment|/* Done indexing switches from ports that go down. 		   Now do the same with ports that are pointing up. 		   if we started from root (rank == 0), the leaf is bsf termination point */
if|if
condition|(
name|p_sw
operator|->
name|rank
operator|!=
literal|0
operator|&&
operator|(
name|p_first_sw
operator|->
name|rank
operator|!=
literal|0
operator|||
operator|!
name|p_sw
operator|->
name|is_leaf
operator|)
condition|)
block|{
comment|/* This is not the root switch, which means that all the ports 			   that are pointing up are taking us to another switches. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|up_port_groups_num
condition|;
name|i
operator|++
control|)
block|{
name|p_remote_sw
operator|=
name|p_sw
operator|->
name|up_port_groups
index|[
name|i
index|]
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
expr_stmt|;
if|if
condition|(
name|tuple_assigned
argument_list|(
name|p_remote_sw
operator|->
name|tuple
argument_list|)
condition|)
continue|continue;
comment|/* allocate new tuple */
name|fabric_get_new_tuple
argument_list|(
name|p_ftree
argument_list|,
name|new_tuple
argument_list|,
name|p_sw
operator|->
name|tuple
argument_list|,
name|FTREE_DIRECTION_UP
argument_list|)
expr_stmt|;
comment|/* Assign the new tuple to the remote switch. 				   This fuction also adds the switch to the 				   switch_by_tuple table. */
name|fabric_assign_tuple
argument_list|(
name|p_ftree
argument_list|,
name|p_remote_sw
argument_list|,
name|new_tuple
argument_list|)
expr_stmt|;
comment|/* add the newly discovered switch to the BFS queue */
name|cl_list_insert_tail
argument_list|(
operator|&
name|bfs_list
argument_list|,
name|p_remote_sw
argument_list|)
expr_stmt|;
block|}
comment|/* Done assigning indexes to all the remote switches 			   that are pointed by the upgoing ports. 			   Now sort port groups according to remote index. */
name|qsort
argument_list|(
name|p_sw
operator|->
name|up_port_groups
argument_list|,
comment|/* array */
name|p_sw
operator|->
name|up_port_groups_num
argument_list|,
comment|/* number of elements */
sizeof|sizeof
argument_list|(
name|ftree_port_group_t
operator|*
argument_list|)
argument_list|,
comment|/* size of each element */
name|compare_port_groups_by_remote_switch_index
argument_list|)
expr_stmt|;
comment|/* comparator */
block|}
comment|/* Done assigning indexes to all the switches that are directly connected 		   to the current switch - go to the next switch in the BFS queue */
block|}
name|cl_list_destroy
argument_list|(
operator|&
name|bfs_list
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fabric_make_indexing
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|subtree
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Starting FatTree indexing\n"
argument_list|)
expr_stmt|;
comment|/* using the first switch as a starting point for indexing algorithm. */
for|for
control|(
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
init|;
name|p_sw
operator|!=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
condition|;
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
control|)
block|{
if|if
condition|(
name|ftree_get_subnet
argument_list|(
name|p_ftree
argument_list|)
operator|->
name|opt
operator|.
name|quasi_ftree_indexing
condition|)
block|{
comment|/* find first root switch */
if|if
condition|(
name|p_sw
operator|->
name|rank
operator|!=
literal|0
condition|)
continue|continue;
block|}
else|else
block|{
comment|/* find first leaf switch */
if|if
condition|(
operator|!
name|p_sw
operator|->
name|is_leaf
condition|)
continue|continue;
block|}
comment|/* Assign the first tuple to the switch that is used as BFS starting point 		   in the subtree. 		   The tuple will be as follows: [rank].0...0.subtree 		   This fuction also adds the switch it into the switch_by_tuple table. */
if|if
condition|(
operator|!
name|tuple_assigned
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
condition|)
block|{
name|fabric_assign_first_tuple
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
argument_list|,
name|subtree
operator|++
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Indexing starting point:\n"
literal|"                                            - Switch rank  : %u\n"
literal|"                                            - Switch index : %s\n"
literal|"                                            - Node LID     : %u\n"
literal|"                                            - Node GUID    : 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|p_sw
operator|->
name|rank
argument_list|,
name|tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|p_sw
operator|->
name|lid
argument_list|,
name|sw_get_guid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bfs_fabric_indexing
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftree_get_subnet
argument_list|(
name|p_ftree
argument_list|)
operator|->
name|opt
operator|.
name|quasi_ftree_indexing
operator|==
name|FALSE
condition|)
goto|goto
name|Exit
goto|;
block|}
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_sw
operator|!=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
condition|)
block|{
if|if
condition|(
name|p_sw
operator|->
name|is_leaf
condition|)
block|{
name|qsort
argument_list|(
name|p_sw
operator|->
name|up_port_groups
argument_list|,
comment|/* array */
name|p_sw
operator|->
name|up_port_groups_num
argument_list|,
comment|/* number of elements */
sizeof|sizeof
argument_list|(
name|ftree_port_group_t
operator|*
argument_list|)
argument_list|,
comment|/* size of each element */
name|compare_port_groups_by_remote_switch_index
argument_list|)
expr_stmt|;
comment|/* comparator */
block|}
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* fabric_make_indexing() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|int
name|fabric_create_leaf_switch_array
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_next_sw
decl_stmt|;
name|ftree_sw_t
modifier|*
modifier|*
name|all_switches_at_leaf_level
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|unsigned
name|all_leaf_idx
init|=
literal|0
decl_stmt|;
name|unsigned
name|first_leaf_idx
decl_stmt|;
name|unsigned
name|last_leaf_idx
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
comment|/* create array of ALL the switches that have leaf rank */
name|all_switches_at_leaf_level
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|ftree_sw_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|all_switches_at_leaf_level
condition|)
block|{
name|osm_log_v2
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
name|FILE_ID
argument_list|,
literal|"Fat-tree routing: Memory allocation failed\n"
argument_list|)
expr_stmt|;
name|res
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|memset
argument_list|(
name|all_switches_at_leaf_level
argument_list|,
literal|0
argument_list|,
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|ftree_sw_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_sw
operator|!=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
condition|)
block|{
name|p_sw
operator|=
name|p_next_sw
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|rank
operator|==
name|p_ftree
operator|->
name|leaf_switch_rank
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Adding switch 0x%"
name|PRIx64
literal|" to full leaf switch array\n"
argument_list|,
name|sw_get_guid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|)
expr_stmt|;
name|all_switches_at_leaf_level
index|[
name|all_leaf_idx
operator|++
index|]
operator|=
name|p_sw
expr_stmt|;
block|}
block|}
comment|/* quick-sort array of leaf switches by index */
name|qsort
argument_list|(
name|all_switches_at_leaf_level
argument_list|,
comment|/* array */
name|all_leaf_idx
argument_list|,
comment|/* number of elements */
sizeof|sizeof
argument_list|(
name|ftree_sw_t
operator|*
argument_list|)
argument_list|,
comment|/* size of each element */
name|compare_switches_by_index
argument_list|)
expr_stmt|;
comment|/* comparator */
comment|/* check the first and the last REAL leaf (the one 	   that has CNs) in the array of all the leafs */
name|first_leaf_idx
operator|=
name|all_leaf_idx
expr_stmt|;
name|last_leaf_idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|all_leaf_idx
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|all_switches_at_leaf_level
index|[
name|i
index|]
operator|->
name|is_leaf
condition|)
block|{
if|if
condition|(
name|i
operator|<
name|first_leaf_idx
condition|)
name|first_leaf_idx
operator|=
name|i
expr_stmt|;
name|last_leaf_idx
operator|=
name|i
expr_stmt|;
block|}
block|}
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Full leaf array info: first_leaf_idx = %u, last_leaf_idx = %u\n"
argument_list|,
name|first_leaf_idx
argument_list|,
name|last_leaf_idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_leaf_idx
operator|>=
name|last_leaf_idx
condition|)
block|{
name|osm_log_v2
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
name|FILE_ID
argument_list|,
literal|"Failed to find leaf switches - topology is not "
literal|"fat-tree\n"
argument_list|)
expr_stmt|;
name|res
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Create array of REAL leaf switches, sorted by index. 	   This array may contain switches at the same rank w/o CNs, 	   in case this is the order of indexing. */
name|p_ftree
operator|->
name|leaf_switches_num
operator|=
name|last_leaf_idx
operator|-
name|first_leaf_idx
operator|+
literal|1
expr_stmt|;
name|p_ftree
operator|->
name|leaf_switches
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|p_ftree
operator|->
name|leaf_switches_num
operator|*
sizeof|sizeof
argument_list|(
name|ftree_sw_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ftree
operator|->
name|leaf_switches
condition|)
block|{
name|osm_log_v2
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
name|FILE_ID
argument_list|,
literal|"Fat-tree routing: Memory allocation failed\n"
argument_list|)
expr_stmt|;
name|res
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|memcpy
argument_list|(
name|p_ftree
operator|->
name|leaf_switches
argument_list|,
operator|&
operator|(
name|all_switches_at_leaf_level
index|[
name|first_leaf_idx
index|]
operator|)
argument_list|,
name|p_ftree
operator|->
name|leaf_switches_num
operator|*
sizeof|sizeof
argument_list|(
name|ftree_sw_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Created array of %u leaf switches\n"
argument_list|,
name|p_ftree
operator|->
name|leaf_switches_num
argument_list|)
expr_stmt|;
name|Exit
label|:
name|free
argument_list|(
name|all_switches_at_leaf_level
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* fabric_create_leaf_switch_array() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|fabric_set_max_cn_per_leaf
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|unsigned
name|j
decl_stmt|;
name|unsigned
name|cns_on_this_leaf
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_port_group_t
modifier|*
name|p_group
decl_stmt|,
modifier|*
name|p_up_group
decl_stmt|;
name|ftree_hca_t
modifier|*
name|p_hca
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_ftree
operator|->
name|leaf_switches_num
condition|;
name|i
operator|++
control|)
block|{
name|p_sw
operator|=
name|p_ftree
operator|->
name|leaf_switches
index|[
name|i
index|]
expr_stmt|;
name|cns_on_this_leaf
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p_sw
operator|->
name|down_port_groups_num
condition|;
name|j
operator|++
control|)
block|{
name|p_group
operator|=
name|p_sw
operator|->
name|down_port_groups
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|p_group
operator|->
name|remote_node_type
operator|!=
name|IB_NODE_TYPE_CA
condition|)
continue|continue;
name|p_hca
operator|=
name|p_group
operator|->
name|remote_hca_or_sw
operator|.
name|p_hca
expr_stmt|;
comment|/* 			 * Get the hca port group corresponding 			 * to the LID of remote HCA port 			 */
name|p_up_group
operator|=
name|hca_get_port_group_by_lid
argument_list|(
name|p_hca
argument_list|,
name|p_group
operator|->
name|remote_lid
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_up_group
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_up_group
operator|->
name|is_cn
condition|)
name|cns_on_this_leaf
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cns_on_this_leaf
operator|>
name|p_ftree
operator|->
name|max_cn_per_leaf
condition|)
name|p_ftree
operator|->
name|max_cn_per_leaf
operator|=
name|cns_on_this_leaf
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* fabric_set_max_cn_per_leaf() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|boolean_t
name|fabric_validate_topology
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|ftree_port_group_t
modifier|*
name|p_group
decl_stmt|;
name|ftree_port_group_t
modifier|*
name|p_ref_group
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_next_sw
decl_stmt|;
name|ftree_sw_t
modifier|*
modifier|*
name|reference_sw_arr
decl_stmt|;
name|uint16_t
name|tree_rank
init|=
name|fabric_get_rank
argument_list|(
name|p_ftree
argument_list|)
decl_stmt|;
name|boolean_t
name|res
init|=
name|TRUE
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Validating fabric topology\n"
argument_list|)
expr_stmt|;
name|reference_sw_arr
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|tree_rank
operator|*
sizeof|sizeof
argument_list|(
name|ftree_sw_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reference_sw_arr
operator|==
name|NULL
condition|)
block|{
name|osm_log_v2
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
name|FILE_ID
argument_list|,
literal|"Fat-tree routing: Memory allocation failed\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|memset
argument_list|(
name|reference_sw_arr
argument_list|,
literal|0
argument_list|,
name|tree_rank
operator|*
sizeof|sizeof
argument_list|(
name|ftree_sw_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|res
operator|&&
name|p_next_sw
operator|!=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
condition|)
block|{
name|p_sw
operator|=
name|p_next_sw
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
condition|)
comment|/* This is the first switch in the current level that 			   we're checking - use it as a reference */
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|=
name|p_sw
expr_stmt|;
else|else
block|{
comment|/* compare this switch properties to the reference switch */
if|if
condition|(
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|up_port_groups_num
operator|!=
name|p_sw
operator|->
name|up_port_groups_num
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB09: Different number of upward port groups on switches:\n"
literal|"       GUID 0x%016"
name|PRIx64
literal|", LID %u, Index %s - %u groups\n"
literal|"       GUID 0x%016"
name|PRIx64
literal|", LID %u, Index %s - %u groups\n"
argument_list|,
name|sw_get_guid_ho
argument_list|(
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
argument_list|)
argument_list|,
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|lid
argument_list|,
name|tuple_to_str
argument_list|(
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|tuple
argument_list|)
argument_list|,
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|up_port_groups_num
argument_list|,
name|sw_get_guid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|,
name|p_sw
operator|->
name|lid
argument_list|,
name|tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|p_sw
operator|->
name|up_port_groups_num
argument_list|)
expr_stmt|;
name|res
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p_sw
operator|->
name|rank
operator|!=
operator|(
name|tree_rank
operator|-
literal|1
operator|)
operator|&&
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|down_port_groups_num
operator|!=
name|p_sw
operator|->
name|down_port_groups_num
condition|)
block|{
comment|/* we're allowing some hca's to be missing */
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB0A: Different number of downward port groups on switches:\n"
literal|"       GUID 0x%016"
name|PRIx64
literal|", LID %u, Index %s - %u port groups\n"
literal|"       GUID 0x%016"
name|PRIx64
literal|", LID %u, Index %s - %u port groups\n"
argument_list|,
name|sw_get_guid_ho
argument_list|(
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
argument_list|)
argument_list|,
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|lid
argument_list|,
name|tuple_to_str
argument_list|(
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|tuple
argument_list|)
argument_list|,
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|down_port_groups_num
argument_list|,
name|sw_get_guid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|,
name|p_sw
operator|->
name|lid
argument_list|,
name|tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|p_sw
operator|->
name|down_port_groups_num
argument_list|)
expr_stmt|;
name|res
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|up_port_groups_num
operator|!=
literal|0
condition|)
block|{
name|p_ref_group
operator|=
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|up_port_groups
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|up_port_groups_num
condition|;
name|i
operator|++
control|)
block|{
name|p_group
operator|=
name|p_sw
operator|->
name|up_port_groups
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_ref_group
operator|->
name|ports
argument_list|)
operator|!=
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB0B: Different number of ports in an upward port group on switches:\n"
literal|"       GUID 0x%016"
name|PRIx64
literal|", LID %u, Index %s - %u ports\n"
literal|"       GUID 0x%016"
name|PRIx64
literal|", LID %u, Index %s - %u ports\n"
argument_list|,
name|sw_get_guid_ho
argument_list|(
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
argument_list|)
argument_list|,
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|lid
argument_list|,
name|tuple_to_str
argument_list|(
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|tuple
argument_list|)
argument_list|,
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_ref_group
operator|->
name|ports
argument_list|)
argument_list|,
name|sw_get_guid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|,
name|p_sw
operator|->
name|lid
argument_list|,
name|tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|down_port_groups_num
operator|!=
literal|0
operator|&&
name|p_sw
operator|->
name|rank
operator|!=
operator|(
name|tree_rank
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* we're allowing some hca's to be missing */
name|p_ref_group
operator|=
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|down_port_groups
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|down_port_groups_num
condition|;
name|i
operator|++
control|)
block|{
name|p_group
operator|=
name|p_sw
operator|->
name|down_port_groups
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_ref_group
operator|->
name|ports
argument_list|)
operator|!=
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB0C: Different number of ports in an downward port group on switches:\n"
literal|"       GUID 0x%016"
name|PRIx64
literal|", LID %u, Index %s - %u ports\n"
literal|"       GUID 0x%016"
name|PRIx64
literal|", LID %u, Index %s - %u ports\n"
argument_list|,
name|sw_get_guid_ho
argument_list|(
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
argument_list|)
argument_list|,
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|lid
argument_list|,
name|tuple_to_str
argument_list|(
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|tuple
argument_list|)
argument_list|,
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_ref_group
operator|->
name|ports
argument_list|)
argument_list|,
name|sw_get_guid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|,
name|p_sw
operator|->
name|lid
argument_list|,
name|tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* end of else */
block|}
comment|/* end of while */
if|if
condition|(
name|res
operator|==
name|TRUE
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Fabric topology has been identified as FatTree\n"
argument_list|)
expr_stmt|;
else|else
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB0D: Fabric topology hasn't been identified as FatTree\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reference_sw_arr
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* fabric_validate_topology() */
end_comment

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|void
name|set_sw_fwd_table
parameter_list|(
name|IN
name|cl_map_item_t
modifier|*
specifier|const
name|p_map_item
parameter_list|,
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
init|=
operator|(
name|ftree_sw_t
operator|*
specifier|const
operator|)
name|p_map_item
decl_stmt|;
name|ftree_fabric_t
modifier|*
name|p_ftree
init|=
operator|(
name|ftree_fabric_t
operator|*
operator|)
name|context
decl_stmt|;
name|p_sw
operator|->
name|p_osm_sw
operator|->
name|max_lid_ho
operator|=
name|p_ftree
operator|->
name|lft_max_lid
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_comment
comment|/*  * Function: Finds the least loaded port group and stores its counter  * Given   : A switch  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|recalculate_min_counter_down
parameter_list|(
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|)
block|{
name|uint32_t
name|min
init|=
operator|(
literal|1
operator|<<
literal|30
operator|)
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|down_port_groups_num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_sw
operator|->
name|down_port_groups
index|[
name|i
index|]
operator|->
name|counter_down
operator|<
name|min
condition|)
block|{
name|min
operator|=
name|p_sw
operator|->
name|down_port_groups
index|[
name|i
index|]
operator|->
name|counter_down
expr_stmt|;
block|}
block|}
name|p_sw
operator|->
name|min_counter_down
operator|=
name|min
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Function: Return the counter value of the least loaded down port group  * Given   : A switch  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint32_t
name|find_lowest_loaded_group_on_sw
parameter_list|(
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|)
block|{
return|return
name|p_sw
operator|->
name|min_counter_down
return|;
block|}
end_function

begin_comment
comment|/*  * Function: Compare the load of two port groups and return which is the least loaded  * Given   : Two port groups with remote switch  * When both port groups are equally loaded, it picks the one whom  * remote switch down ports are least loaded.  * This way, it prefers the switch from where it will be easier to go down (creating upward routes).  * If both are equal, it picks the lowest INDEX to be deterministic.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|port_group_compare_load_down
parameter_list|(
specifier|const
name|ftree_port_group_t
modifier|*
name|p1
parameter_list|,
specifier|const
name|ftree_port_group_t
modifier|*
name|p2
parameter_list|)
block|{
name|int
name|temp
init|=
name|p1
operator|->
name|counter_down
operator|-
name|p2
operator|->
name|counter_down
decl_stmt|;
if|if
condition|(
name|temp
operator|>
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Find the less loaded remote sw and choose this one */
do|do
block|{
name|uint32_t
name|load1
init|=
name|find_lowest_loaded_group_on_sw
argument_list|(
name|p1
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
argument_list|)
decl_stmt|;
name|uint32_t
name|load2
init|=
name|find_lowest_loaded_group_on_sw
argument_list|(
name|p2
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
argument_list|)
decl_stmt|;
name|temp
operator|=
name|load1
operator|-
name|load2
expr_stmt|;
if|if
condition|(
name|temp
operator|>
literal|0
condition|)
return|return
literal|1
return|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
comment|/* If they are both equal, choose the lowest index */
return|return
name|compare_port_groups_by_remote_switch_index
argument_list|(
operator|&
name|p1
argument_list|,
operator|&
name|p2
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|port_group_compare_load_up
parameter_list|(
specifier|const
name|ftree_port_group_t
modifier|*
name|p1
parameter_list|,
specifier|const
name|ftree_port_group_t
modifier|*
name|p2
parameter_list|)
block|{
name|int
name|temp
init|=
name|p1
operator|->
name|counter_up
operator|-
name|p2
operator|->
name|counter_up
decl_stmt|;
if|if
condition|(
name|temp
operator|>
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If they are both equal, choose the lowest index */
return|return
name|compare_port_groups_by_remote_switch_index
argument_list|(
operator|&
name|p1
argument_list|,
operator|&
name|p2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function: Sorts an array of port group by up load order  * Given   : A port group array and its length  * As the list is mostly sorted, we used a bubble sort instead of qsort  * as it is much faster.  *  * Important note:  * This function and bubble_sort_down must NOT be factorized.  * Although most of the code is the same and a function pointer could be used  * for the compareason function, it would prevent the compareason function to be inlined  * and cost a great deal to performances.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|bubble_sort_up
parameter_list|(
name|ftree_port_group_t
modifier|*
modifier|*
name|p_group_array
parameter_list|,
name|uint32_t
name|nmemb
parameter_list|)
block|{
name|uint32_t
name|i
init|=
literal|0
decl_stmt|;
name|uint32_t
name|j
init|=
literal|0
decl_stmt|;
name|ftree_port_group_t
modifier|*
name|tmp
init|=
name|p_group_array
index|[
literal|0
index|]
decl_stmt|;
comment|/* As this function is a great number of times, we only go into the loop 	 * if one of the port counters has changed, thus saving some tests */
if|if
condition|(
name|tmp
operator|->
name|hca_or_sw
operator|.
name|p_sw
operator|->
name|counter_up_changed
operator|==
name|FALSE
condition|)
block|{
return|return;
block|}
comment|/* While we did modifications on the array order */
comment|/* i may grew above array length but next loop will fail and tmp will be null for the next time 	 * this way we save a test i< nmemb for each pass through the loop */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tmp
condition|;
name|i
operator|++
control|)
block|{
comment|/* Assume the array is orderd */
name|tmp
operator|=
name|NULL
expr_stmt|;
comment|/* Comparing elements j and j-1 */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
operator|(
name|nmemb
operator|-
name|i
operator|)
condition|;
name|j
operator|++
control|)
block|{
comment|/* If they are the wrong way around */
if|if
condition|(
name|port_group_compare_load_up
argument_list|(
name|p_group_array
index|[
name|j
index|]
argument_list|,
name|p_group_array
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* We invert them */
name|tmp
operator|=
name|p_group_array
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|p_group_array
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|p_group_array
index|[
name|j
index|]
expr_stmt|;
name|p_group_array
index|[
name|j
index|]
operator|=
name|tmp
expr_stmt|;
comment|/* This sets tmp != NULL so the main loop will make another pass */
block|}
block|}
block|}
comment|/* We have reordered the array so as long noone changes the counter 	 * it's not necessary to do it again */
name|p_group_array
index|[
literal|0
index|]
operator|->
name|hca_or_sw
operator|.
name|p_sw
operator|->
name|counter_up_changed
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|bubble_sort_siblings
parameter_list|(
name|ftree_port_group_t
modifier|*
modifier|*
name|p_group_array
parameter_list|,
name|uint32_t
name|nmemb
parameter_list|)
block|{
name|uint32_t
name|i
init|=
literal|0
decl_stmt|;
name|uint32_t
name|j
init|=
literal|0
decl_stmt|;
name|ftree_port_group_t
modifier|*
name|tmp
init|=
name|p_group_array
index|[
literal|0
index|]
decl_stmt|;
comment|/* While we did modifications on the array order */
comment|/* i may grew above array length but next loop will fail and tmp will be null for the next time 	 * this way we save a test i< nmemb for each pass through the loop */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tmp
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
comment|/* Assume the array is orderd */
name|tmp
operator|=
name|NULL
expr_stmt|;
comment|/* Comparing elements j and j-1 */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
operator|(
name|nmemb
operator|-
name|i
operator|)
condition|;
name|j
operator|++
control|)
block|{
comment|/* If they are the wrong way around */
if|if
condition|(
name|port_group_compare_load_up
argument_list|(
name|p_group_array
index|[
name|j
index|]
argument_list|,
name|p_group_array
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* We invert them */
name|tmp
operator|=
name|p_group_array
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|p_group_array
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|p_group_array
index|[
name|j
index|]
expr_stmt|;
name|p_group_array
index|[
name|j
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Function: Sorts an array of port group. Order is decide through  * port_group_compare_load_down ( up counters, least load remote switch, biggest GUID)  * Given   : A port group array and its length. Each port group points to a remote switch (not a HCA)  * As the list is mostly sorted, we used a bubble sort instead of qsort  * as it is much faster.  *  * Important note:  * This function and bubble_sort_up must NOT be factorized.  * Although most of the code is the same and a function pointer could be used  * for the compareason function, it would prevent the compareason function to be inlined  * and cost a great deal to performances.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|bubble_sort_down
parameter_list|(
name|ftree_port_group_t
modifier|*
modifier|*
name|p_group_array
parameter_list|,
name|uint32_t
name|nmemb
parameter_list|)
block|{
name|uint32_t
name|i
init|=
literal|0
decl_stmt|;
name|uint32_t
name|j
init|=
literal|0
decl_stmt|;
name|ftree_port_group_t
modifier|*
name|tmp
init|=
name|p_group_array
index|[
literal|0
index|]
decl_stmt|;
comment|/* While we did modifications on the array order */
comment|/* i may grew above array length but next loop will fail and tmp will be null for the next time 	 * this way we save a test i< nmemb for each pass through the loop */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tmp
condition|;
name|i
operator|++
control|)
block|{
comment|/* Assume the array is orderd */
name|tmp
operator|=
name|NULL
expr_stmt|;
comment|/* Comparing elements j and j-1 */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
operator|(
name|nmemb
operator|-
name|i
operator|)
condition|;
name|j
operator|++
control|)
block|{
comment|/* If they are the wrong way around */
if|if
condition|(
name|port_group_compare_load_down
argument_list|(
name|p_group_array
index|[
name|j
index|]
argument_list|,
name|p_group_array
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* We invert them */
name|tmp
operator|=
name|p_group_array
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|p_group_array
index|[
name|j
operator|-
literal|1
index|]
operator|=
name|p_group_array
index|[
name|j
index|]
expr_stmt|;
name|p_group_array
index|[
name|j
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_comment
comment|/*  * Function: assign-up-going-port-by-descending-down  * Given   : a switch and a LID  * Pseudo code:  *    foreach down-going-port-group (in indexing order)  *        skip this group if the LFT(LID) port is part of this group  *        find the least loaded port of the group (scan in indexing order)  *        r-port is the remote port connected to it  *        assign the remote switch node LFT(LID) to r-port  *        increase r-port usage counter  *        assign-up-going-port-by-descending-down to r-port node (recursion)  */
end_comment

begin_function
specifier|static
name|boolean_t
name|fabric_route_upgoing_by_going_down
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|ftree_sw_t
modifier|*
name|p_prev_sw
parameter_list|,
name|IN
name|uint16_t
name|target_lid
parameter_list|,
name|IN
name|boolean_t
name|is_main_path
parameter_list|,
name|IN
name|boolean_t
name|is_target_a_sw
parameter_list|,
name|IN
name|uint8_t
name|current_hops
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_remote_sw
decl_stmt|;
name|uint16_t
name|ports_num
decl_stmt|;
name|ftree_port_group_t
modifier|*
name|p_group
decl_stmt|;
name|ftree_port_t
modifier|*
name|p_port
decl_stmt|;
name|ftree_port_t
modifier|*
name|p_min_port
decl_stmt|;
name|uint16_t
name|j
decl_stmt|;
name|uint16_t
name|k
decl_stmt|;
name|boolean_t
name|created_route
init|=
name|FALSE
decl_stmt|;
name|boolean_t
name|routed
init|=
literal|0
decl_stmt|;
name|uint8_t
name|least_hops
decl_stmt|;
comment|/* if there is no down-going ports */
if|if
condition|(
name|p_sw
operator|->
name|down_port_groups_num
operator|==
literal|0
condition|)
return|return
name|FALSE
return|;
comment|/* foreach down-going port group (in load order) */
name|bubble_sort_up
argument_list|(
name|p_sw
operator|->
name|down_port_groups
argument_list|,
name|p_sw
operator|->
name|down_port_groups_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|sibling_port_groups_num
operator|>
literal|0
condition|)
name|bubble_sort_siblings
argument_list|(
name|p_sw
operator|->
name|sibling_port_groups
argument_list|,
name|p_sw
operator|->
name|sibling_port_groups_num
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
operator|(
name|p_sw
operator|->
name|down_port_groups_num
operator|+
operator|(
operator|(
name|target_lid
operator|!=
literal|0
operator|)
condition|?
name|p_sw
operator|->
name|sibling_port_groups_num
else|:
literal|0
operator|)
operator|)
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|k
operator|<
name|p_sw
operator|->
name|down_port_groups_num
condition|)
block|{
name|p_group
operator|=
name|p_sw
operator|->
name|down_port_groups
index|[
name|k
index|]
expr_stmt|;
block|}
else|else
block|{
name|p_group
operator|=
name|p_sw
operator|->
name|sibling_port_groups
index|[
name|k
operator|-
name|p_sw
operator|->
name|down_port_groups_num
index|]
expr_stmt|;
block|}
comment|/* If this port group doesn't point to a switch, mark 		   that the route was created and skip to the next group */
if|if
condition|(
name|p_group
operator|->
name|remote_node_type
operator|!=
name|IB_NODE_TYPE_SWITCH
condition|)
block|{
name|created_route
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|p_prev_sw
operator|&&
name|p_group
operator|->
name|remote_lid
operator|==
name|p_prev_sw
operator|->
name|lid
condition|)
block|{
comment|/* This port group has a port that was used when we entered this switch, 			   which means that the current group points to the switch where we were 			   at the previous step of the algorithm (before going up). 			   Skipping this group. */
continue|continue;
block|}
comment|/* find the least loaded port of the group (in indexing order) */
name|p_min_port
operator|=
name|NULL
expr_stmt|;
name|ports_num
operator|=
operator|(
name|uint16_t
operator|)
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|)
expr_stmt|;
if|if
condition|(
name|ports_num
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ports_num
condition|;
name|j
operator|++
control|)
block|{
name|cl_ptr_vector_at
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|,
name|j
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_port
argument_list|)
expr_stmt|;
comment|/* first port that we're checking - set as port with the lowest load */
comment|/* or this port is less loaded - use it as min */
if|if
condition|(
operator|!
name|p_min_port
operator|||
name|p_port
operator|->
name|counter_up
operator|<
name|p_min_port
operator|->
name|counter_up
condition|)
name|p_min_port
operator|=
name|p_port
expr_stmt|;
block|}
comment|/* At this point we have selected a port in this group with the 		   lowest load of upgoing routes. 		   Set on the remote switch how to get to the target_lid - 		   set LFT(target_lid) on the remote switch to the remote port */
name|p_remote_sw
operator|=
name|p_group
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
expr_stmt|;
name|least_hops
operator|=
name|sw_get_least_hops
argument_list|(
name|p_remote_sw
argument_list|,
name|target_lid
argument_list|)
expr_stmt|;
if|if
condition|(
name|least_hops
operator|!=
name|OSM_NO_PATH
condition|)
block|{
comment|/* Loop in the fabric - we already routed the remote switch 			   on our way UP, and now we see it again on our way DOWN */
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Loop of length %d in the fabric:\n                             "
literal|"Switch %s (LID %u) closes loop through switch %s (LID %u)\n"
argument_list|,
name|current_hops
argument_list|,
name|tuple_to_str
argument_list|(
name|p_remote_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|p_group
operator|->
name|lid
argument_list|,
name|tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|p_group
operator|->
name|remote_lid
argument_list|)
expr_stmt|;
comment|/* We skip only if we have come through a longer path */
if|if
condition|(
name|current_hops
operator|+
literal|1
operator|>=
name|least_hops
condition|)
continue|continue;
block|}
comment|/* Four possible cases: 		 * 		 *  1. is_main_path == TRUE: 		 *      - going DOWN(TRUE,TRUE) through ALL the groups 		 *         + promoting port counter 		 *         + setting path in remote switch fwd tbl 		 *         + setting hops in remote switch on all the ports of each group 		 * 		 *  2. is_main_path == FALSE: 		 *      - going DOWN(TRUE,FALSE) through ALL the groups but only if 		 *        the remote (lower) switch hasn't been already configured 		 *        for this target LID (or with a longer path) 		 *         + promoting port counter 		 *         + setting path in remote switch fwd tbl if it hasn't been set yet 		 *         + setting hops in remote switch on all the ports of each group 		 *           if it hasn't been set yet 		 */
comment|/* setting fwd tbl port only */
name|p_remote_sw
operator|->
name|p_osm_sw
operator|->
name|new_lft
index|[
name|target_lid
index|]
operator|=
name|p_min_port
operator|->
name|remote_port_num
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Switch %s: set path to CA LID %u through port %u\n"
argument_list|,
name|tuple_to_str
argument_list|(
name|p_remote_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|target_lid
argument_list|,
name|p_min_port
operator|->
name|remote_port_num
argument_list|)
expr_stmt|;
comment|/* On the remote switch that is pointed by the p_group, 			set hops for ALL the ports in the remote group. */
name|set_hops_on_remote_sw
argument_list|(
name|p_group
argument_list|,
name|target_lid
argument_list|,
name|current_hops
operator|+
literal|1
argument_list|,
name|is_target_a_sw
argument_list|)
expr_stmt|;
comment|/* Recursion step: 		   Assign upgoing ports by stepping down, starting on REMOTE switch */
name|routed
operator|=
name|fabric_route_upgoing_by_going_down
argument_list|(
name|p_ftree
argument_list|,
name|p_remote_sw
argument_list|,
comment|/* remote switch - used as a route-upgoing alg. start point */
name|NULL
argument_list|,
comment|/* prev. position - NULL to mark that we went down and not up */
name|target_lid
argument_list|,
comment|/* LID that we're routing to */
name|is_main_path
argument_list|,
comment|/* whether this is path to HCA that should by tracked by counters */
name|is_target_a_sw
argument_list|,
comment|/* Whether target lid is a switch or not */
name|current_hops
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Number of hops done to this point */
name|created_route
operator||=
name|routed
expr_stmt|;
comment|/* Counters are promoted only if a route toward a node is created */
if|if
condition|(
name|routed
condition|)
block|{
name|p_min_port
operator|->
name|counter_up
operator|++
expr_stmt|;
name|p_group
operator|->
name|counter_up
operator|++
expr_stmt|;
name|p_group
operator|->
name|hca_or_sw
operator|.
name|p_sw
operator|->
name|counter_up_changed
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* done scanning all the down-going port groups */
comment|/* if the route was created, promote the index that 	   indicates which group should we start with when 	   going through all the downgoing groups */
if|if
condition|(
name|created_route
condition|)
name|p_sw
operator|->
name|down_port_groups_idx
operator|=
operator|(
name|p_sw
operator|->
name|down_port_groups_idx
operator|+
literal|1
operator|)
operator|%
name|p_sw
operator|->
name|down_port_groups_num
expr_stmt|;
return|return
name|created_route
return|;
block|}
end_function

begin_comment
comment|/* fabric_route_upgoing_by_going_down() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_comment
comment|/*  * Function: assign-down-going-port-by-ascending-up  * Given   : a switch and a LID  * Pseudo code:  *    find the least loaded port of all the upgoing groups (scan in indexing order)  *    assign the LFT(LID) of remote switch to that port  *    track that port usage  *    assign-up-going-port-by-descending-down on CURRENT switch  *    assign-down-going-port-by-ascending-up on REMOTE switch (recursion)  */
end_comment

begin_function
specifier|static
name|boolean_t
name|fabric_route_downgoing_by_going_up
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|ftree_sw_t
modifier|*
name|p_prev_sw
parameter_list|,
name|IN
name|uint16_t
name|target_lid
parameter_list|,
name|IN
name|boolean_t
name|is_main_path
parameter_list|,
name|IN
name|boolean_t
name|is_target_a_sw
parameter_list|,
name|IN
name|uint16_t
name|reverse_hop_credit
parameter_list|,
name|IN
name|uint16_t
name|reverse_hops
parameter_list|,
name|IN
name|uint8_t
name|current_hops
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_remote_sw
decl_stmt|;
name|uint16_t
name|ports_num
decl_stmt|;
name|ftree_port_group_t
modifier|*
name|p_group
decl_stmt|;
name|ftree_port_t
modifier|*
name|p_port
decl_stmt|;
name|ftree_port_group_t
modifier|*
name|p_min_group
decl_stmt|;
name|ftree_port_t
modifier|*
name|p_min_port
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|uint16_t
name|j
decl_stmt|;
name|boolean_t
name|created_route
init|=
name|FALSE
decl_stmt|;
name|boolean_t
name|routed
init|=
name|FALSE
decl_stmt|;
comment|/* Assign upgoing ports by stepping down, starting on THIS switch */
name|created_route
operator|=
name|fabric_route_upgoing_by_going_down
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
argument_list|,
comment|/* local switch - used as a route-upgoing alg. start point */
name|p_prev_sw
argument_list|,
comment|/* switch that we went up from (NULL means that we went down) */
name|target_lid
argument_list|,
comment|/* LID that we're routing to */
name|is_main_path
argument_list|,
comment|/* whether this path to HCA should by tracked by counters */
name|is_target_a_sw
argument_list|,
comment|/* Whether target lid is a switch or not */
name|current_hops
argument_list|)
expr_stmt|;
comment|/* Number of hops done up to this point */
comment|/* recursion stop condition - if it's a root switch, */
if|if
condition|(
name|p_sw
operator|->
name|rank
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reverse_hop_credit
operator|>
literal|0
condition|)
block|{
comment|/* We go up by going down as we have some reverse_hop_credit left */
comment|/* We use the index to scatter a bit the reverse up routes */
name|p_sw
operator|->
name|down_port_groups_idx
operator|=
operator|(
name|p_sw
operator|->
name|down_port_groups_idx
operator|+
literal|1
operator|)
operator|%
name|p_sw
operator|->
name|down_port_groups_num
expr_stmt|;
name|i
operator|=
name|p_sw
operator|->
name|down_port_groups_idx
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p_sw
operator|->
name|down_port_groups_num
condition|;
name|j
operator|++
control|)
block|{
name|p_group
operator|=
name|p_sw
operator|->
name|down_port_groups
index|[
name|i
index|]
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|p_sw
operator|->
name|down_port_groups_num
expr_stmt|;
comment|/* Skip this port group unless it points to a switch */
if|if
condition|(
name|p_group
operator|->
name|remote_node_type
operator|!=
name|IB_NODE_TYPE_SWITCH
condition|)
continue|continue;
name|p_remote_sw
operator|=
name|p_group
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
expr_stmt|;
name|created_route
operator||=
name|fabric_route_downgoing_by_going_up
argument_list|(
name|p_ftree
argument_list|,
name|p_remote_sw
argument_list|,
comment|/* remote switch - used as a route-downgoing alg. next step point */
name|p_sw
argument_list|,
comment|/* this switch - prev. position switch for the function */
name|target_lid
argument_list|,
comment|/* LID that we're routing to */
name|is_main_path
argument_list|,
comment|/* whether this is path to HCA that should by tracked by counters */
name|is_target_a_sw
argument_list|,
comment|/* Whether target lid is a switch or not */
name|reverse_hop_credit
operator|-
literal|1
argument_list|,
comment|/* Remaining reverse_hops allowed */
name|reverse_hops
operator|+
literal|1
argument_list|,
comment|/* Number of reverse_hops done up to this point */
name|current_hops
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|created_route
return|;
block|}
comment|/* We should generate a list of port sorted by load so we can find easily the least 	 * going port and explore the other pots on secondary routes more easily (and quickly) */
name|bubble_sort_down
argument_list|(
name|p_sw
operator|->
name|up_port_groups
argument_list|,
name|p_sw
operator|->
name|up_port_groups_num
argument_list|)
expr_stmt|;
name|p_min_group
operator|=
name|p_sw
operator|->
name|up_port_groups
index|[
literal|0
index|]
expr_stmt|;
comment|/* Find the least loaded upgoing port in the selected group */
name|p_min_port
operator|=
name|NULL
expr_stmt|;
name|ports_num
operator|=
operator|(
name|uint16_t
operator|)
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_min_group
operator|->
name|ports
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ports_num
condition|;
name|j
operator|++
control|)
block|{
name|cl_ptr_vector_at
argument_list|(
operator|&
name|p_min_group
operator|->
name|ports
argument_list|,
name|j
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_min_port
condition|)
block|{
comment|/* first port that we're checking - use 			   it as a port with the lowest load */
name|p_min_port
operator|=
name|p_port
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_port
operator|->
name|counter_down
operator|<
name|p_min_port
operator|->
name|counter_down
condition|)
block|{
comment|/* this port is less loaded - use it as min */
name|p_min_port
operator|=
name|p_port
expr_stmt|;
block|}
block|}
comment|/* At this point we have selected a group and port with the 	   lowest load of downgoing routes. 	   Set on the remote switch how to get to the target_lid - 	   set LFT(target_lid) on the remote switch to the remote port */
name|p_remote_sw
operator|=
name|p_min_group
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
expr_stmt|;
comment|/* Four possible cases: 	 * 	 *  1. is_main_path == TRUE: 	 *      - going UP(TRUE,TRUE) on selected min_group and min_port 	 *         + promoting port counter 	 *         + setting path in remote switch fwd tbl 	 *         + setting hops in remote switch on all the ports of selected group 	 *      - going UP(TRUE,FALSE) on rest of the groups, each time on port 0 	 *         + NOT promoting port counter 	 *         + setting path in remote switch fwd tbl if it hasn't been set yet 	 *         + setting hops in remote switch on all the ports of each group 	 *           if it hasn't been set yet 	 * 	 *  2. is_main_path == FALSE: 	 *      - going UP(TRUE,FALSE) on ALL the groups, each time on port 0, 	 *        but only if the remote (upper) switch hasn't been already 	 *        configured for this target LID 	 *         + NOT promoting port counter 	 *         + setting path in remote switch fwd tbl if it hasn't been set yet 	 *         + setting hops in remote switch on all the ports of each group 	 *           if it hasn't been set yet 	 */
comment|/* covering first half of case 1, and case 3 */
if|if
condition|(
name|is_main_path
condition|)
block|{
if|if
condition|(
name|p_sw
operator|->
name|is_leaf
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|" - Routing MAIN path for %s CA LID %u: %s --> %s\n"
argument_list|,
operator|(
name|target_lid
operator|!=
literal|0
operator|)
condition|?
literal|"real"
else|:
literal|"DUMMY"
argument_list|,
name|target_lid
argument_list|,
name|tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|tuple_to_str
argument_list|(
name|p_remote_sw
operator|->
name|tuple
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The number of downgoing routes is tracked in the 		   p_group->counter_down p_port->counter_down counters of the 		   group and port that belong to the lower side of the link 		   (on switch with higher rank) */
name|p_min_group
operator|->
name|counter_down
operator|++
expr_stmt|;
name|p_min_port
operator|->
name|counter_down
operator|++
expr_stmt|;
if|if
condition|(
name|p_min_group
operator|->
name|counter_down
operator|==
operator|(
name|p_min_group
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
operator|->
name|min_counter_down
operator|+
literal|1
operator|)
condition|)
block|{
name|recalculate_min_counter_down
argument_list|(
name|p_min_group
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
argument_list|)
expr_stmt|;
block|}
comment|/* This LID may already be in the LFT in the reverse_hop feature is used */
comment|/* We update the LFT only if this LID isn't already present. */
comment|/* skip if target lid has been already set on remote switch fwd tbl (with a bigger hop count) */
if|if
condition|(
operator|(
name|p_remote_sw
operator|->
name|p_osm_sw
operator|->
name|new_lft
index|[
name|target_lid
index|]
operator|==
name|OSM_NO_PATH
operator|)
operator|||
operator|(
name|current_hops
operator|+
literal|1
operator|<
name|sw_get_least_hops
argument_list|(
name|p_remote_sw
argument_list|,
name|target_lid
argument_list|)
operator|)
condition|)
block|{
name|p_remote_sw
operator|->
name|p_osm_sw
operator|->
name|new_lft
index|[
name|target_lid
index|]
operator|=
name|p_min_port
operator|->
name|remote_port_num
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Switch %s: set path to CA LID %u through port %u\n"
argument_list|,
name|tuple_to_str
argument_list|(
name|p_remote_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|target_lid
argument_list|,
name|p_min_port
operator|->
name|remote_port_num
argument_list|)
expr_stmt|;
comment|/* On the remote switch that is pointed by the min_group, 			set hops for ALL the ports in the remote group. */
name|set_hops_on_remote_sw
argument_list|(
name|p_min_group
argument_list|,
name|target_lid
argument_list|,
name|current_hops
operator|+
literal|1
argument_list|,
name|is_target_a_sw
argument_list|)
expr_stmt|;
block|}
comment|/* Recursion step: Assign downgoing ports by stepping up, starting on REMOTE switch. */
name|created_route
operator||=
name|fabric_route_downgoing_by_going_up
argument_list|(
name|p_ftree
argument_list|,
name|p_remote_sw
argument_list|,
comment|/* remote switch - used as a route-downgoing alg. next step point */
name|p_sw
argument_list|,
comment|/* this switch - prev. position switch for the function */
name|target_lid
argument_list|,
comment|/* LID that we're routing to */
name|is_main_path
argument_list|,
comment|/* whether this is path to HCA that should by tracked by counters */
name|is_target_a_sw
argument_list|,
comment|/* Whether target lid is a switch or not */
name|reverse_hop_credit
argument_list|,
comment|/* Remaining reverse_hops allowed */
name|reverse_hops
argument_list|,
comment|/* Number of reverse_hops done up to this point */
name|current_hops
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* What's left to do at this point: 	 * 	 *  1. is_main_path == TRUE: 	 *      - going UP(TRUE,FALSE) on rest of the groups, each time on port 0, 	 *        but only if the remote (upper) switch hasn't been already 	 *        configured for this target LID 	 *         + NOT promoting port counter 	 *         + setting path in remote switch fwd tbl if it hasn't been set yet 	 *         + setting hops in remote switch on all the ports of each group 	 *           if it hasn't been set yet 	 * 	 *  2. is_main_path == FALSE: 	 *      - going UP(TRUE,FALSE) on ALL the groups, each time on port 0, 	 *        but only if the remote (upper) switch hasn't been already 	 *        configured for this target LID 	 *         + NOT promoting port counter 	 *         + setting path in remote switch fwd tbl if it hasn't been set yet 	 *         + setting hops in remote switch on all the ports of each group 	 *           if it hasn't been set yet 	 * 	 *  These two rules can be rephrased this way: 	 *   - foreach UP port group 	 *      + if remote switch has been set with the target LID 	 *         - skip this port group 	 *      + else 	 *         - select port 0 	 *         - do NOT promote port counter 	 *         - set path in remote switch fwd tbl 	 *         - set hops in remote switch on all the ports of this group 	 *         - go UP(TRUE,FALSE) to the remote switch 	 */
for|for
control|(
name|i
operator|=
name|is_main_path
condition|?
literal|1
else|:
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|up_port_groups_num
condition|;
name|i
operator|++
control|)
block|{
name|p_group
operator|=
name|p_sw
operator|->
name|up_port_groups
index|[
name|i
index|]
expr_stmt|;
name|p_remote_sw
operator|=
name|p_group
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
expr_stmt|;
comment|/* skip if target lid has been already set on remote switch fwd tbl (with a bigger hop count) */
if|if
condition|(
name|p_remote_sw
operator|->
name|p_osm_sw
operator|->
name|new_lft
index|[
name|target_lid
index|]
operator|!=
name|OSM_NO_PATH
condition|)
if|if
condition|(
name|current_hops
operator|+
literal|1
operator|>=
name|sw_get_least_hops
argument_list|(
name|p_remote_sw
argument_list|,
name|target_lid
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|p_sw
operator|->
name|is_leaf
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|" - Routing SECONDARY path for LID %u: %s --> %s\n"
argument_list|,
name|target_lid
argument_list|,
name|tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|tuple_to_str
argument_list|(
name|p_remote_sw
operator|->
name|tuple
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Routing REAL lids on SECONDARY path means routing 		   switch-to-switch or switch-to-CA paths. 		   We can safely assume that switch will initiate very 		   few traffic, so there's no point wasting runtime on 		   trying to balance these routes - always pick port 0. */
name|p_min_port
operator|=
name|NULL
expr_stmt|;
name|ports_num
operator|=
operator|(
name|uint16_t
operator|)
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|)
expr_stmt|;
if|if
condition|(
name|ports_num
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ports_num
condition|;
name|j
operator|++
control|)
block|{
name|cl_ptr_vector_at
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|,
name|j
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_min_port
condition|)
block|{
comment|/* first port that we're checking - use 				   it as a port with the lowest load */
name|p_min_port
operator|=
name|p_port
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_port
operator|->
name|counter_down
operator|<
name|p_min_port
operator|->
name|counter_down
condition|)
block|{
comment|/* this port is less loaded - use it as min */
name|p_min_port
operator|=
name|p_port
expr_stmt|;
block|}
block|}
name|p_port
operator|=
name|p_min_port
expr_stmt|;
name|p_remote_sw
operator|->
name|p_osm_sw
operator|->
name|new_lft
index|[
name|target_lid
index|]
operator|=
name|p_port
operator|->
name|remote_port_num
expr_stmt|;
comment|/* On the remote switch that is pointed by the p_group, 		   set hops for ALL the ports in the remote group. */
name|set_hops_on_remote_sw
argument_list|(
name|p_group
argument_list|,
name|target_lid
argument_list|,
name|current_hops
operator|+
literal|1
argument_list|,
name|is_target_a_sw
argument_list|)
expr_stmt|;
comment|/* Recursion step: 		   Assign downgoing ports by stepping up, starting on REMOTE switch. */
name|routed
operator|=
name|fabric_route_downgoing_by_going_up
argument_list|(
name|p_ftree
argument_list|,
name|p_remote_sw
argument_list|,
comment|/* remote switch - used as a route-downgoing alg. next step point */
name|p_sw
argument_list|,
comment|/* this switch - prev. position switch for the function */
name|target_lid
argument_list|,
comment|/* LID that we're routing to */
name|FALSE
argument_list|,
comment|/* whether this is path to HCA that should by tracked by counters */
name|is_target_a_sw
argument_list|,
comment|/* Whether target lid is a switch or not */
name|reverse_hop_credit
argument_list|,
comment|/* Remaining reverse_hops allowed */
name|reverse_hops
argument_list|,
comment|/* Number of reverse_hops done up to this point */
name|current_hops
operator|+
literal|1
argument_list|)
expr_stmt|;
name|created_route
operator||=
name|routed
expr_stmt|;
block|}
comment|/* Now doing the same thing with horizontal links */
if|if
condition|(
name|p_sw
operator|->
name|sibling_port_groups_num
operator|>
literal|0
condition|)
name|bubble_sort_down
argument_list|(
name|p_sw
operator|->
name|sibling_port_groups
argument_list|,
name|p_sw
operator|->
name|sibling_port_groups_num
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|sibling_port_groups_num
condition|;
name|i
operator|++
control|)
block|{
name|p_group
operator|=
name|p_sw
operator|->
name|sibling_port_groups
index|[
name|i
index|]
expr_stmt|;
name|p_remote_sw
operator|=
name|p_group
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
expr_stmt|;
comment|/* skip if target lid has been already set on remote switch fwd tbl (with a bigger hop count) */
if|if
condition|(
name|p_remote_sw
operator|->
name|p_osm_sw
operator|->
name|new_lft
index|[
name|target_lid
index|]
operator|!=
name|OSM_NO_PATH
condition|)
if|if
condition|(
name|current_hops
operator|+
literal|1
operator|>=
name|sw_get_least_hops
argument_list|(
name|p_remote_sw
argument_list|,
name|target_lid
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|p_sw
operator|->
name|is_leaf
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|" - Routing SECONDARY path for LID %u: %s --> %s\n"
argument_list|,
name|target_lid
argument_list|,
name|tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|tuple_to_str
argument_list|(
name|p_remote_sw
operator|->
name|tuple
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Routing REAL lids on SECONDARY path means routing 		   switch-to-switch or switch-to-CA paths. 		   We can safely assume that switch will initiate very 		   few traffic, so there's no point wasting runtime on 		   trying to balance these routes - always pick port 0. */
name|p_min_port
operator|=
name|NULL
expr_stmt|;
name|ports_num
operator|=
operator|(
name|uint16_t
operator|)
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ports_num
condition|;
name|j
operator|++
control|)
block|{
name|cl_ptr_vector_at
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|,
name|j
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_min_port
condition|)
block|{
comment|/* first port that we're checking - use 				   it as a port with the lowest load */
name|p_min_port
operator|=
name|p_port
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_port
operator|->
name|counter_down
operator|<
name|p_min_port
operator|->
name|counter_down
condition|)
block|{
comment|/* this port is less loaded - use it as min */
name|p_min_port
operator|=
name|p_port
expr_stmt|;
block|}
block|}
name|p_port
operator|=
name|p_min_port
expr_stmt|;
name|p_remote_sw
operator|->
name|p_osm_sw
operator|->
name|new_lft
index|[
name|target_lid
index|]
operator|=
name|p_port
operator|->
name|remote_port_num
expr_stmt|;
comment|/* On the remote switch that is pointed by the p_group, 		   set hops for ALL the ports in the remote group. */
name|set_hops_on_remote_sw
argument_list|(
name|p_group
argument_list|,
name|target_lid
argument_list|,
name|current_hops
operator|+
literal|1
argument_list|,
name|is_target_a_sw
argument_list|)
expr_stmt|;
comment|/* Recursion step: 		   Assign downgoing ports by stepping up, starting on REMOTE switch. */
name|routed
operator|=
name|fabric_route_downgoing_by_going_up
argument_list|(
name|p_ftree
argument_list|,
name|p_remote_sw
argument_list|,
comment|/* remote switch - used as a route-downgoing alg. next step point */
name|p_sw
argument_list|,
comment|/* this switch - prev. position switch for the function */
name|target_lid
argument_list|,
comment|/* LID that we're routing to */
name|FALSE
argument_list|,
comment|/* whether this is path to HCA that should by tracked by counters */
name|is_target_a_sw
argument_list|,
comment|/* Whether target lid is a switch or not */
name|reverse_hop_credit
argument_list|,
comment|/* Remaining reverse_hops allowed */
name|reverse_hops
argument_list|,
comment|/* Number of reverse_hops done up to this point */
name|current_hops
operator|+
literal|1
argument_list|)
expr_stmt|;
name|created_route
operator||=
name|routed
expr_stmt|;
if|if
condition|(
name|routed
condition|)
block|{
name|p_min_group
operator|->
name|counter_down
operator|++
expr_stmt|;
name|p_min_port
operator|->
name|counter_down
operator|++
expr_stmt|;
block|}
block|}
comment|/* If we don't have any reverse hop credits, we are done */
if|if
condition|(
name|reverse_hop_credit
operator|==
literal|0
condition|)
return|return
name|created_route
return|;
if|if
condition|(
name|p_sw
operator|->
name|is_leaf
condition|)
return|return
name|created_route
return|;
comment|/* We explore all the down group ports */
comment|/* We try to reverse jump for each of them */
comment|/* They already have a route to us from the upgoing_by_going_down started earlier */
comment|/* This is only so it'll continue exploring up, after this step backwards */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|down_port_groups_num
condition|;
name|i
operator|++
control|)
block|{
name|p_group
operator|=
name|p_sw
operator|->
name|down_port_groups
index|[
name|i
index|]
expr_stmt|;
name|p_remote_sw
operator|=
name|p_group
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
expr_stmt|;
comment|/* Skip this port group unless it points to a switch */
if|if
condition|(
name|p_group
operator|->
name|remote_node_type
operator|!=
name|IB_NODE_TYPE_SWITCH
condition|)
continue|continue;
comment|/* Recursion step: 		   Assign downgoing ports by stepping up, fter doing one step down starting on REMOTE switch. */
name|created_route
operator||=
name|fabric_route_downgoing_by_going_up
argument_list|(
name|p_ftree
argument_list|,
name|p_remote_sw
argument_list|,
comment|/* remote switch - used as a route-downgoing alg. next step point */
name|p_sw
argument_list|,
comment|/* this switch - prev. position switch for the function */
name|target_lid
argument_list|,
comment|/* LID that we're routing to */
name|TRUE
argument_list|,
comment|/* whether this is path to HCA that should by tracked by counters */
name|is_target_a_sw
argument_list|,
comment|/* Whether target lid is a switch or not */
name|reverse_hop_credit
operator|-
literal|1
argument_list|,
comment|/* Remaining reverse_hops allowed */
name|reverse_hops
operator|+
literal|1
argument_list|,
comment|/* Number of reverse_hops done up to this point */
name|current_hops
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|created_route
return|;
block|}
end_function

begin_comment
comment|/* ftree_fabric_route_downgoing_by_going_up() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_comment
comment|/*  * Pseudo code:  *    foreach leaf switch (in indexing order)  *       for each compute node (in indexing order)  *          obtain the LID of the compute node  *          set local LFT(LID) of the port connecting to compute node  *          call assign-down-going-port-by-ascending-up(TRUE,TRUE) on CURRENT switch  *       for each MISSING compute node  *          call assign-down-going-port-by-ascending-up(FALSE,TRUE) on CURRENT switch  */
end_comment

begin_function
specifier|static
name|void
name|fabric_route_to_cns
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_hca_t
modifier|*
name|p_hca
decl_stmt|;
name|ftree_port_group_t
modifier|*
name|p_leaf_port_group
decl_stmt|;
name|ftree_port_group_t
modifier|*
name|p_hca_port_group
decl_stmt|;
name|ftree_port_t
modifier|*
name|p_port
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uint16_t
name|hca_lid
decl_stmt|;
name|unsigned
name|routed_targets_on_leaf
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
comment|/* for each leaf switch (in indexing order) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_ftree
operator|->
name|leaf_switches_num
condition|;
name|i
operator|++
control|)
block|{
name|p_sw
operator|=
name|p_ftree
operator|->
name|leaf_switches
index|[
name|i
index|]
expr_stmt|;
name|routed_targets_on_leaf
operator|=
literal|0
expr_stmt|;
comment|/* for each HCA connected to this switch */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p_sw
operator|->
name|down_port_groups_num
condition|;
name|j
operator|++
control|)
block|{
name|p_leaf_port_group
operator|=
name|p_sw
operator|->
name|down_port_groups
index|[
name|j
index|]
expr_stmt|;
comment|/* work with this port group only if the remote node is CA */
if|if
condition|(
name|p_leaf_port_group
operator|->
name|remote_node_type
operator|!=
name|IB_NODE_TYPE_CA
condition|)
continue|continue;
name|p_hca
operator|=
name|p_leaf_port_group
operator|->
name|remote_hca_or_sw
operator|.
name|p_hca
expr_stmt|;
comment|/* work with this port group only if remote HCA has CNs */
if|if
condition|(
operator|!
name|p_hca
operator|->
name|cn_num
condition|)
continue|continue;
name|p_hca_port_group
operator|=
name|hca_get_port_group_by_lid
argument_list|(
name|p_hca
argument_list|,
name|p_leaf_port_group
operator|->
name|remote_lid
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_hca_port_group
argument_list|)
expr_stmt|;
comment|/* work with this port group only if remote port is CN */
if|if
condition|(
operator|!
name|p_hca_port_group
operator|->
name|is_cn
condition|)
continue|continue;
comment|/* obtain the LID of HCA port */
name|hca_lid
operator|=
name|p_leaf_port_group
operator|->
name|remote_lid
expr_stmt|;
comment|/* set local LFT(LID) to the port that is connected to HCA */
name|cl_ptr_vector_at
argument_list|(
operator|&
name|p_leaf_port_group
operator|->
name|ports
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_port
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|p_osm_sw
operator|->
name|new_lft
index|[
name|hca_lid
index|]
operator|=
name|p_port
operator|->
name|port_num
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Switch %s: set path to CN LID %u through port %u\n"
argument_list|,
name|tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|hca_lid
argument_list|,
name|p_port
operator|->
name|port_num
argument_list|)
expr_stmt|;
comment|/* set local min hop table(LID) to route to the CA */
name|sw_set_hops
argument_list|(
name|p_sw
argument_list|,
name|hca_lid
argument_list|,
name|p_port
operator|->
name|port_num
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Assign downgoing ports by stepping up. 			   Since we're routing here only CNs, we're routing it as REAL 			   LID and updating fat-tree balancing counters. */
name|fabric_route_downgoing_by_going_up
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
argument_list|,
comment|/* local switch - used as a route-downgoing alg. start point */
name|NULL
argument_list|,
comment|/* prev. position switch */
name|hca_lid
argument_list|,
comment|/* LID that we're routing to */
name|TRUE
argument_list|,
comment|/* whether this path to HCA should by tracked by counters */
name|FALSE
argument_list|,
comment|/* whether target lid is a switch or not */
literal|0
argument_list|,
comment|/* Number of reverse hops allowed */
literal|0
argument_list|,
comment|/* Number of reverse hops done yet */
literal|1
argument_list|)
expr_stmt|;
comment|/* Number of hops done yet */
comment|/* count how many real targets have been routed from this leaf switch */
name|routed_targets_on_leaf
operator|++
expr_stmt|;
block|}
comment|/* We're done with the real targets (all CNs) of this leaf switch. 		   Now route the dummy HCAs that are missing or that are non-CNs. 		   When routing to dummy HCAs we don't fill lid matrices. */
if|if
condition|(
name|p_ftree
operator|->
name|max_cn_per_leaf
operator|>
name|routed_targets_on_leaf
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Routing %u dummy CAs\n"
argument_list|,
name|p_ftree
operator|->
name|max_cn_per_leaf
operator|-
name|p_sw
operator|->
name|down_port_groups_num
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p_ftree
operator|->
name|max_cn_per_leaf
operator|-
name|routed_targets_on_leaf
condition|;
name|j
operator|++
control|)
block|{
name|ftree_sw_t
modifier|*
name|p_next_sw
decl_stmt|,
modifier|*
name|p_ftree_sw
decl_stmt|;
name|sw_set_hops
argument_list|(
name|p_sw
argument_list|,
literal|0
argument_list|,
literal|0xFF
argument_list|,
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* assign downgoing ports by stepping up */
name|fabric_route_downgoing_by_going_up
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
argument_list|,
comment|/* local switch - used as a route-downgoing alg. start point */
name|NULL
argument_list|,
comment|/* prev. position switch */
literal|0
argument_list|,
comment|/* LID that we're routing to - ignored for dummy HCA */
name|TRUE
argument_list|,
comment|/* whether this path to HCA should by tracked by counters */
name|FALSE
argument_list|,
comment|/* Whether the target LID is a switch or not */
literal|0
argument_list|,
comment|/* Number of reverse hops allowed */
literal|0
argument_list|,
comment|/* Number of reverse hops done yet */
literal|1
argument_list|)
expr_stmt|;
comment|/* Number of hops done yet */
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
expr_stmt|;
comment|/* need to clean the LID 0 hops for dummy node */
while|while
condition|(
name|p_next_sw
operator|!=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
condition|)
block|{
name|p_ftree_sw
operator|=
name|p_next_sw
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_ftree_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
name|p_ftree_sw
operator|->
name|hops
index|[
literal|0
index|]
operator|=
name|OSM_NO_PATH
expr_stmt|;
name|p_ftree_sw
operator|->
name|p_osm_sw
operator|->
name|new_lft
index|[
literal|0
index|]
operator|=
name|OSM_NO_PATH
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* done going through all the leaf switches */
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* fabric_route_to_cns() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_comment
comment|/*  * Pseudo code:  *    foreach HCA non-CN port in fabric  *       obtain the LID of the HCA port  *       get switch that is connected to this HCA port  *       set switch LFT(LID) to the port connected to the HCA port  *       call assign-down-going-port-by-ascending-up(TRUE,TRUE) on the switch  *  * Routing to these HCAs is routing a REAL hca lid on MAIN path.  * We want to allow load-leveling of the traffic to the non-CNs,  * because such nodes may include IO nodes with heavy usage  *   - we should set fwd tables  *   - we should update port counters  * Routing to non-CNs is done after routing to CNs, so updated port  * counters will not affect CN-to-CN routing.  */
end_comment

begin_function
specifier|static
name|void
name|fabric_route_to_non_cns
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_hca_t
modifier|*
name|p_hca
decl_stmt|;
name|ftree_hca_t
modifier|*
name|p_next_hca
decl_stmt|;
name|ftree_port_t
modifier|*
name|p_hca_port
decl_stmt|;
name|ftree_port_group_t
modifier|*
name|p_hca_port_group
decl_stmt|;
name|uint16_t
name|hca_lid
decl_stmt|;
name|unsigned
name|port_num_on_switch
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|p_next_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_hca
operator|!=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
condition|)
block|{
name|p_hca
operator|=
name|p_next_hca
expr_stmt|;
name|p_next_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_hca
operator|->
name|map_item
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_hca
operator|->
name|up_port_groups_num
condition|;
name|i
operator|++
control|)
block|{
name|p_hca_port_group
operator|=
name|p_hca
operator|->
name|up_port_groups
index|[
name|i
index|]
expr_stmt|;
comment|/* skip this port if it's CN, in which case it has been already routed */
if|if
condition|(
name|p_hca_port_group
operator|->
name|is_cn
condition|)
continue|continue;
comment|/* skip this port if it is not connected to switch */
if|if
condition|(
name|p_hca_port_group
operator|->
name|remote_node_type
operator|!=
name|IB_NODE_TYPE_SWITCH
condition|)
continue|continue;
name|p_sw
operator|=
name|p_hca_port_group
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
expr_stmt|;
name|hca_lid
operator|=
name|p_hca_port_group
operator|->
name|lid
expr_stmt|;
comment|/* set switches  LFT(LID) to the port that is connected to HCA */
name|cl_ptr_vector_at
argument_list|(
operator|&
name|p_hca_port_group
operator|->
name|ports
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_hca_port
argument_list|)
expr_stmt|;
name|port_num_on_switch
operator|=
name|p_hca_port
operator|->
name|remote_port_num
expr_stmt|;
name|p_sw
operator|->
name|p_osm_sw
operator|->
name|new_lft
index|[
name|hca_lid
index|]
operator|=
name|port_num_on_switch
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Switch %s: set path to non-CN HCA LID %u through port %u\n"
argument_list|,
name|tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|hca_lid
argument_list|,
name|port_num_on_switch
argument_list|)
expr_stmt|;
comment|/* set local min hop table(LID) to route to the CA */
name|sw_set_hops
argument_list|(
name|p_sw
argument_list|,
name|hca_lid
argument_list|,
name|port_num_on_switch
argument_list|,
comment|/* port num */
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* hops */
comment|/* Assign downgoing ports by stepping up. 			   We're routing REAL targets. They are not CNs and not included 			   in the leafs array, but we treat them as MAIN path to allow load 			   leveling, which means that the counters will be updated. */
name|fabric_route_downgoing_by_going_up
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
argument_list|,
comment|/* local switch - used as a route-downgoing alg. start point */
name|NULL
argument_list|,
comment|/* prev. position switch */
name|hca_lid
argument_list|,
comment|/* LID that we're routing to */
name|TRUE
argument_list|,
comment|/* whether this path to HCA should by tracked by counters */
name|FALSE
argument_list|,
comment|/* Whether the target LID is a switch or not */
name|p_hca_port_group
operator|->
name|is_io
condition|?
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|max_reverse_hops
else|:
literal|0
argument_list|,
comment|/* Number or reverse hops allowed */
literal|0
argument_list|,
comment|/* Number or reverse hops done yet */
literal|1
argument_list|)
expr_stmt|;
comment|/* Number of hops done yet */
block|}
comment|/* done with all the port groups of this HCA - go to next HCA */
block|}
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* fabric_route_to_non_cns() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_comment
comment|/*  * Pseudo code:  *    foreach switch in fabric  *       obtain its LID  *       set local LFT(LID) to port 0  *       call assign-down-going-port-by-ascending-up(TRUE,FALSE) on CURRENT switch  *  * Routing to switch is similar to routing a REAL hca lid on SECONDARY path:  *   - we should set fwd tables  *   - we should NOT update port counters  */
end_comment

begin_function
specifier|static
name|void
name|fabric_route_to_switches
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_next_sw
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_sw
operator|!=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
condition|)
block|{
name|p_sw
operator|=
name|p_next_sw
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
comment|/* set local LFT(LID) to 0 (route to itself) */
name|p_sw
operator|->
name|p_osm_sw
operator|->
name|new_lft
index|[
name|p_sw
operator|->
name|lid
index|]
operator|=
literal|0
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Switch %s (LID %u): routing switch-to-switch paths\n"
argument_list|,
name|tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|p_sw
operator|->
name|lid
argument_list|)
expr_stmt|;
comment|/* set min hop table of the switch to itself */
name|sw_set_hops
argument_list|(
name|p_sw
argument_list|,
name|p_sw
operator|->
name|lid
argument_list|,
literal|0
argument_list|,
comment|/* port_num */
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* hops     */
name|fabric_route_downgoing_by_going_up
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
argument_list|,
comment|/* local switch - used as a route-downgoing alg. start point */
name|NULL
argument_list|,
comment|/* prev. position switch */
name|p_sw
operator|->
name|lid
argument_list|,
comment|/* LID that we're routing to */
name|FALSE
argument_list|,
comment|/* whether this path to HCA should by tracked by counters */
name|TRUE
argument_list|,
comment|/* Whether the target LID is a switch or not */
literal|0
argument_list|,
comment|/* Number of reverse hops allowed */
literal|0
argument_list|,
comment|/* Number of reverse hops done yet */
literal|0
argument_list|)
expr_stmt|;
comment|/* Number of hops done yet */
block|}
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* fabric_route_to_switches() */
end_comment

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|void
name|fabric_route_roots
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|uint16_t
name|lid
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_leaf_sw
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
comment|/* 	 * We need a switch that will accomodate all the down/up turns in 	 * the fabric. Having these turn in a single place in the fabric 	 * will not create credit loops. 	 * So we need to select this switch. 	 * The idea here is to chose leaf with the highest index. I don't 	 * have any theory to back me up on this. It's just a general thought 	 * that this way the switch that might be a bottleneck for many mcast 	 * groups will be far away from the OpenSM, so it will draw the 	 * multicast traffic away from the SM. 	 */
name|p_leaf_sw
operator|=
name|p_ftree
operator|->
name|leaf_switches
index|[
name|p_ftree
operator|->
name|leaf_switches_num
operator|-
literal|1
index|]
expr_stmt|;
comment|/* 	 * Now go over all the switches in the fabric that 	 * have lower rank, and route the missing LIDs to 	 * the selected leaf switch. 	 * In short, this leaf switch now poses a target 	 * for all those missing LIDs. 	 */
for|for
control|(
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
init|;
name|p_sw
operator|!=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
condition|;
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
control|)
block|{
if|if
condition|(
name|p_sw
operator|->
name|rank
operator|>=
name|p_ftree
operator|->
name|leaf_switch_rank
condition|)
continue|continue;
for|for
control|(
name|lid
operator|=
literal|1
init|;
name|lid
operator|<=
name|p_leaf_sw
operator|->
name|p_osm_sw
operator|->
name|max_lid_ho
condition|;
name|lid
operator|++
control|)
block|{
if|if
condition|(
name|p_sw
operator|->
name|p_osm_sw
operator|->
name|new_lft
index|[
name|lid
index|]
operator|!=
name|OSM_NO_PATH
operator|||
name|p_leaf_sw
operator|->
name|hops
index|[
name|lid
index|]
operator|==
name|OSM_NO_PATH
condition|)
continue|continue;
name|p_port
operator|=
name|osm_get_port_by_lid_ho
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
argument_list|,
name|lid
argument_list|)
expr_stmt|;
comment|/* we're interested only in switches */
if|if
condition|(
operator|!
name|p_port
operator|||
operator|!
name|p_port
operator|->
name|p_node
operator|->
name|sw
condition|)
continue|continue;
comment|/* 			 * the missing LID will be routed through the same 			 * port that routes to the selected leaf switch 			 */
name|port_num
operator|=
name|p_sw
operator|->
name|p_osm_sw
operator|->
name|new_lft
index|[
name|p_leaf_sw
operator|->
name|lid
index|]
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Switch %s: setting path to LID %u "
literal|"through port %u\n"
argument_list|,
name|tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|lid
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
comment|/* set local lft */
name|p_sw
operator|->
name|p_osm_sw
operator|->
name|new_lft
index|[
name|lid
index|]
operator|=
name|port_num
expr_stmt|;
comment|/* 			 * Set local min hop table. 			 * The distance to the target LID is a distance 			 * to the selected leaf switch plus the distance 			 * from the leaf to the target LID. 			 */
name|sw_set_hops
argument_list|(
name|p_sw
argument_list|,
name|lid
argument_list|,
name|port_num
argument_list|,
name|p_sw
operator|->
name|hops
index|[
name|p_leaf_sw
operator|->
name|lid
index|]
operator|+
name|p_leaf_sw
operator|->
name|hops
index|[
name|lid
index|]
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* fabric_route_roots() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|int
name|fabric_populate_nodes
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|osm_node_t
modifier|*
name|p_osm_node
decl_stmt|;
name|osm_node_t
modifier|*
name|p_next_osm_node
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|p_next_osm_node
operator|=
operator|(
name|osm_node_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|node_guid_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_osm_node
operator|!=
operator|(
name|osm_node_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|node_guid_tbl
argument_list|)
condition|)
block|{
name|p_osm_node
operator|=
name|p_next_osm_node
expr_stmt|;
name|p_next_osm_node
operator|=
operator|(
name|osm_node_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_osm_node
operator|->
name|map_item
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|osm_node_get_type
argument_list|(
name|p_osm_node
argument_list|)
condition|)
block|{
case|case
name|IB_NODE_TYPE_CA
case|:
name|fabric_add_hca
argument_list|(
name|p_ftree
argument_list|,
name|p_osm_node
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_NODE_TYPE_ROUTER
case|:
break|break;
case|case
name|IB_NODE_TYPE_SWITCH
case|:
name|fabric_add_sw
argument_list|(
name|p_ftree
argument_list|,
name|p_osm_node
operator|->
name|sw
argument_list|)
expr_stmt|;
break|break;
default|default:
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB0E: "
literal|"Node GUID 0x%016"
name|PRIx64
literal|" - Unknown node type: %s\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_osm_node
argument_list|)
argument_list|)
argument_list|,
name|ib_get_node_type_str
argument_list|(
name|osm_node_get_type
argument_list|(
name|p_osm_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* fabric_populate_nodes() */
end_comment

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|boolean_t
name|sw_update_rank
parameter_list|(
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|uint32_t
name|new_rank
parameter_list|)
block|{
if|if
condition|(
name|sw_ranked
argument_list|(
name|p_sw
argument_list|)
operator|&&
name|p_sw
operator|->
name|rank
operator|<=
name|new_rank
condition|)
return|return
name|FALSE
return|;
name|p_sw
operator|->
name|rank
operator|=
name|new_rank
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|rank_switches_from_leafs
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|cl_list_t
modifier|*
name|p_ranking_bfs_list
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_remote_sw
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|osm_node_t
modifier|*
name|p_remote_node
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_osm_port
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|unsigned
name|max_rank
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|cl_is_list_empty
argument_list|(
name|p_ranking_bfs_list
argument_list|)
condition|)
block|{
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_list_remove_head
argument_list|(
name|p_ranking_bfs_list
argument_list|)
expr_stmt|;
name|p_node
operator|=
name|p_sw
operator|->
name|p_osm_sw
operator|->
name|p_node
expr_stmt|;
comment|/* note: skipping port 0 on switches */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|osm_node_get_num_physp
argument_list|(
name|p_node
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|p_osm_port
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_osm_port
operator|||
operator|!
name|osm_link_is_healthy
argument_list|(
name|p_osm_port
argument_list|)
condition|)
continue|continue;
name|p_remote_node
operator|=
name|osm_node_get_remote_node
argument_list|(
name|p_node
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_remote_node
condition|)
continue|continue;
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|p_remote_node
argument_list|)
operator|!=
name|IB_NODE_TYPE_SWITCH
condition|)
continue|continue;
name|p_remote_sw
operator|=
name|fabric_get_sw_by_guid
argument_list|(
name|p_ftree
argument_list|,
name|osm_node_get_node_guid
argument_list|(
name|p_remote_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_remote_sw
condition|)
block|{
comment|/* remote node is not a switch */
continue|continue;
block|}
comment|/* if needed, rank the remote switch and add it to the BFS list */
if|if
condition|(
name|sw_update_rank
argument_list|(
name|p_remote_sw
argument_list|,
name|p_sw
operator|->
name|rank
operator|+
literal|1
argument_list|)
condition|)
block|{
name|max_rank
operator|=
name|p_remote_sw
operator|->
name|rank
expr_stmt|;
name|cl_list_insert_tail
argument_list|(
name|p_ranking_bfs_list
argument_list|,
name|p_remote_sw
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* set FatTree maximal switch rank */
name|p_ftree
operator|->
name|max_switch_rank
operator|=
name|max_rank
expr_stmt|;
block|}
end_function

begin_comment
comment|/* rank_switches_from_leafs() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|int
name|rank_leaf_switches
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_hca_t
modifier|*
name|p_hca
parameter_list|,
name|IN
name|cl_list_t
modifier|*
name|p_ranking_bfs_list
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|osm_node_t
modifier|*
name|p_osm_node
init|=
name|p_hca
operator|->
name|p_osm_node
decl_stmt|;
name|osm_node_t
modifier|*
name|p_remote_osm_node
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_osm_port
decl_stmt|;
specifier|static
name|uint8_t
name|i
init|=
literal|0
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|osm_node_get_num_physp
argument_list|(
name|p_osm_node
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|p_osm_port
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_osm_node
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_osm_port
operator|||
operator|!
name|osm_link_is_healthy
argument_list|(
name|p_osm_port
argument_list|)
condition|)
continue|continue;
name|p_remote_osm_node
operator|=
name|osm_node_get_remote_node
argument_list|(
name|p_osm_node
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_remote_osm_node
condition|)
continue|continue;
switch|switch
condition|(
name|osm_node_get_type
argument_list|(
name|p_remote_osm_node
argument_list|)
condition|)
block|{
case|case
name|IB_NODE_TYPE_CA
case|:
comment|/* HCA connected directly to another HCA - not FatTree */
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB0F: "
literal|"CA conected directly to another CA: "
literal|"0x%016"
name|PRIx64
literal|"<---> 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|hca_get_guid_ho
argument_list|(
name|p_hca
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_remote_osm_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
case|case
name|IB_NODE_TYPE_ROUTER
case|:
comment|/* leaving this port - proceeding to the next one */
continue|continue;
case|case
name|IB_NODE_TYPE_SWITCH
case|:
comment|/* continue with this port */
break|break;
default|default:
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB10: Node GUID 0x%016"
name|PRIx64
literal|" - Unknown node type: %s\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_remote_osm_node
argument_list|)
argument_list|)
argument_list|,
name|ib_get_node_type_str
argument_list|(
name|osm_node_get_type
argument_list|(
name|p_remote_osm_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* remote node is switch */
name|p_sw
operator|=
name|fabric_get_sw_by_guid
argument_list|(
name|p_ftree
argument_list|,
name|osm_node_get_node_guid
argument_list|(
name|p_osm_port
operator|->
name|p_remote_physp
operator|->
name|p_node
argument_list|)
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
comment|/* if needed, rank the remote switch and add it to the BFS list */
if|if
condition|(
operator|!
name|sw_update_rank
argument_list|(
name|p_sw
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Marking rank of switch that is directly connected to CA:\n"
literal|"                                            - CA guid    : 0x%016"
name|PRIx64
literal|"\n"
literal|"                                            - Switch guid: 0x%016"
name|PRIx64
literal|"\n"
literal|"                                            - Switch LID : %u\n"
argument_list|,
name|hca_get_guid_ho
argument_list|(
name|p_hca
argument_list|)
argument_list|,
name|sw_get_guid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|,
name|p_sw
operator|->
name|lid
argument_list|)
expr_stmt|;
name|cl_list_insert_tail
argument_list|(
name|p_ranking_bfs_list
argument_list|,
name|p_sw
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* rank_leaf_switches() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|sw_reverse_rank
parameter_list|(
name|IN
name|cl_map_item_t
modifier|*
specifier|const
name|p_map_item
parameter_list|,
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
name|ftree_fabric_t
modifier|*
name|p_ftree
init|=
operator|(
name|ftree_fabric_t
operator|*
operator|)
name|context
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_sw
init|=
operator|(
name|ftree_sw_t
operator|*
specifier|const
operator|)
name|p_map_item
decl_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|rank
operator|!=
literal|0xFFFFFFFF
condition|)
name|p_sw
operator|->
name|rank
operator|=
name|p_ftree
operator|->
name|max_switch_rank
operator|-
name|p_sw
operator|->
name|rank
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|int
name|fabric_construct_hca_ports
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_hca_t
modifier|*
name|p_hca
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_remote_sw
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
init|=
name|p_hca
operator|->
name|p_osm_node
decl_stmt|;
name|osm_node_t
modifier|*
name|p_remote_node
decl_stmt|;
name|uint8_t
name|remote_node_type
decl_stmt|;
name|ib_net64_t
name|remote_node_guid
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_remote_osm_port
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|uint8_t
name|remote_port_num
decl_stmt|;
name|boolean_t
name|is_cn
decl_stmt|;
name|boolean_t
name|is_in_cn_file
decl_stmt|;
name|boolean_t
name|is_io
decl_stmt|;
name|boolean_t
name|is_cns_file_provided
init|=
name|fabric_cns_provided
argument_list|(
name|p_ftree
argument_list|)
decl_stmt|;
name|boolean_t
name|is_ios_file_provided
init|=
name|fabric_ios_provided
argument_list|(
name|p_ftree
argument_list|)
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|osm_node_get_num_physp
argument_list|(
name|p_node
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|osm_physp_t
modifier|*
name|p_osm_port
init|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|is_io
operator|=
name|FALSE
expr_stmt|;
name|is_cn
operator|=
name|TRUE
expr_stmt|;
name|is_in_cn_file
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|p_osm_port
operator|||
operator|!
name|osm_link_is_healthy
argument_list|(
name|p_osm_port
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|p_hca
operator|->
name|disconnected_ports
index|[
name|i
index|]
condition|)
continue|continue;
name|p_remote_osm_port
operator|=
name|osm_physp_get_remote
argument_list|(
name|p_osm_port
argument_list|)
expr_stmt|;
name|p_remote_node
operator|=
name|osm_node_get_remote_node
argument_list|(
name|p_node
argument_list|,
name|i
argument_list|,
operator|&
name|remote_port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_remote_osm_port
operator|||
operator|!
name|p_remote_node
condition|)
continue|continue;
name|remote_node_type
operator|=
name|osm_node_get_type
argument_list|(
name|p_remote_node
argument_list|)
expr_stmt|;
name|remote_node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_remote_node
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|remote_node_type
condition|)
block|{
case|case
name|IB_NODE_TYPE_ROUTER
case|:
comment|/* leaving this port - proceeding to the next one */
continue|continue;
case|case
name|IB_NODE_TYPE_CA
case|:
comment|/* HCA connected directly to another HCA - not FatTree */
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB11: "
literal|"CA conected directly to another CA: "
literal|"0x%016"
name|PRIx64
literal|"<---> 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|remote_node_guid
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
case|case
name|IB_NODE_TYPE_SWITCH
case|:
comment|/* continue with this port */
break|break;
default|default:
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB12: Node GUID 0x%016"
name|PRIx64
literal|" - Unknown node type: %s\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|remote_node_guid
argument_list|)
argument_list|,
name|ib_get_node_type_str
argument_list|(
name|remote_node_type
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* remote node is switch */
name|p_remote_sw
operator|=
name|fabric_get_sw_by_guid
argument_list|(
name|p_ftree
argument_list|,
name|remote_node_guid
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_remote_sw
argument_list|)
expr_stmt|;
comment|/* If CN file is not supplied, then all the CAs considered as Compute Nodes. 		   Otherwise all the CAs are not CNs, and only guids that are present in the 		   CN file will be marked as compute nodes. */
if|if
condition|(
name|is_cns_file_provided
operator|==
name|TRUE
condition|)
block|{
name|name_map_item_t
modifier|*
name|p_elem
init|=
operator|(
name|name_map_item_t
operator|*
operator|)
name|cl_qmap_get
argument_list|(
operator|&
name|p_ftree
operator|->
name|cn_guid_tbl
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_osm_port
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|p_elem
operator|==
operator|(
name|name_map_item_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|cn_guid_tbl
argument_list|)
condition|)
name|is_cn
operator|=
name|FALSE
expr_stmt|;
else|else
name|is_in_cn_file
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|is_in_cn_file
operator|==
name|FALSE
operator|&&
name|is_ios_file_provided
operator|==
name|TRUE
condition|)
block|{
name|name_map_item_t
modifier|*
name|p_elem
init|=
operator|(
name|name_map_item_t
operator|*
operator|)
name|cl_qmap_get
argument_list|(
operator|&
name|p_ftree
operator|->
name|io_guid_tbl
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_osm_port
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|p_elem
operator|!=
operator|(
name|name_map_item_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|io_guid_tbl
argument_list|)
condition|)
block|{
name|is_io
operator|=
name|TRUE
expr_stmt|;
name|is_cn
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|is_cn
condition|)
block|{
name|p_ftree
operator|->
name|cn_num
operator|++
expr_stmt|;
name|p_hca
operator|->
name|cn_num
operator|++
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Marking CN port GUID 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_osm_port
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_io
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Marking I/O port GUID 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_osm_port
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Marking non-CN port GUID 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_osm_port
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|p_ftree
operator|->
name|ca_ports
operator|++
expr_stmt|;
name|hca_add_port
argument_list|(
name|p_ftree
argument_list|,
name|p_hca
argument_list|,
comment|/* local ftree_hca object */
name|i
argument_list|,
comment|/* local port number */
name|remote_port_num
argument_list|,
comment|/* remote port number */
name|cl_ntoh16
argument_list|(
name|osm_node_get_base_lid
argument_list|(
name|p_node
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
comment|/* local lid */
name|cl_ntoh16
argument_list|(
name|osm_node_get_base_lid
argument_list|(
name|p_remote_node
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
comment|/* remote lid */
name|osm_physp_get_port_guid
argument_list|(
name|p_osm_port
argument_list|)
argument_list|,
comment|/* local port guid */
name|osm_physp_get_port_guid
argument_list|(
name|p_remote_osm_port
argument_list|)
argument_list|,
comment|/* remote port guid */
name|remote_node_guid
argument_list|,
comment|/* remote node guid */
name|remote_node_type
argument_list|,
comment|/* remote node type */
operator|(
name|void
operator|*
operator|)
name|p_remote_sw
argument_list|,
comment|/* remote ftree_hca/sw object */
name|is_cn
argument_list|,
name|is_io
argument_list|)
expr_stmt|;
comment|/* whether this port is compute node */
block|}
name|Exit
label|:
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* fabric_construct_hca_ports() */
end_comment

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|int
name|fabric_construct_sw_ports
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|)
block|{
name|ftree_hca_t
modifier|*
name|p_remote_hca
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_remote_sw
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
init|=
name|p_sw
operator|->
name|p_osm_sw
operator|->
name|p_node
decl_stmt|;
name|osm_node_t
modifier|*
name|p_remote_node
decl_stmt|;
name|uint16_t
name|remote_lid
decl_stmt|;
name|uint8_t
name|remote_node_type
decl_stmt|;
name|ib_net64_t
name|remote_node_guid
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_remote_osm_port
decl_stmt|;
name|ftree_direction_t
name|direction
decl_stmt|;
name|void
modifier|*
name|p_remote_hca_or_sw
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|uint8_t
name|remote_port_num
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|osm_node_get_type
argument_list|(
name|p_node
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|osm_node_get_num_physp
argument_list|(
name|p_node
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|osm_physp_t
modifier|*
name|p_osm_port
init|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p_osm_port
operator|||
operator|!
name|osm_link_is_healthy
argument_list|(
name|p_osm_port
argument_list|)
condition|)
continue|continue;
name|p_remote_osm_port
operator|=
name|osm_physp_get_remote
argument_list|(
name|p_osm_port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_remote_osm_port
condition|)
continue|continue;
name|p_remote_node
operator|=
name|osm_node_get_remote_node
argument_list|(
name|p_node
argument_list|,
name|i
argument_list|,
operator|&
name|remote_port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_remote_node
condition|)
continue|continue;
comment|/* ignore any loopback connection on switch */
if|if
condition|(
name|p_node
operator|==
name|p_remote_node
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Ignoring loopback on switch GUID 0x%016"
name|PRIx64
literal|", LID %u, rank %u\n"
argument_list|,
name|sw_get_guid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|,
name|p_sw
operator|->
name|lid
argument_list|,
name|p_sw
operator|->
name|rank
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|remote_node_type
operator|=
name|osm_node_get_type
argument_list|(
name|p_remote_node
argument_list|)
expr_stmt|;
name|remote_node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_remote_node
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|remote_node_type
condition|)
block|{
case|case
name|IB_NODE_TYPE_ROUTER
case|:
comment|/* leaving this port - proceeding to the next one */
continue|continue;
case|case
name|IB_NODE_TYPE_CA
case|:
comment|/* switch connected to hca */
name|p_remote_hca
operator|=
name|fabric_get_hca_by_guid
argument_list|(
name|p_ftree
argument_list|,
name|remote_node_guid
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_remote_hca
argument_list|)
expr_stmt|;
name|p_remote_hca_or_sw
operator|=
operator|(
name|void
operator|*
operator|)
name|p_remote_hca
expr_stmt|;
name|direction
operator|=
name|FTREE_DIRECTION_DOWN
expr_stmt|;
name|remote_lid
operator|=
name|cl_ntoh16
argument_list|(
name|osm_physp_get_base_lid
argument_list|(
name|p_remote_osm_port
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_NODE_TYPE_SWITCH
case|:
comment|/* switch connected to another switch */
name|p_remote_sw
operator|=
name|fabric_get_sw_by_guid
argument_list|(
name|p_ftree
argument_list|,
name|remote_node_guid
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_remote_sw
argument_list|)
expr_stmt|;
name|p_remote_hca_or_sw
operator|=
operator|(
name|void
operator|*
operator|)
name|p_remote_sw
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|rank
operator|>
name|p_remote_sw
operator|->
name|rank
condition|)
block|{
name|direction
operator|=
name|FTREE_DIRECTION_UP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_sw
operator|->
name|rank
operator|==
name|p_remote_sw
operator|->
name|rank
condition|)
block|{
name|direction
operator|=
name|FTREE_DIRECTION_SAME
expr_stmt|;
block|}
else|else
name|direction
operator|=
name|FTREE_DIRECTION_DOWN
expr_stmt|;
comment|/* switch LID is only in port 0 port_info structure */
name|remote_lid
operator|=
name|cl_ntoh16
argument_list|(
name|osm_node_get_base_lid
argument_list|(
name|p_remote_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB13: Node GUID 0x%016"
name|PRIx64
literal|" - Unknown node type: %s\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|remote_node_guid
argument_list|)
argument_list|,
name|ib_get_node_type_str
argument_list|(
name|remote_node_type
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|sw_add_port
argument_list|(
name|p_sw
argument_list|,
comment|/* local ftree_sw object */
name|i
argument_list|,
comment|/* local port number */
name|remote_port_num
argument_list|,
comment|/* remote port number */
name|p_sw
operator|->
name|lid
argument_list|,
comment|/* local lid */
name|remote_lid
argument_list|,
comment|/* remote lid */
name|osm_physp_get_port_guid
argument_list|(
name|p_osm_port
argument_list|)
argument_list|,
comment|/* local port guid */
name|osm_physp_get_port_guid
argument_list|(
name|p_remote_osm_port
argument_list|)
argument_list|,
comment|/* remote port guid */
name|remote_node_guid
argument_list|,
comment|/* remote node guid */
name|remote_node_type
argument_list|,
comment|/* remote node type */
name|p_remote_hca_or_sw
argument_list|,
comment|/* remote ftree_hca/sw object */
name|direction
argument_list|)
expr_stmt|;
comment|/* port direction (up or down) */
comment|/* Track the max lid (in host order) that exists in the fabric */
if|if
condition|(
name|remote_lid
operator|>
name|p_ftree
operator|->
name|lft_max_lid
condition|)
name|p_ftree
operator|->
name|lft_max_lid
operator|=
name|remote_lid
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* fabric_construct_sw_ports() */
end_comment

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_struct
struct|struct
name|rank_root_cxt
block|{
name|ftree_fabric_t
modifier|*
name|fabric
decl_stmt|;
name|cl_list_t
modifier|*
name|list
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|int
name|rank_root_sw_by_guid
parameter_list|(
name|void
modifier|*
name|cxt
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|rank_root_cxt
modifier|*
name|c
init|=
name|cxt
decl_stmt|;
name|ftree_sw_t
modifier|*
name|sw
decl_stmt|;
name|sw
operator|=
name|fabric_get_sw_by_guid
argument_list|(
name|c
operator|->
name|fabric
argument_list|,
name|cl_hton64
argument_list|(
name|guid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sw
condition|)
block|{
comment|/* the specified root guid wasn't found in the fabric */
name|OSM_LOG
argument_list|(
operator|&
name|c
operator|->
name|fabric
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB24: "
literal|"Root switch GUID 0x%"
name|PRIx64
literal|" not found\n"
argument_list|,
name|guid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|OSM_LOG
argument_list|(
operator|&
name|c
operator|->
name|fabric
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Ranking root switch with GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|guid
argument_list|)
expr_stmt|;
name|sw
operator|->
name|rank
operator|=
literal|0
expr_stmt|;
name|cl_list_insert_tail
argument_list|(
name|c
operator|->
name|list
argument_list|,
name|sw
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|boolean_t
name|fabric_load_roots
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|cl_list_t
modifier|*
name|p_ranking_bfs_list
parameter_list|)
block|{
name|struct
name|rank_root_cxt
name|context
decl_stmt|;
name|unsigned
name|num_roots
decl_stmt|;
if|if
condition|(
name|p_ranking_bfs_list
condition|)
block|{
comment|/* Rank all the roots and add them to list */
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Fetching root nodes from file %s\n"
argument_list|,
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|root_guid_file
argument_list|)
expr_stmt|;
name|context
operator|.
name|fabric
operator|=
name|p_ftree
expr_stmt|;
name|context
operator|.
name|list
operator|=
name|p_ranking_bfs_list
expr_stmt|;
if|if
condition|(
name|parse_node_map
argument_list|(
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|root_guid_file
argument_list|,
name|rank_root_sw_by_guid
argument_list|,
operator|&
name|context
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB2A: "
literal|"cannot parse root guids file \'%s\'\n"
argument_list|,
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|root_guid_file
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|num_roots
operator|=
name|cl_list_count
argument_list|(
name|p_ranking_bfs_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num_roots
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB25: "
literal|"No valid roots supplied\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Ranked %u valid root switches\n"
argument_list|,
name|num_roots
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|int
name|fabric_rank_from_roots
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|cl_list_t
modifier|*
name|p_ranking_bfs_list
parameter_list|)
block|{
name|osm_node_t
modifier|*
name|p_osm_node
decl_stmt|;
name|osm_node_t
modifier|*
name|p_remote_osm_node
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_osm_physp
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_remote_sw
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
name|unsigned
name|max_rank
init|=
literal|0
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ranking_bfs_list
condition|)
block|{
name|res
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
while|while
condition|(
operator|!
name|cl_is_list_empty
argument_list|(
name|p_ranking_bfs_list
argument_list|)
condition|)
block|{
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_list_remove_head
argument_list|(
name|p_ranking_bfs_list
argument_list|)
expr_stmt|;
name|p_osm_node
operator|=
name|p_sw
operator|->
name|p_osm_sw
operator|->
name|p_node
expr_stmt|;
comment|/* note: skipping port 0 on switches */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|osm_node_get_num_physp
argument_list|(
name|p_osm_node
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|p_osm_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_osm_node
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_osm_physp
operator|||
operator|!
name|osm_link_is_healthy
argument_list|(
name|p_osm_physp
argument_list|)
condition|)
continue|continue;
name|p_remote_osm_node
operator|=
name|osm_node_get_remote_node
argument_list|(
name|p_osm_node
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_remote_osm_node
condition|)
continue|continue;
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|p_remote_osm_node
argument_list|)
operator|!=
name|IB_NODE_TYPE_SWITCH
condition|)
continue|continue;
name|p_remote_sw
operator|=
name|fabric_get_sw_by_guid
argument_list|(
name|p_ftree
argument_list|,
name|osm_node_get_node_guid
argument_list|(
name|p_remote_osm_node
argument_list|)
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_remote_sw
argument_list|)
expr_stmt|;
comment|/* if needed, rank the remote switch and add it to the BFS list */
if|if
condition|(
name|sw_update_rank
argument_list|(
name|p_remote_sw
argument_list|,
name|p_sw
operator|->
name|rank
operator|+
literal|1
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Ranking switch 0x%"
name|PRIx64
literal|" with rank %u\n"
argument_list|,
name|sw_get_guid_ho
argument_list|(
name|p_remote_sw
argument_list|)
argument_list|,
name|p_remote_sw
operator|->
name|rank
argument_list|)
expr_stmt|;
name|max_rank
operator|=
name|p_remote_sw
operator|->
name|rank
expr_stmt|;
name|cl_list_insert_tail
argument_list|(
name|p_ranking_bfs_list
argument_list|,
name|p_remote_sw
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* done with ports of this switch - go to the next switch in the list */
block|}
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Subnet ranking completed. Max Node Rank = %u\n"
argument_list|,
name|max_rank
argument_list|)
expr_stmt|;
comment|/* set FatTree maximal switch rank */
name|p_ftree
operator|->
name|max_switch_rank
operator|=
name|max_rank
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* fabric_rank_from_roots() */
end_comment

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|int
name|fabric_rank_from_hcas
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|ftree_hca_t
modifier|*
name|p_hca
decl_stmt|;
name|ftree_hca_t
modifier|*
name|p_next_hca
decl_stmt|;
name|cl_list_t
name|ranking_bfs_list
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|cl_list_init
argument_list|(
operator|&
name|ranking_bfs_list
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Mark REVERSED rank of all the switches in the subnet. 	   Start from switches that are connected to hca's, and 	   scan all the switches in the subnet. */
name|p_next_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_hca
operator|!=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
condition|)
block|{
name|p_hca
operator|=
name|p_next_hca
expr_stmt|;
name|p_next_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_hca
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|rank_leaf_switches
argument_list|(
name|p_ftree
argument_list|,
name|p_hca
argument_list|,
operator|&
name|ranking_bfs_list
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|res
operator|=
operator|-
literal|1
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB14: "
literal|"Subnet ranking failed - subnet is not FatTree"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/* Now rank rest of the switches in the fabric, while the 	   list already contains all the ranked leaf switches */
name|rank_switches_from_leafs
argument_list|(
name|p_ftree
argument_list|,
operator|&
name|ranking_bfs_list
argument_list|)
expr_stmt|;
comment|/* fix ranking of the switches by reversing the ranking direction */
name|cl_qmap_apply_func
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|,
name|sw_reverse_rank
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p_ftree
argument_list|)
expr_stmt|;
name|Exit
label|:
name|cl_list_destroy
argument_list|(
operator|&
name|ranking_bfs_list
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* fabric_rank_from_hcas() */
end_comment

begin_comment
comment|/***************************************************  * After ranking from HCA's we want to re-rank using  * the roots  ***************************************************/
end_comment

begin_function
specifier|static
name|int
name|fabric_rerank_using_root
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|cl_list_t
modifier|*
name|p_ranking_bfs_list
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
init|=
name|NULL
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_next_sw
decl_stmt|;
name|int
name|res
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_sw
operator|!=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
condition|)
block|{
name|p_sw
operator|=
name|p_next_sw
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|rank
operator|==
literal|0
condition|)
name|cl_list_insert_tail
argument_list|(
name|p_ranking_bfs_list
argument_list|,
name|p_sw
argument_list|)
expr_stmt|;
else|else
name|p_sw
operator|->
name|rank
operator|=
literal|0xFFFFFFFF
expr_stmt|;
block|}
name|res
operator|=
name|fabric_rank_from_roots
argument_list|(
name|p_ftree
argument_list|,
name|p_ranking_bfs_list
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|int
name|fabric_rank
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
name|cl_list_t
name|ranking_bfs_list
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|cl_list_init
argument_list|(
operator|&
name|ranking_bfs_list
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|fabric_roots_provided
argument_list|(
name|p_ftree
argument_list|)
operator|&&
name|fabric_load_roots
argument_list|(
name|p_ftree
argument_list|,
operator|&
name|ranking_bfs_list
argument_list|)
condition|)
name|res
operator|=
name|fabric_rank_from_roots
argument_list|(
name|p_ftree
argument_list|,
operator|&
name|ranking_bfs_list
argument_list|)
expr_stmt|;
else|else
block|{
name|res
operator|=
name|fabric_rank_from_hcas
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|res
condition|)
name|res
operator|=
name|fabric_rerank_using_root
argument_list|(
name|p_ftree
argument_list|,
operator|&
name|ranking_bfs_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
condition|)
goto|goto
name|Exit
goto|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"FatTree max switch rank is %u\n"
argument_list|,
name|p_ftree
operator|->
name|max_switch_rank
argument_list|)
expr_stmt|;
name|Exit
label|:
name|cl_list_destroy
argument_list|(
operator|&
name|ranking_bfs_list
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* fabric_rank() */
end_comment

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|void
name|fabric_set_leaf_rank
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_hca_t
modifier|*
name|p_hca
init|=
name|NULL
decl_stmt|;
name|ftree_hca_t
modifier|*
name|p_next_hca
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fabric_roots_provided
argument_list|(
name|p_ftree
argument_list|)
condition|)
block|{
comment|/* If root file is not provided, the fabric has to be pure fat-tree 		   in terms of ranking. Thus, leaf switches rank is the max rank. */
name|p_ftree
operator|->
name|leaf_switch_rank
operator|=
name|p_ftree
operator|->
name|max_switch_rank
expr_stmt|;
block|}
else|else
block|{
comment|/* Find the first CN and set the leaf_switch_rank to the rank 		   of the switch that is connected to this CN. Later we will 		   ensure that all the leaf switches have the same rank. */
name|p_next_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_hca
operator|!=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
condition|)
block|{
name|p_hca
operator|=
name|p_next_hca
expr_stmt|;
if|if
condition|(
name|p_hca
operator|->
name|cn_num
condition|)
break|break;
name|p_next_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_hca
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
comment|/* we know that there are CNs in the fabric, so just to be sure... */
name|CL_ASSERT
argument_list|(
name|p_next_hca
operator|!=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Selected CN port GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|hca_get_guid_ho
argument_list|(
name|p_hca
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|p_hca
operator|->
name|up_port_groups_num
operator|)
operator|&&
operator|(
operator|!
name|p_hca
operator|->
name|up_port_groups
index|[
name|i
index|]
operator|->
name|is_cn
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|CL_ASSERT
argument_list|(
name|i
operator|<
name|p_hca
operator|->
name|up_port_groups_num
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_hca
operator|->
name|up_port_groups
index|[
name|i
index|]
operator|->
name|remote_node_type
operator|==
name|IB_NODE_TYPE_SWITCH
argument_list|)
expr_stmt|;
name|p_sw
operator|=
name|p_hca
operator|->
name|up_port_groups
index|[
name|i
index|]
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Selected leaf switch GUID 0x%"
name|PRIx64
literal|", rank %u\n"
argument_list|,
name|sw_get_guid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|,
name|p_sw
operator|->
name|rank
argument_list|)
expr_stmt|;
name|p_ftree
operator|->
name|leaf_switch_rank
operator|=
name|p_sw
operator|->
name|rank
expr_stmt|;
block|}
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"FatTree leaf switch rank is %u\n"
argument_list|,
name|p_ftree
operator|->
name|leaf_switch_rank
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* fabric_set_leaf_rank() */
end_comment

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|int
name|fabric_populate_ports
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|ftree_hca_t
modifier|*
name|p_hca
decl_stmt|;
name|ftree_hca_t
modifier|*
name|p_next_hca
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_next_sw
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|p_next_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_hca
operator|!=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
condition|)
block|{
name|p_hca
operator|=
name|p_next_hca
expr_stmt|;
name|p_next_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_hca
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|fabric_construct_hca_ports
argument_list|(
name|p_ftree
argument_list|,
name|p_hca
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|res
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_sw
operator|!=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
condition|)
block|{
name|p_sw
operator|=
name|p_next_sw
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|fabric_construct_sw_ports
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|res
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* fabric_populate_ports() */
end_comment

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|int
name|add_guid_item_to_map
parameter_list|(
name|void
modifier|*
name|cxt
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
name|cl_qmap_t
modifier|*
name|map
init|=
name|cxt
decl_stmt|;
name|name_map_item_t
modifier|*
name|item
decl_stmt|;
name|name_map_item_t
modifier|*
name|inserted_item
decl_stmt|;
name|item
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
return|return
operator|-
literal|1
return|;
name|item
operator|->
name|guid
operator|=
name|guid
expr_stmt|;
name|inserted_item
operator|=
operator|(
name|name_map_item_t
operator|*
operator|)
name|cl_qmap_insert
argument_list|(
name|map
argument_list|,
name|guid
argument_list|,
operator|&
name|item
operator|->
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|inserted_item
operator|!=
name|item
condition|)
name|free
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fabric_read_guid_files
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|int
name|status
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|fabric_cns_provided
argument_list|(
name|p_ftree
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Fetching compute nodes from file %s\n"
argument_list|,
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|cn_guid_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_node_map
argument_list|(
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|cn_guid_file
argument_list|,
name|add_guid_item_to_map
argument_list|,
operator|&
name|p_ftree
operator|->
name|cn_guid_tbl
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB23: "
literal|"Problem parsing CN guid file\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|!
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|cn_guid_tbl
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB27: "
literal|"Compute node guids file has no valid guids\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
if|if
condition|(
name|fabric_ios_provided
argument_list|(
name|p_ftree
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Fetching I/O nodes from file %s\n"
argument_list|,
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|io_guid_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_node_map
argument_list|(
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|io_guid_file
argument_list|,
name|add_guid_item_to_map
argument_list|,
operator|&
name|p_ftree
operator|->
name|io_guid_tbl
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB28: Problem parsing I/O guid file\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|!
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|io_guid_tbl
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB29: "
literal|"I/O node guids file has no valid guids\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*fabric_read_guid_files() */
end_comment

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_comment
comment|/* Get a Sw and remove all depended HCA's, meaning all  * HCA's which this is the only switch they are connected  * to	*/
end_comment

begin_function
specifier|static
name|int
name|remove_depended_hca
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|)
block|{
name|ftree_hca_t
modifier|*
name|p_hca
decl_stmt|;
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|int
name|port_num
decl_stmt|;
name|uint8_t
name|remote_port_num
decl_stmt|;
name|osm_physp_t
modifier|*
name|physp
decl_stmt|;
name|osm_node_t
modifier|*
name|sw_node
decl_stmt|;
name|uint64_t
name|remote_hca_guid
decl_stmt|;
name|sw_node
operator|=
name|p_sw
operator|->
name|p_osm_sw
operator|->
name|p_node
expr_stmt|;
for|for
control|(
name|port_num
operator|=
literal|0
init|;
name|port_num
operator|<
name|sw_node
operator|->
name|physp_tbl_size
condition|;
name|port_num
operator|++
control|)
block|{
name|physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|sw_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|physp
operator|&&
name|physp
operator|->
name|p_remote_physp
condition|)
block|{
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|physp
operator|->
name|p_remote_physp
operator|->
name|p_node
argument_list|)
operator|==
name|IB_NODE_TYPE_CA
condition|)
block|{
name|remote_hca_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|physp
operator|->
name|p_remote_physp
operator|->
name|p_node
argument_list|)
expr_stmt|;
name|p_hca
operator|=
name|fabric_get_hca_by_guid
argument_list|(
name|p_ftree
argument_list|,
name|remote_hca_guid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_hca
condition|)
continue|continue;
name|remote_port_num
operator|=
name|osm_physp_get_port_num
argument_list|(
name|physp
operator|->
name|p_remote_physp
argument_list|)
expr_stmt|;
name|p_hca
operator|->
name|disconnected_ports
index|[
name|remote_port_num
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
return|return
name|counter
return|;
block|}
end_function

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|void
name|fabric_remove_unranked_sw
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
init|=
name|NULL
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_next_sw
decl_stmt|;
name|int
name|removed_hca
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_sw
operator|!=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
condition|)
block|{
name|p_sw
operator|=
name|p_next_sw
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sw_ranked
argument_list|(
name|p_sw
argument_list|)
condition|)
block|{
name|cl_qmap_remove_item
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|,
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
name|removed_hca
operator|=
name|remove_depended_hca
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Removing Unranked sw 0x%"
name|PRIx64
literal|" (with %d dependent hca's)\n"
argument_list|,
name|sw_get_guid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|,
name|removed_hca
argument_list|)
expr_stmt|;
name|sw_destroy
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Removed %d invalid switches\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|int
name|construct_fabric
parameter_list|(
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
name|ftree_fabric_t
modifier|*
name|p_ftree
init|=
name|context
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|fabric_clear
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|lmc
operator|>
literal|0
condition|)
block|{
name|osm_log_v2
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
name|FILE_ID
argument_list|,
literal|"LMC> 0 is not supported by fat-tree routing.\n"
literal|"Falling back to default routing\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
operator|<
literal|2
condition|)
block|{
name|osm_log_v2
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
name|FILE_ID
argument_list|,
literal|"Fabric has %u switches - topology is not fat-tree.\n"
literal|"Falling back to default routing\n"
argument_list|,
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|(
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|node_guid_tbl
argument_list|)
operator|-
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
operator|)
operator|<
literal|2
condition|)
block|{
name|osm_log_v2
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
name|FILE_ID
argument_list|,
literal|"Fabric has %u nodes (%u switches) - topology is not fat-tree.\n"
literal|"Falling back to default routing\n"
argument_list|,
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|node_guid_tbl
argument_list|)
argument_list|,
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"\n"
literal|"                       |----------------------------------------|\n"
literal|"                       |- Starting FatTree fabric construction -|\n"
literal|"                       |----------------------------------------|\n\n"
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Populating FatTree Switch and CA tables\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fabric_populate_nodes
argument_list|(
name|p_ftree
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|osm_log_v2
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
name|FILE_ID
argument_list|,
literal|"Fabric topology is not fat-tree - "
literal|"falling back to default routing\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Reading guid files provided by user\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fabric_read_guid_files
argument_list|(
name|p_ftree
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|osm_log_v2
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
name|FILE_ID
argument_list|,
literal|"Failed reading guid files - "
literal|"falling back to default routing\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
operator|<
literal|2
condition|)
block|{
name|osm_log_v2
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
name|FILE_ID
argument_list|,
literal|"Fabric has %u CAs - topology is not fat-tree.\n"
literal|"Falling back to default routing\n"
argument_list|,
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Rank all the switches in the fabric. 	   After that we will know only fabric max switch rank. 	   We will be able to check leaf switches rank and the 	   whole tree rank after filling ports and marking CNs. */
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Ranking FatTree\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fabric_rank
argument_list|(
name|p_ftree
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|osm_log_v2
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
name|FILE_ID
argument_list|,
literal|"Failed ranking the tree\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|fabric_remove_unranked_sw
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ftree
operator|->
name|max_switch_rank
operator|==
literal|0
operator|&&
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
operator|>
literal|1
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB2B: Found more than one root on fabric with "
literal|"maximum rank 0\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* For each hca and switch, construct array of ports. 	   This is done after the whole FatTree data structure is ready, 	   because we want the ports to have pointers to ftree_{sw,hca}_t 	   objects, and we need the switches to be already ranked because 	   that's how the port direction is determined. */
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Populating CA& switch ports\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fabric_populate_ports
argument_list|(
name|p_ftree
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|osm_log_v2
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
name|FILE_ID
argument_list|,
literal|"Fabric topology is not a fat-tree\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
elseif|else
if|if
condition|(
name|p_ftree
operator|->
name|cn_num
operator|==
literal|0
condition|)
block|{
name|osm_log_v2
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
name|FILE_ID
argument_list|,
literal|"Fabric has no valid compute nodes\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Now that the CA ports have been created and CNs were marked, 	   we can complete the fabric ranking - set leaf switches rank. */
name|fabric_set_leaf_rank
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
if|if
condition|(
name|fabric_get_rank
argument_list|(
name|p_ftree
argument_list|)
operator|>
name|FAT_TREE_MAX_RANK
operator|||
name|fabric_get_rank
argument_list|(
name|p_ftree
argument_list|)
operator|<
name|FAT_TREE_MIN_RANK
condition|)
block|{
name|osm_log_v2
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
name|FILE_ID
argument_list|,
literal|"Fabric rank is %u (should be between %u and %u)\n"
argument_list|,
name|fabric_get_rank
argument_list|(
name|p_ftree
argument_list|)
argument_list|,
name|FAT_TREE_MIN_RANK
argument_list|,
name|FAT_TREE_MAX_RANK
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Mark all the switches in the fabric with rank equal to 	   p_ftree->leaf_switch_rank and that are also connected to CNs. 	   As a by-product, this function also runs basic topology 	   validation - it checks that all the CNs are at the same rank. */
if|if
condition|(
name|fabric_mark_leaf_switches
argument_list|(
name|p_ftree
argument_list|)
condition|)
block|{
name|osm_log_v2
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
name|FILE_ID
argument_list|,
literal|"Fabric topology is not a fat-tree\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Assign index to all the switches in the fabric. 	   This function also sorts leaf switch array by the switch index, 	   sorts all the port arrays of the indexed switches by remote 	   switch index, and creates switch-by-tuple table (sw_by_tuple_tbl) */
name|fabric_make_indexing
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
comment|/* Create leaf switch array sorted by index. 	   This array contains switches with rank equal to p_ftree->leaf_switch_rank 	   and that are also connected to CNs (REAL leafs), and it may contain 	   switches at the same leaf rank w/o CNs, if this is the order of indexing. 	   In any case, the first and the last switches in the array are REAL leafs. */
if|if
condition|(
name|fabric_create_leaf_switch_array
argument_list|(
name|p_ftree
argument_list|)
condition|)
block|{
name|osm_log_v2
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
name|FILE_ID
argument_list|,
literal|"Fabric topology is not a fat-tree\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* calculate and set ftree.max_cn_per_leaf field */
name|fabric_set_max_cn_per_leaf
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
comment|/* print general info about fabric topology */
name|fabric_dump_general_info
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
comment|/* dump full tree topology */
if|if
condition|(
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
name|fabric_dump
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
comment|/* the fabric is required to be PURE fat-tree only if the root 	   guid file hasn't been provided by user */
if|if
condition|(
operator|!
name|fabric_roots_provided
argument_list|(
name|p_ftree
argument_list|)
operator|&&
operator|!
name|fabric_validate_topology
argument_list|(
name|p_ftree
argument_list|)
condition|)
block|{
name|osm_log_v2
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
name|FILE_ID
argument_list|,
literal|"Fabric topology is not a fat-tree\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Max LID in switch LFTs: %u\n"
argument_list|,
name|p_ftree
operator|->
name|lft_max_lid
argument_list|)
expr_stmt|;
comment|/* Build the full lid matrices needed for multicast routing */
name|osm_ucast_mgr_build_lid_matrices
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|sm
operator|.
name|ucast_mgr
argument_list|)
expr_stmt|;
name|Exit
label|:
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Clearing FatTree Fabric data structures\n"
argument_list|)
expr_stmt|;
name|fabric_clear
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
block|}
else|else
name|p_ftree
operator|->
name|fabric_built
operator|=
name|TRUE
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"\n"
literal|"                       |--------------------------------------------------|\n"
literal|"                       |- Done constructing FatTree fabric (status = %d) -|\n"
literal|"                       |--------------------------------------------------|\n\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* construct_fabric() */
end_comment

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|int
name|do_routing
parameter_list|(
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
name|ftree_fabric_t
modifier|*
name|p_ftree
init|=
name|context
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ftree
operator|->
name|fabric_built
condition|)
block|{
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Starting FatTree routing\n"
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Filling switch forwarding tables for Compute Nodes\n"
argument_list|)
expr_stmt|;
name|fabric_route_to_cns
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Filling switch forwarding tables for non-CN targets\n"
argument_list|)
expr_stmt|;
name|fabric_route_to_non_cns
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Filling switch forwarding tables for switch-to-switch paths\n"
argument_list|)
expr_stmt|;
name|fabric_route_to_switches
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|connect_roots
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Connecting switches that are unreachable within "
literal|"Up/Down rules\n"
argument_list|)
expr_stmt|;
name|fabric_route_roots
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
block|}
comment|/* for each switch, set its fwd table */
name|cl_qmap_apply_func
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|,
name|set_sw_fwd_table
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p_ftree
argument_list|)
expr_stmt|;
comment|/* write out hca ordering file */
name|fabric_dump_hca_ordering
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"FatTree routing is done\n"
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|void
name|delete
parameter_list|(
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
if|if
condition|(
operator|!
name|context
condition|)
return|return;
name|fabric_destroy
argument_list|(
operator|(
name|ftree_fabric_t
operator|*
operator|)
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
name|int
name|osm_ucast_ftree_setup
parameter_list|(
name|struct
name|osm_routing_engine
modifier|*
name|r
parameter_list|,
name|osm_opensm_t
modifier|*
name|p_osm
parameter_list|)
block|{
name|ftree_fabric_t
modifier|*
name|p_ftree
init|=
name|fabric_create
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|p_ftree
condition|)
return|return
operator|-
literal|1
return|;
name|p_ftree
operator|->
name|p_osm
operator|=
name|p_osm
expr_stmt|;
name|p_ftree
operator|->
name|p_subn
operator|=
name|p_osm
operator|->
name|sm
operator|.
name|ucast_mgr
operator|.
name|p_subn
expr_stmt|;
name|r
operator|->
name|context
operator|=
operator|(
name|void
operator|*
operator|)
name|p_ftree
expr_stmt|;
name|r
operator|->
name|build_lid_matrices
operator|=
name|construct_fabric
expr_stmt|;
name|r
operator|->
name|ucast_build_fwd_tables
operator|=
name|do_routing
expr_stmt|;
name|r
operator|->
name|destroy
operator|=
name|delete
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

