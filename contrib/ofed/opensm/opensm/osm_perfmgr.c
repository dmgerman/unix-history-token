begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2007 The Regents of the University of California.  * Copyright (c) 2007-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 2009,2010 HNR Consulting. All rights reserved.  * Copyright (c) 2013 Lawrence Livermore National Security. All rights reserved.  * Copyright (c) 2011-2014 Mellanox Technologies LTD. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_perfmgr_t.  * This object implements an IBA performance manager.  *  * Author:  *    Ira Weiny, LLNL  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_OSM_PERF_MGR
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<poll.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<float.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_thread.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_PERFMGR_C
end_define

begin_include
include|#
directive|include
file|<vendor/osm_vendor_api.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_perfmgr.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_node.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_define
define|#
directive|define
name|PERFMGR_INITIAL_TID_VALUE
value|0xcafe
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_OSM_PERF_MGR_PROFILE
end_ifdef

begin_struct
struct|struct
block|{
name|double
name|fastest_us
decl_stmt|;
name|double
name|slowest_us
decl_stmt|;
name|double
name|avg_us
decl_stmt|;
name|uint64_t
name|num
decl_stmt|;
block|}
name|perfmgr_mad_stats
init|=
block|{
name|fastest_us
operator|:
name|DBL_MAX
block|,
name|slowest_us
operator|:
name|DBL_MIN
block|,
name|avg_us
operator|:
literal|0
block|,
name|num
operator|:
literal|0
block|}
struct|;
end_struct

begin_comment
comment|/* diff must be something which can fit in a susecond_t */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|update_mad_stats
parameter_list|(
name|struct
name|timeval
modifier|*
name|diff
parameter_list|)
block|{
name|double
name|new
init|=
operator|(
name|diff
operator|->
name|tv_sec
operator|*
literal|1000000
operator|)
operator|+
name|diff
operator|->
name|tv_usec
decl_stmt|;
if|if
condition|(
name|new
operator|<
name|perfmgr_mad_stats
operator|.
name|fastest_us
condition|)
name|perfmgr_mad_stats
operator|.
name|fastest_us
operator|=
name|new
expr_stmt|;
if|if
condition|(
name|new
operator|>
name|perfmgr_mad_stats
operator|.
name|slowest_us
condition|)
name|perfmgr_mad_stats
operator|.
name|slowest_us
operator|=
name|new
expr_stmt|;
name|perfmgr_mad_stats
operator|.
name|avg_us
operator|=
operator|(
operator|(
name|perfmgr_mad_stats
operator|.
name|avg_us
operator|*
name|perfmgr_mad_stats
operator|.
name|num
operator|)
operator|+
name|new
operator|)
operator|/
operator|(
name|perfmgr_mad_stats
operator|.
name|num
operator|+
literal|1
operator|)
expr_stmt|;
name|perfmgr_mad_stats
operator|.
name|num
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|clear_mad_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|perfmgr_mad_stats
operator|.
name|fastest_us
operator|=
name|DBL_MAX
expr_stmt|;
name|perfmgr_mad_stats
operator|.
name|slowest_us
operator|=
name|DBL_MIN
expr_stmt|;
name|perfmgr_mad_stats
operator|.
name|avg_us
operator|=
literal|0
expr_stmt|;
name|perfmgr_mad_stats
operator|.
name|num
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* after and diff can be the same struct */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|diff_time
parameter_list|(
name|struct
name|timeval
modifier|*
name|before
parameter_list|,
name|struct
name|timeval
modifier|*
name|after
parameter_list|,
name|struct
name|timeval
modifier|*
name|diff
parameter_list|)
block|{
name|struct
name|timeval
name|tmp
init|=
operator|*
name|after
decl_stmt|;
if|if
condition|(
name|tmp
operator|.
name|tv_usec
operator|<
name|before
operator|->
name|tv_usec
condition|)
block|{
name|tmp
operator|.
name|tv_sec
operator|--
expr_stmt|;
name|tmp
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
name|diff
operator|->
name|tv_sec
operator|=
name|tmp
operator|.
name|tv_sec
operator|-
name|before
operator|->
name|tv_sec
expr_stmt|;
name|diff
operator|->
name|tv_usec
operator|=
name|tmp
operator|.
name|tv_usec
operator|-
name|before
operator|->
name|tv_usec
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**********************************************************************  * Internal helper functions  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|init_monitored_nodes
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|)
block|{
name|cl_qmap_init
argument_list|(
operator|&
name|pm
operator|->
name|monitored_map
argument_list|)
expr_stmt|;
name|pm
operator|->
name|remove_list
operator|=
name|NULL
expr_stmt|;
name|cl_event_construct
argument_list|(
operator|&
name|pm
operator|->
name|sig_query
argument_list|)
expr_stmt|;
name|cl_event_init
argument_list|(
operator|&
name|pm
operator|->
name|sig_query
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mark_for_removal
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|,
name|monitored_node_t
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|pm
operator|->
name|remove_list
condition|)
block|{
name|node
operator|->
name|next
operator|=
name|pm
operator|->
name|remove_list
expr_stmt|;
name|pm
operator|->
name|remove_list
operator|=
name|node
expr_stmt|;
block|}
else|else
block|{
name|node
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|pm
operator|->
name|remove_list
operator|=
name|node
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|remove_marked_nodes
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|)
block|{
while|while
condition|(
name|pm
operator|->
name|remove_list
condition|)
block|{
name|monitored_node_t
modifier|*
name|next
init|=
name|pm
operator|->
name|remove_list
operator|->
name|next
decl_stmt|;
name|int
name|port
decl_stmt|;
name|cl_qmap_remove_item
argument_list|(
operator|&
name|pm
operator|->
name|monitored_map
argument_list|,
operator|(
name|cl_map_item_t
operator|*
operator|)
operator|(
name|pm
operator|->
name|remove_list
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|rm_nodes
condition|)
name|perfmgr_db_delete_entry
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|pm
operator|->
name|remove_list
operator|->
name|guid
argument_list|)
expr_stmt|;
else|else
name|perfmgr_db_mark_active
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|pm
operator|->
name|remove_list
operator|->
name|guid
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|remove_list
operator|->
name|name
condition|)
name|free
argument_list|(
name|pm
operator|->
name|remove_list
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|port
operator|=
name|pm
operator|->
name|remove_list
operator|->
name|esp0
condition|?
literal|0
else|:
literal|1
init|;
name|port
operator|<
name|pm
operator|->
name|remove_list
operator|->
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
if|if
condition|(
name|pm
operator|->
name|remove_list
operator|->
name|port
index|[
name|port
index|]
operator|.
name|remote_name
condition|)
name|free
argument_list|(
name|pm
operator|->
name|remove_list
operator|->
name|port
index|[
name|port
index|]
operator|.
name|remote_name
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pm
operator|->
name|remove_list
argument_list|)
expr_stmt|;
name|pm
operator|->
name|remove_list
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|decrement_outstanding_queries
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|)
block|{
name|cl_atomic_dec
argument_list|(
operator|&
name|pm
operator|->
name|outstanding_queries
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pm
operator|->
name|outstanding_queries
condition|)
block|{
name|cl_spinlock_acquire
argument_list|(
operator|&
name|pm
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|sweep_state
operator|==
name|PERFMGR_SWEEP_POST_PROCESSING
condition|)
block|{
name|pm
operator|->
name|sweep_state
operator|=
name|PERFMGR_SWEEP_SLEEP
expr_stmt|;
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"PM sweep state exiting Post Processing\n"
argument_list|)
expr_stmt|;
block|}
name|cl_spinlock_release
argument_list|(
operator|&
name|pm
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|cl_event_signal
argument_list|(
operator|&
name|pm
operator|->
name|sig_query
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Receive the MAD from the vendor layer and post it for processing by  * the dispatcher  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|perfmgr_mad_recv_callback
parameter_list|(
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|,
name|void
modifier|*
name|bind_context
parameter_list|,
name|osm_madw_t
modifier|*
name|p_req_madw
parameter_list|)
block|{
name|osm_perfmgr_t
modifier|*
name|pm
init|=
operator|(
name|osm_perfmgr_t
operator|*
operator|)
name|bind_context
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_req_madw
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|osm_madw_copy_context
argument_list|(
name|p_madw
argument_list|,
name|p_req_madw
argument_list|)
expr_stmt|;
name|osm_mad_pool_put
argument_list|(
name|pm
operator|->
name|mad_pool
argument_list|,
name|p_req_madw
argument_list|)
expr_stmt|;
name|decrement_outstanding_queries
argument_list|(
name|pm
argument_list|)
expr_stmt|;
comment|/* post this message for later processing. */
if|if
condition|(
name|cl_disp_post
argument_list|(
name|pm
operator|->
name|pc_disp_h
argument_list|,
name|OSM_MSG_MAD_PORT_COUNTERS
argument_list|,
name|p_madw
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|!=
name|CL_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 5401: "
literal|"PerfMgr Dispatcher post failed\n"
argument_list|)
expr_stmt|;
name|osm_mad_pool_put
argument_list|(
name|pm
operator|->
name|mad_pool
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Process MAD send errors  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|perfmgr_mad_send_err_callback
parameter_list|(
name|void
modifier|*
name|bind_context
parameter_list|,
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|)
block|{
name|osm_perfmgr_t
modifier|*
name|pm
init|=
operator|(
name|osm_perfmgr_t
operator|*
operator|)
name|bind_context
decl_stmt|;
name|osm_madw_context_t
modifier|*
name|context
init|=
operator|&
name|p_madw
operator|->
name|context
decl_stmt|;
name|uint64_t
name|node_guid
init|=
name|context
operator|->
name|perfmgr_context
operator|.
name|node_guid
decl_stmt|;
name|uint8_t
name|port
init|=
name|context
operator|->
name|perfmgr_context
operator|.
name|port
decl_stmt|;
name|cl_map_item_t
modifier|*
name|p_node
decl_stmt|;
name|monitored_node_t
modifier|*
name|p_mon_node
decl_stmt|;
name|ib_net16_t
name|orig_lid
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
comment|/* 	 * get the monitored node struct to have the printable name 	 * for log messages 	 */
if|if
condition|(
operator|(
name|p_node
operator|=
name|cl_qmap_get
argument_list|(
operator|&
name|pm
operator|->
name|monitored_map
argument_list|,
name|node_guid
argument_list|)
operator|)
operator|==
name|cl_qmap_end
argument_list|(
operator|&
name|pm
operator|->
name|monitored_map
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 5415: GUID 0x%016"
name|PRIx64
literal|" not found in monitored map\n"
argument_list|,
name|node_guid
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_mon_node
operator|=
operator|(
name|monitored_node_t
operator|*
operator|)
name|p_node
expr_stmt|;
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 5402: %s (0x%"
name|PRIx64
literal|") port %u LID %u TID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|p_mon_node
operator|->
name|name
argument_list|,
name|p_mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_madw
operator|->
name|mad_addr
operator|.
name|dest_lid
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_madw
operator|->
name|p_mad
operator|->
name|trans_id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|subn
operator|->
name|opt
operator|.
name|perfmgr_redir
operator|&&
name|p_madw
operator|->
name|status
operator|==
name|IB_TIMEOUT
condition|)
block|{
comment|/* First, find the node in the monitored map */
name|cl_plock_acquire
argument_list|(
operator|&
name|pm
operator|->
name|osm
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* Now, validate port number */
if|if
condition|(
name|port
operator|>=
name|p_mon_node
operator|->
name|num_ports
condition|)
block|{
name|cl_plock_release
argument_list|(
operator|&
name|pm
operator|->
name|osm
operator|->
name|lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 5416: "
literal|"Invalid port num %u for %s (GUID 0x%016"
name|PRIx64
literal|") num ports %u\n"
argument_list|,
name|port
argument_list|,
name|p_mon_node
operator|->
name|name
argument_list|,
name|p_mon_node
operator|->
name|guid
argument_list|,
name|p_mon_node
operator|->
name|num_ports
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Clear redirection info for this port except orig_lid */
name|orig_lid
operator|=
name|p_mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|orig_lid
expr_stmt|;
name|memset
argument_list|(
operator|&
name|p_mon_node
operator|->
name|port
index|[
name|port
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|monitored_port_t
argument_list|)
argument_list|)
expr_stmt|;
name|p_mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|orig_lid
operator|=
name|orig_lid
expr_stmt|;
name|p_mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|valid
operator|=
name|TRUE
expr_stmt|;
name|cl_plock_release
argument_list|(
operator|&
name|pm
operator|->
name|osm
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|osm_mad_pool_put
argument_list|(
name|pm
operator|->
name|mad_pool
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
name|decrement_outstanding_queries
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Bind the PerfMgr to the vendor layer for MAD sends/receives  **********************************************************************/
end_comment

begin_function
name|ib_api_status_t
name|osm_perfmgr_bind
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|,
name|ib_net64_t
name|port_guid
parameter_list|)
block|{
name|osm_bind_info_t
name|bind_info
decl_stmt|;
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|bind_handle
operator|!=
name|OSM_BIND_INVALID_HANDLE
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 5403: Multiple binds not allowed\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|bind_info
operator|.
name|port_guid
operator|=
name|pm
operator|->
name|port_guid
operator|=
name|port_guid
expr_stmt|;
name|bind_info
operator|.
name|mad_class
operator|=
name|IB_MCLASS_PERF
expr_stmt|;
name|bind_info
operator|.
name|class_version
operator|=
literal|1
expr_stmt|;
name|bind_info
operator|.
name|is_responder
operator|=
name|FALSE
expr_stmt|;
name|bind_info
operator|.
name|is_report_processor
operator|=
name|FALSE
expr_stmt|;
name|bind_info
operator|.
name|is_trap_processor
operator|=
name|FALSE
expr_stmt|;
name|bind_info
operator|.
name|recv_q_size
operator|=
name|OSM_PM_DEFAULT_QP1_RCV_SIZE
expr_stmt|;
name|bind_info
operator|.
name|send_q_size
operator|=
name|OSM_PM_DEFAULT_QP1_SEND_SIZE
expr_stmt|;
name|bind_info
operator|.
name|timeout
operator|=
name|pm
operator|->
name|subn
operator|->
name|opt
operator|.
name|transaction_timeout
expr_stmt|;
name|bind_info
operator|.
name|retries
operator|=
name|pm
operator|->
name|subn
operator|->
name|opt
operator|.
name|transaction_retries
expr_stmt|;
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Binding to port GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
name|pm
operator|->
name|bind_handle
operator|=
name|osm_vendor_bind
argument_list|(
name|pm
operator|->
name|vendor
argument_list|,
operator|&
name|bind_info
argument_list|,
name|pm
operator|->
name|mad_pool
argument_list|,
name|perfmgr_mad_recv_callback
argument_list|,
name|perfmgr_mad_send_err_callback
argument_list|,
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|bind_handle
operator|==
name|OSM_BIND_INVALID_HANDLE
condition|)
block|{
name|status
operator|=
name|IB_ERROR
expr_stmt|;
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 5404: Vendor specific bind failed (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Unbind the PerfMgr from the vendor layer for MAD sends/receives  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|perfmgr_mad_unbind
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|)
block|{
name|OSM_LOG_ENTER
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|bind_handle
operator|==
name|OSM_BIND_INVALID_HANDLE
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 5405: No previous bind\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|osm_vendor_unbind
argument_list|(
name|pm
operator|->
name|bind_handle
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Given a monitored node and a port, return the qp  **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_net32_t
name|get_qp
parameter_list|(
name|monitored_node_t
modifier|*
name|mon_node
parameter_list|,
name|uint8_t
name|port
parameter_list|)
block|{
name|ib_net32_t
name|qp
init|=
name|IB_QP1
decl_stmt|;
if|if
condition|(
name|mon_node
operator|&&
name|mon_node
operator|->
name|num_ports
operator|&&
name|port
operator|<
name|mon_node
operator|->
name|num_ports
operator|&&
name|mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|redirection
operator|&&
name|mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|qp
condition|)
name|qp
operator|=
name|mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|qp
expr_stmt|;
return|return
name|qp
return|;
block|}
end_function

begin_function
specifier|static
name|ib_net16_t
name|get_base_lid
parameter_list|(
name|osm_node_t
modifier|*
name|p_node
parameter_list|,
name|uint8_t
name|port
parameter_list|)
block|{
switch|switch
condition|(
name|p_node
operator|->
name|node_info
operator|.
name|node_type
condition|)
block|{
case|case
name|IB_NODE_TYPE_CA
case|:
case|case
name|IB_NODE_TYPE_ROUTER
case|:
return|return
name|osm_node_get_base_lid
argument_list|(
name|p_node
argument_list|,
name|port
argument_list|)
return|;
case|case
name|IB_NODE_TYPE_SWITCH
case|:
return|return
name|osm_node_get_base_lid
argument_list|(
name|p_node
argument_list|,
literal|0
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/**********************************************************************  * Given a node, a port, and an optional monitored node,  * return the lid appropriate to query that port  **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_net16_t
name|get_lid
parameter_list|(
name|osm_node_t
modifier|*
name|p_node
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|monitored_node_t
modifier|*
name|mon_node
parameter_list|)
block|{
if|if
condition|(
name|mon_node
operator|&&
name|mon_node
operator|->
name|num_ports
operator|&&
name|port
operator|<
name|mon_node
operator|->
name|num_ports
operator|&&
name|mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|lid
condition|)
return|return
name|mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|lid
return|;
return|return
name|get_base_lid
argument_list|(
name|p_node
argument_list|,
name|port
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Build a Performance Management class MAD  **********************************************************************/
end_comment

begin_function
specifier|static
name|osm_madw_t
modifier|*
name|perfmgr_build_mad
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|perfmgr
parameter_list|,
name|ib_net16_t
name|dest_lid
parameter_list|,
name|uint8_t
name|sl
parameter_list|,
name|ib_net32_t
name|dest_qp
parameter_list|,
name|uint16_t
name|pkey_ix
parameter_list|,
name|uint8_t
name|mad_method
parameter_list|,
name|ib_net16_t
name|attr_id
parameter_list|,
name|osm_madw_context_t
modifier|*
name|p_context
parameter_list|,
name|ib_perfmgt_mad_t
modifier|*
modifier|*
name|p_pm_mad
parameter_list|)
block|{
name|ib_perfmgt_mad_t
modifier|*
name|pm_mad
init|=
name|NULL
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_madw
init|=
name|NULL
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|perfmgr
operator|->
name|log
argument_list|)
expr_stmt|;
name|p_madw
operator|=
name|osm_mad_pool_get
argument_list|(
name|perfmgr
operator|->
name|mad_pool
argument_list|,
name|perfmgr
operator|->
name|bind_handle
argument_list|,
name|MAD_BLOCK_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_madw
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|pm_mad
operator|=
name|osm_madw_get_perfmgt_mad_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
comment|/* build the mad */
name|pm_mad
operator|->
name|header
operator|.
name|base_ver
operator|=
literal|1
expr_stmt|;
name|pm_mad
operator|->
name|header
operator|.
name|mgmt_class
operator|=
name|IB_MCLASS_PERF
expr_stmt|;
name|pm_mad
operator|->
name|header
operator|.
name|class_ver
operator|=
literal|1
expr_stmt|;
name|pm_mad
operator|->
name|header
operator|.
name|method
operator|=
name|mad_method
expr_stmt|;
name|pm_mad
operator|->
name|header
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|pm_mad
operator|->
name|header
operator|.
name|class_spec
operator|=
literal|0
expr_stmt|;
name|pm_mad
operator|->
name|header
operator|.
name|trans_id
operator|=
name|cl_hton64
argument_list|(
operator|(
name|uint64_t
operator|)
name|cl_atomic_inc
argument_list|(
operator|&
name|perfmgr
operator|->
name|trans_id
argument_list|)
operator|&
call|(
name|uint64_t
call|)
argument_list|(
literal|0xFFFFFFFF
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|perfmgr
operator|->
name|trans_id
operator|==
literal|0
condition|)
name|pm_mad
operator|->
name|header
operator|.
name|trans_id
operator|=
name|cl_hton64
argument_list|(
operator|(
name|uint64_t
operator|)
name|cl_atomic_inc
argument_list|(
operator|&
name|perfmgr
operator|->
name|trans_id
argument_list|)
operator|&
call|(
name|uint64_t
call|)
argument_list|(
literal|0xFFFFFFFF
argument_list|)
argument_list|)
expr_stmt|;
name|pm_mad
operator|->
name|header
operator|.
name|attr_id
operator|=
name|attr_id
expr_stmt|;
name|pm_mad
operator|->
name|header
operator|.
name|resv
operator|=
literal|0
expr_stmt|;
name|pm_mad
operator|->
name|header
operator|.
name|attr_mod
operator|=
literal|0
expr_stmt|;
name|p_madw
operator|->
name|mad_addr
operator|.
name|dest_lid
operator|=
name|dest_lid
expr_stmt|;
name|p_madw
operator|->
name|mad_addr
operator|.
name|addr_type
operator|.
name|gsi
operator|.
name|remote_qp
operator|=
name|dest_qp
expr_stmt|;
name|p_madw
operator|->
name|mad_addr
operator|.
name|addr_type
operator|.
name|gsi
operator|.
name|remote_qkey
operator|=
name|cl_hton32
argument_list|(
name|IB_QP1_WELL_KNOWN_Q_KEY
argument_list|)
expr_stmt|;
name|p_madw
operator|->
name|mad_addr
operator|.
name|addr_type
operator|.
name|gsi
operator|.
name|pkey_ix
operator|=
name|pkey_ix
expr_stmt|;
name|p_madw
operator|->
name|mad_addr
operator|.
name|addr_type
operator|.
name|gsi
operator|.
name|service_level
operator|=
name|sl
expr_stmt|;
name|p_madw
operator|->
name|mad_addr
operator|.
name|addr_type
operator|.
name|gsi
operator|.
name|global_route
operator|=
name|FALSE
expr_stmt|;
name|p_madw
operator|->
name|resp_expected
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|p_context
condition|)
name|p_madw
operator|->
name|context
operator|=
operator|*
name|p_context
expr_stmt|;
if|if
condition|(
name|p_pm_mad
condition|)
operator|*
name|p_pm_mad
operator|=
name|pm_mad
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|perfmgr
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
operator|(
name|p_madw
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Send a Performance Management class MAD  **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|perfmgr_send_mad
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|perfmgr
parameter_list|,
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|)
block|{
name|cl_status_t
name|sts
decl_stmt|;
name|ib_api_status_t
name|status
init|=
name|osm_vendor_send
argument_list|(
name|perfmgr
operator|->
name|bind_handle
argument_list|,
name|p_madw
argument_list|,
name|TRUE
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|IB_SUCCESS
condition|)
block|{
comment|/* pause thread if there are too many outstanding requests */
name|cl_atomic_inc
argument_list|(
operator|&
operator|(
name|perfmgr
operator|->
name|outstanding_queries
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|perfmgr
operator|->
name|outstanding_queries
operator|>
operator|(
name|int32_t
operator|)
name|perfmgr
operator|->
name|max_outstanding_queries
condition|)
block|{
name|cl_spinlock_acquire
argument_list|(
operator|&
name|perfmgr
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|perfmgr
operator|->
name|sweep_state
operator|==
name|PERFMGR_SWEEP_SLEEP
condition|)
block|{
name|perfmgr
operator|->
name|sweep_state
operator|=
name|PERFMGR_SWEEP_POST_PROCESSING
expr_stmt|;
name|OSM_LOG
argument_list|(
name|perfmgr
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"PM sweep state going into Post Processing\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|perfmgr
operator|->
name|sweep_state
operator|==
name|PERFMGR_SWEEP_ACTIVE
condition|)
name|perfmgr
operator|->
name|sweep_state
operator|=
name|PERFMGR_SWEEP_SUSPENDED
expr_stmt|;
name|cl_spinlock_release
argument_list|(
operator|&
name|perfmgr
operator|->
name|lock
argument_list|)
expr_stmt|;
name|wait
label|:
name|sts
operator|=
name|cl_event_wait_on
argument_list|(
operator|&
name|perfmgr
operator|->
name|sig_query
argument_list|,
name|EVENT_NO_TIMEOUT
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sts
operator|!=
name|CL_SUCCESS
condition|)
goto|goto
name|wait
goto|;
name|cl_spinlock_acquire
argument_list|(
operator|&
name|perfmgr
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|perfmgr
operator|->
name|sweep_state
operator|==
name|PERFMGR_SWEEP_SUSPENDED
condition|)
name|perfmgr
operator|->
name|sweep_state
operator|=
name|PERFMGR_SWEEP_ACTIVE
expr_stmt|;
name|cl_spinlock_release
argument_list|(
operator|&
name|perfmgr
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Form and send the PortCounters MAD for a single port  **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|perfmgr_send_pc_mad
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|perfmgr
parameter_list|,
name|ib_net16_t
name|dest_lid
parameter_list|,
name|ib_net32_t
name|dest_qp
parameter_list|,
name|uint16_t
name|pkey_ix
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|uint8_t
name|mad_method
parameter_list|,
name|uint16_t
name|counter_select
parameter_list|,
name|uint8_t
name|counter_select2
parameter_list|,
name|osm_madw_context_t
modifier|*
name|p_context
parameter_list|,
name|uint8_t
name|sl
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|ib_port_counters_t
modifier|*
name|port_counter
init|=
name|NULL
decl_stmt|;
name|ib_perfmgt_mad_t
modifier|*
name|pm_mad
init|=
name|NULL
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_madw
init|=
name|NULL
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|perfmgr
operator|->
name|log
argument_list|)
expr_stmt|;
name|p_context
operator|->
name|perfmgr_context
operator|.
name|mad_attr_id
operator|=
name|IB_MAD_ATTR_PORT_CNTRS
expr_stmt|;
name|p_madw
operator|=
name|perfmgr_build_mad
argument_list|(
name|perfmgr
argument_list|,
name|dest_lid
argument_list|,
name|sl
argument_list|,
name|dest_qp
argument_list|,
name|pkey_ix
argument_list|,
name|mad_method
argument_list|,
name|IB_MAD_ATTR_PORT_CNTRS
argument_list|,
name|p_context
argument_list|,
operator|&
name|pm_mad
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_madw
operator|==
name|NULL
condition|)
return|return
name|IB_INSUFFICIENT_MEMORY
return|;
name|port_counter
operator|=
operator|(
name|ib_port_counters_t
operator|*
operator|)
operator|&
name|pm_mad
operator|->
name|data
expr_stmt|;
name|memset
argument_list|(
name|port_counter
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|port_counter
argument_list|)
argument_list|)
expr_stmt|;
name|port_counter
operator|->
name|port_select
operator|=
name|port
expr_stmt|;
name|port_counter
operator|->
name|counter_select
operator|=
name|cl_hton16
argument_list|(
name|counter_select
argument_list|)
expr_stmt|;
name|port_counter
operator|->
name|counter_select2
operator|=
name|counter_select2
expr_stmt|;
name|status
operator|=
name|perfmgr_send_mad
argument_list|(
name|perfmgr
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|perfmgr
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * sweep the node_guid_tbl and collect the node guids to be tracked  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|collect_guids
parameter_list|(
name|cl_map_item_t
modifier|*
name|p_map_item
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|osm_node_t
modifier|*
name|node
init|=
operator|(
name|osm_node_t
operator|*
operator|)
name|p_map_item
decl_stmt|;
name|uint64_t
name|node_guid
init|=
name|cl_ntoh64
argument_list|(
name|node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|)
decl_stmt|;
name|osm_perfmgr_t
modifier|*
name|pm
init|=
operator|(
name|osm_perfmgr_t
operator|*
operator|)
name|context
decl_stmt|;
name|monitored_node_t
modifier|*
name|mon_node
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|num_ports
decl_stmt|;
name|int
name|port
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl_qmap_get
argument_list|(
operator|&
name|pm
operator|->
name|monitored_map
argument_list|,
name|node_guid
argument_list|)
operator|==
name|cl_qmap_end
argument_list|(
operator|&
name|pm
operator|->
name|monitored_map
argument_list|)
condition|)
block|{
if|if
condition|(
name|pm
operator|->
name|ignore_cas
operator|&&
operator|(
name|node
operator|->
name|node_info
operator|.
name|node_type
operator|==
name|IB_NODE_TYPE_CA
operator|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* if not already in map add it */
name|num_ports
operator|=
name|osm_node_get_num_physp
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|mon_node
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mon_node
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|monitored_port_t
argument_list|)
operator|*
name|num_ports
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mon_node
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"PerfMgr: ERR 5406: "
literal|"malloc failed: not handling node %s"
literal|"(GUID 0x%"
name|PRIx64
literal|")\n"
argument_list|,
name|node
operator|->
name|print_desc
argument_list|,
name|node_guid
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|memset
argument_list|(
name|mon_node
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mon_node
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|monitored_port_t
argument_list|)
operator|*
name|num_ports
argument_list|)
expr_stmt|;
name|mon_node
operator|->
name|guid
operator|=
name|node_guid
expr_stmt|;
name|mon_node
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
name|mon_node
operator|->
name|num_ports
operator|=
name|num_ports
expr_stmt|;
name|mon_node
operator|->
name|node_type
operator|=
name|node
operator|->
name|node_info
operator|.
name|node_type
expr_stmt|;
comment|/* check for enhanced switch port 0 */
name|mon_node
operator|->
name|esp0
operator|=
operator|(
name|node
operator|->
name|sw
operator|&&
name|ib_switch_info_is_enhanced_port0
argument_list|(
operator|&
name|node
operator|->
name|sw
operator|->
name|switch_info
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|port
operator|=
name|mon_node
operator|->
name|esp0
condition|?
literal|0
else|:
literal|1
init|;
name|port
operator|<
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
name|monitored_port_t
modifier|*
name|mon_port
init|=
operator|&
name|mon_node
operator|->
name|port
index|[
name|port
index|]
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
init|=
operator|&
name|node
operator|->
name|physp_table
index|[
name|port
index|]
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_remote_physp
init|=
name|p_physp
operator|->
name|p_remote_physp
decl_stmt|;
name|mon_port
operator|->
name|orig_lid
operator|=
literal|0
expr_stmt|;
name|mon_port
operator|->
name|valid
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|osm_physp_is_valid
argument_list|(
name|p_physp
argument_list|)
condition|)
block|{
name|mon_port
operator|->
name|orig_lid
operator|=
name|get_base_lid
argument_list|(
name|node
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|mon_port
operator|->
name|valid
operator|=
name|TRUE
expr_stmt|;
block|}
name|mon_port
operator|->
name|remote_valid
operator|=
name|FALSE
expr_stmt|;
name|mon_port
operator|->
name|remote_name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|p_remote_physp
operator|&&
name|osm_physp_is_valid
argument_list|(
name|p_remote_physp
argument_list|)
condition|)
block|{
name|osm_node_t
modifier|*
name|p_remote_node
init|=
name|p_remote_physp
operator|->
name|p_node
decl_stmt|;
name|mon_port
operator|->
name|remote_valid
operator|=
name|TRUE
expr_stmt|;
name|mon_port
operator|->
name|remote_guid
operator|=
name|p_remote_node
operator|->
name|node_info
operator|.
name|node_guid
expr_stmt|;
name|mon_port
operator|->
name|remote_name
operator|=
name|strdup
argument_list|(
name|p_remote_node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
name|mon_port
operator|->
name|remote_port
operator|=
name|p_remote_physp
operator|->
name|port_num
expr_stmt|;
block|}
block|}
name|cl_qmap_insert
argument_list|(
operator|&
name|pm
operator|->
name|monitored_map
argument_list|,
name|node_guid
argument_list|,
operator|(
name|cl_map_item_t
operator|*
operator|)
name|mon_node
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Form and send the ClassPortInfo MAD for a single port  **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|perfmgr_send_cpi_mad
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|,
name|ib_net16_t
name|dest_lid
parameter_list|,
name|ib_net32_t
name|dest_qp
parameter_list|,
name|uint16_t
name|pkey_ix
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|osm_madw_context_t
modifier|*
name|p_context
parameter_list|,
name|uint8_t
name|sl
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_madw
init|=
name|NULL
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
name|p_context
operator|->
name|perfmgr_context
operator|.
name|mad_attr_id
operator|=
name|IB_MAD_ATTR_CLASS_PORT_INFO
expr_stmt|;
name|p_madw
operator|=
name|perfmgr_build_mad
argument_list|(
name|pm
argument_list|,
name|dest_lid
argument_list|,
name|sl
argument_list|,
name|dest_qp
argument_list|,
name|pkey_ix
argument_list|,
name|IB_MAD_METHOD_GET
argument_list|,
name|IB_MAD_ATTR_CLASS_PORT_INFO
argument_list|,
name|p_context
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_madw
operator|==
name|NULL
condition|)
return|return
name|IB_INSUFFICIENT_MEMORY
return|;
name|status
operator|=
name|perfmgr_send_mad
argument_list|(
name|pm
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * return if some form of PortCountersExtended (PCE || PCE NoIETF) are supported  **********************************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|boolean_t
name|pce_supported
parameter_list|(
name|monitored_node_t
modifier|*
name|mon_node
parameter_list|,
name|uint8_t
name|port
parameter_list|)
block|{
name|monitored_port_t
modifier|*
name|mon_port
init|=
operator|&
operator|(
name|mon_node
operator|->
name|port
index|[
name|port
index|]
operator|)
decl_stmt|;
return|return
operator|(
name|mon_port
operator|->
name|cpi_valid
operator|&&
operator|(
name|mon_port
operator|->
name|cap_mask
operator|&
name|IB_PM_EXT_WIDTH_SUPPORTED
operator|||
name|mon_port
operator|->
name|cap_mask
operator|&
name|IB_PM_EXT_WIDTH_NOIETF_SUP
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * return if CapMask.PortCountersXmitWaitSupported is set  **********************************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|boolean_t
name|xmit_wait_supported
parameter_list|(
name|monitored_node_t
modifier|*
name|mon_node
parameter_list|,
name|uint8_t
name|port
parameter_list|)
block|{
name|monitored_port_t
modifier|*
name|mon_port
init|=
operator|&
operator|(
name|mon_node
operator|->
name|port
index|[
name|port
index|]
operator|)
decl_stmt|;
return|return
operator|(
name|mon_port
operator|->
name|cpi_valid
operator|&&
operator|(
name|mon_port
operator|->
name|cap_mask
operator|&
name|IB_PM_PC_XMIT_WAIT_SUP
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * return if "full" PortCountersExtended (IETF) is indicated  **********************************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|boolean_t
name|ietf_supported
parameter_list|(
name|monitored_node_t
modifier|*
name|mon_node
parameter_list|,
name|uint8_t
name|port
parameter_list|)
block|{
name|monitored_port_t
modifier|*
name|mon_port
init|=
operator|&
operator|(
name|mon_node
operator|->
name|port
index|[
name|port
index|]
operator|)
decl_stmt|;
return|return
operator|(
name|mon_port
operator|->
name|cpi_valid
operator|&&
operator|(
name|mon_port
operator|->
name|cap_mask
operator|&
name|IB_PM_EXT_WIDTH_SUPPORTED
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Form and send the PortCountersExtended MAD for a single port  **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|perfmgr_send_pce_mad
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|perfmgr
parameter_list|,
name|ib_net16_t
name|dest_lid
parameter_list|,
name|ib_net32_t
name|dest_qp
parameter_list|,
name|uint16_t
name|pkey_ix
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|uint8_t
name|mad_method
parameter_list|,
name|osm_madw_context_t
modifier|*
name|p_context
parameter_list|,
name|uint8_t
name|sl
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|ib_port_counters_ext_t
modifier|*
name|port_counter_ext
init|=
name|NULL
decl_stmt|;
name|ib_perfmgt_mad_t
modifier|*
name|pm_mad
init|=
name|NULL
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_madw
init|=
name|NULL
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|perfmgr
operator|->
name|log
argument_list|)
expr_stmt|;
name|p_context
operator|->
name|perfmgr_context
operator|.
name|mad_attr_id
operator|=
name|IB_MAD_ATTR_PORT_CNTRS_EXT
expr_stmt|;
name|p_madw
operator|=
name|perfmgr_build_mad
argument_list|(
name|perfmgr
argument_list|,
name|dest_lid
argument_list|,
name|sl
argument_list|,
name|dest_qp
argument_list|,
name|pkey_ix
argument_list|,
name|mad_method
argument_list|,
name|IB_MAD_ATTR_PORT_CNTRS_EXT
argument_list|,
name|p_context
argument_list|,
operator|&
name|pm_mad
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_madw
operator|==
name|NULL
condition|)
return|return
name|IB_INSUFFICIENT_MEMORY
return|;
name|port_counter_ext
operator|=
operator|(
name|ib_port_counters_ext_t
operator|*
operator|)
operator|&
name|pm_mad
operator|->
name|data
expr_stmt|;
name|memset
argument_list|(
name|port_counter_ext
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|port_counter_ext
argument_list|)
argument_list|)
expr_stmt|;
name|port_counter_ext
operator|->
name|port_select
operator|=
name|port
expr_stmt|;
name|port_counter_ext
operator|->
name|counter_select
operator|=
name|cl_hton16
argument_list|(
literal|0x00FF
argument_list|)
expr_stmt|;
name|status
operator|=
name|perfmgr_send_mad
argument_list|(
name|perfmgr
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|perfmgr
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * query the Port Counters of all the nodes in the subnet  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|perfmgr_query_counters
parameter_list|(
name|cl_map_item_t
modifier|*
name|p_map_item
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|osm_perfmgr_t
modifier|*
name|pm
init|=
name|context
decl_stmt|;
name|osm_node_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|monitored_node_t
modifier|*
name|mon_node
init|=
operator|(
name|monitored_node_t
operator|*
operator|)
name|p_map_item
decl_stmt|;
name|osm_madw_context_t
name|mad_context
decl_stmt|;
name|uint64_t
name|node_guid
init|=
literal|0
decl_stmt|;
name|ib_net32_t
name|remote_qp
decl_stmt|;
name|uint8_t
name|port
decl_stmt|,
name|num_ports
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
name|cl_plock_acquire
argument_list|(
operator|&
name|pm
operator|->
name|osm
operator|->
name|lock
argument_list|)
expr_stmt|;
name|node
operator|=
name|osm_get_node_by_guid
argument_list|(
name|pm
operator|->
name|subn
argument_list|,
name|cl_hton64
argument_list|(
name|mon_node
operator|->
name|guid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 5407: Node \"%s\" (guid 0x%"
name|PRIx64
literal|") no longer exists so removing from PerfMgr monitoring\n"
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|)
expr_stmt|;
name|mark_for_removal
argument_list|(
name|pm
argument_list|,
name|mon_node
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|num_ports
operator|=
name|osm_node_get_num_physp
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node_guid
operator|=
name|cl_ntoh64
argument_list|(
name|node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|)
expr_stmt|;
comment|/* make sure there is a database object ready to store this info */
if|if
condition|(
name|perfmgr_db_create_entry
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|node_guid
argument_list|,
name|mon_node
operator|->
name|esp0
argument_list|,
name|num_ports
argument_list|,
name|node
operator|->
name|print_desc
argument_list|)
operator|!=
name|PERFMGR_EVENT_DB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 5408: DB create entry failed for 0x%"
name|PRIx64
literal|" (%s) : %s\n"
argument_list|,
name|node_guid
argument_list|,
name|node
operator|->
name|print_desc
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|perfmgr_db_mark_active
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|node_guid
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* issue the query for each port */
for|for
control|(
name|port
operator|=
name|mon_node
operator|->
name|esp0
condition|?
literal|0
else|:
literal|1
init|;
name|port
operator|<
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
name|ib_net16_t
name|lid
decl_stmt|;
if|if
condition|(
operator|!
name|osm_node_get_physp_ptr
argument_list|(
name|node
argument_list|,
name|port
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|valid
condition|)
continue|continue;
name|lid
operator|=
name|get_lid
argument_list|(
name|node
argument_list|,
name|port
argument_list|,
name|mon_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|lid
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"WARN: node 0x%"
name|PRIx64
literal|" port %d (%s): port out of range, skipping\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|)
argument_list|,
name|port
argument_list|,
name|node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|remote_qp
operator|=
name|get_qp
argument_list|(
name|mon_node
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|mad_context
operator|.
name|perfmgr_context
operator|.
name|node_guid
operator|=
name|node_guid
expr_stmt|;
name|mad_context
operator|.
name|perfmgr_context
operator|.
name|port
operator|=
name|port
expr_stmt|;
name|mad_context
operator|.
name|perfmgr_context
operator|.
name|mad_method
operator|=
name|IB_MAD_METHOD_GET
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|query_cpi
operator|&&
operator|!
name|mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|cpi_valid
condition|)
block|{
name|status
operator|=
name|perfmgr_send_cpi_mad
argument_list|(
name|pm
argument_list|,
name|lid
argument_list|,
name|remote_qp
argument_list|,
name|mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|pkey_ix
argument_list|,
name|port
argument_list|,
operator|&
name|mad_context
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME SL != 0 */
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 5410: "
literal|"Failed to issue ClassPortInfo query "
literal|"for node 0x%"
name|PRIx64
literal|" port %d (%s)\n"
argument_list|,
name|node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|,
name|port
argument_list|,
name|node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|mon_node
operator|->
name|node_type
operator|==
name|IB_NODE_TYPE_SWITCH
condition|)
goto|goto
name|Exit
goto|;
comment|/* only need to issue 1 CPI query 						for switches */
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ENABLE_OSM_PERF_MGR_PROFILE
name|gettimeofday
argument_list|(
operator|&
name|mad_context
operator|.
name|perfmgr_context
operator|.
name|query_start
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Getting stats for node 0x%"
name|PRIx64
literal|" port %d (lid %u) (%s)\n"
argument_list|,
name|node_guid
argument_list|,
name|port
argument_list|,
name|cl_ntoh16
argument_list|(
name|lid
argument_list|)
argument_list|,
name|node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
name|status
operator|=
name|perfmgr_send_pc_mad
argument_list|(
name|pm
argument_list|,
name|lid
argument_list|,
name|remote_qp
argument_list|,
name|mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|pkey_ix
argument_list|,
name|port
argument_list|,
name|IB_MAD_METHOD_GET
argument_list|,
literal|0xffff
argument_list|,
literal|1
argument_list|,
operator|&
name|mad_context
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME SL != 0 */
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 5409: "
literal|"Failed to issue port counter query for node 0x%"
name|PRIx64
literal|" port %d (%s)\n"
argument_list|,
name|node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|,
name|port
argument_list|,
name|node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pce_supported
argument_list|(
name|mon_node
argument_list|,
name|port
argument_list|)
condition|)
block|{
if|#
directive|if
name|ENABLE_OSM_PERF_MGR_PROFILE
name|gettimeofday
argument_list|(
operator|&
name|mad_context
operator|.
name|perfmgr_context
operator|.
name|query_start
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|status
operator|=
name|perfmgr_send_pce_mad
argument_list|(
name|pm
argument_list|,
name|lid
argument_list|,
name|remote_qp
argument_list|,
name|mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|pkey_ix
argument_list|,
name|port
argument_list|,
name|IB_MAD_METHOD_GET
argument_list|,
operator|&
name|mad_context
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME SL != 0 */
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 5417: Failed to issue "
literal|"port counter query for "
literal|"node 0x%"
name|PRIx64
literal|" port "
literal|"%d (%s)\n"
argument_list|,
name|node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|,
name|port
argument_list|,
name|node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Exit
label|:
name|cl_plock_release
argument_list|(
operator|&
name|pm
operator|->
name|osm
operator|->
name|lock
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Discovery stuff  * This code should not be here, but merged with main OpenSM  **********************************************************************/
end_comment

begin_function_decl
specifier|extern
name|int
name|wait_for_pending_transactions
parameter_list|(
name|osm_stats_t
modifier|*
name|stats
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|osm_drop_mgr_process
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|sweep_hop_1
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|osm_madw_context_t
name|context
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|osm_dr_path_t
name|hop_1_path
decl_stmt|;
name|ib_net64_t
name|port_guid
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|uint8_t
name|path_array
index|[
name|IB_SUBNET_PATH_HOPS_MAX
index|]
decl_stmt|;
name|uint8_t
name|num_ports
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_ext_physp
decl_stmt|;
name|port_guid
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|sm_port_guid
expr_stmt|;
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 5481: No SM port object\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p_node
operator|=
name|p_port
operator|->
name|p_node
expr_stmt|;
name|port_num
operator|=
name|ib_node_info_get_local_port_num
argument_list|(
operator|&
name|p_node
operator|->
name|node_info
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Probing hop 1 on local port %u\n"
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|path_array
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|path_array
argument_list|)
argument_list|)
expr_stmt|;
comment|/* the hop_1 operations depend on the type of our node. 	 * Currently - legal nodes that can host SM are SW and CA */
switch|switch
condition|(
name|osm_node_get_type
argument_list|(
name|p_node
argument_list|)
condition|)
block|{
case|case
name|IB_NODE_TYPE_CA
case|:
case|case
name|IB_NODE_TYPE_ROUTER
case|:
name|memset
argument_list|(
operator|&
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|ni_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|context
operator|.
name|ni_context
operator|.
name|port_num
operator|=
name|port_num
expr_stmt|;
name|path_array
index|[
literal|1
index|]
operator|=
name|port_num
expr_stmt|;
name|osm_dr_path_init
argument_list|(
operator|&
name|hop_1_path
argument_list|,
literal|1
argument_list|,
name|path_array
argument_list|)
expr_stmt|;
name|CL_PLOCK_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
operator|&
name|hop_1_path
argument_list|,
name|IB_MAD_ATTR_NODE_INFO
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 5482: "
literal|"Request for NodeInfo failed\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_NODE_TYPE_SWITCH
case|:
comment|/* Need to go over all the ports of the switch, and send a node_info 		 * from them. This doesn't include the port 0 of the switch, which 		 * hosts the SM. 		 * Note: We'll send another switchInfo on port 0, since if no ports 		 * are connected, we still want to get some response, and have the 		 * subnet come up. 		 */
name|num_ports
operator|=
name|osm_node_get_num_physp
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
for|for
control|(
name|port_num
operator|=
literal|0
init|;
name|port_num
operator|<
name|num_ports
condition|;
name|port_num
operator|++
control|)
block|{
comment|/* go through the port only if the port is not DOWN */
name|p_ext_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ext_physp
operator|||
name|ib_port_info_get_port_state
argument_list|(
operator|&
name|p_ext_physp
operator|->
name|port_info
argument_list|)
operator|<=
name|IB_LINK_DOWN
condition|)
continue|continue;
name|memset
argument_list|(
operator|&
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|ni_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|context
operator|.
name|ni_context
operator|.
name|port_num
operator|=
name|port_num
expr_stmt|;
name|path_array
index|[
literal|1
index|]
operator|=
name|port_num
expr_stmt|;
name|osm_dr_path_init
argument_list|(
operator|&
name|hop_1_path
argument_list|,
literal|1
argument_list|,
name|path_array
argument_list|)
expr_stmt|;
name|CL_PLOCK_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
operator|&
name|hop_1_path
argument_list|,
name|IB_MAD_ATTR_NODE_INFO
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 5484: "
literal|"Request for NodeInfo failed\n"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 5483: Unknown node type %d\n"
argument_list|,
name|osm_node_get_type
argument_list|(
name|p_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|is_sm_port_down
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|ib_net64_t
name|port_guid
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|port_guid
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|sm_port_guid
expr_stmt|;
if|if
condition|(
name|port_guid
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|CL_PLOCK_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
block|{
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 5485: "
literal|"SM port with GUID:%016"
name|PRIx64
literal|" is unknown\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_port
operator|->
name|p_node
operator|->
name|sw
operator|&&
operator|!
name|ib_switch_info_is_enhanced_port0
argument_list|(
operator|&
name|p_port
operator|->
name|p_node
operator|->
name|sw
operator|->
name|switch_info
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* base SP0 */
return|return
name|osm_physp_get_port_state
argument_list|(
name|p_port
operator|->
name|p_physp
argument_list|)
operator|==
name|IB_LINK_DOWN
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sweep_hop_0
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|ib_api_status_t
name|status
decl_stmt|;
name|osm_dr_path_t
name|dr_path
decl_stmt|;
name|osm_bind_handle_t
name|h_bind
decl_stmt|;
name|uint8_t
name|path_array
index|[
name|IB_SUBNET_PATH_HOPS_MAX
index|]
decl_stmt|;
name|memset
argument_list|(
name|path_array
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|path_array
argument_list|)
argument_list|)
expr_stmt|;
name|h_bind
operator|=
name|osm_sm_mad_ctrl_get_bind_handle
argument_list|(
operator|&
name|sm
operator|->
name|mad_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|h_bind
operator|==
name|OSM_BIND_INVALID_HANDLE
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"No bound ports\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|osm_dr_path_init
argument_list|(
operator|&
name|dr_path
argument_list|,
literal|0
argument_list|,
name|path_array
argument_list|)
expr_stmt|;
name|CL_PLOCK_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
operator|&
name|dr_path
argument_list|,
name|IB_MAD_ATTR_NODE_INFO
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 5486: Request for NodeInfo failed\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|reset_node_count
parameter_list|(
name|cl_map_item_t
modifier|*
name|p_map_item
parameter_list|,
name|void
modifier|*
name|cxt
parameter_list|)
block|{
name|osm_node_t
modifier|*
name|p_node
init|=
operator|(
name|osm_node_t
operator|*
operator|)
name|p_map_item
decl_stmt|;
name|p_node
operator|->
name|discovery_count
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|p_node
operator|->
name|physp_discovered
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|*
name|p_node
operator|->
name|physp_tbl_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|reset_port_count
parameter_list|(
name|cl_map_item_t
modifier|*
name|p_map_item
parameter_list|,
name|void
modifier|*
name|cxt
parameter_list|)
block|{
name|osm_port_t
modifier|*
name|p_port
init|=
operator|(
name|osm_port_t
operator|*
operator|)
name|p_map_item
decl_stmt|;
name|p_port
operator|->
name|discovery_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|reset_switch_count
parameter_list|(
name|cl_map_item_t
modifier|*
name|p_map_item
parameter_list|,
name|void
modifier|*
name|cxt
parameter_list|)
block|{
name|osm_switch_t
modifier|*
name|p_sw
init|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|p_map_item
decl_stmt|;
name|p_sw
operator|->
name|need_update
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|perfmgr_discovery
parameter_list|(
name|osm_opensm_t
modifier|*
name|osm
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|CL_PLOCK_ACQUIRE
argument_list|(
operator|&
name|osm
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cl_qmap_apply_func
argument_list|(
operator|&
name|osm
operator|->
name|subn
operator|.
name|node_guid_tbl
argument_list|,
name|reset_node_count
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cl_qmap_apply_func
argument_list|(
operator|&
name|osm
operator|->
name|subn
operator|.
name|port_guid_tbl
argument_list|,
name|reset_port_count
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cl_qmap_apply_func
argument_list|(
operator|&
name|osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|,
name|reset_switch_count
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
operator|&
name|osm
operator|->
name|lock
argument_list|)
expr_stmt|;
name|osm
operator|->
name|subn
operator|.
name|in_sweep_hop_0
operator|=
name|TRUE
expr_stmt|;
name|ret
operator|=
name|sweep_hop_0
argument_list|(
operator|&
name|osm
operator|->
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|_exit
goto|;
if|if
condition|(
name|wait_for_pending_transactions
argument_list|(
operator|&
name|osm
operator|->
name|stats
argument_list|)
condition|)
goto|goto
name|_exit
goto|;
if|if
condition|(
name|is_sm_port_down
argument_list|(
operator|&
name|osm
operator|->
name|sm
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"SM port is down\n"
argument_list|)
expr_stmt|;
goto|goto
name|_drop
goto|;
block|}
name|osm
operator|->
name|subn
operator|.
name|in_sweep_hop_0
operator|=
name|FALSE
expr_stmt|;
name|ret
operator|=
name|sweep_hop_1
argument_list|(
operator|&
name|osm
operator|->
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|_exit
goto|;
if|if
condition|(
name|wait_for_pending_transactions
argument_list|(
operator|&
name|osm
operator|->
name|stats
argument_list|)
condition|)
goto|goto
name|_exit
goto|;
name|_drop
label|:
name|osm_drop_mgr_process
argument_list|(
operator|&
name|osm
operator|->
name|sm
argument_list|)
expr_stmt|;
name|_exit
label|:
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Main PerfMgr processor - query the performance counters  **********************************************************************/
end_comment

begin_function
name|void
name|osm_perfmgr_process
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_OSM_PERF_MGR_PROFILE
name|struct
name|timeval
name|before
decl_stmt|,
name|after
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pm
operator|->
name|state
operator|!=
name|PERFMGR_STATE_ENABLED
condition|)
return|return;
name|cl_spinlock_acquire
argument_list|(
operator|&
name|pm
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|sweep_state
operator|==
name|PERFMGR_SWEEP_ACTIVE
operator|||
name|pm
operator|->
name|sweep_state
operator|==
name|PERFMGR_SWEEP_SUSPENDED
operator|||
name|pm
operator|->
name|sweep_state
operator|==
name|PERFMGR_SWEEP_POST_PROCESSING
condition|)
block|{
name|cl_spinlock_release
argument_list|(
operator|&
name|pm
operator|->
name|lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"PM sweep state %d, skipping sweep\n"
argument_list|,
name|pm
operator|->
name|sweep_state
argument_list|)
expr_stmt|;
return|return;
block|}
name|pm
operator|->
name|sweep_state
operator|=
name|PERFMGR_SWEEP_ACTIVE
expr_stmt|;
name|cl_spinlock_release
argument_list|(
operator|&
name|pm
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|subn
operator|->
name|sm_state
operator|==
name|IB_SMINFO_STATE_STANDBY
operator|||
name|pm
operator|->
name|subn
operator|->
name|sm_state
operator|==
name|IB_SMINFO_STATE_NOTACTIVE
condition|)
name|perfmgr_discovery
argument_list|(
name|pm
operator|->
name|subn
operator|->
name|p_osm
argument_list|)
expr_stmt|;
comment|/* if redirection enabled, determine local port */
if|if
condition|(
name|pm
operator|->
name|subn
operator|->
name|opt
operator|.
name|perfmgr_redir
operator|&&
name|pm
operator|->
name|local_port
operator|==
operator|-
literal|1
condition|)
block|{
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|CL_PLOCK_ACQUIRE
argument_list|(
name|pm
operator|->
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|pm
operator|->
name|subn
argument_list|,
name|pm
operator|->
name|port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_port
condition|)
block|{
name|p_node
operator|=
name|p_port
operator|->
name|p_node
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|pm
operator|->
name|local_port
operator|=
name|ib_node_info_get_local_port_num
argument_list|(
operator|&
name|p_node
operator|->
name|node_info
argument_list|)
expr_stmt|;
block|}
else|else
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 5487: No PerfMgr port object for "
literal|"port GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|pm
operator|->
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|pm
operator|->
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ENABLE_OSM_PERF_MGR_PROFILE
name|gettimeofday
argument_list|(
operator|&
name|before
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* With the global lock held, collect the node guids */
comment|/* FIXME we should be able to track SA notices 	 * and not have to sweep the node_guid_tbl each pass 	 */
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Gathering PerfMgr stats\n"
argument_list|)
expr_stmt|;
name|cl_plock_acquire
argument_list|(
operator|&
name|pm
operator|->
name|osm
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cl_qmap_apply_func
argument_list|(
operator|&
name|pm
operator|->
name|subn
operator|->
name|node_guid_tbl
argument_list|,
name|collect_guids
argument_list|,
name|pm
argument_list|)
expr_stmt|;
name|cl_plock_release
argument_list|(
operator|&
name|pm
operator|->
name|osm
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* then for each node query their counters */
name|cl_qmap_apply_func
argument_list|(
operator|&
name|pm
operator|->
name|monitored_map
argument_list|,
name|perfmgr_query_counters
argument_list|,
name|pm
argument_list|)
expr_stmt|;
comment|/* clean out any nodes found to be removed during the sweep */
name|remove_marked_nodes
argument_list|(
name|pm
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_OSM_PERF_MGR_PROFILE
name|gettimeofday
argument_list|(
operator|&
name|after
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|diff_time
argument_list|(
operator|&
name|before
argument_list|,
operator|&
name|after
argument_list|,
operator|&
name|after
argument_list|)
expr_stmt|;
name|osm_log_v2
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
name|FILE_ID
argument_list|,
literal|"PerfMgr total sweep time : %ld.%06ld s\n"
literal|"        fastest mad      : %g us\n"
literal|"        slowest mad      : %g us\n"
literal|"        average mad      : %g us\n"
argument_list|,
name|after
operator|.
name|tv_sec
argument_list|,
name|after
operator|.
name|tv_usec
argument_list|,
name|perfmgr_mad_stats
operator|.
name|fastest_us
argument_list|,
name|perfmgr_mad_stats
operator|.
name|slowest_us
argument_list|,
name|perfmgr_mad_stats
operator|.
name|avg_us
argument_list|)
expr_stmt|;
name|clear_mad_stats
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|cl_spinlock_acquire
argument_list|(
operator|&
name|pm
operator|->
name|lock
argument_list|)
expr_stmt|;
name|pm
operator|->
name|sweep_state
operator|=
name|PERFMGR_SWEEP_SLEEP
expr_stmt|;
name|cl_spinlock_release
argument_list|(
operator|&
name|pm
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * PerfMgr timer - loop continuously and signal SM to run PerfMgr  * processor if enabled  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|perfmgr_sweep
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|osm_perfmgr_t
modifier|*
name|pm
init|=
name|arg
decl_stmt|;
name|osm_sm_signal
argument_list|(
name|pm
operator|->
name|sm
argument_list|,
name|OSM_SIGNAL_PERFMGR_SWEEP
argument_list|)
expr_stmt|;
name|cl_timer_start
argument_list|(
operator|&
name|pm
operator|->
name|sweep_timer
argument_list|,
name|pm
operator|->
name|sweep_time_s
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_perfmgr_shutdown
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|)
block|{
name|OSM_LOG_ENTER
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
name|cl_timer_stop
argument_list|(
operator|&
name|pm
operator|->
name|sweep_timer
argument_list|)
expr_stmt|;
name|cl_disp_unregister
argument_list|(
name|pm
operator|->
name|pc_disp_h
argument_list|)
expr_stmt|;
name|perfmgr_mad_unbind
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_perfmgr_destroy
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|)
block|{
name|OSM_LOG_ENTER
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
name|perfmgr_db_destroy
argument_list|(
name|pm
operator|->
name|db
argument_list|)
expr_stmt|;
name|cl_timer_destroy
argument_list|(
operator|&
name|pm
operator|->
name|sweep_timer
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Detect if someone else on the network could have cleared the counters  * without us knowing.  This is easy to detect because the counters never  * wrap but are "sticky".  *  * The one time this will not work is if the port is getting errors fast  * enough to have the reading overtake the previous reading.  In this case,  * counters will be missed.  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|perfmgr_check_oob_clear
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|,
name|monitored_node_t
modifier|*
name|mon_node
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|perfmgr_db_err_reading_t
modifier|*
name|cr
parameter_list|)
block|{
name|perfmgr_db_err_reading_t
name|prev_err
decl_stmt|;
if|if
condition|(
name|perfmgr_db_get_prev_err
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|,
operator|&
name|prev_err
argument_list|)
operator|!=
name|PERFMGR_EVENT_DB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Failed to find previous "
literal|"error reading for %s (guid 0x%"
name|PRIx64
literal|") port %u\n"
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return;
block|}
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Errors vs previous node %s (0x%"
name|PRIx64
literal|") port %u\n"
literal|"SE:   %"
name|PRIu64
literal|" ?< %"
name|PRIu64
literal|"\n"
literal|"LE:   %"
name|PRIu64
literal|" ?< %"
name|PRIu64
literal|"\n"
literal|"LD:   %"
name|PRIu64
literal|" ?< %"
name|PRIu64
literal|"\n"
literal|"RE:   %"
name|PRIu64
literal|" ?< %"
name|PRIu64
literal|"\n"
literal|"RPE:  %"
name|PRIu64
literal|" ?< %"
name|PRIu64
literal|"\n"
literal|"SRE:  %"
name|PRIu64
literal|" ?< %"
name|PRIu64
literal|"\n"
literal|"XD:   %"
name|PRIu64
literal|" ?< %"
name|PRIu64
literal|"\n"
literal|"XCE:  %"
name|PRIu64
literal|" ?< %"
name|PRIu64
literal|"\n"
literal|"RCE:  %"
name|PRIu64
literal|" ?< %"
name|PRIu64
literal|"\n"
literal|"LI:   %"
name|PRIu64
literal|" ?< %"
name|PRIu64
literal|"\n"
literal|"BO:   %"
name|PRIu64
literal|" ?< %"
name|PRIu64
literal|"\n"
literal|"VL15: %"
name|PRIu64
literal|" ?< %"
name|PRIu64
literal|"\n"
literal|"XW:   %"
name|PRIu64
literal|" ?< %"
name|PRIu64
literal|"\n"
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|,
name|cr
operator|->
name|symbol_err_cnt
argument_list|,
name|prev_err
operator|.
name|symbol_err_cnt
argument_list|,
name|cr
operator|->
name|link_err_recover
argument_list|,
name|prev_err
operator|.
name|link_err_recover
argument_list|,
name|cr
operator|->
name|link_downed
argument_list|,
name|prev_err
operator|.
name|link_downed
argument_list|,
name|cr
operator|->
name|rcv_err
argument_list|,
name|prev_err
operator|.
name|rcv_err
argument_list|,
name|cr
operator|->
name|rcv_rem_phys_err
argument_list|,
name|prev_err
operator|.
name|rcv_rem_phys_err
argument_list|,
name|cr
operator|->
name|rcv_switch_relay_err
argument_list|,
name|prev_err
operator|.
name|rcv_switch_relay_err
argument_list|,
name|cr
operator|->
name|xmit_discards
argument_list|,
name|prev_err
operator|.
name|xmit_discards
argument_list|,
name|cr
operator|->
name|xmit_constraint_err
argument_list|,
name|prev_err
operator|.
name|xmit_constraint_err
argument_list|,
name|cr
operator|->
name|rcv_constraint_err
argument_list|,
name|prev_err
operator|.
name|rcv_constraint_err
argument_list|,
name|cr
operator|->
name|link_integrity
argument_list|,
name|prev_err
operator|.
name|link_integrity
argument_list|,
name|cr
operator|->
name|buffer_overrun
argument_list|,
name|prev_err
operator|.
name|buffer_overrun
argument_list|,
name|cr
operator|->
name|vl15_dropped
argument_list|,
name|prev_err
operator|.
name|vl15_dropped
argument_list|,
name|cr
operator|->
name|xmit_wait
argument_list|,
name|prev_err
operator|.
name|xmit_wait
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
operator|->
name|symbol_err_cnt
operator|<
name|prev_err
operator|.
name|symbol_err_cnt
operator|||
name|cr
operator|->
name|link_err_recover
operator|<
name|prev_err
operator|.
name|link_err_recover
operator|||
name|cr
operator|->
name|link_downed
operator|<
name|prev_err
operator|.
name|link_downed
operator|||
name|cr
operator|->
name|rcv_err
operator|<
name|prev_err
operator|.
name|rcv_err
operator|||
name|cr
operator|->
name|rcv_rem_phys_err
operator|<
name|prev_err
operator|.
name|rcv_rem_phys_err
operator|||
name|cr
operator|->
name|rcv_switch_relay_err
operator|<
name|prev_err
operator|.
name|rcv_switch_relay_err
operator|||
name|cr
operator|->
name|xmit_discards
operator|<
name|prev_err
operator|.
name|xmit_discards
operator|||
name|cr
operator|->
name|xmit_constraint_err
operator|<
name|prev_err
operator|.
name|xmit_constraint_err
operator|||
name|cr
operator|->
name|rcv_constraint_err
operator|<
name|prev_err
operator|.
name|rcv_constraint_err
operator|||
name|cr
operator|->
name|link_integrity
operator|<
name|prev_err
operator|.
name|link_integrity
operator|||
name|cr
operator|->
name|buffer_overrun
operator|<
name|prev_err
operator|.
name|buffer_overrun
operator|||
name|cr
operator|->
name|vl15_dropped
operator|<
name|prev_err
operator|.
name|vl15_dropped
operator|||
name|cr
operator|->
name|xmit_wait
operator|<
name|prev_err
operator|.
name|xmit_wait
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"PerfMgr: ERR 540A: "
literal|"Detected an out of band error clear "
literal|"on %s (0x%"
name|PRIx64
literal|") port %u\n"
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|perfmgr_db_clear_prev_err
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**********************************************************************  * Return 1 if the value is "close" to overflowing  * "close" is defined at 25% for now  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|counter_overflow_4
parameter_list|(
name|uint8_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|val
operator|>=
literal|10
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|counter_overflow_8
parameter_list|(
name|uint8_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|val
operator|>=
operator|(
name|UINT8_MAX
operator|-
operator|(
name|UINT8_MAX
operator|/
literal|4
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|counter_overflow_16
parameter_list|(
name|ib_net16_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|cl_ntoh16
argument_list|(
name|val
argument_list|)
operator|>=
operator|(
name|UINT16_MAX
operator|-
operator|(
name|UINT16_MAX
operator|/
literal|4
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|counter_overflow_32
parameter_list|(
name|ib_net32_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|cl_ntoh32
argument_list|(
name|val
argument_list|)
operator|>=
operator|(
name|UINT32_MAX
operator|-
operator|(
name|UINT32_MAX
operator|/
literal|4
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|counter_overflow_64
parameter_list|(
name|ib_net64_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|cl_ntoh64
argument_list|(
name|val
argument_list|)
operator|>=
operator|(
name|UINT64_MAX
operator|-
operator|(
name|UINT64_MAX
operator|/
literal|4
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Check if the port counters have overflowed and if so issue a clear  * MAD to the port  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|perfmgr_check_overflow
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|,
name|monitored_node_t
modifier|*
name|mon_node
parameter_list|,
name|int16_t
name|pkey_ix
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|ib_port_counters_t
modifier|*
name|pc
parameter_list|,
name|boolean_t
name|xmit_wait_sup
parameter_list|)
block|{
name|osm_madw_context_t
name|mad_context
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|ib_net32_t
name|remote_qp
decl_stmt|;
name|uint16_t
name|counter_select
decl_stmt|;
name|uint8_t
name|counter_select2
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|counter_overflow_16
argument_list|(
name|pc
operator|->
name|symbol_err_cnt
argument_list|)
operator|||
name|counter_overflow_8
argument_list|(
name|pc
operator|->
name|link_err_recover
argument_list|)
operator|||
name|counter_overflow_8
argument_list|(
name|pc
operator|->
name|link_downed
argument_list|)
operator|||
name|counter_overflow_16
argument_list|(
name|pc
operator|->
name|rcv_err
argument_list|)
operator|||
name|counter_overflow_16
argument_list|(
name|pc
operator|->
name|rcv_rem_phys_err
argument_list|)
operator|||
name|counter_overflow_16
argument_list|(
name|pc
operator|->
name|rcv_switch_relay_err
argument_list|)
operator|||
name|counter_overflow_16
argument_list|(
name|pc
operator|->
name|xmit_discards
argument_list|)
operator|||
name|counter_overflow_8
argument_list|(
name|pc
operator|->
name|xmit_constraint_err
argument_list|)
operator|||
name|counter_overflow_8
argument_list|(
name|pc
operator|->
name|rcv_constraint_err
argument_list|)
operator|||
name|counter_overflow_4
argument_list|(
name|PC_LINK_INT
argument_list|(
name|pc
operator|->
name|link_int_buffer_overrun
argument_list|)
argument_list|)
operator|||
name|counter_overflow_4
argument_list|(
name|PC_BUF_OVERRUN
argument_list|(
name|pc
operator|->
name|link_int_buffer_overrun
argument_list|)
argument_list|)
operator|||
name|counter_overflow_16
argument_list|(
name|pc
operator|->
name|vl15_dropped
argument_list|)
operator|||
operator|(
name|xmit_wait_sup
operator|&&
name|counter_overflow_32
argument_list|(
name|pc
operator|->
name|xmit_wait
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|pce_supported
argument_list|(
name|mon_node
argument_list|,
name|port
argument_list|)
operator|&&
operator|(
name|counter_overflow_32
argument_list|(
name|pc
operator|->
name|xmit_data
argument_list|)
operator|||
name|counter_overflow_32
argument_list|(
name|pc
operator|->
name|rcv_data
argument_list|)
operator|||
name|counter_overflow_32
argument_list|(
name|pc
operator|->
name|xmit_pkts
argument_list|)
operator|||
name|counter_overflow_32
argument_list|(
name|pc
operator|->
name|rcv_pkts
argument_list|)
operator|)
operator|)
condition|)
block|{
name|osm_node_t
modifier|*
name|p_node
init|=
name|NULL
decl_stmt|;
name|ib_net16_t
name|lid
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|valid
condition|)
goto|goto
name|Exit
goto|;
name|osm_log_v2
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
name|FILE_ID
argument_list|,
literal|"PerfMgr: Counter overflow: %s (0x%"
name|PRIx64
literal|") port %d; clearing counters\n"
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|cl_plock_acquire
argument_list|(
operator|&
name|pm
operator|->
name|osm
operator|->
name|lock
argument_list|)
expr_stmt|;
name|p_node
operator|=
name|osm_get_node_by_guid
argument_list|(
name|pm
operator|->
name|subn
argument_list|,
name|cl_hton64
argument_list|(
name|mon_node
operator|->
name|guid
argument_list|)
argument_list|)
expr_stmt|;
name|lid
operator|=
name|get_lid
argument_list|(
name|p_node
argument_list|,
name|port
argument_list|,
name|mon_node
argument_list|)
expr_stmt|;
name|cl_plock_release
argument_list|(
operator|&
name|pm
operator|->
name|osm
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|lid
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"PerfMgr: ERR 540C: "
literal|"Failed to clear counters for %s (0x%"
name|PRIx64
literal|") port %d; failed to get lid\n"
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|remote_qp
operator|=
name|get_qp
argument_list|(
name|NULL
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|mad_context
operator|.
name|perfmgr_context
operator|.
name|node_guid
operator|=
name|mon_node
operator|->
name|guid
expr_stmt|;
name|mad_context
operator|.
name|perfmgr_context
operator|.
name|port
operator|=
name|port
expr_stmt|;
name|mad_context
operator|.
name|perfmgr_context
operator|.
name|mad_method
operator|=
name|IB_MAD_METHOD_SET
expr_stmt|;
comment|/* apparently some HW uses the same counters for the 32 and 64 		 * bit versions and a clear of them in the PortCounters 		 * attribute also clears the ExtendedPortCounters equivalant 		 * counters 		 */
if|if
condition|(
name|pce_supported
argument_list|(
name|mon_node
argument_list|,
name|port
argument_list|)
condition|)
name|counter_select
operator|=
literal|0x0fff
expr_stmt|;
else|else
name|counter_select
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|xmit_wait_sup
condition|)
name|counter_select2
operator|=
literal|1
expr_stmt|;
else|else
name|counter_select2
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|perfmgr_send_pc_mad
argument_list|(
name|pm
argument_list|,
name|lid
argument_list|,
name|remote_qp
argument_list|,
name|pkey_ix
argument_list|,
name|port
argument_list|,
name|IB_MAD_METHOD_SET
argument_list|,
name|counter_select
argument_list|,
name|counter_select2
argument_list|,
operator|&
name|mad_context
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME SL != 0 */
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"PerfMgr: ERR 5411: "
literal|"Failed to send clear counters MAD for %s (0x%"
name|PRIx64
literal|") port %d\n"
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|perfmgr_db_clear_prev_err
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pce_supported
argument_list|(
name|mon_node
argument_list|,
name|port
argument_list|)
condition|)
name|perfmgr_db_clear_prev_dc
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Check if the port counters have overflowed and if so issue a clear  * MAD to the port  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|perfmgr_check_pce_overflow
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|,
name|monitored_node_t
modifier|*
name|mon_node
parameter_list|,
name|int16_t
name|pkey_ix
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|ib_port_counters_ext_t
modifier|*
name|pc
parameter_list|)
block|{
name|osm_madw_context_t
name|mad_context
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|ib_net32_t
name|remote_qp
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|counter_overflow_64
argument_list|(
name|pc
operator|->
name|xmit_data
argument_list|)
operator|||
name|counter_overflow_64
argument_list|(
name|pc
operator|->
name|rcv_data
argument_list|)
operator|||
name|counter_overflow_64
argument_list|(
name|pc
operator|->
name|xmit_pkts
argument_list|)
operator|||
name|counter_overflow_64
argument_list|(
name|pc
operator|->
name|rcv_pkts
argument_list|)
operator|||
operator|(
name|ietf_supported
argument_list|(
name|mon_node
argument_list|,
name|port
argument_list|)
operator|&&
operator|(
name|counter_overflow_64
argument_list|(
name|pc
operator|->
name|unicast_xmit_pkts
argument_list|)
operator|||
name|counter_overflow_64
argument_list|(
name|pc
operator|->
name|unicast_rcv_pkts
argument_list|)
operator|||
name|counter_overflow_64
argument_list|(
name|pc
operator|->
name|multicast_xmit_pkts
argument_list|)
operator|||
name|counter_overflow_64
argument_list|(
name|pc
operator|->
name|multicast_rcv_pkts
argument_list|)
operator|)
operator|)
condition|)
block|{
name|osm_node_t
modifier|*
name|p_node
init|=
name|NULL
decl_stmt|;
name|ib_net16_t
name|lid
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|valid
condition|)
goto|goto
name|Exit
goto|;
name|osm_log
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"PerfMgr: PortCountersExtended overflow: %s (0x%"
name|PRIx64
literal|") port %d; clearing counters\n"
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|cl_plock_acquire
argument_list|(
operator|&
name|pm
operator|->
name|osm
operator|->
name|lock
argument_list|)
expr_stmt|;
name|p_node
operator|=
name|osm_get_node_by_guid
argument_list|(
name|pm
operator|->
name|subn
argument_list|,
name|cl_hton64
argument_list|(
name|mon_node
operator|->
name|guid
argument_list|)
argument_list|)
expr_stmt|;
name|lid
operator|=
name|get_lid
argument_list|(
name|p_node
argument_list|,
name|port
argument_list|,
name|mon_node
argument_list|)
expr_stmt|;
name|cl_plock_release
argument_list|(
operator|&
name|pm
operator|->
name|osm
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|lid
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"PerfMgr: ERR 5418: "
literal|"Failed to clear counters for %s (0x%"
name|PRIx64
literal|") port %d; failed to get lid\n"
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|remote_qp
operator|=
name|get_qp
argument_list|(
name|NULL
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|mad_context
operator|.
name|perfmgr_context
operator|.
name|node_guid
operator|=
name|mon_node
operator|->
name|guid
expr_stmt|;
name|mad_context
operator|.
name|perfmgr_context
operator|.
name|port
operator|=
name|port
expr_stmt|;
name|mad_context
operator|.
name|perfmgr_context
operator|.
name|mad_method
operator|=
name|IB_MAD_METHOD_SET
expr_stmt|;
comment|/* clear port counters */
name|status
operator|=
name|perfmgr_send_pce_mad
argument_list|(
name|pm
argument_list|,
name|lid
argument_list|,
name|remote_qp
argument_list|,
name|pkey_ix
argument_list|,
name|port
argument_list|,
name|IB_MAD_METHOD_SET
argument_list|,
operator|&
name|mad_context
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME SL != 0 */
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"PerfMgr: ERR 5419: "
literal|"Failed to send clear counters MAD for %s (0x%"
name|PRIx64
literal|") port %d\n"
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|perfmgr_db_clear_prev_dc
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Check values for logging of errors  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|perfmgr_log_errors
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|,
name|monitored_node_t
modifier|*
name|mon_node
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|perfmgr_db_err_reading_t
modifier|*
name|reading
parameter_list|)
block|{
name|perfmgr_db_err_reading_t
name|prev_read
decl_stmt|;
name|perfmgr_db_err_t
name|err
init|=
name|perfmgr_db_get_prev_err
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|,
operator|&
name|prev_read
argument_list|)
decl_stmt|;
name|uint64_t
name|cur
decl_stmt|,
name|prev
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|PERFMGR_EVENT_DB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Failed to find previous "
literal|"reading for %s (0x%"
name|PRIx64
literal|") port %u\n"
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return;
block|}
define|#
directive|define
name|LOG_ERR_CNT
parameter_list|(
name|errname
parameter_list|,
name|errnum
parameter_list|,
name|counter_name
parameter_list|)
define|\
value|if (reading->counter_name> prev_read.counter_name) { \ 		if (mon_node->port[port].remote_valid == TRUE) \ 			OSM_LOG(pm->log, OSM_LOG_ERROR, "ERR %s: " \ 				"%s : %" PRIu64 " : node " \ 				"\"%s\" (NodeGUID: 0x%" PRIx64 ") : port %u " \ 				"connected to \"%s\" (NodeGUID: 0x%" PRIx64 ") : port %u\n", \ 				errnum, errname, \ 				reading->counter_name - prev_read.counter_name, \ 				mon_node->name, mon_node->guid, port, \ 				mon_node->port[port].remote_name, \ 				mon_node->port[port].remote_guid, \ 				mon_node->port[port].remote_port); \ 		else \ 			OSM_LOG(pm->log, OSM_LOG_ERROR, "ERR %s: " \ 				"%s : %" PRIu64 " : node " \ 				"\"%s\" (NodeGUID: 0x%" PRIx64 ") : port %u\n", \ 				errnum, errname, \ 				reading->counter_name - prev_read.counter_name, \ 				mon_node->name, mon_node->guid, port); \ 	}
name|LOG_ERR_CNT
argument_list|(
literal|"SymbolErrorCounter"
argument_list|,
literal|"5431"
argument_list|,
name|symbol_err_cnt
argument_list|)
expr_stmt|;
name|LOG_ERR_CNT
argument_list|(
literal|"LinkErrorRecoveryCounter"
argument_list|,
literal|"5432"
argument_list|,
name|link_err_recover
argument_list|)
expr_stmt|;
name|LOG_ERR_CNT
argument_list|(
literal|"LinkDownedCounter"
argument_list|,
literal|"5433"
argument_list|,
name|link_downed
argument_list|)
expr_stmt|;
name|LOG_ERR_CNT
argument_list|(
literal|"PortRcvErrors"
argument_list|,
literal|"5434"
argument_list|,
name|rcv_err
argument_list|)
expr_stmt|;
name|LOG_ERR_CNT
argument_list|(
literal|"PortRcvRemotePhysicalErrors"
argument_list|,
literal|"5435"
argument_list|,
name|rcv_rem_phys_err
argument_list|)
expr_stmt|;
name|LOG_ERR_CNT
argument_list|(
literal|"PortRcvSwitchRelayErrors"
argument_list|,
literal|"5436"
argument_list|,
name|rcv_switch_relay_err
argument_list|)
expr_stmt|;
name|LOG_ERR_CNT
argument_list|(
literal|"PortXmitDiscards"
argument_list|,
literal|"5437"
argument_list|,
name|xmit_discards
argument_list|)
expr_stmt|;
name|LOG_ERR_CNT
argument_list|(
literal|"PortXmitConstraintErrors"
argument_list|,
literal|"5438"
argument_list|,
name|xmit_constraint_err
argument_list|)
expr_stmt|;
name|LOG_ERR_CNT
argument_list|(
literal|"PortRcvConstraintErrors"
argument_list|,
literal|"5439"
argument_list|,
name|rcv_constraint_err
argument_list|)
expr_stmt|;
name|LOG_ERR_CNT
argument_list|(
literal|"LocalLinkIntegrityErrors"
argument_list|,
literal|"543A"
argument_list|,
name|link_integrity
argument_list|)
expr_stmt|;
name|LOG_ERR_CNT
argument_list|(
literal|"ExcessiveBufferOverrunErrors"
argument_list|,
literal|"543B"
argument_list|,
name|buffer_overrun
argument_list|)
expr_stmt|;
name|LOG_ERR_CNT
argument_list|(
literal|"VL15Dropped"
argument_list|,
literal|"543C"
argument_list|,
name|vl15_dropped
argument_list|)
expr_stmt|;
name|cur
operator|=
name|reading
operator|->
name|xmit_wait
expr_stmt|;
name|prev
operator|=
name|prev_read
operator|.
name|xmit_wait
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|xmit_wait_log
operator|&&
name|cur
operator|>
name|prev
operator|&&
operator|(
name|cur
operator|-
name|prev
operator|)
operator|>=
name|pm
operator|->
name|xmit_wait_threshold
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 543D: XmitWait : %"
name|PRIu64
literal|" : node \"%s\" (NodeGUID: 0x%"
name|PRIx64
literal|") : port %u\n"
argument_list|,
name|cur
operator|-
name|prev
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int16_t
name|validate_redir_pkey
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|,
name|ib_net16_t
name|pkey
parameter_list|)
block|{
name|int16_t
name|pkey_ix
init|=
operator|-
literal|1
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|osm_pkey_tbl_t
modifier|*
name|p_pkey_tbl
decl_stmt|;
name|ib_net16_t
modifier|*
name|p_orig_pkey
decl_stmt|;
name|uint16_t
name|block
decl_stmt|;
name|uint8_t
name|index
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
name|CL_PLOCK_ACQUIRE
argument_list|(
name|pm
operator|->
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|pm
operator|->
name|subn
argument_list|,
name|pm
operator|->
name|port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
block|{
name|CL_PLOCK_RELEASE
argument_list|(
name|pm
operator|->
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 541E: No PerfMgr port object\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|p_port
operator|->
name|p_physp
operator|&&
name|osm_physp_is_valid
argument_list|(
name|p_port
operator|->
name|p_physp
argument_list|)
condition|)
block|{
name|p_pkey_tbl
operator|=
operator|&
name|p_port
operator|->
name|p_physp
operator|->
name|pkeys
expr_stmt|;
if|if
condition|(
operator|!
name|p_pkey_tbl
condition|)
block|{
name|CL_PLOCK_RELEASE
argument_list|(
name|pm
operator|->
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"No PKey table found for PerfMgr port\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_orig_pkey
operator|=
name|cl_map_get
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|keys
argument_list|,
name|ib_pkey_get_base
argument_list|(
name|pkey
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_orig_pkey
condition|)
block|{
name|CL_PLOCK_RELEASE
argument_list|(
name|pm
operator|->
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"PKey 0x%x not found for PerfMgr port\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|pkey
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|osm_pkey_tbl_get_block_and_idx
argument_list|(
name|p_pkey_tbl
argument_list|,
name|p_orig_pkey
argument_list|,
operator|&
name|block
argument_list|,
operator|&
name|index
argument_list|)
operator|==
name|IB_SUCCESS
condition|)
block|{
name|CL_PLOCK_RELEASE
argument_list|(
name|pm
operator|->
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|pkey_ix
operator|=
name|block
operator|*
name|IB_NUM_PKEY_ELEMENTS_IN_BLOCK
operator|+
name|index
expr_stmt|;
block|}
else|else
block|{
name|CL_PLOCK_RELEASE
argument_list|(
name|pm
operator|->
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 541F: Failed to obtain P_Key 0x%04x "
literal|"block and index for PerfMgr port\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|pkey
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|CL_PLOCK_RELEASE
argument_list|(
name|pm
operator|->
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 5420: Local PerfMgt port physp invalid\n"
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|pkey_ix
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|handle_redirect
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|,
name|ib_class_port_info_t
modifier|*
name|cpi
parameter_list|,
name|monitored_node_t
modifier|*
name|p_mon_node
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|osm_madw_context_t
modifier|*
name|mad_context
parameter_list|)
block|{
name|char
name|gid_str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|boolean_t
name|valid
init|=
name|TRUE
decl_stmt|;
name|int16_t
name|pkey_ix
init|=
literal|0
decl_stmt|;
name|uint8_t
name|mad_method
decl_stmt|;
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Redirection to LID %u GID %s QP 0x%x received\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|cpi
operator|->
name|redir_lid
argument_list|)
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|cpi
operator|->
name|redir_gid
operator|.
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
name|gid_str
argument_list|)
argument_list|,
name|cl_ntoh32
argument_list|(
name|cpi
operator|->
name|redir_qp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pm
operator|->
name|subn
operator|->
name|opt
operator|.
name|perfmgr_redir
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Redirection requested but disabled\n"
argument_list|)
expr_stmt|;
name|valid
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* valid redirection ? */
if|if
condition|(
name|cpi
operator|->
name|redir_lid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ib_gid_is_notzero
argument_list|(
operator|&
name|cpi
operator|->
name|redir_gid
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Invalid redirection "
literal|"(both redirect LID and GID are zero)\n"
argument_list|)
expr_stmt|;
name|valid
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cpi
operator|->
name|redir_qp
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Invalid RedirectQP\n"
argument_list|)
expr_stmt|;
name|valid
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|cpi
operator|->
name|redir_pkey
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Invalid RedirectP_Key\n"
argument_list|)
expr_stmt|;
name|valid
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|cpi
operator|->
name|redir_qkey
operator|!=
name|IB_QP1_WELL_KNOWN_Q_KEY
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Invalid RedirectQ_Key\n"
argument_list|)
expr_stmt|;
name|valid
operator|=
name|FALSE
expr_stmt|;
block|}
name|pkey_ix
operator|=
name|validate_redir_pkey
argument_list|(
name|pm
argument_list|,
name|cpi
operator|->
name|redir_pkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey_ix
operator|==
operator|-
literal|1
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Index for Pkey 0x%x not found\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|cpi
operator|->
name|redir_pkey
argument_list|)
argument_list|)
expr_stmt|;
name|valid
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|cpi
operator|->
name|redir_lid
operator|==
literal|0
condition|)
block|{
comment|/* GID redirection: get PathRecord information */
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"GID redirection not currently supported\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|!
name|valid
condition|)
goto|goto
name|Exit
goto|;
comment|/* LID redirection support (easier than GID redirection) */
name|cl_plock_acquire
argument_list|(
operator|&
name|pm
operator|->
name|osm
operator|->
name|lock
argument_list|)
expr_stmt|;
name|p_mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|redirection
operator|=
name|TRUE
expr_stmt|;
name|p_mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|valid
operator|=
name|valid
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|gid
argument_list|,
operator|&
name|cpi
operator|->
name|redir_gid
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_gid_t
argument_list|)
argument_list|)
expr_stmt|;
name|p_mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|lid
operator|=
name|cpi
operator|->
name|redir_lid
expr_stmt|;
name|p_mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|qp
operator|=
name|cpi
operator|->
name|redir_qp
expr_stmt|;
name|p_mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|pkey
operator|=
name|cpi
operator|->
name|redir_pkey
expr_stmt|;
if|if
condition|(
name|pkey_ix
operator|!=
operator|-
literal|1
condition|)
name|p_mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|pkey_ix
operator|=
name|pkey_ix
expr_stmt|;
name|cl_plock_release
argument_list|(
operator|&
name|pm
operator|->
name|osm
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* either */
if|if
condition|(
name|pm
operator|->
name|query_cpi
condition|)
block|{
comment|/* issue a CPI query to the redirected location */
name|mad_method
operator|=
name|IB_MAD_METHOD_GET
expr_stmt|;
name|p_mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|cpi_valid
operator|=
name|FALSE
expr_stmt|;
name|status
operator|=
name|perfmgr_send_cpi_mad
argument_list|(
name|pm
argument_list|,
name|cpi
operator|->
name|redir_lid
argument_list|,
name|cpi
operator|->
name|redir_qp
argument_list|,
name|pkey_ix
argument_list|,
name|port
argument_list|,
name|mad_context
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME SL != 0 */
block|}
else|else
block|{
comment|/* reissue the original query to the redirected location */
name|uint8_t
name|counter_select2
decl_stmt|;
if|if
condition|(
name|xmit_wait_supported
argument_list|(
name|p_mon_node
argument_list|,
name|port
argument_list|)
condition|)
name|counter_select2
operator|=
literal|1
expr_stmt|;
else|else
name|counter_select2
operator|=
literal|0
expr_stmt|;
name|mad_method
operator|=
name|mad_context
operator|->
name|perfmgr_context
operator|.
name|mad_method
expr_stmt|;
if|if
condition|(
name|mad_context
operator|->
name|perfmgr_context
operator|.
name|mad_attr_id
operator|==
name|IB_MAD_ATTR_PORT_CNTRS
condition|)
block|{
name|status
operator|=
name|perfmgr_send_pc_mad
argument_list|(
name|pm
argument_list|,
name|cpi
operator|->
name|redir_lid
argument_list|,
name|cpi
operator|->
name|redir_qp
argument_list|,
name|pkey_ix
argument_list|,
name|port
argument_list|,
name|mad_method
argument_list|,
literal|0xffff
argument_list|,
name|counter_select2
argument_list|,
name|mad_context
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME SL != 0 */
block|}
else|else
block|{
name|status
operator|=
name|perfmgr_send_pce_mad
argument_list|(
name|pm
argument_list|,
name|cpi
operator|->
name|redir_lid
argument_list|,
name|cpi
operator|->
name|redir_qp
argument_list|,
name|pkey_ix
argument_list|,
name|port
argument_list|,
name|mad_method
argument_list|,
name|mad_context
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME SL != 0 */
block|}
block|}
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 5414: "
literal|"Failed to send redirected MAD "
literal|"with method 0x%x for node %s "
literal|"(NodeGuid 0x%"
name|PRIx64
literal|") port %d\n"
argument_list|,
name|mad_method
argument_list|,
name|p_mon_node
operator|->
name|name
argument_list|,
name|p_mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
operator|(
name|valid
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Detect if someone else on the network could have cleared the counters  * without us knowing.  This is easy to detect because the counters never  * wrap but are "sticky" PortCountersExtended version.  *  * The one time this will not work is if the port is getting errors fast  * enough to have the reading overtake the previous reading.  In this case,  * counters will be missed.  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|perfmgr_check_data_cnt_oob_clear
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|,
name|monitored_node_t
modifier|*
name|mon_node
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|perfmgr_db_data_cnt_reading_t
modifier|*
name|dc
parameter_list|)
block|{
name|perfmgr_db_data_cnt_reading_t
name|prev_dc
decl_stmt|;
if|if
condition|(
name|perfmgr_db_get_prev_dc
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|,
operator|&
name|prev_dc
argument_list|)
operator|!=
name|PERFMGR_EVENT_DB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Failed to find previous data count "
literal|"reading for %s (0x%"
name|PRIx64
literal|") port %u\n"
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return;
block|}
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Data vs previous node %s (0x%"
name|PRIx64
literal|") port %u\n"
literal|"TX:    %"
name|PRIu64
literal|" ?< %"
name|PRIu64
literal|"\n"
literal|"RX:    %"
name|PRIu64
literal|" ?< %"
name|PRIu64
literal|"\n"
literal|"TXP:   %"
name|PRIu64
literal|" ?< %"
name|PRIu64
literal|"\n"
literal|"RXP:   %"
name|PRIu64
literal|" ?< %"
name|PRIu64
literal|"\n"
literal|"UTXP:  %"
name|PRIu64
literal|" ?< %"
name|PRIu64
literal|"\n"
literal|"URXP:  %"
name|PRIu64
literal|" ?< %"
name|PRIu64
literal|"\n"
literal|"MTXP:  %"
name|PRIu64
literal|" ?< %"
name|PRIu64
literal|"\n"
literal|"MRXP:  %"
name|PRIu64
literal|" ?< %"
name|PRIu64
literal|"\n"
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|,
name|dc
operator|->
name|xmit_data
argument_list|,
name|prev_dc
operator|.
name|xmit_data
argument_list|,
name|dc
operator|->
name|rcv_data
argument_list|,
name|prev_dc
operator|.
name|rcv_data
argument_list|,
name|dc
operator|->
name|xmit_pkts
argument_list|,
name|prev_dc
operator|.
name|xmit_pkts
argument_list|,
name|dc
operator|->
name|rcv_pkts
argument_list|,
name|prev_dc
operator|.
name|rcv_pkts
argument_list|,
name|dc
operator|->
name|unicast_xmit_pkts
argument_list|,
name|prev_dc
operator|.
name|unicast_xmit_pkts
argument_list|,
name|dc
operator|->
name|unicast_rcv_pkts
argument_list|,
name|prev_dc
operator|.
name|unicast_rcv_pkts
argument_list|,
name|dc
operator|->
name|multicast_xmit_pkts
argument_list|,
name|prev_dc
operator|.
name|multicast_xmit_pkts
argument_list|,
name|dc
operator|->
name|multicast_rcv_pkts
argument_list|,
name|prev_dc
operator|.
name|multicast_rcv_pkts
argument_list|)
expr_stmt|;
if|if
condition|(
name|dc
operator|->
name|xmit_data
operator|<
name|prev_dc
operator|.
name|xmit_data
operator|||
name|dc
operator|->
name|rcv_data
operator|<
name|prev_dc
operator|.
name|rcv_data
operator|||
name|dc
operator|->
name|xmit_pkts
operator|<
name|prev_dc
operator|.
name|xmit_pkts
operator|||
name|dc
operator|->
name|rcv_pkts
operator|<
name|prev_dc
operator|.
name|rcv_pkts
operator|||
operator|(
name|ietf_supported
argument_list|(
name|mon_node
argument_list|,
name|port
argument_list|)
operator|&&
operator|(
name|dc
operator|->
name|unicast_xmit_pkts
operator|<
name|prev_dc
operator|.
name|unicast_xmit_pkts
operator|||
name|dc
operator|->
name|unicast_rcv_pkts
operator|<
name|prev_dc
operator|.
name|unicast_rcv_pkts
operator|||
name|dc
operator|->
name|multicast_xmit_pkts
operator|<
name|prev_dc
operator|.
name|multicast_xmit_pkts
operator|||
name|dc
operator|->
name|multicast_rcv_pkts
operator|<
name|prev_dc
operator|.
name|multicast_rcv_pkts
operator|)
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"PerfMgr: ERR 540B: Detected an out of band data counter "
literal|"clear on node %s (0x%"
name|PRIx64
literal|") port %u\n"
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|perfmgr_db_clear_prev_dc
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**********************************************************************  * The dispatcher uses a thread pool which will call this function when  * there is a thread available to process the mad received on the wire  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|pc_recv_process
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|osm_perfmgr_t
modifier|*
name|pm
init|=
name|context
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_madw
init|=
name|data
decl_stmt|;
name|osm_madw_context_t
modifier|*
name|mad_context
init|=
operator|&
name|p_madw
operator|->
name|context
decl_stmt|;
name|ib_mad_t
modifier|*
name|p_mad
init|=
name|osm_madw_get_mad_ptr
argument_list|(
name|p_madw
argument_list|)
decl_stmt|;
name|uint64_t
name|node_guid
init|=
name|mad_context
operator|->
name|perfmgr_context
operator|.
name|node_guid
decl_stmt|;
name|uint8_t
name|port
init|=
name|mad_context
operator|->
name|perfmgr_context
operator|.
name|port
decl_stmt|;
name|perfmgr_db_err_reading_t
name|err_reading
decl_stmt|;
name|perfmgr_db_data_cnt_reading_t
name|data_reading
decl_stmt|;
name|cl_map_item_t
modifier|*
name|p_node
decl_stmt|;
name|monitored_node_t
modifier|*
name|p_mon_node
decl_stmt|;
name|ib_class_port_info_t
modifier|*
name|cpi
init|=
name|NULL
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
comment|/* 	 * get the monitored node struct to have the printable name 	 * for log messages 	 */
if|if
condition|(
operator|(
name|p_node
operator|=
name|cl_qmap_get
argument_list|(
operator|&
name|pm
operator|->
name|monitored_map
argument_list|,
name|node_guid
argument_list|)
operator|)
operator|==
name|cl_qmap_end
argument_list|(
operator|&
name|pm
operator|->
name|monitored_map
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 5412: GUID 0x%016"
name|PRIx64
literal|" not found in monitored map\n"
argument_list|,
name|node_guid
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_mon_node
operator|=
operator|(
name|monitored_node_t
operator|*
operator|)
name|p_node
expr_stmt|;
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Processing received MAD status 0x%x context 0x%"
name|PRIx64
literal|" port %u\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_mad
operator|->
name|status
argument_list|)
argument_list|,
name|node_guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_mad
operator|->
name|attr_id
operator|==
name|IB_MAD_ATTR_PORT_CNTRS
operator|||
name|p_mad
operator|->
name|attr_id
operator|==
name|IB_MAD_ATTR_PORT_CNTRS_EXT
operator|||
name|p_mad
operator|->
name|attr_id
operator|==
name|IB_MAD_ATTR_CLASS_PORT_INFO
argument_list|)
expr_stmt|;
name|cl_plock_acquire
argument_list|(
operator|&
name|pm
operator|->
name|osm
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* validate port number */
if|if
condition|(
name|port
operator|>=
name|p_mon_node
operator|->
name|num_ports
condition|)
block|{
name|cl_plock_release
argument_list|(
operator|&
name|pm
operator|->
name|osm
operator|->
name|lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 5413: "
literal|"Invalid port num %d for GUID 0x%016"
name|PRIx64
literal|" num ports %d\n"
argument_list|,
name|port
argument_list|,
name|node_guid
argument_list|,
name|p_mon_node
operator|->
name|num_ports
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|cl_plock_release
argument_list|(
operator|&
name|pm
operator|->
name|osm
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* capture CLASS_PORT_INFO data */
if|if
condition|(
name|p_mad
operator|->
name|attr_id
operator|==
name|IB_MAD_ATTR_CLASS_PORT_INFO
condition|)
block|{
name|boolean_t
name|cpi_valid
init|=
name|TRUE
decl_stmt|;
name|cpi
operator|=
operator|(
name|ib_class_port_info_t
operator|*
operator|)
operator|&
operator|(
name|osm_madw_get_perfmgt_mad_ptr
argument_list|(
name|p_madw
argument_list|)
operator|->
name|data
operator|)
expr_stmt|;
comment|/* Response could be redirection (IBM eHCA PMA does this) */
if|if
condition|(
name|p_mad
operator|->
name|status
operator|&
name|IB_MAD_STATUS_REDIRECT
condition|)
name|cpi_valid
operator|=
name|handle_redirect
argument_list|(
name|pm
argument_list|,
name|cpi
argument_list|,
name|p_mon_node
argument_list|,
name|port
argument_list|,
name|mad_context
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|query_cpi
operator|&&
name|cpi_valid
condition|)
block|{
name|cl_plock_acquire
argument_list|(
operator|&
name|pm
operator|->
name|osm
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_mon_node
operator|->
name|node_type
operator|==
name|IB_NODE_TYPE_SWITCH
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|p_mon_node
operator|->
name|esp0
condition|?
literal|0
else|:
literal|1
init|;
name|i
operator|<
name|p_mon_node
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|p_mon_node
operator|->
name|port
index|[
name|i
index|]
operator|.
name|cap_mask
operator|=
name|cpi
operator|->
name|cap_mask
expr_stmt|;
name|p_mon_node
operator|->
name|port
index|[
name|i
index|]
operator|.
name|cpi_valid
operator|=
name|cpi_valid
expr_stmt|;
block|}
block|}
else|else
block|{
name|p_mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|cap_mask
operator|=
name|cpi
operator|->
name|cap_mask
expr_stmt|;
name|p_mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|cpi_valid
operator|=
name|cpi_valid
expr_stmt|;
block|}
name|cl_plock_release
argument_list|(
operator|&
name|pm
operator|->
name|osm
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|p_mad
operator|->
name|attr_id
operator|==
name|IB_MAD_ATTR_PORT_CNTRS_EXT
condition|)
block|{
name|ib_port_counters_ext_t
modifier|*
name|ext_wire_read
init|=
operator|(
name|ib_port_counters_ext_t
operator|*
operator|)
operator|&
name|osm_madw_get_perfmgt_mad_ptr
argument_list|(
name|p_madw
argument_list|)
operator|->
name|data
decl_stmt|;
comment|/* convert wire data to perfmgr data counter reading */
name|perfmgr_db_fill_data_cnt_read_pce
argument_list|(
name|ext_wire_read
argument_list|,
operator|&
name|data_reading
argument_list|,
name|ietf_supported
argument_list|(
name|p_mon_node
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
comment|/* add counter */
if|if
condition|(
name|mad_context
operator|->
name|perfmgr_context
operator|.
name|mad_method
operator|==
name|IB_MAD_METHOD_GET
condition|)
block|{
comment|/* detect an out of band clear on the port */
name|perfmgr_check_data_cnt_oob_clear
argument_list|(
name|pm
argument_list|,
name|p_mon_node
argument_list|,
name|port
argument_list|,
operator|&
name|data_reading
argument_list|)
expr_stmt|;
name|perfmgr_db_add_dc_reading
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|node_guid
argument_list|,
name|port
argument_list|,
operator|&
name|data_reading
argument_list|,
name|ietf_supported
argument_list|(
name|p_mon_node
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|perfmgr_db_clear_prev_dc
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|node_guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
name|perfmgr_check_pce_overflow
argument_list|(
name|pm
argument_list|,
name|p_mon_node
argument_list|,
name|p_mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|pkey_ix
argument_list|,
name|port
argument_list|,
name|ext_wire_read
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|boolean_t
name|pce_sup
init|=
name|pce_supported
argument_list|(
name|p_mon_node
argument_list|,
name|port
argument_list|)
decl_stmt|;
name|boolean_t
name|xmit_wait_sup
init|=
name|xmit_wait_supported
argument_list|(
name|p_mon_node
argument_list|,
name|port
argument_list|)
decl_stmt|;
name|ib_port_counters_t
modifier|*
name|wire_read
init|=
operator|(
name|ib_port_counters_t
operator|*
operator|)
operator|&
name|osm_madw_get_perfmgt_mad_ptr
argument_list|(
name|p_madw
argument_list|)
operator|->
name|data
decl_stmt|;
name|perfmgr_db_fill_err_read
argument_list|(
name|wire_read
argument_list|,
operator|&
name|err_reading
argument_list|,
name|xmit_wait_sup
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pce_sup
condition|)
name|perfmgr_db_fill_data_cnt_read_pc
argument_list|(
name|wire_read
argument_list|,
operator|&
name|data_reading
argument_list|)
expr_stmt|;
if|if
condition|(
name|mad_context
operator|->
name|perfmgr_context
operator|.
name|mad_method
operator|==
name|IB_MAD_METHOD_GET
condition|)
block|{
comment|/* detect an out of band clear on the port */
name|perfmgr_check_oob_clear
argument_list|(
name|pm
argument_list|,
name|p_mon_node
argument_list|,
name|port
argument_list|,
operator|&
name|err_reading
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pce_sup
condition|)
name|perfmgr_check_data_cnt_oob_clear
argument_list|(
name|pm
argument_list|,
name|p_mon_node
argument_list|,
name|port
argument_list|,
operator|&
name|data_reading
argument_list|)
expr_stmt|;
comment|/* log errors from this reading */
if|if
condition|(
name|pm
operator|->
name|subn
operator|->
name|opt
operator|.
name|perfmgr_log_errors
condition|)
name|perfmgr_log_errors
argument_list|(
name|pm
argument_list|,
name|p_mon_node
argument_list|,
name|port
argument_list|,
operator|&
name|err_reading
argument_list|)
expr_stmt|;
name|perfmgr_db_add_err_reading
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|node_guid
argument_list|,
name|port
argument_list|,
operator|&
name|err_reading
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pce_sup
condition|)
name|perfmgr_db_add_dc_reading
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|node_guid
argument_list|,
name|port
argument_list|,
operator|&
name|data_reading
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|perfmgr_db_clear_prev_err
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|node_guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pce_sup
condition|)
name|perfmgr_db_clear_prev_dc
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|node_guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
name|perfmgr_check_overflow
argument_list|(
name|pm
argument_list|,
name|p_mon_node
argument_list|,
name|p_mon_node
operator|->
name|port
index|[
name|port
index|]
operator|.
name|pkey_ix
argument_list|,
name|port
argument_list|,
name|wire_read
argument_list|,
name|xmit_wait_sup
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ENABLE_OSM_PERF_MGR_PROFILE
do|do
block|{
name|struct
name|timeval
name|proc_time
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|proc_time
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|diff_time
argument_list|(
operator|&
name|p_madw
operator|->
name|context
operator|.
name|perfmgr_context
operator|.
name|query_start
argument_list|,
operator|&
name|proc_time
argument_list|,
operator|&
name|proc_time
argument_list|)
expr_stmt|;
name|update_mad_stats
argument_list|(
operator|&
name|proc_time
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
endif|#
directive|endif
name|Exit
label|:
name|osm_mad_pool_put
argument_list|(
name|pm
operator|->
name|mad_pool
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Initialize the PerfMgr object  **********************************************************************/
end_comment

begin_function
name|ib_api_status_t
name|osm_perfmgr_init
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|,
name|osm_opensm_t
modifier|*
name|osm
parameter_list|,
specifier|const
name|osm_subn_opt_t
modifier|*
name|p_opt
parameter_list|)
block|{
name|ib_api_status_t
name|status
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Initializing PerfMgr\n"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|pm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pm
argument_list|)
argument_list|)
expr_stmt|;
name|pm
operator|->
name|subn
operator|=
operator|&
name|osm
operator|->
name|subn
expr_stmt|;
name|pm
operator|->
name|sm
operator|=
operator|&
name|osm
operator|->
name|sm
expr_stmt|;
name|pm
operator|->
name|log
operator|=
operator|&
name|osm
operator|->
name|log
expr_stmt|;
name|pm
operator|->
name|mad_pool
operator|=
operator|&
name|osm
operator|->
name|mad_pool
expr_stmt|;
name|pm
operator|->
name|vendor
operator|=
name|osm
operator|->
name|p_vendor
expr_stmt|;
name|pm
operator|->
name|trans_id
operator|=
name|PERFMGR_INITIAL_TID_VALUE
expr_stmt|;
name|pm
operator|->
name|state
operator|=
name|p_opt
operator|->
name|perfmgr
condition|?
name|PERFMGR_STATE_ENABLED
else|:
name|PERFMGR_STATE_DISABLE
expr_stmt|;
name|pm
operator|->
name|sweep_state
operator|=
name|PERFMGR_SWEEP_SLEEP
expr_stmt|;
name|cl_spinlock_init
argument_list|(
operator|&
name|pm
operator|->
name|lock
argument_list|)
expr_stmt|;
name|pm
operator|->
name|sweep_time_s
operator|=
name|p_opt
operator|->
name|perfmgr_sweep_time_s
expr_stmt|;
name|pm
operator|->
name|max_outstanding_queries
operator|=
name|p_opt
operator|->
name|perfmgr_max_outstanding_queries
expr_stmt|;
name|pm
operator|->
name|ignore_cas
operator|=
name|p_opt
operator|->
name|perfmgr_ignore_cas
expr_stmt|;
name|pm
operator|->
name|osm
operator|=
name|osm
expr_stmt|;
name|pm
operator|->
name|local_port
operator|=
operator|-
literal|1
expr_stmt|;
name|status
operator|=
name|cl_timer_init
argument_list|(
operator|&
name|pm
operator|->
name|sweep_timer
argument_list|,
name|perfmgr_sweep
argument_list|,
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
name|status
operator|=
name|IB_INSUFFICIENT_RESOURCES
expr_stmt|;
name|pm
operator|->
name|db
operator|=
name|perfmgr_db_construct
argument_list|(
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pm
operator|->
name|db
condition|)
block|{
name|pm
operator|->
name|state
operator|=
name|PERFMGR_STATE_NO_DB
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|pm
operator|->
name|pc_disp_h
operator|=
name|cl_disp_register
argument_list|(
operator|&
name|osm
operator|->
name|disp
argument_list|,
name|OSM_MSG_MAD_PORT_COUNTERS
argument_list|,
name|pc_recv_process
argument_list|,
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|pc_disp_h
operator|==
name|CL_DISP_INVALID_HANDLE
condition|)
block|{
name|perfmgr_db_destroy
argument_list|(
name|pm
operator|->
name|db
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|init_monitored_nodes
argument_list|(
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|state
operator|==
name|PERFMGR_STATE_ENABLED
condition|)
name|cl_timer_start
argument_list|(
operator|&
name|pm
operator|->
name|sweep_timer
argument_list|,
name|pm
operator|->
name|sweep_time_s
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|pm
operator|->
name|rm_nodes
operator|=
name|p_opt
operator|->
name|perfmgr_rm_nodes
expr_stmt|;
name|pm
operator|->
name|query_cpi
operator|=
name|p_opt
operator|->
name|perfmgr_query_cpi
expr_stmt|;
name|pm
operator|->
name|xmit_wait_log
operator|=
name|p_opt
operator|->
name|perfmgr_xmit_wait_log
expr_stmt|;
name|pm
operator|->
name|xmit_wait_threshold
operator|=
name|p_opt
operator|->
name|perfmgr_xmit_wait_threshold
expr_stmt|;
name|status
operator|=
name|IB_SUCCESS
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Clear the counters from the db  **********************************************************************/
end_comment

begin_function
name|void
name|osm_perfmgr_clear_counters
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|)
block|{
comment|/** 	 * FIXME todo issue clear on the fabric? 	 */
name|perfmgr_db_clear_counters
argument_list|(
name|pm
operator|->
name|db
argument_list|)
expr_stmt|;
name|osm_log_v2
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
name|FILE_ID
argument_list|,
literal|"PerfMgr counters cleared\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************  * Dump the DB information to the file specified  *******************************************************************/
end_comment

begin_function
name|void
name|osm_perfmgr_dump_counters
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|,
name|perfmgr_db_dump_t
name|dump_type
parameter_list|)
block|{
name|char
name|path
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|file_name
decl_stmt|;
if|if
condition|(
name|pm
operator|->
name|subn
operator|->
name|opt
operator|.
name|event_db_dump_file
condition|)
name|file_name
operator|=
name|pm
operator|->
name|subn
operator|->
name|opt
operator|.
name|event_db_dump_file
expr_stmt|;
else|else
block|{
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|pm
operator|->
name|subn
operator|->
name|opt
operator|.
name|dump_files_dir
argument_list|,
name|OSM_PERFMGR_DEFAULT_DUMP_FILE
argument_list|)
expr_stmt|;
name|file_name
operator|=
name|path
expr_stmt|;
block|}
if|if
condition|(
name|perfmgr_db_dump
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|file_name
argument_list|,
name|dump_type
argument_list|)
operator|!=
literal|0
condition|)
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"Failed to dump file %s : %s"
argument_list|,
name|file_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************  * Print the DB information to the fp specified  *******************************************************************/
end_comment

begin_function
name|void
name|osm_perfmgr_print_counters
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|,
name|char
modifier|*
name|nodename
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
name|port
parameter_list|,
name|int
name|err_only
parameter_list|)
block|{
if|if
condition|(
name|nodename
condition|)
block|{
name|char
modifier|*
name|end
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|guid
init|=
name|strtoull
argument_list|(
name|nodename
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodename
operator|+
name|strlen
argument_list|(
name|nodename
argument_list|)
operator|!=
name|end
condition|)
name|perfmgr_db_print_by_name
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|nodename
argument_list|,
name|fp
argument_list|,
name|port
argument_list|,
name|err_only
argument_list|)
expr_stmt|;
else|else
name|perfmgr_db_print_by_guid
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|guid
argument_list|,
name|fp
argument_list|,
name|port
argument_list|,
name|err_only
argument_list|)
expr_stmt|;
block|}
else|else
name|perfmgr_db_print_all
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|fp
argument_list|,
name|err_only
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_perfmgr_update_nodename
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|,
name|uint64_t
name|node_guid
parameter_list|,
name|char
modifier|*
name|nodename
parameter_list|)
block|{
if|if
condition|(
name|pm
operator|->
name|db
condition|)
name|perfmgr_db_update_name
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|node_guid
argument_list|,
name|nodename
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENABLE_OSM_PERF_MGR */
end_comment

end_unit

