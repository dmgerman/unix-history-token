begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2015 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  * Copyright (c) 2009 HNR Consulting. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_ni_rcv_t.  * This object represents the NodeInfo Receiver object.  * This object is part of the opensm family of objects.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qmap.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_passivelock.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_NODE_INFO_RCV_C
end_define

begin_include
include|#
directive|include
file|<opensm/osm_madw.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_node.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_subnet.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_router.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_mad_pool.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_msgdef.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_ucast_mgr.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_db_pack.h>
end_include

begin_function
specifier|static
name|void
name|report_duplicated_guid
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|osm_physp_t
modifier|*
name|p_physp
parameter_list|,
name|osm_node_t
modifier|*
name|p_neighbor_node
parameter_list|,
specifier|const
name|uint8_t
name|port_num
parameter_list|)
block|{
name|osm_physp_t
modifier|*
name|p_old
decl_stmt|,
modifier|*
name|p_new
decl_stmt|;
name|osm_dr_path_t
name|path
decl_stmt|;
name|p_old
operator|=
name|p_physp
operator|->
name|p_remote_physp
expr_stmt|;
name|p_new
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_neighbor_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_SYS
operator||
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D01: "
literal|"Found duplicated node GUID.\n"
literal|"Node 0x%"
name|PRIx64
literal|" port %u is reachable from remote node "
literal|"0x%"
name|PRIx64
literal|" port %u and remote node 0x%"
name|PRIx64
literal|" port %u.\n"
literal|"Paths are:\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_physp
operator|->
name|p_node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|)
argument_list|,
name|p_physp
operator|->
name|port_num
argument_list|,
name|p_old
condition|?
name|cl_ntoh64
argument_list|(
name|p_old
operator|->
name|p_node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|)
else|:
literal|0
argument_list|,
name|p_old
condition|?
name|p_old
operator|->
name|port_num
else|:
literal|0
argument_list|,
name|p_new
condition|?
name|cl_ntoh64
argument_list|(
name|p_new
operator|->
name|p_node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|)
else|:
literal|0
argument_list|,
name|p_new
condition|?
name|p_new
operator|->
name|port_num
else|:
literal|0
argument_list|)
expr_stmt|;
name|osm_dump_dr_path_v2
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
argument_list|,
name|FILE_ID
argument_list|,
name|OSM_LOG_ERROR
argument_list|)
expr_stmt|;
name|path
operator|=
operator|*
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_new
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_dr_path_extend
argument_list|(
operator|&
name|path
argument_list|,
name|port_num
argument_list|)
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D05: "
literal|"DR path with hop count %d couldn't be extended\n"
argument_list|,
name|path
operator|.
name|hop_count
argument_list|)
expr_stmt|;
name|osm_dump_dr_path_v2
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
operator|&
name|path
argument_list|,
name|FILE_ID
argument_list|,
name|OSM_LOG_ERROR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|requery_dup_node_info
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|osm_physp_t
modifier|*
name|p_physp
parameter_list|,
name|unsigned
name|count
parameter_list|)
block|{
name|osm_madw_context_t
name|context
decl_stmt|;
name|osm_dr_path_t
name|path
decl_stmt|;
name|cl_status_t
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|p_physp
operator|->
name|p_remote_physp
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D0D: "
literal|"DR path couldn't be extended due to NULL remote physp\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|path
operator|=
operator|*
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
operator|->
name|p_remote_physp
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_dr_path_extend
argument_list|(
operator|&
name|path
argument_list|,
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|port_num
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D08: "
literal|"DR path with hop count %d couldn't be extended\n"
argument_list|,
name|path
operator|.
name|hop_count
argument_list|)
expr_stmt|;
return|return;
block|}
name|context
operator|.
name|ni_context
operator|.
name|node_guid
operator|=
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|p_node
operator|->
name|node_info
operator|.
name|port_guid
expr_stmt|;
name|context
operator|.
name|ni_context
operator|.
name|port_num
operator|=
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|port_num
expr_stmt|;
name|context
operator|.
name|ni_context
operator|.
name|dup_node_guid
operator|=
name|p_physp
operator|->
name|p_node
operator|->
name|node_info
operator|.
name|node_guid
expr_stmt|;
name|context
operator|.
name|ni_context
operator|.
name|dup_port_num
operator|=
name|p_physp
operator|->
name|port_num
expr_stmt|;
name|context
operator|.
name|ni_context
operator|.
name|dup_count
operator|=
name|count
expr_stmt|;
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
operator|&
name|path
argument_list|,
name|IB_MAD_ATTR_NODE_INFO
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D02: "
literal|"Failure initiating NodeInfo request (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  The plock must be held before calling this function. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ni_rcv_set_links
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|osm_node_t
modifier|*
name|p_node
parameter_list|,
specifier|const
name|uint8_t
name|port_num
parameter_list|,
specifier|const
name|osm_ni_context_t
modifier|*
name|p_ni_context
parameter_list|)
block|{
name|osm_node_t
modifier|*
name|p_neighbor_node
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|,
modifier|*
name|p_remote_physp
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	   A special case exists in which the node we're trying to 	   link is our own node.  In this case, the guid value in 	   the ni_context will be zero. 	 */
if|if
condition|(
name|p_ni_context
operator|->
name|node_guid
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Nothing to link for our own node 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|_exit
goto|;
block|}
name|p_neighbor_node
operator|=
name|osm_get_node_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|p_ni_context
operator|->
name|node_guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF
argument_list|(
operator|!
name|p_neighbor_node
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D10: "
literal|"Unexpected removal of neighbor node 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni_context
operator|->
name|node_guid
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|_exit
goto|;
block|}
comment|/* When setting the link, ports on both 	   sides of the link should be initialized */
name|CL_ASSERT
argument_list|(
name|osm_node_link_has_valid_ports
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|,
name|p_neighbor_node
argument_list|,
name|p_ni_context
operator|->
name|port_num
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_node_link_exists
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|,
name|p_neighbor_node
argument_list|,
name|p_ni_context
operator|->
name|port_num
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Link already exists\n"
argument_list|)
expr_stmt|;
goto|goto
name|_exit
goto|;
block|}
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR OD0E: "
literal|"Failed to find physp for port %d of Node GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|port_num
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|_exit
goto|;
block|}
comment|/* 	 * If the link went UP, after we already discovered it, we shouldn't 	 * set the link between the ports and resweep. 	 */
if|if
condition|(
name|osm_physp_get_port_state
argument_list|(
name|p_physp
argument_list|)
operator|==
name|IB_LINK_DOWN
operator|&&
name|p_node
operator|->
name|physp_discovered
index|[
name|port_num
index|]
condition|)
block|{
comment|/* Link down on another side. Don't create a link*/
name|p_node
operator|->
name|physp_discovered
index|[
name|port_num
index|]
operator|=
literal|0
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|force_heavy_sweep
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|_exit
goto|;
block|}
if|if
condition|(
name|osm_node_has_any_link
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
operator|&&
name|sm
operator|->
name|p_subn
operator|->
name|force_heavy_sweep
operator|==
name|FALSE
operator|&&
operator|(
operator|!
name|p_ni_context
operator|->
name|dup_count
operator|||
operator|(
name|p_ni_context
operator|->
name|dup_node_guid
operator|==
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
operator|&&
name|p_ni_context
operator|->
name|dup_port_num
operator|==
name|port_num
operator|)
operator|)
condition|)
block|{
comment|/* 		   Uh oh... 		   This could be reconnected ports, but also duplicated GUID 		   (2 nodes have the same guid) or a 12x link with lane reversal 		   that is not configured correctly. 		   We will try to recover by querying NodeInfo again. 		   In order to catch even fast port moving to new location(s) 		   and back we will count up to 5. 		   Some crazy reconnections (newly created switch loop right 		   before targeted CA) will not be catched this way. So in worst 		   case - report GUID duplication and request new discovery. 		   When switch node is targeted NodeInfo querying will be done 		   in opposite order, this is much stronger check, unfortunately 		   it is impossible with CAs. 		 */
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR OD0F: "
literal|"Failed to find physp for port %d of Node GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|port_num
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|_exit
goto|;
block|}
if|if
condition|(
name|p_ni_context
operator|->
name|dup_count
operator|>
literal|5
condition|)
block|{
name|report_duplicated_guid
argument_list|(
name|sm
argument_list|,
name|p_physp
argument_list|,
name|p_neighbor_node
argument_list|,
name|p_ni_context
operator|->
name|port_num
argument_list|)
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|force_heavy_sweep
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_node
operator|->
name|sw
condition|)
name|requery_dup_node_info
argument_list|(
name|sm
argument_list|,
name|p_physp
operator|->
name|p_remote_physp
argument_list|,
name|p_ni_context
operator|->
name|dup_count
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|requery_dup_node_info
argument_list|(
name|sm
argument_list|,
name|p_physp
argument_list|,
name|p_ni_context
operator|->
name|dup_count
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	   When there are only two nodes with exact same guids (connected back 	   to back) - the previous check for duplicated guid will not catch 	   them. But the link will be from the port to itself... 	   Enhanced Port 0 is an exception to this 	 */
if|if
condition|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
operator|==
name|p_ni_context
operator|->
name|node_guid
operator|&&
name|port_num
operator|==
name|p_ni_context
operator|->
name|port_num
operator|&&
name|port_num
operator|!=
literal|0
operator|&&
name|cl_qmap_count
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Duplicate GUID found by link from a port to itself:"
literal|"node 0x%"
name|PRIx64
literal|", port number %u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR OD1D: "
literal|"Failed to find physp for port %d of Node GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|port_num
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|_exit
goto|;
block|}
name|osm_dump_dr_path_v2
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
argument_list|,
name|FILE_ID
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|exit_on_fatal
operator|==
name|TRUE
condition|)
block|{
name|osm_log_v2
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
name|FILE_ID
argument_list|,
literal|"Errors on subnet. Duplicate GUID found "
literal|"by link from a port to itself. "
literal|"See verbose opensm.log for more details\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Creating new link between:\n\t\t\t\tnode 0x%"
name|PRIx64
literal|", port number %u and\n\t\t\t\tnode 0x%"
name|PRIx64
literal|", port number %u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|port_num
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni_context
operator|->
name|node_guid
argument_list|)
argument_list|,
name|p_ni_context
operator|->
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|ucast_mgr
operator|.
name|cache_valid
condition|)
name|osm_ucast_cache_check_new_link
argument_list|(
operator|&
name|sm
operator|->
name|ucast_mgr
argument_list|,
name|p_node
argument_list|,
name|port_num
argument_list|,
name|p_neighbor_node
argument_list|,
name|p_ni_context
operator|->
name|port_num
argument_list|)
expr_stmt|;
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|p_remote_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_neighbor_node
argument_list|,
name|p_ni_context
operator|->
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
operator|||
operator|!
name|p_remote_physp
condition|)
goto|goto
name|_exit
goto|;
name|osm_node_link
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|,
name|p_neighbor_node
argument_list|,
name|p_ni_context
operator|->
name|port_num
argument_list|)
expr_stmt|;
name|osm_db_neighbor_set
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_neighbor
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_physp
argument_list|)
argument_list|)
argument_list|,
name|port_num
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_remote_physp
argument_list|)
argument_list|)
argument_list|,
name|p_ni_context
operator|->
name|port_num
argument_list|)
expr_stmt|;
name|osm_db_neighbor_set
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_neighbor
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_remote_physp
argument_list|)
argument_list|)
argument_list|,
name|p_ni_context
operator|->
name|port_num
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_physp
argument_list|)
argument_list|)
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|_exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ni_rcv_get_port_info
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
name|node
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
name|madw
parameter_list|)
block|{
name|osm_madw_context_t
name|context
decl_stmt|;
name|osm_physp_t
modifier|*
name|physp
decl_stmt|;
name|ib_node_info_t
modifier|*
name|ni
decl_stmt|;
name|unsigned
name|port
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|int
name|mlnx_epi_supported
init|=
literal|0
decl_stmt|;
name|ni
operator|=
name|ib_smp_get_payload_ptr
argument_list|(
name|osm_madw_get_smp_ptr
argument_list|(
name|madw
argument_list|)
argument_list|)
expr_stmt|;
name|port
operator|=
name|ib_node_info_get_local_port_num
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|fdr10
condition|)
name|mlnx_epi_supported
operator|=
name|is_mlnx_ext_port_info_supported
argument_list|(
name|ib_node_info_get_vendor_id
argument_list|(
name|ni
argument_list|)
argument_list|,
name|ni
operator|->
name|device_id
argument_list|)
expr_stmt|;
name|physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|node
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|physp
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR OD1E: "
literal|"Failed to find physp for port %d of Node GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|port
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|context
operator|.
name|pi_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|port_guid
operator|=
name|osm_physp_get_port_guid
argument_list|(
name|physp
argument_list|)
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|set_method
operator|=
name|FALSE
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|light_sweep
operator|=
name|FALSE
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|active_transition
operator|=
name|FALSE
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|client_rereg
operator|=
name|FALSE
expr_stmt|;
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
name|osm_physp_get_dr_path_ptr
argument_list|(
name|physp
argument_list|)
argument_list|,
name|IB_MAD_ATTR_PORT_INFO
argument_list|,
name|cl_hton32
argument_list|(
name|port
argument_list|)
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR OD02: "
literal|"Failure initiating PortInfo request (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlnx_epi_supported
condition|)
block|{
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
name|osm_physp_get_dr_path_ptr
argument_list|(
name|physp
argument_list|)
argument_list|,
name|IB_MAD_ATTR_MLNX_EXTENDED_PORT_INFO
argument_list|,
name|cl_hton32
argument_list|(
name|port
argument_list|)
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D0B: "
literal|"Failure initiating MLNX ExtPortInfo request (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**********************************************************************  The plock must be held before calling this function. **********************************************************************/
end_comment

begin_function
name|void
name|osm_req_get_node_desc
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|osm_physp_t
modifier|*
name|p_physp
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|osm_madw_context_t
name|context
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|context
operator|.
name|nd_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|osm_physp_get_node_ptr
argument_list|(
name|p_physp
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
argument_list|,
name|IB_MAD_ATTR_NODE_DESC
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D03: "
literal|"Failure initiating NodeDescription request (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  The plock must be held before calling this function. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ni_rcv_get_node_desc
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
name|p_node
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|)
block|{
name|ib_node_info_t
modifier|*
name|p_ni
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
init|=
name|NULL
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_ni
operator|=
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
name|port_num
operator|=
name|ib_node_info_get_local_port_num
argument_list|(
name|p_ni
argument_list|)
expr_stmt|;
comment|/* 	   Request PortInfo& NodeDescription attributes for the port 	   that responded to the NodeInfo attribute. 	   Because this is a channel adapter or router, we are 	   not allowed to request PortInfo for the other ports. 	   Set the context union properly, so the recipient 	   knows which node& port are relevant. 	 */
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR OD1F: "
literal|"Failed to find physp for port %d of Node GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|port_num
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|osm_req_get_node_desc
argument_list|(
name|sm
argument_list|,
name|p_physp
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  The plock must be held before calling this function. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ni_rcv_process_new_ca_or_router
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
name|p_node
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|)
block|{
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|ni_rcv_get_port_info
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
comment|/* 	   A node guid of 0 is the corner case that indicates 	   we discovered our own node.  Initialize the subnet 	   object with the SM's own port guid. 	 */
if|if
condition|(
name|osm_madw_get_ni_context_ptr
argument_list|(
name|p_madw
argument_list|)
operator|->
name|node_guid
operator|==
literal|0
condition|)
name|sm
operator|->
name|p_subn
operator|->
name|sm_port_guid
operator|=
name|p_node
operator|->
name|node_info
operator|.
name|port_guid
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  The plock must be held before calling this function. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ni_rcv_process_existing_ca_or_router
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
name|p_node
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|)
block|{
name|ib_node_info_t
modifier|*
name|p_ni
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port_check
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|osm_dr_path_t
modifier|*
name|p_dr_path
decl_stmt|;
name|osm_alias_guid_t
modifier|*
name|p_alias_guid
decl_stmt|,
modifier|*
name|p_alias_guid_check
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_ni
operator|=
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
name|port_num
operator|=
name|ib_node_info_get_local_port_num
argument_list|(
name|p_ni
argument_list|)
expr_stmt|;
comment|/* 	   Determine if we have encountered this node through a 	   previously undiscovered port.  If so, build the new 	   port object. 	 */
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|p_ni
operator|->
name|port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Creating new port object with GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni
operator|->
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
name|osm_node_init_physp
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
name|p_port
operator|=
name|osm_port_new
argument_list|(
name|p_ni
argument_list|,
name|p_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF
argument_list|(
name|p_port
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D04: "
literal|"Unable to create new port object\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 		   Add the new port object to the database. 		 */
name|p_port_check
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_insert
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|port_guid_tbl
argument_list|,
name|p_ni
operator|->
name|port_guid
argument_list|,
operator|&
name|p_port
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF
argument_list|(
name|p_port_check
operator|!=
name|p_port
argument_list|)
condition|)
block|{
comment|/* 			   We should never be here! 			   Somehow, this port GUID already exists in the table. 			 */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D12: "
literal|"Port 0x%"
name|PRIx64
literal|" already in the database!\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni
operator|->
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
name|osm_port_delete
argument_list|(
operator|&
name|p_port
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_alias_guid
operator|=
name|osm_alias_guid_new
argument_list|(
name|p_ni
operator|->
name|port_guid
argument_list|,
name|p_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF
argument_list|(
operator|!
name|p_alias_guid
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D11: "
literal|"alias guid memory allocation failed"
literal|" for port GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni
operator|->
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|alias_done
goto|;
block|}
comment|/* insert into alias guid table */
name|p_alias_guid_check
operator|=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_insert
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|alias_port_guid_tbl
argument_list|,
name|p_alias_guid
operator|->
name|alias_guid
argument_list|,
operator|&
name|p_alias_guid
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_alias_guid_check
operator|!=
name|p_alias_guid
condition|)
block|{
comment|/* alias GUID is a duplicate */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D13: "
literal|"Duplicate alias port GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni
operator|->
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
name|osm_alias_guid_delete
argument_list|(
operator|&
name|p_alias_guid
argument_list|)
expr_stmt|;
name|osm_port_delete
argument_list|(
operator|&
name|p_port
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|alias_done
label|:
comment|/* If we are a master, then this means the port is new on the subnet. 		   Mark it as new - need to send trap 64 for these ports. 		   The condition that we are master is true, since if we are in discovering 		   state (meaning we woke up from standby or we are just initializing), 		   then these ports may be new to us, but are not new on the subnet. 		   If we are master, then the subnet as we know it is the updated one, 		   and any new ports we encounter should cause trap 64. C14-72.1.1 */
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
operator|==
name|IB_SMINFO_STATE_MASTER
condition|)
name|p_port
operator|->
name|is_new
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|osm_physp_t
modifier|*
name|p_physp
init|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
decl_stmt|;
if|if
condition|(
name|PF
argument_list|(
name|p_physp
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D1C: "
literal|"No physical port found for node GUID 0x%"
name|PRIx64
literal|" port %u. Might be duplicate port GUID\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|)
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 		   Update the DR Path to the port, 		   in case the old one is no longer available. 		 */
name|p_dr_path
operator|=
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|osm_dr_path_init
argument_list|(
name|p_dr_path
argument_list|,
name|p_smp
operator|->
name|hop_count
argument_list|,
name|p_smp
operator|->
name|initial_path
argument_list|)
expr_stmt|;
block|}
name|ni_rcv_get_port_info
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ni_rcv_process_switch
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
name|p_node
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|osm_madw_context_t
name|context
decl_stmt|;
name|osm_dr_path_t
modifier|*
name|path
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* update DR path of already initialized switch port 0 */
name|path
operator|=
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|osm_dr_path_init
argument_list|(
name|path
argument_list|,
name|p_smp
operator|->
name|hop_count
argument_list|,
name|p_smp
operator|->
name|initial_path
argument_list|)
expr_stmt|;
name|context
operator|.
name|si_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|context
operator|.
name|si_context
operator|.
name|set_method
operator|=
name|FALSE
expr_stmt|;
name|context
operator|.
name|si_context
operator|.
name|light_sweep
operator|=
name|FALSE
expr_stmt|;
name|context
operator|.
name|si_context
operator|.
name|lft_top_change
operator|=
name|FALSE
expr_stmt|;
comment|/* Request a SwitchInfo attribute */
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
name|path
argument_list|,
name|IB_MAD_ATTR_SWITCH_INFO
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
comment|/* continue despite error */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D06: "
literal|"Failure initiating SwitchInfo request (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  The plock must be held before calling this function. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ni_rcv_process_existing_switch
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
name|p_node
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|)
block|{
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	   If this switch has already been probed during this sweep, 	   then don't bother reprobing it. 	 */
if|if
condition|(
name|p_node
operator|->
name|discovery_count
operator|==
literal|1
condition|)
name|ni_rcv_process_switch
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  The plock must be held before calling this function. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ni_rcv_process_new_switch
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
name|p_node
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|)
block|{
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|ni_rcv_process_switch
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
comment|/* 	   A node guid of 0 is the corner case that indicates 	   we discovered our own node.  Initialize the subnet 	   object with the SM's own port guid. 	 */
if|if
condition|(
name|osm_madw_get_ni_context_ptr
argument_list|(
name|p_madw
argument_list|)
operator|->
name|node_guid
operator|==
literal|0
condition|)
name|sm
operator|->
name|p_subn
operator|->
name|sm_port_guid
operator|=
name|p_node
operator|->
name|node_info
operator|.
name|port_guid
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  The plock must NOT be held before calling this function. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ni_rcv_process_new
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|)
block|{
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node_check
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port_check
decl_stmt|;
name|osm_router_t
modifier|*
name|p_rtr
init|=
name|NULL
decl_stmt|;
name|osm_router_t
modifier|*
name|p_rtr_check
decl_stmt|;
name|cl_qmap_t
modifier|*
name|p_rtr_guid_tbl
decl_stmt|;
name|ib_node_info_t
modifier|*
name|p_ni
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|osm_ni_context_t
modifier|*
name|p_ni_context
decl_stmt|;
name|osm_alias_guid_t
modifier|*
name|p_alias_guid
decl_stmt|,
modifier|*
name|p_alias_guid_check
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_ni
operator|=
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
name|p_ni_context
operator|=
name|osm_madw_get_ni_context_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|port_num
operator|=
name|ib_node_info_get_local_port_num
argument_list|(
name|p_ni
argument_list|)
expr_stmt|;
name|osm_dump_smp_dr_path_v2
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|p_smp
argument_list|,
name|FILE_ID
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Discovered new %s node,"
literal|"\n\t\t\t\tGUID 0x%"
name|PRIx64
literal|", TID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|ib_get_node_type_str
argument_list|(
name|p_ni
operator|->
name|node_type
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni
operator|->
name|node_guid
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_smp
operator|->
name|trans_id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF
argument_list|(
name|port_num
operator|>
name|p_ni
operator|->
name|num_ports
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D0A: "
literal|"New %s node GUID 0x%"
name|PRIx64
literal|"is non-compliant and "
literal|"is being ignored since the "
literal|"local port num %u> num ports %u\n"
argument_list|,
name|ib_get_node_type_str
argument_list|(
name|p_ni
operator|->
name|node_type
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni
operator|->
name|node_guid
argument_list|)
argument_list|,
name|port_num
argument_list|,
name|p_ni
operator|->
name|num_ports
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_node
operator|=
name|osm_node_new
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF
argument_list|(
name|p_node
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D07: "
literal|"Unable to create new node object\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	   Create a new port object to represent this node's physical 	   ports in the port table. 	 */
name|p_port
operator|=
name|osm_port_new
argument_list|(
name|p_ni
argument_list|,
name|p_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF
argument_list|(
name|p_port
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D14: "
literal|"Unable to create new port object\n"
argument_list|)
expr_stmt|;
name|osm_node_delete
argument_list|(
operator|&
name|p_node
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	   Add the new port object to the database. 	 */
name|p_port_check
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_insert
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|port_guid_tbl
argument_list|,
name|p_ni
operator|->
name|port_guid
argument_list|,
operator|&
name|p_port
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF
argument_list|(
name|p_port_check
operator|!=
name|p_port
argument_list|)
condition|)
block|{
comment|/* 		   We should never be here! 		   Somehow, this port GUID already exists in the table. 		 */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D15: "
literal|"Duplicate Port GUID 0x%"
name|PRIx64
literal|"! Found by the two directed routes:\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni
operator|->
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
name|osm_dump_dr_path_v2
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_port
operator|->
name|p_physp
argument_list|)
argument_list|,
name|FILE_ID
argument_list|,
name|OSM_LOG_ERROR
argument_list|)
expr_stmt|;
name|osm_dump_dr_path_v2
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_port_check
operator|->
name|p_physp
argument_list|)
argument_list|,
name|FILE_ID
argument_list|,
name|OSM_LOG_ERROR
argument_list|)
expr_stmt|;
name|osm_port_delete
argument_list|(
operator|&
name|p_port
argument_list|)
expr_stmt|;
name|osm_node_delete
argument_list|(
operator|&
name|p_node
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_alias_guid
operator|=
name|osm_alias_guid_new
argument_list|(
name|p_ni
operator|->
name|port_guid
argument_list|,
name|p_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF
argument_list|(
operator|!
name|p_alias_guid
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D18: "
literal|"alias guid memory allocation failed"
literal|" for port GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni
operator|->
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|alias_done2
goto|;
block|}
comment|/* insert into alias guid table */
name|p_alias_guid_check
operator|=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_insert
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|alias_port_guid_tbl
argument_list|,
name|p_alias_guid
operator|->
name|alias_guid
argument_list|,
operator|&
name|p_alias_guid
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_alias_guid_check
operator|!=
name|p_alias_guid
condition|)
block|{
comment|/* alias GUID is a duplicate */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D19: "
literal|"Duplicate alias port GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni
operator|->
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
name|osm_alias_guid_delete
argument_list|(
operator|&
name|p_alias_guid
argument_list|)
expr_stmt|;
block|}
name|alias_done2
label|:
comment|/* If we are a master, then this means the port is new on the subnet. 	   Mark it as new - need to send trap 64 on these ports. 	   The condition that we are master is true, since if we are in discovering 	   state (meaning we woke up from standby or we are just initializing), 	   then these ports may be new to us, but are not new on the subnet. 	   If we are master, then the subnet as we know it is the updated one, 	   and any new ports we encounter should cause trap 64. C14-72.1.1 */
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
operator|==
name|IB_SMINFO_STATE_MASTER
condition|)
name|p_port
operator|->
name|is_new
operator|=
literal|1
expr_stmt|;
comment|/* If there were RouterInfo or other router attribute, 	   this would be elsewhere */
if|if
condition|(
name|p_ni
operator|->
name|node_type
operator|==
name|IB_NODE_TYPE_ROUTER
condition|)
block|{
if|if
condition|(
name|PF
argument_list|(
operator|(
name|p_rtr
operator|=
name|osm_router_new
argument_list|(
name|p_port
argument_list|)
operator|)
operator|==
name|NULL
argument_list|)
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D1A: "
literal|"Unable to create new router object\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|p_rtr_guid_tbl
operator|=
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|rtr_guid_tbl
expr_stmt|;
name|p_rtr_check
operator|=
operator|(
name|osm_router_t
operator|*
operator|)
name|cl_qmap_insert
argument_list|(
name|p_rtr_guid_tbl
argument_list|,
name|p_ni
operator|->
name|port_guid
argument_list|,
operator|&
name|p_rtr
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF
argument_list|(
name|p_rtr_check
operator|!=
name|p_rtr
argument_list|)
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D1B: "
literal|"Unable to add port GUID:0x%016"
name|PRIx64
literal|" to router table\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni
operator|->
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|p_node_check
operator|=
operator|(
name|osm_node_t
operator|*
operator|)
name|cl_qmap_insert
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|node_guid_tbl
argument_list|,
name|p_ni
operator|->
name|node_guid
argument_list|,
operator|&
name|p_node
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF
argument_list|(
name|p_node_check
operator|!=
name|p_node
argument_list|)
condition|)
block|{
comment|/* 		   This node must have been inserted by another thread. 		   This is unexpected, but is not an error. 		   We can simply clean-up, since the other thread will 		   see this processing through to completion. 		 */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Discovery race detected at node 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni
operator|->
name|node_guid
argument_list|)
argument_list|)
expr_stmt|;
name|osm_node_delete
argument_list|(
operator|&
name|p_node
argument_list|)
expr_stmt|;
name|p_node
operator|=
name|p_node_check
expr_stmt|;
name|ni_rcv_set_links
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|port_num
argument_list|,
name|p_ni_context
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
else|else
name|ni_rcv_set_links
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|port_num
argument_list|,
name|p_ni_context
argument_list|)
expr_stmt|;
name|p_node
operator|->
name|discovery_count
operator|++
expr_stmt|;
name|ni_rcv_get_node_desc
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_ni
operator|->
name|node_type
condition|)
block|{
case|case
name|IB_NODE_TYPE_CA
case|:
case|case
name|IB_NODE_TYPE_ROUTER
case|:
name|ni_rcv_process_new_ca_or_router
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_NODE_TYPE_SWITCH
case|:
name|ni_rcv_process_new_switch
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
break|break;
default|default:
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D16: "
literal|"Unknown node type %u with GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|p_ni
operator|->
name|node_type
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni
operator|->
name|node_guid
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  The plock must be held before calling this function. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|ni_rcv_process_existing
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
name|p_node
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|)
block|{
name|ib_node_info_t
modifier|*
name|p_ni
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|osm_ni_context_t
modifier|*
name|p_ni_context
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_ni
operator|=
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
name|p_ni_context
operator|=
name|osm_madw_get_ni_context_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|port_num
operator|=
name|ib_node_info_get_local_port_num
argument_list|(
name|p_ni
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Rediscovered %s node 0x%"
name|PRIx64
literal|" TID 0x%"
name|PRIx64
literal|", discovered %u times already\n"
argument_list|,
name|ib_get_node_type_str
argument_list|(
name|p_ni
operator|->
name|node_type
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni
operator|->
name|node_guid
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_smp
operator|->
name|trans_id
argument_list|)
argument_list|,
name|p_node
operator|->
name|discovery_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF
argument_list|(
name|port_num
operator|>
name|p_ni
operator|->
name|num_ports
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D0C: "
literal|"Existing %s node GUID 0x%"
name|PRIx64
literal|"is non-compliant "
literal|"and is being ignored since the "
literal|"local port num %u> num ports %u\n"
argument_list|,
name|ib_get_node_type_str
argument_list|(
name|p_ni
operator|->
name|node_type
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni
operator|->
name|node_guid
argument_list|)
argument_list|,
name|port_num
argument_list|,
name|p_ni
operator|->
name|num_ports
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	   If we haven't already encountered this existing node 	   on this particular sweep, then process further. 	 */
name|p_node
operator|->
name|discovery_count
operator|++
expr_stmt|;
switch|switch
condition|(
name|p_ni
operator|->
name|node_type
condition|)
block|{
case|case
name|IB_NODE_TYPE_CA
case|:
case|case
name|IB_NODE_TYPE_ROUTER
case|:
name|ni_rcv_process_existing_ca_or_router
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_NODE_TYPE_SWITCH
case|:
name|ni_rcv_process_existing_switch
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
break|break;
default|default:
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D09: "
literal|"Unknown node type %u with GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|p_ni
operator|->
name|node_type
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni
operator|->
name|node_guid
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p_ni
operator|->
name|sys_guid
operator|!=
name|p_node
operator|->
name|node_info
operator|.
name|sys_guid
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Updated SysImageGUID: 0x%"
name|PRIx64
literal|" for node 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni
operator|->
name|sys_guid
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni
operator|->
name|node_guid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ni_rcv_set_links
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|port_num
argument_list|,
name|p_ni_context
argument_list|)
expr_stmt|;
name|p_node
operator|->
name|node_info
operator|=
operator|*
name|p_ni
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_ni_rcv_process
parameter_list|(
name|IN
name|void
modifier|*
name|context
parameter_list|,
name|IN
name|void
modifier|*
name|data
parameter_list|)
block|{
name|osm_sm_t
modifier|*
name|sm
init|=
name|context
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_madw
init|=
name|data
decl_stmt|;
name|ib_node_info_t
modifier|*
name|p_ni
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_ni
operator|=
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_smp
operator|->
name|attr_id
operator|==
name|IB_MAD_ATTR_NODE_INFO
argument_list|)
expr_stmt|;
if|if
condition|(
name|PF
argument_list|(
name|p_ni
operator|->
name|node_guid
operator|==
literal|0
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D16: "
literal|"Got Zero Node GUID! Found on the directed route:\n"
argument_list|)
expr_stmt|;
name|osm_dump_smp_dr_path_v2
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|p_smp
argument_list|,
name|FILE_ID
argument_list|,
name|OSM_LOG_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|PF
argument_list|(
name|p_ni
operator|->
name|port_guid
operator|==
literal|0
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D17: "
literal|"Got Zero Port GUID! Found on the directed route:\n"
argument_list|)
expr_stmt|;
name|osm_dump_smp_dr_path_v2
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|p_smp
argument_list|,
name|FILE_ID
argument_list|,
name|OSM_LOG_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|ib_smp_get_status
argument_list|(
name|p_smp
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"MAD status 0x%x received\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|ib_smp_get_status
argument_list|(
name|p_smp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	   Determine if this node has already been discovered, 	   and process accordingly. 	   During processing of this node, hold the shared lock. 	 */
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|p_node
operator|=
name|osm_get_node_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|p_ni
operator|->
name|node_guid
argument_list|)
expr_stmt|;
name|osm_dump_node_info_v2
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|p_ni
argument_list|,
name|FILE_ID
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_node
condition|)
name|ni_rcv_process_new
argument_list|(
name|sm
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
else|else
name|ni_rcv_process_existing
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

