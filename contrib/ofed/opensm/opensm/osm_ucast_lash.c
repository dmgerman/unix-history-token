begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2015 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  * Copyright (c) 2007      Simula Research Laboratory. All rights reserved.  * Copyright (c) 2007      Silicon Graphics Inc. All rights reserved.  * Copyright (c) 2008,2009 System Fabric Works, Inc. All rights reserved.  * Copyright (c) 2009      HNR Consulting. All rights reserved.  * Copyright (c) 2009-2011 ZIH, TU Dresden, Federal Republic of Germany. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *      Implementation of LASH algorithm Calculation functions  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qmap.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_UCAST_LASH_C
end_define

begin_include
include|#
directive|include
file|<opensm/osm_switch.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_mesh.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_ucast_lash.h>
end_include

begin_typedef
typedef|typedef
struct|struct
name|_reachable_dest
block|{
name|int
name|switch_id
decl_stmt|;
name|struct
name|_reachable_dest
modifier|*
name|next
decl_stmt|;
block|}
name|reachable_dest_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|connect_switches
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|int
name|sw1
parameter_list|,
name|int
name|sw2
parameter_list|,
name|int
name|phy_port_1
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|unsigned
name|num
init|=
name|p_lash
operator|->
name|switches
index|[
name|sw1
index|]
operator|->
name|node
operator|->
name|num_links
decl_stmt|;
name|switch_t
modifier|*
name|s1
init|=
name|p_lash
operator|->
name|switches
index|[
name|sw1
index|]
decl_stmt|;
name|mesh_node_t
modifier|*
name|node
init|=
name|s1
operator|->
name|node
decl_stmt|;
name|switch_t
modifier|*
name|s2
decl_stmt|;
name|link_t
modifier|*
name|l
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* 	 * if doing mesh analysis: 	 *  - do not consider connections to self 	 *  - collapse multiple connections between 	 *    pair of switches to a single locical link 	 */
if|if
condition|(
name|p_lash
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|do_mesh_analysis
condition|)
block|{
if|if
condition|(
name|sw1
operator|==
name|sw2
condition|)
return|return;
comment|/* see if we are already linked to sw2 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|l
operator|=
name|node
operator|->
name|links
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|links
index|[
name|i
index|]
operator|->
name|switch_id
operator|==
name|sw2
condition|)
block|{
name|l
operator|->
name|ports
index|[
name|l
operator|->
name|num_ports
operator|++
index|]
operator|=
name|phy_port_1
expr_stmt|;
return|return;
block|}
block|}
block|}
name|l
operator|=
name|node
operator|->
name|links
index|[
name|num
index|]
expr_stmt|;
name|l
operator|->
name|switch_id
operator|=
name|sw2
expr_stmt|;
name|l
operator|->
name|link_id
operator|=
operator|-
literal|1
expr_stmt|;
name|l
operator|->
name|ports
index|[
name|l
operator|->
name|num_ports
operator|++
index|]
operator|=
name|phy_port_1
expr_stmt|;
name|s2
operator|=
name|p_lash
operator|->
name|switches
index|[
name|sw2
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s2
operator|->
name|node
operator|->
name|num_links
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|s2
operator|->
name|node
operator|->
name|links
index|[
name|i
index|]
operator|->
name|switch_id
operator|==
name|sw1
condition|)
block|{
name|s2
operator|->
name|node
operator|->
name|links
index|[
name|i
index|]
operator|->
name|link_id
operator|=
name|num
expr_stmt|;
name|l
operator|->
name|link_id
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|node
operator|->
name|num_links
operator|++
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"LASH connect: %d, %d, %d\n"
argument_list|,
name|sw1
argument_list|,
name|sw2
argument_list|,
name|phy_port_1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|osm_switch_t
modifier|*
name|get_osm_switch_from_port
parameter_list|(
specifier|const
name|osm_port_t
modifier|*
name|port
parameter_list|)
block|{
name|osm_physp_t
modifier|*
name|p
init|=
name|port
operator|->
name|p_physp
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|p_node
operator|->
name|sw
condition|)
return|return
name|p
operator|->
name|p_node
operator|->
name|sw
return|;
elseif|else
if|if
condition|(
name|p
operator|->
name|p_remote_physp
operator|&&
name|p
operator|->
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
condition|)
return|return
name|p
operator|->
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cycle_exists
parameter_list|(
name|cdg_vertex_t
modifier|*
name|start
parameter_list|,
name|cdg_vertex_t
modifier|*
name|current
parameter_list|,
name|cdg_vertex_t
modifier|*
name|prev
parameter_list|,
name|int
name|visit_num
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|new_visit_num
decl_stmt|;
name|int
name|cycle_found
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|current
operator|!=
name|NULL
operator|&&
name|current
operator|->
name|visiting_number
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|visit_num
operator|>
name|current
operator|->
name|visiting_number
operator|&&
name|current
operator|->
name|seen
operator|==
literal|0
condition|)
block|{
name|cycle_found
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|current
operator|==
name|NULL
condition|)
block|{
name|current
operator|=
name|start
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|prev
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
name|current
operator|->
name|visiting_number
operator|=
name|visit_num
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
name|prev
operator|->
name|next
operator|=
name|current
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|prev
operator|->
name|to
operator|==
name|current
operator|->
name|from
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|prev
operator|->
name|visiting_number
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
name|new_visit_num
operator|=
name|visit_num
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|current
operator|->
name|num_deps
condition|;
name|i
operator|++
control|)
block|{
name|cycle_found
operator|=
name|cycle_exists
argument_list|(
name|start
argument_list|,
name|current
operator|->
name|deps
index|[
name|i
index|]
operator|.
name|v
argument_list|,
name|current
argument_list|,
name|new_visit_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|cycle_found
operator|==
literal|1
condition|)
name|i
operator|=
name|current
operator|->
name|num_deps
expr_stmt|;
block|}
name|current
operator|->
name|seen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
name|prev
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|cycle_found
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|get_next_switch
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|int
name|sw
parameter_list|,
name|int
name|link
parameter_list|)
block|{
return|return
name|p_lash
operator|->
name|switches
index|[
name|sw
index|]
operator|->
name|node
operator|->
name|links
index|[
name|link
index|]
operator|->
name|switch_id
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_semipermanent_depend_for_sp
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|int
name|sw
parameter_list|,
name|int
name|dest_switch
parameter_list|,
name|int
name|lane
parameter_list|)
block|{
name|switch_t
modifier|*
modifier|*
name|switches
init|=
name|p_lash
operator|->
name|switches
decl_stmt|;
name|cdg_vertex_t
modifier|*
modifier|*
modifier|*
modifier|*
name|cdg_vertex_matrix
init|=
name|p_lash
operator|->
name|cdg_vertex_matrix
decl_stmt|;
name|int
name|i_next_switch
decl_stmt|,
name|output_link
decl_stmt|,
name|i
decl_stmt|,
name|next_link
decl_stmt|,
name|i_next_next_switch
decl_stmt|,
name|depend
init|=
literal|0
decl_stmt|;
name|cdg_vertex_t
modifier|*
name|v
decl_stmt|;
name|int
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
name|found
decl_stmt|;
name|output_link
operator|=
name|switches
index|[
name|sw
index|]
operator|->
name|routing_table
index|[
name|dest_switch
index|]
operator|.
name|out_link
expr_stmt|;
name|i_next_switch
operator|=
name|get_next_switch
argument_list|(
name|p_lash
argument_list|,
name|sw
argument_list|,
name|output_link
argument_list|)
expr_stmt|;
while|while
condition|(
name|sw
operator|!=
name|dest_switch
condition|)
block|{
name|v
operator|=
name|cdg_vertex_matrix
index|[
name|lane
index|]
index|[
name|sw
index|]
index|[
name|i_next_switch
index|]
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|v
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|num_using_vertex
operator|==
literal|1
condition|)
block|{
name|cdg_vertex_matrix
index|[
name|lane
index|]
index|[
name|sw
index|]
index|[
name|i_next_switch
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|v
operator|->
name|num_using_vertex
operator|--
expr_stmt|;
if|if
condition|(
name|i_next_switch
operator|!=
name|dest_switch
condition|)
block|{
name|next_link
operator|=
name|switches
index|[
name|i_next_switch
index|]
operator|->
name|routing_table
index|[
name|dest_switch
index|]
operator|.
name|out_link
expr_stmt|;
name|i_next_next_switch
operator|=
name|get_next_switch
argument_list|(
name|p_lash
argument_list|,
name|i_next_switch
argument_list|,
name|next_link
argument_list|)
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|v
operator|->
name|num_deps
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|v
operator|->
name|deps
index|[
name|i
index|]
operator|.
name|v
operator|==
name|cdg_vertex_matrix
index|[
name|lane
index|]
index|[
name|i_next_switch
index|]
index|[
name|i_next_next_switch
index|]
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
name|depend
operator|=
name|i
expr_stmt|;
block|}
name|CL_ASSERT
argument_list|(
name|found
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|deps
index|[
name|depend
index|]
operator|.
name|num_used
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
name|depend
init|;
name|i
operator|<
name|v
operator|->
name|num_deps
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|->
name|deps
index|[
name|i
index|]
operator|.
name|v
operator|=
name|v
operator|->
name|deps
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|v
expr_stmt|;
name|v
operator|->
name|deps
index|[
name|i
index|]
operator|.
name|num_used
operator|=
name|v
operator|->
name|deps
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|num_used
expr_stmt|;
block|}
name|v
operator|->
name|num_deps
operator|--
expr_stmt|;
block|}
else|else
name|v
operator|->
name|deps
index|[
name|depend
index|]
operator|.
name|num_used
operator|--
expr_stmt|;
block|}
block|}
name|sw
operator|=
name|i_next_switch
expr_stmt|;
name|output_link
operator|=
name|switches
index|[
name|sw
index|]
operator|->
name|routing_table
index|[
name|dest_switch
index|]
operator|.
name|out_link
expr_stmt|;
if|if
condition|(
name|sw
operator|!=
name|dest_switch
condition|)
name|i_next_switch
operator|=
name|get_next_switch
argument_list|(
name|p_lash
argument_list|,
name|sw
argument_list|,
name|output_link
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|inline
specifier|static
name|void
name|enqueue
parameter_list|(
name|cl_list_t
modifier|*
name|bfsq
parameter_list|,
name|switch_t
modifier|*
name|sw
parameter_list|)
block|{
name|CL_ASSERT
argument_list|(
name|sw
operator|->
name|q_state
operator|==
name|UNQUEUED
argument_list|)
expr_stmt|;
name|sw
operator|->
name|q_state
operator|=
name|Q_MEMBER
expr_stmt|;
name|cl_list_insert_tail
argument_list|(
name|bfsq
argument_list|,
name|sw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|inline
specifier|static
name|void
name|dequeue
parameter_list|(
name|cl_list_t
modifier|*
name|bfsq
parameter_list|,
name|switch_t
modifier|*
modifier|*
name|sw
parameter_list|)
block|{
operator|*
name|sw
operator|=
operator|(
name|switch_t
operator|*
operator|)
name|cl_list_remove_head
argument_list|(
name|bfsq
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
operator|(
operator|*
name|sw
operator|)
operator|->
name|q_state
operator|==
name|Q_MEMBER
argument_list|)
expr_stmt|;
operator|(
operator|*
name|sw
operator|)
operator|->
name|q_state
operator|=
name|MST_MEMBER
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_phys_connection
parameter_list|(
name|switch_t
modifier|*
name|sw
parameter_list|,
name|int
name|switch_to
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sw
operator|->
name|node
operator|->
name|num_links
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sw
operator|->
name|node
operator|->
name|links
index|[
name|i
index|]
operator|->
name|switch_id
operator|==
name|switch_to
condition|)
return|return
name|i
return|;
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|shortest_path
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|int
name|ir
parameter_list|)
block|{
name|switch_t
modifier|*
modifier|*
name|switches
init|=
name|p_lash
operator|->
name|switches
decl_stmt|,
modifier|*
name|sw
decl_stmt|,
modifier|*
name|swi
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|cl_list_t
name|bfsq
decl_stmt|;
name|cl_list_construct
argument_list|(
operator|&
name|bfsq
argument_list|)
expr_stmt|;
name|cl_list_init
argument_list|(
operator|&
name|bfsq
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|enqueue
argument_list|(
operator|&
name|bfsq
argument_list|,
name|switches
index|[
name|ir
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|cl_is_list_empty
argument_list|(
operator|&
name|bfsq
argument_list|)
condition|)
block|{
name|dequeue
argument_list|(
operator|&
name|bfsq
argument_list|,
operator|&
name|sw
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sw
operator|->
name|node
operator|->
name|num_links
condition|;
name|i
operator|++
control|)
block|{
name|swi
operator|=
name|switches
index|[
name|sw
operator|->
name|node
operator|->
name|links
index|[
name|i
index|]
operator|->
name|switch_id
index|]
expr_stmt|;
if|if
condition|(
name|swi
operator|->
name|q_state
operator|==
name|UNQUEUED
condition|)
block|{
name|enqueue
argument_list|(
operator|&
name|bfsq
argument_list|,
name|swi
argument_list|)
expr_stmt|;
name|sw
operator|->
name|dij_channels
index|[
name|sw
operator|->
name|used_channels
operator|++
index|]
operator|=
name|swi
operator|->
name|id
expr_stmt|;
block|}
block|}
block|}
name|cl_list_destroy
argument_list|(
operator|&
name|bfsq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|generate_routing_func_for_mst
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|int
name|sw_id
parameter_list|,
name|reachable_dest_t
modifier|*
modifier|*
name|destinations
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|next_switch
decl_stmt|;
name|switch_t
modifier|*
name|sw
init|=
name|p_lash
operator|->
name|switches
index|[
name|sw_id
index|]
decl_stmt|;
name|int
name|num_channels
init|=
name|sw
operator|->
name|used_channels
decl_stmt|;
name|reachable_dest_t
modifier|*
name|dest
decl_stmt|,
modifier|*
name|i_dest
decl_stmt|,
modifier|*
name|concat_dest
init|=
name|NULL
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_channels
condition|;
name|i
operator|++
control|)
block|{
name|next_switch
operator|=
name|sw
operator|->
name|dij_channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|generate_routing_func_for_mst
argument_list|(
name|p_lash
argument_list|,
name|next_switch
argument_list|,
operator|&
name|dest
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|i_dest
operator|=
name|dest
expr_stmt|;
name|prev
operator|=
name|i_dest
expr_stmt|;
while|while
condition|(
name|i_dest
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sw
operator|->
name|routing_table
index|[
name|i_dest
operator|->
name|switch_id
index|]
operator|.
name|out_link
operator|==
name|NONE
condition|)
name|sw
operator|->
name|routing_table
index|[
name|i_dest
operator|->
name|switch_id
index|]
operator|.
name|out_link
operator|=
name|get_phys_connection
argument_list|(
name|sw
argument_list|,
name|next_switch
argument_list|)
expr_stmt|;
name|prev
operator|=
name|i_dest
expr_stmt|;
name|i_dest
operator|=
name|i_dest
operator|->
name|next
expr_stmt|;
block|}
name|CL_ASSERT
argument_list|(
name|prev
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|concat_dest
expr_stmt|;
name|concat_dest
operator|=
name|dest
expr_stmt|;
block|}
name|i_dest
operator|=
operator|(
name|reachable_dest_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|reachable_dest_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i_dest
condition|)
return|return
operator|-
literal|1
return|;
name|i_dest
operator|->
name|switch_id
operator|=
name|sw
operator|->
name|id
expr_stmt|;
name|i_dest
operator|->
name|next
operator|=
name|concat_dest
expr_stmt|;
operator|*
name|destinations
operator|=
name|i_dest
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|generate_cdg_for_sp
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|int
name|sw
parameter_list|,
name|int
name|dest_switch
parameter_list|,
name|int
name|lane
parameter_list|)
block|{
name|unsigned
name|num_switches
init|=
name|p_lash
operator|->
name|num_switches
decl_stmt|;
name|switch_t
modifier|*
modifier|*
name|switches
init|=
name|p_lash
operator|->
name|switches
decl_stmt|;
name|cdg_vertex_t
modifier|*
modifier|*
modifier|*
modifier|*
name|cdg_vertex_matrix
init|=
name|p_lash
operator|->
name|cdg_vertex_matrix
decl_stmt|;
name|int
name|next_switch
decl_stmt|,
name|output_link
decl_stmt|,
name|j
decl_stmt|,
name|exists
decl_stmt|;
name|cdg_vertex_t
modifier|*
name|v
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|output_link
operator|=
name|switches
index|[
name|sw
index|]
operator|->
name|routing_table
index|[
name|dest_switch
index|]
operator|.
name|out_link
expr_stmt|;
name|next_switch
operator|=
name|get_next_switch
argument_list|(
name|p_lash
argument_list|,
name|sw
argument_list|,
name|output_link
argument_list|)
expr_stmt|;
while|while
condition|(
name|sw
operator|!=
name|dest_switch
condition|)
block|{
if|if
condition|(
name|cdg_vertex_matrix
index|[
name|lane
index|]
index|[
name|sw
index|]
index|[
name|next_switch
index|]
operator|==
name|NULL
condition|)
block|{
name|v
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|v
argument_list|)
operator|+
operator|(
name|num_switches
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|v
operator|->
name|deps
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|v
condition|)
return|return
operator|-
literal|1
return|;
name|v
operator|->
name|from
operator|=
name|sw
expr_stmt|;
name|v
operator|->
name|to
operator|=
name|next_switch
expr_stmt|;
name|v
operator|->
name|temp
operator|=
literal|1
expr_stmt|;
name|cdg_vertex_matrix
index|[
name|lane
index|]
index|[
name|sw
index|]
index|[
name|next_switch
index|]
operator|=
name|v
expr_stmt|;
block|}
else|else
name|v
operator|=
name|cdg_vertex_matrix
index|[
name|lane
index|]
index|[
name|sw
index|]
index|[
name|next_switch
index|]
expr_stmt|;
name|v
operator|->
name|num_using_vertex
operator|++
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
name|exists
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|prev
operator|->
name|num_deps
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|prev
operator|->
name|deps
index|[
name|j
index|]
operator|.
name|v
operator|==
name|v
condition|)
block|{
name|exists
operator|=
literal|1
expr_stmt|;
name|prev
operator|->
name|deps
index|[
name|j
index|]
operator|.
name|num_used
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|exists
operator|==
literal|0
condition|)
block|{
name|prev
operator|->
name|deps
index|[
name|prev
operator|->
name|num_deps
index|]
operator|.
name|v
operator|=
name|v
expr_stmt|;
name|prev
operator|->
name|deps
index|[
name|prev
operator|->
name|num_deps
index|]
operator|.
name|num_used
operator|++
expr_stmt|;
name|prev
operator|->
name|num_deps
operator|++
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|prev
operator|->
name|num_deps
operator|<
operator|(
name|int
operator|)
name|num_switches
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|->
name|temp
operator|==
literal|0
condition|)
name|prev
operator|->
name|num_temp_depend
operator|++
expr_stmt|;
block|}
block|}
name|sw
operator|=
name|next_switch
expr_stmt|;
name|output_link
operator|=
name|switches
index|[
name|sw
index|]
operator|->
name|routing_table
index|[
name|dest_switch
index|]
operator|.
name|out_link
expr_stmt|;
if|if
condition|(
name|sw
operator|!=
name|dest_switch
condition|)
block|{
name|CL_ASSERT
argument_list|(
name|output_link
operator|!=
name|NONE
argument_list|)
expr_stmt|;
name|next_switch
operator|=
name|get_next_switch
argument_list|(
name|p_lash
argument_list|,
name|sw
argument_list|,
name|output_link
argument_list|)
expr_stmt|;
block|}
name|prev
operator|=
name|v
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_temp_depend_to_permanent_for_sp
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|int
name|sw
parameter_list|,
name|int
name|dest_switch
parameter_list|,
name|int
name|lane
parameter_list|)
block|{
name|switch_t
modifier|*
modifier|*
name|switches
init|=
name|p_lash
operator|->
name|switches
decl_stmt|;
name|cdg_vertex_t
modifier|*
modifier|*
modifier|*
modifier|*
name|cdg_vertex_matrix
init|=
name|p_lash
operator|->
name|cdg_vertex_matrix
decl_stmt|;
name|int
name|next_switch
decl_stmt|,
name|output_link
decl_stmt|;
name|cdg_vertex_t
modifier|*
name|v
decl_stmt|;
name|output_link
operator|=
name|switches
index|[
name|sw
index|]
operator|->
name|routing_table
index|[
name|dest_switch
index|]
operator|.
name|out_link
expr_stmt|;
name|next_switch
operator|=
name|get_next_switch
argument_list|(
name|p_lash
argument_list|,
name|sw
argument_list|,
name|output_link
argument_list|)
expr_stmt|;
while|while
condition|(
name|sw
operator|!=
name|dest_switch
condition|)
block|{
name|v
operator|=
name|cdg_vertex_matrix
index|[
name|lane
index|]
index|[
name|sw
index|]
index|[
name|next_switch
index|]
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|v
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|temp
operator|==
literal|1
condition|)
name|v
operator|->
name|temp
operator|=
literal|0
expr_stmt|;
else|else
name|v
operator|->
name|num_temp_depend
operator|=
literal|0
expr_stmt|;
name|sw
operator|=
name|next_switch
expr_stmt|;
name|output_link
operator|=
name|switches
index|[
name|sw
index|]
operator|->
name|routing_table
index|[
name|dest_switch
index|]
operator|.
name|out_link
expr_stmt|;
if|if
condition|(
name|sw
operator|!=
name|dest_switch
condition|)
name|next_switch
operator|=
name|get_next_switch
argument_list|(
name|p_lash
argument_list|,
name|sw
argument_list|,
name|output_link
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|remove_temp_depend_for_sp
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|int
name|sw
parameter_list|,
name|int
name|dest_switch
parameter_list|,
name|int
name|lane
parameter_list|)
block|{
name|switch_t
modifier|*
modifier|*
name|switches
init|=
name|p_lash
operator|->
name|switches
decl_stmt|;
name|cdg_vertex_t
modifier|*
modifier|*
modifier|*
modifier|*
name|cdg_vertex_matrix
init|=
name|p_lash
operator|->
name|cdg_vertex_matrix
decl_stmt|;
name|int
name|next_switch
decl_stmt|,
name|output_link
decl_stmt|,
name|i
decl_stmt|;
name|cdg_vertex_t
modifier|*
name|v
decl_stmt|;
name|output_link
operator|=
name|switches
index|[
name|sw
index|]
operator|->
name|routing_table
index|[
name|dest_switch
index|]
operator|.
name|out_link
expr_stmt|;
name|next_switch
operator|=
name|get_next_switch
argument_list|(
name|p_lash
argument_list|,
name|sw
argument_list|,
name|output_link
argument_list|)
expr_stmt|;
while|while
condition|(
name|sw
operator|!=
name|dest_switch
condition|)
block|{
name|v
operator|=
name|cdg_vertex_matrix
index|[
name|lane
index|]
index|[
name|sw
index|]
index|[
name|next_switch
index|]
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|v
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|temp
operator|==
literal|1
condition|)
block|{
name|cdg_vertex_matrix
index|[
name|lane
index|]
index|[
name|sw
index|]
index|[
name|next_switch
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CL_ASSERT
argument_list|(
name|v
operator|->
name|num_temp_depend
operator|<=
name|v
operator|->
name|num_deps
argument_list|)
expr_stmt|;
name|v
operator|->
name|num_deps
operator|=
name|v
operator|->
name|num_deps
operator|-
name|v
operator|->
name|num_temp_depend
expr_stmt|;
name|v
operator|->
name|num_temp_depend
operator|=
literal|0
expr_stmt|;
name|v
operator|->
name|num_using_vertex
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
name|v
operator|->
name|num_deps
init|;
name|i
operator|<
name|p_lash
operator|->
name|num_switches
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|v
operator|->
name|deps
index|[
name|i
index|]
operator|.
name|num_used
operator|=
literal|0
expr_stmt|;
block|}
name|sw
operator|=
name|next_switch
expr_stmt|;
name|output_link
operator|=
name|switches
index|[
name|sw
index|]
operator|->
name|routing_table
index|[
name|dest_switch
index|]
operator|.
name|out_link
expr_stmt|;
if|if
condition|(
name|sw
operator|!=
name|dest_switch
condition|)
name|next_switch
operator|=
name|get_next_switch
argument_list|(
name|p_lash
argument_list|,
name|sw
argument_list|,
name|output_link
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|balance_virtual_lanes
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|unsigned
name|lanes_needed
parameter_list|)
block|{
name|unsigned
name|num_switches
init|=
name|p_lash
operator|->
name|num_switches
decl_stmt|;
name|cdg_vertex_t
modifier|*
modifier|*
modifier|*
modifier|*
name|cdg_vertex_matrix
init|=
name|p_lash
operator|->
name|cdg_vertex_matrix
decl_stmt|;
name|int
modifier|*
name|num_mst_in_lane
init|=
name|p_lash
operator|->
name|num_mst_in_lane
decl_stmt|;
name|int
modifier|*
modifier|*
modifier|*
name|virtual_location
init|=
name|p_lash
operator|->
name|virtual_location
decl_stmt|;
name|int
name|min_filled_lane
decl_stmt|,
name|max_filled_lane
decl_stmt|,
name|trials
decl_stmt|;
name|int
name|old_min_filled_lane
decl_stmt|,
name|old_max_filled_lane
decl_stmt|,
name|new_num_min_lane
decl_stmt|,
name|new_num_max_lane
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|src
decl_stmt|,
name|dest
decl_stmt|,
name|start
decl_stmt|,
name|next_switch
decl_stmt|,
name|output_link
decl_stmt|;
name|int
name|next_switch2
decl_stmt|,
name|output_link2
decl_stmt|;
name|int
name|stop
init|=
literal|0
decl_stmt|,
name|cycle_found
decl_stmt|;
name|int
name|cycle_found2
decl_stmt|;
name|unsigned
name|start_vl
init|=
name|p_lash
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|lash_start_vl
decl_stmt|;
name|max_filled_lane
operator|=
literal|0
expr_stmt|;
name|min_filled_lane
operator|=
name|lanes_needed
operator|-
literal|1
expr_stmt|;
name|trials
operator|=
name|num_mst_in_lane
index|[
name|max_filled_lane
index|]
expr_stmt|;
if|if
condition|(
name|lanes_needed
operator|==
literal|1
condition|)
name|stop
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|stop
operator|==
literal|0
condition|)
block|{
name|src
operator|=
name|abs
argument_list|(
name|rand
argument_list|()
argument_list|)
operator|%
operator|(
name|num_switches
operator|)
expr_stmt|;
name|dest
operator|=
name|abs
argument_list|(
name|rand
argument_list|()
argument_list|)
operator|%
operator|(
name|num_switches
operator|)
expr_stmt|;
while|while
condition|(
name|virtual_location
index|[
name|src
index|]
index|[
name|dest
index|]
index|[
name|max_filled_lane
index|]
operator|!=
literal|1
condition|)
block|{
name|start
operator|=
name|dest
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|num_switches
operator|-
literal|1
condition|)
name|dest
operator|=
literal|0
expr_stmt|;
else|else
name|dest
operator|++
expr_stmt|;
while|while
condition|(
name|dest
operator|!=
name|start
operator|&&
name|virtual_location
index|[
name|src
index|]
index|[
name|dest
index|]
index|[
name|max_filled_lane
index|]
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|dest
operator|==
name|num_switches
operator|-
literal|1
condition|)
name|dest
operator|=
literal|0
expr_stmt|;
else|else
name|dest
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|virtual_location
index|[
name|src
index|]
index|[
name|dest
index|]
index|[
name|max_filled_lane
index|]
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|src
operator|==
name|num_switches
operator|-
literal|1
condition|)
name|src
operator|=
literal|0
expr_stmt|;
else|else
name|src
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|generate_cdg_for_sp
argument_list|(
name|p_lash
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
name|min_filled_lane
argument_list|)
operator|||
name|generate_cdg_for_sp
argument_list|(
name|p_lash
argument_list|,
name|dest
argument_list|,
name|src
argument_list|,
name|min_filled_lane
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|output_link
operator|=
name|p_lash
operator|->
name|switches
index|[
name|src
index|]
operator|->
name|routing_table
index|[
name|dest
index|]
operator|.
name|out_link
expr_stmt|;
name|next_switch
operator|=
name|get_next_switch
argument_list|(
name|p_lash
argument_list|,
name|src
argument_list|,
name|output_link
argument_list|)
expr_stmt|;
name|output_link2
operator|=
name|p_lash
operator|->
name|switches
index|[
name|dest
index|]
operator|->
name|routing_table
index|[
name|src
index|]
operator|.
name|out_link
expr_stmt|;
name|next_switch2
operator|=
name|get_next_switch
argument_list|(
name|p_lash
argument_list|,
name|dest
argument_list|,
name|output_link2
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|cdg_vertex_matrix
index|[
name|min_filled_lane
index|]
index|[
name|src
index|]
index|[
name|next_switch
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|cdg_vertex_matrix
index|[
name|min_filled_lane
index|]
index|[
name|dest
index|]
index|[
name|next_switch2
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|cycle_found
operator|=
name|cycle_exists
argument_list|(
name|cdg_vertex_matrix
index|[
name|min_filled_lane
index|]
index|[
name|src
index|]
index|[
name|next_switch
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cycle_found2
operator|=
name|cycle_exists
argument_list|(
name|cdg_vertex_matrix
index|[
name|min_filled_lane
index|]
index|[
name|dest
index|]
index|[
name|next_switch2
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_switches
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_switches
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|cdg_vertex_matrix
index|[
name|min_filled_lane
index|]
index|[
name|i
index|]
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
block|{
name|cdg_vertex_matrix
index|[
name|min_filled_lane
index|]
index|[
name|i
index|]
index|[
name|j
index|]
operator|->
name|visiting_number
operator|=
literal|0
expr_stmt|;
name|cdg_vertex_matrix
index|[
name|min_filled_lane
index|]
index|[
name|i
index|]
index|[
name|j
index|]
operator|->
name|seen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cycle_found
operator|==
literal|1
operator|||
name|cycle_found2
operator|==
literal|1
condition|)
block|{
name|remove_temp_depend_for_sp
argument_list|(
name|p_lash
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
name|min_filled_lane
argument_list|)
expr_stmt|;
name|remove_temp_depend_for_sp
argument_list|(
name|p_lash
argument_list|,
name|dest
argument_list|,
name|src
argument_list|,
name|min_filled_lane
argument_list|)
expr_stmt|;
name|virtual_location
index|[
name|src
index|]
index|[
name|dest
index|]
index|[
name|max_filled_lane
index|]
operator|=
literal|2
expr_stmt|;
name|virtual_location
index|[
name|dest
index|]
index|[
name|src
index|]
index|[
name|max_filled_lane
index|]
operator|=
literal|2
expr_stmt|;
name|trials
operator|--
expr_stmt|;
name|trials
operator|--
expr_stmt|;
block|}
else|else
block|{
name|set_temp_depend_to_permanent_for_sp
argument_list|(
name|p_lash
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
name|min_filled_lane
argument_list|)
expr_stmt|;
name|set_temp_depend_to_permanent_for_sp
argument_list|(
name|p_lash
argument_list|,
name|dest
argument_list|,
name|src
argument_list|,
name|min_filled_lane
argument_list|)
expr_stmt|;
name|num_mst_in_lane
index|[
name|max_filled_lane
index|]
operator|--
expr_stmt|;
name|num_mst_in_lane
index|[
name|max_filled_lane
index|]
operator|--
expr_stmt|;
name|num_mst_in_lane
index|[
name|min_filled_lane
index|]
operator|++
expr_stmt|;
name|num_mst_in_lane
index|[
name|min_filled_lane
index|]
operator|++
expr_stmt|;
name|remove_semipermanent_depend_for_sp
argument_list|(
name|p_lash
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
name|max_filled_lane
argument_list|)
expr_stmt|;
name|remove_semipermanent_depend_for_sp
argument_list|(
name|p_lash
argument_list|,
name|dest
argument_list|,
name|src
argument_list|,
name|max_filled_lane
argument_list|)
expr_stmt|;
name|virtual_location
index|[
name|src
index|]
index|[
name|dest
index|]
index|[
name|max_filled_lane
index|]
operator|=
literal|0
expr_stmt|;
name|virtual_location
index|[
name|dest
index|]
index|[
name|src
index|]
index|[
name|max_filled_lane
index|]
operator|=
literal|0
expr_stmt|;
name|virtual_location
index|[
name|src
index|]
index|[
name|dest
index|]
index|[
name|min_filled_lane
index|]
operator|=
literal|1
expr_stmt|;
name|virtual_location
index|[
name|dest
index|]
index|[
name|src
index|]
index|[
name|min_filled_lane
index|]
operator|=
literal|1
expr_stmt|;
name|p_lash
operator|->
name|switches
index|[
name|src
index|]
operator|->
name|routing_table
index|[
name|dest
index|]
operator|.
name|lane
operator|=
name|min_filled_lane
operator|+
name|start_vl
expr_stmt|;
name|p_lash
operator|->
name|switches
index|[
name|dest
index|]
operator|->
name|routing_table
index|[
name|src
index|]
operator|.
name|lane
operator|=
name|min_filled_lane
operator|+
name|start_vl
expr_stmt|;
block|}
if|if
condition|(
name|trials
operator|==
literal|0
condition|)
name|stop
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|num_mst_in_lane
index|[
name|max_filled_lane
index|]
operator|-
name|num_mst_in_lane
index|[
name|min_filled_lane
index|]
operator|<
name|p_lash
operator|->
name|balance_limit
condition|)
name|stop
operator|=
literal|1
expr_stmt|;
block|}
name|old_min_filled_lane
operator|=
name|min_filled_lane
expr_stmt|;
name|old_max_filled_lane
operator|=
name|max_filled_lane
expr_stmt|;
name|new_num_min_lane
operator|=
name|MAX_INT
expr_stmt|;
name|new_num_max_lane
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lanes_needed
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|num_mst_in_lane
index|[
name|i
index|]
operator|<
name|new_num_min_lane
condition|)
block|{
name|new_num_min_lane
operator|=
name|num_mst_in_lane
index|[
name|i
index|]
expr_stmt|;
name|min_filled_lane
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|num_mst_in_lane
index|[
name|i
index|]
operator|>
name|new_num_max_lane
condition|)
block|{
name|new_num_max_lane
operator|=
name|num_mst_in_lane
index|[
name|i
index|]
expr_stmt|;
name|max_filled_lane
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|old_min_filled_lane
operator|!=
name|min_filled_lane
condition|)
block|{
name|trials
operator|=
name|num_mst_in_lane
index|[
name|max_filled_lane
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_switches
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_switches
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|virtual_location
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|max_filled_lane
index|]
operator|==
literal|2
condition|)
name|virtual_location
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|max_filled_lane
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|old_max_filled_lane
operator|!=
name|max_filled_lane
condition|)
block|{
name|trials
operator|=
name|num_mst_in_lane
index|[
name|max_filled_lane
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_switches
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_switches
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|virtual_location
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|old_max_filled_lane
index|]
operator|==
literal|2
condition|)
name|virtual_location
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|old_max_filled_lane
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|switch_t
modifier|*
name|switch_create
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|unsigned
name|id
parameter_list|,
name|osm_switch_t
modifier|*
name|p_sw
parameter_list|)
block|{
name|unsigned
name|num_switches
init|=
name|p_lash
operator|->
name|num_switches
decl_stmt|;
name|unsigned
name|num_ports
init|=
name|p_sw
operator|->
name|num_ports
decl_stmt|;
name|switch_t
modifier|*
name|sw
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|sw
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sw
argument_list|)
operator|+
name|num_switches
operator|*
sizeof|sizeof
argument_list|(
name|sw
operator|->
name|routing_table
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sw
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|sw
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sw
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_switches
condition|;
name|i
operator|++
control|)
block|{
name|sw
operator|->
name|routing_table
index|[
name|i
index|]
operator|.
name|out_link
operator|=
name|NONE
expr_stmt|;
name|sw
operator|->
name|routing_table
index|[
name|i
index|]
operator|.
name|lane
operator|=
name|NONE
expr_stmt|;
block|}
name|sw
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|sw
operator|->
name|dij_channels
operator|=
name|malloc
argument_list|(
name|num_ports
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sw
operator|->
name|dij_channels
condition|)
block|{
name|free
argument_list|(
name|sw
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sw
operator|->
name|p_sw
operator|=
name|p_sw
expr_stmt|;
name|p_sw
operator|->
name|priv
operator|=
name|sw
expr_stmt|;
if|if
condition|(
name|osm_mesh_node_create
argument_list|(
name|p_lash
argument_list|,
name|sw
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|sw
operator|->
name|dij_channels
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sw
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|sw
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|switch_delete
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|switch_t
modifier|*
name|sw
parameter_list|)
block|{
if|if
condition|(
name|sw
operator|->
name|dij_channels
condition|)
name|free
argument_list|(
name|sw
operator|->
name|dij_channels
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_mesh_switches
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|)
block|{
if|if
condition|(
name|p_lash
operator|->
name|switches
condition|)
block|{
name|unsigned
name|id
decl_stmt|;
for|for
control|(
name|id
operator|=
literal|0
init|;
operator|(
operator|(
name|int
operator|)
name|id
operator|)
operator|<
name|p_lash
operator|->
name|num_switches
condition|;
name|id
operator|++
control|)
if|if
condition|(
name|p_lash
operator|->
name|switches
index|[
name|id
index|]
condition|)
name|osm_mesh_node_delete
argument_list|(
name|p_lash
argument_list|,
name|p_lash
operator|->
name|switches
index|[
name|id
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|free_lash_structures
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|unsigned
name|num_switches
init|=
name|p_lash
operator|->
name|num_switches
decl_stmt|;
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|delete_mesh_switches
argument_list|(
name|p_lash
argument_list|)
expr_stmt|;
comment|/* free cdg_vertex_matrix */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_lash
operator|->
name|vl_min
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_switches
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|num_switches
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|p_lash
operator|->
name|cdg_vertex_matrix
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
condition|)
name|free
argument_list|(
name|p_lash
operator|->
name|cdg_vertex_matrix
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_lash
operator|->
name|cdg_vertex_matrix
index|[
name|i
index|]
index|[
name|j
index|]
condition|)
name|free
argument_list|(
name|p_lash
operator|->
name|cdg_vertex_matrix
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_lash
operator|->
name|cdg_vertex_matrix
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|p_lash
operator|->
name|cdg_vertex_matrix
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_lash
operator|->
name|cdg_vertex_matrix
condition|)
name|free
argument_list|(
name|p_lash
operator|->
name|cdg_vertex_matrix
argument_list|)
expr_stmt|;
comment|/* free virtual_location */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_switches
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_switches
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|p_lash
operator|->
name|virtual_location
index|[
name|i
index|]
index|[
name|j
index|]
condition|)
name|free
argument_list|(
name|p_lash
operator|->
name|virtual_location
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_lash
operator|->
name|virtual_location
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|p_lash
operator|->
name|virtual_location
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_lash
operator|->
name|virtual_location
condition|)
name|free
argument_list|(
name|p_lash
operator|->
name|virtual_location
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_lash_structures
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|)
block|{
name|unsigned
name|vl_min
init|=
name|p_lash
operator|->
name|vl_min
decl_stmt|;
name|unsigned
name|num_switches
init|=
name|p_lash
operator|->
name|num_switches
decl_stmt|;
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
comment|/* initialise cdg_vertex_matrix[num_switches][num_switches][num_switches] */
name|p_lash
operator|->
name|cdg_vertex_matrix
operator|=
operator|(
name|cdg_vertex_t
operator|*
operator|*
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|vl_min
operator|*
sizeof|sizeof
argument_list|(
name|cdg_vertex_t
operator|*
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_lash
operator|->
name|cdg_vertex_matrix
operator|==
name|NULL
condition|)
goto|goto
name|Exit_Mem_Error
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vl_min
condition|;
name|i
operator|++
control|)
block|{
name|p_lash
operator|->
name|cdg_vertex_matrix
index|[
name|i
index|]
operator|=
operator|(
name|cdg_vertex_t
operator|*
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|num_switches
operator|*
sizeof|sizeof
argument_list|(
name|cdg_vertex_t
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_lash
operator|->
name|cdg_vertex_matrix
index|[
name|i
index|]
operator|==
name|NULL
condition|)
goto|goto
name|Exit_Mem_Error
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vl_min
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_switches
condition|;
name|j
operator|++
control|)
block|{
name|p_lash
operator|->
name|cdg_vertex_matrix
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
name|cdg_vertex_t
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|num_switches
operator|*
sizeof|sizeof
argument_list|(
name|cdg_vertex_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_lash
operator|->
name|cdg_vertex_matrix
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
name|NULL
condition|)
goto|goto
name|Exit_Mem_Error
goto|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|num_switches
condition|;
name|k
operator|++
control|)
name|p_lash
operator|->
name|cdg_vertex_matrix
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	 * initialise virtual_location[num_switches][num_switches][num_layers], 	 * default value = 0 	 */
name|p_lash
operator|->
name|virtual_location
operator|=
operator|(
name|int
operator|*
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|num_switches
operator|*
sizeof|sizeof
argument_list|(
name|int
operator|*
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_lash
operator|->
name|virtual_location
operator|==
name|NULL
condition|)
goto|goto
name|Exit_Mem_Error
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_switches
condition|;
name|i
operator|++
control|)
block|{
name|p_lash
operator|->
name|virtual_location
index|[
name|i
index|]
operator|=
operator|(
name|int
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|num_switches
operator|*
sizeof|sizeof
argument_list|(
name|int
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_lash
operator|->
name|virtual_location
index|[
name|i
index|]
operator|==
name|NULL
condition|)
goto|goto
name|Exit_Mem_Error
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_switches
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_switches
condition|;
name|j
operator|++
control|)
block|{
name|p_lash
operator|->
name|virtual_location
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
name|vl_min
operator|*
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_lash
operator|->
name|virtual_location
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
name|NULL
condition|)
goto|goto
name|Exit_Mem_Error
goto|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|vl_min
condition|;
name|k
operator|++
control|)
name|p_lash
operator|->
name|virtual_location
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* initialise num_mst_in_lane[num_switches], default 0 */
name|memset
argument_list|(
name|p_lash
operator|->
name|num_mst_in_lane
argument_list|,
literal|0
argument_list|,
name|IB_MAX_NUM_VLS
operator|*
sizeof|sizeof
argument_list|(
name|p_lash
operator|->
name|num_mst_in_lane
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
name|Exit_Mem_Error
label|:
name|status
operator|=
operator|-
literal|1
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4D01: "
literal|"Could not allocate required memory for LASH errno %d, errno %d for lack of memory\n"
argument_list|,
name|errno
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lash_core
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|unsigned
name|num_switches
init|=
name|p_lash
operator|->
name|num_switches
decl_stmt|;
name|switch_t
modifier|*
modifier|*
name|switches
init|=
name|p_lash
operator|->
name|switches
decl_stmt|;
name|unsigned
name|lanes_needed
init|=
literal|1
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|dest_switch
init|=
literal|0
decl_stmt|;
name|reachable_dest_t
modifier|*
name|dests
decl_stmt|,
modifier|*
name|idest
decl_stmt|;
name|int
name|cycle_found
init|=
literal|0
decl_stmt|;
name|unsigned
name|v_lane
decl_stmt|;
name|int
name|stop
init|=
literal|0
decl_stmt|,
name|output_link
decl_stmt|,
name|i_next_switch
decl_stmt|;
name|int
name|output_link2
decl_stmt|,
name|i_next_switch2
decl_stmt|;
name|int
name|cycle_found2
init|=
literal|0
decl_stmt|;
name|int
name|status
init|=
operator|-
literal|1
decl_stmt|;
name|int
modifier|*
name|switch_bitmap
init|=
name|NULL
decl_stmt|;
comment|/* Bitmap to check if we have processed this pair */
name|unsigned
name|start_vl
init|=
name|p_lash
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|lash_start_vl
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_lash
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|do_mesh_analysis
operator|&&
name|osm_do_mesh_analysis
argument_list|(
name|p_lash
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4D05: Mesh analysis failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_switches
condition|;
name|i
operator|++
control|)
block|{
name|shortest_path
argument_list|(
name|p_lash
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|generate_routing_func_for_mst
argument_list|(
name|p_lash
argument_list|,
name|i
argument_list|,
operator|&
name|dests
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4D06: "
literal|"generate_routing_func_for_mst failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|idest
operator|=
name|dests
expr_stmt|;
while|while
condition|(
name|idest
operator|!=
name|NULL
condition|)
block|{
name|dests
operator|=
name|dests
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|idest
argument_list|)
expr_stmt|;
name|idest
operator|=
name|dests
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_switches
condition|;
name|j
operator|++
control|)
block|{
name|switches
index|[
name|j
index|]
operator|->
name|used_channels
operator|=
literal|0
expr_stmt|;
name|switches
index|[
name|j
index|]
operator|->
name|q_state
operator|=
name|UNQUEUED
expr_stmt|;
block|}
block|}
name|switch_bitmap
operator|=
name|calloc
argument_list|(
name|num_switches
operator|*
name|num_switches
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|switch_bitmap
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4D04: "
literal|"Failed allocating switch_bitmap - out of memory\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_switches
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|dest_switch
operator|=
literal|0
init|;
name|dest_switch
operator|<
name|num_switches
condition|;
name|dest_switch
operator|++
control|)
if|if
condition|(
name|dest_switch
operator|!=
name|i
operator|&&
name|switch_bitmap
index|[
name|i
operator|*
name|num_switches
operator|+
name|dest_switch
index|]
operator|==
literal|0
condition|)
block|{
name|v_lane
operator|=
literal|0
expr_stmt|;
name|stop
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|v_lane
operator|<
name|lanes_needed
operator|&&
name|stop
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|generate_cdg_for_sp
argument_list|(
name|p_lash
argument_list|,
name|i
argument_list|,
name|dest_switch
argument_list|,
name|v_lane
argument_list|)
operator|||
name|generate_cdg_for_sp
argument_list|(
name|p_lash
argument_list|,
name|dest_switch
argument_list|,
name|i
argument_list|,
name|v_lane
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4D07: generate_cdg_for_sp failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|output_link
operator|=
name|switches
index|[
name|i
index|]
operator|->
name|routing_table
index|[
name|dest_switch
index|]
operator|.
name|out_link
expr_stmt|;
name|output_link2
operator|=
name|switches
index|[
name|dest_switch
index|]
operator|->
name|routing_table
index|[
name|i
index|]
operator|.
name|out_link
expr_stmt|;
name|i_next_switch
operator|=
name|get_next_switch
argument_list|(
name|p_lash
argument_list|,
name|i
argument_list|,
name|output_link
argument_list|)
expr_stmt|;
name|i_next_switch2
operator|=
name|get_next_switch
argument_list|(
name|p_lash
argument_list|,
name|dest_switch
argument_list|,
name|output_link2
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_lash
operator|->
name|cdg_vertex_matrix
index|[
name|v_lane
index|]
index|[
name|i
index|]
index|[
name|i_next_switch
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_lash
operator|->
name|cdg_vertex_matrix
index|[
name|v_lane
index|]
index|[
name|dest_switch
index|]
index|[
name|i_next_switch2
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|cycle_found
operator|=
name|cycle_exists
argument_list|(
name|p_lash
operator|->
name|cdg_vertex_matrix
index|[
name|v_lane
index|]
index|[
name|i
index|]
index|[
name|i_next_switch
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cycle_found2
operator|=
name|cycle_exists
argument_list|(
name|p_lash
operator|->
name|cdg_vertex_matrix
index|[
name|v_lane
index|]
index|[
name|dest_switch
index|]
index|[
name|i_next_switch2
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_switches
condition|;
name|j
operator|++
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|num_switches
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|p_lash
operator|->
name|cdg_vertex_matrix
index|[
name|v_lane
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|!=
name|NULL
condition|)
block|{
name|p_lash
operator|->
name|cdg_vertex_matrix
index|[
name|v_lane
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|->
name|visiting_number
operator|=
literal|0
expr_stmt|;
name|p_lash
operator|->
name|cdg_vertex_matrix
index|[
name|v_lane
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|->
name|seen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cycle_found
operator|==
literal|1
operator|||
name|cycle_found2
operator|==
literal|1
condition|)
block|{
name|remove_temp_depend_for_sp
argument_list|(
name|p_lash
argument_list|,
name|i
argument_list|,
name|dest_switch
argument_list|,
name|v_lane
argument_list|)
expr_stmt|;
name|remove_temp_depend_for_sp
argument_list|(
name|p_lash
argument_list|,
name|dest_switch
argument_list|,
name|i
argument_list|,
name|v_lane
argument_list|)
expr_stmt|;
name|v_lane
operator|++
expr_stmt|;
block|}
else|else
block|{
name|set_temp_depend_to_permanent_for_sp
argument_list|(
name|p_lash
argument_list|,
name|i
argument_list|,
name|dest_switch
argument_list|,
name|v_lane
argument_list|)
expr_stmt|;
name|set_temp_depend_to_permanent_for_sp
argument_list|(
name|p_lash
argument_list|,
name|dest_switch
argument_list|,
name|i
argument_list|,
name|v_lane
argument_list|)
expr_stmt|;
name|stop
operator|=
literal|1
expr_stmt|;
name|p_lash
operator|->
name|num_mst_in_lane
index|[
name|v_lane
index|]
operator|++
expr_stmt|;
name|p_lash
operator|->
name|num_mst_in_lane
index|[
name|v_lane
index|]
operator|++
expr_stmt|;
block|}
block|}
name|switches
index|[
name|i
index|]
operator|->
name|routing_table
index|[
name|dest_switch
index|]
operator|.
name|lane
operator|=
name|v_lane
operator|+
name|start_vl
expr_stmt|;
name|switches
index|[
name|dest_switch
index|]
operator|->
name|routing_table
index|[
name|i
index|]
operator|.
name|lane
operator|=
name|v_lane
operator|+
name|start_vl
expr_stmt|;
if|if
condition|(
name|cycle_found
operator|==
literal|1
operator|||
name|cycle_found2
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|++
name|lanes_needed
operator|>
name|p_lash
operator|->
name|vl_min
condition|)
goto|goto
name|Error_Not_Enough_Lanes
goto|;
if|if
condition|(
name|generate_cdg_for_sp
argument_list|(
name|p_lash
argument_list|,
name|i
argument_list|,
name|dest_switch
argument_list|,
name|v_lane
argument_list|)
operator|||
name|generate_cdg_for_sp
argument_list|(
name|p_lash
argument_list|,
name|dest_switch
argument_list|,
name|i
argument_list|,
name|v_lane
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4D08: generate_cdg_for_sp failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|set_temp_depend_to_permanent_for_sp
argument_list|(
name|p_lash
argument_list|,
name|i
argument_list|,
name|dest_switch
argument_list|,
name|v_lane
argument_list|)
expr_stmt|;
name|set_temp_depend_to_permanent_for_sp
argument_list|(
name|p_lash
argument_list|,
name|dest_switch
argument_list|,
name|i
argument_list|,
name|v_lane
argument_list|)
expr_stmt|;
name|p_lash
operator|->
name|num_mst_in_lane
index|[
name|v_lane
index|]
operator|++
expr_stmt|;
name|p_lash
operator|->
name|num_mst_in_lane
index|[
name|v_lane
index|]
operator|++
expr_stmt|;
block|}
name|p_lash
operator|->
name|virtual_location
index|[
name|i
index|]
index|[
name|dest_switch
index|]
index|[
name|v_lane
index|]
operator|=
literal|1
expr_stmt|;
name|p_lash
operator|->
name|virtual_location
index|[
name|dest_switch
index|]
index|[
name|i
index|]
index|[
name|v_lane
index|]
operator|=
literal|1
expr_stmt|;
name|switch_bitmap
index|[
name|i
operator|*
name|num_switches
operator|+
name|dest_switch
index|]
operator|=
literal|1
expr_stmt|;
name|switch_bitmap
index|[
name|dest_switch
operator|*
name|num_switches
operator|+
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lanes_needed
condition|;
name|i
operator|++
control|)
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Lanes in layer %d: %d\n"
argument_list|,
name|i
argument_list|,
name|p_lash
operator|->
name|num_mst_in_lane
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Lanes needed: %d, Balancing\n"
argument_list|,
name|lanes_needed
argument_list|)
expr_stmt|;
if|if
condition|(
name|balance_virtual_lanes
argument_list|(
name|p_lash
argument_list|,
name|lanes_needed
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4D09: Balancing failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lanes_needed
condition|;
name|i
operator|++
control|)
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Lanes in layer %d: %d\n"
argument_list|,
name|i
argument_list|,
name|p_lash
operator|->
name|num_mst_in_lane
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
goto|goto
name|Exit
goto|;
name|Error_Not_Enough_Lanes
label|:
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4D02: "
literal|"Lane requirements (%d) exceed available lanes (%d)"
literal|" with starting lane (%d)\n"
argument_list|,
name|lanes_needed
argument_list|,
name|p_lash
operator|->
name|vl_min
argument_list|,
name|start_vl
argument_list|)
expr_stmt|;
name|Exit
label|:
if|if
condition|(
name|switch_bitmap
condition|)
name|free
argument_list|(
name|switch_bitmap
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|get_lash_id
parameter_list|(
name|osm_switch_t
modifier|*
name|p_sw
parameter_list|)
block|{
return|return
operator|(
operator|(
name|switch_t
operator|*
operator|)
name|p_sw
operator|->
name|priv
operator|)
operator|->
name|id
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_next_port
parameter_list|(
name|switch_t
modifier|*
name|sw
parameter_list|,
name|int
name|link
parameter_list|)
block|{
name|link_t
modifier|*
name|l
init|=
name|sw
operator|->
name|node
operator|->
name|links
index|[
name|link
index|]
decl_stmt|;
name|int
name|port
init|=
name|l
operator|->
name|next_port
operator|++
decl_stmt|;
comment|/* 	 * note if not doing mesh analysis 	 * then num_ports is always 1 	 */
if|if
condition|(
name|l
operator|->
name|next_port
operator|>=
name|l
operator|->
name|num_ports
condition|)
name|l
operator|->
name|next_port
operator|=
literal|0
expr_stmt|;
return|return
name|l
operator|->
name|ports
index|[
name|port
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|populate_fwd_tbls
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|osm_subn_t
modifier|*
name|p_subn
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|subn
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|,
modifier|*
name|p_next_sw
decl_stmt|,
modifier|*
name|p_dst_sw
decl_stmt|;
name|osm_port_t
modifier|*
name|port
decl_stmt|;
name|uint16_t
name|max_lid_ho
decl_stmt|,
name|lid
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|)
expr_stmt|;
comment|/* Go through each switch individually */
while|while
condition|(
name|p_next_sw
operator|!=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|)
condition|)
block|{
name|uint64_t
name|current_guid
decl_stmt|;
name|switch_t
modifier|*
name|sw
decl_stmt|;
name|p_sw
operator|=
name|p_next_sw
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
name|max_lid_ho
operator|=
name|p_sw
operator|->
name|max_lid_ho
expr_stmt|;
name|current_guid
operator|=
name|p_sw
operator|->
name|p_node
operator|->
name|node_info
operator|.
name|port_guid
expr_stmt|;
name|sw
operator|=
name|p_sw
operator|->
name|priv
expr_stmt|;
name|memset
argument_list|(
name|p_sw
operator|->
name|new_lft
argument_list|,
name|OSM_NO_PATH
argument_list|,
name|p_sw
operator|->
name|lft_size
argument_list|)
expr_stmt|;
for|for
control|(
name|lid
operator|=
literal|1
init|;
name|lid
operator|<=
name|max_lid_ho
condition|;
name|lid
operator|++
control|)
block|{
name|port
operator|=
name|osm_get_port_by_lid_ho
argument_list|(
name|p_subn
argument_list|,
name|lid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port
condition|)
continue|continue;
name|p_dst_sw
operator|=
name|get_osm_switch_from_port
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_dst_sw
operator|==
name|p_sw
condition|)
block|{
name|uint8_t
name|egress_port
init|=
name|port
operator|->
name|p_node
operator|->
name|sw
condition|?
literal|0
else|:
name|port
operator|->
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|port_num
decl_stmt|;
name|p_sw
operator|->
name|new_lft
index|[
name|lid
index|]
operator|=
name|egress_port
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"LASH fwd MY SRC SRC GUID 0x%016"
name|PRIx64
literal|" src lash id (%d), src lid no (%u) src lash port (%d) "
literal|"DST GUID 0x%016"
name|PRIx64
literal|" src lash id (%d), src lash port (%d)\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|current_guid
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|lid
argument_list|,
name|egress_port
argument_list|,
name|cl_ntoh64
argument_list|(
name|current_guid
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|egress_port
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_dst_sw
condition|)
block|{
name|unsigned
name|dst_lash_switch_id
init|=
name|get_lash_id
argument_list|(
name|p_dst_sw
argument_list|)
decl_stmt|;
name|uint8_t
name|lash_egress_port
init|=
operator|(
name|uint8_t
operator|)
name|sw
operator|->
name|routing_table
index|[
name|dst_lash_switch_id
index|]
operator|.
name|out_link
decl_stmt|;
name|uint8_t
name|physical_egress_port
init|=
name|get_next_port
argument_list|(
name|sw
argument_list|,
name|lash_egress_port
argument_list|)
decl_stmt|;
name|p_sw
operator|->
name|new_lft
index|[
name|lid
index|]
operator|=
name|physical_egress_port
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"LASH fwd SRC GUID 0x%016"
name|PRIx64
literal|" src lash id (%d), "
literal|"src lid no (%u) src lash port (%d) "
literal|"DST GUID 0x%016"
name|PRIx64
literal|" src lash id (%d), src lash port (%d)\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|current_guid
argument_list|)
argument_list|,
name|sw
operator|->
name|id
argument_list|,
name|lid
argument_list|,
name|lash_egress_port
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_dst_sw
operator|->
name|p_node
operator|->
name|node_info
operator|.
name|port_guid
argument_list|)
argument_list|,
name|dst_lash_switch_id
argument_list|,
name|physical_egress_port
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* for */
block|}
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|osm_lash_process_switch
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|,
name|osm_switch_t
modifier|*
name|p_sw
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|int
name|i
decl_stmt|,
name|port_count
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_current_physp
decl_stmt|,
modifier|*
name|p_remote_physp
decl_stmt|;
name|unsigned
name|switch_a_lash_id
decl_stmt|,
name|switch_b_lash_id
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|switch_a_lash_id
operator|=
name|get_lash_id
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
name|port_count
operator|=
name|osm_node_get_num_physp
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|)
expr_stmt|;
comment|/* starting at port 1, ignoring management port on switch */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|port_count
condition|;
name|i
operator|++
control|)
block|{
name|p_current_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_current_physp
condition|)
block|{
name|p_remote_physp
operator|=
name|p_current_physp
operator|->
name|p_remote_physp
expr_stmt|;
if|if
condition|(
name|p_remote_physp
operator|&&
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
condition|)
block|{
name|int
name|physical_port_a_num
init|=
name|osm_physp_get_port_num
argument_list|(
name|p_current_physp
argument_list|)
decl_stmt|;
name|int
name|physical_port_b_num
init|=
name|osm_physp_get_port_num
argument_list|(
name|p_remote_physp
argument_list|)
decl_stmt|;
name|switch_b_lash_id
operator|=
name|get_lash_id
argument_list|(
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
argument_list|)
expr_stmt|;
name|connect_switches
argument_list|(
name|p_lash
argument_list|,
name|switch_a_lash_id
argument_list|,
name|switch_b_lash_id
argument_list|,
name|physical_port_a_num
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"LASH SUCCESS connected G 0x%016"
name|PRIx64
literal|" , lash_id(%u), P(%u) "
literal|" to G 0x%016"
name|PRIx64
literal|" , lash_id(%u) , P(%u)\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_current_physp
argument_list|)
argument_list|)
argument_list|,
name|switch_a_lash_id
argument_list|,
name|physical_port_a_num
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_remote_physp
argument_list|)
argument_list|)
argument_list|,
name|switch_b_lash_id
argument_list|,
name|physical_port_b_num
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lash_cleanup
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|)
block|{
name|osm_subn_t
modifier|*
name|p_subn
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|subn
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_next_sw
decl_stmt|,
modifier|*
name|p_sw
decl_stmt|;
comment|/* drop any existing references to old lash switches */
name|p_next_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_sw
operator|!=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|)
condition|)
block|{
name|p_sw
operator|=
name|p_next_sw
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|priv
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|p_lash
operator|->
name|switches
condition|)
block|{
name|unsigned
name|id
decl_stmt|;
for|for
control|(
name|id
operator|=
literal|0
init|;
operator|(
operator|(
name|int
operator|)
name|id
operator|)
operator|<
name|p_lash
operator|->
name|num_switches
condition|;
name|id
operator|++
control|)
if|if
condition|(
name|p_lash
operator|->
name|switches
index|[
name|id
index|]
condition|)
name|switch_delete
argument_list|(
name|p_lash
argument_list|,
name|p_lash
operator|->
name|switches
index|[
name|id
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_lash
operator|->
name|switches
argument_list|)
expr_stmt|;
block|}
name|p_lash
operator|->
name|switches
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   static int  discover_network_properties()   Traverse the topology of the network in order to determine    - the maximum number of switches,    - the minimum number of virtual layers */
end_comment

begin_function
specifier|static
name|int
name|discover_network_properties
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|id
init|=
literal|0
decl_stmt|;
name|uint8_t
name|vl_min
decl_stmt|;
name|osm_subn_t
modifier|*
name|p_subn
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|subn
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_next_sw
decl_stmt|,
modifier|*
name|p_sw
decl_stmt|;
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|p_lash
operator|->
name|num_switches
operator|=
name|cl_qmap_count
argument_list|(
operator|&
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|)
expr_stmt|;
name|p_lash
operator|->
name|switches
operator|=
name|calloc
argument_list|(
name|p_lash
operator|->
name|num_switches
argument_list|,
sizeof|sizeof
argument_list|(
name|switch_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_lash
operator|->
name|switches
condition|)
return|return
operator|-
literal|1
return|;
name|vl_min
operator|=
literal|5
expr_stmt|;
comment|/* set to a high value */
name|p_next_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_sw
operator|!=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|)
condition|)
block|{
name|uint16_t
name|port_count
decl_stmt|;
name|p_sw
operator|=
name|p_next_sw
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
name|p_lash
operator|->
name|switches
index|[
name|id
index|]
operator|=
name|switch_create
argument_list|(
name|p_lash
argument_list|,
name|id
argument_list|,
name|p_sw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_lash
operator|->
name|switches
index|[
name|id
index|]
condition|)
return|return
operator|-
literal|1
return|;
name|id
operator|++
expr_stmt|;
name|port_count
operator|=
name|osm_node_get_num_physp
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|)
expr_stmt|;
comment|/* Note, ignoring port 0. management port */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|port_count
condition|;
name|i
operator|++
control|)
block|{
name|osm_physp_t
modifier|*
name|p_current_physp
init|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|p_current_physp
operator|&&
name|p_current_physp
operator|->
name|p_remote_physp
condition|)
block|{
name|ib_port_info_t
modifier|*
name|p_port_info
init|=
operator|&
name|p_current_physp
operator|->
name|port_info
decl_stmt|;
name|uint8_t
name|port_vl_min
init|=
name|ib_port_info_get_op_vls
argument_list|(
name|p_port_info
argument_list|)
decl_stmt|;
if|if
condition|(
name|port_vl_min
operator|&&
name|port_vl_min
operator|<
name|vl_min
condition|)
name|vl_min
operator|=
name|port_vl_min
expr_stmt|;
block|}
block|}
comment|/* for */
block|}
comment|/* while */
name|vl_min
operator|=
literal|1
operator|<<
operator|(
name|vl_min
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|vl_min
operator|>
literal|15
condition|)
name|vl_min
operator|=
literal|15
expr_stmt|;
if|if
condition|(
name|p_lash
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|lash_start_vl
operator|>=
name|vl_min
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4D03: "
literal|"Start VL(%d) too high for min operational vl(%d)\n"
argument_list|,
name|p_lash
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|lash_start_vl
argument_list|,
name|vl_min
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p_lash
operator|->
name|vl_min
operator|=
name|vl_min
operator|-
name|p_lash
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|lash_start_vl
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"min operational vl(%d) start vl(%d) max_switches(%d)\n"
argument_list|,
name|p_lash
operator|->
name|vl_min
argument_list|,
name|p_lash
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|lash_start_vl
argument_list|,
name|p_lash
operator|->
name|num_switches
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_switches
parameter_list|(
name|lash_t
modifier|*
name|p_lash
parameter_list|)
block|{
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|,
modifier|*
name|p_next_sw
decl_stmt|;
name|osm_subn_t
modifier|*
name|p_subn
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|subn
decl_stmt|;
comment|/* Go through each switch and process it. i.e build the connection 	   structure required by LASH */
name|p_next_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_sw
operator|!=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|)
condition|)
block|{
name|p_sw
operator|=
name|p_next_sw
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
name|osm_lash_process_switch
argument_list|(
name|p_lash
argument_list|,
name|p_sw
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|lash_process
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|lash_t
modifier|*
name|p_lash
init|=
name|context
decl_stmt|;
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_lash
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|p_lash
operator|->
name|balance_limit
operator|=
literal|6
expr_stmt|;
comment|/* everything starts here */
name|lash_cleanup
argument_list|(
name|p_lash
argument_list|)
expr_stmt|;
name|status
operator|=
name|discover_network_properties
argument_list|(
name|p_lash
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
goto|goto
name|Exit
goto|;
name|status
operator|=
name|init_lash_structures
argument_list|(
name|p_lash
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
goto|goto
name|Exit
goto|;
name|process_switches
argument_list|(
name|p_lash
argument_list|)
expr_stmt|;
name|status
operator|=
name|lash_core
argument_list|(
name|p_lash
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
goto|goto
name|Exit
goto|;
name|populate_fwd_tbls
argument_list|(
name|p_lash
argument_list|)
expr_stmt|;
name|Exit
label|:
if|if
condition|(
name|p_lash
operator|->
name|vl_min
condition|)
name|free_lash_structures
argument_list|(
name|p_lash
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|lash_t
modifier|*
name|lash_create
parameter_list|(
name|osm_opensm_t
modifier|*
name|p_osm
parameter_list|)
block|{
name|lash_t
modifier|*
name|p_lash
decl_stmt|;
name|p_lash
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|lash_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_lash
condition|)
return|return
name|NULL
return|;
name|p_lash
operator|->
name|p_osm
operator|=
name|p_osm
expr_stmt|;
return|return
name|p_lash
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lash_delete
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|lash_t
modifier|*
name|p_lash
init|=
name|context
decl_stmt|;
if|if
condition|(
name|p_lash
operator|->
name|switches
condition|)
block|{
name|unsigned
name|id
decl_stmt|;
for|for
control|(
name|id
operator|=
literal|0
init|;
operator|(
operator|(
name|int
operator|)
name|id
operator|)
operator|<
name|p_lash
operator|->
name|num_switches
condition|;
name|id
operator|++
control|)
if|if
condition|(
name|p_lash
operator|->
name|switches
index|[
name|id
index|]
condition|)
name|switch_delete
argument_list|(
name|p_lash
argument_list|,
name|p_lash
operator|->
name|switches
index|[
name|id
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_lash
operator|->
name|switches
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|p_lash
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|get_lash_sl
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|uint8_t
name|path_sl_hint
parameter_list|,
specifier|const
name|ib_net16_t
name|slid
parameter_list|,
specifier|const
name|ib_net16_t
name|dlid
parameter_list|)
block|{
name|unsigned
name|dst_id
decl_stmt|;
name|unsigned
name|src_id
decl_stmt|;
name|osm_port_t
modifier|*
name|p_src_port
decl_stmt|,
modifier|*
name|p_dst_port
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|lash_t
modifier|*
name|p_lash
init|=
name|context
decl_stmt|;
name|osm_opensm_t
modifier|*
name|p_osm
init|=
name|p_lash
operator|->
name|p_osm
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_osm
operator|->
name|routing_engine_used
operator|&&
name|p_osm
operator|->
name|routing_engine_used
operator|->
name|type
operator|==
name|OSM_ROUTING_ENGINE_TYPE_LASH
operator|)
condition|)
return|return
name|OSM_DEFAULT_SL
return|;
name|p_src_port
operator|=
name|osm_get_port_by_lid
argument_list|(
operator|&
name|p_osm
operator|->
name|subn
argument_list|,
name|slid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_src_port
condition|)
return|return
name|OSM_DEFAULT_SL
return|;
name|p_dst_port
operator|=
name|osm_get_port_by_lid
argument_list|(
operator|&
name|p_osm
operator|->
name|subn
argument_list|,
name|dlid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_dst_port
condition|)
return|return
name|OSM_DEFAULT_SL
return|;
name|p_sw
operator|=
name|get_osm_switch_from_port
argument_list|(
name|p_dst_port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_sw
operator|||
operator|!
name|p_sw
operator|->
name|priv
condition|)
return|return
name|OSM_DEFAULT_SL
return|;
name|dst_id
operator|=
name|get_lash_id
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
name|p_sw
operator|=
name|get_osm_switch_from_port
argument_list|(
name|p_src_port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_sw
operator|||
operator|!
name|p_sw
operator|->
name|priv
condition|)
return|return
name|OSM_DEFAULT_SL
return|;
name|src_id
operator|=
name|get_lash_id
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_id
operator|==
name|dst_id
condition|)
return|return
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|lash_start_vl
return|;
return|return
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|switch_t
operator|*
operator|)
name|p_sw
operator|->
name|priv
argument_list|)
operator|->
name|routing_table
index|[
name|dst_id
index|]
operator|.
name|lane
return|;
block|}
end_function

begin_function
name|int
name|osm_ucast_lash_setup
parameter_list|(
name|struct
name|osm_routing_engine
modifier|*
name|r
parameter_list|,
name|osm_opensm_t
modifier|*
name|p_osm
parameter_list|)
block|{
name|lash_t
modifier|*
name|p_lash
init|=
name|lash_create
argument_list|(
name|p_osm
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p_lash
condition|)
return|return
operator|-
literal|1
return|;
name|r
operator|->
name|context
operator|=
name|p_lash
expr_stmt|;
name|r
operator|->
name|ucast_build_fwd_tables
operator|=
name|lash_process
expr_stmt|;
name|r
operator|->
name|path_sl
operator|=
name|get_lash_sl
expr_stmt|;
name|r
operator|->
name|destroy
operator|=
name|lash_delete
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

