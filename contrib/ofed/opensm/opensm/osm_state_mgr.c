begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2009 Sun Microsystems, Inc. All rights reserved.  * Copyright (c) 2004-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2015 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  * Copyright (c) 2009 HNR Consulting. All rights reserved.  * Copyright (c) 2013 Oracle and/or its affiliates. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_state_mgr_t.  * This file implements the State Manager object.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_passivelock.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qmap.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_STATE_MGR_C
end_define

begin_include
include|#
directive|include
file|<opensm/osm_sm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_madw.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_switch.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_subnet.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_msgdef.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_node.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_port.h>
end_include

begin_include
include|#
directive|include
file|<vendor/osm_vendor_api.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_inform.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_congestion_control.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_db.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_service.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_guid.h>
end_include

begin_function_decl
specifier|extern
name|void
name|osm_drop_mgr_process
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|osm_qos_setup
parameter_list|(
name|IN
name|osm_opensm_t
modifier|*
name|p_osm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|osm_pkey_mgr_process
parameter_list|(
name|IN
name|osm_opensm_t
modifier|*
name|p_osm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|osm_mcast_mgr_process
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|boolean_t
name|config_all
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|osm_link_mgr_process
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|uint8_t
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|osm_guid_mgr_process
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|state_mgr_up_msg
parameter_list|(
name|IN
specifier|const
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
comment|/* 	 * This message should be written only once - when the 	 * SM moves to Master state and the subnet is up for 	 * the first time. 	 */
name|osm_log_v2
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|sm
operator|->
name|p_subn
operator|->
name|first_time_master_sweep
condition|?
name|OSM_LOG_SYS
else|:
name|OSM_LOG_INFO
argument_list|,
name|FILE_ID
argument_list|,
literal|"SUBNET UP\n"
argument_list|)
expr_stmt|;
name|OSM_LOG_MSG_BOX
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|sweep_interval
condition|?
literal|"SUBNET UP"
else|:
literal|"SUBNET UP (sweep disabled)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|state_mgr_reset_node_count
parameter_list|(
name|IN
name|cl_map_item_t
modifier|*
name|p_map_item
parameter_list|,
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
name|osm_node_t
modifier|*
name|p_node
init|=
operator|(
name|osm_node_t
operator|*
operator|)
name|p_map_item
decl_stmt|;
name|p_node
operator|->
name|discovery_count
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|p_node
operator|->
name|physp_discovered
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|*
name|p_node
operator|->
name|physp_tbl_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|state_mgr_reset_port_count
parameter_list|(
name|IN
name|cl_map_item_t
modifier|*
name|p_map_item
parameter_list|,
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
name|osm_port_t
modifier|*
name|p_port
init|=
operator|(
name|osm_port_t
operator|*
operator|)
name|p_map_item
decl_stmt|;
name|p_port
operator|->
name|discovery_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|state_mgr_reset_switch_count
parameter_list|(
name|IN
name|cl_map_item_t
modifier|*
name|p_map_item
parameter_list|,
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
name|osm_switch_t
modifier|*
name|p_sw
init|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|p_map_item
decl_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|max_lid_ho
operator|!=
literal|0
condition|)
name|p_sw
operator|->
name|need_update
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|state_mgr_get_sw_info
parameter_list|(
name|IN
name|cl_map_item_t
modifier|*
name|p_object
parameter_list|,
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|osm_dr_path_t
modifier|*
name|p_dr_path
decl_stmt|;
name|osm_madw_context_t
name|mad_context
decl_stmt|;
name|osm_switch_t
modifier|*
specifier|const
name|p_sw
init|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|p_object
decl_stmt|;
name|osm_sm_t
modifier|*
name|sm
init|=
name|context
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_node
operator|=
name|p_sw
operator|->
name|p_node
expr_stmt|;
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p_dr_path
operator|=
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mad_context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mad_context
argument_list|)
argument_list|)
expr_stmt|;
name|mad_context
operator|.
name|si_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|mad_context
operator|.
name|si_context
operator|.
name|set_method
operator|=
name|FALSE
expr_stmt|;
name|mad_context
operator|.
name|si_context
operator|.
name|light_sweep
operator|=
name|TRUE
expr_stmt|;
name|mad_context
operator|.
name|si_context
operator|.
name|lft_top_change
operator|=
name|FALSE
expr_stmt|;
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
name|p_dr_path
argument_list|,
name|IB_MAD_ATTR_SWITCH_INFO
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|ib_port_info_get_m_key
argument_list|(
operator|&
name|p_physp
operator|->
name|port_info
argument_list|)
argument_list|,
name|OSM_MSG_LIGHT_SWEEP_FAIL
argument_list|,
operator|&
name|mad_context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3304: "
literal|"Request for SwitchInfo from 0x%"
name|PRIx64
literal|" failed (%s)\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Initiate a remote port info request for the given physical port  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|state_mgr_get_remote_port_info
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_physp_t
modifier|*
name|p_physp
parameter_list|)
block|{
name|osm_dr_path_t
modifier|*
name|p_dr_path
decl_stmt|;
name|osm_dr_path_t
name|rem_node_dr_path
decl_stmt|;
name|osm_madw_context_t
name|mad_context
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* generate a dr path leaving on the physp to the remote node */
name|p_dr_path
operator|=
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|rem_node_dr_path
argument_list|,
name|p_dr_path
argument_list|,
sizeof|sizeof
argument_list|(
name|osm_dr_path_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_dr_path_extend
argument_list|(
operator|&
name|rem_node_dr_path
argument_list|,
name|osm_physp_get_port_num
argument_list|(
name|p_physp
argument_list|)
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 332D: "
literal|"DR path with hop count %d couldn't be extended "
literal|"so skipping PortInfo query\n"
argument_list|,
name|p_dr_path
operator|->
name|hop_count
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|memset
argument_list|(
operator|&
name|mad_context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mad_context
argument_list|)
argument_list|)
expr_stmt|;
name|mad_context
operator|.
name|pi_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|osm_physp_get_node_ptr
argument_list|(
name|p_physp
argument_list|)
argument_list|)
expr_stmt|;
name|mad_context
operator|.
name|pi_context
operator|.
name|port_guid
operator|=
name|p_physp
operator|->
name|port_guid
expr_stmt|;
name|mad_context
operator|.
name|pi_context
operator|.
name|set_method
operator|=
name|FALSE
expr_stmt|;
name|mad_context
operator|.
name|pi_context
operator|.
name|light_sweep
operator|=
name|TRUE
expr_stmt|;
name|mad_context
operator|.
name|pi_context
operator|.
name|active_transition
operator|=
name|FALSE
expr_stmt|;
name|mad_context
operator|.
name|pi_context
operator|.
name|client_rereg
operator|=
name|FALSE
expr_stmt|;
comment|/* note that with some negative logic - if the query failed it means 	 * that there is no point in going to heavy sweep */
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
operator|&
name|rem_node_dr_path
argument_list|,
name|IB_MAD_ATTR_PORT_INFO
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|mad_context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 332E: "
literal|"Request for remote PortInfo from 0x%"
name|PRIx64
literal|" failed (%s)\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_physp
operator|->
name|port_guid
argument_list|)
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Initiates a thorough sweep of the subnet.  Used when there is suspicion that something on the subnet has changed. **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|state_mgr_sweep_hop_0
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|ib_api_status_t
name|status
decl_stmt|;
name|osm_dr_path_t
name|dr_path
decl_stmt|;
name|osm_bind_handle_t
name|h_bind
decl_stmt|;
name|uint8_t
name|path_array
index|[
name|IB_SUBNET_PATH_HOPS_MAX
index|]
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|path_array
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|path_array
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * First, get the bind handle. 	 */
name|h_bind
operator|=
name|osm_sm_mad_ctrl_get_bind_handle
argument_list|(
operator|&
name|sm
operator|->
name|mad_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|h_bind
operator|!=
name|OSM_BIND_INVALID_HANDLE
condition|)
block|{
name|OSM_LOG_MSG_BOX
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"INITIATING HEAVY SWEEP"
argument_list|)
expr_stmt|;
comment|/* 		 * Start the sweep by clearing the port counts, then 		 * get our own NodeInfo at 0 hops. 		 */
name|CL_PLOCK_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|cl_qmap_apply_func
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|node_guid_tbl
argument_list|,
name|state_mgr_reset_node_count
argument_list|,
name|sm
argument_list|)
expr_stmt|;
name|cl_qmap_apply_func
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|port_guid_tbl
argument_list|,
name|state_mgr_reset_port_count
argument_list|,
name|sm
argument_list|)
expr_stmt|;
name|cl_qmap_apply_func
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|,
name|state_mgr_reset_switch_count
argument_list|,
name|sm
argument_list|)
expr_stmt|;
comment|/* Set the in_sweep_hop_0 flag in subn to be TRUE. 		 * This will indicate the sweeping not to continue beyond the 		 * the current node. 		 * This is relevant for the case of SM on switch, since in the 		 * switch info we need to signal somehow not to continue 		 * the sweeping. */
name|sm
operator|->
name|p_subn
operator|->
name|in_sweep_hop_0
operator|=
name|TRUE
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|osm_dr_path_init
argument_list|(
operator|&
name|dr_path
argument_list|,
literal|0
argument_list|,
name|path_array
argument_list|)
expr_stmt|;
name|CL_PLOCK_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
operator|&
name|dr_path
argument_list|,
name|IB_MAD_ATTR_NODE_INFO
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3305: "
literal|"Request for NodeInfo failed (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"No bound ports. Deferring sweep...\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_INVALID_STATE
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Clear out all existing port lid assignments **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|state_mgr_clean_known_lids
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|cl_ptr_vector_t
modifier|*
name|p_vec
init|=
operator|&
operator|(
name|sm
operator|->
name|p_subn
operator|->
name|port_lid_tbl
operator|)
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* we need a lock here! */
name|CL_PLOCK_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cl_ptr_vector_get_size
argument_list|(
name|p_vec
argument_list|)
condition|;
name|i
operator|++
control|)
name|cl_ptr_vector_set
argument_list|(
name|p_vec
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Clear SA cache **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|state_mgr_sa_clean
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|cl_qmap_t
modifier|*
name|p_port_guid_tbl
decl_stmt|;
name|osm_assigned_guids_t
modifier|*
name|p_assigned_guids
decl_stmt|,
modifier|*
name|p_next_assigned_guids
decl_stmt|;
name|osm_alias_guid_t
modifier|*
name|p_alias_guid
decl_stmt|,
modifier|*
name|p_next_alias_guid
decl_stmt|;
name|osm_mcm_port_t
modifier|*
name|mcm_port
decl_stmt|;
name|osm_subn_t
modifier|*
name|p_subn
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|osm_infr_t
modifier|*
name|p_infr
decl_stmt|;
name|osm_svcr_t
modifier|*
name|p_svcr
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_subn
operator|=
name|sm
operator|->
name|p_subn
expr_stmt|;
comment|/* we need a lock here! */
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_subn
operator|->
name|opt
operator|.
name|drop_event_subscriptions
condition|)
block|{
comment|/* Clean InformInfo records */
name|p_infr
operator|=
operator|(
name|osm_infr_t
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
operator|&
name|p_subn
operator|->
name|sa_infr_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_infr
operator|!=
operator|(
name|osm_infr_t
operator|*
operator|)
name|cl_qlist_end
argument_list|(
operator|&
name|p_subn
operator|->
name|sa_infr_list
argument_list|)
condition|)
block|{
name|osm_infr_delete
argument_list|(
name|p_infr
argument_list|)
expr_stmt|;
name|p_infr
operator|=
operator|(
name|osm_infr_t
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
operator|&
name|p_subn
operator|->
name|sa_infr_list
argument_list|)
expr_stmt|;
block|}
comment|/* For now, treat Service Records in same category as InformInfos */
comment|/* Clean Service records */
name|p_svcr
operator|=
operator|(
name|osm_svcr_t
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
operator|&
name|p_subn
operator|->
name|sa_sr_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_svcr
operator|!=
operator|(
name|osm_svcr_t
operator|*
operator|)
name|cl_qlist_end
argument_list|(
operator|&
name|p_subn
operator|->
name|sa_sr_list
argument_list|)
condition|)
block|{
name|osm_svcr_delete
argument_list|(
name|p_svcr
argument_list|)
expr_stmt|;
name|p_svcr
operator|=
operator|(
name|osm_svcr_t
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
operator|&
name|p_subn
operator|->
name|sa_sr_list
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clean Multicast member list on each port */
name|p_port_guid_tbl
operator|=
operator|&
name|p_subn
operator|->
name|port_guid_tbl
expr_stmt|;
for|for
control|(
name|p_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_port_guid_tbl
argument_list|)
init|;
name|p_port
operator|!=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_port_guid_tbl
argument_list|)
condition|;
name|p_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_port
operator|->
name|map_item
argument_list|)
control|)
block|{
while|while
condition|(
operator|!
name|cl_is_qlist_empty
argument_list|(
operator|&
name|p_port
operator|->
name|mcm_list
argument_list|)
condition|)
block|{
name|mcm_port
operator|=
name|cl_item_obj
argument_list|(
name|cl_qlist_head
argument_list|(
operator|&
name|p_port
operator|->
name|mcm_list
argument_list|)
argument_list|,
name|mcm_port
argument_list|,
name|list_item
argument_list|)
expr_stmt|;
name|osm_mgrp_delete_port
argument_list|(
name|p_subn
argument_list|,
name|sm
operator|->
name|p_log
argument_list|,
name|mcm_port
operator|->
name|mgrp
argument_list|,
name|p_port
argument_list|)
expr_stmt|;
block|}
comment|/* Hack - clean alias guid table from physp */
name|free
argument_list|(
name|p_port
operator|->
name|p_physp
operator|->
name|p_guids
argument_list|)
expr_stmt|;
name|p_port
operator|->
name|p_physp
operator|->
name|p_guids
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Clean Alias Guid work objects */
while|while
condition|(
name|cl_qlist_count
argument_list|(
operator|&
name|p_subn
operator|->
name|alias_guid_list
argument_list|)
condition|)
name|osm_guid_work_obj_delete
argument_list|(
operator|(
name|osm_guidinfo_work_obj_t
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
operator|&
name|p_subn
operator|->
name|alias_guid_list
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Clean Assigned GUIDs table */
name|p_next_assigned_guids
operator|=
operator|(
name|osm_assigned_guids_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_subn
operator|->
name|assigned_guids_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_assigned_guids
operator|!=
operator|(
name|osm_assigned_guids_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_subn
operator|->
name|assigned_guids_tbl
argument_list|)
condition|)
block|{
name|p_assigned_guids
operator|=
name|p_next_assigned_guids
expr_stmt|;
name|p_next_assigned_guids
operator|=
operator|(
name|osm_assigned_guids_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_assigned_guids
operator|->
name|map_item
argument_list|)
expr_stmt|;
name|cl_qmap_remove_item
argument_list|(
operator|&
name|p_subn
operator|->
name|assigned_guids_tbl
argument_list|,
operator|&
name|p_assigned_guids
operator|->
name|map_item
argument_list|)
expr_stmt|;
name|osm_assigned_guids_delete
argument_list|(
operator|&
name|p_assigned_guids
argument_list|)
expr_stmt|;
block|}
comment|/* Clean Alias GUIDs table */
name|p_next_alias_guid
operator|=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_subn
operator|->
name|alias_port_guid_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_alias_guid
operator|!=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_subn
operator|->
name|alias_port_guid_tbl
argument_list|)
condition|)
block|{
name|p_alias_guid
operator|=
name|p_next_alias_guid
expr_stmt|;
name|p_next_alias_guid
operator|=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_alias_guid
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_alias_guid_get_alias_guid
argument_list|(
name|p_alias_guid
argument_list|)
operator|!=
name|osm_alias_guid_get_base_guid
argument_list|(
name|p_alias_guid
argument_list|)
condition|)
block|{
comment|/* Clean if it's not base port GUID */
name|cl_qmap_remove_item
argument_list|(
operator|&
name|p_subn
operator|->
name|alias_port_guid_tbl
argument_list|,
operator|&
name|p_alias_guid
operator|->
name|map_item
argument_list|)
expr_stmt|;
name|osm_alias_guid_delete
argument_list|(
operator|&
name|p_alias_guid
argument_list|)
expr_stmt|;
block|}
block|}
name|p_subn
operator|->
name|p_osm
operator|->
name|sa
operator|.
name|dirty
operator|=
name|TRUE
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Notifies the transport layer that the local LID has changed,  which give it a chance to update address vectors, etc.. **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|state_mgr_notify_lid_change
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|ib_api_status_t
name|status
decl_stmt|;
name|osm_bind_handle_t
name|h_bind
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	 * First, get the bind handle. 	 */
name|h_bind
operator|=
name|osm_sm_mad_ctrl_get_bind_handle
argument_list|(
operator|&
name|sm
operator|->
name|mad_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|h_bind
operator|==
name|OSM_BIND_INVALID_HANDLE
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3306: "
literal|"No bound ports\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	 * Notify the transport layer that we changed the local LID. 	 */
name|status
operator|=
name|osm_vendor_local_lid_change
argument_list|(
name|h_bind
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3307: "
literal|"Vendor LID update failed (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Returns true if the SM port is down.  The SM's port object must exist in the port_guid table. **********************************************************************/
end_comment

begin_function
specifier|static
name|boolean_t
name|state_mgr_is_sm_port_down
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|ib_net64_t
name|port_guid
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|uint8_t
name|state
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|port_guid
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|sm_port_guid
expr_stmt|;
comment|/* 	 * If we don't know our own port guid yet, assume the port is down. 	 */
if|if
condition|(
name|port_guid
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3308: "
literal|"SM port GUID unknown\n"
argument_list|)
expr_stmt|;
name|state
operator|=
name|IB_LINK_DOWN
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|CL_ASSERT
argument_list|(
name|port_guid
argument_list|)
expr_stmt|;
name|CL_PLOCK_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3309: "
literal|"SM port with GUID:%016"
name|PRIx64
literal|" is unknown\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|=
name|IB_LINK_DOWN
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_physp
operator|=
name|p_port
operator|->
name|p_physp
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_port
operator|->
name|p_node
operator|->
name|sw
operator|&&
operator|!
name|ib_switch_info_is_enhanced_port0
argument_list|(
operator|&
name|p_port
operator|->
name|p_node
operator|->
name|sw
operator|->
name|switch_info
argument_list|)
condition|)
name|state
operator|=
name|IB_LINK_ACTIVE
expr_stmt|;
comment|/* base SP0 */
else|else
name|state
operator|=
name|osm_physp_get_port_state
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
operator|->
name|discovery_count
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 330A: Failed to discover SM port\n"
argument_list|)
expr_stmt|;
name|state
operator|=
name|IB_LINK_DOWN
expr_stmt|;
block|}
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|state
operator|==
name|IB_LINK_DOWN
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Sweeps the node 1 hop away.  This sets off a "chain reaction" that causes discovery of the subnet.  Used when there is suspicion that something on the subnet has changed. **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|state_mgr_sweep_hop_1
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|osm_madw_context_t
name|context
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|osm_dr_path_t
name|hop_1_path
decl_stmt|;
name|ib_net64_t
name|port_guid
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|uint8_t
name|path_array
index|[
name|IB_SUBNET_PATH_HOPS_MAX
index|]
decl_stmt|;
name|uint8_t
name|num_ports
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_ext_physp
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	 * First, get our own port and node objects. 	 */
name|port_guid
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|sm_port_guid
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|port_guid
argument_list|)
expr_stmt|;
comment|/* Set the in_sweep_hop_0 flag in subn to be FALSE. 	 * This will indicate the sweeping to continue beyond the 	 * the current node. 	 * This is relevant for the case of SM on switch, since in the 	 * switch info we need to signal that the sweeping should 	 * continue through the switch. */
name|sm
operator|->
name|p_subn
operator|->
name|in_sweep_hop_0
operator|=
name|FALSE
expr_stmt|;
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3310: "
literal|"No SM port object\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_node
operator|=
name|p_port
operator|->
name|p_node
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|port_num
operator|=
name|ib_node_info_get_local_port_num
argument_list|(
operator|&
name|p_node
operator|->
name|node_info
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Probing hop 1 on local port %u\n"
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|path_array
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|path_array
argument_list|)
argument_list|)
expr_stmt|;
comment|/* the hop_1 operations depend on the type of our node. 	 * Currently - legal nodes that can host SM are SW and CA */
switch|switch
condition|(
name|osm_node_get_type
argument_list|(
name|p_node
argument_list|)
condition|)
block|{
case|case
name|IB_NODE_TYPE_CA
case|:
case|case
name|IB_NODE_TYPE_ROUTER
case|:
name|memset
argument_list|(
operator|&
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|ni_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|context
operator|.
name|ni_context
operator|.
name|port_num
operator|=
name|port_num
expr_stmt|;
name|path_array
index|[
literal|1
index|]
operator|=
name|port_num
expr_stmt|;
name|osm_dr_path_init
argument_list|(
operator|&
name|hop_1_path
argument_list|,
literal|1
argument_list|,
name|path_array
argument_list|)
expr_stmt|;
name|CL_PLOCK_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
operator|&
name|hop_1_path
argument_list|,
name|IB_MAD_ATTR_NODE_INFO
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3311: "
literal|"Request for NodeInfo failed (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_NODE_TYPE_SWITCH
case|:
comment|/* Need to go over all the ports of the switch, and send a 		 * node_info from them. This doesn't include the port 0 of the 		 * switch, which hosts the SM. 		 * Note: We'll send another switchInfo on port 0, since if no 		 * ports are connected, we still want to get some response, and 		 * have the subnet come up. 		 */
name|num_ports
operator|=
name|osm_node_get_num_physp
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
for|for
control|(
name|port_num
operator|=
literal|1
init|;
name|port_num
operator|<
name|num_ports
condition|;
name|port_num
operator|++
control|)
block|{
comment|/* go through the port only if the port is not DOWN */
name|p_ext_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ext_physp
operator|&&
name|ib_port_info_get_port_state
argument_list|(
operator|&
operator|(
name|p_ext_physp
operator|->
name|port_info
operator|)
argument_list|)
operator|>
name|IB_LINK_DOWN
condition|)
block|{
name|memset
argument_list|(
operator|&
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|ni_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|context
operator|.
name|ni_context
operator|.
name|port_num
operator|=
name|port_num
expr_stmt|;
name|path_array
index|[
literal|1
index|]
operator|=
name|port_num
expr_stmt|;
name|osm_dr_path_init
argument_list|(
operator|&
name|hop_1_path
argument_list|,
literal|1
argument_list|,
name|path_array
argument_list|)
expr_stmt|;
name|CL_PLOCK_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
operator|&
name|hop_1_path
argument_list|,
name|IB_MAD_ATTR_NODE_INFO
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3312: "
literal|"Request for NodeInfo failed (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3313: Unknown node type %d (%s)\n"
argument_list|,
name|osm_node_get_type
argument_list|(
name|p_node
argument_list|)
argument_list|,
name|p_node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|query_sm_info
parameter_list|(
name|cl_map_item_t
modifier|*
name|item
parameter_list|,
name|void
modifier|*
name|cxt
parameter_list|)
block|{
name|osm_madw_context_t
name|context
decl_stmt|;
name|osm_remote_sm_t
modifier|*
name|r_sm
init|=
name|cl_item_obj
argument_list|(
name|item
argument_list|,
name|r_sm
argument_list|,
name|map_item
argument_list|)
decl_stmt|;
name|osm_sm_t
modifier|*
name|sm
init|=
name|cxt
decl_stmt|;
name|ib_api_status_t
name|ret
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|r_sm
operator|->
name|smi
operator|.
name|guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_port
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3340: "
literal|"No port object on given sm object\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|context
operator|.
name|smi_context
operator|.
name|port_guid
operator|=
name|r_sm
operator|->
name|smi
operator|.
name|guid
expr_stmt|;
name|context
operator|.
name|smi_context
operator|.
name|set_method
operator|=
name|FALSE
expr_stmt|;
name|context
operator|.
name|smi_context
operator|.
name|light_sweep
operator|=
name|TRUE
expr_stmt|;
name|ret
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_port
operator|->
name|p_physp
argument_list|)
argument_list|,
name|IB_MAD_ATTR_SM_INFO
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|ib_port_info_get_m_key
argument_list|(
operator|&
name|p_port
operator|->
name|p_physp
operator|->
name|port_info
argument_list|)
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3314: "
literal|"Failure requesting SMInfo (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|state_mgr_reset_state_change_bit
parameter_list|(
name|IN
name|cl_map_item_t
modifier|*
name|obj
parameter_list|,
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
name|osm_madw_context_t
name|mad_context
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_sw
init|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|obj
decl_stmt|;
name|osm_sm_t
modifier|*
name|sm
init|=
name|context
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|osm_dr_path_t
modifier|*
name|p_path
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|ib_switch_info_t
name|si
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
name|p_node
operator|=
name|p_sw
operator|->
name|p_node
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p_path
operator|=
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ib_switch_info_get_state_change
argument_list|(
operator|&
name|p_sw
operator|->
name|switch_info
argument_list|)
condition|)
goto|goto
name|exit
goto|;
name|si
operator|=
name|p_sw
operator|->
name|switch_info
expr_stmt|;
name|ib_switch_info_state_change_set
argument_list|(
operator|&
name|si
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Resetting PortStateChange on switch GUID 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mad_context
operator|.
name|si_context
operator|.
name|light_sweep
operator|=
name|FALSE
expr_stmt|;
name|mad_context
operator|.
name|si_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|mad_context
operator|.
name|si_context
operator|.
name|set_method
operator|=
name|TRUE
expr_stmt|;
name|mad_context
operator|.
name|si_context
operator|.
name|lft_top_change
operator|=
name|FALSE
expr_stmt|;
name|status
operator|=
name|osm_req_set
argument_list|(
name|sm
argument_list|,
name|p_path
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|si
argument_list|,
sizeof|sizeof
argument_list|(
name|si
argument_list|)
argument_list|,
name|IB_MAD_ATTR_SWITCH_INFO
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|ib_port_info_get_m_key
argument_list|(
operator|&
name|p_physp
operator|->
name|port_info
argument_list|)
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|mad_context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 332A: "
literal|"Sending SwitchInfo attribute failed (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|state_mgr_update_node_desc
parameter_list|(
name|IN
name|cl_map_item_t
modifier|*
name|obj
parameter_list|,
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
name|osm_madw_context_t
name|mad_context
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
init|=
operator|(
name|osm_node_t
operator|*
operator|)
name|obj
decl_stmt|;
name|osm_sm_t
modifier|*
name|sm
init|=
name|context
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
init|=
name|NULL
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|num_ports
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Updating NodeDesc for 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get a physp to request from. */
name|num_ports
operator|=
name|osm_node_get_num_physp
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ports
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|i
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|p_physp
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 331C: "
literal|"Failed to find any valid physical port object.\n"
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
name|mad_context
operator|.
name|nd_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
argument_list|,
name|IB_MAD_ATTR_NODE_DESC
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|ib_port_info_get_m_key
argument_list|(
operator|&
name|p_physp
operator|->
name|port_info
argument_list|)
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|mad_context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 331B: Failure initiating NodeDescription request "
literal|"(%s) to 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_reset_switch_state_change_bit
parameter_list|(
name|IN
name|osm_opensm_t
modifier|*
name|osm
parameter_list|)
block|{
name|CL_PLOCK_ACQUIRE
argument_list|(
operator|&
name|osm
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cl_qmap_apply_func
argument_list|(
operator|&
name|osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|,
name|state_mgr_reset_state_change_bit
argument_list|,
operator|&
name|osm
operator|->
name|sm
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
operator|&
name|osm
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_update_node_desc
parameter_list|(
name|IN
name|osm_opensm_t
modifier|*
name|osm
parameter_list|)
block|{
name|CL_PLOCK_ACQUIRE
argument_list|(
operator|&
name|osm
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cl_qmap_apply_func
argument_list|(
operator|&
name|osm
operator|->
name|subn
operator|.
name|node_guid_tbl
argument_list|,
name|state_mgr_update_node_desc
argument_list|,
operator|&
name|osm
operator|->
name|sm
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
operator|&
name|osm
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  During a light sweep, check each node to see if the node description  is valid and if not issue a ND query. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|state_mgr_get_node_desc
parameter_list|(
name|IN
name|cl_map_item_t
modifier|*
name|obj
parameter_list|,
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
name|osm_node_t
modifier|*
name|p_node
init|=
operator|(
name|osm_node_t
operator|*
operator|)
name|obj
decl_stmt|;
name|osm_sm_t
modifier|*
name|sm
init|=
name|context
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_node
operator|->
name|print_desc
operator|&&
name|strcmp
argument_list|(
name|p_node
operator|->
name|print_desc
argument_list|,
name|OSM_NODE_DESC_UNKNOWN
argument_list|)
condition|)
comment|/* if ND is valid, do nothing */
goto|goto
name|exit
goto|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3319: Unknown node description for node GUID "
literal|"0x%016"
name|PRIx64
literal|".  Reissuing ND query\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|state_mgr_update_node_desc
argument_list|(
name|obj
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Initiates a lightweight sweep of the subnet.  Used during normal sweeps after the subnet is up. **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|state_mgr_light_sweep_start
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|osm_bind_handle_t
name|h_bind
decl_stmt|;
name|cl_qmap_t
modifier|*
name|p_sw_tbl
decl_stmt|;
name|cl_map_item_t
modifier|*
name|p_next
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_sw_tbl
operator|=
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
expr_stmt|;
comment|/* 	 * First, get the bind handle. 	 */
name|h_bind
operator|=
name|osm_sm_mad_ctrl_get_bind_handle
argument_list|(
operator|&
name|sm
operator|->
name|mad_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|h_bind
operator|==
name|OSM_BIND_INVALID_HANDLE
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"No bound ports. Deferring sweep...\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_INVALID_STATE
expr_stmt|;
goto|goto
name|_exit
goto|;
block|}
name|OSM_LOG_MSG_BOX
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"INITIATING LIGHT SWEEP"
argument_list|)
expr_stmt|;
name|CL_PLOCK_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|cl_qmap_apply_func
argument_list|(
name|p_sw_tbl
argument_list|,
name|state_mgr_get_sw_info
argument_list|,
name|sm
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|CL_PLOCK_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|cl_qmap_apply_func
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|node_guid_tbl
argument_list|,
name|state_mgr_get_node_desc
argument_list|,
name|sm
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
comment|/* now scan the list of physical ports that were not down but have no remote port */
name|CL_PLOCK_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|p_next
operator|=
name|cl_qmap_head
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|node_guid_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next
operator|!=
name|cl_qmap_end
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|node_guid_tbl
argument_list|)
condition|)
block|{
name|p_node
operator|=
operator|(
name|osm_node_t
operator|*
operator|)
name|p_next
expr_stmt|;
name|p_next
operator|=
name|cl_qmap_next
argument_list|(
name|p_next
argument_list|)
expr_stmt|;
for|for
control|(
name|port_num
operator|=
literal|1
init|;
name|port_num
operator|<
name|osm_node_get_num_physp
argument_list|(
name|p_node
argument_list|)
condition|;
name|port_num
operator|++
control|)
block|{
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_physp
operator|&&
operator|(
name|osm_physp_get_port_state
argument_list|(
name|p_physp
argument_list|)
operator|!=
name|IB_LINK_DOWN
operator|)
operator|&&
operator|!
name|osm_physp_get_remote
argument_list|(
name|p_physp
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3315: "
literal|"Unknown remote side for node 0x%016"
name|PRIx64
literal|" (%s) port %u. Adding to light sweep sampling list\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|p_node
operator|->
name|print_desc
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|osm_dump_dr_path_v2
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
argument_list|,
name|FILE_ID
argument_list|,
name|OSM_LOG_ERROR
argument_list|)
expr_stmt|;
name|state_mgr_get_remote_port_info
argument_list|(
name|sm
argument_list|,
name|p_physp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|cl_qmap_apply_func
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sm_guid_tbl
argument_list|,
name|query_sm_info
argument_list|,
name|sm
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|_exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Go over all the remote SMs (as updated in the sm_guid_tbl).  * Find if there is a remote sm that is a master SM.  * If there is a remote master SM - return a pointer to it,  * else - return NULL.  **********************************************************************/
end_comment

begin_function
specifier|static
name|osm_remote_sm_t
modifier|*
name|state_mgr_exists_other_master_sm
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|cl_qmap_t
modifier|*
name|p_sm_tbl
decl_stmt|;
name|osm_remote_sm_t
modifier|*
name|p_sm
decl_stmt|;
name|osm_remote_sm_t
modifier|*
name|p_sm_res
init|=
name|NULL
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_sm_tbl
operator|=
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sm_guid_tbl
expr_stmt|;
comment|/* go over all the remote SMs */
for|for
control|(
name|p_sm
operator|=
operator|(
name|osm_remote_sm_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_sm_tbl
argument_list|)
init|;
name|p_sm
operator|!=
operator|(
name|osm_remote_sm_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_sm_tbl
argument_list|)
condition|;
name|p_sm
operator|=
operator|(
name|osm_remote_sm_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sm
operator|->
name|map_item
argument_list|)
control|)
block|{
comment|/* If the sm is in MASTER state - return a pointer to it */
name|p_node
operator|=
name|osm_get_node_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|p_sm
operator|->
name|smi
operator|.
name|guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_sminfo_get_state
argument_list|(
operator|&
name|p_sm
operator|->
name|smi
argument_list|)
operator|==
name|IB_SMINFO_STATE_MASTER
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Found remote master SM with guid:0x%016"
name|PRIx64
literal|" (node %s)\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_sm
operator|->
name|smi
operator|.
name|guid
argument_list|)
argument_list|,
name|p_node
condition|?
name|p_node
operator|->
name|print_desc
else|:
literal|"UNKNOWN"
argument_list|)
expr_stmt|;
name|p_sm_res
operator|=
name|p_sm
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|p_sm_res
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Go over all remote SMs (as updated in the sm_guid_tbl).  * Find the one with the highest priority and lowest guid.  * Compare this SM to the local SM. If the local SM is higher -  * return NULL, if the remote SM is higher - return a pointer to it.  **********************************************************************/
end_comment

begin_function
specifier|static
name|osm_remote_sm_t
modifier|*
name|state_mgr_get_highest_sm
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|cl_qmap_t
modifier|*
name|p_sm_tbl
decl_stmt|;
name|osm_remote_sm_t
modifier|*
name|p_sm
init|=
name|NULL
decl_stmt|;
name|osm_remote_sm_t
modifier|*
name|p_highest_sm
decl_stmt|;
name|uint8_t
name|highest_sm_priority
decl_stmt|;
name|ib_net64_t
name|highest_sm_guid
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_sm_tbl
operator|=
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sm_guid_tbl
expr_stmt|;
comment|/* Start with the local sm as the standard */
name|p_highest_sm
operator|=
name|NULL
expr_stmt|;
name|highest_sm_priority
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|sm_priority
expr_stmt|;
name|highest_sm_guid
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|sm_port_guid
expr_stmt|;
comment|/* go over all the remote SMs */
for|for
control|(
name|p_sm
operator|=
operator|(
name|osm_remote_sm_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_sm_tbl
argument_list|)
init|;
name|p_sm
operator|!=
operator|(
name|osm_remote_sm_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_sm_tbl
argument_list|)
condition|;
name|p_sm
operator|=
operator|(
name|osm_remote_sm_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sm
operator|->
name|map_item
argument_list|)
control|)
block|{
comment|/* If the sm is in NOTACTIVE state - continue */
if|if
condition|(
name|ib_sminfo_get_state
argument_list|(
operator|&
name|p_sm
operator|->
name|smi
argument_list|)
operator|==
name|IB_SMINFO_STATE_NOTACTIVE
condition|)
continue|continue;
if|if
condition|(
name|osm_sm_is_greater_than
argument_list|(
name|ib_sminfo_get_priority
argument_list|(
operator|&
name|p_sm
operator|->
name|smi
argument_list|)
argument_list|,
name|p_sm
operator|->
name|smi
operator|.
name|guid
argument_list|,
name|highest_sm_priority
argument_list|,
name|highest_sm_guid
argument_list|)
condition|)
block|{
comment|/* the new p_sm is with higher priority - update the highest_sm */
comment|/* to this sm */
name|p_highest_sm
operator|=
name|p_sm
expr_stmt|;
name|highest_sm_priority
operator|=
name|ib_sminfo_get_priority
argument_list|(
operator|&
name|p_sm
operator|->
name|smi
argument_list|)
expr_stmt|;
name|highest_sm_guid
operator|=
name|p_sm
operator|->
name|smi
operator|.
name|guid
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_highest_sm
operator|!=
name|NULL
condition|)
block|{
name|p_node
operator|=
name|osm_get_node_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|p_highest_sm
operator|->
name|smi
operator|.
name|guid
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Found higher priority SM with guid: %016"
name|PRIx64
literal|" (node %s)\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_highest_sm
operator|->
name|smi
operator|.
name|guid
argument_list|)
argument_list|,
name|p_node
condition|?
name|p_node
operator|->
name|print_desc
else|:
literal|"UNKNOWN"
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|p_highest_sm
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Send SubnSet(SMInfo) SMP with HANDOVER attribute to the  * remote_sm indicated.  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|state_mgr_send_handover
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_remote_sm_t
modifier|*
name|p_sm
parameter_list|)
block|{
name|uint8_t
name|payload
index|[
name|IB_SMP_DATA_SIZE
index|]
decl_stmt|;
name|ib_sm_info_t
modifier|*
name|p_smi
init|=
operator|(
name|ib_sm_info_t
operator|*
operator|)
name|payload
decl_stmt|;
name|osm_madw_context_t
name|context
decl_stmt|;
specifier|const
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	 * Send a query of SubnSet(SMInfo) HANDOVER to the remote sm given. 	 */
name|memset
argument_list|(
operator|&
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|p_sm
operator|->
name|smi
operator|.
name|guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_port
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3316: "
literal|"No port object on given remote_sm object\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* update the master_guid in the sm_state_mgr object according to */
comment|/* the guid of the port where the new Master SM should reside. */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Handing over mastership. Updating sm_state_mgr master_guid: %016"
name|PRIx64
literal|" (node %s)\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_port
operator|->
name|guid
argument_list|)
argument_list|,
name|p_port
operator|->
name|p_node
condition|?
name|p_port
operator|->
name|p_node
operator|->
name|print_desc
else|:
literal|"UNKNOWN"
argument_list|)
expr_stmt|;
name|sm
operator|->
name|master_sm_guid
operator|=
name|p_port
operator|->
name|guid
expr_stmt|;
name|context
operator|.
name|smi_context
operator|.
name|port_guid
operator|=
name|p_port
operator|->
name|guid
expr_stmt|;
name|context
operator|.
name|smi_context
operator|.
name|set_method
operator|=
name|TRUE
expr_stmt|;
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|p_smi
operator|->
name|guid
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|sm_port_guid
expr_stmt|;
name|p_smi
operator|->
name|act_count
operator|=
name|cl_hton32
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
operator|->
name|stats
operator|.
name|qp0_mads_sent
argument_list|)
expr_stmt|;
name|p_smi
operator|->
name|pri_state
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
operator||
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|sm_priority
operator|<<
literal|4
argument_list|)
expr_stmt|;
name|p_smi
operator|->
name|sm_key
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|sm_key
expr_stmt|;
name|CL_PLOCK_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_req_set
argument_list|(
name|sm
argument_list|,
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_port
operator|->
name|p_physp
argument_list|)
argument_list|,
name|payload
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|,
name|IB_MAD_ATTR_SM_INFO
argument_list|,
name|IB_SMINFO_ATTR_MOD_HANDOVER
argument_list|,
name|FALSE
argument_list|,
name|ib_port_info_get_m_key
argument_list|(
operator|&
name|p_port
operator|->
name|p_physp
operator|->
name|port_info
argument_list|)
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3317: "
literal|"Failure requesting SMInfo (%s), remote SM at 0x%"
name|PRIx64
literal|" (node %s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_port
operator|->
name|guid
argument_list|)
argument_list|,
name|p_port
operator|->
name|p_node
condition|?
name|p_port
operator|->
name|p_node
operator|->
name|print_desc
else|:
literal|"UNKNOWN"
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Send Trap 64 on all new ports.  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|state_mgr_report_new_ports
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|ib_gid_t
name|port_gid
decl_stmt|;
name|ib_mad_notice_attr_t
name|notice
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|ib_net64_t
name|port_guid
decl_stmt|;
name|cl_map_item_t
modifier|*
name|p_next
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|uint16_t
name|min_lid_ho
decl_stmt|;
name|uint16_t
name|max_lid_ho
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_PLOCK_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|p_next
operator|=
name|cl_qmap_head
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|port_guid_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next
operator|!=
name|cl_qmap_end
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|port_guid_tbl
argument_list|)
condition|)
block|{
name|p_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|p_next
expr_stmt|;
name|p_next
operator|=
name|cl_qmap_next
argument_list|(
name|p_next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
operator|->
name|is_new
condition|)
continue|continue;
name|port_guid
operator|=
name|osm_port_get_guid
argument_list|(
name|p_port
argument_list|)
expr_stmt|;
comment|/* issue a notice - trap 64 (SM_GID_IN_SERVICE_TRAP) */
comment|/* details of the notice */
name|notice
operator|.
name|generic_type
operator|=
literal|0x80
operator||
name|IB_NOTICE_TYPE_SUBN_MGMT
expr_stmt|;
comment|/* is generic subn mgt type */
name|ib_notice_set_prod_type_ho
argument_list|(
operator|&
name|notice
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* A Class Manager generator */
comment|/* endport becomes reachable */
name|notice
operator|.
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
operator|=
name|CL_HTON16
argument_list|(
name|SM_GID_IN_SERVICE_TRAP
argument_list|)
expr_stmt|;
comment|/* 64 */
comment|/* The sm_base_lid is saved in network order already. */
name|notice
operator|.
name|issuer_lid
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|sm_base_lid
expr_stmt|;
comment|/* following C14-72.1.1 and table 119 p739 */
comment|/* we need to provide the GID */
name|port_gid
operator|.
name|unicast
operator|.
name|prefix
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|subnet_prefix
expr_stmt|;
name|port_gid
operator|.
name|unicast
operator|.
name|interface_id
operator|=
name|port_guid
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
name|notice
operator|.
name|data_details
operator|.
name|ntc_64_67
operator|.
name|gid
operator|)
argument_list|,
operator|&
operator|(
name|port_gid
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_gid_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* According to page 653 - the issuer gid in this case of trap 		 * is the SM gid, since the SM is the initiator of this trap. */
name|notice
operator|.
name|issuer_gid
operator|.
name|unicast
operator|.
name|prefix
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|subnet_prefix
expr_stmt|;
name|notice
operator|.
name|issuer_gid
operator|.
name|unicast
operator|.
name|interface_id
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|sm_port_guid
expr_stmt|;
name|status
operator|=
name|osm_report_notice
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|sm
operator|->
name|p_subn
argument_list|,
operator|&
name|notice
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3318: "
literal|"Error sending trap reports on GUID:0x%016"
name|PRIx64
literal|" (%s)\n"
argument_list|,
name|port_gid
operator|.
name|unicast
operator|.
name|interface_id
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|osm_port_get_lid_range_ho
argument_list|(
name|p_port
argument_list|,
operator|&
name|min_lid_ho
argument_list|,
operator|&
name|max_lid_ho
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Discovered new port with GUID:0x%016"
name|PRIx64
literal|" LID range [%u,%u] of node: %s\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_gid
operator|.
name|unicast
operator|.
name|interface_id
argument_list|)
argument_list|,
name|min_lid_ho
argument_list|,
name|max_lid_ho
argument_list|,
name|p_port
operator|->
name|p_node
condition|?
name|p_port
operator|->
name|p_node
operator|->
name|print_desc
else|:
literal|"UNKNOWN"
argument_list|)
expr_stmt|;
name|p_port
operator|->
name|is_new
operator|=
literal|0
expr_stmt|;
block|}
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Make sure that the lid_port_tbl of the subnet has only the ports  * that are recognized, and in the correct lid place. There could be  * errors if we wanted to assign a certain port with lid X, but that  * request didn't reach the port. In this case port_lid_tbl will have  * the port under lid X, though the port isn't updated with this lid.  * We will run a new heavy sweep (since there were errors in the  * initialization), but here we'll clean the database from incorrect  * information.  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|state_mgr_check_tbl_consistency
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|cl_qmap_t
modifier|*
name|p_port_guid_tbl
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|osm_port_t
modifier|*
name|p_next_port
decl_stmt|;
name|cl_ptr_vector_t
modifier|*
name|p_port_lid_tbl
decl_stmt|;
name|size_t
name|max_lid
decl_stmt|,
name|ref_size
decl_stmt|,
name|curr_size
decl_stmt|,
name|lid
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port_ref
decl_stmt|,
modifier|*
name|p_port_stored
decl_stmt|;
name|cl_ptr_vector_t
name|ref_port_lid_tbl
decl_stmt|;
name|uint16_t
name|min_lid_ho
decl_stmt|;
name|uint16_t
name|max_lid_ho
decl_stmt|;
name|uint16_t
name|lid_ho
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|lid_mgr
operator|.
name|dirty
operator|==
name|FALSE
condition|)
goto|goto
name|Exit
goto|;
name|sm
operator|->
name|lid_mgr
operator|.
name|dirty
operator|=
name|FALSE
expr_stmt|;
name|cl_ptr_vector_construct
argument_list|(
operator|&
name|ref_port_lid_tbl
argument_list|)
expr_stmt|;
name|cl_ptr_vector_init
argument_list|(
operator|&
name|ref_port_lid_tbl
argument_list|,
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|port_lid_tbl
argument_list|)
argument_list|,
name|OSM_SUBNET_VECTOR_GROW_SIZE
argument_list|)
expr_stmt|;
name|p_port_guid_tbl
operator|=
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|port_guid_tbl
expr_stmt|;
comment|/* Let's go over all the ports according to port_guid_tbl, 	 * and add the port to a reference port_lid_tbl. */
name|p_next_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_port_guid_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_port
operator|!=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_port_guid_tbl
argument_list|)
condition|)
block|{
name|p_port
operator|=
name|p_next_port
expr_stmt|;
name|p_next_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_next_port
operator|->
name|map_item
argument_list|)
expr_stmt|;
name|osm_port_get_lid_range_ho
argument_list|(
name|p_port
argument_list|,
operator|&
name|min_lid_ho
argument_list|,
operator|&
name|max_lid_ho
argument_list|)
expr_stmt|;
for|for
control|(
name|lid_ho
operator|=
name|min_lid_ho
init|;
name|lid_ho
operator|<=
name|max_lid_ho
condition|;
name|lid_ho
operator|++
control|)
name|cl_ptr_vector_set
argument_list|(
operator|&
name|ref_port_lid_tbl
argument_list|,
name|lid_ho
argument_list|,
name|p_port
argument_list|)
expr_stmt|;
block|}
name|p_port_lid_tbl
operator|=
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|port_lid_tbl
expr_stmt|;
name|ref_size
operator|=
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|ref_port_lid_tbl
argument_list|)
expr_stmt|;
name|curr_size
operator|=
name|cl_ptr_vector_get_size
argument_list|(
name|p_port_lid_tbl
argument_list|)
expr_stmt|;
comment|/* They should be the same, but compare it anyway */
name|max_lid
operator|=
operator|(
name|ref_size
operator|>
name|curr_size
operator|)
condition|?
name|ref_size
else|:
name|curr_size
expr_stmt|;
for|for
control|(
name|lid
operator|=
literal|1
init|;
name|lid
operator|<
name|max_lid
condition|;
name|lid
operator|++
control|)
block|{
name|p_port_ref
operator|=
name|NULL
expr_stmt|;
name|p_port_stored
operator|=
name|NULL
expr_stmt|;
name|cl_ptr_vector_at
argument_list|(
name|p_port_lid_tbl
argument_list|,
name|lid
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_port_stored
argument_list|)
expr_stmt|;
name|cl_ptr_vector_at
argument_list|(
operator|&
name|ref_port_lid_tbl
argument_list|,
name|lid
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_port_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_port_stored
operator|==
name|p_port_ref
condition|)
comment|/* This is the "good" case - both entries are the 			 * same for this lid. Nothing to do. */
continue|continue;
if|if
condition|(
name|p_port_ref
operator|==
name|NULL
condition|)
block|{
comment|/* There is an object in the subnet database for this 			 * lid, but no such object exists in the reference 			 * port_list_tbl. This can occur if we wanted to assign 			 * a certain port with some lid (different than the one 			 * pre-assigned to it), and the port didn't get the 			 * PortInfo Set request. Due to this, the port is 			 * updated with its original lid in our database 			 * rather than the new lid we wanted to give it. */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3322: "
literal|"lid %zu is wrongly assigned to port 0x%016"
name|PRIx64
literal|" (\'%s\' port %u) in port_lid_tbl\n"
argument_list|,
name|lid
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_port_get_guid
argument_list|(
name|p_port_stored
argument_list|)
argument_list|)
argument_list|,
name|p_port_stored
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_port_stored
operator|->
name|p_physp
operator|->
name|port_num
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_port_stored
operator|==
name|NULL
condition|)
comment|/* There is an object in the new database, but no 			 * object in our subnet database. This is the matching 			 * case of the prior check - the port still has its 			 * original lid. */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3323: "
literal|"port 0x%016"
name|PRIx64
literal|" (\'%s\' port %u)"
literal|" exists in new port_lid_tbl under lid %zu,"
literal|" but missing in subnet port_lid_tbl db\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_port_get_guid
argument_list|(
name|p_port_ref
argument_list|)
argument_list|)
argument_list|,
name|p_port_ref
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_port_ref
operator|->
name|p_physp
operator|->
name|port_num
argument_list|,
name|lid
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* if we reached here then p_port_stored != p_port_ref. 			 * We were trying to set a lid to p_port_stored, but 			 * it didn't reach it, and p_port_ref also didn't get 			 * the lid update. */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3324: "
literal|"lid %zu has port 0x%016"
name|PRIx64
literal|" (\'%s\' port %u) in new port_lid_tbl db, "
literal|"and port 0x%016"
name|PRIx64
literal|" (\'%s\' port %u)"
literal|" in subnet port_lid_tbl db\n"
argument_list|,
name|lid
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_port_get_guid
argument_list|(
name|p_port_ref
argument_list|)
argument_list|)
argument_list|,
name|p_port_ref
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_port_ref
operator|->
name|p_physp
operator|->
name|port_num
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_port_get_guid
argument_list|(
name|p_port_stored
argument_list|)
argument_list|)
argument_list|,
name|p_port_stored
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_port_stored
operator|->
name|p_physp
operator|->
name|port_num
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Clear the lid of the port in order to ignore it 		 *  in routing phase 		 */
if|if
condition|(
name|p_port_stored
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Clearing Lid for "
literal|"port 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_port_get_guid
argument_list|(
name|p_port_stored
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|osm_port_clear_base_lid
argument_list|(
name|p_port_stored
argument_list|)
expr_stmt|;
name|cl_ptr_vector_set
argument_list|(
name|p_port_lid_tbl
argument_list|,
name|lid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure we'll do another heavy sweep. */
name|sm
operator|->
name|p_subn
operator|->
name|subnet_initialization_error
operator|=
name|TRUE
expr_stmt|;
block|}
name|cl_ptr_vector_destroy
argument_list|(
operator|&
name|ref_port_lid_tbl
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_switch_lft
parameter_list|(
name|cl_map_item_t
modifier|*
name|item
parameter_list|,
name|void
modifier|*
name|log
parameter_list|)
block|{
name|osm_switch_t
modifier|*
name|sw
init|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|item
decl_stmt|;
if|if
condition|(
operator|!
name|sw
operator|->
name|new_lft
condition|)
return|return;
if|if
condition|(
name|memcmp
argument_list|(
name|sw
operator|->
name|lft
argument_list|,
name|sw
operator|->
name|new_lft
argument_list|,
name|sw
operator|->
name|max_lid_ho
operator|+
literal|1
argument_list|)
condition|)
name|osm_log_v2
argument_list|(
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
name|FILE_ID
argument_list|,
literal|"ERR 331D: "
literal|"LFT of switch 0x%016"
name|PRIx64
literal|" (%s) is not up to date\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|sw
operator|->
name|p_node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|)
argument_list|,
name|sw
operator|->
name|p_node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|wait_for_pending_transactions
parameter_list|(
name|osm_stats_t
modifier|*
name|stats
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_LIBPTHREAD
name|pthread_mutex_lock
argument_list|(
operator|&
name|stats
operator|->
name|mutex
argument_list|)
expr_stmt|;
while|while
condition|(
name|stats
operator|->
name|qp0_mads_outstanding
operator|&&
operator|!
name|osm_exit_flag
condition|)
name|pthread_cond_wait
argument_list|(
operator|&
name|stats
operator|->
name|cond
argument_list|,
operator|&
name|stats
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|stats
operator|->
name|mutex
argument_list|)
expr_stmt|;
else|#
directive|else
while|while
condition|(
literal|1
condition|)
block|{
name|unsigned
name|count
init|=
name|stats
operator|->
name|qp0_mads_outstanding
decl_stmt|;
if|if
condition|(
operator|!
name|count
operator|||
name|osm_exit_flag
condition|)
break|break;
name|cl_event_wait_on
argument_list|(
operator|&
name|stats
operator|->
name|event
argument_list|,
name|EVENT_NO_TIMEOUT
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|osm_exit_flag
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_sweep
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|ib_api_status_t
name|status
decl_stmt|;
name|osm_remote_sm_t
modifier|*
name|p_remote_sm
decl_stmt|;
name|unsigned
name|config_parsed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|force_first_time_master_sweep
condition|)
block|{
name|sm
operator|->
name|p_subn
operator|->
name|force_heavy_sweep
operator|=
name|TRUE
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|coming_out_of_standby
operator|=
name|TRUE
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|first_time_master_sweep
operator|=
name|TRUE
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|force_first_time_master_sweep
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* after subnet initialization error, run heavy sweep */
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|subnet_initialization_error
condition|)
name|sm
operator|->
name|p_subn
operator|->
name|force_heavy_sweep
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|force_heavy_sweep
condition|)
block|{
if|if
condition|(
name|osm_subn_rescan_conf_files
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|)
operator|<
literal|0
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 331A: "
literal|"osm_subn_rescan_conf_file failed\n"
argument_list|)
expr_stmt|;
else|else
name|config_parsed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
operator|!=
name|IB_SMINFO_STATE_MASTER
operator|&&
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
operator|!=
name|IB_SMINFO_STATE_DISCOVERING
condition|)
return|return;
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|coming_out_of_standby
condition|)
block|{
comment|/* 		 * Need to force re-write of sm_base_lid to all ports 		 * to do that we want all the ports to be considered 		 * foreign 		 */
name|state_mgr_clean_known_lids
argument_list|(
name|sm
argument_list|)
expr_stmt|;
comment|/* 		 * Need to clean SA cache when state changes to STANDBY 		 * after handover. 		 */
name|state_mgr_sa_clean
argument_list|(
name|sm
argument_list|)
expr_stmt|;
comment|/* 		 * Need to reconfigure LFTs, PKEYs, and QoS on all switches 		 * when coming out of STANDBY 		 */
name|sm
operator|->
name|p_subn
operator|->
name|need_update
operator|=
literal|1
expr_stmt|;
block|}
name|sm
operator|->
name|master_sm_found
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If we already have switches, then try a light sweep. 	 * Otherwise, this is probably our first discovery pass 	 * or we are connected in loopback. In both cases do a 	 * heavy sweep. 	 * Note: If we are connected in loopback we want a heavy 	 * sweep, since we will not be getting any traps if there is 	 * a lost connection. 	 */
comment|/*  if we are in DISCOVERING state - this means it is either in 	 *  initializing or wake up from STANDBY - run the heavy sweep */
if|if
condition|(
name|cl_qmap_count
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|)
operator|&&
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
operator|!=
name|IB_SMINFO_STATE_DISCOVERING
operator|&&
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|force_heavy_sweep
operator|==
name|FALSE
operator|&&
name|sm
operator|->
name|p_subn
operator|->
name|force_heavy_sweep
operator|==
name|FALSE
operator|&&
name|sm
operator|->
name|p_subn
operator|->
name|force_reroute
operator|==
name|FALSE
operator|&&
name|sm
operator|->
name|p_subn
operator|->
name|subnet_initialization_error
operator|==
name|FALSE
operator|&&
operator|(
name|state_mgr_light_sweep_start
argument_list|(
name|sm
argument_list|)
operator|==
name|IB_SUCCESS
operator|)
condition|)
block|{
if|if
condition|(
name|wait_for_pending_transactions
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
operator|->
name|stats
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|sm
operator|->
name|p_subn
operator|->
name|force_heavy_sweep
condition|)
block|{
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|sa_db_dump
operator|&&
operator|!
name|osm_sa_db_file_dump
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
argument_list|)
condition|)
name|osm_opensm_report_event
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
argument_list|,
name|OSM_EVENT_ID_SA_DB_DUMPED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|OSM_LOG_MSG_BOX
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"LIGHT SWEEP COMPLETE"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Unicast cache should be invalidated when subnet re-route is 	 * requested, and when OpenSM comes out of standby state. 	 */
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|use_ucast_cache
operator|&&
operator|(
name|sm
operator|->
name|p_subn
operator|->
name|force_reroute
operator|||
name|sm
operator|->
name|p_subn
operator|->
name|coming_out_of_standby
operator|)
condition|)
name|osm_ucast_cache_invalidate
argument_list|(
operator|&
name|sm
operator|->
name|ucast_mgr
argument_list|)
expr_stmt|;
comment|/* 	 * If we don't need to do a heavy sweep and we want to do a reroute, 	 * just reroute only. 	 */
if|if
condition|(
name|cl_qmap_count
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|)
operator|&&
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
operator|!=
name|IB_SMINFO_STATE_DISCOVERING
operator|&&
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|force_heavy_sweep
operator|==
name|FALSE
operator|&&
name|sm
operator|->
name|p_subn
operator|->
name|force_heavy_sweep
operator|==
name|FALSE
operator|&&
name|sm
operator|->
name|p_subn
operator|->
name|force_reroute
operator|==
name|TRUE
operator|&&
name|sm
operator|->
name|p_subn
operator|->
name|subnet_initialization_error
operator|==
name|FALSE
condition|)
block|{
comment|/* Reset flag */
name|sm
operator|->
name|p_subn
operator|->
name|force_reroute
operator|=
name|FALSE
expr_stmt|;
comment|/* Re-program the switches fully */
name|sm
operator|->
name|p_subn
operator|->
name|ignore_existing_lfts
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|osm_ucast_mgr_process
argument_list|(
operator|&
name|sm
operator|->
name|ucast_mgr
argument_list|)
condition|)
block|{
name|OSM_LOG_MSG_BOX
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"REROUTE FAILED"
argument_list|)
expr_stmt|;
return|return;
block|}
name|osm_qos_setup
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
argument_list|)
expr_stmt|;
comment|/* Reset flag */
name|sm
operator|->
name|p_subn
operator|->
name|ignore_existing_lfts
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|wait_for_pending_transactions
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
operator|->
name|stats
argument_list|)
condition|)
return|return;
name|osm_congestion_control_setup
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_congestion_control_wait_pending_transactions
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|sm
operator|->
name|p_subn
operator|->
name|subnet_initialization_error
condition|)
block|{
name|OSM_LOG_MSG_BOX
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"REROUTE COMPLETE"
argument_list|)
expr_stmt|;
name|osm_opensm_report_event
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
argument_list|,
name|OSM_EVENT_ID_UCAST_ROUTING_DONE
argument_list|,
operator|(
name|void
operator|*
operator|)
name|UCAST_ROUTING_REROUTE
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|osm_opensm_report_event
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
argument_list|,
name|OSM_EVENT_ID_HEAVY_SWEEP_START
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* go to heavy sweep */
name|repeat_discovery
label|:
comment|/* First of all - unset all flags */
name|sm
operator|->
name|p_subn
operator|->
name|force_heavy_sweep
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|force_reroute
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|subnet_initialization_error
operator|=
name|FALSE
expr_stmt|;
comment|/* Reset tracking values in case limiting component got removed 	 * from fabric. */
name|sm
operator|->
name|p_subn
operator|->
name|min_ca_mtu
operator|=
name|IB_MAX_MTU
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|min_ca_rate
operator|=
name|IB_PATH_RECORD_RATE_300_GBS
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|min_data_vls
operator|=
name|IB_MAX_NUM_VLS
operator|-
literal|1
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|min_sw_data_vls
operator|=
name|IB_MAX_NUM_VLS
operator|-
literal|1
expr_stmt|;
comment|/* rescan configuration updates */
if|if
condition|(
operator|!
name|config_parsed
operator|&&
name|osm_subn_rescan_conf_files
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|)
operator|<
literal|0
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 331A: "
literal|"osm_subn_rescan_conf_file failed\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
operator|!=
name|IB_SMINFO_STATE_MASTER
condition|)
name|sm
operator|->
name|p_subn
operator|->
name|need_update
operator|=
literal|1
expr_stmt|;
name|status
operator|=
name|state_mgr_sweep_hop_0
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
operator|||
name|wait_for_pending_transactions
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
operator|->
name|stats
argument_list|)
condition|)
return|return;
if|if
condition|(
name|state_mgr_is_sm_port_down
argument_list|(
name|sm
argument_list|)
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|last_sm_port_state
condition|)
block|{
name|sm
operator|->
name|p_subn
operator|->
name|last_sm_port_state
operator|=
literal|0
expr_stmt|;
name|state_mgr_sa_clean
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|osm_log_v2
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
name|FILE_ID
argument_list|,
literal|"SM port is down\n"
argument_list|)
expr_stmt|;
name|OSM_LOG_MSG_BOX
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"SM PORT DOWN"
argument_list|)
expr_stmt|;
block|}
comment|/* Run the drop manager - we want to clear all records */
name|osm_drop_mgr_process
argument_list|(
name|sm
argument_list|)
expr_stmt|;
comment|/* Move to DISCOVERING state */
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
operator|!=
name|IB_SMINFO_STATE_DISCOVERING
condition|)
name|osm_sm_state_mgr_process
argument_list|(
name|sm
argument_list|,
name|OSM_SM_SIGNAL_DISCOVER
argument_list|)
expr_stmt|;
name|osm_opensm_report_event
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
argument_list|,
name|OSM_EVENT_ID_STATE_CHANGE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|sm
operator|->
name|p_subn
operator|->
name|last_sm_port_state
condition|)
block|{
name|sm
operator|->
name|p_subn
operator|->
name|last_sm_port_state
operator|=
literal|1
expr_stmt|;
name|osm_log_v2
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
name|FILE_ID
argument_list|,
literal|"SM port is up\n"
argument_list|)
expr_stmt|;
name|OSM_LOG_MSG_BOX
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"SM PORT UP"
argument_list|)
expr_stmt|;
block|}
block|}
name|status
operator|=
name|state_mgr_sweep_hop_1
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
operator|||
name|wait_for_pending_transactions
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
operator|->
name|stats
argument_list|)
condition|)
return|return;
comment|/* discovery completed - check other sm presence */
if|if
condition|(
name|sm
operator|->
name|master_sm_found
condition|)
block|{
comment|/* 		 * Call the sm_state_mgr with signal 		 * MASTER_OR_HIGHER_SM_DETECTED_DONE 		 */
name|osm_sm_state_mgr_process
argument_list|(
name|sm
argument_list|,
name|OSM_SM_SIGNAL_MASTER_OR_HIGHER_SM_DETECTED
argument_list|)
expr_stmt|;
name|OSM_LOG_MSG_BOX
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"ENTERING STANDBY STATE"
argument_list|)
expr_stmt|;
comment|/* notify master SM about us */
name|osm_send_trap144
argument_list|(
name|sm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|osm_opensm_report_event
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
argument_list|,
name|OSM_EVENT_ID_STATE_CHANGE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* if new sweep requested - don't bother with the rest */
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|force_heavy_sweep
condition|)
block|{
name|config_parsed
operator|=
literal|0
expr_stmt|;
goto|goto
name|repeat_discovery
goto|;
block|}
name|osm_opensm_report_event
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
argument_list|,
name|OSM_EVENT_ID_HEAVY_SWEEP_DONE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|OSM_LOG_MSG_BOX
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"HEAVY SWEEP COMPLETE"
argument_list|)
expr_stmt|;
name|osm_drop_mgr_process
argument_list|(
name|sm
argument_list|)
expr_stmt|;
comment|/* If we are MASTER - get the highest remote_sm, and 	 * see if it is higher than our local sm. 	 */
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
operator|==
name|IB_SMINFO_STATE_MASTER
condition|)
block|{
name|p_remote_sm
operator|=
name|state_mgr_get_highest_sm
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_remote_sm
operator|!=
name|NULL
condition|)
block|{
comment|/* report new ports (trap 64) before leaving MASTER */
name|state_mgr_report_new_ports
argument_list|(
name|sm
argument_list|)
expr_stmt|;
comment|/* need to handover the mastership 			 * to the remote sm, and move to standby */
name|state_mgr_send_handover
argument_list|(
name|sm
argument_list|,
name|p_remote_sm
argument_list|)
expr_stmt|;
name|osm_sm_state_mgr_process
argument_list|(
name|sm
argument_list|,
name|OSM_SM_SIGNAL_HANDOVER_SENT
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* We are the highest sm - check to see if there is 			 * a remote SM that is in master state. */
name|p_remote_sm
operator|=
name|state_mgr_exists_other_master_sm
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_remote_sm
operator|!=
name|NULL
condition|)
block|{
comment|/* There is a remote SM that is master. 				 * need to wait for that SM to relinquish control 				 * of its portion of the subnet. C14-60.2.1. 				 * Also - need to start polling on that SM. */
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|sm
operator|->
name|polling_sm_guid
operator|=
name|p_remote_sm
operator|->
name|smi
operator|.
name|guid
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|osm_sm_state_mgr_process
argument_list|(
name|sm
argument_list|,
name|OSM_SM_SIGNAL_WAIT_FOR_HANDOVER
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|sm
operator|->
name|polling_sm_guid
condition|)
block|{
comment|/* Stop polling SM if it's not found */
name|osm_sm_state_mgr_process
argument_list|(
name|sm
argument_list|,
name|OSM_SM_SIGNAL_POLLING_TIMEOUT
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* 	 * If we are not MASTER already - this means that we are 	 * in discovery state. call osm_sm_state_mgr with signal 	 * DISCOVERY_COMPLETED 	 */
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
operator|==
name|IB_SMINFO_STATE_DISCOVERING
condition|)
name|osm_sm_state_mgr_process
argument_list|(
name|sm
argument_list|,
name|OSM_SM_SIGNAL_DISCOVERY_COMPLETED
argument_list|)
expr_stmt|;
name|osm_reset_switch_state_change_bit
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for_pending_transactions
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
operator|->
name|stats
argument_list|)
condition|)
return|return;
name|osm_pkey_mgr_process
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
argument_list|)
expr_stmt|;
comment|/* try to restore SA DB (this should be before lid_mgr 	   because we may want to disable clients reregistration 	   when SA DB is restored) */
name|osm_sa_db_file_load
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for_pending_transactions
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
operator|->
name|stats
argument_list|)
condition|)
return|return;
name|OSM_LOG_MSG_BOX
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"PKEY setup completed - STARTING SM LID CONFIG"
argument_list|)
expr_stmt|;
name|osm_lid_mgr_process_sm
argument_list|(
operator|&
name|sm
operator|->
name|lid_mgr
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for_pending_transactions
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
operator|->
name|stats
argument_list|)
condition|)
return|return;
name|OSM_LOG_MSG_BOX
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"SM LID ASSIGNMENT COMPLETE - STARTING SUBNET LID CONFIG"
argument_list|)
expr_stmt|;
name|state_mgr_notify_lid_change
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|osm_lid_mgr_process_subnet
argument_list|(
operator|&
name|sm
operator|->
name|lid_mgr
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for_pending_transactions
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
operator|->
name|stats
argument_list|)
condition|)
return|return;
comment|/* At this point we need to check the consistency of 	 * the port_lid_tbl under the subnet. There might be 	 * errors in it if PortInfo Set requests didn't reach 	 * their destination. */
name|state_mgr_check_tbl_consistency
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|OSM_LOG_MSG_BOX
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"LID ASSIGNMENT COMPLETE - STARTING SWITCH TABLE CONFIG"
argument_list|)
expr_stmt|;
comment|/* 	 * Proceed with unicast forwarding table configuration; if it fails 	 * return early to wait for a trap or the next sweep interval. 	 */
if|if
condition|(
operator|!
name|sm
operator|->
name|ucast_mgr
operator|.
name|cache_valid
operator|||
name|osm_ucast_cache_process
argument_list|(
operator|&
name|sm
operator|->
name|ucast_mgr
argument_list|)
condition|)
block|{
if|if
condition|(
name|osm_ucast_mgr_process
argument_list|(
operator|&
name|sm
operator|->
name|ucast_mgr
argument_list|)
condition|)
block|{
name|osm_ucast_cache_invalidate
argument_list|(
operator|&
name|sm
operator|->
name|ucast_mgr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|osm_qos_setup
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for_pending_transactions
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
operator|->
name|stats
argument_list|)
condition|)
return|return;
comment|/* We are done setting all LFTs so clear the ignore existing. 	 * From now on, as long as we are still master, we want to 	 * take into account these lfts. */
name|sm
operator|->
name|p_subn
operator|->
name|ignore_existing_lfts
operator|=
name|FALSE
expr_stmt|;
name|OSM_LOG_MSG_BOX
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"SWITCHES CONFIGURED FOR UNICAST"
argument_list|)
expr_stmt|;
name|osm_opensm_report_event
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
argument_list|,
name|OSM_EVENT_ID_UCAST_ROUTING_DONE
argument_list|,
operator|(
name|void
operator|*
operator|)
name|UCAST_ROUTING_HEAVY_SWEEP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|disable_multicast
condition|)
block|{
name|osm_mcast_mgr_process
argument_list|(
name|sm
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for_pending_transactions
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
operator|->
name|stats
argument_list|)
condition|)
return|return;
name|OSM_LOG_MSG_BOX
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"SWITCHES CONFIGURED FOR MULTICAST"
argument_list|)
expr_stmt|;
block|}
name|osm_guid_mgr_process
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for_pending_transactions
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
operator|->
name|stats
argument_list|)
condition|)
return|return;
name|OSM_LOG_MSG_BOX
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"ALIAS GUIDS CONFIGURED"
argument_list|)
expr_stmt|;
comment|/* 	 * The LINK_PORTS state is required since we cannot count on 	 * the port state change MADs to succeed. This is an artifact 	 * of the spec defining state change from state X to state X 	 * as an error. The hardware then is not required to process 	 * other parameters provided by the Set(PortInfo) Packet. 	 */
name|osm_link_mgr_process
argument_list|(
name|sm
argument_list|,
name|IB_LINK_NO_CHANGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for_pending_transactions
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
operator|->
name|stats
argument_list|)
condition|)
return|return;
name|OSM_LOG_MSG_BOX
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"LINKS PORTS CONFIGURED - SET LINKS TO ARMED STATE"
argument_list|)
expr_stmt|;
name|osm_link_mgr_process
argument_list|(
name|sm
argument_list|,
name|IB_LINK_ARMED
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for_pending_transactions
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
operator|->
name|stats
argument_list|)
condition|)
return|return;
name|OSM_LOG_MSG_BOX
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"LINKS ARMED - SET LINKS TO ACTIVE STATE"
argument_list|)
expr_stmt|;
name|osm_link_mgr_process
argument_list|(
name|sm
argument_list|,
name|IB_LINK_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait_for_pending_transactions
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
operator|->
name|stats
argument_list|)
condition|)
return|return;
comment|/* 	 * The sweep completed! 	 */
comment|/* Now do GSI configuration */
name|osm_congestion_control_setup
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_congestion_control_wait_pending_transactions
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
argument_list|)
condition|)
return|return;
comment|/* 	 * Send trap 64 on newly discovered endports 	 */
name|state_mgr_report_new_ports
argument_list|(
name|sm
argument_list|)
expr_stmt|;
comment|/* check switch lft buffers assignments */
name|cl_qmap_apply_func
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|,
name|check_switch_lft
argument_list|,
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* in any case we zero this flag */
name|sm
operator|->
name|p_subn
operator|->
name|coming_out_of_standby
operator|=
name|FALSE
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|first_time_master_sweep
operator|=
name|FALSE
expr_stmt|;
comment|/* If there were errors - then the subnet is not really up */
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|subnet_initialization_error
operator|==
name|TRUE
condition|)
block|{
name|osm_log_v2
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
name|FILE_ID
argument_list|,
literal|"Errors during initialization\n"
argument_list|)
expr_stmt|;
name|OSM_LOG_MSG_BOX
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERRORS DURING INITIALIZATION"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sm
operator|->
name|p_subn
operator|->
name|need_update
operator|=
literal|0
expr_stmt|;
name|osm_dump_all
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
argument_list|)
expr_stmt|;
name|state_mgr_up_msg
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|)
operator|||
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|sa_db_dump
operator|)
operator|&&
operator|!
name|osm_sa_db_file_dump
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
argument_list|)
condition|)
name|osm_opensm_report_event
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
argument_list|,
name|OSM_EVENT_ID_SA_DB_DUMPED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Finally signal the subnet up event 	 */
name|cl_event_signal
argument_list|(
operator|&
name|sm
operator|->
name|subnet_up_event
argument_list|)
expr_stmt|;
comment|/* if we got a signal to force heavy sweep or errors 	 * in the middle of the sweep - try another sweep. */
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|force_heavy_sweep
condition|)
name|osm_sm_signal
argument_list|(
name|sm
argument_list|,
name|OSM_SIGNAL_SWEEP
argument_list|)
expr_stmt|;
comment|/* Write a new copy of our persistent guid2mkey database */
name|osm_db_store
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_g2m
argument_list|,
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|fsync_high_avail_files
argument_list|)
expr_stmt|;
name|osm_db_store
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_neighbor
argument_list|,
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|fsync_high_avail_files
argument_list|)
expr_stmt|;
name|osm_opensm_report_event
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
argument_list|,
name|OSM_EVENT_ID_SUBNET_UP
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_process_mgrp_queue
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
operator|!=
name|IB_SMINFO_STATE_MASTER
condition|)
return|return;
if|if
condition|(
operator|!
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|disable_multicast
condition|)
block|{
name|osm_mcast_mgr_process
argument_list|(
name|sm
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|wait_for_pending_transactions
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
operator|->
name|stats
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_process_guid_queue
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|osm_guid_mgr_process
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|wait_for_pending_transactions
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
operator|->
name|stats
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_state_mgr_process
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_signal_t
name|signal
parameter_list|)
block|{
name|CL_ASSERT
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Received signal %s in state %s\n"
argument_list|,
name|osm_get_sm_signal_str
argument_list|(
name|signal
argument_list|)
argument_list|,
name|osm_get_sm_mgr_state_str
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|signal
condition|)
block|{
case|case
name|OSM_SIGNAL_SWEEP
case|:
if|if
condition|(
operator|!
name|sm
operator|->
name|p_subn
operator|->
name|sweeping_enabled
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"sweeping disabled - "
literal|"ignoring signal %s in state %s\n"
argument_list|,
name|osm_get_sm_signal_str
argument_list|(
name|signal
argument_list|)
argument_list|,
name|osm_get_sm_mgr_state_str
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|do_sweep
argument_list|(
name|sm
argument_list|)
expr_stmt|;
break|break;
case|case
name|OSM_SIGNAL_IDLE_TIME_PROCESS_REQUEST
case|:
name|do_process_mgrp_queue
argument_list|(
name|sm
argument_list|)
expr_stmt|;
break|break;
case|case
name|OSM_SIGNAL_GUID_PROCESS_REQUEST
case|:
name|do_process_guid_queue
argument_list|(
name|sm
argument_list|)
expr_stmt|;
break|break;
default|default:
name|CL_ASSERT
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3320: "
literal|"Invalid SM signal %u\n"
argument_list|,
name|signal
argument_list|)
expr_stmt|;
break|break;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

