begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2011 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  * Copyright (c) 2008 Xsigo Systems Inc. All rights reserved.  * Copyright (c) 2009 HNR Consulting. All rights reserved.  * Copyright (c) 2010 Sun Microsystems, Inc. All rights reserved.  * Copyright (c) 2009-2011 ZIH, TU Dresden, Federal Republic of Germany. All rights reserved.  * Copyright (c) 2013 Oracle and/or its affiliates. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_pr_rcv_t.  * This object represents the PathRecord Receiver object.  * This object is part of the opensm family of objects.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qmap.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_passivelock.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qlist.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_SA_PATH_RECORD_C
end_define

begin_include
include|#
directive|include
file|<vendor/osm_vendor_api.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_base.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_port.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_node.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_switch.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_pkey.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_multicast.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_partition.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_qos_policy.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_sa.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_router.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_prefix_route.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_ucast_lash.h>
end_include

begin_define
define|#
directive|define
name|SA_PR_RESP_SIZE
value|SA_ITEM_RESP_SIZE(path_rec)
end_define

begin_define
define|#
directive|define
name|MAX_HOPS
value|64
end_define

begin_function
specifier|static
specifier|inline
name|boolean_t
name|sa_path_rec_is_tavor_port
parameter_list|(
name|IN
specifier|const
name|osm_port_t
modifier|*
name|p_port
parameter_list|)
block|{
name|osm_node_t
specifier|const
modifier|*
name|p_node
decl_stmt|;
name|ib_net32_t
name|vend_id
decl_stmt|;
name|p_node
operator|=
name|p_port
operator|->
name|p_node
expr_stmt|;
name|vend_id
operator|=
name|ib_node_info_get_vendor_id
argument_list|(
operator|&
name|p_node
operator|->
name|node_info
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|p_node
operator|->
name|node_info
operator|.
name|device_id
operator|==
name|CL_HTON16
argument_list|(
literal|23108
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|vend_id
operator|==
name|CL_HTON32
argument_list|(
name|OSM_VENDOR_ID_MELLANOX
argument_list|)
operator|)
operator|||
operator|(
name|vend_id
operator|==
name|CL_HTON32
argument_list|(
name|OSM_VENDOR_ID_TOPSPIN
argument_list|)
operator|)
operator|||
operator|(
name|vend_id
operator|==
name|CL_HTON32
argument_list|(
name|OSM_VENDOR_ID_SILVERSTORM
argument_list|)
operator|)
operator|||
operator|(
name|vend_id
operator|==
name|CL_HTON32
argument_list|(
name|OSM_VENDOR_ID_VOLTAIRE
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|sa_path_rec_apply_tavor_mtu_limit
parameter_list|(
name|IN
specifier|const
name|ib_path_rec_t
modifier|*
name|p_pr
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
name|p_src_port
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
name|p_dest_port
parameter_list|,
name|IN
specifier|const
name|ib_net64_t
name|comp_mask
parameter_list|)
block|{
name|uint8_t
name|required_mtu
decl_stmt|;
comment|/* only if at least one of the ports is a Tavor device */
if|if
condition|(
operator|!
name|sa_path_rec_is_tavor_port
argument_list|(
name|p_src_port
argument_list|)
operator|&&
operator|!
name|sa_path_rec_is_tavor_port
argument_list|(
name|p_dest_port
argument_list|)
condition|)
return|return
name|FALSE
return|;
comment|/* 	   we can apply the patch if either: 	   1. No MTU required 	   2. Required MTU< 	   3. Required MTU = 1K or 512 or 256 	   4. Required MTU> 256 or 512 	 */
name|required_mtu
operator|=
name|ib_path_rec_mtu
argument_list|(
name|p_pr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_MTUSELEC
operator|)
operator|&&
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_MTU
operator|)
condition|)
block|{
switch|switch
condition|(
name|ib_path_rec_mtu_sel
argument_list|(
name|p_pr
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* must be greater than */
case|case
literal|2
case|:
comment|/* exact match */
if|if
condition|(
name|IB_MTU_LEN_1024
operator|<
name|required_mtu
condition|)
return|return
name|FALSE
return|;
break|break;
case|case
literal|1
case|:
comment|/* must be less than */
comment|/* can't be disqualified by this one */
break|break;
case|case
literal|3
case|:
comment|/* largest available */
comment|/* the ULP intentionally requested */
comment|/* the largest MTU possible */
return|return
name|FALSE
return|;
default|default:
comment|/* if we're here, there's a bug in ib_path_rec_mtu_sel() */
name|CL_ASSERT
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|ib_api_status_t
name|pr_rcv_get_path_parms
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|ib_path_rec_t
modifier|*
name|p_pr
parameter_list|,
name|IN
specifier|const
name|osm_alias_guid_t
modifier|*
name|p_src_alias_guid
parameter_list|,
name|IN
specifier|const
name|uint16_t
name|src_lid_ho
parameter_list|,
name|IN
specifier|const
name|osm_alias_guid_t
modifier|*
name|p_dest_alias_guid
parameter_list|,
name|IN
specifier|const
name|uint16_t
name|dest_lid_ho
parameter_list|,
name|IN
specifier|const
name|ib_net64_t
name|comp_mask
parameter_list|,
name|OUT
name|osm_path_parms_t
modifier|*
name|p_parms
parameter_list|)
block|{
specifier|const
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
specifier|const
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|,
modifier|*
name|p_physp0
decl_stmt|;
specifier|const
name|osm_physp_t
modifier|*
name|p_src_physp
decl_stmt|;
specifier|const
name|osm_physp_t
modifier|*
name|p_dest_physp
decl_stmt|;
specifier|const
name|osm_prtn_t
modifier|*
name|p_prtn
init|=
name|NULL
decl_stmt|;
name|osm_opensm_t
modifier|*
name|p_osm
decl_stmt|;
name|struct
name|osm_routing_engine
modifier|*
name|p_re
decl_stmt|;
specifier|const
name|ib_port_info_t
modifier|*
name|p_pi
decl_stmt|,
modifier|*
name|p_pi0
decl_stmt|;
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|ib_net16_t
name|pkey
decl_stmt|;
name|uint8_t
name|mtu
decl_stmt|;
name|uint8_t
name|rate
decl_stmt|,
name|p0_extended_rate
decl_stmt|,
name|dest_rate
decl_stmt|;
name|uint8_t
name|pkt_life
decl_stmt|;
name|uint8_t
name|required_mtu
decl_stmt|;
name|uint8_t
name|required_rate
decl_stmt|;
name|uint8_t
name|required_pkt_life
decl_stmt|;
name|uint8_t
name|sl
decl_stmt|;
name|uint8_t
name|in_port_num
decl_stmt|;
name|ib_net16_t
name|dest_lid
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|ib_slvl_table_t
modifier|*
name|p_slvl_tbl
init|=
name|NULL
decl_stmt|;
name|osm_qos_level_t
modifier|*
name|p_qos_level
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|valid_sl_mask
init|=
literal|0xffff
decl_stmt|;
name|int
name|hops
init|=
literal|0
decl_stmt|;
name|int
name|extended
decl_stmt|,
name|p0_extended
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|dest_lid
operator|=
name|cl_hton16
argument_list|(
name|dest_lid_ho
argument_list|)
expr_stmt|;
name|p_dest_physp
operator|=
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
expr_stmt|;
name|p_physp
operator|=
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
expr_stmt|;
name|p_src_physp
operator|=
name|p_physp
expr_stmt|;
name|p_pi
operator|=
operator|&
name|p_physp
operator|->
name|port_info
expr_stmt|;
name|p_osm
operator|=
name|sa
operator|->
name|p_subn
operator|->
name|p_osm
expr_stmt|;
name|p_re
operator|=
name|p_osm
operator|->
name|routing_engine_used
expr_stmt|;
name|mtu
operator|=
name|ib_port_info_get_mtu_cap
argument_list|(
name|p_pi
argument_list|)
expr_stmt|;
name|extended
operator|=
name|p_pi
operator|->
name|capability_mask
operator|&
name|IB_PORT_CAP_HAS_EXT_SPEEDS
expr_stmt|;
name|rate
operator|=
name|ib_port_info_compute_rate
argument_list|(
name|p_pi
argument_list|,
name|extended
argument_list|)
expr_stmt|;
comment|/* 	   Mellanox Tavor device performance is better using 1K MTU. 	   If required MTU and MTU selector are such that 1K is OK 	   and at least one end of the path is Tavor we override the 	   port MTU with 1K. 	 */
if|if
condition|(
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|enable_quirks
operator|&&
name|sa_path_rec_apply_tavor_mtu_limit
argument_list|(
name|p_pr
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
argument_list|,
name|comp_mask
argument_list|)
condition|)
if|if
condition|(
name|mtu
operator|>
name|IB_MTU_LEN_1024
condition|)
block|{
name|mtu
operator|=
name|IB_MTU_LEN_1024
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Optimized Path MTU to 1K for Mellanox Tavor device\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	   Walk the subnet object from source to destination, 	   tracking the most restrictive rate and mtu values along the way...  	   If source port node is a switch, then p_physp should 	   point to the port that routes the destination lid 	 */
name|p_node
operator|=
name|osm_physp_get_node_ptr
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_node
operator|->
name|sw
condition|)
block|{
comment|/* 		 * Source node is a switch. 		 * Make sure that p_physp points to the out port of the 		 * switch that routes to the destination lid (dest_lid_ho) 		 */
name|p_physp
operator|=
name|osm_switch_get_route_by_lid
argument_list|(
name|p_node
operator|->
name|sw
argument_list|,
name|dest_lid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_physp
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F02: "
literal|"Cannot find routing from LID %u to LID %u on "
literal|"switch %s (GUID: 0x%016"
name|PRIx64
literal|")\n"
argument_list|,
name|src_lid_ho
argument_list|,
name|dest_lid_ho
argument_list|,
name|p_node
operator|->
name|print_desc
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
if|if
condition|(
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|qos
condition|)
block|{
comment|/* 		 * Whether this node is switch or CA, the IN port for 		 * the sl2vl table is 0, because this is a source node. 		 */
name|p_slvl_tbl
operator|=
name|osm_physp_get_slvl_tbl
argument_list|(
name|p_physp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* update valid SLs that still exist on this route */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IB_MAX_NUM_VLS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|valid_sl_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|&&
name|ib_slvl_table_get
argument_list|(
name|p_slvl_tbl
argument_list|,
name|i
argument_list|)
operator|==
name|IB_DROP_VL
condition|)
name|valid_sl_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|valid_sl_mask
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"All the SLs lead to VL15 on this path\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/* 	 * Same as above 	 */
name|p_node
operator|=
name|osm_physp_get_node_ptr
argument_list|(
name|p_dest_physp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_node
operator|->
name|sw
condition|)
block|{
comment|/* 		 * if destination is switch, we want p_dest_physp to point to port 0 		 */
name|p_dest_physp
operator|=
name|osm_switch_get_route_by_lid
argument_list|(
name|p_node
operator|->
name|sw
argument_list|,
name|dest_lid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_dest_physp
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F03: "
literal|"Can't find routing from LID %u to LID %u on "
literal|"switch %s (GUID: 0x%016"
name|PRIx64
literal|")\n"
argument_list|,
name|src_lid_ho
argument_list|,
name|dest_lid_ho
argument_list|,
name|p_node
operator|->
name|print_desc
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/* 	 * Now go through the path step by step 	 */
while|while
condition|(
name|p_physp
operator|!=
name|p_dest_physp
condition|)
block|{
name|int
name|tmp_pnum
init|=
name|p_physp
operator|->
name|port_num
decl_stmt|;
name|p_node
operator|=
name|osm_physp_get_node_ptr
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|p_physp
operator|=
name|osm_physp_get_remote
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_physp
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F05: "
literal|"Can't find remote phys port of %s (GUID: "
literal|"0x%016"
name|PRIx64
literal|") port %d "
literal|"while routing from LID %u to LID %u\n"
argument_list|,
name|p_node
operator|->
name|print_desc
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|tmp_pnum
argument_list|,
name|src_lid_ho
argument_list|,
name|dest_lid_ho
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|in_port_num
operator|=
name|osm_physp_get_port_num
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
comment|/* 		   This is point to point case (no switch in between) 		 */
if|if
condition|(
name|p_physp
operator|==
name|p_dest_physp
condition|)
break|break;
name|p_node
operator|=
name|osm_physp_get_node_ptr
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_node
operator|->
name|sw
condition|)
block|{
comment|/* 			   There is some sort of problem in the subnet object! 			   If this isn't a switch, we should have reached 			   the destination by now! 			 */
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F06: "
literal|"Internal error, bad path while routing "
literal|"%s (GUID: 0x%016"
name|PRIx64
literal|") port %d to "
literal|"%s (GUID: 0x%016"
name|PRIx64
literal|") port %d; "
literal|"ended at %s port %d\n"
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|)
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|)
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|,
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_physp
operator|->
name|port_num
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 		   Check parameters for the ingress port in this switch. 		 */
name|p_pi
operator|=
operator|&
name|p_physp
operator|->
name|port_info
expr_stmt|;
if|if
condition|(
name|mtu
operator|>
name|ib_port_info_get_mtu_cap
argument_list|(
name|p_pi
argument_list|)
condition|)
name|mtu
operator|=
name|ib_port_info_get_mtu_cap
argument_list|(
name|p_pi
argument_list|)
expr_stmt|;
name|p_physp0
operator|=
name|osm_node_get_physp_ptr
argument_list|(
operator|(
name|osm_node_t
operator|*
operator|)
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p_pi0
operator|=
operator|&
name|p_physp0
operator|->
name|port_info
expr_stmt|;
name|p0_extended
operator|=
name|p_pi0
operator|->
name|capability_mask
operator|&
name|IB_PORT_CAP_HAS_EXT_SPEEDS
expr_stmt|;
name|p0_extended_rate
operator|=
name|ib_port_info_compute_rate
argument_list|(
name|p_pi
argument_list|,
name|p0_extended
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_path_compare_rates
argument_list|(
name|rate
argument_list|,
name|p0_extended_rate
argument_list|)
operator|>
literal|0
condition|)
name|rate
operator|=
name|p0_extended_rate
expr_stmt|;
comment|/* 		   Continue with the egress port on this switch. 		 */
name|p_physp
operator|=
name|osm_switch_get_route_by_lid
argument_list|(
name|p_node
operator|->
name|sw
argument_list|,
name|dest_lid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_physp
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F07: "
literal|"Dead end path on switch "
literal|"%s (GUID: 0x%016"
name|PRIx64
literal|") to LID %u\n"
argument_list|,
name|p_node
operator|->
name|print_desc
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|dest_lid_ho
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_pi
operator|=
operator|&
name|p_physp
operator|->
name|port_info
expr_stmt|;
if|if
condition|(
name|mtu
operator|>
name|ib_port_info_get_mtu_cap
argument_list|(
name|p_pi
argument_list|)
condition|)
name|mtu
operator|=
name|ib_port_info_get_mtu_cap
argument_list|(
name|p_pi
argument_list|)
expr_stmt|;
name|p_physp0
operator|=
name|osm_node_get_physp_ptr
argument_list|(
operator|(
name|osm_node_t
operator|*
operator|)
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p_pi0
operator|=
operator|&
name|p_physp0
operator|->
name|port_info
expr_stmt|;
name|p0_extended
operator|=
name|p_pi0
operator|->
name|capability_mask
operator|&
name|IB_PORT_CAP_HAS_EXT_SPEEDS
expr_stmt|;
name|p0_extended_rate
operator|=
name|ib_port_info_compute_rate
argument_list|(
name|p_pi
argument_list|,
name|p0_extended
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_path_compare_rates
argument_list|(
name|rate
argument_list|,
name|p0_extended_rate
argument_list|)
operator|>
literal|0
condition|)
name|rate
operator|=
name|p0_extended_rate
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|qos
condition|)
block|{
comment|/* 			 * Check SL2VL table of the switch and update valid SLs 			 */
name|p_slvl_tbl
operator|=
name|osm_physp_get_slvl_tbl
argument_list|(
name|p_physp
argument_list|,
name|in_port_num
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IB_MAX_NUM_VLS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|valid_sl_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|&&
name|ib_slvl_table_get
argument_list|(
name|p_slvl_tbl
argument_list|,
name|i
argument_list|)
operator|==
name|IB_DROP_VL
condition|)
name|valid_sl_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|valid_sl_mask
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"All the SLs "
literal|"lead to VL15 on this path\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/* update number of hops traversed */
name|hops
operator|++
expr_stmt|;
if|if
condition|(
name|hops
operator|>
name|MAX_HOPS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F25: "
literal|"Path from GUID 0x%016"
name|PRIx64
literal|" (%s port %d) "
literal|"to lid %u GUID 0x%016"
name|PRIx64
literal|" (%s port %d) "
literal|"needs more than %d hops, max %d hops allowed\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_src_physp
argument_list|)
argument_list|)
argument_list|,
name|p_src_physp
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_src_physp
operator|->
name|port_num
argument_list|,
name|dest_lid_ho
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_dest_physp
argument_list|)
argument_list|)
argument_list|,
name|p_dest_physp
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_dest_physp
operator|->
name|port_num
argument_list|,
name|hops
argument_list|,
name|MAX_HOPS
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/* 	   p_physp now points to the destination 	 */
name|p_pi
operator|=
operator|&
name|p_physp
operator|->
name|port_info
expr_stmt|;
if|if
condition|(
name|mtu
operator|>
name|ib_port_info_get_mtu_cap
argument_list|(
name|p_pi
argument_list|)
condition|)
name|mtu
operator|=
name|ib_port_info_get_mtu_cap
argument_list|(
name|p_pi
argument_list|)
expr_stmt|;
name|extended
operator|=
name|p_pi
operator|->
name|capability_mask
operator|&
name|IB_PORT_CAP_HAS_EXT_SPEEDS
expr_stmt|;
name|dest_rate
operator|=
name|ib_port_info_compute_rate
argument_list|(
name|p_pi
argument_list|,
name|extended
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_path_compare_rates
argument_list|(
name|rate
argument_list|,
name|dest_rate
argument_list|)
operator|>
literal|0
condition|)
name|rate
operator|=
name|dest_rate
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Path min MTU = %u, min rate = %u\n"
argument_list|,
name|mtu
argument_list|,
name|rate
argument_list|)
expr_stmt|;
comment|/* 	 * Get QoS Level object according to the path request 	 * and adjust path parameters according to QoS settings 	 */
if|if
condition|(
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|qos
operator|&&
name|sa
operator|->
name|p_subn
operator|->
name|p_qos_policy
operator|&&
operator|(
name|p_qos_level
operator|=
name|osm_qos_policy_get_qos_level_by_pr
argument_list|(
name|sa
operator|->
name|p_subn
operator|->
name|p_qos_policy
argument_list|,
name|p_pr
argument_list|,
name|p_src_physp
argument_list|,
name|p_dest_physp
argument_list|,
name|comp_mask
argument_list|)
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"PathRecord request matches QoS Level '%s' (%s)\n"
argument_list|,
name|p_qos_level
operator|->
name|name
argument_list|,
name|p_qos_level
operator|->
name|use
condition|?
name|p_qos_level
operator|->
name|use
else|:
literal|"no description"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_qos_level
operator|->
name|mtu_limit_set
operator|&&
operator|(
name|mtu
operator|>
name|p_qos_level
operator|->
name|mtu_limit
operator|)
condition|)
name|mtu
operator|=
name|p_qos_level
operator|->
name|mtu_limit
expr_stmt|;
if|if
condition|(
name|p_qos_level
operator|->
name|rate_limit_set
operator|&&
operator|(
name|ib_path_compare_rates
argument_list|(
name|rate
argument_list|,
name|p_qos_level
operator|->
name|rate_limit
argument_list|)
operator|>
literal|0
operator|)
condition|)
name|rate
operator|=
name|p_qos_level
operator|->
name|rate_limit
expr_stmt|;
if|if
condition|(
name|p_qos_level
operator|->
name|sl_set
condition|)
block|{
name|sl
operator|=
name|p_qos_level
operator|->
name|sl
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|valid_sl_mask
operator|&
operator|(
literal|1
operator|<<
name|sl
operator|)
operator|)
condition|)
block|{
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
block|}
comment|/* 	 * Set packet lifetime. 	 * According to spec definition IBA 1.2 Table 205 	 * PacketLifeTime description, for loopback paths, 	 * packetLifeTime shall be zero. 	 */
if|if
condition|(
name|p_src_alias_guid
operator|->
name|p_base_port
operator|==
name|p_dest_alias_guid
operator|->
name|p_base_port
condition|)
name|pkt_life
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|p_qos_level
operator|&&
name|p_qos_level
operator|->
name|pkt_life_set
condition|)
name|pkt_life
operator|=
name|p_qos_level
operator|->
name|pkt_life
expr_stmt|;
else|else
name|pkt_life
operator|=
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|subnet_timeout
expr_stmt|;
comment|/* 	   Determine if these values meet the user criteria 	   and adjust appropriately 	 */
comment|/* we silently ignore cases where only the MTU selector is defined */
if|if
condition|(
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_MTUSELEC
operator|)
operator|&&
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_MTU
operator|)
condition|)
block|{
name|required_mtu
operator|=
name|ib_path_rec_mtu
argument_list|(
name|p_pr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ib_path_rec_mtu_sel
argument_list|(
name|p_pr
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* must be greater than */
if|if
condition|(
name|mtu
operator|<=
name|required_mtu
condition|)
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* must be less than */
if|if
condition|(
name|mtu
operator|>=
name|required_mtu
condition|)
block|{
comment|/* adjust to use the highest mtu 				   lower than the required one */
if|if
condition|(
name|required_mtu
operator|>
literal|1
condition|)
name|mtu
operator|=
name|required_mtu
operator|-
literal|1
expr_stmt|;
else|else
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* exact match */
if|if
condition|(
name|mtu
operator|<
name|required_mtu
condition|)
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
else|else
name|mtu
operator|=
name|required_mtu
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* largest available */
comment|/* can't be disqualified by this one */
break|break;
default|default:
comment|/* if we're here, there's a bug in ib_path_rec_mtu_sel() */
name|CL_ASSERT
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
comment|/* we silently ignore cases where only the Rate selector is defined */
if|if
condition|(
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_RATESELEC
operator|)
operator|&&
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_RATE
operator|)
condition|)
block|{
name|required_rate
operator|=
name|ib_path_rec_rate
argument_list|(
name|p_pr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ib_path_rec_rate_sel
argument_list|(
name|p_pr
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* must be greater than */
if|if
condition|(
name|ib_path_compare_rates
argument_list|(
name|rate
argument_list|,
name|required_rate
argument_list|)
operator|<=
literal|0
condition|)
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* must be less than */
if|if
condition|(
name|ib_path_compare_rates
argument_list|(
name|rate
argument_list|,
name|required_rate
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* adjust the rate to use the highest rate 				   lower than the required one */
name|rate
operator|=
name|ib_path_rate_get_prev
argument_list|(
name|required_rate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rate
condition|)
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* exact match */
if|if
condition|(
name|ib_path_compare_rates
argument_list|(
name|rate
argument_list|,
name|required_rate
argument_list|)
condition|)
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
else|else
name|rate
operator|=
name|required_rate
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* largest available */
comment|/* can't be disqualified by this one */
break|break;
default|default:
comment|/* if we're here, there's a bug in ib_path_rec_mtu_sel() */
name|CL_ASSERT
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
comment|/* we silently ignore cases where only the PktLife selector is defined */
if|if
condition|(
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_PKTLIFETIMESELEC
operator|)
operator|&&
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_PKTLIFETIME
operator|)
condition|)
block|{
name|required_pkt_life
operator|=
name|ib_path_rec_pkt_life
argument_list|(
name|p_pr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ib_path_rec_pkt_life_sel
argument_list|(
name|p_pr
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* must be greater than */
if|if
condition|(
name|pkt_life
operator|<=
name|required_pkt_life
condition|)
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* must be less than */
if|if
condition|(
name|pkt_life
operator|>=
name|required_pkt_life
condition|)
block|{
comment|/* adjust the lifetime to use the highest possible 				   lower than the required one */
if|if
condition|(
name|required_pkt_life
operator|>
literal|1
condition|)
name|pkt_life
operator|=
name|required_pkt_life
operator|-
literal|1
expr_stmt|;
else|else
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* exact match */
if|if
condition|(
name|pkt_life
operator|<
name|required_pkt_life
condition|)
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
else|else
name|pkt_life
operator|=
name|required_pkt_life
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* smallest available */
comment|/* can't be disqualified by this one */
break|break;
default|default:
comment|/* if we're here, there's a bug in ib_path_rec_pkt_life_sel() */
name|CL_ASSERT
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
comment|/* 	 * set Pkey for this path record request 	 */
if|if
condition|(
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_RAWTRAFFIC
operator|)
operator|&&
operator|(
name|cl_ntoh32
argument_list|(
name|p_pr
operator|->
name|hop_flow_raw
argument_list|)
operator|&
operator|(
literal|1
operator|<<
literal|31
operator|)
operator|)
condition|)
name|pkey
operator|=
name|osm_physp_find_common_pkey
argument_list|(
name|p_src_physp
argument_list|,
name|p_dest_physp
argument_list|,
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|allow_both_pkeys
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_PKEY
condition|)
block|{
comment|/* 		 * PR request has a specific pkey: 		 * Check that source and destination share this pkey. 		 * If QoS level has pkeys, check that this pkey exists 		 * in the QoS level pkeys. 		 * PR returned pkey is the requested pkey. 		 */
name|pkey
operator|=
name|p_pr
operator|->
name|pkey
expr_stmt|;
if|if
condition|(
operator|!
name|osm_physp_share_this_pkey
argument_list|(
name|p_src_physp
argument_list|,
name|p_dest_physp
argument_list|,
name|pkey
argument_list|,
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|allow_both_pkeys
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F1A: "
literal|"Ports 0x%016"
name|PRIx64
literal|" (%s port %d) and "
literal|"0x%016"
name|PRIx64
literal|" (%s port %d) "
literal|"do not share specified PKey 0x%04x\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_src_physp
argument_list|)
argument_list|)
argument_list|,
name|p_src_physp
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_src_physp
operator|->
name|port_num
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_dest_physp
argument_list|)
argument_list|)
argument_list|,
name|p_dest_physp
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_dest_physp
operator|->
name|port_num
argument_list|,
name|cl_ntoh16
argument_list|(
name|pkey
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|p_qos_level
operator|&&
name|p_qos_level
operator|->
name|pkey_range_len
operator|&&
operator|!
name|osm_qos_level_has_pkey
argument_list|(
name|p_qos_level
argument_list|,
name|pkey
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F1D: "
literal|"QoS level \"%s\" doesn't define specified PKey 0x%04x "
literal|"for ports 0x%016"
name|PRIx64
literal|" (%s port %d) and "
literal|"0x%016"
name|PRIx64
literal|" (%s port %d)\n"
argument_list|,
name|p_qos_level
operator|->
name|name
argument_list|,
name|cl_ntoh16
argument_list|(
name|pkey
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_src_physp
argument_list|)
argument_list|)
argument_list|,
name|p_src_physp
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_dest_physp
argument_list|)
argument_list|)
argument_list|,
name|p_dest_physp
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|p_qos_level
operator|&&
name|p_qos_level
operator|->
name|pkey_range_len
condition|)
block|{
comment|/* 		 * PR request doesn't have a specific pkey, but QoS level 		 * has pkeys - get shared pkey from QoS level pkeys 		 */
name|pkey
operator|=
name|osm_qos_level_get_shared_pkey
argument_list|(
name|p_qos_level
argument_list|,
name|p_src_physp
argument_list|,
name|p_dest_physp
argument_list|,
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|allow_both_pkeys
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pkey
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F1E: "
literal|"Ports 0x%016"
name|PRIx64
literal|" (%s) and "
literal|"0x%016"
name|PRIx64
literal|" (%s) do not share "
literal|"PKeys defined by QoS level \"%s\"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_src_physp
argument_list|)
argument_list|)
argument_list|,
name|p_src_physp
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_dest_physp
argument_list|)
argument_list|)
argument_list|,
name|p_dest_physp
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_qos_level
operator|->
name|name
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
else|else
block|{
comment|/* 		 * Neither PR request nor QoS level have pkey. 		 * Just get any shared pkey. 		 */
name|pkey
operator|=
name|osm_physp_find_common_pkey
argument_list|(
name|p_src_physp
argument_list|,
name|p_dest_physp
argument_list|,
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|allow_both_pkeys
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pkey
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F1B: "
literal|"Ports src 0x%016"
name|PRIx64
literal|" (%s port %d) and "
literal|"dst 0x%016"
name|PRIx64
literal|" (%s port %d) do not have "
literal|"any shared PKeys\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_src_physp
argument_list|)
argument_list|)
argument_list|,
name|p_src_physp
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_src_physp
operator|->
name|port_num
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_dest_physp
argument_list|)
argument_list|)
argument_list|,
name|p_dest_physp
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_dest_physp
operator|->
name|port_num
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
if|if
condition|(
name|pkey
condition|)
block|{
name|p_prtn
operator|=
operator|(
name|osm_prtn_t
operator|*
operator|)
name|cl_qmap_get
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|prtn_pkey_tbl
argument_list|,
name|pkey
operator|&
name|cl_hton16
argument_list|(
operator|(
name|uint16_t
operator|)
operator|~
literal|0x8000
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_prtn
operator|==
operator|(
name|osm_prtn_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|prtn_pkey_tbl
argument_list|)
condition|)
name|p_prtn
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Set PathRecord SL 	 */
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_SL
condition|)
block|{
comment|/* 		 * Specific SL was requested 		 */
name|sl
operator|=
name|ib_path_rec_sl
argument_list|(
name|p_pr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_qos_level
operator|&&
name|p_qos_level
operator|->
name|sl_set
operator|&&
operator|(
name|p_qos_level
operator|->
name|sl
operator|!=
name|sl
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F1F: "
literal|"QoS constraints: required PathRecord SL (%u) "
literal|"doesn't match QoS policy \"%s\" SL (%u) "
literal|"[%s port %d<-> %s port %d]\n"
argument_list|,
name|sl
argument_list|,
name|p_qos_level
operator|->
name|name
argument_list|,
name|p_qos_level
operator|->
name|sl
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|p_qos_level
operator|&&
name|p_qos_level
operator|->
name|sl_set
condition|)
block|{
comment|/* 		 * No specific SL was requested, but there is an SL in 		 * QoS level. 		 */
name|sl
operator|=
name|p_qos_level
operator|->
name|sl
expr_stmt|;
if|if
condition|(
name|pkey
operator|&&
name|p_prtn
operator|&&
name|p_prtn
operator|->
name|sl
operator|!=
name|p_qos_level
operator|->
name|sl
condition|)
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"QoS level SL (%u) overrides partition SL (%u)\n"
argument_list|,
name|p_qos_level
operator|->
name|sl
argument_list|,
name|p_prtn
operator|->
name|sl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pkey
condition|)
block|{
comment|/* 		 * No specific SL in request or in QoS level - use partition SL 		 */
if|if
condition|(
operator|!
name|p_prtn
condition|)
block|{
name|sl
operator|=
name|OSM_DEFAULT_SL
expr_stmt|;
comment|/* this may be possible when pkey tables are created somehow in 			   previous runs or things are going wrong here */
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F1C: "
literal|"No partition found for PKey 0x%04x - "
literal|"using default SL %d "
literal|"[%s port %d<-> %s port %d]\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|pkey
argument_list|)
argument_list|,
name|sl
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|)
expr_stmt|;
block|}
else|else
name|sl
operator|=
name|p_prtn
operator|->
name|sl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|qos
condition|)
block|{
if|if
condition|(
name|valid_sl_mask
operator|&
operator|(
literal|1
operator|<<
name|OSM_DEFAULT_SL
operator|)
condition|)
name|sl
operator|=
name|OSM_DEFAULT_SL
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IB_MAX_NUM_VLS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|valid_sl_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
break|break;
name|sl
operator|=
name|i
expr_stmt|;
block|}
block|}
else|else
name|sl
operator|=
name|OSM_DEFAULT_SL
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|qos
operator|&&
operator|!
operator|(
name|valid_sl_mask
operator|&
operator|(
literal|1
operator|<<
name|sl
operator|)
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F24: "
literal|"Selected SL (%u) leads to VL15 "
literal|"[%s port %d<-> %s port %d]\n"
argument_list|,
name|sl
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	 * If the routing engine wants to have a say in path SL selection, 	 * send the currently computed SL value as a hint and let the routing 	 * engine override it. 	 */
if|if
condition|(
name|p_re
operator|&&
name|p_re
operator|->
name|path_sl
condition|)
block|{
name|uint8_t
name|pr_sl
decl_stmt|;
name|pr_sl
operator|=
name|sl
expr_stmt|;
name|sl
operator|=
name|p_re
operator|->
name|path_sl
argument_list|(
name|p_re
operator|->
name|context
argument_list|,
name|sl
argument_list|,
name|cl_hton16
argument_list|(
name|src_lid_ho
argument_list|)
argument_list|,
name|cl_hton16
argument_list|(
name|dest_lid_ho
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_SL
operator|)
operator|&&
operator|(
name|sl
operator|!=
name|pr_sl
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F2A: "
literal|"Requested SL (%u) doesn't match SL calculated"
literal|"by routing engine (%u) "
literal|"[%s port %d<-> %s port %d]\n"
argument_list|,
name|pr_sl
argument_list|,
name|sl
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/* reset pkey when raw traffic */
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_RAWTRAFFIC
operator|&&
name|cl_ntoh32
argument_list|(
name|p_pr
operator|->
name|hop_flow_raw
argument_list|)
operator|&
operator|(
literal|1
operator|<<
literal|31
operator|)
condition|)
name|pkey
operator|=
literal|0
expr_stmt|;
name|p_parms
operator|->
name|mtu
operator|=
name|mtu
expr_stmt|;
name|p_parms
operator|->
name|rate
operator|=
name|rate
expr_stmt|;
name|p_parms
operator|->
name|pkt_life
operator|=
name|pkt_life
expr_stmt|;
name|p_parms
operator|->
name|pkey
operator|=
name|pkey
expr_stmt|;
name|p_parms
operator|->
name|sl
operator|=
name|sl
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Path params: mtu = %u, rate = %u,"
literal|" packet lifetime = %u, pkey = 0x%04X, sl = %u\n"
argument_list|,
name|mtu
argument_list|,
name|rate
argument_list|,
name|pkt_life
argument_list|,
name|cl_ntoh16
argument_list|(
name|pkey
argument_list|)
argument_list|,
name|sl
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|ib_api_status_t
name|osm_get_path_params
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
name|p_src_port
parameter_list|,
name|IN
specifier|const
name|uint16_t
name|slid_ho
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
name|p_dest_port
parameter_list|,
name|IN
specifier|const
name|uint16_t
name|dlid_ho
parameter_list|,
name|OUT
name|osm_path_parms_t
modifier|*
name|p_parms
parameter_list|)
block|{
name|osm_alias_guid_t
modifier|*
name|p_src_alias_guid
decl_stmt|,
modifier|*
name|p_dest_alias_guid
decl_stmt|;
name|ib_path_rec_t
name|pr
decl_stmt|;
if|if
condition|(
operator|!
name|p_src_port
operator|||
operator|!
name|slid_ho
operator|||
operator|!
name|p_dest_port
operator|||
operator|!
name|dlid_ho
condition|)
return|return
name|IB_INVALID_PARAMETER
return|;
name|memset
argument_list|(
operator|&
name|pr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_path_rec_t
argument_list|)
argument_list|)
expr_stmt|;
name|p_src_alias_guid
operator|=
name|osm_get_alias_guid_by_guid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|osm_port_get_guid
argument_list|(
name|p_src_port
argument_list|)
argument_list|)
expr_stmt|;
name|p_dest_alias_guid
operator|=
name|osm_get_alias_guid_by_guid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|osm_port_get_guid
argument_list|(
name|p_dest_port
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pr_rcv_get_path_parms
argument_list|(
name|sa
argument_list|,
operator|&
name|pr
argument_list|,
name|p_src_alias_guid
argument_list|,
name|slid_ho
argument_list|,
name|p_dest_alias_guid
argument_list|,
name|dlid_ho
argument_list|,
literal|0
argument_list|,
name|p_parms
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pr_rcv_build_pr
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|osm_alias_guid_t
modifier|*
name|p_src_alias_guid
parameter_list|,
name|IN
specifier|const
name|osm_alias_guid_t
modifier|*
name|p_dest_alias_guid
parameter_list|,
name|IN
specifier|const
name|ib_gid_t
modifier|*
name|p_sgid
parameter_list|,
name|IN
specifier|const
name|ib_gid_t
modifier|*
name|p_dgid
parameter_list|,
name|IN
specifier|const
name|uint16_t
name|src_lid_ho
parameter_list|,
name|IN
specifier|const
name|uint16_t
name|dest_lid_ho
parameter_list|,
name|IN
specifier|const
name|uint8_t
name|preference
parameter_list|,
name|IN
specifier|const
name|osm_path_parms_t
modifier|*
name|p_parms
parameter_list|,
name|OUT
name|ib_path_rec_t
modifier|*
name|p_pr
parameter_list|)
block|{
specifier|const
name|osm_physp_t
modifier|*
name|p_src_physp
decl_stmt|,
modifier|*
name|p_dest_physp
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_dgid
condition|)
name|p_pr
operator|->
name|dgid
operator|=
operator|*
name|p_dgid
expr_stmt|;
else|else
block|{
name|p_dest_physp
operator|=
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
expr_stmt|;
name|p_pr
operator|->
name|dgid
operator|.
name|unicast
operator|.
name|prefix
operator|=
name|osm_physp_get_subnet_prefix
argument_list|(
name|p_dest_physp
argument_list|)
expr_stmt|;
name|p_pr
operator|->
name|dgid
operator|.
name|unicast
operator|.
name|interface_id
operator|=
name|p_dest_alias_guid
operator|->
name|alias_guid
expr_stmt|;
block|}
if|if
condition|(
name|p_sgid
condition|)
name|p_pr
operator|->
name|sgid
operator|=
operator|*
name|p_sgid
expr_stmt|;
else|else
block|{
name|p_src_physp
operator|=
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
expr_stmt|;
name|p_pr
operator|->
name|sgid
operator|.
name|unicast
operator|.
name|prefix
operator|=
name|osm_physp_get_subnet_prefix
argument_list|(
name|p_src_physp
argument_list|)
expr_stmt|;
name|p_pr
operator|->
name|sgid
operator|.
name|unicast
operator|.
name|interface_id
operator|=
name|p_src_alias_guid
operator|->
name|alias_guid
expr_stmt|;
block|}
name|p_pr
operator|->
name|dlid
operator|=
name|cl_hton16
argument_list|(
name|dest_lid_ho
argument_list|)
expr_stmt|;
name|p_pr
operator|->
name|slid
operator|=
name|cl_hton16
argument_list|(
name|src_lid_ho
argument_list|)
expr_stmt|;
name|p_pr
operator|->
name|hop_flow_raw
operator|&=
name|cl_hton32
argument_list|(
literal|1
operator|<<
literal|31
argument_list|)
expr_stmt|;
comment|/* Only set HopLimit if going through a router */
if|if
condition|(
name|p_dgid
condition|)
name|p_pr
operator|->
name|hop_flow_raw
operator||=
name|cl_hton32
argument_list|(
name|IB_HOPLIMIT_MAX
argument_list|)
expr_stmt|;
name|p_pr
operator|->
name|pkey
operator|=
name|p_parms
operator|->
name|pkey
expr_stmt|;
name|ib_path_rec_set_sl
argument_list|(
name|p_pr
argument_list|,
name|p_parms
operator|->
name|sl
argument_list|)
expr_stmt|;
name|ib_path_rec_set_qos_class
argument_list|(
name|p_pr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p_pr
operator|->
name|mtu
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_parms
operator|->
name|mtu
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|p_pr
operator|->
name|rate
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_parms
operator|->
name|rate
operator||
literal|0x80
argument_list|)
expr_stmt|;
comment|/* According to 1.2 spec definition Table 205 PacketLifeTime description, 	   for loopback paths, packetLifeTime shall be zero. */
if|if
condition|(
name|p_src_alias_guid
operator|->
name|p_base_port
operator|==
name|p_dest_alias_guid
operator|->
name|p_base_port
condition|)
name|p_pr
operator|->
name|pkt_life
operator|=
literal|0x80
expr_stmt|;
comment|/* loopback */
else|else
name|p_pr
operator|->
name|pkt_life
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_parms
operator|->
name|pkt_life
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|p_pr
operator|->
name|preference
operator|=
name|preference
expr_stmt|;
comment|/* always return num_path = 0 so this is only the reversible component */
if|if
condition|(
name|p_parms
operator|->
name|reversible
condition|)
name|p_pr
operator|->
name|num_path
operator|=
literal|0x80
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|osm_sa_item_t
modifier|*
name|pr_rcv_get_lid_pair_path
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|ib_path_rec_t
modifier|*
name|p_pr
parameter_list|,
name|IN
specifier|const
name|osm_alias_guid_t
modifier|*
name|p_src_alias_guid
parameter_list|,
name|IN
specifier|const
name|osm_alias_guid_t
modifier|*
name|p_dest_alias_guid
parameter_list|,
name|IN
specifier|const
name|ib_gid_t
modifier|*
name|p_sgid
parameter_list|,
name|IN
specifier|const
name|ib_gid_t
modifier|*
name|p_dgid
parameter_list|,
name|IN
specifier|const
name|uint16_t
name|src_lid_ho
parameter_list|,
name|IN
specifier|const
name|uint16_t
name|dest_lid_ho
parameter_list|,
name|IN
specifier|const
name|ib_net64_t
name|comp_mask
parameter_list|,
name|IN
specifier|const
name|uint8_t
name|preference
parameter_list|)
block|{
name|osm_path_parms_t
name|path_parms
decl_stmt|;
name|osm_path_parms_t
name|rev_path_parms
decl_stmt|;
name|osm_sa_item_t
modifier|*
name|p_pr_item
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|,
name|rev_path_status
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Src LID %u, Dest LID %u\n"
argument_list|,
name|src_lid_ho
argument_list|,
name|dest_lid_ho
argument_list|)
expr_stmt|;
name|p_pr_item
operator|=
name|malloc
argument_list|(
name|SA_PR_RESP_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_pr_item
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F01: "
literal|"Unable to allocate path record\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|memset
argument_list|(
name|p_pr_item
argument_list|,
literal|0
argument_list|,
name|SA_PR_RESP_SIZE
argument_list|)
expr_stmt|;
name|status
operator|=
name|pr_rcv_get_path_parms
argument_list|(
name|sa
argument_list|,
name|p_pr
argument_list|,
name|p_src_alias_guid
argument_list|,
name|src_lid_ho
argument_list|,
name|p_dest_alias_guid
argument_list|,
name|dest_lid_ho
argument_list|,
name|comp_mask
argument_list|,
operator|&
name|path_parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|free
argument_list|(
name|p_pr_item
argument_list|)
expr_stmt|;
name|p_pr_item
operator|=
name|NULL
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* now try the reversible path */
name|rev_path_status
operator|=
name|pr_rcv_get_path_parms
argument_list|(
name|sa
argument_list|,
name|p_pr
argument_list|,
name|p_dest_alias_guid
argument_list|,
name|dest_lid_ho
argument_list|,
name|p_src_alias_guid
argument_list|,
name|src_lid_ho
argument_list|,
name|comp_mask
argument_list|,
operator|&
name|rev_path_parms
argument_list|)
expr_stmt|;
name|path_parms
operator|.
name|reversible
operator|=
operator|(
name|rev_path_status
operator|==
name|IB_SUCCESS
operator|)
expr_stmt|;
comment|/* did we get a Reversible Path compmask ? */
comment|/* 	   NOTE that if the reversible component = 0, it is a don't care 	   rather than requiring non-reversible paths ... 	   see Vol1 Ver1.2 p900 l16 	 */
if|if
condition|(
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_REVERSIBLE
operator|)
operator|&&
operator|!
name|path_parms
operator|.
name|reversible
operator|&&
operator|(
name|p_pr
operator|->
name|num_path
operator|&
literal|0x80
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Requested reversible path but failed to get one\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_pr_item
argument_list|)
expr_stmt|;
name|p_pr_item
operator|=
name|NULL
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|pr_rcv_build_pr
argument_list|(
name|sa
argument_list|,
name|p_src_alias_guid
argument_list|,
name|p_dest_alias_guid
argument_list|,
name|p_sgid
argument_list|,
name|p_dgid
argument_list|,
name|src_lid_ho
argument_list|,
name|dest_lid_ho
argument_list|,
name|preference
argument_list|,
operator|&
name|path_parms
argument_list|,
operator|&
name|p_pr_item
operator|->
name|resp
operator|.
name|path_rec
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|p_pr_item
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pr_rcv_get_port_pair_paths
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|ib_sa_mad_t
modifier|*
name|sa_mad
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
name|p_req_port
parameter_list|,
name|IN
specifier|const
name|osm_alias_guid_t
modifier|*
name|p_src_alias_guid
parameter_list|,
name|IN
specifier|const
name|osm_alias_guid_t
modifier|*
name|p_dest_alias_guid
parameter_list|,
name|IN
specifier|const
name|ib_gid_t
modifier|*
name|p_sgid
parameter_list|,
name|IN
specifier|const
name|ib_gid_t
modifier|*
name|p_dgid
parameter_list|,
name|IN
name|cl_qlist_t
modifier|*
name|p_list
parameter_list|)
block|{
specifier|const
name|ib_path_rec_t
modifier|*
name|p_pr
init|=
name|ib_sa_mad_get_payload_ptr
argument_list|(
name|sa_mad
argument_list|)
decl_stmt|;
name|ib_net64_t
name|comp_mask
init|=
name|sa_mad
operator|->
name|comp_mask
decl_stmt|;
name|osm_sa_item_t
modifier|*
name|p_pr_item
decl_stmt|;
name|uint16_t
name|src_lid_min_ho
decl_stmt|;
name|uint16_t
name|src_lid_max_ho
decl_stmt|;
name|uint16_t
name|dest_lid_min_ho
decl_stmt|;
name|uint16_t
name|dest_lid_max_ho
decl_stmt|;
name|uint16_t
name|src_lid_ho
decl_stmt|;
name|uint16_t
name|dest_lid_ho
decl_stmt|;
name|uint32_t
name|path_num
decl_stmt|;
name|uint8_t
name|preference
decl_stmt|;
name|unsigned
name|iterations
decl_stmt|,
name|src_offset
decl_stmt|,
name|dest_offset
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Src port 0x%016"
name|PRIx64
literal|", Dst port 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_src_alias_guid
operator|->
name|alias_guid
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_dest_alias_guid
operator|->
name|alias_guid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check that the req_port, src_port and dest_port all share a 	   pkey. The check is done on the default physical port of the ports. */
if|if
condition|(
name|osm_port_share_pkey
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_req_port
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
argument_list|,
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|allow_both_pkeys
argument_list|)
operator|==
name|FALSE
operator|||
name|osm_port_share_pkey
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_req_port
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
argument_list|,
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|allow_both_pkeys
argument_list|)
operator|==
name|FALSE
operator|||
name|osm_port_share_pkey
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
argument_list|,
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|allow_both_pkeys
argument_list|)
operator|==
name|FALSE
condition|)
comment|/* One of the pairs doesn't share a pkey so the path is disqualified. */
goto|goto
name|Exit
goto|;
comment|/* 	   We shouldn't be here if the paths are disqualified in some way... 	   Thus, we assume every possible connection is valid.  	   We desire to return high-quality paths first. 	   In OpenSM, higher quality means least overlap with other paths. 	   This is acheived in practice by returning paths with 	   different LID value on each end, which means these 	   paths are more redundant that paths with the same LID repeated 	   on one side.  For example, in OpenSM the paths between two 	   endpoints with LMC = 1 might be as follows:  	   Port A, LID 1<-> Port B, LID 3 	   Port A, LID 1<-> Port B, LID 4 	   Port A, LID 2<-> Port B, LID 3 	   Port A, LID 2<-> Port B, LID 4  	   The OpenSM unicast routing algorithms attempt to disperse each path 	   to as varied a physical path as is reasonable.  1<->3 and 1<->4 have 	   more physical overlap (hence less redundancy) than 1<->3 and 2<->4.  	   OpenSM ranks paths in three preference groups:  	   Preference Value    Description 	   ----------------    ------------------------------------------- 	   0             Redundant in both directions with other 	   pref value = 0 paths  	   1             Redundant in one direction with other 	   pref value = 0 and pref value = 1 paths  	   2             Not redundant in either direction with 	   other paths  	   3-FF          Unused  	   SA clients don't need to know these details, only that the lower 	   preference paths are preferred, as stated in the spec.  The paths 	   may not actually be physically redundant depending on the topology 	   of the subnet, but the point of LMC> 0 is to offer redundancy, 	   so it is assumed that the subnet is physically appropriate for the 	   specified LMC value.  A more advanced implementation would inspect for 	   physical redundancy, but I'm not going to bother with that now. 	 */
comment|/* 	   Refine our search if the client specified end-point LIDs 	 */
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_DLID
condition|)
name|dest_lid_max_ho
operator|=
name|dest_lid_min_ho
operator|=
name|cl_ntoh16
argument_list|(
name|p_pr
operator|->
name|dlid
argument_list|)
expr_stmt|;
else|else
name|osm_port_get_lid_range_ho
argument_list|(
name|p_dest_alias_guid
operator|->
name|p_base_port
argument_list|,
operator|&
name|dest_lid_min_ho
argument_list|,
operator|&
name|dest_lid_max_ho
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_SLID
condition|)
name|src_lid_max_ho
operator|=
name|src_lid_min_ho
operator|=
name|cl_ntoh16
argument_list|(
name|p_pr
operator|->
name|slid
argument_list|)
expr_stmt|;
else|else
name|osm_port_get_lid_range_ho
argument_list|(
name|p_src_alias_guid
operator|->
name|p_base_port
argument_list|,
operator|&
name|src_lid_min_ho
argument_list|,
operator|&
name|src_lid_max_ho
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_lid_min_ho
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Obtained source LID of 0. No such LID possible "
literal|"(%s port %d)\n"
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_src_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|dest_lid_min_ho
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Obtained destination LID of 0. No such LID possible "
literal|"(%s port %d)\n"
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Src LIDs [%u-%u], Dest LIDs [%u-%u]\n"
argument_list|,
name|src_lid_min_ho
argument_list|,
name|src_lid_max_ho
argument_list|,
name|dest_lid_min_ho
argument_list|,
name|dest_lid_max_ho
argument_list|)
expr_stmt|;
name|src_lid_ho
operator|=
name|src_lid_min_ho
expr_stmt|;
name|dest_lid_ho
operator|=
name|dest_lid_min_ho
expr_stmt|;
comment|/* 	   Preferred paths come first in OpenSM 	 */
name|preference
operator|=
literal|0
expr_stmt|;
name|path_num
operator|=
literal|0
expr_stmt|;
comment|/* If SubnAdmGet, assume NumbPaths 1 (1.2 erratum) */
if|if
condition|(
name|sa_mad
operator|->
name|method
operator|==
name|IB_MAD_METHOD_GET
condition|)
name|iterations
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_NUMBPATH
condition|)
name|iterations
operator|=
name|ib_path_rec_num_path
argument_list|(
name|p_pr
argument_list|)
expr_stmt|;
else|else
name|iterations
operator|=
call|(
name|unsigned
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|path_num
operator|<
name|iterations
condition|)
block|{
comment|/* 		   These paths are "fully redundant" 		 */
name|p_pr_item
operator|=
name|pr_rcv_get_lid_pair_path
argument_list|(
name|sa
argument_list|,
name|p_pr
argument_list|,
name|p_src_alias_guid
argument_list|,
name|p_dest_alias_guid
argument_list|,
name|p_sgid
argument_list|,
name|p_dgid
argument_list|,
name|src_lid_ho
argument_list|,
name|dest_lid_ho
argument_list|,
name|comp_mask
argument_list|,
name|preference
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_pr_item
condition|)
block|{
name|cl_qlist_insert_tail
argument_list|(
name|p_list
argument_list|,
operator|&
name|p_pr_item
operator|->
name|list_item
argument_list|)
expr_stmt|;
operator|++
name|path_num
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|src_lid_ho
operator|>
name|src_lid_max_ho
condition|)
break|break;
if|if
condition|(
operator|++
name|dest_lid_ho
operator|>
name|dest_lid_max_ho
condition|)
break|break;
block|}
comment|/* 	   Check if we've accumulated all the paths that the user cares to see 	 */
if|if
condition|(
name|path_num
operator|==
name|iterations
condition|)
goto|goto
name|Exit
goto|;
comment|/* 	   Don't bother reporting preference 1 paths for now. 	   It's more trouble than it's worth and can only occur 	   if ports have different LMC values, which isn't supported 	   by OpenSM right now anyway. 	 */
name|preference
operator|=
literal|2
expr_stmt|;
name|src_lid_ho
operator|=
name|src_lid_min_ho
expr_stmt|;
name|dest_lid_ho
operator|=
name|dest_lid_min_ho
expr_stmt|;
name|src_offset
operator|=
literal|0
expr_stmt|;
name|dest_offset
operator|=
literal|0
expr_stmt|;
comment|/* 	   Iterate over the remaining paths 	 */
while|while
condition|(
name|path_num
operator|<
name|iterations
condition|)
block|{
name|dest_offset
operator|++
expr_stmt|;
name|dest_lid_ho
operator|++
expr_stmt|;
if|if
condition|(
name|dest_lid_ho
operator|>
name|dest_lid_max_ho
condition|)
block|{
name|src_offset
operator|++
expr_stmt|;
name|src_lid_ho
operator|++
expr_stmt|;
if|if
condition|(
name|src_lid_ho
operator|>
name|src_lid_max_ho
condition|)
break|break;
comment|/* done */
name|dest_offset
operator|=
literal|0
expr_stmt|;
name|dest_lid_ho
operator|=
name|dest_lid_min_ho
expr_stmt|;
block|}
comment|/* 		   These paths are "fully non-redundant" with paths already 		   identified above and consequently not of much value.  		   Don't return paths we already identified above, as indicated 		   by the offset values being equal. 		 */
if|if
condition|(
name|src_offset
operator|==
name|dest_offset
condition|)
continue|continue;
comment|/* already reported */
name|p_pr_item
operator|=
name|pr_rcv_get_lid_pair_path
argument_list|(
name|sa
argument_list|,
name|p_pr
argument_list|,
name|p_src_alias_guid
argument_list|,
name|p_dest_alias_guid
argument_list|,
name|p_sgid
argument_list|,
name|p_dgid
argument_list|,
name|src_lid_ho
argument_list|,
name|dest_lid_ho
argument_list|,
name|comp_mask
argument_list|,
name|preference
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_pr_item
condition|)
block|{
name|cl_qlist_insert_tail
argument_list|(
name|p_list
argument_list|,
operator|&
name|p_pr_item
operator|->
name|list_item
argument_list|)
expr_stmt|;
operator|++
name|path_num
expr_stmt|;
block|}
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the router port that is configured to handle this prefix, if any */
end_comment

begin_function
specifier|static
name|ib_net64_t
name|find_router
parameter_list|(
specifier|const
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|ib_net64_t
name|prefix
parameter_list|)
block|{
name|osm_prefix_route_t
modifier|*
name|route
init|=
name|NULL
decl_stmt|;
name|osm_router_t
modifier|*
name|rtr
decl_stmt|;
name|cl_qlist_t
modifier|*
name|l
init|=
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|prefix_routes_list
decl_stmt|;
name|cl_list_item_t
modifier|*
name|i
decl_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Non local DGID subnet prefix "
literal|"0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|prefix
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cl_qlist_head
argument_list|(
name|l
argument_list|)
init|;
name|i
operator|!=
name|cl_qlist_end
argument_list|(
name|l
argument_list|)
condition|;
name|i
operator|=
name|cl_qlist_next
argument_list|(
name|i
argument_list|)
control|)
block|{
name|osm_prefix_route_t
modifier|*
name|r
init|=
operator|(
name|osm_prefix_route_t
operator|*
operator|)
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|r
operator|->
name|prefix
operator|||
name|r
operator|->
name|prefix
operator|==
name|prefix
condition|)
block|{
name|route
operator|=
name|r
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|route
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|route
operator|->
name|guid
operator|==
literal|0
condition|)
comment|/* first router */
name|rtr
operator|=
operator|(
name|osm_router_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|rtr_guid_tbl
argument_list|)
expr_stmt|;
else|else
name|rtr
operator|=
operator|(
name|osm_router_t
operator|*
operator|)
name|cl_qmap_get
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|rtr_guid_tbl
argument_list|,
name|route
operator|->
name|guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtr
operator|==
operator|(
name|osm_router_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|rtr_guid_tbl
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|osm_port_get_guid
argument_list|(
name|osm_router_get_port_ptr
argument_list|(
name|rtr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|ib_net16_t
name|osm_pr_get_end_points
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|ib_sa_mad_t
modifier|*
name|sa_mad
parameter_list|,
name|OUT
specifier|const
name|osm_alias_guid_t
modifier|*
modifier|*
name|pp_src_alias_guid
parameter_list|,
name|OUT
specifier|const
name|osm_alias_guid_t
modifier|*
modifier|*
name|pp_dest_alias_guid
parameter_list|,
name|OUT
specifier|const
name|osm_port_t
modifier|*
modifier|*
name|pp_src_port
parameter_list|,
name|OUT
specifier|const
name|osm_port_t
modifier|*
modifier|*
name|pp_dest_port
parameter_list|,
name|OUT
specifier|const
name|ib_gid_t
modifier|*
modifier|*
name|pp_sgid
parameter_list|,
name|OUT
specifier|const
name|ib_gid_t
modifier|*
modifier|*
name|pp_dgid
parameter_list|)
block|{
specifier|const
name|ib_path_rec_t
modifier|*
name|p_pr
init|=
name|ib_sa_mad_get_payload_ptr
argument_list|(
name|sa_mad
argument_list|)
decl_stmt|;
name|ib_net64_t
name|comp_mask
init|=
name|sa_mad
operator|->
name|comp_mask
decl_stmt|;
name|ib_net64_t
name|dest_guid
decl_stmt|;
name|ib_net16_t
name|sa_status
init|=
name|IB_SA_MAD_STATUS_SUCCESS
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	   Determine what fields are valid and then get a pointer 	   to the source and destination port objects, if possible. 	 */
comment|/* 	   Check a few easy disqualifying cases up front before getting 	   into the endpoints. 	 */
operator|*
name|pp_src_alias_guid
operator|=
name|NULL
expr_stmt|;
operator|*
name|pp_src_port
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_SGID
condition|)
block|{
if|if
condition|(
operator|!
name|ib_gid_is_link_local
argument_list|(
operator|&
name|p_pr
operator|->
name|sgid
argument_list|)
condition|)
block|{
if|if
condition|(
name|ib_gid_get_subnet_prefix
argument_list|(
operator|&
name|p_pr
operator|->
name|sgid
argument_list|)
operator|!=
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|subnet_prefix
condition|)
block|{
comment|/* 				   This 'error' is the client's fault (bad gid) 				   so don't enter it as an error in our own log. 				   Return an error response to the client. 				 */
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Non local SGID subnet prefix 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_pr
operator|->
name|sgid
operator|.
name|unicast
operator|.
name|prefix
argument_list|)
argument_list|)
expr_stmt|;
name|sa_status
operator|=
name|IB_SA_MAD_STATUS_INVALID_GID
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
operator|*
name|pp_src_alias_guid
operator|=
name|osm_get_alias_guid_by_guid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|p_pr
operator|->
name|sgid
operator|.
name|unicast
operator|.
name|interface_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pp_src_alias_guid
condition|)
block|{
comment|/* 			   This 'error' is the client's fault (bad gid) so 			   don't enter it as an error in our own log. 			   Return an error response to the client. 			 */
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"No source port with GUID 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_pr
operator|->
name|sgid
operator|.
name|unicast
operator|.
name|interface_id
argument_list|)
argument_list|)
expr_stmt|;
name|sa_status
operator|=
name|IB_SA_MAD_STATUS_INVALID_GID
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|pp_sgid
condition|)
operator|*
name|pp_sgid
operator|=
operator|&
name|p_pr
operator|->
name|sgid
expr_stmt|;
block|}
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_SLID
condition|)
block|{
operator|*
name|pp_src_port
operator|=
name|osm_get_port_by_lid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|p_pr
operator|->
name|slid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pp_src_port
condition|)
block|{
comment|/* 			   This 'error' is the client's fault (bad lid) so 			   don't enter it as an error in our own log. 			   Return an error response to the client. 			 */
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"No source port "
literal|"with LID %u\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_pr
operator|->
name|slid
argument_list|)
argument_list|)
expr_stmt|;
name|sa_status
operator|=
name|IB_SA_MAD_STATUS_NO_RECORDS
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
operator|*
name|pp_dest_alias_guid
operator|=
name|NULL
expr_stmt|;
operator|*
name|pp_dest_port
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_DGID
condition|)
block|{
if|if
condition|(
operator|!
name|ib_gid_is_link_local
argument_list|(
operator|&
name|p_pr
operator|->
name|dgid
argument_list|)
operator|&&
operator|!
name|ib_gid_is_multicast
argument_list|(
operator|&
name|p_pr
operator|->
name|dgid
argument_list|)
operator|&&
name|ib_gid_get_subnet_prefix
argument_list|(
operator|&
name|p_pr
operator|->
name|dgid
argument_list|)
operator|!=
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|subnet_prefix
condition|)
block|{
name|dest_guid
operator|=
name|find_router
argument_list|(
name|sa
argument_list|,
name|p_pr
operator|->
name|dgid
operator|.
name|unicast
operator|.
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dest_guid
condition|)
block|{
name|char
name|gid_str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Off subnet DGID %s, but router not "
literal|"found\n"
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|p_pr
operator|->
name|dgid
operator|.
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
argument_list|(
name|gid_str
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sa_status
operator|=
name|IB_SA_MAD_STATUS_INVALID_GID
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|pp_dgid
condition|)
operator|*
name|pp_dgid
operator|=
operator|&
name|p_pr
operator|->
name|dgid
expr_stmt|;
block|}
else|else
name|dest_guid
operator|=
name|p_pr
operator|->
name|dgid
operator|.
name|unicast
operator|.
name|interface_id
expr_stmt|;
operator|*
name|pp_dest_alias_guid
operator|=
name|osm_get_alias_guid_by_guid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|dest_guid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pp_dest_alias_guid
condition|)
block|{
comment|/* 			   This 'error' is the client's fault (bad gid) so 			   don't enter it as an error in our own log. 			   Return an error response to the client. 			 */
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"No dest port with GUID 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|dest_guid
argument_list|)
argument_list|)
expr_stmt|;
name|sa_status
operator|=
name|IB_SA_MAD_STATUS_INVALID_GID
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_DLID
condition|)
block|{
operator|*
name|pp_dest_port
operator|=
name|osm_get_port_by_lid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|p_pr
operator|->
name|dlid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pp_dest_port
condition|)
block|{
comment|/* 			   This 'error' is the client's fault (bad lid) 			   so don't enter it as an error in our own log. 			   Return an error response to the client. 			 */
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"No dest port "
literal|"with LID %u\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_pr
operator|->
name|dlid
argument_list|)
argument_list|)
expr_stmt|;
name|sa_status
operator|=
name|IB_SA_MAD_STATUS_NO_RECORDS
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|sa_status
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pr_rcv_process_world
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|ib_sa_mad_t
modifier|*
name|sa_mad
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
name|requester_port
parameter_list|,
name|IN
specifier|const
name|ib_gid_t
modifier|*
name|p_sgid
parameter_list|,
name|IN
specifier|const
name|ib_gid_t
modifier|*
name|p_dgid
parameter_list|,
name|IN
name|cl_qlist_t
modifier|*
name|p_list
parameter_list|)
block|{
specifier|const
name|cl_qmap_t
modifier|*
name|p_tbl
decl_stmt|;
specifier|const
name|osm_alias_guid_t
modifier|*
name|p_dest_alias_guid
decl_stmt|,
modifier|*
name|p_src_alias_guid
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	   Iterate the entire port space over itself. 	   A path record from a port to itself is legit, so no 	   need for a special case there.  	   We compute both A -> B and B -> A, since we don't have 	   any check to determine the reversability of the paths. 	 */
name|p_tbl
operator|=
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|alias_port_guid_tbl
expr_stmt|;
name|p_dest_alias_guid
operator|=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_dest_alias_guid
operator|!=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_tbl
argument_list|)
condition|)
block|{
name|p_src_alias_guid
operator|=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_src_alias_guid
operator|!=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_tbl
argument_list|)
condition|)
block|{
name|pr_rcv_get_port_pair_paths
argument_list|(
name|sa
argument_list|,
name|sa_mad
argument_list|,
name|requester_port
argument_list|,
name|p_src_alias_guid
argument_list|,
name|p_dest_alias_guid
argument_list|,
name|p_sgid
argument_list|,
name|p_dgid
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa_mad
operator|->
name|method
operator|==
name|IB_MAD_METHOD_GET
operator|&&
name|cl_qlist_count
argument_list|(
name|p_list
argument_list|)
operator|>
literal|0
condition|)
goto|goto
name|Exit
goto|;
name|p_src_alias_guid
operator|=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_src_alias_guid
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
name|p_dest_alias_guid
operator|=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_dest_alias_guid
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_pr_process_half
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|ib_sa_mad_t
modifier|*
name|sa_mad
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
name|requester_port
parameter_list|,
name|IN
specifier|const
name|osm_alias_guid_t
modifier|*
name|p_src_alias_guid
parameter_list|,
name|IN
specifier|const
name|osm_alias_guid_t
modifier|*
name|p_dest_alias_guid
parameter_list|,
name|IN
specifier|const
name|ib_gid_t
modifier|*
name|p_sgid
parameter_list|,
name|IN
specifier|const
name|ib_gid_t
modifier|*
name|p_dgid
parameter_list|,
name|IN
name|cl_qlist_t
modifier|*
name|p_list
parameter_list|)
block|{
specifier|const
name|cl_qmap_t
modifier|*
name|p_tbl
decl_stmt|;
specifier|const
name|osm_alias_guid_t
modifier|*
name|p_alias_guid
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	   Iterate over every port, looking for matches... 	   A path record from a port to itself is legit, so no 	   need to special case that one. 	 */
name|p_tbl
operator|=
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|alias_port_guid_tbl
expr_stmt|;
if|if
condition|(
name|p_src_alias_guid
condition|)
block|{
comment|/* 		   The src port if fixed, so iterate over destination ports. 		 */
name|p_alias_guid
operator|=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_alias_guid
operator|!=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_tbl
argument_list|)
condition|)
block|{
name|pr_rcv_get_port_pair_paths
argument_list|(
name|sa
argument_list|,
name|sa_mad
argument_list|,
name|requester_port
argument_list|,
name|p_src_alias_guid
argument_list|,
name|p_alias_guid
argument_list|,
name|p_sgid
argument_list|,
name|p_dgid
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa_mad
operator|->
name|method
operator|==
name|IB_MAD_METHOD_GET
operator|&&
name|cl_qlist_count
argument_list|(
name|p_list
argument_list|)
operator|>
literal|0
condition|)
break|break;
name|p_alias_guid
operator|=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_alias_guid
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		   The dest port if fixed, so iterate over source ports. 		 */
name|p_alias_guid
operator|=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_alias_guid
operator|!=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_tbl
argument_list|)
condition|)
block|{
name|pr_rcv_get_port_pair_paths
argument_list|(
name|sa
argument_list|,
name|sa_mad
argument_list|,
name|requester_port
argument_list|,
name|p_alias_guid
argument_list|,
name|p_dest_alias_guid
argument_list|,
name|p_sgid
argument_list|,
name|p_dgid
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa_mad
operator|->
name|method
operator|==
name|IB_MAD_METHOD_GET
operator|&&
name|cl_qlist_count
argument_list|(
name|p_list
argument_list|)
operator|>
literal|0
condition|)
break|break;
name|p_alias_guid
operator|=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_alias_guid
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_pr_process_pair
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|ib_sa_mad_t
modifier|*
name|sa_mad
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
name|requester_port
parameter_list|,
name|IN
specifier|const
name|osm_alias_guid_t
modifier|*
name|p_src_alias_guid
parameter_list|,
name|IN
specifier|const
name|osm_alias_guid_t
modifier|*
name|p_dest_alias_guid
parameter_list|,
name|IN
specifier|const
name|ib_gid_t
modifier|*
name|p_sgid
parameter_list|,
name|IN
specifier|const
name|ib_gid_t
modifier|*
name|p_dgid
parameter_list|,
name|IN
name|cl_qlist_t
modifier|*
name|p_list
parameter_list|)
block|{
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|pr_rcv_get_port_pair_paths
argument_list|(
name|sa
argument_list|,
name|sa_mad
argument_list|,
name|requester_port
argument_list|,
name|p_src_alias_guid
argument_list|,
name|p_dest_alias_guid
argument_list|,
name|p_sgid
argument_list|,
name|p_dgid
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ib_api_status_t
name|pr_match_mgrp_attributes
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|ib_sa_mad_t
modifier|*
name|sa_mad
parameter_list|,
name|IN
specifier|const
name|osm_mgrp_t
modifier|*
name|p_mgrp
parameter_list|)
block|{
specifier|const
name|ib_path_rec_t
modifier|*
name|p_pr
init|=
name|ib_sa_mad_get_payload_ptr
argument_list|(
name|sa_mad
argument_list|)
decl_stmt|;
name|ib_net64_t
name|comp_mask
init|=
name|sa_mad
operator|->
name|comp_mask
decl_stmt|;
specifier|const
name|osm_port_t
modifier|*
name|port
decl_stmt|;
name|ib_api_status_t
name|status
init|=
name|IB_ERROR
decl_stmt|;
name|uint32_t
name|flow_label
decl_stmt|;
name|uint8_t
name|sl
decl_stmt|,
name|hop_limit
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* check that MLID of the MC group matches the PathRecord DLID */
if|if
condition|(
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_DLID
operator|)
operator|&&
name|p_mgrp
operator|->
name|mlid
operator|!=
name|p_pr
operator|->
name|dlid
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"DLID 0x%x is not MLID 0x%x for MC group\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_pr
operator|->
name|dlid
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_mgrp
operator|->
name|mlid
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* If SGID and/or SLID specified, should validate as member of MC group */
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_SGID
condition|)
block|{
if|if
condition|(
operator|!
name|osm_mgrp_get_mcm_alias_guid
argument_list|(
name|p_mgrp
argument_list|,
name|p_pr
operator|->
name|sgid
operator|.
name|unicast
operator|.
name|interface_id
argument_list|)
condition|)
block|{
name|char
name|gid_str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"SGID %s is not a member of MC group\n"
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|p_pr
operator|->
name|sgid
operator|.
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
name|gid_str
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_SLID
condition|)
block|{
name|port
operator|=
name|osm_get_port_by_lid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|p_pr
operator|->
name|slid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port
operator|||
operator|!
name|osm_mgrp_get_mcm_port
argument_list|(
name|p_mgrp
argument_list|,
name|port
operator|->
name|guid
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Either no port with SLID %u found or "
literal|"SLID not a member of MC group\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_pr
operator|->
name|slid
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/* Also, MTU, rate, packet lifetime, and raw traffic requested are not currently checked */
if|if
condition|(
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_PKEY
operator|)
operator|&&
name|p_pr
operator|->
name|pkey
operator|!=
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|pkey
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Pkey 0x%x doesn't match MC group Pkey 0x%x\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_pr
operator|->
name|pkey
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|pkey
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|ib_member_get_sl_flow_hop
argument_list|(
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|sl_flow_hop
argument_list|,
operator|&
name|sl
argument_list|,
operator|&
name|flow_label
argument_list|,
operator|&
name|hop_limit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_SL
operator|)
operator|&&
name|ib_path_rec_sl
argument_list|(
name|p_pr
argument_list|)
operator|!=
name|sl
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"SL %d doesn't match MC group SL %d\n"
argument_list|,
name|ib_path_rec_sl
argument_list|(
name|p_pr
argument_list|)
argument_list|,
name|sl
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* If SubnAdmGet, assume NumbPaths of 1 (1.2 erratum) */
if|if
condition|(
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_NUMBPATH
operator|)
operator|&&
name|sa_mad
operator|->
name|method
operator|!=
name|IB_MAD_METHOD_GET
operator|&&
name|ib_path_rec_num_path
argument_list|(
name|p_pr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Number of paths requested is 0\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_FLOWLABEL
operator|)
operator|&&
name|ib_path_rec_flow_lbl
argument_list|(
name|p_pr
argument_list|)
operator|!=
name|flow_label
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Flow label 0x%x doesn't match MC group "
literal|" flow label 0x%x\n"
argument_list|,
name|ib_path_rec_flow_lbl
argument_list|(
name|p_pr
argument_list|)
argument_list|,
name|flow_label
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_HOPLIMIT
operator|)
operator|&&
name|ib_path_rec_hop_limit
argument_list|(
name|p_pr
argument_list|)
operator|!=
name|hop_limit
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Hop limit %u doesn't match MC group hop limit %u\n"
argument_list|,
name|ib_path_rec_hop_limit
argument_list|(
name|p_pr
argument_list|)
argument_list|,
name|hop_limit
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_TCLASS
operator|)
operator|&&
name|p_pr
operator|->
name|tclass
operator|!=
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|tclass
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"TClass 0x%02x doesn't match MC group TClass 0x%02x\n"
argument_list|,
name|p_pr
operator|->
name|tclass
argument_list|,
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|tclass
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|status
operator|=
name|IB_SUCCESS
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pr_process_multicast
parameter_list|(
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
specifier|const
name|ib_sa_mad_t
modifier|*
name|sa_mad
parameter_list|,
name|cl_qlist_t
modifier|*
name|list
parameter_list|)
block|{
name|ib_path_rec_t
modifier|*
name|pr
init|=
name|ib_sa_mad_get_payload_ptr
argument_list|(
name|sa_mad
argument_list|)
decl_stmt|;
name|osm_mgrp_t
modifier|*
name|mgrp
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|osm_sa_item_t
modifier|*
name|pr_item
decl_stmt|;
name|uint32_t
name|flow_label
decl_stmt|;
name|uint8_t
name|sl
decl_stmt|,
name|hop_limit
decl_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Multicast destination requested\n"
argument_list|)
expr_stmt|;
name|mgrp
operator|=
name|osm_get_mgrp_by_mgid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
operator|&
name|pr
operator|->
name|dgid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mgrp
condition|)
block|{
name|char
name|gid_str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F09: "
literal|"No MC group found for PathRecord destination GID %s\n"
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|pr
operator|->
name|dgid
operator|.
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
name|gid_str
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Make sure the rest of the PathRecord matches the MC group attributes */
name|status
operator|=
name|pr_match_mgrp_attributes
argument_list|(
name|sa
argument_list|,
name|sa_mad
argument_list|,
name|mgrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F19: "
literal|"MC group attributes don't match PathRecord request\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pr_item
operator|=
name|malloc
argument_list|(
name|SA_PR_RESP_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr_item
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F18: "
literal|"Unable to allocate path record for MC group\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
name|pr_item
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cl_list_item_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy PathRecord request into response */
name|pr_item
operator|->
name|resp
operator|.
name|path_rec
operator|=
operator|*
name|pr
expr_stmt|;
comment|/* Now, use the MC info to cruft up the PathRecord response */
name|pr_item
operator|->
name|resp
operator|.
name|path_rec
operator|.
name|dgid
operator|=
name|mgrp
operator|->
name|mcmember_rec
operator|.
name|mgid
expr_stmt|;
name|pr_item
operator|->
name|resp
operator|.
name|path_rec
operator|.
name|dlid
operator|=
name|mgrp
operator|->
name|mcmember_rec
operator|.
name|mlid
expr_stmt|;
name|pr_item
operator|->
name|resp
operator|.
name|path_rec
operator|.
name|tclass
operator|=
name|mgrp
operator|->
name|mcmember_rec
operator|.
name|tclass
expr_stmt|;
name|pr_item
operator|->
name|resp
operator|.
name|path_rec
operator|.
name|num_path
operator|=
literal|1
expr_stmt|;
name|pr_item
operator|->
name|resp
operator|.
name|path_rec
operator|.
name|pkey
operator|=
name|mgrp
operator|->
name|mcmember_rec
operator|.
name|pkey
expr_stmt|;
comment|/* MTU, rate, and packet lifetime should be exactly */
name|pr_item
operator|->
name|resp
operator|.
name|path_rec
operator|.
name|mtu
operator|=
operator|(
name|IB_PATH_SELECTOR_EXACTLY
operator|<<
literal|6
operator|)
operator||
name|mgrp
operator|->
name|mcmember_rec
operator|.
name|mtu
expr_stmt|;
name|pr_item
operator|->
name|resp
operator|.
name|path_rec
operator|.
name|rate
operator|=
operator|(
name|IB_PATH_SELECTOR_EXACTLY
operator|<<
literal|6
operator|)
operator||
name|mgrp
operator|->
name|mcmember_rec
operator|.
name|rate
expr_stmt|;
name|pr_item
operator|->
name|resp
operator|.
name|path_rec
operator|.
name|pkt_life
operator|=
operator|(
name|IB_PATH_SELECTOR_EXACTLY
operator|<<
literal|6
operator|)
operator||
name|mgrp
operator|->
name|mcmember_rec
operator|.
name|pkt_life
expr_stmt|;
comment|/* SL, Hop Limit, and Flow Label */
name|ib_member_get_sl_flow_hop
argument_list|(
name|mgrp
operator|->
name|mcmember_rec
operator|.
name|sl_flow_hop
argument_list|,
operator|&
name|sl
argument_list|,
operator|&
name|flow_label
argument_list|,
operator|&
name|hop_limit
argument_list|)
expr_stmt|;
name|ib_path_rec_set_sl
argument_list|(
operator|&
name|pr_item
operator|->
name|resp
operator|.
name|path_rec
argument_list|,
name|sl
argument_list|)
expr_stmt|;
name|ib_path_rec_set_qos_class
argument_list|(
operator|&
name|pr_item
operator|->
name|resp
operator|.
name|path_rec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* HopLimit is not yet set in non link local MC groups */
comment|/* If it were, this would not be needed */
if|if
condition|(
name|ib_mgid_get_scope
argument_list|(
operator|&
name|mgrp
operator|->
name|mcmember_rec
operator|.
name|mgid
argument_list|)
operator|!=
name|IB_MC_SCOPE_LINK_LOCAL
condition|)
name|hop_limit
operator|=
name|IB_HOPLIMIT_MAX
expr_stmt|;
name|pr_item
operator|->
name|resp
operator|.
name|path_rec
operator|.
name|hop_flow_raw
operator|=
name|cl_hton32
argument_list|(
name|hop_limit
argument_list|)
operator||
operator|(
name|flow_label
operator|<<
literal|8
operator|)
expr_stmt|;
name|cl_qlist_insert_tail
argument_list|(
name|list
argument_list|,
operator|&
name|pr_item
operator|->
name|list_item
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_pr_rcv_process
parameter_list|(
name|IN
name|void
modifier|*
name|context
parameter_list|,
name|IN
name|void
modifier|*
name|data
parameter_list|)
block|{
name|osm_sa_t
modifier|*
name|sa
init|=
name|context
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_madw
init|=
name|data
decl_stmt|;
specifier|const
name|ib_sa_mad_t
modifier|*
name|p_sa_mad
init|=
name|osm_madw_get_sa_mad_ptr
argument_list|(
name|p_madw
argument_list|)
decl_stmt|;
name|ib_path_rec_t
modifier|*
name|p_pr
init|=
name|ib_sa_mad_get_payload_ptr
argument_list|(
name|p_sa_mad
argument_list|)
decl_stmt|;
name|cl_qlist_t
name|pr_list
decl_stmt|;
specifier|const
name|ib_gid_t
modifier|*
name|p_sgid
init|=
name|NULL
decl_stmt|,
modifier|*
name|p_dgid
init|=
name|NULL
decl_stmt|;
specifier|const
name|osm_alias_guid_t
modifier|*
name|p_src_alias_guid
decl_stmt|,
modifier|*
name|p_dest_alias_guid
decl_stmt|;
specifier|const
name|osm_port_t
modifier|*
name|p_src_port
decl_stmt|,
modifier|*
name|p_dest_port
decl_stmt|;
name|osm_port_t
modifier|*
name|requester_port
decl_stmt|;
name|uint8_t
name|rate
decl_stmt|,
name|mtu
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_sa_mad
operator|->
name|attr_id
operator|==
name|IB_MAD_ATTR_PATH_RECORD
argument_list|)
expr_stmt|;
comment|/* we only support SubnAdmGet and SubnAdmGetTable methods */
if|if
condition|(
name|p_sa_mad
operator|->
name|method
operator|!=
name|IB_MAD_METHOD_GET
operator|&&
name|p_sa_mad
operator|->
name|method
operator|!=
name|IB_MAD_METHOD_GETTABLE
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F17: "
literal|"Unsupported Method (%s) for PathRecord request\n"
argument_list|,
name|ib_get_sa_method_str
argument_list|(
name|p_sa_mad
operator|->
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_MAD_STATUS_UNSUP_METHOD_ATTR
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Validate rate if supplied */
if|if
condition|(
operator|(
name|p_sa_mad
operator|->
name|comp_mask
operator|&
name|IB_PR_COMPMASK_RATESELEC
operator|)
operator|&&
operator|(
name|p_sa_mad
operator|->
name|comp_mask
operator|&
name|IB_PR_COMPMASK_RATE
operator|)
condition|)
block|{
name|rate
operator|=
name|ib_path_rec_rate
argument_list|(
name|p_pr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ib_rate_is_valid
argument_list|(
name|rate
argument_list|)
condition|)
block|{
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/* Validate MTU if supplied */
if|if
condition|(
operator|(
name|p_sa_mad
operator|->
name|comp_mask
operator|&
name|IB_PR_COMPMASK_MTUSELEC
operator|)
operator|&&
operator|(
name|p_sa_mad
operator|->
name|comp_mask
operator|&
name|IB_PR_COMPMASK_MTU
operator|)
condition|)
block|{
name|mtu
operator|=
name|ib_path_rec_mtu
argument_list|(
name|p_pr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ib_mtu_is_valid
argument_list|(
name|mtu
argument_list|)
condition|)
block|{
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/* Make sure either none or both ServiceID parameters are supplied */
if|if
condition|(
operator|(
name|p_sa_mad
operator|->
name|comp_mask
operator|&
name|IB_PR_COMPMASK_SERVICEID
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|p_sa_mad
operator|->
name|comp_mask
operator|&
name|IB_PR_COMPMASK_SERVICEID
operator|)
operator|!=
name|IB_PR_COMPMASK_SERVICEID
condition|)
block|{
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_INSUF_COMPS
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|cl_qlist_init
argument_list|(
operator|&
name|pr_list
argument_list|)
expr_stmt|;
comment|/* 	   Most SA functions (including this one) are read-only on the 	   subnet object, so we grab the lock non-exclusively. 	 */
name|cl_plock_acquire
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
comment|/* update the requester physical port */
name|requester_port
operator|=
name|osm_get_port_by_mad_addr
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|sa
operator|->
name|p_subn
argument_list|,
name|osm_madw_get_mad_addr_ptr
argument_list|(
name|p_madw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|requester_port
operator|==
name|NULL
condition|)
block|{
name|cl_plock_release
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F16: "
literal|"Cannot find requester physical port\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Requester port GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_port_get_guid
argument_list|(
name|requester_port
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|osm_dump_path_record_v2
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_pr
argument_list|,
name|FILE_ID
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
expr_stmt|;
block|}
comment|/* Handle multicast destinations separately */
if|if
condition|(
operator|(
name|p_sa_mad
operator|->
name|comp_mask
operator|&
name|IB_PR_COMPMASK_DGID
operator|)
operator|&&
name|ib_gid_is_multicast
argument_list|(
operator|&
name|p_pr
operator|->
name|dgid
argument_list|)
condition|)
block|{
name|pr_process_multicast
argument_list|(
name|sa
argument_list|,
name|p_sa_mad
argument_list|,
operator|&
name|pr_list
argument_list|)
expr_stmt|;
goto|goto
name|Unlock
goto|;
block|}
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Unicast destination requested\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_pr_get_end_points
argument_list|(
name|sa
argument_list|,
name|p_sa_mad
argument_list|,
operator|&
name|p_src_alias_guid
argument_list|,
operator|&
name|p_dest_alias_guid
argument_list|,
operator|&
name|p_src_port
argument_list|,
operator|&
name|p_dest_port
argument_list|,
operator|&
name|p_sgid
argument_list|,
operator|&
name|p_dgid
argument_list|)
operator|!=
name|IB_SA_MAD_STATUS_SUCCESS
condition|)
goto|goto
name|Unlock
goto|;
if|if
condition|(
name|p_src_alias_guid
operator|&&
name|p_src_port
operator|&&
name|p_src_alias_guid
operator|->
name|p_base_port
operator|!=
name|p_src_port
condition|)
block|{
name|cl_plock_release
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Requester port GUID 0x%"
name|PRIx64
literal|": Port for SGUID "
literal|"0x%"
name|PRIx64
literal|" not same as port for SLID %u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_port_get_guid
argument_list|(
name|requester_port
argument_list|)
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_pr
operator|->
name|sgid
operator|.
name|unicast
operator|.
name|interface_id
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_pr
operator|->
name|slid
argument_list|)
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|p_dest_alias_guid
operator|&&
name|p_dest_port
operator|&&
name|p_dest_alias_guid
operator|->
name|p_base_port
operator|!=
name|p_dest_port
condition|)
block|{
name|cl_plock_release
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Requester port GUID 0x%"
name|PRIx64
literal|": Port for DGUID "
literal|"0x%"
name|PRIx64
literal|" not same as port for DLID %u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_port_get_guid
argument_list|(
name|requester_port
argument_list|)
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_pr
operator|->
name|dgid
operator|.
name|unicast
operator|.
name|interface_id
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_pr
operator|->
name|dlid
argument_list|)
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	   What happens next depends on the type of endpoint information 	   that was specified.... 	 */
if|if
condition|(
name|p_src_alias_guid
condition|)
block|{
if|if
condition|(
name|p_dest_alias_guid
condition|)
name|osm_pr_process_pair
argument_list|(
name|sa
argument_list|,
name|p_sa_mad
argument_list|,
name|requester_port
argument_list|,
name|p_src_alias_guid
argument_list|,
name|p_dest_alias_guid
argument_list|,
name|p_sgid
argument_list|,
name|p_dgid
argument_list|,
operator|&
name|pr_list
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|p_dest_port
condition|)
name|osm_pr_process_half
argument_list|(
name|sa
argument_list|,
name|p_sa_mad
argument_list|,
name|requester_port
argument_list|,
name|p_src_alias_guid
argument_list|,
name|NULL
argument_list|,
name|p_sgid
argument_list|,
name|p_dgid
argument_list|,
operator|&
name|pr_list
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Get all alias GUIDs for the dest port */
name|p_dest_alias_guid
operator|=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|alias_port_guid_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_dest_alias_guid
operator|!=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|alias_port_guid_tbl
argument_list|)
condition|)
block|{
if|if
condition|(
name|osm_get_port_by_alias_guid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|p_dest_alias_guid
operator|->
name|alias_guid
argument_list|)
operator|==
name|p_dest_port
condition|)
name|osm_pr_process_pair
argument_list|(
name|sa
argument_list|,
name|p_sa_mad
argument_list|,
name|requester_port
argument_list|,
name|p_src_alias_guid
argument_list|,
name|p_dest_alias_guid
argument_list|,
name|p_sgid
argument_list|,
name|p_dgid
argument_list|,
operator|&
name|pr_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sa_mad
operator|->
name|method
operator|==
name|IB_MAD_METHOD_GET
operator|&&
name|cl_qlist_count
argument_list|(
operator|&
name|pr_list
argument_list|)
operator|>
literal|0
condition|)
break|break;
name|p_dest_alias_guid
operator|=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_dest_alias_guid
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|p_dest_alias_guid
operator|&&
operator|!
name|p_src_port
condition|)
name|osm_pr_process_half
argument_list|(
name|sa
argument_list|,
name|p_sa_mad
argument_list|,
name|requester_port
argument_list|,
name|NULL
argument_list|,
name|p_dest_alias_guid
argument_list|,
name|p_sgid
argument_list|,
name|p_dgid
argument_list|,
operator|&
name|pr_list
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|p_src_port
operator|&&
operator|!
name|p_dest_port
condition|)
comment|/* 			   Katie, bar the door! 			 */
name|pr_rcv_process_world
argument_list|(
name|sa
argument_list|,
name|p_sa_mad
argument_list|,
name|requester_port
argument_list|,
name|p_sgid
argument_list|,
name|p_dgid
argument_list|,
operator|&
name|pr_list
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p_dest_alias_guid
operator|&&
name|p_src_port
condition|)
block|{
comment|/* Get all alias GUIDs for the src port */
name|p_src_alias_guid
operator|=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|alias_port_guid_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_src_alias_guid
operator|!=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|alias_port_guid_tbl
argument_list|)
condition|)
block|{
if|if
condition|(
name|osm_get_port_by_alias_guid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|p_src_alias_guid
operator|->
name|alias_guid
argument_list|)
operator|==
name|p_src_port
condition|)
name|osm_pr_process_pair
argument_list|(
name|sa
argument_list|,
name|p_sa_mad
argument_list|,
name|requester_port
argument_list|,
name|p_src_alias_guid
argument_list|,
name|p_dest_alias_guid
argument_list|,
name|p_sgid
argument_list|,
name|p_dgid
argument_list|,
operator|&
name|pr_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sa_mad
operator|->
name|method
operator|==
name|IB_MAD_METHOD_GET
operator|&&
name|cl_qlist_count
argument_list|(
operator|&
name|pr_list
argument_list|)
operator|>
literal|0
condition|)
break|break;
name|p_src_alias_guid
operator|=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_src_alias_guid
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p_src_port
operator|&&
operator|!
name|p_dest_port
condition|)
block|{
comment|/* Get all alias GUIDs for the src port */
name|p_src_alias_guid
operator|=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|alias_port_guid_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_src_alias_guid
operator|!=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|alias_port_guid_tbl
argument_list|)
condition|)
block|{
if|if
condition|(
name|osm_get_port_by_alias_guid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|p_src_alias_guid
operator|->
name|alias_guid
argument_list|)
operator|==
name|p_src_port
condition|)
name|osm_pr_process_half
argument_list|(
name|sa
argument_list|,
name|p_sa_mad
argument_list|,
name|requester_port
argument_list|,
name|p_src_alias_guid
argument_list|,
name|NULL
argument_list|,
name|p_sgid
argument_list|,
name|p_dgid
argument_list|,
operator|&
name|pr_list
argument_list|)
expr_stmt|;
name|p_src_alias_guid
operator|=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_src_alias_guid
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|p_dest_port
operator|&&
operator|!
name|p_src_port
condition|)
block|{
comment|/* Get all alias GUIDs for the dest port */
name|p_dest_alias_guid
operator|=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|alias_port_guid_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_dest_alias_guid
operator|!=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|alias_port_guid_tbl
argument_list|)
condition|)
block|{
if|if
condition|(
name|osm_get_port_by_alias_guid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|p_dest_alias_guid
operator|->
name|alias_guid
argument_list|)
operator|==
name|p_dest_port
condition|)
name|osm_pr_process_half
argument_list|(
name|sa
argument_list|,
name|p_sa_mad
argument_list|,
name|requester_port
argument_list|,
name|NULL
argument_list|,
name|p_dest_alias_guid
argument_list|,
name|p_sgid
argument_list|,
name|p_dgid
argument_list|,
operator|&
name|pr_list
argument_list|)
expr_stmt|;
name|p_dest_alias_guid
operator|=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_dest_alias_guid
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Get all alias GUIDs for the src port */
name|p_src_alias_guid
operator|=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|alias_port_guid_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_src_alias_guid
operator|!=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|alias_port_guid_tbl
argument_list|)
condition|)
block|{
if|if
condition|(
name|osm_get_port_by_alias_guid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|p_src_alias_guid
operator|->
name|alias_guid
argument_list|)
operator|==
name|p_src_port
condition|)
block|{
comment|/* Get all alias GUIDs for the dest port */
name|p_dest_alias_guid
operator|=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|alias_port_guid_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_dest_alias_guid
operator|!=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|alias_port_guid_tbl
argument_list|)
condition|)
block|{
if|if
condition|(
name|osm_get_port_by_alias_guid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|p_dest_alias_guid
operator|->
name|alias_guid
argument_list|)
operator|==
name|p_dest_port
condition|)
name|osm_pr_process_pair
argument_list|(
name|sa
argument_list|,
name|p_sa_mad
argument_list|,
name|requester_port
argument_list|,
name|p_src_alias_guid
argument_list|,
name|p_dest_alias_guid
argument_list|,
name|p_sgid
argument_list|,
name|p_dgid
argument_list|,
operator|&
name|pr_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sa_mad
operator|->
name|method
operator|==
name|IB_MAD_METHOD_GET
operator|&&
name|cl_qlist_count
argument_list|(
operator|&
name|pr_list
argument_list|)
operator|>
literal|0
condition|)
break|break;
name|p_dest_alias_guid
operator|=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_dest_alias_guid
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_sa_mad
operator|->
name|method
operator|==
name|IB_MAD_METHOD_GET
operator|&&
name|cl_qlist_count
argument_list|(
operator|&
name|pr_list
argument_list|)
operator|>
literal|0
condition|)
break|break;
name|p_src_alias_guid
operator|=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_src_alias_guid
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Unlock
label|:
name|cl_plock_release
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
comment|/* Now, (finally) respond to the PathRecord request */
name|osm_sa_respond
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_path_rec_t
argument_list|)
argument_list|,
operator|&
name|pr_list
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

