begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2008 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2007,2009 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  * Copyright (c) 2009 HNR Consulting. All rights reserved.  * Copyright (c) 2009 Battelle Memorial Institue. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *      Implementation of Up Down Algorithm using ranking& Min Hop  *      Calculation functions  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qmap.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_UCAST_DNUP_C
end_define

begin_include
include|#
directive|include
file|<opensm/osm_switch.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_ucast_mgr.h>
end_include

begin_comment
comment|/* //////////////////////////// */
end_comment

begin_comment
comment|/*  Local types                 */
end_comment

begin_comment
comment|/* //////////////////////////// */
end_comment

begin_comment
comment|/* direction */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|dnup_switch_dir
block|{
name|UP
init|=
literal|0
block|,
name|DOWN
block|,
name|EQUAL
block|}
name|dnup_switch_dir_t
typedef|;
end_typedef

begin_comment
comment|/* dnup structure */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dnup
block|{
name|osm_opensm_t
modifier|*
name|p_osm
decl_stmt|;
block|}
name|dnup_t
typedef|;
end_typedef

begin_struct
struct|struct
name|dnup_node
block|{
name|cl_list_item_t
name|list
decl_stmt|;
name|osm_switch_t
modifier|*
name|sw
decl_stmt|;
name|dnup_switch_dir_t
name|dir
decl_stmt|;
name|unsigned
name|rank
decl_stmt|;
name|unsigned
name|visited
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This function returns direction based on rank and guid info of current&    remote ports */
end_comment

begin_function
specifier|static
name|dnup_switch_dir_t
name|dnup_get_dir
parameter_list|(
name|unsigned
name|cur_rank
parameter_list|,
name|unsigned
name|rem_rank
parameter_list|)
block|{
comment|/* HACK: comes to solve root nodes connection, in a classic subnet root nodes do not connect 	   directly, but in case they are we assign to root node an UP direction to allow DNUP to discover 	   the subnet correctly (and not from the point of view of the last root node). 	 */
if|if
condition|(
operator|!
name|cur_rank
operator|&&
operator|!
name|rem_rank
condition|)
return|return
name|EQUAL
return|;
if|if
condition|(
name|cur_rank
operator|<
name|rem_rank
condition|)
return|return
name|DOWN
return|;
elseif|else
if|if
condition|(
name|cur_rank
operator|>
name|rem_rank
condition|)
return|return
name|UP
return|;
else|else
return|return
name|EQUAL
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * This function does the bfs of min hop table calculation by guid index  * as a starting point.  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|dnup_bfs_by_node
parameter_list|(
name|IN
name|osm_log_t
modifier|*
name|p_log
parameter_list|,
name|IN
name|osm_subn_t
modifier|*
name|p_subn
parameter_list|,
name|IN
name|osm_switch_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|uint8_t
name|prune_weight
parameter_list|,
name|OUT
name|uint8_t
modifier|*
name|max_hops
parameter_list|)
block|{
name|uint8_t
name|pn
decl_stmt|,
name|pn_rem
decl_stmt|;
name|cl_qlist_t
name|list
decl_stmt|;
name|uint16_t
name|lid
decl_stmt|;
name|struct
name|dnup_node
modifier|*
name|u
decl_stmt|;
name|dnup_switch_dir_t
name|next_dir
decl_stmt|,
name|current_dir
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|lid
operator|=
name|osm_node_get_base_lid
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lid
operator|=
name|cl_ntoh16
argument_list|(
name|lid
argument_list|)
expr_stmt|;
name|osm_switch_set_hops
argument_list|(
name|p_sw
argument_list|,
name|lid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Starting from switch - port GUID 0x%"
name|PRIx64
literal|" lid %u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_sw
operator|->
name|p_node
operator|->
name|node_info
operator|.
name|port_guid
argument_list|)
argument_list|,
name|lid
argument_list|)
expr_stmt|;
name|u
operator|=
name|p_sw
operator|->
name|priv
expr_stmt|;
name|u
operator|->
name|dir
operator|=
name|DOWN
expr_stmt|;
comment|/* Update list with the new element */
name|cl_qlist_init
argument_list|(
operator|&
name|list
argument_list|)
expr_stmt|;
name|cl_qlist_insert_tail
argument_list|(
operator|&
name|list
argument_list|,
operator|&
name|u
operator|->
name|list
argument_list|)
expr_stmt|;
comment|/* BFS the list till no next element */
while|while
condition|(
operator|!
name|cl_is_qlist_empty
argument_list|(
operator|&
name|list
argument_list|)
condition|)
block|{
name|u
operator|=
operator|(
expr|struct
name|dnup_node
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
operator|&
name|list
argument_list|)
expr_stmt|;
name|u
operator|->
name|visited
operator|=
literal|0
expr_stmt|;
comment|/* cleanup */
name|current_dir
operator|=
name|u
operator|->
name|dir
expr_stmt|;
comment|/* Go over all ports of the switch and find unvisited remote nodes */
for|for
control|(
name|pn
operator|=
literal|1
init|;
name|pn
operator|<
name|u
operator|->
name|sw
operator|->
name|num_ports
condition|;
name|pn
operator|++
control|)
block|{
name|osm_node_t
modifier|*
name|p_remote_node
decl_stmt|;
name|struct
name|dnup_node
modifier|*
name|rem_u
decl_stmt|;
name|uint8_t
name|current_min_hop
decl_stmt|,
name|remote_min_hop
decl_stmt|,
name|set_hop_return_value
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_remote_sw
decl_stmt|;
name|p_remote_node
operator|=
name|osm_node_get_remote_node
argument_list|(
name|u
operator|->
name|sw
operator|->
name|p_node
argument_list|,
name|pn
argument_list|,
operator|&
name|pn_rem
argument_list|)
expr_stmt|;
comment|/* If no remote node OR remote node is not a SWITCH 			   continue to next pn */
if|if
condition|(
operator|!
name|p_remote_node
operator|||
operator|!
name|p_remote_node
operator|->
name|sw
condition|)
continue|continue;
comment|/* Fetch remote guid only after validation of remote node */
name|p_remote_sw
operator|=
name|p_remote_node
operator|->
name|sw
expr_stmt|;
name|rem_u
operator|=
name|p_remote_sw
operator|->
name|priv
expr_stmt|;
comment|/* Decide which direction to mark it (UP/DOWN) */
name|next_dir
operator|=
name|dnup_get_dir
argument_list|(
name|u
operator|->
name|rank
argument_list|,
name|rem_u
operator|->
name|rank
argument_list|)
expr_stmt|;
comment|/* Set MinHop value for the current lid */
name|current_min_hop
operator|=
name|osm_switch_get_least_hops
argument_list|(
name|u
operator|->
name|sw
argument_list|,
name|lid
argument_list|)
expr_stmt|;
comment|/* Check hop count if better insert into list&& update 			   the remote node Min Hop Table */
name|remote_min_hop
operator|=
name|osm_switch_get_hop_count
argument_list|(
name|p_remote_sw
argument_list|,
name|lid
argument_list|,
name|pn_rem
argument_list|)
expr_stmt|;
comment|/* Check if this is a legal step : the only illegal step is going 			   from UP to DOWN */
if|if
condition|(
operator|(
name|current_dir
operator|==
name|UP
operator|)
operator|&&
operator|(
name|next_dir
operator|==
name|DOWN
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Avoiding move from 0x%016"
name|PRIx64
literal|" to 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|u
operator|->
name|sw
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_remote_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Illegal step. If prune_weight is set, allow it with an 				 * additional weight 				 */
if|if
condition|(
name|prune_weight
condition|)
block|{
name|current_min_hop
operator|+=
name|prune_weight
expr_stmt|;
if|if
condition|(
name|current_min_hop
operator|>=
literal|64
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AE02: Too many hops on subnet,"
literal|" can't relax illegal Dn/Up transition."
argument_list|)
expr_stmt|;
name|osm_switch_set_hops
argument_list|(
name|p_remote_sw
argument_list|,
name|lid
argument_list|,
name|pn_rem
argument_list|,
name|OSM_NO_PATH
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
continue|continue;
block|}
block|}
if|if
condition|(
name|current_min_hop
operator|+
literal|1
operator|<
name|remote_min_hop
condition|)
block|{
name|set_hop_return_value
operator|=
name|osm_switch_set_hops
argument_list|(
name|p_remote_sw
argument_list|,
name|lid
argument_list|,
name|pn_rem
argument_list|,
name|current_min_hop
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_hops
operator|&&
name|current_min_hop
operator|+
literal|1
operator|>
operator|*
name|max_hops
condition|)
block|{
operator|*
name|max_hops
operator|=
name|current_min_hop
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|set_hop_return_value
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AE01: "
literal|"Invalid value returned from set min hop is: %d\n"
argument_list|,
name|set_hop_return_value
argument_list|)
expr_stmt|;
block|}
comment|/* Check if remote port has already been visited */
if|if
condition|(
operator|!
name|rem_u
operator|->
name|visited
condition|)
block|{
comment|/* Insert dnup_switch item into the list */
name|rem_u
operator|->
name|dir
operator|=
name|next_dir
expr_stmt|;
name|rem_u
operator|->
name|visited
operator|=
literal|1
expr_stmt|;
name|cl_qlist_insert_tail
argument_list|(
operator|&
name|list
argument_list|,
operator|&
name|rem_u
operator|->
name|list
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* NOTE : PLS check if we need to decide that the first */
end_comment

begin_comment
comment|/*        rank is a SWITCH for BFS purpose */
end_comment

begin_function
specifier|static
name|int
name|dnup_subn_rank
parameter_list|(
name|IN
name|dnup_t
modifier|*
name|p_dnup
parameter_list|)
block|{
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|,
modifier|*
name|p_remote_physp
decl_stmt|;
name|cl_qlist_t
name|list
decl_stmt|;
name|cl_map_item_t
modifier|*
name|item
decl_stmt|;
name|struct
name|dnup_node
modifier|*
name|u
decl_stmt|,
modifier|*
name|remote_u
decl_stmt|;
name|uint8_t
name|num_ports
decl_stmt|,
name|port_num
decl_stmt|;
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|unsigned
name|max_rank
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|cl_qlist_init
argument_list|(
operator|&
name|list
argument_list|)
expr_stmt|;
comment|/* add all node level switches to the list */
for|for
control|(
name|item
operator|=
name|cl_qmap_head
argument_list|(
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
init|;
name|item
operator|!=
name|cl_qmap_end
argument_list|(
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
condition|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
control|)
block|{
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|item
expr_stmt|;
name|u
operator|=
name|p_sw
operator|->
name|priv
expr_stmt|;
if|if
condition|(
name|u
operator|->
name|rank
operator|==
literal|0
condition|)
name|cl_qlist_insert_tail
argument_list|(
operator|&
name|list
argument_list|,
operator|&
name|u
operator|->
name|list
argument_list|)
expr_stmt|;
block|}
comment|/* BFS the list till it's empty */
while|while
condition|(
operator|!
name|cl_is_qlist_empty
argument_list|(
operator|&
name|list
argument_list|)
condition|)
block|{
name|u
operator|=
operator|(
expr|struct
name|dnup_node
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
operator|&
name|list
argument_list|)
expr_stmt|;
comment|/* Go over all remote nodes and rank them (if not already visited) */
name|p_sw
operator|=
name|u
operator|->
name|sw
expr_stmt|;
name|num_ports
operator|=
name|p_sw
operator|->
name|num_ports
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Handling switch GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|port_num
operator|=
literal|1
init|;
name|port_num
operator|<
name|num_ports
condition|;
name|port_num
operator|++
control|)
block|{
name|ib_net64_t
name|port_guid
decl_stmt|;
comment|/* Current port fetched in order to get remote side */
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
condition|)
continue|continue;
name|p_remote_physp
operator|=
name|p_physp
operator|->
name|p_remote_physp
expr_stmt|;
comment|/* 			   make sure that all the following occur on p_remote_physp: 			   1. The port isn't NULL 			   2. It is a switch 			 */
if|if
condition|(
name|p_remote_physp
operator|&&
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
condition|)
block|{
name|remote_u
operator|=
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
operator|->
name|priv
expr_stmt|;
name|port_guid
operator|=
name|p_remote_physp
operator|->
name|port_guid
expr_stmt|;
if|if
condition|(
name|remote_u
operator|->
name|rank
operator|>
name|u
operator|->
name|rank
operator|+
literal|1
condition|)
block|{
name|remote_u
operator|->
name|rank
operator|=
name|u
operator|->
name|rank
operator|+
literal|1
expr_stmt|;
name|max_rank
operator|=
name|remote_u
operator|->
name|rank
expr_stmt|;
name|cl_qlist_insert_tail
argument_list|(
operator|&
name|list
argument_list|,
operator|&
name|remote_u
operator|->
name|list
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Rank of port GUID 0x%"
name|PRIx64
literal|" = %u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|,
name|remote_u
operator|->
name|rank
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Print Summary of ranking */
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Subnet ranking completed. Max Node Rank = %d\n"
argument_list|,
name|max_rank
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dnup_set_min_hop_table
parameter_list|(
name|IN
name|dnup_t
modifier|*
name|p_dnup
parameter_list|)
block|{
name|osm_subn_t
modifier|*
name|p_subn
init|=
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|subn
decl_stmt|;
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|struct
name|dnup_node
modifier|*
name|u
decl_stmt|;
name|cl_map_item_t
modifier|*
name|item
decl_stmt|;
name|uint8_t
name|max_hops
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
comment|/* Go over all the switches in the subnet - for each init their Min Hop 	   Table */
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Init Min Hop Table of all switches [\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
name|cl_qmap_head
argument_list|(
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
init|;
name|item
operator|!=
name|cl_qmap_end
argument_list|(
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
condition|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
control|)
block|{
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|item
expr_stmt|;
comment|/* Clear Min Hop Table */
name|osm_switch_clear_hops
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Init Min Hop Table of all switches ]\n"
argument_list|)
expr_stmt|;
comment|/* Now do the BFS for each port  in the subnet */
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"BFS through all port guids in the subnet [\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
name|cl_qmap_head
argument_list|(
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
init|;
name|item
operator|!=
name|cl_qmap_end
argument_list|(
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
condition|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
control|)
block|{
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|item
expr_stmt|;
name|dnup_bfs_by_node
argument_list|(
name|p_log
argument_list|,
name|p_subn
argument_list|,
name|p_sw
argument_list|,
literal|0
argument_list|,
operator|&
name|max_hops
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_subn
operator|->
name|opt
operator|.
name|connect_roots
condition|)
block|{
comment|/*This is probably not necessary, by I am more comfortable 		 * clearing any possible side effects from the previous 		 * dnup routing pass 		 */
for|for
control|(
name|item
operator|=
name|cl_qmap_head
argument_list|(
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
init|;
name|item
operator|!=
name|cl_qmap_end
argument_list|(
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
condition|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
control|)
block|{
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|item
expr_stmt|;
name|osm_switch_clear_hops
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
name|u
operator|=
operator|(
expr|struct
name|dnup_node
operator|*
operator|)
name|p_sw
operator|->
name|priv
expr_stmt|;
name|u
operator|->
name|visited
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|item
operator|=
name|cl_qmap_head
argument_list|(
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
init|;
name|item
operator|!=
name|cl_qmap_end
argument_list|(
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
condition|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
control|)
block|{
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|item
expr_stmt|;
name|dnup_bfs_by_node
argument_list|(
name|p_log
argument_list|,
name|p_subn
argument_list|,
name|p_sw
argument_list|,
name|max_hops
operator|+
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"BFS through all port guids in the subnet ]\n"
argument_list|)
expr_stmt|;
comment|/* Cleanup */
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dnup_build_lid_matrices
parameter_list|(
name|IN
name|dnup_t
modifier|*
name|p_dnup
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Ranking all port guids in the list\n"
argument_list|)
expr_stmt|;
comment|/* Check if it's not a switched subnet */
if|if
condition|(
name|cl_is_qmap_empty
argument_list|(
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AEOB: "
literal|"This is not a switched subnet, cannot perform DNUP algorithm\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|_exit
goto|;
block|}
comment|/* Rank the subnet switches */
name|dnup_subn_rank
argument_list|(
name|p_dnup
argument_list|)
expr_stmt|;
comment|/* After multiple ranking need to set Min Hop Table by DnUp algorithm  */
name|OSM_LOG
argument_list|(
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Setting all switches' Min Hop Table\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|dnup_set_min_hop_table
argument_list|(
name|p_dnup
argument_list|)
expr_stmt|;
name|_exit
label|:
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|dnup_node
modifier|*
name|create_dnup_node
parameter_list|(
name|osm_switch_t
modifier|*
name|sw
parameter_list|)
block|{
name|struct
name|dnup_node
modifier|*
name|u
decl_stmt|;
name|u
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|u
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|u
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|u
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|u
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|->
name|sw
operator|=
name|sw
expr_stmt|;
name|u
operator|->
name|rank
operator|=
literal|0xffffffff
expr_stmt|;
return|return
name|u
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_dnup_node
parameter_list|(
name|struct
name|dnup_node
modifier|*
name|u
parameter_list|)
block|{
name|u
operator|->
name|sw
operator|->
name|priv
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* DNUP callback function */
end_comment

begin_function
specifier|static
name|int
name|dnup_lid_matrices
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|dnup_t
modifier|*
name|p_dnup
init|=
name|ctx
decl_stmt|;
name|cl_map_item_t
modifier|*
name|item
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|num_leafs
init|=
literal|0
decl_stmt|;
name|uint8_t
name|pn
decl_stmt|,
name|pn_rem
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
name|cl_qmap_head
argument_list|(
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
init|;
name|item
operator|!=
name|cl_qmap_end
argument_list|(
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
condition|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
control|)
block|{
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|item
expr_stmt|;
name|p_sw
operator|->
name|priv
operator|=
name|create_dnup_node
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_sw
operator|->
name|priv
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
operator|(
name|p_dnup
operator|->
name|p_osm
operator|->
name|log
operator|)
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AE0C: "
literal|"cannot create dnup node\n"
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* First setup node level nodes */
for|for
control|(
name|item
operator|=
name|cl_qmap_head
argument_list|(
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
init|;
name|item
operator|!=
name|cl_qmap_end
argument_list|(
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
condition|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
control|)
block|{
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|item
expr_stmt|;
for|for
control|(
name|pn
operator|=
literal|0
init|;
name|pn
operator|<
name|p_sw
operator|->
name|num_ports
condition|;
name|pn
operator|++
control|)
block|{
name|osm_node_t
modifier|*
name|p_remote_node
decl_stmt|;
name|p_remote_node
operator|=
name|osm_node_get_remote_node
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|,
name|pn
argument_list|,
operator|&
name|pn_rem
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_remote_node
operator|&&
operator|!
name|p_remote_node
operator|->
name|sw
condition|)
block|{
name|struct
name|dnup_node
modifier|*
name|u
init|=
name|p_sw
operator|->
name|priv
decl_stmt|;
name|u
operator|->
name|rank
operator|=
literal|0
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
operator|(
name|p_dnup
operator|->
name|p_osm
operator|->
name|log
operator|)
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"(%s) rank 0 leaf switch\n"
argument_list|,
name|p_sw
operator|->
name|p_node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
name|num_leafs
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|num_leafs
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
operator|(
name|p_dnup
operator|->
name|p_osm
operator|->
name|log
operator|)
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AE0D: No leaf switches found, DnUp routing failed\n"
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ret
operator|=
name|dnup_build_lid_matrices
argument_list|(
name|p_dnup
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
name|cl_qmap_head
argument_list|(
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
init|;
name|item
operator|!=
name|cl_qmap_end
argument_list|(
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
condition|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
control|)
block|{
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|item
expr_stmt|;
name|delete_dnup_node
argument_list|(
name|p_sw
operator|->
name|priv
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_dnup
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dnup_delete
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|free
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|osm_ucast_dnup_setup
parameter_list|(
name|struct
name|osm_routing_engine
modifier|*
name|r
parameter_list|,
name|osm_opensm_t
modifier|*
name|osm
parameter_list|)
block|{
name|dnup_t
modifier|*
name|dnup
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|dnup
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dnup_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dnup
condition|)
return|return
operator|-
literal|1
return|;
name|memset
argument_list|(
name|dnup
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dnup_t
argument_list|)
argument_list|)
expr_stmt|;
name|dnup
operator|->
name|p_osm
operator|=
name|osm
expr_stmt|;
name|r
operator|->
name|context
operator|=
name|dnup
expr_stmt|;
name|r
operator|->
name|destroy
operator|=
name|dnup_delete
expr_stmt|;
name|r
operator|->
name|build_lid_matrices
operator|=
name|dnup_lid_matrices
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

