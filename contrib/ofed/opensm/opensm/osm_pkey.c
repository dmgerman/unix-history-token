begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2012 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of opensm pkey manipulation functions.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_PKEY_C
end_define

begin_include
include|#
directive|include
file|<opensm/osm_pkey.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_port.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_node.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_switch.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_function
name|void
name|osm_pkey_tbl_construct
parameter_list|(
name|IN
name|osm_pkey_tbl_t
modifier|*
name|p_pkey_tbl
parameter_list|)
block|{
name|cl_map_construct
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|accum_pkeys
argument_list|)
expr_stmt|;
name|cl_ptr_vector_construct
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|blocks
argument_list|)
expr_stmt|;
name|cl_ptr_vector_construct
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|new_blocks
argument_list|)
expr_stmt|;
name|cl_map_construct
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|keys
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_pkey_tbl_destroy
parameter_list|(
name|IN
name|osm_pkey_tbl_t
modifier|*
name|p_pkey_tbl
parameter_list|)
block|{
name|ib_pkey_table_t
modifier|*
name|p_block
decl_stmt|;
name|uint16_t
name|num_blocks
decl_stmt|,
name|i
decl_stmt|;
name|num_blocks
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|blocks
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|p_block
operator|=
name|cl_ptr_vector_get
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|blocks
argument_list|,
name|i
argument_list|)
operator|)
condition|)
name|free
argument_list|(
name|p_block
argument_list|)
expr_stmt|;
name|cl_ptr_vector_destroy
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|blocks
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|new_blocks
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|p_block
operator|=
name|cl_ptr_vector_get
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|new_blocks
argument_list|,
name|i
argument_list|)
operator|)
condition|)
name|free
argument_list|(
name|p_block
argument_list|)
expr_stmt|;
name|cl_ptr_vector_destroy
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|new_blocks
argument_list|)
expr_stmt|;
name|cl_map_remove_all
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|accum_pkeys
argument_list|)
expr_stmt|;
name|cl_map_destroy
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|accum_pkeys
argument_list|)
expr_stmt|;
name|cl_map_remove_all
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|keys
argument_list|)
expr_stmt|;
name|cl_map_destroy
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|keys
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ib_api_status_t
name|osm_pkey_tbl_init
parameter_list|(
name|IN
name|osm_pkey_tbl_t
modifier|*
name|p_pkey_tbl
parameter_list|)
block|{
name|cl_map_init
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|accum_pkeys
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cl_ptr_vector_init
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|blocks
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cl_ptr_vector_init
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|new_blocks
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cl_map_init
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|keys
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cl_qlist_init
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|pending
argument_list|)
expr_stmt|;
name|p_pkey_tbl
operator|->
name|last_pkey_idx
operator|=
literal|0
expr_stmt|;
name|p_pkey_tbl
operator|->
name|used_blocks
operator|=
literal|0
expr_stmt|;
name|p_pkey_tbl
operator|->
name|max_blocks
operator|=
literal|0
expr_stmt|;
name|p_pkey_tbl
operator|->
name|rcv_blocks_cnt
operator|=
literal|0
expr_stmt|;
name|p_pkey_tbl
operator|->
name|indx0_pkey
operator|=
literal|0
expr_stmt|;
return|return
name|IB_SUCCESS
return|;
block|}
end_function

begin_function
name|void
name|osm_pkey_tbl_init_new_blocks
parameter_list|(
name|IN
specifier|const
name|osm_pkey_tbl_t
modifier|*
name|p_pkey_tbl
parameter_list|)
block|{
name|ib_pkey_table_t
modifier|*
name|p_block
decl_stmt|;
name|size_t
name|b
decl_stmt|,
name|num_blocks
init|=
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|new_blocks
argument_list|)
decl_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|num_blocks
condition|;
name|b
operator|++
control|)
if|if
condition|(
operator|(
name|p_block
operator|=
name|cl_ptr_vector_get
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|new_blocks
argument_list|,
name|b
argument_list|)
operator|)
condition|)
name|memset
argument_list|(
name|p_block
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_block
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ib_api_status_t
name|osm_pkey_tbl_set
parameter_list|(
name|IN
name|osm_pkey_tbl_t
modifier|*
name|p_pkey_tbl
parameter_list|,
name|IN
name|uint16_t
name|block
parameter_list|,
name|IN
name|ib_pkey_table_t
modifier|*
name|p_tbl
parameter_list|,
name|IN
name|boolean_t
name|allow_both_pkeys
parameter_list|)
block|{
name|uint16_t
name|b
decl_stmt|,
name|i
decl_stmt|;
name|ib_pkey_table_t
modifier|*
name|p_pkey_block
decl_stmt|;
name|uint16_t
modifier|*
name|p_prev_pkey
decl_stmt|;
name|ib_net16_t
name|pkey
decl_stmt|,
name|pkey_base
decl_stmt|;
comment|/* make sure the block is allocated */
if|if
condition|(
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|blocks
argument_list|)
operator|>
name|block
condition|)
name|p_pkey_block
operator|=
operator|(
name|ib_pkey_table_t
operator|*
operator|)
name|cl_ptr_vector_get
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
else|else
name|p_pkey_block
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|p_pkey_block
condition|)
block|{
name|p_pkey_block
operator|=
operator|(
name|ib_pkey_table_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ib_pkey_table_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_pkey_block
condition|)
return|return
name|IB_ERROR
return|;
name|memset
argument_list|(
name|p_pkey_block
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_pkey_table_t
argument_list|)
argument_list|)
expr_stmt|;
name|cl_ptr_vector_set
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|blocks
argument_list|,
name|block
argument_list|,
name|p_pkey_block
argument_list|)
expr_stmt|;
block|}
comment|/* sets the block values */
name|memcpy
argument_list|(
name|p_pkey_block
argument_list|,
name|p_tbl
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_pkey_table_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	   NOTE: as the spec does not require uniqueness of PKeys in 	   tables there is no other way but to refresh the entire keys map.  	   Moreover, if the same key exists but with full membership it should 	   have precedence over the key with limited membership ! 	 */
name|cl_map_remove_all
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|keys
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|blocks
argument_list|)
condition|;
name|b
operator|++
control|)
block|{
name|p_pkey_block
operator|=
name|cl_ptr_vector_get
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|blocks
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_pkey_block
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IB_NUM_PKEY_ELEMENTS_IN_BLOCK
condition|;
name|i
operator|++
control|)
block|{
name|pkey
operator|=
name|p_pkey_block
operator|->
name|pkey_entry
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ib_pkey_is_invalid
argument_list|(
name|pkey
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|allow_both_pkeys
condition|)
name|pkey_base
operator|=
name|pkey
expr_stmt|;
else|else
name|pkey_base
operator|=
name|ib_pkey_get_base
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
comment|/* 			   If allow_both_pkeys is FALSE, 			   ignore the PKey Full Member bit in the key but store 			   the pointer to the table element as the map value 			 */
name|p_prev_pkey
operator|=
name|cl_map_get
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|keys
argument_list|,
name|pkey_base
argument_list|)
expr_stmt|;
comment|/* we only insert if no previous or it is not full member and allow_both_pkeys is FALSE */
if|if
condition|(
operator|(
name|p_prev_pkey
operator|==
name|NULL
operator|)
operator|||
operator|(
name|allow_both_pkeys
operator|==
name|FALSE
operator|&&
name|cl_ntoh16
argument_list|(
operator|*
name|p_prev_pkey
argument_list|)
operator|<
name|cl_ntoh16
argument_list|(
name|pkey
argument_list|)
operator|)
condition|)
name|cl_map_insert
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|keys
argument_list|,
name|pkey_base
argument_list|,
operator|&
operator|(
name|p_pkey_block
operator|->
name|pkey_entry
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|IB_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*   Store the given pkey (along with it's overall index) in the accum_pkeys array. */
end_comment

begin_function
name|cl_status_t
name|osm_pkey_tbl_set_accum_pkeys
parameter_list|(
name|IN
name|osm_pkey_tbl_t
modifier|*
name|p_pkey_tbl
parameter_list|,
name|IN
name|uint16_t
name|pkey
parameter_list|,
name|IN
name|uint16_t
name|pkey_idx
parameter_list|)
block|{
name|uintptr_t
name|ptr
init|=
name|pkey_idx
operator|+
literal|1
decl_stmt|;
comment|/* 0 means not found so bias by 1 */
name|uint16_t
modifier|*
name|p_prev_pkey_idx
decl_stmt|;
name|cl_status_t
name|status
init|=
name|CL_SUCCESS
decl_stmt|;
if|if
condition|(
name|pkey_idx
operator|>=
name|p_pkey_tbl
operator|->
name|last_pkey_idx
condition|)
name|p_pkey_tbl
operator|->
name|last_pkey_idx
operator|=
name|pkey_idx
operator|+
literal|1
expr_stmt|;
name|p_prev_pkey_idx
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|cl_map_get
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|accum_pkeys
argument_list|,
name|pkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_prev_pkey_idx
operator|!=
name|NULL
condition|)
name|cl_map_remove
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|accum_pkeys
argument_list|,
name|pkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl_map_insert
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|accum_pkeys
argument_list|,
name|pkey
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ptr
argument_list|)
operator|==
name|NULL
condition|)
name|status
operator|=
name|CL_INSUFFICIENT_MEMORY
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* + * Find the next last pkey index +*/
end_comment

begin_function
name|void
name|osm_pkey_find_last_accum_pkey_index
parameter_list|(
name|IN
name|osm_pkey_tbl_t
modifier|*
name|p_pkey_tbl
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|uintptr_t
name|pkey_idx_ptr
decl_stmt|;
name|uint16_t
name|pkey_idx
decl_stmt|,
name|last_pkey_idx
init|=
literal|0
decl_stmt|;
name|cl_map_iterator_t
name|map_iter
init|=
name|cl_map_head
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|accum_pkeys
argument_list|)
decl_stmt|;
while|while
condition|(
name|map_iter
operator|!=
name|cl_map_end
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|accum_pkeys
argument_list|)
condition|)
block|{
name|ptr
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|cl_map_obj
argument_list|(
name|map_iter
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|pkey_idx_ptr
operator|=
operator|(
name|uintptr_t
operator|)
name|ptr
expr_stmt|;
name|pkey_idx
operator|=
name|pkey_idx_ptr
expr_stmt|;
if|if
condition|(
name|pkey_idx
operator|>
name|last_pkey_idx
condition|)
name|last_pkey_idx
operator|=
name|pkey_idx
expr_stmt|;
name|map_iter
operator|=
name|cl_map_next
argument_list|(
name|map_iter
argument_list|)
expr_stmt|;
block|}
name|p_pkey_tbl
operator|->
name|last_pkey_idx
operator|=
name|last_pkey_idx
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   Store the given pkey in the "new" blocks array.   Also, make sure the regular block exists. */
end_comment

begin_function
name|ib_api_status_t
name|osm_pkey_tbl_set_new_entry
parameter_list|(
name|IN
name|osm_pkey_tbl_t
modifier|*
name|p_pkey_tbl
parameter_list|,
name|IN
name|uint16_t
name|block_idx
parameter_list|,
name|IN
name|uint8_t
name|pkey_idx
parameter_list|,
name|IN
name|uint16_t
name|pkey
parameter_list|)
block|{
name|ib_pkey_table_t
modifier|*
name|p_block
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_block
operator|=
name|osm_pkey_tbl_new_block_get
argument_list|(
name|p_pkey_tbl
argument_list|,
name|block_idx
argument_list|)
operator|)
condition|)
block|{
name|p_block
operator|=
operator|(
name|ib_pkey_table_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ib_pkey_table_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_block
condition|)
return|return
name|IB_ERROR
return|;
name|memset
argument_list|(
name|p_block
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_pkey_table_t
argument_list|)
argument_list|)
expr_stmt|;
name|cl_ptr_vector_set
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|new_blocks
argument_list|,
name|block_idx
argument_list|,
name|p_block
argument_list|)
expr_stmt|;
block|}
name|p_block
operator|->
name|pkey_entry
index|[
name|pkey_idx
index|]
operator|=
name|pkey
expr_stmt|;
if|if
condition|(
name|p_pkey_tbl
operator|->
name|used_blocks
operator|<=
name|block_idx
condition|)
name|p_pkey_tbl
operator|->
name|used_blocks
operator|=
name|block_idx
operator|+
literal|1
expr_stmt|;
return|return
name|IB_SUCCESS
return|;
block|}
end_function

begin_function
name|boolean_t
name|osm_pkey_find_next_free_entry
parameter_list|(
name|IN
name|osm_pkey_tbl_t
modifier|*
name|p_pkey_tbl
parameter_list|,
name|OUT
name|uint16_t
modifier|*
name|p_block_idx
parameter_list|,
name|OUT
name|uint8_t
modifier|*
name|p_pkey_idx
parameter_list|)
block|{
name|ib_pkey_table_t
modifier|*
name|p_new_block
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_block_idx
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_pkey_idx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p_block_idx
operator|<
name|p_pkey_tbl
operator|->
name|max_blocks
condition|)
block|{
if|if
condition|(
operator|*
name|p_pkey_idx
operator|>
name|IB_NUM_PKEY_ELEMENTS_IN_BLOCK
operator|-
literal|1
condition|)
block|{
operator|*
name|p_pkey_idx
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|p_block_idx
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p_block_idx
operator|>=
name|p_pkey_tbl
operator|->
name|max_blocks
condition|)
return|return
name|FALSE
return|;
block|}
name|p_new_block
operator|=
name|osm_pkey_tbl_new_block_get
argument_list|(
name|p_pkey_tbl
argument_list|,
operator|*
name|p_block_idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_new_block
operator|||
name|ib_pkey_is_invalid
argument_list|(
name|p_new_block
operator|->
name|pkey_entry
index|[
operator|*
name|p_pkey_idx
index|]
argument_list|)
condition|)
return|return
name|TRUE
return|;
else|else
operator|(
operator|*
name|p_pkey_idx
operator|)
operator|++
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|ib_api_status_t
name|osm_pkey_tbl_get_block_and_idx
parameter_list|(
name|IN
name|osm_pkey_tbl_t
modifier|*
name|p_pkey_tbl
parameter_list|,
name|IN
name|uint16_t
modifier|*
name|p_pkey
parameter_list|,
name|OUT
name|uint16_t
modifier|*
name|p_block_idx
parameter_list|,
name|OUT
name|uint8_t
modifier|*
name|p_pkey_idx
parameter_list|)
block|{
name|uint16_t
name|num_of_blocks
decl_stmt|;
name|uint16_t
name|block_index
decl_stmt|;
name|ib_pkey_table_t
modifier|*
name|block
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_block_idx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_pkey_idx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|num_of_blocks
operator|=
operator|(
name|uint16_t
operator|)
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|block_index
operator|=
literal|0
init|;
name|block_index
operator|<
name|num_of_blocks
condition|;
name|block_index
operator|++
control|)
block|{
name|block
operator|=
name|osm_pkey_tbl_block_get
argument_list|(
name|p_pkey_tbl
argument_list|,
name|block_index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|block
operator|->
name|pkey_entry
operator|<=
name|p_pkey
operator|)
operator|&&
operator|(
name|p_pkey
operator|<
name|block
operator|->
name|pkey_entry
operator|+
name|IB_NUM_PKEY_ELEMENTS_IN_BLOCK
operator|)
condition|)
block|{
operator|*
name|p_block_idx
operator|=
name|block_index
expr_stmt|;
operator|*
name|p_pkey_idx
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_pkey
operator|-
name|block
operator|->
name|pkey_entry
argument_list|)
expr_stmt|;
return|return
name|IB_SUCCESS
return|;
block|}
block|}
return|return
name|IB_NOT_FOUND
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|match_pkey
parameter_list|(
name|IN
specifier|const
name|ib_net16_t
modifier|*
name|pkey1
parameter_list|,
name|IN
specifier|const
name|ib_net16_t
modifier|*
name|pkey2
parameter_list|)
block|{
comment|/* if both pkeys are not full member - this is not a match */
if|if
condition|(
operator|!
operator|(
name|ib_pkey_is_full_member
argument_list|(
operator|*
name|pkey1
argument_list|)
operator|||
name|ib_pkey_is_full_member
argument_list|(
operator|*
name|pkey2
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* compare if the bases are the same. if they are - then 	   this is a match */
if|if
condition|(
name|ib_pkey_get_base
argument_list|(
operator|*
name|pkey1
argument_list|)
operator|!=
name|ib_pkey_get_base
argument_list|(
operator|*
name|pkey2
argument_list|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|boolean_t
name|osm_physp_share_this_pkey
parameter_list|(
name|IN
specifier|const
name|osm_physp_t
modifier|*
name|p_physp1
parameter_list|,
name|IN
specifier|const
name|osm_physp_t
modifier|*
name|p_physp2
parameter_list|,
name|IN
name|ib_net16_t
name|pkey
parameter_list|,
name|IN
name|boolean_t
name|allow_both_pkeys
parameter_list|)
block|{
name|ib_net16_t
modifier|*
name|pkey1
decl_stmt|,
modifier|*
name|pkey2
decl_stmt|;
name|ib_net16_t
name|full_pkey
decl_stmt|,
name|limited_pkey
decl_stmt|;
if|if
condition|(
name|allow_both_pkeys
condition|)
block|{
name|full_pkey
operator|=
name|pkey
operator||
name|IB_PKEY_TYPE_MASK
expr_stmt|;
name|limited_pkey
operator|=
name|pkey
operator|&
operator|~
name|IB_PKEY_TYPE_MASK
expr_stmt|;
name|pkey1
operator|=
name|cl_map_get
argument_list|(
operator|&
operator|(
name|osm_physp_get_pkey_tbl
argument_list|(
name|p_physp1
argument_list|)
operator|)
operator|->
name|keys
argument_list|,
name|full_pkey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pkey1
condition|)
name|pkey1
operator|=
name|cl_map_get
argument_list|(
operator|&
operator|(
name|osm_physp_get_pkey_tbl
argument_list|(
name|p_physp1
argument_list|)
operator|)
operator|->
name|keys
argument_list|,
name|limited_pkey
argument_list|)
expr_stmt|;
name|pkey2
operator|=
name|cl_map_get
argument_list|(
operator|&
operator|(
name|osm_physp_get_pkey_tbl
argument_list|(
name|p_physp2
argument_list|)
operator|)
operator|->
name|keys
argument_list|,
name|full_pkey
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pkey2
condition|)
name|pkey2
operator|=
name|cl_map_get
argument_list|(
operator|&
operator|(
name|osm_physp_get_pkey_tbl
argument_list|(
name|p_physp2
argument_list|)
operator|)
operator|->
name|keys
argument_list|,
name|limited_pkey
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pkey1
operator|=
name|cl_map_get
argument_list|(
operator|&
operator|(
name|osm_physp_get_pkey_tbl
argument_list|(
name|p_physp1
argument_list|)
operator|)
operator|->
name|keys
argument_list|,
name|ib_pkey_get_base
argument_list|(
name|pkey
argument_list|)
argument_list|)
expr_stmt|;
name|pkey2
operator|=
name|cl_map_get
argument_list|(
operator|&
operator|(
name|osm_physp_get_pkey_tbl
argument_list|(
name|p_physp2
argument_list|)
operator|)
operator|->
name|keys
argument_list|,
name|ib_pkey_get_base
argument_list|(
name|pkey
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|pkey1
operator|&&
name|pkey2
operator|&&
name|match_pkey
argument_list|(
name|pkey1
argument_list|,
name|pkey2
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|ib_net16_t
name|osm_physp_find_common_pkey
parameter_list|(
name|IN
specifier|const
name|osm_physp_t
modifier|*
name|p_physp1
parameter_list|,
name|IN
specifier|const
name|osm_physp_t
modifier|*
name|p_physp2
parameter_list|,
name|IN
name|boolean_t
name|allow_both_pkeys
parameter_list|)
block|{
name|ib_net16_t
modifier|*
name|pkey1
decl_stmt|,
modifier|*
name|pkey2
decl_stmt|;
name|uint64_t
name|pkey1_base
decl_stmt|,
name|pkey2_base
decl_stmt|;
specifier|const
name|osm_pkey_tbl_t
modifier|*
name|pkey_tbl1
decl_stmt|,
modifier|*
name|pkey_tbl2
decl_stmt|;
name|cl_map_iterator_t
name|map_iter1
decl_stmt|,
name|map_iter2
decl_stmt|;
name|pkey_tbl1
operator|=
name|osm_physp_get_pkey_tbl
argument_list|(
name|p_physp1
argument_list|)
expr_stmt|;
name|pkey_tbl2
operator|=
name|osm_physp_get_pkey_tbl
argument_list|(
name|p_physp2
argument_list|)
expr_stmt|;
name|map_iter1
operator|=
name|cl_map_head
argument_list|(
operator|&
name|pkey_tbl1
operator|->
name|keys
argument_list|)
expr_stmt|;
name|map_iter2
operator|=
name|cl_map_head
argument_list|(
operator|&
name|pkey_tbl2
operator|->
name|keys
argument_list|)
expr_stmt|;
comment|/* we rely on the fact the map are sorted by pkey */
while|while
condition|(
operator|(
name|map_iter1
operator|!=
name|cl_map_end
argument_list|(
operator|&
name|pkey_tbl1
operator|->
name|keys
argument_list|)
operator|)
operator|&&
operator|(
name|map_iter2
operator|!=
name|cl_map_end
argument_list|(
operator|&
name|pkey_tbl2
operator|->
name|keys
argument_list|)
operator|)
condition|)
block|{
name|pkey1
operator|=
operator|(
name|ib_net16_t
operator|*
operator|)
name|cl_map_obj
argument_list|(
name|map_iter1
argument_list|)
expr_stmt|;
name|pkey2
operator|=
operator|(
name|ib_net16_t
operator|*
operator|)
name|cl_map_obj
argument_list|(
name|map_iter2
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_pkey
argument_list|(
name|pkey1
argument_list|,
name|pkey2
argument_list|)
condition|)
return|return
operator|*
name|pkey1
return|;
comment|/* advance the lower value if they are not equal */
name|pkey1_base
operator|=
name|cl_map_key
argument_list|(
name|map_iter1
argument_list|)
expr_stmt|;
name|pkey2_base
operator|=
name|cl_map_key
argument_list|(
name|map_iter2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey2_base
operator|==
name|pkey1_base
condition|)
block|{
name|map_iter1
operator|=
name|cl_map_next
argument_list|(
name|map_iter1
argument_list|)
expr_stmt|;
name|map_iter2
operator|=
name|cl_map_next
argument_list|(
name|map_iter2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pkey2_base
operator|<
name|pkey1_base
condition|)
name|map_iter2
operator|=
name|cl_map_next
argument_list|(
name|map_iter2
argument_list|)
expr_stmt|;
else|else
name|map_iter1
operator|=
name|cl_map_next
argument_list|(
name|map_iter1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|allow_both_pkeys
condition|)
return|return
literal|0
return|;
comment|/* 	   When using allow_both_pkeys, the keys in pkey tables are the 	   pkey value including membership bit. 	   Therefore, in order to complete the search, we also need to 	   compare port\s 1 full pkeys with port 2 limited pkeys, and 	   port 2 full pkeys with port 1 full pkeys. 	*/
name|map_iter1
operator|=
name|cl_map_head
argument_list|(
operator|&
name|pkey_tbl1
operator|->
name|keys
argument_list|)
expr_stmt|;
name|map_iter2
operator|=
name|cl_map_head
argument_list|(
operator|&
name|pkey_tbl2
operator|->
name|keys
argument_list|)
expr_stmt|;
comment|/* comparing pkey_tbl1 full with pkey_tbl2 limited */
while|while
condition|(
operator|(
name|map_iter1
operator|!=
name|cl_map_end
argument_list|(
operator|&
name|pkey_tbl1
operator|->
name|keys
argument_list|)
operator|)
operator|&&
operator|(
name|map_iter2
operator|!=
name|cl_map_end
argument_list|(
operator|&
name|pkey_tbl2
operator|->
name|keys
argument_list|)
operator|)
condition|)
block|{
name|pkey1
operator|=
operator|(
name|ib_net16_t
operator|*
operator|)
name|cl_map_obj
argument_list|(
name|map_iter1
argument_list|)
expr_stmt|;
name|pkey2
operator|=
operator|(
name|ib_net16_t
operator|*
operator|)
name|cl_map_obj
argument_list|(
name|map_iter2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ib_pkey_is_full_member
argument_list|(
operator|*
name|pkey1
argument_list|)
condition|)
block|{
name|map_iter1
operator|=
name|cl_map_next
argument_list|(
name|map_iter1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ib_pkey_is_full_member
argument_list|(
operator|*
name|pkey2
argument_list|)
condition|)
block|{
name|map_iter2
operator|=
name|cl_map_next
argument_list|(
name|map_iter2
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|match_pkey
argument_list|(
name|pkey1
argument_list|,
name|pkey2
argument_list|)
condition|)
return|return
operator|*
name|pkey1
return|;
comment|/* advance the lower value if they are not equal */
name|pkey1_base
operator|=
name|ib_pkey_get_base
argument_list|(
name|cl_map_key
argument_list|(
name|map_iter1
argument_list|)
argument_list|)
expr_stmt|;
name|pkey2_base
operator|=
name|ib_pkey_get_base
argument_list|(
name|cl_map_key
argument_list|(
name|map_iter2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey2_base
operator|==
name|pkey1_base
condition|)
block|{
name|map_iter1
operator|=
name|cl_map_next
argument_list|(
name|map_iter1
argument_list|)
expr_stmt|;
name|map_iter2
operator|=
name|cl_map_next
argument_list|(
name|map_iter2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pkey2_base
operator|<
name|pkey1_base
condition|)
name|map_iter2
operator|=
name|cl_map_next
argument_list|(
name|map_iter2
argument_list|)
expr_stmt|;
else|else
name|map_iter1
operator|=
name|cl_map_next
argument_list|(
name|map_iter1
argument_list|)
expr_stmt|;
block|}
name|map_iter1
operator|=
name|cl_map_head
argument_list|(
operator|&
name|pkey_tbl1
operator|->
name|keys
argument_list|)
expr_stmt|;
name|map_iter2
operator|=
name|cl_map_head
argument_list|(
operator|&
name|pkey_tbl2
operator|->
name|keys
argument_list|)
expr_stmt|;
comment|/* comparing pkey_tbl1 limited with pkey_tbl2 full */
while|while
condition|(
operator|(
name|map_iter1
operator|!=
name|cl_map_end
argument_list|(
operator|&
name|pkey_tbl1
operator|->
name|keys
argument_list|)
operator|)
operator|&&
operator|(
name|map_iter2
operator|!=
name|cl_map_end
argument_list|(
operator|&
name|pkey_tbl2
operator|->
name|keys
argument_list|)
operator|)
condition|)
block|{
name|pkey1
operator|=
operator|(
name|ib_net16_t
operator|*
operator|)
name|cl_map_obj
argument_list|(
name|map_iter1
argument_list|)
expr_stmt|;
name|pkey2
operator|=
operator|(
name|ib_net16_t
operator|*
operator|)
name|cl_map_obj
argument_list|(
name|map_iter2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_pkey_is_full_member
argument_list|(
operator|*
name|pkey1
argument_list|)
condition|)
block|{
name|map_iter1
operator|=
name|cl_map_next
argument_list|(
name|map_iter1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|ib_pkey_is_full_member
argument_list|(
operator|*
name|pkey2
argument_list|)
condition|)
block|{
name|map_iter2
operator|=
name|cl_map_next
argument_list|(
name|map_iter2
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|match_pkey
argument_list|(
name|pkey1
argument_list|,
name|pkey2
argument_list|)
condition|)
return|return
operator|*
name|pkey1
return|;
comment|/* advance the lower value if they are not equal */
name|pkey1_base
operator|=
name|ib_pkey_get_base
argument_list|(
name|cl_map_key
argument_list|(
name|map_iter1
argument_list|)
argument_list|)
expr_stmt|;
name|pkey2_base
operator|=
name|ib_pkey_get_base
argument_list|(
name|cl_map_key
argument_list|(
name|map_iter2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey2_base
operator|==
name|pkey1_base
condition|)
block|{
name|map_iter1
operator|=
name|cl_map_next
argument_list|(
name|map_iter1
argument_list|)
expr_stmt|;
name|map_iter2
operator|=
name|cl_map_next
argument_list|(
name|map_iter2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pkey2_base
operator|<
name|pkey1_base
condition|)
name|map_iter2
operator|=
name|cl_map_next
argument_list|(
name|map_iter2
argument_list|)
expr_stmt|;
else|else
name|map_iter1
operator|=
name|cl_map_next
argument_list|(
name|map_iter1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|boolean_t
name|osm_physp_share_pkey
parameter_list|(
name|IN
name|osm_log_t
modifier|*
name|p_log
parameter_list|,
name|IN
specifier|const
name|osm_physp_t
modifier|*
name|p_physp_1
parameter_list|,
name|IN
specifier|const
name|osm_physp_t
modifier|*
name|p_physp_2
parameter_list|,
name|IN
name|boolean_t
name|allow_both_pkeys
parameter_list|)
block|{
specifier|const
name|osm_pkey_tbl_t
modifier|*
name|pkey_tbl1
decl_stmt|,
modifier|*
name|pkey_tbl2
decl_stmt|;
if|if
condition|(
name|p_physp_1
operator|==
name|p_physp_2
condition|)
return|return
name|TRUE
return|;
name|pkey_tbl1
operator|=
name|osm_physp_get_pkey_tbl
argument_list|(
name|p_physp_1
argument_list|)
expr_stmt|;
name|pkey_tbl2
operator|=
name|osm_physp_get_pkey_tbl
argument_list|(
name|p_physp_2
argument_list|)
expr_stmt|;
comment|/* 	   The spec: 10.9.2 does not require each phys port to have PKey Table. 	   So actually if it does not, we need to use the default port instead.  	   HACK: meanwhile we will ignore the check 	 */
if|if
condition|(
name|cl_is_map_empty
argument_list|(
operator|&
name|pkey_tbl1
operator|->
name|keys
argument_list|)
operator|||
name|cl_is_map_empty
argument_list|(
operator|&
name|pkey_tbl2
operator|->
name|keys
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
operator|!
name|ib_pkey_is_invalid
argument_list|(
name|osm_physp_find_common_pkey
argument_list|(
name|p_physp_1
argument_list|,
name|p_physp_2
argument_list|,
name|allow_both_pkeys
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|osm_port_share_pkey
parameter_list|(
name|IN
name|osm_log_t
modifier|*
name|p_log
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
name|p_port_1
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
name|p_port_2
parameter_list|,
name|IN
name|boolean_t
name|allow_both_pkeys
parameter_list|)
block|{
name|osm_physp_t
modifier|*
name|p_physp1
decl_stmt|,
modifier|*
name|p_physp2
decl_stmt|;
name|boolean_t
name|ret
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port_1
operator|||
operator|!
name|p_port_2
condition|)
block|{
name|ret
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_physp1
operator|=
name|p_port_1
operator|->
name|p_physp
expr_stmt|;
name|p_physp2
operator|=
name|p_port_2
operator|->
name|p_physp
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp1
operator|||
operator|!
name|p_physp2
condition|)
block|{
name|ret
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|ret
operator|=
name|osm_physp_share_pkey
argument_list|(
name|p_log
argument_list|,
name|p_physp1
argument_list|,
name|p_physp2
argument_list|,
name|allow_both_pkeys
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|boolean_t
name|osm_physp_has_pkey
parameter_list|(
name|IN
name|osm_log_t
modifier|*
name|p_log
parameter_list|,
name|IN
name|ib_net16_t
name|pkey
parameter_list|,
name|IN
specifier|const
name|osm_physp_t
modifier|*
name|p_physp
parameter_list|)
block|{
name|ib_net16_t
modifier|*
name|p_pkey
decl_stmt|,
name|pkey_base
decl_stmt|;
specifier|const
name|osm_pkey_tbl_t
modifier|*
name|pkey_tbl
decl_stmt|;
name|boolean_t
name|res
init|=
name|FALSE
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Search for PKey: 0x%04x\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|pkey
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if the pkey given is an invalid pkey - return TRUE. */
if|if
condition|(
name|ib_pkey_is_invalid
argument_list|(
name|pkey
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Given invalid PKey - we treat it loosely and allow it\n"
argument_list|)
expr_stmt|;
name|res
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|pkey_base
operator|=
name|ib_pkey_get_base
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
name|pkey_tbl
operator|=
name|osm_physp_get_pkey_tbl
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|p_pkey
operator|=
name|cl_map_get
argument_list|(
operator|&
name|pkey_tbl
operator|->
name|keys
argument_list|,
name|pkey_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_pkey
condition|)
block|{
name|res
operator|=
name|TRUE
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"PKey 0x%04x was found\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|pkey
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"PKey 0x%04x was not found\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|pkey
argument_list|)
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|void
name|osm_pkey_tbl_set_indx0_pkey
parameter_list|(
name|IN
name|osm_log_t
modifier|*
name|p_log
parameter_list|,
name|IN
name|ib_net16_t
name|pkey
parameter_list|,
name|IN
name|boolean_t
name|full
parameter_list|,
name|OUT
name|osm_pkey_tbl_t
modifier|*
name|p_pkey_tbl
parameter_list|)
block|{
name|p_pkey_tbl
operator|->
name|indx0_pkey
operator|=
operator|(
name|full
operator|==
name|TRUE
operator|)
condition|?
name|pkey
operator||
name|cl_hton16
argument_list|(
literal|0x8000
argument_list|)
else|:
name|pkey
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"pkey 0x%04x set at indx0\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_pkey_tbl
operator|->
name|indx0_pkey
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

