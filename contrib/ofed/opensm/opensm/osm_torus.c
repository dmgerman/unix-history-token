begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2009 Sandia Corporation.  Under the terms of Contract  * DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains  * certain rights in this software.  * Copyright (c) 2009-2011 ZIH, TU Dresden, Federal Republic of Germany. All rights reserved.  * Copyright (c) 2010-2012 Mellanox Technologies LTD. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_define
define|#
directive|define
name|_WITH_GETLINE
end_define

begin_comment
comment|/* for getline() */
end_comment

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_TORUS_C
end_define

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_port.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_switch.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_node.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_define
define|#
directive|define
name|TORUS_MAX_DIM
value|3
end_define

begin_define
define|#
directive|define
name|PORTGRP_MAX_PORTS
value|16
end_define

begin_define
define|#
directive|define
name|SWITCH_MAX_PORTGRPS
value|(1 + 2 * TORUS_MAX_DIM)
end_define

begin_define
define|#
directive|define
name|DEFAULT_MAX_CHANGES
value|32
end_define

begin_define
define|#
directive|define
name|ARRAY_SIZE
parameter_list|(
name|x
parameter_list|)
value|(sizeof(x) / sizeof((x)[0]))
end_define

begin_typedef
typedef|typedef
name|ib_net64_t
name|guid_t
typedef|;
end_typedef

begin_comment
comment|/*  * An endpoint terminates a link, and is one of three types:  *   UNKNOWN  - Uninitialized endpoint.  *   SRCSINK  - generates or consumes traffic, and thus has an associated LID;  *		  i.e. a CA or router port.  *   PASSTHRU - Has no associated LID; i.e. a switch port.  *  * If it is possible to communicate in-band with a switch, it will require  * a port with a GUID in the switch to source/sink that traffic, but there  * will be no attached link.  This code assumes there is only one such port.  *  * Here is an endpoint taxonomy:  *  *   type == SRCSINK  *   link == pointer to a valid struct link  *     ==> This endpoint is a CA or router port connected via a link to  *	     either a switch or another CA/router.  Thus:  *	   n_id ==> identifies the CA/router node GUID  *	   sw   ==> NULL  *	   port ==> identifies the port on the CA/router this endpoint uses  *	   pgrp ==> NULL  *  *   type == SRCSINK  *   link == NULL pointer  *     ==> This endpoint is the switch port used for in-band communication  *	     with the switch itself.  Thus:  *	   n_id ==> identifies the node GUID used to talk to the switch  *		      containing this endpoint  *	   sw   ==> pointer to valid struct switch containing this endpoint  *	   port ==> identifies the port on the switch this endpoint uses  *	   pgrp ==> NULL, or pointer to the valid struct port_grp holding  *		      the port in a t_switch.  *  *   type == PASSTHRU  *   link == pointer to valid struct link  *     ==> This endpoint is a switch port connected via a link to either  *	     another switch or a CA/router.  Thus:  *	   n_id ==> identifies the node GUID used to talk to the switch  *		      containing this endpoint - since each switch is assumed  *		      to have only one in-band communication port, this is a  *		      convenient unique name for the switch itself.  *	   sw   ==> pointer to valid struct switch containing this endpoint,  *		      or NULL, in the case of a fabric link that has been  *		      disconnected after being transferred to a torus link.  *	   port ==> identifies the port on the switch this endpoint uses.  *		      Note that in the special case of the coordinate direction  *		      links, the port value is -1, as those links aren't  *		      really connected to anything.  *	   pgrp ==> NULL, or pointer to the valid struct port_grp holding  *		      the port in a t_switch.  */
end_comment

begin_enum
enum|enum
name|endpt_type
block|{
name|UNKNOWN
init|=
literal|0
block|,
name|SRCSINK
block|,
name|PASSTHRU
block|}
enum|;
end_enum

begin_struct_decl
struct_decl|struct
name|torus
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|t_switch
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|port_grp
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|endpoint
block|{
name|enum
name|endpt_type
name|type
decl_stmt|;
name|int
name|port
decl_stmt|;
name|guid_t
name|n_id
decl_stmt|;
comment|/* IBA node GUID */
name|void
modifier|*
name|sw
decl_stmt|;
comment|/* void* can point to either switch type */
name|struct
name|link
modifier|*
name|link
decl_stmt|;
name|struct
name|port_grp
modifier|*
name|pgrp
decl_stmt|;
name|void
modifier|*
name|tmp
decl_stmt|;
comment|/* 	 * Note: osm_port is only guaranteed to contain a valid pointer 	 * when the call stack contains torus_build_lfts() or 	 * osm_port_relink_endpoint(). 	 * 	 * Otherwise, the opensm core could have deleted an osm_port object 	 * without notifying us, invalidating the pointer we hold. 	 * 	 * When presented with a pointer to an osm_port_t, it is generally 	 * safe and required to cast osm_port_t:priv to struct endpoint, and 	 * check that the endpoint's osm_port is the same as the original 	 * osm_port_t pointer.  Failure to do so means that invalidated 	 * pointers will go undetected. 	 */
name|struct
name|osm_port
modifier|*
name|osm_port
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|link
block|{
name|struct
name|endpoint
name|end
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * A port group is a collection of endpoints on a switch that share certain  * characteristics.  All the endpoints in a port group must have the same  * type.  Furthermore, if that type is PASSTHRU, then the connected links:  *   1) are parallel to a given coordinate direction  *   2) share the same two switches as endpoints.  *  * Torus-2QoS uses one master spanning tree for multicast, of which every  * multicast group spanning tree is a subtree.  to_stree_root is a pointer  * to the next port_grp on the path to the master spanning tree root.  * to_stree_tip is a pointer to the next port_grp on the path to a master  * spanning tree branch tip.  *  * Each t_switch can have at most one port_grp with a non-NULL to_stree_root.  * Exactly one t_switch in the fabric will have all port_grp objects with  * to_stree_root NULL; it is the master spanning tree root.  *  * A t_switch with all port_grp objects where to_stree_tip is NULL is at a  * master spanning tree branch tip.  */
end_comment

begin_struct
struct|struct
name|port_grp
block|{
name|enum
name|endpt_type
name|type
decl_stmt|;
name|size_t
name|port_cnt
decl_stmt|;
comment|/* number of attached ports in group */
name|size_t
name|port_grp
decl_stmt|;
comment|/* what switch port_grp we're in */
name|unsigned
name|sw_dlid_cnt
decl_stmt|;
comment|/* switch dlids routed through this group */
name|unsigned
name|ca_dlid_cnt
decl_stmt|;
comment|/* CA dlids routed through this group */
name|struct
name|t_switch
modifier|*
name|sw
decl_stmt|;
comment|/* what switch we're attached to */
name|struct
name|port_grp
modifier|*
name|to_stree_root
decl_stmt|;
name|struct
name|port_grp
modifier|*
name|to_stree_tip
decl_stmt|;
name|struct
name|endpoint
modifier|*
modifier|*
name|port
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * A struct t_switch is used to represent a switch as placed in a torus.  *  * A t_switch used to build an N-dimensional torus will have 2N+1 port groups,  * used as follows, assuming 0<= d< N:  *   port_grp[2d]   => links leaving in negative direction for coordinate d  *   port_grp[2d+1] => links leaving in positive direction for coordinate d  *   port_grp[2N]   => endpoints local to switch; i.e., hosts on switch  *  * struct link objects referenced by a t_switch are assumed to be oriented:  * traversing a link from link.end[0] to link.end[1] is always in the positive  * coordinate direction.  */
end_comment

begin_struct
struct|struct
name|t_switch
block|{
name|guid_t
name|n_id
decl_stmt|;
comment|/* IBA node GUID */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|unsigned
name|port_cnt
decl_stmt|;
comment|/* including management port */
name|struct
name|torus
modifier|*
name|torus
decl_stmt|;
name|void
modifier|*
name|tmp
decl_stmt|;
comment|/* 	 * Note: osm_switch is only guaranteed to contain a valid pointer 	 * when the call stack contains torus_build_lfts(). 	 * 	 * Otherwise, the opensm core could have deleted an osm_switch object 	 * without notifying us, invalidating the pointer we hold. 	 * 	 * When presented with a pointer to an osm_switch_t, it is generally 	 * safe and required to cast osm_switch_t:priv to struct t_switch, and 	 * check that the switch's osm_switch is the same as the original 	 * osm_switch_t pointer.  Failure to do so means that invalidated 	 * pointers will go undetected. 	 */
name|struct
name|osm_switch
modifier|*
name|osm_switch
decl_stmt|;
name|struct
name|port_grp
name|ptgrp
index|[
name|SWITCH_MAX_PORTGRPS
index|]
decl_stmt|;
name|struct
name|endpoint
modifier|*
modifier|*
name|port
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * We'd like to be able to discover the torus topology in a pile of switch  * links if we can.  We'll use a struct f_switch to store raw topology for a  * fabric description, then contruct the torus topology from struct t_switch  * objects as we process the fabric and recover it.  */
end_comment

begin_struct
struct|struct
name|f_switch
block|{
name|guid_t
name|n_id
decl_stmt|;
comment|/* IBA node GUID */
name|unsigned
name|port_cnt
decl_stmt|;
comment|/* including management port */
name|void
modifier|*
name|tmp
decl_stmt|;
comment|/* 	 * Same rules apply here as for a struct t_switch member osm_switch. 	 */
name|struct
name|osm_switch
modifier|*
name|osm_switch
decl_stmt|;
name|struct
name|endpoint
modifier|*
modifier|*
name|port
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|fabric
block|{
name|osm_opensm_t
modifier|*
name|osm
decl_stmt|;
name|unsigned
name|ca_cnt
decl_stmt|;
name|unsigned
name|link_cnt
decl_stmt|;
name|unsigned
name|switch_cnt
decl_stmt|;
name|unsigned
name|link_cnt_max
decl_stmt|;
name|unsigned
name|switch_cnt_max
decl_stmt|;
name|struct
name|link
modifier|*
modifier|*
name|link
decl_stmt|;
name|struct
name|f_switch
modifier|*
modifier|*
name|sw
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|coord_dirs
block|{
comment|/* 	 * These links define the coordinate directions for the torus. 	 * They are duplicates of links connected to switches.  Each of 	 * these links must connect to a common switch. 	 * 	 * In the event that a failed switch was specified as one of these 	 * link endpoints, our algorithm would not be able to find the 	 * torus in the fabric.  So, we'll allow multiple instances of 	 * this in the config file to allow improved resiliency. 	 */
name|struct
name|link
name|xm_link
decl_stmt|,
name|ym_link
decl_stmt|,
name|zm_link
decl_stmt|;
name|struct
name|link
name|xp_link
decl_stmt|,
name|yp_link
decl_stmt|,
name|zp_link
decl_stmt|;
comment|/* 	 * A torus dimension has coordinate values 0, 1, ..., radix - 1. 	 * The dateline, where we need to change VLs to avoid credit loops, 	 * for a torus dimension is always between coordinate values 	 * radix - 1 and 0.  The following specify the dateline location 	 * relative to the coordinate links shared switch location. 	 * 	 * E.g. if the shared switch is at 0,0,0, the following are all 	 * zero; if the shared switch is at 1,1,1, the following are all 	 * -1, etc. 	 * 	 * Since our SL/VL assignment for a path depends on the position 	 * of the path endpoints relative to the torus datelines, we need 	 * this information to keep SL/VL assignment constant in the event 	 * one of the switches used to specify coordinate directions fails. 	 */
name|int
name|x_dateline
decl_stmt|,
name|y_dateline
decl_stmt|,
name|z_dateline
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|torus
block|{
name|osm_opensm_t
modifier|*
name|osm
decl_stmt|;
name|unsigned
name|ca_cnt
decl_stmt|;
name|unsigned
name|link_cnt
decl_stmt|;
name|unsigned
name|switch_cnt
decl_stmt|;
name|unsigned
name|seed_cnt
decl_stmt|,
name|seed_idx
decl_stmt|;
name|unsigned
name|x_sz
decl_stmt|,
name|y_sz
decl_stmt|,
name|z_sz
decl_stmt|;
name|unsigned
name|port_order
index|[
name|IB_NODE_NUM_PORTS_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|unsigned
name|sw_pool_sz
decl_stmt|;
name|unsigned
name|link_pool_sz
decl_stmt|;
name|unsigned
name|seed_sz
decl_stmt|;
name|unsigned
name|portgrp_sz
decl_stmt|;
comment|/* max ports for port groups in this torus */
name|struct
name|fabric
modifier|*
name|fabric
decl_stmt|;
name|struct
name|t_switch
modifier|*
modifier|*
name|sw_pool
decl_stmt|;
name|struct
name|link
modifier|*
name|link_pool
decl_stmt|;
name|struct
name|coord_dirs
modifier|*
name|seed
decl_stmt|;
name|struct
name|t_switch
modifier|*
modifier|*
modifier|*
modifier|*
name|sw
decl_stmt|;
name|struct
name|t_switch
modifier|*
name|master_stree_root
decl_stmt|;
name|unsigned
name|flags
decl_stmt|;
name|unsigned
name|max_changes
decl_stmt|;
name|int
name|debug
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Bits to use in torus.flags  */
end_comment

begin_define
define|#
directive|define
name|X_MESH
value|(1U<< 0)
end_define

begin_define
define|#
directive|define
name|Y_MESH
value|(1U<< 1)
end_define

begin_define
define|#
directive|define
name|Z_MESH
value|(1U<< 2)
end_define

begin_define
define|#
directive|define
name|MSG_DEADLOCK
value|(1U<< 29)
end_define

begin_define
define|#
directive|define
name|NOTIFY_CHANGES
value|(1U<< 30)
end_define

begin_define
define|#
directive|define
name|ALL_MESH
parameter_list|(
name|flags
parameter_list|)
define|\
value|((flags& (X_MESH | Y_MESH | Z_MESH)) == (X_MESH | Y_MESH | Z_MESH))
end_define

begin_struct
struct|struct
name|torus_context
block|{
name|osm_opensm_t
modifier|*
name|osm
decl_stmt|;
name|struct
name|torus
modifier|*
name|torus
decl_stmt|;
name|struct
name|fabric
name|fabric
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|teardown_fabric
parameter_list|(
name|struct
name|fabric
modifier|*
name|f
parameter_list|)
block|{
name|unsigned
name|l
decl_stmt|,
name|p
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|endpoint
modifier|*
name|port
decl_stmt|;
name|struct
name|f_switch
modifier|*
name|sw
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
return|return;
if|if
condition|(
name|f
operator|->
name|sw
condition|)
block|{
comment|/* 		 * Need to free switches, and also find/free the endpoints 		 * we allocated for switch management ports. 		 */
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|f
operator|->
name|switch_cnt
condition|;
name|s
operator|++
control|)
block|{
name|sw
operator|=
name|f
operator|->
name|sw
index|[
name|s
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|sw
condition|)
continue|continue;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|sw
operator|->
name|port_cnt
condition|;
name|p
operator|++
control|)
block|{
name|port
operator|=
name|sw
operator|->
name|port
index|[
name|p
index|]
expr_stmt|;
if|if
condition|(
name|port
operator|&&
operator|!
name|port
operator|->
name|link
condition|)
name|free
argument_list|(
name|port
argument_list|)
expr_stmt|;
comment|/* management port */
block|}
name|free
argument_list|(
name|sw
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|f
operator|->
name|sw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|->
name|link
condition|)
block|{
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|f
operator|->
name|link_cnt
condition|;
name|l
operator|++
control|)
if|if
condition|(
name|f
operator|->
name|link
index|[
name|l
index|]
condition|)
name|free
argument_list|(
name|f
operator|->
name|link
index|[
name|l
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|f
operator|->
name|link
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|teardown_torus
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|)
block|{
name|unsigned
name|p
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|endpoint
modifier|*
name|port
decl_stmt|;
name|struct
name|t_switch
modifier|*
name|sw
decl_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
return|return;
if|if
condition|(
name|t
operator|->
name|sw_pool
condition|)
block|{
comment|/* 		 * Need to free switches, and also find/free the endpoints 		 * we allocated for switch management ports. 		 */
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|t
operator|->
name|switch_cnt
condition|;
name|s
operator|++
control|)
block|{
name|sw
operator|=
name|t
operator|->
name|sw_pool
index|[
name|s
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|sw
condition|)
continue|continue;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|sw
operator|->
name|port_cnt
condition|;
name|p
operator|++
control|)
block|{
name|port
operator|=
name|sw
operator|->
name|port
index|[
name|p
index|]
expr_stmt|;
if|if
condition|(
name|port
operator|&&
operator|!
name|port
operator|->
name|link
condition|)
name|free
argument_list|(
name|port
argument_list|)
expr_stmt|;
comment|/* management port */
block|}
name|free
argument_list|(
name|sw
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|t
operator|->
name|sw_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|link_pool
condition|)
name|free
argument_list|(
name|t
operator|->
name|link_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|sw
condition|)
name|free
argument_list|(
name|t
operator|->
name|sw
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|seed
condition|)
name|free
argument_list|(
name|t
operator|->
name|seed
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|torus_context
modifier|*
name|torus_context_create
parameter_list|(
name|osm_opensm_t
modifier|*
name|osm
parameter_list|)
block|{
name|struct
name|torus_context
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
condition|)
name|ctx
operator|->
name|osm
operator|=
name|osm
expr_stmt|;
else|else
name|OSM_LOG
argument_list|(
operator|&
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E01: calloc: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ctx
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|torus_context_delete
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|torus_context
modifier|*
name|ctx
init|=
name|context
decl_stmt|;
name|teardown_fabric
argument_list|(
operator|&
name|ctx
operator|->
name|fabric
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|torus
condition|)
name|teardown_torus
argument_list|(
name|ctx
operator|->
name|torus
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|grow_seed_array
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|new_seeds
parameter_list|)
block|{
name|unsigned
name|cnt
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|cnt
operator|=
name|t
operator|->
name|seed_cnt
operator|+
name|new_seeds
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
name|t
operator|->
name|seed_sz
condition|)
block|{
name|cnt
operator|+=
literal|2
operator|+
name|cnt
operator|/
literal|2
expr_stmt|;
name|ptr
operator|=
name|realloc
argument_list|(
name|t
operator|->
name|seed
argument_list|,
name|cnt
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|t
operator|->
name|seed
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
return|return
name|false
return|;
name|t
operator|->
name|seed
operator|=
name|ptr
expr_stmt|;
name|t
operator|->
name|seed_sz
operator|=
name|cnt
expr_stmt|;
name|memset
argument_list|(
operator|&
name|t
operator|->
name|seed
index|[
name|t
operator|->
name|seed_cnt
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|cnt
operator|-
name|t
operator|->
name|seed_cnt
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|t
operator|->
name|seed
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|f_switch
modifier|*
name|find_f_sw
parameter_list|(
name|struct
name|fabric
modifier|*
name|f
parameter_list|,
name|guid_t
name|sw_guid
parameter_list|)
block|{
name|unsigned
name|s
decl_stmt|;
name|struct
name|f_switch
modifier|*
name|sw
decl_stmt|;
if|if
condition|(
name|f
operator|->
name|sw
condition|)
block|{
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|f
operator|->
name|switch_cnt
condition|;
name|s
operator|++
control|)
block|{
name|sw
operator|=
name|f
operator|->
name|sw
index|[
name|s
index|]
expr_stmt|;
if|if
condition|(
name|sw
operator|->
name|n_id
operator|==
name|sw_guid
condition|)
return|return
name|sw
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|link
modifier|*
name|find_f_link
parameter_list|(
name|struct
name|fabric
modifier|*
name|f
parameter_list|,
name|guid_t
name|guid0
parameter_list|,
name|int
name|port0
parameter_list|,
name|guid_t
name|guid1
parameter_list|,
name|int
name|port1
parameter_list|)
block|{
name|unsigned
name|l
decl_stmt|;
name|struct
name|link
modifier|*
name|link
decl_stmt|;
if|if
condition|(
name|f
operator|->
name|link
condition|)
block|{
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|f
operator|->
name|link_cnt
condition|;
name|l
operator|++
control|)
block|{
name|link
operator|=
name|f
operator|->
name|link
index|[
name|l
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|link
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|==
name|guid0
operator|&&
name|link
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|==
name|port0
operator|&&
name|link
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|n_id
operator|==
name|guid1
operator|&&
name|link
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|port
operator|==
name|port1
operator|)
operator|||
operator|(
name|link
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|==
name|guid1
operator|&&
name|link
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|==
name|port1
operator|&&
name|link
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|n_id
operator|==
name|guid0
operator|&&
name|link
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|port
operator|==
name|port0
operator|)
condition|)
return|return
name|link
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|f_switch
modifier|*
name|alloc_fswitch
parameter_list|(
name|struct
name|fabric
modifier|*
name|f
parameter_list|,
name|guid_t
name|sw_id
parameter_list|,
name|unsigned
name|port_cnt
parameter_list|)
block|{
name|size_t
name|new_sw_sz
decl_stmt|;
name|unsigned
name|cnt_max
decl_stmt|;
name|struct
name|f_switch
modifier|*
name|sw
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|f
operator|->
name|switch_cnt
operator|>=
name|f
operator|->
name|switch_cnt_max
condition|)
block|{
name|cnt_max
operator|=
literal|16
operator|+
literal|5
operator|*
name|f
operator|->
name|switch_cnt_max
operator|/
literal|4
expr_stmt|;
name|ptr
operator|=
name|realloc
argument_list|(
name|f
operator|->
name|sw
argument_list|,
name|cnt_max
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|f
operator|->
name|sw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|f
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E02: realloc: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|f
operator|->
name|sw
operator|=
name|ptr
expr_stmt|;
name|f
operator|->
name|switch_cnt_max
operator|=
name|cnt_max
expr_stmt|;
name|memset
argument_list|(
operator|&
name|f
operator|->
name|sw
index|[
name|f
operator|->
name|switch_cnt
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|f
operator|->
name|switch_cnt_max
operator|-
name|f
operator|->
name|switch_cnt
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|f
operator|->
name|sw
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|new_sw_sz
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sw
argument_list|)
operator|+
name|port_cnt
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sw
operator|->
name|port
argument_list|)
expr_stmt|;
name|sw
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|new_sw_sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sw
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|f
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E03: calloc: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sw
operator|->
name|port
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|sw
operator|+
literal|1
operator|)
expr_stmt|;
name|sw
operator|->
name|n_id
operator|=
name|sw_id
expr_stmt|;
name|sw
operator|->
name|port_cnt
operator|=
name|port_cnt
expr_stmt|;
name|f
operator|->
name|sw
index|[
name|f
operator|->
name|switch_cnt
operator|++
index|]
operator|=
name|sw
expr_stmt|;
name|out
label|:
return|return
name|sw
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|link
modifier|*
name|alloc_flink
parameter_list|(
name|struct
name|fabric
modifier|*
name|f
parameter_list|)
block|{
name|unsigned
name|cnt_max
decl_stmt|;
name|struct
name|link
modifier|*
name|l
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|f
operator|->
name|link_cnt
operator|>=
name|f
operator|->
name|link_cnt_max
condition|)
block|{
name|cnt_max
operator|=
literal|16
operator|+
literal|5
operator|*
name|f
operator|->
name|link_cnt_max
operator|/
literal|4
expr_stmt|;
name|ptr
operator|=
name|realloc
argument_list|(
name|f
operator|->
name|link
argument_list|,
name|cnt_max
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|f
operator|->
name|link
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|f
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E04: realloc: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|f
operator|->
name|link
operator|=
name|ptr
expr_stmt|;
name|f
operator|->
name|link_cnt_max
operator|=
name|cnt_max
expr_stmt|;
name|memset
argument_list|(
operator|&
name|f
operator|->
name|link
index|[
name|f
operator|->
name|link_cnt
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|f
operator|->
name|link_cnt_max
operator|-
name|f
operator|->
name|link_cnt
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|f
operator|->
name|link
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|l
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|l
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|f
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E05: calloc: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|f
operator|->
name|link
index|[
name|f
operator|->
name|link_cnt
operator|++
index|]
operator|=
name|l
expr_stmt|;
name|out
label|:
return|return
name|l
return|;
block|}
end_function

begin_comment
comment|/*  * Caller must ensure osm_port points to a valid port which contains  * a valid osm_physp_t pointer for port 0, the switch management port.  */
end_comment

begin_function
specifier|static
name|bool
name|build_sw_endpoint
parameter_list|(
name|struct
name|fabric
modifier|*
name|f
parameter_list|,
name|osm_port_t
modifier|*
name|osm_port
parameter_list|)
block|{
name|int
name|sw_port
decl_stmt|;
name|guid_t
name|sw_guid
decl_stmt|;
name|struct
name|osm_switch
modifier|*
name|osm_sw
decl_stmt|;
name|struct
name|f_switch
modifier|*
name|sw
decl_stmt|;
name|struct
name|endpoint
modifier|*
name|ep
decl_stmt|;
name|bool
name|success
init|=
name|false
decl_stmt|;
name|sw_port
operator|=
name|osm_physp_get_port_num
argument_list|(
name|osm_port
operator|->
name|p_physp
argument_list|)
expr_stmt|;
name|sw_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|osm_port
operator|->
name|p_node
argument_list|)
expr_stmt|;
name|osm_sw
operator|=
name|osm_port
operator|->
name|p_node
operator|->
name|sw
expr_stmt|;
comment|/* 	 * The switch must already exist. 	 */
name|sw
operator|=
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|sw_guid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sw
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|f
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E06: missing switch w/GUID 0x%04"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|sw_guid
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * The endpoint may already exist. 	 */
if|if
condition|(
name|sw
operator|->
name|port
index|[
name|sw_port
index|]
condition|)
block|{
if|if
condition|(
name|sw
operator|->
name|port
index|[
name|sw_port
index|]
operator|->
name|n_id
operator|==
name|sw_guid
condition|)
block|{
name|ep
operator|=
name|sw
operator|->
name|port
index|[
name|sw_port
index|]
expr_stmt|;
goto|goto
name|success
goto|;
block|}
else|else
name|OSM_LOG
argument_list|(
operator|&
name|f
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E07: switch port %d has id "
literal|"0x%04"
name|PRIx64
literal|", expected 0x%04"
name|PRIx64
literal|"\n"
argument_list|,
name|sw_port
argument_list|,
name|cl_ntoh64
argument_list|(
name|sw
operator|->
name|port
index|[
name|sw_port
index|]
operator|->
name|n_id
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|sw_guid
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ep
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ep
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|f
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E08: allocating endpoint: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ep
operator|->
name|type
operator|=
name|SRCSINK
expr_stmt|;
name|ep
operator|->
name|port
operator|=
name|sw_port
expr_stmt|;
name|ep
operator|->
name|n_id
operator|=
name|sw_guid
expr_stmt|;
name|ep
operator|->
name|link
operator|=
name|NULL
expr_stmt|;
name|ep
operator|->
name|sw
operator|=
name|sw
expr_stmt|;
name|sw
operator|->
name|port
index|[
name|sw_port
index|]
operator|=
name|ep
expr_stmt|;
name|success
label|:
comment|/* 	 * Fabric objects are temporary, so don't set osm_sw/osm_port priv 	 * pointers using them.  Wait until torus objects get constructed. 	 */
name|sw
operator|->
name|osm_switch
operator|=
name|osm_sw
expr_stmt|;
name|ep
operator|->
name|osm_port
operator|=
name|osm_port
expr_stmt|;
name|success
operator|=
name|true
expr_stmt|;
name|out
label|:
return|return
name|success
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|build_ca_link
parameter_list|(
name|struct
name|fabric
modifier|*
name|f
parameter_list|,
name|osm_port_t
modifier|*
name|osm_port_ca
parameter_list|,
name|guid_t
name|sw_guid
parameter_list|,
name|int
name|sw_port
parameter_list|)
block|{
name|int
name|ca_port
decl_stmt|;
name|guid_t
name|ca_guid
decl_stmt|;
name|struct
name|link
modifier|*
name|l
decl_stmt|;
name|struct
name|f_switch
modifier|*
name|sw
decl_stmt|;
name|bool
name|success
init|=
name|false
decl_stmt|;
name|ca_port
operator|=
name|osm_physp_get_port_num
argument_list|(
name|osm_port_ca
operator|->
name|p_physp
argument_list|)
expr_stmt|;
name|ca_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|osm_port_ca
operator|->
name|p_node
argument_list|)
expr_stmt|;
comment|/* 	 * The link may already exist. 	 */
name|l
operator|=
name|find_f_link
argument_list|(
name|f
argument_list|,
name|sw_guid
argument_list|,
name|sw_port
argument_list|,
name|ca_guid
argument_list|,
name|ca_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
condition|)
block|{
name|success
operator|=
name|true
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * The switch must already exist. 	 */
name|sw
operator|=
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|sw_guid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sw
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|f
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E09: missing switch w/GUID 0x%04"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|sw_guid
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|l
operator|=
name|alloc_flink
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|l
condition|)
goto|goto
name|out
goto|;
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|PASSTHRU
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|=
name|sw_port
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|=
name|sw_guid
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|sw
operator|=
name|sw
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|link
operator|=
name|l
expr_stmt|;
name|sw
operator|->
name|port
index|[
name|sw_port
index|]
operator|=
operator|&
name|l
operator|->
name|end
index|[
literal|0
index|]
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|SRCSINK
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|port
operator|=
name|ca_port
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|n_id
operator|=
name|ca_guid
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|sw
operator|=
name|NULL
expr_stmt|;
comment|/* Correct for a CA */
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|link
operator|=
name|l
expr_stmt|;
comment|/* 	 * Fabric objects are temporary, so don't set osm_sw/osm_port priv 	 * pointers using them.  Wait until torus objects get constructed. 	 */
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|osm_port
operator|=
name|osm_port_ca
expr_stmt|;
operator|++
name|f
operator|->
name|ca_cnt
expr_stmt|;
name|success
operator|=
name|true
expr_stmt|;
name|out
label|:
return|return
name|success
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|build_link
parameter_list|(
name|struct
name|fabric
modifier|*
name|f
parameter_list|,
name|guid_t
name|sw_guid0
parameter_list|,
name|int
name|sw_port0
parameter_list|,
name|guid_t
name|sw_guid1
parameter_list|,
name|int
name|sw_port1
parameter_list|)
block|{
name|struct
name|link
modifier|*
name|l
decl_stmt|;
name|struct
name|f_switch
modifier|*
name|sw0
decl_stmt|,
modifier|*
name|sw1
decl_stmt|;
name|bool
name|success
init|=
name|false
decl_stmt|;
comment|/* 	 * The link may already exist. 	 */
name|l
operator|=
name|find_f_link
argument_list|(
name|f
argument_list|,
name|sw_guid0
argument_list|,
name|sw_port0
argument_list|,
name|sw_guid1
argument_list|,
name|sw_port1
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
condition|)
block|{
name|success
operator|=
name|true
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * The switches must already exist. 	 */
name|sw0
operator|=
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|sw_guid0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sw0
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|f
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E0A: missing switch w/GUID 0x%04"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|sw_guid0
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sw1
operator|=
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|sw_guid1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sw1
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|f
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E0B: missing switch w/GUID 0x%04"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|sw_guid1
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|l
operator|=
name|alloc_flink
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|l
condition|)
goto|goto
name|out
goto|;
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|PASSTHRU
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|=
name|sw_port0
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|=
name|sw_guid0
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|sw
operator|=
name|sw0
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|link
operator|=
name|l
expr_stmt|;
name|sw0
operator|->
name|port
index|[
name|sw_port0
index|]
operator|=
operator|&
name|l
operator|->
name|end
index|[
literal|0
index|]
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|PASSTHRU
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|port
operator|=
name|sw_port1
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|n_id
operator|=
name|sw_guid1
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|sw
operator|=
name|sw1
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|link
operator|=
name|l
expr_stmt|;
name|sw1
operator|->
name|port
index|[
name|sw_port1
index|]
operator|=
operator|&
name|l
operator|->
name|end
index|[
literal|1
index|]
expr_stmt|;
name|success
operator|=
name|true
expr_stmt|;
name|out
label|:
return|return
name|success
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|parse_size
parameter_list|(
name|unsigned
modifier|*
name|tsz
parameter_list|,
name|unsigned
modifier|*
name|tflags
parameter_list|,
name|unsigned
name|mask
parameter_list|,
specifier|const
name|char
modifier|*
name|parse_sep
parameter_list|)
block|{
name|char
modifier|*
name|val
decl_stmt|,
modifier|*
name|nextchar
decl_stmt|;
name|val
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
name|parse_sep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
return|return
name|false
return|;
operator|*
name|tsz
operator|=
name|strtoul
argument_list|(
name|val
argument_list|,
operator|&
name|nextchar
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tsz
condition|)
block|{
if|if
condition|(
operator|*
name|nextchar
operator|==
literal|'t'
operator|||
operator|*
name|nextchar
operator|==
literal|'T'
condition|)
operator|*
name|tflags
operator|&=
operator|~
name|mask
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|nextchar
operator|==
literal|'m'
operator|||
operator|*
name|nextchar
operator|==
literal|'M'
condition|)
operator|*
name|tflags
operator||=
name|mask
expr_stmt|;
comment|/* 		 * A torus of radix two is also a mesh of radix two 		 * with multiple links between switches in that direction. 		 * 		 * Make it so always, otherwise the failure case routing 		 * logic gets confused. 		 */
if|if
condition|(
operator|*
name|tsz
operator|==
literal|2
condition|)
operator|*
name|tflags
operator||=
name|mask
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|parse_torus
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|parse_sep
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|cnt
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|bool
name|success
init|=
name|false
decl_stmt|;
comment|/* 	 * There can be only one.  Ignore the imposters. 	 */
if|if
condition|(
name|t
operator|->
name|sw_pool
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|parse_size
argument_list|(
operator|&
name|t
operator|->
name|x_sz
argument_list|,
operator|&
name|t
operator|->
name|flags
argument_list|,
name|X_MESH
argument_list|,
name|parse_sep
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|parse_size
argument_list|(
operator|&
name|t
operator|->
name|y_sz
argument_list|,
operator|&
name|t
operator|->
name|flags
argument_list|,
name|Y_MESH
argument_list|,
name|parse_sep
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|parse_size
argument_list|(
operator|&
name|t
operator|->
name|z_sz
argument_list|,
operator|&
name|t
operator|->
name|flags
argument_list|,
name|Z_MESH
argument_list|,
name|parse_sep
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Set up a linear array of switch pointers big enough to hold 	 * all expected switches. 	 */
name|t
operator|->
name|sw_pool_sz
operator|=
name|t
operator|->
name|x_sz
operator|*
name|t
operator|->
name|y_sz
operator|*
name|t
operator|->
name|z_sz
expr_stmt|;
name|t
operator|->
name|sw_pool
operator|=
name|calloc
argument_list|(
name|t
operator|->
name|sw_pool_sz
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|t
operator|->
name|sw_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|sw_pool
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E0C: Torus switch array calloc: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Set things up so that t->sw[i][j][k] can point to the i,j,k switch. 	 */
name|cnt
operator|=
name|t
operator|->
name|x_sz
operator|*
operator|(
literal|1
operator|+
name|t
operator|->
name|y_sz
operator|*
operator|(
literal|1
operator|+
name|t
operator|->
name|z_sz
operator|)
operator|)
expr_stmt|;
name|t
operator|->
name|sw
operator|=
name|malloc
argument_list|(
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|sw
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E0D: Torus switch array malloc: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ptr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|t
operator|->
name|sw
operator|)
expr_stmt|;
name|ptr
operator|+=
name|t
operator|->
name|x_sz
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|x_sz
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|->
name|sw
index|[
name|i
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
name|t
operator|->
name|y_sz
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|x_sz
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|t
operator|->
name|y_sz
condition|;
name|j
operator|++
control|)
block|{
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
name|t
operator|->
name|z_sz
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|x_sz
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|t
operator|->
name|y_sz
condition|;
name|j
operator|++
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|t
operator|->
name|z_sz
condition|;
name|k
operator|++
control|)
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|=
name|NULL
expr_stmt|;
name|success
operator|=
name|true
expr_stmt|;
name|out
label|:
return|return
name|success
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|parse_unsigned
parameter_list|(
name|unsigned
modifier|*
name|result
parameter_list|,
specifier|const
name|char
modifier|*
name|parse_sep
parameter_list|)
block|{
name|char
modifier|*
name|val
decl_stmt|,
modifier|*
name|nextchar
decl_stmt|;
name|val
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
name|parse_sep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
return|return
name|false
return|;
operator|*
name|result
operator|=
name|strtoul
argument_list|(
name|val
argument_list|,
operator|&
name|nextchar
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|parse_port_order
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|parse_sep
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|t
operator|->
name|port_order
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|parse_unsigned
argument_list|(
operator|&
operator|(
name|t
operator|->
name|port_order
index|[
name|i
index|]
operator|)
argument_list|,
name|parse_sep
argument_list|)
condition|)
break|break;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|t
operator|->
name|port_order
index|[
name|j
index|]
operator|==
name|t
operator|->
name|port_order
index|[
name|i
index|]
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Ignored duplicate port %u in"
literal|" port_order parsing\n"
argument_list|,
name|t
operator|->
name|port_order
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
comment|/* Ignore duplicate port number */
break|break;
block|}
block|}
block|}
name|n
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ARRAY_SIZE
argument_list|(
name|t
operator|->
name|port_order
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|i
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|t
operator|->
name|port_order
index|[
name|k
index|]
operator|==
name|j
condition|)
break|break;
if|if
condition|(
name|k
operator|>=
name|i
condition|)
name|t
operator|->
name|port_order
index|[
name|n
operator|++
index|]
operator|=
name|j
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|parse_guid
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|guid_t
modifier|*
name|guid
parameter_list|,
specifier|const
name|char
modifier|*
name|parse_sep
parameter_list|)
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|bool
name|success
init|=
name|false
decl_stmt|;
name|val
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
name|parse_sep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
goto|goto
name|out
goto|;
operator|*
name|guid
operator|=
name|strtoull
argument_list|(
name|val
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|guid
operator|=
name|cl_hton64
argument_list|(
operator|*
name|guid
argument_list|)
expr_stmt|;
name|success
operator|=
name|true
expr_stmt|;
name|out
label|:
return|return
name|success
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|parse_dir_link
parameter_list|(
name|int
name|c_dir
parameter_list|,
name|struct
name|torus
modifier|*
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|parse_sep
parameter_list|)
block|{
name|guid_t
name|sw_guid0
decl_stmt|,
name|sw_guid1
decl_stmt|;
name|struct
name|link
modifier|*
name|l
decl_stmt|;
name|bool
name|success
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|!
name|parse_guid
argument_list|(
name|t
argument_list|,
operator|&
name|sw_guid0
argument_list|,
name|parse_sep
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|parse_guid
argument_list|(
name|t
argument_list|,
operator|&
name|sw_guid1
argument_list|,
name|parse_sep
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|success
operator|=
name|true
expr_stmt|;
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|c_dir
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|l
operator|=
operator|&
name|t
operator|->
name|seed
index|[
name|t
operator|->
name|seed_cnt
operator|-
literal|1
index|]
operator|.
name|xm_link
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|l
operator|=
operator|&
name|t
operator|->
name|seed
index|[
name|t
operator|->
name|seed_cnt
operator|-
literal|1
index|]
operator|.
name|xp_link
expr_stmt|;
break|break;
case|case
operator|-
literal|2
case|:
name|l
operator|=
operator|&
name|t
operator|->
name|seed
index|[
name|t
operator|->
name|seed_cnt
operator|-
literal|1
index|]
operator|.
name|ym_link
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|l
operator|=
operator|&
name|t
operator|->
name|seed
index|[
name|t
operator|->
name|seed_cnt
operator|-
literal|1
index|]
operator|.
name|yp_link
expr_stmt|;
break|break;
case|case
operator|-
literal|3
case|:
name|l
operator|=
operator|&
name|t
operator|->
name|seed
index|[
name|t
operator|->
name|seed_cnt
operator|-
literal|1
index|]
operator|.
name|zm_link
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|l
operator|=
operator|&
name|t
operator|->
name|seed
index|[
name|t
operator|->
name|seed_cnt
operator|-
literal|1
index|]
operator|.
name|zp_link
expr_stmt|;
break|break;
default|default:
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E0E: unknown link direction %d\n"
argument_list|,
name|c_dir
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|PASSTHRU
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We don't really connect. */
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|=
name|sw_guid0
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|sw
operator|=
name|NULL
expr_stmt|;
comment|/* Fix this up later. */
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|link
operator|=
name|NULL
expr_stmt|;
comment|/* Fix this up later. */
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|PASSTHRU
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|port
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We don't really connect. */
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|n_id
operator|=
name|sw_guid1
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|sw
operator|=
name|NULL
expr_stmt|;
comment|/* Fix this up later. */
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|link
operator|=
name|NULL
expr_stmt|;
comment|/* Fix this up later. */
name|success
operator|=
name|true
expr_stmt|;
name|out
label|:
return|return
name|success
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|parse_dir_dateline
parameter_list|(
name|int
name|c_dir
parameter_list|,
name|struct
name|torus
modifier|*
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|parse_sep
parameter_list|)
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|int
modifier|*
name|dl
decl_stmt|,
name|max_dl
decl_stmt|;
name|bool
name|success
init|=
name|false
decl_stmt|;
name|val
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
name|parse_sep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|success
operator|=
name|true
expr_stmt|;
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|c_dir
condition|)
block|{
case|case
literal|1
case|:
name|dl
operator|=
operator|&
name|t
operator|->
name|seed
index|[
name|t
operator|->
name|seed_cnt
operator|-
literal|1
index|]
operator|.
name|x_dateline
expr_stmt|;
name|max_dl
operator|=
name|t
operator|->
name|x_sz
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|dl
operator|=
operator|&
name|t
operator|->
name|seed
index|[
name|t
operator|->
name|seed_cnt
operator|-
literal|1
index|]
operator|.
name|y_dateline
expr_stmt|;
name|max_dl
operator|=
name|t
operator|->
name|y_sz
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|dl
operator|=
operator|&
name|t
operator|->
name|seed
index|[
name|t
operator|->
name|seed_cnt
operator|-
literal|1
index|]
operator|.
name|z_dateline
expr_stmt|;
name|max_dl
operator|=
name|t
operator|->
name|z_sz
expr_stmt|;
break|break;
default|default:
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E0F: unknown dateline direction %d\n"
argument_list|,
name|c_dir
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|*
name|dl
operator|=
name|strtol
argument_list|(
name|val
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|dl
operator|<
literal|0
operator|&&
operator|*
name|dl
operator|<=
operator|-
name|max_dl
operator|)
operator|||
operator|*
name|dl
operator|>=
name|max_dl
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E10: dateline value for coordinate direction %d "
literal|"must be %d< dl< %d\n"
argument_list|,
name|c_dir
argument_list|,
operator|-
name|max_dl
argument_list|,
name|max_dl
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|true
expr_stmt|;
name|out
label|:
return|return
name|success
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|parse_config
parameter_list|(
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
name|struct
name|fabric
modifier|*
name|f
parameter_list|,
name|struct
name|torus
modifier|*
name|t
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|char
modifier|*
name|keyword
decl_stmt|;
name|char
modifier|*
name|line_buf
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|parse_sep
init|=
literal|" \n\t\015"
decl_stmt|;
name|size_t
name|line_buf_sz
init|=
literal|0
decl_stmt|;
name|size_t
name|line_cntr
init|=
literal|0
decl_stmt|;
name|ssize_t
name|llen
decl_stmt|;
name|bool
name|kw_success
decl_stmt|,
name|success
init|=
name|true
decl_stmt|;
if|if
condition|(
operator|!
name|grow_seed_array
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|t
operator|->
name|port_order
argument_list|)
condition|;
name|i
operator|++
control|)
name|t
operator|->
name|port_order
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|fn
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E11: Opening %s: %s\n"
argument_list|,
name|fn
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|t
operator|->
name|flags
operator||=
name|NOTIFY_CHANGES
expr_stmt|;
name|t
operator|->
name|portgrp_sz
operator|=
name|PORTGRP_MAX_PORTS
expr_stmt|;
name|t
operator|->
name|max_changes
operator|=
name|DEFAULT_MAX_CHANGES
expr_stmt|;
name|next_line
label|:
name|llen
operator|=
name|getline
argument_list|(
operator|&
name|line_buf
argument_list|,
operator|&
name|line_buf_sz
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|llen
operator|<
literal|0
condition|)
goto|goto
name|out
goto|;
operator|++
name|line_cntr
expr_stmt|;
name|keyword
operator|=
name|strtok
argument_list|(
name|line_buf
argument_list|,
name|parse_sep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|keyword
condition|)
goto|goto
name|next_line
goto|;
if|if
condition|(
name|strcmp
argument_list|(
literal|"torus"
argument_list|,
name|keyword
argument_list|)
operator|==
literal|0
condition|)
block|{
name|kw_success
operator|=
name|parse_torus
argument_list|(
name|t
argument_list|,
name|parse_sep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"mesh"
argument_list|,
name|keyword
argument_list|)
operator|==
literal|0
condition|)
block|{
name|t
operator|->
name|flags
operator||=
name|X_MESH
operator||
name|Y_MESH
operator||
name|Z_MESH
expr_stmt|;
name|kw_success
operator|=
name|parse_torus
argument_list|(
name|t
argument_list|,
name|parse_sep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"port_order"
argument_list|,
name|keyword
argument_list|)
operator|==
literal|0
condition|)
block|{
name|kw_success
operator|=
name|parse_port_order
argument_list|(
name|t
argument_list|,
name|parse_sep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"next_seed"
argument_list|,
name|keyword
argument_list|)
operator|==
literal|0
condition|)
block|{
name|kw_success
operator|=
name|grow_seed_array
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|t
operator|->
name|seed_cnt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"portgroup_max_ports"
argument_list|,
name|keyword
argument_list|)
operator|==
literal|0
condition|)
block|{
name|kw_success
operator|=
name|parse_unsigned
argument_list|(
operator|&
name|t
operator|->
name|portgrp_sz
argument_list|,
name|parse_sep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"xp_link"
argument_list|,
name|keyword
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|t
operator|->
name|seed_cnt
condition|)
name|t
operator|->
name|seed_cnt
operator|++
expr_stmt|;
name|kw_success
operator|=
name|parse_dir_link
argument_list|(
literal|1
argument_list|,
name|t
argument_list|,
name|parse_sep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"xm_link"
argument_list|,
name|keyword
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|t
operator|->
name|seed_cnt
condition|)
name|t
operator|->
name|seed_cnt
operator|++
expr_stmt|;
name|kw_success
operator|=
name|parse_dir_link
argument_list|(
operator|-
literal|1
argument_list|,
name|t
argument_list|,
name|parse_sep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"x_dateline"
argument_list|,
name|keyword
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|t
operator|->
name|seed_cnt
condition|)
name|t
operator|->
name|seed_cnt
operator|++
expr_stmt|;
name|kw_success
operator|=
name|parse_dir_dateline
argument_list|(
literal|1
argument_list|,
name|t
argument_list|,
name|parse_sep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"yp_link"
argument_list|,
name|keyword
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|t
operator|->
name|seed_cnt
condition|)
name|t
operator|->
name|seed_cnt
operator|++
expr_stmt|;
name|kw_success
operator|=
name|parse_dir_link
argument_list|(
literal|2
argument_list|,
name|t
argument_list|,
name|parse_sep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"ym_link"
argument_list|,
name|keyword
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|t
operator|->
name|seed_cnt
condition|)
name|t
operator|->
name|seed_cnt
operator|++
expr_stmt|;
name|kw_success
operator|=
name|parse_dir_link
argument_list|(
operator|-
literal|2
argument_list|,
name|t
argument_list|,
name|parse_sep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"y_dateline"
argument_list|,
name|keyword
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|t
operator|->
name|seed_cnt
condition|)
name|t
operator|->
name|seed_cnt
operator|++
expr_stmt|;
name|kw_success
operator|=
name|parse_dir_dateline
argument_list|(
literal|2
argument_list|,
name|t
argument_list|,
name|parse_sep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"zp_link"
argument_list|,
name|keyword
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|t
operator|->
name|seed_cnt
condition|)
name|t
operator|->
name|seed_cnt
operator|++
expr_stmt|;
name|kw_success
operator|=
name|parse_dir_link
argument_list|(
literal|3
argument_list|,
name|t
argument_list|,
name|parse_sep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"zm_link"
argument_list|,
name|keyword
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|t
operator|->
name|seed_cnt
condition|)
name|t
operator|->
name|seed_cnt
operator|++
expr_stmt|;
name|kw_success
operator|=
name|parse_dir_link
argument_list|(
operator|-
literal|3
argument_list|,
name|t
argument_list|,
name|parse_sep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"z_dateline"
argument_list|,
name|keyword
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|t
operator|->
name|seed_cnt
condition|)
name|t
operator|->
name|seed_cnt
operator|++
expr_stmt|;
name|kw_success
operator|=
name|parse_dir_dateline
argument_list|(
literal|3
argument_list|,
name|t
argument_list|,
name|parse_sep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"max_changes"
argument_list|,
name|keyword
argument_list|)
operator|==
literal|0
condition|)
block|{
name|kw_success
operator|=
name|parse_unsigned
argument_list|(
operator|&
name|t
operator|->
name|max_changes
argument_list|,
name|parse_sep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|keyword
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
goto|goto
name|next_line
goto|;
else|else
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E12: no keyword found: line %u\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|line_cntr
argument_list|)
expr_stmt|;
name|kw_success
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|kw_success
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E13: parsing '%s': line %u\n"
argument_list|,
name|keyword
argument_list|,
operator|(
name|unsigned
operator|)
name|line_cntr
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
name|success
operator|&&
name|kw_success
expr_stmt|;
goto|goto
name|next_line
goto|;
name|out
label|:
if|if
condition|(
name|line_buf
condition|)
name|free
argument_list|(
name|line_buf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|capture_fabric
parameter_list|(
name|struct
name|fabric
modifier|*
name|fabric
parameter_list|)
block|{
name|osm_subn_t
modifier|*
name|subnet
init|=
operator|&
name|fabric
operator|->
name|osm
operator|->
name|subn
decl_stmt|;
name|osm_switch_t
modifier|*
name|osm_sw
decl_stmt|;
name|osm_physp_t
modifier|*
name|lphysp
decl_stmt|,
modifier|*
name|rphysp
decl_stmt|;
name|osm_port_t
modifier|*
name|lport
decl_stmt|;
name|osm_node_t
modifier|*
name|osm_node
decl_stmt|;
name|cl_map_item_t
modifier|*
name|item
decl_stmt|;
name|uint8_t
name|ltype
decl_stmt|,
name|rtype
decl_stmt|;
name|int
name|p
decl_stmt|,
name|port_cnt
decl_stmt|;
name|guid_t
name|sw_guid
decl_stmt|;
name|bool
name|success
init|=
name|true
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|fabric
operator|->
name|osm
operator|->
name|log
argument_list|)
expr_stmt|;
comment|/* 	 * On OpenSM data structures: 	 * 	 * Apparently, every port in a fabric has an associated osm_physp_t, 	 * but not every port has an associated osm_port_t.  Apparently every 	 * osm_port_t has an associated osm_physp_t. 	 * 	 * So, in order to find the inter-switch links we need to walk the 	 * switch list and examine each port, via its osm_physp_t object. 	 * 	 * But, we need to associate our CA and switch management port 	 * endpoints with the corresponding osm_port_t objects, in order 	 * to simplify computation of LFT entries and perform SL lookup for 	 * path records. Since it is apparently difficult to locate the 	 * osm_port_t that corresponds to a given osm_physp_t, we also 	 * need to walk the list of ports indexed by GUID to get access 	 * to the appropriate osm_port_t objects. 	 * 	 * Need to allocate our switches before we do anything else. 	 */
name|item
operator|=
name|cl_qmap_head
argument_list|(
operator|&
name|subnet
operator|->
name|sw_guid_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|item
operator|!=
name|cl_qmap_end
argument_list|(
operator|&
name|subnet
operator|->
name|sw_guid_tbl
argument_list|)
condition|)
block|{
name|osm_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|item
expr_stmt|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|osm_sw
operator|->
name|priv
operator|=
name|NULL
expr_stmt|;
comment|/* avoid stale pointer dereferencing */
name|osm_node
operator|=
name|osm_sw
operator|->
name|p_node
expr_stmt|;
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|osm_node
argument_list|)
operator|!=
name|IB_NODE_TYPE_SWITCH
condition|)
continue|continue;
name|port_cnt
operator|=
name|osm_node_get_num_physp
argument_list|(
name|osm_node
argument_list|)
expr_stmt|;
name|sw_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|osm_node
argument_list|)
expr_stmt|;
name|success
operator|=
name|alloc_fswitch
argument_list|(
name|fabric
argument_list|,
name|sw_guid
argument_list|,
name|port_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Now build all our endpoints. 	 */
name|item
operator|=
name|cl_qmap_head
argument_list|(
operator|&
name|subnet
operator|->
name|port_guid_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|item
operator|!=
name|cl_qmap_end
argument_list|(
operator|&
name|subnet
operator|->
name|port_guid_tbl
argument_list|)
condition|)
block|{
name|lport
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|item
expr_stmt|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|lport
operator|->
name|priv
operator|=
name|NULL
expr_stmt|;
comment|/* avoid stale pointer dereferencing */
name|lphysp
operator|=
name|lport
operator|->
name|p_physp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|lphysp
operator|&&
name|osm_physp_is_valid
argument_list|(
name|lphysp
argument_list|)
operator|)
condition|)
continue|continue;
name|ltype
operator|=
name|osm_node_get_type
argument_list|(
name|lphysp
operator|->
name|p_node
argument_list|)
expr_stmt|;
comment|/* 		 * Switch management port is always port 0. 		 */
if|if
condition|(
name|lphysp
operator|->
name|port_num
operator|==
literal|0
operator|&&
name|ltype
operator|==
name|IB_NODE_TYPE_SWITCH
condition|)
block|{
name|success
operator|=
name|build_sw_endpoint
argument_list|(
name|fabric
argument_list|,
name|lport
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
goto|goto
name|out
goto|;
continue|continue;
block|}
name|rphysp
operator|=
name|lphysp
operator|->
name|p_remote_physp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rphysp
operator|&&
name|osm_physp_is_valid
argument_list|(
name|rphysp
argument_list|)
operator|)
condition|)
continue|continue;
name|rtype
operator|=
name|osm_node_get_type
argument_list|(
name|rphysp
operator|->
name|p_node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ltype
operator|!=
name|IB_NODE_TYPE_CA
operator|&&
name|ltype
operator|!=
name|IB_NODE_TYPE_ROUTER
operator|)
operator|||
name|rtype
operator|!=
name|IB_NODE_TYPE_SWITCH
condition|)
continue|continue;
name|success
operator|=
name|build_ca_link
argument_list|(
name|fabric
argument_list|,
name|lport
argument_list|,
name|osm_node_get_node_guid
argument_list|(
name|rphysp
operator|->
name|p_node
argument_list|)
argument_list|,
name|osm_physp_get_port_num
argument_list|(
name|rphysp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Lastly, build all our interswitch links. 	 */
name|item
operator|=
name|cl_qmap_head
argument_list|(
operator|&
name|subnet
operator|->
name|sw_guid_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|item
operator|!=
name|cl_qmap_end
argument_list|(
operator|&
name|subnet
operator|->
name|sw_guid_tbl
argument_list|)
condition|)
block|{
name|osm_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|item
expr_stmt|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|port_cnt
operator|=
name|osm_node_get_num_physp
argument_list|(
name|osm_sw
operator|->
name|p_node
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|port_cnt
condition|;
name|p
operator|++
control|)
block|{
name|lphysp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|osm_sw
operator|->
name|p_node
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|lphysp
operator|&&
name|osm_physp_is_valid
argument_list|(
name|lphysp
argument_list|)
operator|)
condition|)
continue|continue;
name|rphysp
operator|=
name|lphysp
operator|->
name|p_remote_physp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rphysp
operator|&&
name|osm_physp_is_valid
argument_list|(
name|rphysp
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|lphysp
operator|==
name|rphysp
condition|)
continue|continue;
comment|/* ignore loopbacks */
name|ltype
operator|=
name|osm_node_get_type
argument_list|(
name|lphysp
operator|->
name|p_node
argument_list|)
expr_stmt|;
name|rtype
operator|=
name|osm_node_get_type
argument_list|(
name|rphysp
operator|->
name|p_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|ltype
operator|!=
name|IB_NODE_TYPE_SWITCH
operator|||
name|rtype
operator|!=
name|IB_NODE_TYPE_SWITCH
condition|)
continue|continue;
name|success
operator|=
name|build_link
argument_list|(
name|fabric
argument_list|,
name|osm_node_get_node_guid
argument_list|(
name|lphysp
operator|->
name|p_node
argument_list|)
argument_list|,
name|osm_physp_get_port_num
argument_list|(
name|lphysp
argument_list|)
argument_list|,
name|osm_node_get_node_guid
argument_list|(
name|rphysp
operator|->
name|p_node
argument_list|)
argument_list|,
name|osm_physp_get_port_num
argument_list|(
name|rphysp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|fabric
operator|->
name|osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/*  * diagnose_fabric() is just intended to report on fabric elements that  * could not be placed into the torus.  We want to warn that there were  * non-torus fabric elements, but they will be ignored for routing purposes.  * Having them is not an error, and diagnose_fabric() thus has no return  * value.  */
end_comment

begin_function
specifier|static
name|void
name|diagnose_fabric
parameter_list|(
name|struct
name|fabric
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|link
modifier|*
name|l
decl_stmt|;
name|struct
name|endpoint
modifier|*
name|ep
decl_stmt|;
name|unsigned
name|k
decl_stmt|,
name|p
decl_stmt|;
comment|/* 	 * Report on any links that didn't get transferred to the torus. 	 */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|f
operator|->
name|link_cnt
condition|;
name|k
operator|++
control|)
block|{
name|l
operator|=
name|f
operator|->
name|link
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|sw
operator|&&
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|sw
operator|)
condition|)
continue|continue;
name|OSM_LOG
argument_list|(
operator|&
name|f
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Found non-torus fabric link:"
literal|" sw GUID 0x%04"
name|PRIx64
literal|" port %d<->"
literal|" sw GUID 0x%04"
name|PRIx64
literal|" port %d\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|n_id
argument_list|)
argument_list|,
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|port
argument_list|,
name|cl_ntoh64
argument_list|(
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|n_id
argument_list|)
argument_list|,
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|port
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Report on any switches with ports using endpoints that didn't 	 * get transferred to the torus. 	 */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|f
operator|->
name|switch_cnt
condition|;
name|k
operator|++
control|)
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|f
operator|->
name|sw
index|[
name|k
index|]
operator|->
name|port_cnt
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|f
operator|->
name|sw
index|[
name|k
index|]
operator|->
name|port
index|[
name|p
index|]
condition|)
continue|continue;
name|ep
operator|=
name|f
operator|->
name|sw
index|[
name|k
index|]
operator|->
name|port
index|[
name|p
index|]
expr_stmt|;
comment|/* 			 * We already reported on inter-switch links above. 			 */
if|if
condition|(
name|ep
operator|->
name|type
operator|==
name|PASSTHRU
condition|)
continue|continue;
name|OSM_LOG
argument_list|(
operator|&
name|f
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Found non-torus fabric port:"
literal|" sw GUID 0x%04"
name|PRIx64
literal|" port %d\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|f
operator|->
name|sw
index|[
name|k
index|]
operator|->
name|n_id
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|t_switch
modifier|*
name|alloc_tswitch
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|struct
name|f_switch
modifier|*
name|fsw
parameter_list|)
block|{
name|unsigned
name|g
decl_stmt|;
name|size_t
name|new_sw_sz
decl_stmt|;
name|struct
name|t_switch
modifier|*
name|sw
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|!
name|fsw
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|t
operator|->
name|switch_cnt
operator|>=
name|t
operator|->
name|sw_pool_sz
condition|)
block|{
comment|/* 		 * This should never happen, but occasionally a particularly 		 * pathological fabric can induce it.  So log an error. 		 */
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E14: unexpectedly requested too many switch "
literal|"structures!\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|new_sw_sz
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sw
argument_list|)
operator|+
name|fsw
operator|->
name|port_cnt
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sw
operator|->
name|port
argument_list|)
operator|+
name|SWITCH_MAX_PORTGRPS
operator|*
name|t
operator|->
name|portgrp_sz
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sw
operator|->
name|ptgrp
index|[
literal|0
index|]
operator|.
name|port
argument_list|)
expr_stmt|;
name|sw
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|new_sw_sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sw
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E15: calloc: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sw
operator|->
name|port
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|sw
operator|+
literal|1
operator|)
expr_stmt|;
name|sw
operator|->
name|n_id
operator|=
name|fsw
operator|->
name|n_id
expr_stmt|;
name|sw
operator|->
name|port_cnt
operator|=
name|fsw
operator|->
name|port_cnt
expr_stmt|;
name|sw
operator|->
name|torus
operator|=
name|t
expr_stmt|;
name|sw
operator|->
name|tmp
operator|=
name|fsw
expr_stmt|;
name|ptr
operator|=
operator|&
name|sw
operator|->
name|port
index|[
name|sw
operator|->
name|port_cnt
index|]
expr_stmt|;
for|for
control|(
name|g
operator|=
literal|0
init|;
name|g
operator|<
name|SWITCH_MAX_PORTGRPS
condition|;
name|g
operator|++
control|)
block|{
name|sw
operator|->
name|ptgrp
index|[
name|g
index|]
operator|.
name|port_grp
operator|=
name|g
expr_stmt|;
name|sw
operator|->
name|ptgrp
index|[
name|g
index|]
operator|.
name|sw
operator|=
name|sw
expr_stmt|;
name|sw
operator|->
name|ptgrp
index|[
name|g
index|]
operator|.
name|port
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|=
operator|&
name|sw
operator|->
name|ptgrp
index|[
name|g
index|]
operator|.
name|port
index|[
name|t
operator|->
name|portgrp_sz
index|]
expr_stmt|;
block|}
name|t
operator|->
name|sw_pool
index|[
name|t
operator|->
name|switch_cnt
operator|++
index|]
operator|=
name|sw
expr_stmt|;
name|out
label|:
return|return
name|sw
return|;
block|}
end_function

begin_comment
comment|/*  * install_tswitch() expects the switch coordinates i,j,k to be canonicalized  * by caller.  */
end_comment

begin_function
specifier|static
name|bool
name|install_tswitch
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|,
name|struct
name|f_switch
modifier|*
name|fsw
parameter_list|)
block|{
name|struct
name|t_switch
modifier|*
modifier|*
name|sw
init|=
operator|&
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|sw
condition|)
operator|*
name|sw
operator|=
name|alloc_tswitch
argument_list|(
name|t
argument_list|,
name|fsw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sw
condition|)
block|{
operator|(
operator|*
name|sw
operator|)
operator|->
name|i
operator|=
name|i
expr_stmt|;
operator|(
operator|*
name|sw
operator|)
operator|->
name|j
operator|=
name|j
expr_stmt|;
operator|(
operator|*
name|sw
operator|)
operator|->
name|k
operator|=
name|k
expr_stmt|;
block|}
return|return
operator|!
operator|!
operator|*
name|sw
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|link
modifier|*
name|alloc_tlink
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|->
name|link_cnt
operator|>=
name|t
operator|->
name|link_pool_sz
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E16: unexpectedly out of pre-allocated link "
literal|"structures!\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|&
name|t
operator|->
name|link_pool
index|[
name|t
operator|->
name|link_cnt
operator|++
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|canonicalize
parameter_list|(
name|int
name|v
parameter_list|,
name|int
name|vmax
parameter_list|)
block|{
if|if
condition|(
name|v
operator|>=
literal|0
operator|&&
name|v
operator|<
name|vmax
condition|)
return|return
name|v
return|;
if|if
condition|(
name|v
operator|<
literal|0
condition|)
name|v
operator|+=
name|vmax
operator|*
operator|(
literal|1
operator|-
name|v
operator|/
name|vmax
operator|)
expr_stmt|;
return|return
name|v
operator|%
name|vmax
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|set_fp_bit
parameter_list|(
name|bool
name|present
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
return|return
call|(
name|unsigned
call|)
argument_list|(
operator|!
name|present
argument_list|)
operator|<<
operator|(
name|i
operator|+
literal|2
operator|*
name|j
operator|+
literal|4
operator|*
name|k
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns an 11-bit fingerprint of what switches are absent in a cube of  * neighboring switches.  Each bit 0-7 corresponds to a corner of the cube;  * if a bit is set the corresponding switch is absent.  *  * Bits 8-10 distinguish between 2D and 3D cases.  If bit 8+d is set,  * for 0<= d< 3;  the d dimension of the desired torus has radix greater  * than 1. Thus, if all bits 8-10 are set, the desired torus is 3D.  */
end_comment

begin_function
specifier|static
name|unsigned
name|fingerprint
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|unsigned
name|fp
decl_stmt|;
name|int
name|ip1
decl_stmt|,
name|jp1
decl_stmt|,
name|kp1
decl_stmt|;
name|int
name|x_sz_gt1
decl_stmt|,
name|y_sz_gt1
decl_stmt|,
name|z_sz_gt1
decl_stmt|;
name|x_sz_gt1
operator|=
name|t
operator|->
name|x_sz
operator|>
literal|1
expr_stmt|;
name|y_sz_gt1
operator|=
name|t
operator|->
name|y_sz
operator|>
literal|1
expr_stmt|;
name|z_sz_gt1
operator|=
name|t
operator|->
name|z_sz
operator|>
literal|1
expr_stmt|;
name|ip1
operator|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
expr_stmt|;
name|jp1
operator|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
expr_stmt|;
name|kp1
operator|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
expr_stmt|;
name|fp
operator|=
name|set_fp_bit
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fp
operator||=
name|set_fp_bit
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|x_sz_gt1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fp
operator||=
name|set_fp_bit
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
literal|0
argument_list|,
name|y_sz_gt1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fp
operator||=
name|set_fp_bit
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|x_sz_gt1
argument_list|,
name|y_sz_gt1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fp
operator||=
name|set_fp_bit
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|z_sz_gt1
argument_list|)
expr_stmt|;
name|fp
operator||=
name|set_fp_bit
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|x_sz_gt1
argument_list|,
literal|0
argument_list|,
name|z_sz_gt1
argument_list|)
expr_stmt|;
name|fp
operator||=
name|set_fp_bit
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
literal|0
argument_list|,
name|y_sz_gt1
argument_list|,
name|z_sz_gt1
argument_list|)
expr_stmt|;
name|fp
operator||=
name|set_fp_bit
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|x_sz_gt1
argument_list|,
name|y_sz_gt1
argument_list|,
name|z_sz_gt1
argument_list|)
expr_stmt|;
name|fp
operator||=
name|x_sz_gt1
operator|<<
literal|8
expr_stmt|;
name|fp
operator||=
name|y_sz_gt1
operator|<<
literal|9
expr_stmt|;
name|fp
operator||=
name|z_sz_gt1
operator|<<
literal|10
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|connect_tlink
parameter_list|(
name|struct
name|port_grp
modifier|*
name|pg0
parameter_list|,
name|struct
name|endpoint
modifier|*
name|f_ep0
parameter_list|,
name|struct
name|port_grp
modifier|*
name|pg1
parameter_list|,
name|struct
name|endpoint
modifier|*
name|f_ep1
parameter_list|,
name|struct
name|torus
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|link
modifier|*
name|l
decl_stmt|;
name|bool
name|success
init|=
name|false
decl_stmt|;
if|if
condition|(
name|pg0
operator|->
name|port_cnt
operator|==
name|t
operator|->
name|portgrp_sz
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E17: exceeded port group max "
literal|"port count (%d): switch GUID 0x%04"
name|PRIx64
literal|"\n"
argument_list|,
name|t
operator|->
name|portgrp_sz
argument_list|,
name|cl_ntoh64
argument_list|(
name|pg0
operator|->
name|sw
operator|->
name|n_id
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|pg1
operator|->
name|port_cnt
operator|==
name|t
operator|->
name|portgrp_sz
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E18: exceeded port group max "
literal|"port count (%d): switch GUID 0x%04"
name|PRIx64
literal|"\n"
argument_list|,
name|t
operator|->
name|portgrp_sz
argument_list|,
name|cl_ntoh64
argument_list|(
name|pg1
operator|->
name|sw
operator|->
name|n_id
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|l
operator|=
name|alloc_tlink
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|l
condition|)
goto|goto
name|out
goto|;
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|f_ep0
operator|->
name|type
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|=
name|f_ep0
operator|->
name|port
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|=
name|f_ep0
operator|->
name|n_id
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|sw
operator|=
name|pg0
operator|->
name|sw
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|link
operator|=
name|l
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|pgrp
operator|=
name|pg0
expr_stmt|;
name|pg0
operator|->
name|port
index|[
name|pg0
operator|->
name|port_cnt
operator|++
index|]
operator|=
operator|&
name|l
operator|->
name|end
index|[
literal|0
index|]
expr_stmt|;
name|pg0
operator|->
name|sw
operator|->
name|port
index|[
name|f_ep0
operator|->
name|port
index|]
operator|=
operator|&
name|l
operator|->
name|end
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|f_ep0
operator|->
name|osm_port
condition|)
block|{
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|osm_port
operator|=
name|f_ep0
operator|->
name|osm_port
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|osm_port
operator|->
name|priv
operator|=
operator|&
name|l
operator|->
name|end
index|[
literal|0
index|]
expr_stmt|;
name|f_ep0
operator|->
name|osm_port
operator|=
name|NULL
expr_stmt|;
block|}
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|f_ep1
operator|->
name|type
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|port
operator|=
name|f_ep1
operator|->
name|port
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|n_id
operator|=
name|f_ep1
operator|->
name|n_id
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|sw
operator|=
name|pg1
operator|->
name|sw
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|link
operator|=
name|l
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|pgrp
operator|=
name|pg1
expr_stmt|;
name|pg1
operator|->
name|port
index|[
name|pg1
operator|->
name|port_cnt
operator|++
index|]
operator|=
operator|&
name|l
operator|->
name|end
index|[
literal|1
index|]
expr_stmt|;
name|pg1
operator|->
name|sw
operator|->
name|port
index|[
name|f_ep1
operator|->
name|port
index|]
operator|=
operator|&
name|l
operator|->
name|end
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|f_ep1
operator|->
name|osm_port
condition|)
block|{
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|osm_port
operator|=
name|f_ep1
operator|->
name|osm_port
expr_stmt|;
name|l
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|osm_port
operator|->
name|priv
operator|=
operator|&
name|l
operator|->
name|end
index|[
literal|1
index|]
expr_stmt|;
name|f_ep1
operator|->
name|osm_port
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Disconnect fabric link, so that later we can see if any were 	 * left unconnected in the torus. 	 */
operator|(
operator|(
expr|struct
name|f_switch
operator|*
operator|)
name|f_ep0
operator|->
name|sw
operator|)
operator|->
name|port
index|[
name|f_ep0
operator|->
name|port
index|]
operator|=
name|NULL
expr_stmt|;
name|f_ep0
operator|->
name|sw
operator|=
name|NULL
expr_stmt|;
name|f_ep0
operator|->
name|port
operator|=
operator|-
literal|1
expr_stmt|;
operator|(
operator|(
expr|struct
name|f_switch
operator|*
operator|)
name|f_ep1
operator|->
name|sw
operator|)
operator|->
name|port
index|[
name|f_ep1
operator|->
name|port
index|]
operator|=
name|NULL
expr_stmt|;
name|f_ep1
operator|->
name|sw
operator|=
name|NULL
expr_stmt|;
name|f_ep1
operator|->
name|port
operator|=
operator|-
literal|1
expr_stmt|;
name|success
operator|=
name|true
expr_stmt|;
name|out
label|:
return|return
name|success
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|link_tswitches
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|cdir
parameter_list|,
name|struct
name|t_switch
modifier|*
name|t_sw0
parameter_list|,
name|struct
name|t_switch
modifier|*
name|t_sw1
parameter_list|)
block|{
name|int
name|p
decl_stmt|;
name|struct
name|port_grp
modifier|*
name|pg0
decl_stmt|,
modifier|*
name|pg1
decl_stmt|;
name|struct
name|f_switch
modifier|*
name|f_sw0
decl_stmt|,
modifier|*
name|f_sw1
decl_stmt|;
specifier|const
name|char
modifier|*
name|cdir_name
init|=
literal|"unknown"
decl_stmt|;
name|unsigned
name|port_cnt
decl_stmt|;
name|int
name|success
init|=
name|false
decl_stmt|;
comment|/* 	 * If this is a 2D torus, it is possible for this function to be 	 * called with its two switch arguments being the same switch, in 	 * which case there are no links to install. 	 */
if|if
condition|(
name|t_sw0
operator|==
name|t_sw1
operator|&&
operator|(
operator|(
name|cdir
operator|==
literal|0
operator|&&
name|t
operator|->
name|x_sz
operator|==
literal|1
operator|)
operator|||
operator|(
name|cdir
operator|==
literal|1
operator|&&
name|t
operator|->
name|y_sz
operator|==
literal|1
operator|)
operator|||
operator|(
name|cdir
operator|==
literal|2
operator|&&
name|t
operator|->
name|z_sz
operator|==
literal|1
operator|)
operator|)
condition|)
block|{
name|success
operator|=
name|true
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Ensure that t_sw1 is in the positive cdir direction wrt. t_sw0. 	 * ring_next_sw() relies on it. 	 */
switch|switch
condition|(
name|cdir
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|t
operator|->
name|x_sz
operator|>
literal|1
operator|&&
name|canonicalize
argument_list|(
name|t_sw0
operator|->
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
operator|!=
name|t_sw1
operator|->
name|i
condition|)
block|{
name|cdir_name
operator|=
literal|"x"
expr_stmt|;
goto|goto
name|cdir_error
goto|;
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|t
operator|->
name|y_sz
operator|>
literal|1
operator|&&
name|canonicalize
argument_list|(
name|t_sw0
operator|->
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
operator|!=
name|t_sw1
operator|->
name|j
condition|)
block|{
name|cdir_name
operator|=
literal|"y"
expr_stmt|;
goto|goto
name|cdir_error
goto|;
block|}
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|t
operator|->
name|z_sz
operator|>
literal|1
operator|&&
name|canonicalize
argument_list|(
name|t_sw0
operator|->
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
operator|!=
name|t_sw1
operator|->
name|k
condition|)
block|{
name|cdir_name
operator|=
literal|"z"
expr_stmt|;
goto|goto
name|cdir_error
goto|;
block|}
break|break;
default|default:
name|cdir_error
label|:
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E19: "
literal|"sw 0x%04"
name|PRIx64
literal|" (%d,%d,%d)<--> "
literal|"sw 0x%04"
name|PRIx64
literal|" (%d,%d,%d) "
literal|"invalid torus %s link orientation\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|t_sw0
operator|->
name|n_id
argument_list|)
argument_list|,
name|t_sw0
operator|->
name|i
argument_list|,
name|t_sw0
operator|->
name|j
argument_list|,
name|t_sw0
operator|->
name|k
argument_list|,
name|cl_ntoh64
argument_list|(
name|t_sw1
operator|->
name|n_id
argument_list|)
argument_list|,
name|t_sw1
operator|->
name|i
argument_list|,
name|t_sw1
operator|->
name|j
argument_list|,
name|t_sw1
operator|->
name|k
argument_list|,
name|cdir_name
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|f_sw0
operator|=
name|t_sw0
operator|->
name|tmp
expr_stmt|;
name|f_sw1
operator|=
name|t_sw1
operator|->
name|tmp
expr_stmt|;
if|if
condition|(
operator|!
name|f_sw0
operator|||
operator|!
name|f_sw1
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E1A: missing fabric switches!\n"
literal|"  switch GUIDs: 0x%04"
name|PRIx64
literal|" 0x%04"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|t_sw0
operator|->
name|n_id
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|t_sw1
operator|->
name|n_id
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|pg0
operator|=
operator|&
name|t_sw0
operator|->
name|ptgrp
index|[
literal|2
operator|*
name|cdir
operator|+
literal|1
index|]
expr_stmt|;
name|pg0
operator|->
name|type
operator|=
name|PASSTHRU
expr_stmt|;
name|pg1
operator|=
operator|&
name|t_sw1
operator|->
name|ptgrp
index|[
literal|2
operator|*
name|cdir
index|]
expr_stmt|;
name|pg1
operator|->
name|type
operator|=
name|PASSTHRU
expr_stmt|;
name|port_cnt
operator|=
name|f_sw0
operator|->
name|port_cnt
expr_stmt|;
comment|/* 	 * Find all the links between these two switches. 	 */
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|port_cnt
condition|;
name|p
operator|++
control|)
block|{
name|struct
name|endpoint
modifier|*
name|f_ep0
init|=
name|NULL
decl_stmt|,
modifier|*
name|f_ep1
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|f_sw0
operator|->
name|port
index|[
name|p
index|]
operator|||
operator|!
name|f_sw0
operator|->
name|port
index|[
name|p
index|]
operator|->
name|link
condition|)
continue|continue;
if|if
condition|(
name|f_sw0
operator|->
name|port
index|[
name|p
index|]
operator|->
name|link
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|==
name|t_sw0
operator|->
name|n_id
operator|&&
name|f_sw0
operator|->
name|port
index|[
name|p
index|]
operator|->
name|link
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|n_id
operator|==
name|t_sw1
operator|->
name|n_id
condition|)
block|{
name|f_ep0
operator|=
operator|&
name|f_sw0
operator|->
name|port
index|[
name|p
index|]
operator|->
name|link
operator|->
name|end
index|[
literal|0
index|]
expr_stmt|;
name|f_ep1
operator|=
operator|&
name|f_sw0
operator|->
name|port
index|[
name|p
index|]
operator|->
name|link
operator|->
name|end
index|[
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f_sw0
operator|->
name|port
index|[
name|p
index|]
operator|->
name|link
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|n_id
operator|==
name|t_sw0
operator|->
name|n_id
operator|&&
name|f_sw0
operator|->
name|port
index|[
name|p
index|]
operator|->
name|link
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|==
name|t_sw1
operator|->
name|n_id
condition|)
block|{
name|f_ep0
operator|=
operator|&
name|f_sw0
operator|->
name|port
index|[
name|p
index|]
operator|->
name|link
operator|->
name|end
index|[
literal|1
index|]
expr_stmt|;
name|f_ep1
operator|=
operator|&
name|f_sw0
operator|->
name|port
index|[
name|p
index|]
operator|->
name|link
operator|->
name|end
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
continue|continue;
if|if
condition|(
operator|!
operator|(
name|f_ep0
operator|->
name|type
operator|==
name|PASSTHRU
operator|&&
name|f_ep1
operator|->
name|type
operator|==
name|PASSTHRU
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E1B: not interswitch "
literal|"link:\n  0x%04"
name|PRIx64
literal|"/%d<-> 0x%04"
name|PRIx64
literal|"/%d\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|f_ep0
operator|->
name|n_id
argument_list|)
argument_list|,
name|f_ep0
operator|->
name|port
argument_list|,
name|cl_ntoh64
argument_list|(
name|f_ep1
operator|->
name|n_id
argument_list|)
argument_list|,
name|f_ep1
operator|->
name|port
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * Skip over links that already have been established in the 		 * torus. 		 */
if|if
condition|(
operator|!
operator|(
name|f_ep0
operator|->
name|sw
operator|&&
name|f_ep1
operator|->
name|sw
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|connect_tlink
argument_list|(
name|pg0
argument_list|,
name|f_ep0
argument_list|,
name|pg1
argument_list|,
name|f_ep1
argument_list|,
name|t
argument_list|)
condition|)
goto|goto
name|out
goto|;
block|}
name|success
operator|=
name|true
expr_stmt|;
name|out
label|:
return|return
name|success
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|link_srcsink
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|struct
name|endpoint
modifier|*
name|f_ep0
decl_stmt|;
name|struct
name|endpoint
modifier|*
name|f_ep1
decl_stmt|;
name|struct
name|t_switch
modifier|*
name|tsw
decl_stmt|;
name|struct
name|f_switch
modifier|*
name|fsw
decl_stmt|;
name|struct
name|port_grp
modifier|*
name|pg
decl_stmt|;
name|struct
name|link
modifier|*
name|fl
decl_stmt|,
modifier|*
name|tl
decl_stmt|;
name|unsigned
name|p
decl_stmt|,
name|port_cnt
decl_stmt|;
name|bool
name|success
init|=
name|false
decl_stmt|;
name|i
operator|=
name|canonicalize
argument_list|(
name|i
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
expr_stmt|;
name|j
operator|=
name|canonicalize
argument_list|(
name|j
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
expr_stmt|;
name|k
operator|=
name|canonicalize
argument_list|(
name|k
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
expr_stmt|;
name|tsw
operator|=
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|tsw
condition|)
return|return
name|true
return|;
name|fsw
operator|=
name|tsw
operator|->
name|tmp
expr_stmt|;
comment|/* 	 * link_srcsink is supposed to get called once for every switch in 	 * the fabric.  At this point every fsw we encounter must have a 	 * non-null osm_switch.  Otherwise something has gone horribly 	 * wrong with topology discovery; the most likely reason is that 	 * the fabric contains a radix-4 torus dimension, but the user gave 	 * a config that didn't say so, breaking all the checking in 	 * safe_x_perpendicular and friends. 	 */
if|if
condition|(
operator|!
operator|(
name|fsw
operator|&&
name|fsw
operator|->
name|osm_switch
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E1C: Invalid topology discovery. "
literal|"Verify torus-2QoS.conf contents.\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|pg
operator|=
operator|&
name|tsw
operator|->
name|ptgrp
index|[
literal|2
operator|*
name|TORUS_MAX_DIM
index|]
expr_stmt|;
name|pg
operator|->
name|type
operator|=
name|SRCSINK
expr_stmt|;
name|tsw
operator|->
name|osm_switch
operator|=
name|fsw
operator|->
name|osm_switch
expr_stmt|;
name|tsw
operator|->
name|osm_switch
operator|->
name|priv
operator|=
name|tsw
expr_stmt|;
name|fsw
operator|->
name|osm_switch
operator|=
name|NULL
expr_stmt|;
name|port_cnt
operator|=
name|fsw
operator|->
name|port_cnt
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|port_cnt
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|fsw
operator|->
name|port
index|[
name|p
index|]
condition|)
continue|continue;
if|if
condition|(
name|fsw
operator|->
name|port
index|[
name|p
index|]
operator|->
name|type
operator|==
name|SRCSINK
condition|)
block|{
comment|/* 			 * If the endpoint is the switch port used for in-band 			 * communication with the switch itself, move it to 			 * the torus. 			 */
if|if
condition|(
name|pg
operator|->
name|port_cnt
operator|==
name|t
operator|->
name|portgrp_sz
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E1D: exceeded port group max port "
literal|"count (%d): switch GUID 0x%04"
name|PRIx64
literal|"\n"
argument_list|,
name|t
operator|->
name|portgrp_sz
argument_list|,
name|cl_ntoh64
argument_list|(
name|tsw
operator|->
name|n_id
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fsw
operator|->
name|port
index|[
name|p
index|]
operator|->
name|sw
operator|=
name|tsw
expr_stmt|;
name|fsw
operator|->
name|port
index|[
name|p
index|]
operator|->
name|pgrp
operator|=
name|pg
expr_stmt|;
name|tsw
operator|->
name|port
index|[
name|p
index|]
operator|=
name|fsw
operator|->
name|port
index|[
name|p
index|]
expr_stmt|;
name|tsw
operator|->
name|port
index|[
name|p
index|]
operator|->
name|osm_port
operator|->
name|priv
operator|=
name|tsw
operator|->
name|port
index|[
name|p
index|]
expr_stmt|;
name|pg
operator|->
name|port
index|[
name|pg
operator|->
name|port_cnt
operator|++
index|]
operator|=
name|fsw
operator|->
name|port
index|[
name|p
index|]
expr_stmt|;
name|fsw
operator|->
name|port
index|[
name|p
index|]
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fsw
operator|->
name|port
index|[
name|p
index|]
operator|->
name|link
operator|&&
name|fsw
operator|->
name|port
index|[
name|p
index|]
operator|->
name|type
operator|==
name|PASSTHRU
condition|)
block|{
comment|/* 			 * If the endpoint is a link to a CA, create a new link 			 * in the torus.  Disconnect the fabric link. 			 */
name|fl
operator|=
name|fsw
operator|->
name|port
index|[
name|p
index|]
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|sw
operator|==
name|fsw
condition|)
block|{
name|f_ep0
operator|=
operator|&
name|fl
operator|->
name|end
index|[
literal|0
index|]
expr_stmt|;
name|f_ep1
operator|=
operator|&
name|fl
operator|->
name|end
index|[
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fl
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|sw
operator|==
name|fsw
condition|)
block|{
name|f_ep1
operator|=
operator|&
name|fl
operator|->
name|end
index|[
literal|0
index|]
expr_stmt|;
name|f_ep0
operator|=
operator|&
name|fl
operator|->
name|end
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
continue|continue;
if|if
condition|(
name|f_ep1
operator|->
name|type
operator|!=
name|SRCSINK
condition|)
continue|continue;
if|if
condition|(
name|pg
operator|->
name|port_cnt
operator|==
name|t
operator|->
name|portgrp_sz
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E1E: exceeded port group max port "
literal|"count (%d): switch GUID 0x%04"
name|PRIx64
literal|"\n"
argument_list|,
name|t
operator|->
name|portgrp_sz
argument_list|,
name|cl_ntoh64
argument_list|(
name|tsw
operator|->
name|n_id
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 			 * Switch ports connected to links don't get 			 * associated with osm_port_t objects; see 			 * capture_fabric().  So just check CA end. 			 */
if|if
condition|(
operator|!
name|f_ep1
operator|->
name|osm_port
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E1F: NULL osm_port->priv port "
literal|"GUID 0x%04"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|f_ep1
operator|->
name|n_id
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|tl
operator|=
name|alloc_tlink
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tl
condition|)
continue|continue;
name|tl
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|f_ep0
operator|->
name|type
expr_stmt|;
name|tl
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|=
name|f_ep0
operator|->
name|port
expr_stmt|;
name|tl
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|=
name|f_ep0
operator|->
name|n_id
expr_stmt|;
name|tl
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|sw
operator|=
name|tsw
expr_stmt|;
name|tl
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|link
operator|=
name|tl
expr_stmt|;
name|tl
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|pgrp
operator|=
name|pg
expr_stmt|;
name|pg
operator|->
name|port
index|[
name|pg
operator|->
name|port_cnt
operator|++
index|]
operator|=
operator|&
name|tl
operator|->
name|end
index|[
literal|0
index|]
expr_stmt|;
name|pg
operator|->
name|sw
operator|->
name|port
index|[
name|f_ep0
operator|->
name|port
index|]
operator|=
operator|&
name|tl
operator|->
name|end
index|[
literal|0
index|]
expr_stmt|;
name|tl
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|f_ep1
operator|->
name|type
expr_stmt|;
name|tl
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|port
operator|=
name|f_ep1
operator|->
name|port
expr_stmt|;
name|tl
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|n_id
operator|=
name|f_ep1
operator|->
name|n_id
expr_stmt|;
name|tl
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|sw
operator|=
name|NULL
expr_stmt|;
comment|/* Correct for a CA */
name|tl
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|link
operator|=
name|tl
expr_stmt|;
name|tl
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|pgrp
operator|=
name|NULL
expr_stmt|;
comment|/* Correct for a CA */
name|tl
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|osm_port
operator|=
name|f_ep1
operator|->
name|osm_port
expr_stmt|;
name|tl
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|osm_port
operator|->
name|priv
operator|=
operator|&
name|tl
operator|->
name|end
index|[
literal|1
index|]
expr_stmt|;
name|f_ep1
operator|->
name|osm_port
operator|=
name|NULL
expr_stmt|;
name|t
operator|->
name|ca_cnt
operator|++
expr_stmt|;
name|f_ep0
operator|->
name|sw
operator|=
name|NULL
expr_stmt|;
name|f_ep0
operator|->
name|port
operator|=
operator|-
literal|1
expr_stmt|;
name|fsw
operator|->
name|port
index|[
name|p
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|success
operator|=
name|true
expr_stmt|;
name|out
label|:
return|return
name|success
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|f_switch
modifier|*
name|ffind_face_corner
parameter_list|(
name|struct
name|f_switch
modifier|*
name|fsw0
parameter_list|,
name|struct
name|f_switch
modifier|*
name|fsw1
parameter_list|,
name|struct
name|f_switch
modifier|*
name|fsw2
parameter_list|)
block|{
name|int
name|p0
decl_stmt|,
name|p3
decl_stmt|;
name|struct
name|link
modifier|*
name|l
decl_stmt|;
name|struct
name|endpoint
modifier|*
name|far_end
decl_stmt|;
name|struct
name|f_switch
modifier|*
name|fsw
decl_stmt|,
modifier|*
name|fsw3
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fsw0
operator|&&
name|fsw1
operator|&&
name|fsw2
operator|)
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|p0
operator|=
literal|0
init|;
name|p0
operator|<
name|fsw0
operator|->
name|port_cnt
condition|;
name|p0
operator|++
control|)
block|{
comment|/* 		 * Ignore everything except switch links that haven't 		 * been installed into the torus. 		 */
if|if
condition|(
operator|!
operator|(
name|fsw0
operator|->
name|port
index|[
name|p0
index|]
operator|&&
name|fsw0
operator|->
name|port
index|[
name|p0
index|]
operator|->
name|sw
operator|&&
name|fsw0
operator|->
name|port
index|[
name|p0
index|]
operator|->
name|type
operator|==
name|PASSTHRU
operator|)
condition|)
continue|continue;
name|l
operator|=
name|fsw0
operator|->
name|port
index|[
name|p0
index|]
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|==
name|fsw0
operator|->
name|n_id
condition|)
name|far_end
operator|=
operator|&
name|l
operator|->
name|end
index|[
literal|1
index|]
expr_stmt|;
else|else
name|far_end
operator|=
operator|&
name|l
operator|->
name|end
index|[
literal|0
index|]
expr_stmt|;
comment|/* 		 * Ignore CAs 		 */
if|if
condition|(
operator|!
operator|(
name|far_end
operator|->
name|type
operator|==
name|PASSTHRU
operator|&&
name|far_end
operator|->
name|sw
operator|)
condition|)
continue|continue;
name|fsw3
operator|=
name|far_end
operator|->
name|sw
expr_stmt|;
if|if
condition|(
name|fsw3
operator|->
name|n_id
operator|==
name|fsw1
operator|->
name|n_id
condition|)
comment|/* existing corner */
continue|continue;
for|for
control|(
name|p3
operator|=
literal|0
init|;
name|p3
operator|<
name|fsw3
operator|->
name|port_cnt
condition|;
name|p3
operator|++
control|)
block|{
comment|/* 			 * Ignore everything except switch links that haven't 			 * been installed into the torus. 			 */
if|if
condition|(
operator|!
operator|(
name|fsw3
operator|->
name|port
index|[
name|p3
index|]
operator|&&
name|fsw3
operator|->
name|port
index|[
name|p3
index|]
operator|->
name|sw
operator|&&
name|fsw3
operator|->
name|port
index|[
name|p3
index|]
operator|->
name|type
operator|==
name|PASSTHRU
operator|)
condition|)
continue|continue;
name|l
operator|=
name|fsw3
operator|->
name|port
index|[
name|p3
index|]
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|==
name|fsw3
operator|->
name|n_id
condition|)
name|far_end
operator|=
operator|&
name|l
operator|->
name|end
index|[
literal|1
index|]
expr_stmt|;
else|else
name|far_end
operator|=
operator|&
name|l
operator|->
name|end
index|[
literal|0
index|]
expr_stmt|;
comment|/* 			 * Ignore CAs 			 */
if|if
condition|(
operator|!
operator|(
name|far_end
operator|->
name|type
operator|==
name|PASSTHRU
operator|&&
name|far_end
operator|->
name|sw
operator|)
condition|)
continue|continue;
name|fsw
operator|=
name|far_end
operator|->
name|sw
expr_stmt|;
if|if
condition|(
name|fsw
operator|->
name|n_id
operator|==
name|fsw2
operator|->
name|n_id
condition|)
goto|goto
name|out
goto|;
block|}
block|}
name|fsw3
operator|=
name|NULL
expr_stmt|;
name|out
label|:
return|return
name|fsw3
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|f_switch
modifier|*
name|tfind_face_corner
parameter_list|(
name|struct
name|t_switch
modifier|*
name|tsw0
parameter_list|,
name|struct
name|t_switch
modifier|*
name|tsw1
parameter_list|,
name|struct
name|t_switch
modifier|*
name|tsw2
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|tsw0
operator|&&
name|tsw1
operator|&&
name|tsw2
operator|)
condition|)
return|return
name|NULL
return|;
return|return
name|ffind_face_corner
argument_list|(
name|tsw0
operator|->
name|tmp
argument_list|,
name|tsw1
operator|->
name|tmp
argument_list|,
name|tsw2
operator|->
name|tmp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * This code can break on any torus with a dimension that has radix four.  *  * What is supposed to happen is that this code will find the  * two faces whose shared edge is the desired perpendicular.  *  * What actually happens is while searching we send two connected  * edges that are colinear in a torus dimension with radix four to  * ffind_face_corner(), which tries to complete a face by finding a  * 4-loop of edges.  *  * In the radix four torus case, it can find a 4-loop which is a ring in a  * dimension with radix four, rather than the desired face.  It thus returns  * true when it shouldn't, so the wrong edge is returned as the perpendicular.  *  * The appropriate instance of safe_N_perpendicular() (where N == x, y, z)  * should be used to determine if it is safe to call ffind_perpendicular();  * these functions will return false it there is a possibility of finding  * a wrong perpendicular.  */
end_comment

begin_function
name|struct
name|f_switch
modifier|*
name|ffind_3d_perpendicular
parameter_list|(
name|struct
name|f_switch
modifier|*
name|fsw0
parameter_list|,
name|struct
name|f_switch
modifier|*
name|fsw1
parameter_list|,
name|struct
name|f_switch
modifier|*
name|fsw2
parameter_list|,
name|struct
name|f_switch
modifier|*
name|fsw3
parameter_list|)
block|{
name|int
name|p1
decl_stmt|;
name|struct
name|link
modifier|*
name|l
decl_stmt|;
name|struct
name|endpoint
modifier|*
name|far_end
decl_stmt|;
name|struct
name|f_switch
modifier|*
name|fsw4
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fsw0
operator|&&
name|fsw1
operator|&&
name|fsw2
operator|&&
name|fsw3
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Look at all the ports on the switch, fsw1,  that is the base of 	 * the perpendicular. 	 */
for|for
control|(
name|p1
operator|=
literal|0
init|;
name|p1
operator|<
name|fsw1
operator|->
name|port_cnt
condition|;
name|p1
operator|++
control|)
block|{
comment|/* 		 * Ignore everything except switch links that haven't 		 * been installed into the torus. 		 */
if|if
condition|(
operator|!
operator|(
name|fsw1
operator|->
name|port
index|[
name|p1
index|]
operator|&&
name|fsw1
operator|->
name|port
index|[
name|p1
index|]
operator|->
name|sw
operator|&&
name|fsw1
operator|->
name|port
index|[
name|p1
index|]
operator|->
name|type
operator|==
name|PASSTHRU
operator|)
condition|)
continue|continue;
name|l
operator|=
name|fsw1
operator|->
name|port
index|[
name|p1
index|]
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|==
name|fsw1
operator|->
name|n_id
condition|)
name|far_end
operator|=
operator|&
name|l
operator|->
name|end
index|[
literal|1
index|]
expr_stmt|;
else|else
name|far_end
operator|=
operator|&
name|l
operator|->
name|end
index|[
literal|0
index|]
expr_stmt|;
comment|/* 		 * Ignore CAs 		 */
if|if
condition|(
operator|!
operator|(
name|far_end
operator|->
name|type
operator|==
name|PASSTHRU
operator|&&
name|far_end
operator|->
name|sw
operator|)
condition|)
continue|continue;
name|fsw4
operator|=
name|far_end
operator|->
name|sw
expr_stmt|;
if|if
condition|(
name|fsw4
operator|->
name|n_id
operator|==
name|fsw3
operator|->
name|n_id
condition|)
comment|/* wrong perpendicular */
continue|continue;
if|if
condition|(
name|ffind_face_corner
argument_list|(
name|fsw0
argument_list|,
name|fsw1
argument_list|,
name|fsw4
argument_list|)
operator|&&
name|ffind_face_corner
argument_list|(
name|fsw2
argument_list|,
name|fsw1
argument_list|,
name|fsw4
argument_list|)
condition|)
goto|goto
name|out
goto|;
block|}
name|fsw4
operator|=
name|NULL
expr_stmt|;
name|out
label|:
return|return
name|fsw4
return|;
block|}
end_function

begin_function
name|struct
name|f_switch
modifier|*
name|ffind_2d_perpendicular
parameter_list|(
name|struct
name|f_switch
modifier|*
name|fsw0
parameter_list|,
name|struct
name|f_switch
modifier|*
name|fsw1
parameter_list|,
name|struct
name|f_switch
modifier|*
name|fsw2
parameter_list|)
block|{
name|int
name|p1
decl_stmt|;
name|struct
name|link
modifier|*
name|l
decl_stmt|;
name|struct
name|endpoint
modifier|*
name|far_end
decl_stmt|;
name|struct
name|f_switch
modifier|*
name|fsw3
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fsw0
operator|&&
name|fsw1
operator|&&
name|fsw2
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Look at all the ports on the switch, fsw1,  that is the base of 	 * the perpendicular. 	 */
for|for
control|(
name|p1
operator|=
literal|0
init|;
name|p1
operator|<
name|fsw1
operator|->
name|port_cnt
condition|;
name|p1
operator|++
control|)
block|{
comment|/* 		 * Ignore everything except switch links that haven't 		 * been installed into the torus. 		 */
if|if
condition|(
operator|!
operator|(
name|fsw1
operator|->
name|port
index|[
name|p1
index|]
operator|&&
name|fsw1
operator|->
name|port
index|[
name|p1
index|]
operator|->
name|sw
operator|&&
name|fsw1
operator|->
name|port
index|[
name|p1
index|]
operator|->
name|type
operator|==
name|PASSTHRU
operator|)
condition|)
continue|continue;
name|l
operator|=
name|fsw1
operator|->
name|port
index|[
name|p1
index|]
operator|->
name|link
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|==
name|fsw1
operator|->
name|n_id
condition|)
name|far_end
operator|=
operator|&
name|l
operator|->
name|end
index|[
literal|1
index|]
expr_stmt|;
else|else
name|far_end
operator|=
operator|&
name|l
operator|->
name|end
index|[
literal|0
index|]
expr_stmt|;
comment|/* 		 * Ignore CAs 		 */
if|if
condition|(
operator|!
operator|(
name|far_end
operator|->
name|type
operator|==
name|PASSTHRU
operator|&&
name|far_end
operator|->
name|sw
operator|)
condition|)
continue|continue;
name|fsw3
operator|=
name|far_end
operator|->
name|sw
expr_stmt|;
if|if
condition|(
name|fsw3
operator|->
name|n_id
operator|==
name|fsw2
operator|->
name|n_id
condition|)
comment|/* wrong perpendicular */
continue|continue;
if|if
condition|(
name|ffind_face_corner
argument_list|(
name|fsw0
argument_list|,
name|fsw1
argument_list|,
name|fsw3
argument_list|)
condition|)
goto|goto
name|out
goto|;
block|}
name|fsw3
operator|=
name|NULL
expr_stmt|;
name|out
label|:
return|return
name|fsw3
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|f_switch
modifier|*
name|tfind_3d_perpendicular
parameter_list|(
name|struct
name|t_switch
modifier|*
name|tsw0
parameter_list|,
name|struct
name|t_switch
modifier|*
name|tsw1
parameter_list|,
name|struct
name|t_switch
modifier|*
name|tsw2
parameter_list|,
name|struct
name|t_switch
modifier|*
name|tsw3
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|tsw0
operator|&&
name|tsw1
operator|&&
name|tsw2
operator|&&
name|tsw3
operator|)
condition|)
return|return
name|NULL
return|;
return|return
name|ffind_3d_perpendicular
argument_list|(
name|tsw0
operator|->
name|tmp
argument_list|,
name|tsw1
operator|->
name|tmp
argument_list|,
name|tsw2
operator|->
name|tmp
argument_list|,
name|tsw3
operator|->
name|tmp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|f_switch
modifier|*
name|tfind_2d_perpendicular
parameter_list|(
name|struct
name|t_switch
modifier|*
name|tsw0
parameter_list|,
name|struct
name|t_switch
modifier|*
name|tsw1
parameter_list|,
name|struct
name|t_switch
modifier|*
name|tsw2
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|tsw0
operator|&&
name|tsw1
operator|&&
name|tsw2
operator|)
condition|)
return|return
name|NULL
return|;
return|return
name|ffind_2d_perpendicular
argument_list|(
name|tsw0
operator|->
name|tmp
argument_list|,
name|tsw1
operator|->
name|tmp
argument_list|,
name|tsw2
operator|->
name|tmp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|safe_x_ring
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|im1
decl_stmt|,
name|ip1
decl_stmt|,
name|ip2
decl_stmt|;
name|bool
name|success
init|=
name|true
decl_stmt|;
comment|/* 	 * If this x-direction radix-4 ring has at least two links 	 * already installed into the torus,  then this ring does not 	 * prevent us from looking for y or z direction perpendiculars. 	 * 	 * It is easier to check for the appropriate switches being installed 	 * into the torus than it is to check for the links, so force the 	 * link installation if the appropriate switches are installed. 	 * 	 * Recall that canonicalize(n - 2, 4) == canonicalize(n + 2, 4). 	 */
if|if
condition|(
name|t
operator|->
name|x_sz
operator|!=
literal|4
operator|||
name|t
operator|->
name|flags
operator|&
name|X_MESH
condition|)
goto|goto
name|out
goto|;
name|im1
operator|=
name|canonicalize
argument_list|(
name|i
operator|-
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
expr_stmt|;
name|ip1
operator|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
expr_stmt|;
name|ip2
operator|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|2
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|!
name|t
operator|->
name|sw
index|[
name|im1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|+
operator|!
operator|!
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|+
operator|!
operator|!
name|t
operator|->
name|sw
index|[
name|ip2
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|<
literal|2
condition|)
block|{
name|success
operator|=
name|false
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|t
operator|->
name|sw
index|[
name|ip2
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|&&
name|t
operator|->
name|sw
index|[
name|im1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
condition|)
name|success
operator|=
name|link_tswitches
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip2
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|im1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
operator|&&
name|success
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|sw
index|[
name|im1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|&&
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
condition|)
name|success
operator|=
name|link_tswitches
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
name|t
operator|->
name|sw
index|[
name|im1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
operator|&&
name|success
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|&&
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
condition|)
name|success
operator|=
name|link_tswitches
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
operator|&&
name|success
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|&&
name|t
operator|->
name|sw
index|[
name|ip2
index|]
index|[
name|j
index|]
index|[
name|k
index|]
condition|)
name|success
operator|=
name|link_tswitches
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip2
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
operator|&&
name|success
expr_stmt|;
name|out
label|:
return|return
name|success
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|safe_y_ring
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|jm1
decl_stmt|,
name|jp1
decl_stmt|,
name|jp2
decl_stmt|;
name|bool
name|success
init|=
name|true
decl_stmt|;
comment|/* 	 * If this y-direction radix-4 ring has at least two links 	 * already installed into the torus,  then this ring does not 	 * prevent us from looking for x or z direction perpendiculars. 	 * 	 * It is easier to check for the appropriate switches being installed 	 * into the torus than it is to check for the links, so force the 	 * link installation if the appropriate switches are installed. 	 * 	 * Recall that canonicalize(n - 2, 4) == canonicalize(n + 2, 4). 	 */
if|if
condition|(
name|t
operator|->
name|y_sz
operator|!=
literal|4
operator|||
operator|(
name|t
operator|->
name|flags
operator|&
name|Y_MESH
operator|)
condition|)
goto|goto
name|out
goto|;
name|jm1
operator|=
name|canonicalize
argument_list|(
name|j
operator|-
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
expr_stmt|;
name|jp1
operator|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
expr_stmt|;
name|jp2
operator|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|2
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|!
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jm1
index|]
index|[
name|k
index|]
operator|+
operator|!
operator|!
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
operator|+
operator|!
operator|!
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp2
index|]
index|[
name|k
index|]
operator|<
literal|2
condition|)
block|{
name|success
operator|=
name|false
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp2
index|]
index|[
name|k
index|]
operator|&&
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jm1
index|]
index|[
name|k
index|]
condition|)
name|success
operator|=
name|link_tswitches
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp2
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jm1
index|]
index|[
name|k
index|]
argument_list|)
operator|&&
name|success
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jm1
index|]
index|[
name|k
index|]
operator|&&
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
condition|)
name|success
operator|=
name|link_tswitches
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jm1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
operator|&&
name|success
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|&&
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
condition|)
name|success
operator|=
name|link_tswitches
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
operator|&&
name|success
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
operator|&&
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp2
index|]
index|[
name|k
index|]
condition|)
name|success
operator|=
name|link_tswitches
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp2
index|]
index|[
name|k
index|]
argument_list|)
operator|&&
name|success
expr_stmt|;
name|out
label|:
return|return
name|success
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|safe_z_ring
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|km1
decl_stmt|,
name|kp1
decl_stmt|,
name|kp2
decl_stmt|;
name|bool
name|success
init|=
name|true
decl_stmt|;
comment|/* 	 * If this z-direction radix-4 ring has at least two links 	 * already installed into the torus,  then this ring does not 	 * prevent us from looking for x or y direction perpendiculars. 	 * 	 * It is easier to check for the appropriate switches being installed 	 * into the torus than it is to check for the links, so force the 	 * link installation if the appropriate switches are installed. 	 * 	 * Recall that canonicalize(n - 2, 4) == canonicalize(n + 2, 4). 	 */
if|if
condition|(
name|t
operator|->
name|z_sz
operator|!=
literal|4
operator|||
name|t
operator|->
name|flags
operator|&
name|Z_MESH
condition|)
goto|goto
name|out
goto|;
name|km1
operator|=
name|canonicalize
argument_list|(
name|k
operator|-
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
expr_stmt|;
name|kp1
operator|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
expr_stmt|;
name|kp2
operator|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|2
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|!
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|km1
index|]
operator|+
operator|!
operator|!
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
operator|+
operator|!
operator|!
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp2
index|]
operator|<
literal|2
condition|)
block|{
name|success
operator|=
name|false
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp2
index|]
operator|&&
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|km1
index|]
condition|)
name|success
operator|=
name|link_tswitches
argument_list|(
name|t
argument_list|,
literal|2
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp2
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|km1
index|]
argument_list|)
operator|&&
name|success
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|km1
index|]
operator|&&
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
condition|)
name|success
operator|=
name|link_tswitches
argument_list|(
name|t
argument_list|,
literal|2
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|km1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
operator|&&
name|success
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|&&
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
condition|)
name|success
operator|=
name|link_tswitches
argument_list|(
name|t
argument_list|,
literal|2
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
operator|&&
name|success
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
operator|&&
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp2
index|]
condition|)
name|success
operator|=
name|link_tswitches
argument_list|(
name|t
argument_list|,
literal|2
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp2
index|]
argument_list|)
operator|&&
name|success
expr_stmt|;
name|out
label|:
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/*  * These functions return true when it safe to call  * tfind_3d_perpendicular()/ffind_3d_perpendicular().  */
end_comment

begin_function
specifier|static
name|bool
name|safe_x_perpendicular
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
comment|/* 	 * If the dimensions perpendicular to the search direction are 	 * not radix 4 torus dimensions, it is always safe to search for 	 * a perpendicular. 	 * 	 * Here we are checking for enough appropriate links having been 	 * installed into the torus to prevent an incorrect link from being 	 * considered as a perpendicular candidate. 	 */
return|return
name|safe_y_ring
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
operator|&&
name|safe_z_ring
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|safe_y_perpendicular
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
comment|/* 	 * If the dimensions perpendicular to the search direction are 	 * not radix 4 torus dimensions, it is always safe to search for 	 * a perpendicular. 	 * 	 * Here we are checking for enough appropriate links having been 	 * installed into the torus to prevent an incorrect link from being 	 * considered as a perpendicular candidate. 	 */
return|return
name|safe_x_ring
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
operator|&&
name|safe_z_ring
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|safe_z_perpendicular
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
comment|/* 	 * If the dimensions perpendicular to the search direction are 	 * not radix 4 torus dimensions, it is always safe to search for 	 * a perpendicular. 	 * 	 * Implement this by checking for enough appropriate links having 	 * been installed into the torus to prevent an incorrect link from 	 * being considered as a perpendicular candidate. 	 */
return|return
name|safe_x_ring
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
operator|&&
name|safe_y_ring
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Templates for determining 2D/3D case fingerprints. Recall that if  * a fingerprint bit is set the corresponding switch is absent from  * the all-switches-present template.  *  * I.e., for the 2D case where the x,y dimensions have a radix greater  * than one, and the z dimension has radix 1, fingerprint bits 4-7 are  * always zero.  *  * For the 2D case where the x,z dimensions have a radix greater than  * one, and the y dimension has radix 1, fingerprint bits 2,3,6,7 are  * always zero.  *  * For the 2D case where the y,z dimensions have a radix greater than  * one, and the x dimension has radix 1, fingerprint bits 1,3,5,7 are  * always zero.  *  * Recall also that bits 8-10 distinguish between 2D and 3D cases.  * If bit 8+d is set, for 0<= d< 3;  the d dimension of the desired  * torus has radix greater than 1.  */
end_comment

begin_comment
comment|/*  * 2D case 0x300  *  b0: t->sw[i  ][j  ][0  ]  *  b1: t->sw[i+1][j  ][0  ]  *  b2: t->sw[i  ][j+1][0  ]  *  b3: t->sw[i+1][j+1][0  ]  *                                    O . . . . . O  * 2D case 0x500                      .           .  *  b0: t->sw[i  ][0  ][k  ]          .           .  *  b1: t->sw[i+1][0  ][k  ]          .           .  *  b4: t->sw[i  ][0  ][k+1]          .           .  *  b5: t->sw[i+1][0  ][k+1]          .           .  *                                    @ . . . . . O  * 2D case 0x600  *  b0: t->sw[0  ][j  ][k  ]  *  b2: t->sw[0  ][j+1][k  ]  *  b4: t->sw[0  ][j  ][k+1]  *  b6: t->sw[0  ][j+1][k+1]  */
end_comment

begin_comment
comment|/*  * 3D case 0x700:                           O  *                                        . . .  *  b0: t->sw[i  ][j  ][k  ]            .   .   .  *  b1: t->sw[i+1][j  ][k  ]          .     .     .  *  b2: t->sw[i  ][j+1][k  ]        .       .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4: t->sw[i  ][j  ][k+1]      . .       O       . .  *  b5: t->sw[i+1][j  ][k+1]      .   .   .   .   .   .  *  b6: t->sw[i  ][j+1][k+1]      .     .       .     .  *  b7: t->sw[i+1][j+1][k+1]      .   .   .   .   .   .  *                                . .       O       . .  *                                O         .         O  *                                  .       .       .  *                                    .     .     .  *                                      .   .   .  *                                        . . .  *                                          @  */
end_comment

begin_function
specifier|static
name|void
name|log_no_crnr
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|unsigned
name|n
parameter_list|,
name|int
name|case_i
parameter_list|,
name|int
name|case_j
parameter_list|,
name|int
name|case_k
parameter_list|,
name|int
name|crnr_i
parameter_list|,
name|int
name|crnr_j
parameter_list|,
name|int
name|crnr_k
parameter_list|)
block|{
if|if
condition|(
name|t
operator|->
name|debug
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Case 0x%03x "
literal|"@ %d %d %d: no corner @ %d %d %d\n"
argument_list|,
name|n
argument_list|,
name|case_i
argument_list|,
name|case_j
argument_list|,
name|case_k
argument_list|,
name|crnr_i
argument_list|,
name|crnr_j
argument_list|,
name|crnr_k
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|log_no_perp
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|unsigned
name|n
parameter_list|,
name|int
name|case_i
parameter_list|,
name|int
name|case_j
parameter_list|,
name|int
name|case_k
parameter_list|,
name|int
name|perp_i
parameter_list|,
name|int
name|perp_j
parameter_list|,
name|int
name|perp_k
parameter_list|)
block|{
if|if
condition|(
name|t
operator|->
name|debug
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Case 0x%03x "
literal|"@ %d %d %d: no perpendicular @ %d %d %d\n"
argument_list|,
name|n
argument_list|,
name|case_i
argument_list|,
name|case_j
argument_list|,
name|case_k
argument_list|,
name|perp_i
argument_list|,
name|perp_j
argument_list|,
name|perp_k
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle the 2D cases with a single existing edge.  *  */
end_comment

begin_comment
comment|/*  * 2D case 0x30c  *  b0: t->sw[i  ][j  ][0  ]  *  b1: t->sw[i+1][j  ][0  ]  *  b2:  *  b3:  *                                    O           O  * 2D case 0x530  *  b0: t->sw[i  ][0  ][k  ]  *  b1: t->sw[i+1][0  ][k  ]  *  b4:  *  b5:  *                                    @ . . . . . O  * 2D case 0x650  *  b0: t->sw[0  ][j  ][k  ]  *  b2: t->sw[0  ][j+1][k  ]  *  b4:  *  b6:  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x30c
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jm1
init|=
name|canonicalize
argument_list|(
name|j
operator|-
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_y_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_2d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jm1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x30c
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|safe_y_perpendicular
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_2d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jm1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x30c
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|handle_case_0x530
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|km1
init|=
name|canonicalize
argument_list|(
name|k
operator|-
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_z_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_2d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|km1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x530
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|safe_z_perpendicular
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_2d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|km1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x530
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|handle_case_0x650
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|km1
init|=
name|canonicalize
argument_list|(
name|k
operator|-
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_z_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_2d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|km1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x650
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|safe_z_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_2d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|km1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x650
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 2D case 0x305  *  b0:  *  b1: t->sw[i+1][j  ][0  ]  *  b2:  *  b3: t->sw[i+1][j+1][0  ]  *                                    O           O  * 2D case 0x511                                  .  *  b0:                                           .  *  b1: t->sw[i+1][0  ][k  ]                      .  *  b4:                                           .  *  b5: t->sw[i+1][0  ][k+1]                      .  *                                    @           O  * 2D case 0x611  *  b0:  *  b2: t->sw[0  ][j+1][k  ]  *  b4:  *  b6: t->sw[0  ][j+1][k+1]  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x305
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|ip2
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|2
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_x_perpendicular
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_2d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip2
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x305
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|safe_x_perpendicular
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_2d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip2
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x305
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|handle_case_0x511
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|ip2
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|2
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_x_perpendicular
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_2d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip2
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x511
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|safe_x_perpendicular
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_2d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip2
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x511
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|handle_case_0x611
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|jp2
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|2
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_y_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_2d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp2
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x611
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|safe_y_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_2d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp2
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x611
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 2D case 0x303  *  b0:  *  b1:  *  b2: t->sw[i  ][j+1][0  ]  *  b3: t->sw[i+1][j+1][0  ]  *                                    O . . . . . O  * 2D case 0x503  *  b0:  *  b1:  *  b4: t->sw[i  ][0  ][k+1]  *  b5: t->sw[i+1][0  ][k+1]  *                                    @           O  * 2D case 0x605  *  b0:  *  b2:  *  b4: t->sw[0  ][j  ][k+1]  *  b6: t->sw[0  ][j+1][k+1]  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x303
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|jp2
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|2
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_y_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_2d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp2
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x303
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|safe_y_perpendicular
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_2d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp2
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x303
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|handle_case_0x503
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
name|int
name|kp2
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|2
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_z_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_2d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp2
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x503
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|safe_z_perpendicular
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_2d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp2
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x503
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|handle_case_0x605
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
name|int
name|kp2
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|2
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_z_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_2d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp2
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x605
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|safe_z_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_2d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp2
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x605
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 2D case 0x30a  *  b0: t->sw[i  ][j  ][0  ]  *  b1:  *  b2: t->sw[i  ][j+1][0  ]  *  b3:  *                                    O           O  * 2D case 0x522                      .  *  b0: t->sw[i  ][0  ][k  ]          .  *  b1:                               .  *  b4: t->sw[i  ][0  ][k+1]          .  *  b5:                               .  *                                    @           O  * 2D case 0x644  *  b0: t->sw[0  ][j  ][k  ]  *  b2:  *  b4: t->sw[0  ][j  ][k+1]  *  b6:  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x30a
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|im1
init|=
name|canonicalize
argument_list|(
name|i
operator|-
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_x_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_2d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|im1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x30a
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|safe_x_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_2d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|im1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x30a
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|handle_case_0x522
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|im1
init|=
name|canonicalize
argument_list|(
name|i
operator|-
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_x_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_2d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|im1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x522
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|safe_x_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_2d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|im1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x522
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|handle_case_0x644
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|jm1
init|=
name|canonicalize
argument_list|(
name|j
operator|-
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_y_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_2d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jm1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x644
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|safe_y_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_2d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jm1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x644
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * Handle the 2D cases where two existing edges meet at a corner.  *  */
end_comment

begin_comment
comment|/*  * 2D case 0x301  *  b0:  *  b1: t->sw[i+1][j  ][0  ]  *  b2: t->sw[i  ][j+1][0  ]  *  b3: t->sw[i+1][j+1][0  ]  *                                    O . . . . . O  * 2D case 0x501                                  .  *  b0:                                           .  *  b1: t->sw[i+1][0  ][k  ]                      .  *  b4: t->sw[i  ][0  ][k+1]                      .  *  b5: t->sw[i+1][0  ][k+1]                      .  *                                    @           O  * 2D case 0x601  *  b0:  *  b2: t->sw[0  ][j+1][k  ]  *  b4: t->sw[0  ][j  ][k+1]  *  b6: t->sw[0  ][j+1][k+1]  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x301
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x301
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|handle_case_0x501
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x501
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|handle_case_0x601
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x601
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 2D case 0x302  *  b0: t->sw[i  ][j  ][0  ]  *  b1:  *  b2: t->sw[i  ][j+1][0  ]  *  b3: t->sw[i+1][j+1][0  ]  *                                    O . . . . . O  * 2D case 0x502                      .  *  b0: t->sw[i  ][0  ][k  ]          .  *  b1:                               .  *  b4: t->sw[i  ][0  ][k+1]          .  *  b5: t->sw[i+1][0  ][k+1]          .  *                                    @           O  * 2D case 0x604  *  b0: t->sw[0  ][j  ][k  ]  *  b2:  *  b4: t->sw[0  ][j  ][k+1]  *  b6: t->sw[0  ][j+1][k+1]  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x302
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x302
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|handle_case_0x502
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x502
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|handle_case_0x604
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x604
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 2D case 0x308  *  b0: t->sw[i  ][j  ][0  ]  *  b1: t->sw[i+1][j  ][0  ]  *  b2: t->sw[i  ][j+1][0  ]  *  b3:  *                                    O           O  * 2D case 0x520                      .  *  b0: t->sw[i  ][0  ][k  ]          .  *  b1: t->sw[i+1][0  ][k  ]          .  *  b4: t->sw[i  ][0  ][k+1]          .  *  b5:                               .  *                                    @ . . . . . O  * 2D case 0x640  *  b0: t->sw[0  ][j  ][k  ]  *  b2: t->sw[0  ][j+1][k  ]  *  b4: t->sw[0  ][j  ][k+1]  *  b6:  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x308
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x308
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|handle_case_0x520
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x520
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|handle_case_0x640
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x640
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 2D case 0x304  *  b0: t->sw[i  ][j  ][0  ]  *  b1: t->sw[i+1][j  ][0  ]  *  b2:  *  b3: t->sw[i+1][j+1][0  ]  *                                    O           O  * 2D case 0x510                                  .  *  b0: t->sw[i  ][0  ][k  ]                      .  *  b1: t->sw[i+1][0  ][k  ]                      .  *  b4:                                           .  *  b5: t->sw[i+1][0  ][k+1]                      .  *                                    @ . . . . . O  * 2D case 0x610  *  b0: t->sw[0  ][j  ][k  ]  *  b2: t->sw[0  ][j+1][k  ]  *  b4:  *  b6: t->sw[0  ][j+1][k+1]  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x304
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x304
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|handle_case_0x510
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x510
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|handle_case_0x610
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x610
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * Handle the 3D cases where two existing edges meet at a corner.  *  */
end_comment

begin_comment
comment|/*  * 3D case 0x71f:                           O  *                                        .   .  *  b0:                                 .       .  *  b1:                               .           .  *  b2:                             .               .  *  b3:                           O                   O  *  b4:                                     O  *  b5: t->sw[i+1][j  ][k+1]  *  b6: t->sw[i  ][j+1][k+1]  *  b7: t->sw[i+1][j+1][k+1]  *                                          O  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x71f
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
name|int
name|kp2
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|2
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_z_perpendicular
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_3d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp2
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x71f
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x72f:                           O  *                                        .  *  b0:                                 .  *  b1:                               .  *  b2:                             .  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]        .       O  *  b5:                               .  *  b6: t->sw[i  ][j+1][k+1]            .  *  b7: t->sw[i+1][j+1][k+1]              .  *                                          O  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x72f
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
name|int
name|kp2
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|2
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_z_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_3d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp2
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x72f
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x737:                           O  *                                        . .  *  b0:                                 .   .  *  b1:                               .     .  *  b2:                             .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4:                                     O  *  b5:  *  b6: t->sw[i  ][j+1][k+1]  *  b7: t->sw[i+1][j+1][k+1]  *                                          O  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x737
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|jp2
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|2
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_y_perpendicular
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_3d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp2
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x737
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x73b:                           O  *                                        .  *  b0:                                 .  *  b1:                               .  *  b2: t->sw[i  ][j+1][k  ]        .  *  b3:                           O                   O  *  b4:                           .         O  *  b5:                           .  *  b6: t->sw[i  ][j+1][k+1]      .  *  b7: t->sw[i+1][j+1][k+1]      .  *                                .         O  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x73b
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|jp2
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|2
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_y_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_3d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp2
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x73b
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x74f:                           O  *                                            .  *  b0:                                         .  *  b1:                                           .  *  b2:                                             .  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]                O       .  *  b5: t->sw[i+1][j  ][k+1]                      .  *  b6:                                         .  *  b7: t->sw[i+1][j+1][k+1]                  .  *                                          O  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x74f
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
name|int
name|kp2
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|2
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_z_perpendicular
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_3d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp2
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x74f
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x757:                           O  *                                          . .  *  b0:                                     .   .  *  b1:                                     .     .  *  b2:                                     .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4:                                     O  *  b5: t->sw[i+1][j  ][k+1]  *  b6:  *  b7: t->sw[i+1][j+1][k+1]  *                                          O  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x757
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|ip2
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|2
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_x_perpendicular
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_3d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip2
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x757
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x75d:                           O  *                                            .  *  b0:                                         .  *  b1: t->sw[i+1][j  ][k  ]                      .  *  b2:                                             .  *  b3:                           O                   O  *  b4:                                     O         .  *  b5: t->sw[i+1][j  ][k+1]                          .  *  b6:                                               .  *  b7: t->sw[i+1][j+1][k+1]                          .  *                                          O         .  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x75d
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|ip2
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|2
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_x_perpendicular
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_3d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip2
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x75d
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x773:                           O  *                                          .  *  b0:                                     .  *  b1:                                     .  *  b2: t->sw[i  ][j+1][k  ]                .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4:                                     O  *  b5:                                   .  *  b6:                                 .  *  b7: t->sw[i+1][j+1][k+1]          .  *                                  .       O  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x773
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|jp2
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|2
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_y_perpendicular
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_3d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp2
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x773
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x775:                           O  *                                          .  *  b0:                                     .  *  b1: t->sw[i+1][j  ][k  ]                .  *  b2:                                     .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4:                                     O  *  b5:                                       .  *  b6:                                         .  *  b7: t->sw[i+1][j+1][k+1]                      .  *                                          O       .  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x775
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|ip2
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|2
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_x_perpendicular
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_3d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip2
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x775
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x78f:                           O  *  *  b0:  *  b1:  *  b2:  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]        .       O       .  *  b5: t->sw[i+1][j  ][k+1]          .           .  *  b6: t->sw[i  ][j+1][k+1]            .       .  *  b7:                                   .   .  *                                          O  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x78f
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
name|int
name|kp2
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|2
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_z_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_3d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp2
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x78f
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7ab:                           O  *  *  b0:  *  b1:  *  b2: t->sw[i  ][j+1][k  ]  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]      . .       O  *  b5:                           .   .  *  b6: t->sw[i  ][j+1][k+1]      .     .  *  b7:                           .       .  *                                .         O  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7ab
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|im1
init|=
name|canonicalize
argument_list|(
name|i
operator|-
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_x_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_3d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|im1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x7ab
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7ae:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1:  *  b2:  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]        .       O  *  b5:                               .  *  b6: t->sw[i  ][j+1][k+1]            .  *  b7:                                   .  *                                          O  *                                O         .         O  *                                          .  *                                          .  *                                          .  *                                          .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7ae
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|im1
init|=
name|canonicalize
argument_list|(
name|i
operator|-
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_x_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_3d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|im1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x7ae
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7b3:                           O  *  *  b0:  *  b1:  *  b2: t->sw[i  ][j+1][k  ]  *  b3: t->sw[i+1][j+1][k  ]      O                   O  *  b4:                           .         O  *  b5:                           .       .  *  b6: t->sw[i  ][j+1][k+1]      .     .  *  b7:                           .   .  *                                . .       O  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7b3
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|jp2
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|2
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_y_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_3d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp2
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x7b3
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7ba:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1:  *  b2: t->sw[i  ][j+1][k  ]  *  b3:                           O                   O  *  b4:                           .         O  *  b5:                           .  *  b6: t->sw[i  ][j+1][k+1]      .  *  b7:                           .  *                                .         O  *                                O                   O  *                                  .  *                                    .  *                                      .  *                                        .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7ba
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|im1
init|=
name|canonicalize
argument_list|(
name|i
operator|-
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_x_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_3d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|im1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x7ba
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7cd:                           O  *  *  b0:  *  b1: t->sw[i+1][j  ][k  ]  *  b2:  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]                O       . .  *  b5: t->sw[i+1][j  ][k+1]                      .   .  *  b6:                                         .     .  *  b7:                                       .       .  *                                          O         .  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7cd
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|jm1
init|=
name|canonicalize
argument_list|(
name|j
operator|-
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_y_perpendicular
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_3d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jm1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x7cd
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7ce:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1:  *  b2:  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]                O       .  *  b5: t->sw[i+1][j  ][k+1]                      .  *  b6:                                         .  *  b7:                                       .  *                                          O  *                                O         .         O  *                                          .  *                                          .  *                                          .  *                                          .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7ce
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|jm1
init|=
name|canonicalize
argument_list|(
name|j
operator|-
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_y_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_3d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jm1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x7ce
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7d5:                           O  *  *  b0:  *  b1: t->sw[i+1][j  ][k  ]  *  b2:  *  b3: t->sw[i+1][j+1][k  ]      O                   O  *  b4:                                     O         .  *  b5: t->sw[i+1][j  ][k+1]                  .       .  *  b6:                                         .     .  *  b7:                                           .   .  *                                          O       . .  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7d5
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|ip2
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|2
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_x_perpendicular
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_3d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip2
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x7d5
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7dc:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1: t->sw[i+1][j  ][k  ]  *  b2:  *  b3:                           O                   O  *  b4:                                     O         .  *  b5: t->sw[i+1][j  ][k+1]                          .  *  b6:                                               .  *  b7:                                               .  *                                          O         .  *                                O                   O  *                                                  .  *                                                .  *                                              .  *                                            .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7dc
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|jm1
init|=
name|canonicalize
argument_list|(
name|j
operator|-
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_y_perpendicular
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_3d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jm1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x7dc
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7ea:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1:  *  b2: t->sw[i  ][j+1][k  ]  *  b3:                            O                   O  *  b4: t->sw[i  ][j  ][k+1]                 O  *  b5:  *  b6:  *  b7:  *                                          O  *                                O         .         O  *                                  .       .  *                                    .     .  *                                      .   .  *                                        . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7ea
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|im1
init|=
name|canonicalize
argument_list|(
name|i
operator|-
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_x_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_3d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|im1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x7ea
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7ec:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1: t->sw[i+1][j  ][k  ]  *  b2:  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]                O  *  b5:  *  b6:  *  b7:  *                                          O  *                                O         .         O  *                                          .       .  *                                          .     .  *                                          .   .  *                                          . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7ec
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|jm1
init|=
name|canonicalize
argument_list|(
name|j
operator|-
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_y_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_3d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jm1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x7ec
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7f1:                           O  *  *  b0:  *  b1: t->sw[i+1][j  ][k  ]  *  b2: t->sw[i  ][j+1][k  ]  *  b3: t->sw[i+1][j+1][k  ]      O                   O  *  b4:                                     O  *  b5:                                   .   .  *  b6:                                 .       .  *  b7:                               .           .  *                                  .       O       .  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7f1
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|km1
init|=
name|canonicalize
argument_list|(
name|k
operator|-
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_z_perpendicular
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_3d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|km1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x7f1
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7f2:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1:  *  b2: t->sw[i  ][j+1][k  ]  *  b3: t->sw[i+1][j+1][k  ]      O                   O  *  b4:                                     O  *  b5:                                   .  *  b6:                                 .  *  b7:                               .  *                                  .       O  *                                O                   O  *                                  .  *                                    .  *                                      .  *                                        .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7f2
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|km1
init|=
name|canonicalize
argument_list|(
name|k
operator|-
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_z_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_3d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|km1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x7f2
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7f4:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1: t->sw[i+1][j  ][k  ]  *  b2:  *  b3: t->sw[i+1][j+1][k  ]      O                   O  *  b4:                                     O  *  b5:                                       .  *  b6:                                         .  *  b7:                                           .  *                                          O       .  *                                O                   O  *                                                  .  *                                                .  *                                              .  *                                            .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7f4
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|km1
init|=
name|canonicalize
argument_list|(
name|k
operator|-
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_z_perpendicular
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_3d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|km1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x7f4
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7f8:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1: t->sw[i+1][j  ][k  ]  *  b2: t->sw[i  ][j+1][k  ]  *  b3:                           O                   O  *  b4:                                     O  *  b5:  *  b6:  *  b7:  *                                          O  *                                O                   O  *                                  .               .  *                                    .           .  *                                      .       .  *                                        .   .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7f8
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|km1
init|=
name|canonicalize
argument_list|(
name|k
operator|-
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|safe_z_perpendicular
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_3d_perpendicular
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|km1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_perp
argument_list|(
name|t
argument_list|,
literal|0x7f8
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * Handle the cases where three existing edges meet at a corner.  */
end_comment

begin_comment
comment|/*  * 3D case 0x717:                           O  *                                        . . .  *  b0:                                 .   .   .  *  b1:                               .     .     .  *  b2:                             .       .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4:                                     O  *  b5: t->sw[i+1][j  ][k+1]  *  b6: t->sw[i  ][j+1][k+1]  *  b7: t->sw[i+1][j+1][k+1]  *                                          O  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x717
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x717
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x717
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x717
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x72b:                           O  *                                        .  *  b0:                                 .  *  b1:                               .  *  b2: t->sw[i  ][j+1][k  ]        .  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]      . .       O  *  b5:                           .   .  *  b6: t->sw[i  ][j+1][k+1]      .     .  *  b7: t->sw[i+1][j+1][k+1]      .       .  *                                .         O  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x72b
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x72b
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x72b
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x72b
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x74d:                           O  *                                            .  *  b0:                                         .  *  b1: t->sw[i+1][j  ][k  ]                      .  *  b2:                                             .  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]                O       . .  *  b5: t->sw[i+1][j  ][k+1]                      .   .  *  b6:                                         .     .  *  b7: t->sw[i+1][j+1][k+1]                  .       .  *                                          O         .  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x74d
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x74d
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x74d
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x74d
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x771:                           O  *                                          .  *  b0:                                     .  *  b1: t->sw[i+1][j  ][k  ]                .  *  b2: t->sw[i  ][j+1][k  ]                .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4:                                     O  *  b5:                                   .   .  *  b6:                                 .       .  *  b7: t->sw[i+1][j+1][k+1]          .           .  *                                  .       O       .  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x771
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x771
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x771
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x771
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x78e:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1:  *  b2:  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]        .       O       .  *  b5: t->sw[i+1][j  ][k+1]          .           .  *  b6: t->sw[i  ][j+1][k+1]            .       .  *  b7:                                   .   .  *                                          O  *                                O         .         O  *                                          .  *                                          .  *                                          .  *                                          .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x78e
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x78e
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x78e
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x78e
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7b2:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1:  *  b2: t->sw[i  ][j+1][k  ]  *  b3: t->sw[i+1][j+1][k  ]      O                   O  *  b4:                           .         O  *  b5:                           .       .  *  b6: t->sw[i  ][j+1][k+1]      .     .  *  b7:                           .   .  *                                . .       O  *                                O                   O  *                                  .  *                                    .  *                                      .  *                                        .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7b2
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7b2
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7b2
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7b2
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7d4:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1: t->sw[i+1][j  ][k  ]  *  b2:  *  b3: t->sw[i+1][j+1][k  ]      O                   O  *  b4:                                     O         .  *  b5: t->sw[i+1][j  ][k+1]                  .       .  *  b6:                                         .     .  *  b7:                                           .   .  *                                          O       . .  *                                O                   O  *                                                  .  *                                                .  *                                              .  *                                            .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7d4
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7d4
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7d4
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7d4
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7e8:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1: t->sw[i+1][j  ][k  ]  *  b2: t->sw[i  ][j+1][k  ]  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]                O  *  b5:  *  b6:  *  b7:  *                                          O  *                                O         .         O  *                                  .       .       .  *                                    .     .     .  *                                      .   .   .  *                                        . . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7e8
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7e8
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7e8
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7e8
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * Handle the cases where four corners on a single face are missing.  */
end_comment

begin_comment
comment|/*  * 3D case 0x70f:                           O  *                                        .   .  *  b0:                                 .       .  *  b1:                               .           .  *  b2:                             .               .  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]        .       O       .  *  b5: t->sw[i+1][j  ][k+1]          .           .  *  b6: t->sw[i  ][j+1][k+1]            .       .  *  b7: t->sw[i+1][j+1][k+1]              .   .  *                                          O  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x70f
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
if|if
condition|(
name|handle_case_0x71f
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|handle_case_0x72f
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|handle_case_0x74f
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|handle_case_0x78f
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x733:                           O  *                                        . .  *  b0:                                 .   .  *  b1:                               .     .  *  b2: t->sw[i  ][j+1][k  ]        .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4:                           .         O  *  b5:                           .       .  *  b6: t->sw[i  ][j+1][k+1]      .     .  *  b7: t->sw[i+1][j+1][k+1]      .   .  *                                . .       O  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x733
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
if|if
condition|(
name|handle_case_0x737
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|handle_case_0x73b
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|handle_case_0x773
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|handle_case_0x7b3
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x755:                           O  *                                          . .  *  b0:                                     .   .  *  b1: t->sw[i+1][j  ][k  ]                .     .  *  b2:                                     .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4:                                     O         .  *  b5: t->sw[i+1][j  ][k+1]                  .       .  *  b6:                                         .     .  *  b7: t->sw[i+1][j+1][k+1]                      .   .  *                                          O       . .  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x755
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
if|if
condition|(
name|handle_case_0x757
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|handle_case_0x75d
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|handle_case_0x775
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|handle_case_0x7d5
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7aa:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1:  *  b2: t->sw[i  ][j+1][k  ]  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]      . .       O  *  b5:                           .   .  *  b6: t->sw[i  ][j+1][k+1]      .     .  *  b7:                           .       .  *                                .         O  *                                O         .         O  *                                  .       .  *                                    .     .  *                                      .   .  *                                        . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7aa
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
if|if
condition|(
name|handle_case_0x7ab
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|handle_case_0x7ae
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|handle_case_0x7ba
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|handle_case_0x7ea
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7cc:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1: t->sw[i+1][j  ][k  ]  *  b2:  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]                O       . .  *  b5: t->sw[i+1][j  ][k+1]                      .   .  *  b6:                                         .     .  *  b7:                                       .       .  *                                          O         .  *                                O         .         O  *                                          .       .  *                                          .     .  *                                          .   .  *                                          . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7cc
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
if|if
condition|(
name|handle_case_0x7cd
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|handle_case_0x7ce
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|handle_case_0x7dc
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|handle_case_0x7ec
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7f0:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1: t->sw[i+1][j  ][k  ]  *  b2: t->sw[i  ][j+1][k  ]  *  b3: t->sw[i+1][j+1][k  ]      O                   O  *  b4:                                     O  *  b5:                                   .   .  *  b6:                                 .       .  *  b7:                               .           .  *                                  .       O       .  *                                O                   O  *                                  .               .  *                                    .           .  *                                      .       .  *                                        .   .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7f0
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
if|if
condition|(
name|handle_case_0x7f1
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|handle_case_0x7f2
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|handle_case_0x7f4
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|handle_case_0x7f8
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle the cases where three corners on a single face are missing.  */
end_comment

begin_comment
comment|/*  * 3D case 0x707:                           O  *                                        . . .  *  b0:                                 .   .   .  *  b1:                               .     .     .  *  b2:                             .       .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4: t->sw[i  ][j  ][k+1]        .       O       .  *  b5: t->sw[i+1][j  ][k+1]          .           .  *  b6: t->sw[i  ][j+1][k+1]            .       .  *  b7: t->sw[i+1][j+1][k+1]              .   .  *                                          O  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x707
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x707
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x707
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x70b:                           O  *                                        .   .  *  b0:                                 .       .  *  b1:                               .           .  *  b2: t->sw[i  ][j+1][k  ]        .               .  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]      . .       O       .  *  b5: t->sw[i+1][j  ][k+1]      .   .           .  *  b6: t->sw[i  ][j+1][k+1]      .     .       .  *  b7: t->sw[i+1][j+1][k+1]      .       .   .  *                                .         O  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x70b
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x70b
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x70b
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x70d:                           O  *                                        .   .  *  b0:                                 .       .  *  b1: t->sw[i+1][j  ][k  ]          .           .  *  b2:                             .               .  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]        .       O       . .  *  b5: t->sw[i+1][j  ][k+1]          .           .   .  *  b6: t->sw[i  ][j+1][k+1]            .       .     .  *  b7: t->sw[i+1][j+1][k+1]              .   .       .  *                                          O         .  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x70d
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x70d
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x70d
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x70e:                           O  *                                        .   .  *  b0: t->sw[i  ][j  ][k  ]            .       .  *  b1:                               .           .  *  b2:                             .               .  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]        .       O       .  *  b5: t->sw[i+1][j  ][k+1]          .           .  *  b6: t->sw[i  ][j+1][k+1]            .       .  *  b7: t->sw[i+1][j+1][k+1]              .   .  *                                          O  *                                O         .         O  *                                          .  *                                          .  *                                          .  *                                          .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x70e
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x70e
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x70e
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x713:                           O  *                                        . . .  *  b0:                                 .   .   .  *  b1:                               .     .     .  *  b2: t->sw[i  ][j+1][k  ]        .       .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4:                           .         O  *  b5: t->sw[i+1][j  ][k+1]      .       .  *  b6: t->sw[i  ][j+1][k+1]      .     .  *  b7: t->sw[i+1][j+1][k+1]      .   .  *                                . .       O  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x713
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x713
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x713
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x715:                           O  *                                        . . .  *  b0:                                 .   .   .  *  b1: t->sw[i+1][j  ][k  ]          .     .     .  *  b2:                             .       .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4:                                     O         .  *  b5: t->sw[i+1][j  ][k+1]                  .       .  *  b6: t->sw[i  ][j+1][k+1]                    .     .  *  b7: t->sw[i+1][j+1][k+1]                      .   .  *                                          O       . .  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x715
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x715
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x715
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x723:                           O  *                                        . .  *  b0:                                 .   .  *  b1:                               .     .  *  b2: t->sw[i  ][j+1][k  ]        .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4: t->sw[i  ][j  ][k+1]      . .       O  *  b5:                           .   .   .  *  b6: t->sw[i  ][j+1][k+1]      .     .  *  b7: t->sw[i+1][j+1][k+1]      .   .   .  *                                . .       O  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x723
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x723
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x723
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x72a:                           O  *                                        .  *  b0: t->sw[i  ][j  ][k  ]            .  *  b1:                               .  *  b2: t->sw[i  ][j+1][k  ]        .  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]      . .       O  *  b5:                           .   .  *  b6: t->sw[i  ][j+1][k+1]      .     .  *  b7: t->sw[i+1][j+1][k+1]      .       .  *                                .         O  *                                O         .         O  *                                  .       .  *                                    .     .  *                                      .   .  *                                        . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x72a
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x72a
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x72a
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x731:                           O  *                                        . .  *  b0:                                 .   .  *  b1: t->sw[i+1][j  ][k  ]          .     .  *  b2: t->sw[i  ][j+1][k  ]        .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4:                           .         O  *  b5:                           .       .   .  *  b6: t->sw[i  ][j+1][k+1]      .     .       .  *  b7: t->sw[i+1][j+1][k+1]      .   .           .  *                                . .       O       .  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x731
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x731
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x731
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x732:                           O  *                                        . .  *  b0: t->sw[i  ][j  ][k  ]            .   .  *  b1:                               .     .  *  b2: t->sw[i  ][j+1][k  ]        .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4:                           .         O  *  b5:                           .       .  *  b6: t->sw[i  ][j+1][k+1]      .     .  *  b7: t->sw[i+1][j+1][k+1]      .   .  *                                . .       O  *                                O                   O  *                                  .  *                                    .  *                                      .  *                                        .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x732
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x732
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x732
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x745:                           O  *                                          . .  *  b0:                                     .   .  *  b1: t->sw[i+1][j  ][k  ]                .     .  *  b2:                                     .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4: t->sw[i  ][j  ][k+1]                O       . .  *  b5: t->sw[i+1][j  ][k+1]                  .   .   .  *  b6:                                         .     .  *  b7: t->sw[i+1][j+1][k+1]                  .   .   .  *                                          O       . .  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x745
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x745
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x745
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x74c:                           O  *                                            .  *  b0: t->sw[i  ][j  ][k  ]                    .  *  b1: t->sw[i+1][j  ][k  ]                      .  *  b2:                                             .  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]                O       . .  *  b5: t->sw[i+1][j  ][k+1]                      .   .  *  b6:                                         .     .  *  b7: t->sw[i+1][j+1][k+1]                  .       .  *                                          O         .  *                                O         .         O  *                                          .       .  *                                          .     .  *                                          .   .  *                                          . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x74c
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x74c
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x74c
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x751:                           O  *                                          . .  *  b0:                                     .   .  *  b1: t->sw[i+1][j  ][k  ]                .     .  *  b2: t->sw[i  ][j+1][k  ]                .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4:                                     O         .  *  b5: t->sw[i+1][j  ][k+1]              .   .       .  *  b6:                                 .       .     .  *  b7: t->sw[i+1][j+1][k+1]          .           .   .  *                                  .       O       . .  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x751
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x751
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x751
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x754:                           O  *                                          . .  *  b0: t->sw[i  ][j  ][k  ]                .   .  *  b1: t->sw[i+1][j  ][k  ]                .     .  *  b2:                                     .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4:                                     O         .  *  b5: t->sw[i+1][j  ][k+1]                  .       .  *  b6:                                         .     .  *  b7: t->sw[i+1][j+1][k+1]                      .   .  *                                          O       . .  *                                O                   O  *                                                  .  *                                                .  *                                              .  *                                            .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x754
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x754
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x754
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x770:                           O  *                                          .  *  b0: t->sw[i  ][j  ][k  ]                .  *  b1: t->sw[i+1][j  ][k  ]                .  *  b2: t->sw[i  ][j+1][k  ]                .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4:                                     O  *  b5:                                   .   .  *  b6:                                 .       .  *  b7: t->sw[i+1][j+1][k+1]          .           .  *                                  .       O       .  *                                O                   O  *                                  .               .  *                                    .           .  *                                      .       .  *                                        .   .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x770
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x770
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x770
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x78a:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1:  *  b2: t->sw[i  ][j+1][k  ]  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]      . .       O       .  *  b5: t->sw[i+1][j  ][k+1]      .   .           .  *  b6: t->sw[i  ][j+1][k+1]      .     .       .  *  b7:                           .       .   .  *                                .         O  *                                O         .         O  *                                  .       .  *                                    .     .  *                                      .   .  *                                        . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x78a
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x78a
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x78a
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x78c:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1: t->sw[i+1][j  ][k  ]  *  b2:  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]        .       O       . .  *  b5: t->sw[i+1][j  ][k+1]          .           .   .  *  b6: t->sw[i  ][j+1][k+1]            .       .     .  *  b7:                                   .   .       .  *                                          O         .  *                                O         .         O  *                                          .       .  *                                          .     .  *                                          .   .  *                                          . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x78c
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x78c
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x78c
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7a2:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1:  *  b2: t->sw[i  ][j+1][k  ]  *  b3: t->sw[i+1][j+1][k  ]      O                   O  *  b4: t->sw[i  ][j  ][k+1]      . .       O  *  b5:                           .   .   .  *  b6: t->sw[i  ][j+1][k+1]      .     .  *  b7:                           .   .   .  *                                . .       O  *                                O         .         O  *                                  .       .  *                                    .     .  *                                      .   .  *                                        . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7a2
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7a2
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7a2
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7a8:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1: t->sw[ip1][j  ][k  ]  *  b2: t->sw[i  ][j+1][k  ]  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]      . .       O  *  b5:                           .   .  *  b6: t->sw[i  ][j+1][k+1]      .     .  *  b7:                           .       .  *                                .         O  *                                O         .         O  *                                  .       .       .  *                                    .     .     .  *                                      .   .   .  *                                        . . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7a8
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7a8
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7a8
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7b0:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1: t->sw[i+1][j  ][k  ]  *  b2: t->sw[i  ][j+1][k  ]  *  b3: t->sw[i+1][j+1][k  ]      O                   O  *  b4:                           .         O  *  b5:                           .       .   .  *  b6: t->sw[i  ][j+1][k+1]      .     .       .  *  b7:                           .   .           .  *                                . .       O       .  *                                O                   O  *                                  .               .  *                                    .           .  *                                      .       .  *                                        .   .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7b0
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7b0
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7b0
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7c4:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1: t->sw[i+1][j  ][k  ]  *  b2:  *  b3: t->sw[i+1][j+1][k  ]      O                   O  *  b4: t->sw[i  ][j  ][k+1]                O       . .  *  b5: t->sw[i+1][j  ][k+1]                  .   .   .  *  b6:                                         .     .  *  b7:                                       .   .   .  *                                          O       . .  *                                O         .         O  *                                          .       .  *                                          .     .  *                                          .   .  *                                          . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7c4
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7c4
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7c4
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7c8:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1: t->sw[i+1][j  ][k  ]  *  b2: t->sw[i  ][j+1][k  ]  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]                O       . .  *  b5: t->sw[i+1][j  ][k+1]                      .   .  *  b6:                                         .     .  *  b7:                                       .       .  *                                          O         .  *                                O         .         O  *                                  .       .       .  *                                    .     .     .  *                                      .   .   .  *                                        . . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7c8
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7c8
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7c8
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7d0:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1: t->sw[i+1][j  ][k  ]  *  b2: t->sw[i  ][j+1][k  ]  *  b3: t->sw[i+1][j+1][k  ]      O                   O  *  b4:                                     O         .  *  b5: t->sw[i+1][j  ][k+1]              .   .       .  *  b6:                                 .       .     .  *  b7:                               .           .   .  *                                  .       O       . .  *                                O                   O  *                                  .               .  *                                    .           .  *                                      .       .  *                                        .   .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7d0
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7d0
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7d0
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7e0:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1: t->sw[i+1][j  ][k  ]  *  b2: t->sw[i  ][j+1][k  ]  *  b3: t->sw[i+1][j+1][k  ]      O                   O  *  b4: t->sw[i  ][j  ][k+1]                O  *  b5:                                   .   .  *  b6:                                 .       .  *  b7:                               .           .  *                                  .       O       .  *                                O         .         O  *                                  .       .       .  *                                    .     .     .  *                                      .   .   .  *                                        . . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7e0
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7e0
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7e0
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * Handle the cases where two corners on a single edge are missing.  */
end_comment

begin_comment
comment|/*  * 3D case 0x703:                           O  *                                        . . .  *  b0:                                 .   .   .  *  b1:                               .     .     .  *  b2: t->sw[i  ][j+1][k  ]        .       .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4: t->sw[i  ][j  ][k+1]      . .       O       .  *  b5: t->sw[i+1][j  ][k+1]      .   .   .       .  *  b6: t->sw[i  ][j+1][k+1]      .     .       .  *  b7: t->sw[i+1][j+1][k+1]      .   .   .   .  *                                . .       O  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x703
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x703
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x703
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x705:                           O  *                                        . . .  *  b0:                                 .   .   .  *  b1: t->sw[i+1][j  ][k  ]          .     .     .  *  b2:                             .       .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4: t->sw[i  ][j  ][k+1]        .       O       . .  *  b5: t->sw[i+1][j  ][k+1]          .       .   .   .  *  b6: t->sw[i  ][j+1][k+1]            .       .     .  *  b7: t->sw[i+1][j+1][k+1]              .   .   .   .  *                                          O       . .  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x705
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x705
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x705
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x70a:                           O  *                                        . . .  *  b0: t->sw[i  ][j  ][k  ]            .       .  *  b1:                               .           .  *  b2: t->sw[i  ][j+1][k  ]        .               .  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]      . .       O       .  *  b5: t->sw[i+1][j  ][k+1]      .   .           .  *  b6: t->sw[i  ][j+1][k+1]      .     .       .  *  b7: t->sw[i+1][j+1][k+1]      .       .   .  *                                .         O  *                                O         .         O  *                                  .       .  *                                    .     .  *                                      .   .  *                                        . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x70a
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x70a
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x70a
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x70c:                           O  *                                        .   .  *  b0: t->sw[i  ][j  ][k  ]            .       .  *  b1: t->sw[i+1][j  ][k  ]          .           .  *  b2:                             .               .  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]        .       O       . .  *  b5: t->sw[i+1][j  ][k+1]          .           .   .  *  b6: t->sw[i  ][j+1][k+1]            .       .     .  *  b7: t->sw[i+1][j+1][k+1]              .   .       .  *                                          O         .  *                                O         .         O  *                                          .       .  *                                          .     .  *                                          .   .  *                                          . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x70c
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x70c
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x70c
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x711:                           O  *                                        . . .  *  b0:                                 .   .   .  *  b1: t->sw[i+1][j  ][k  ]          .     .     .  *  b2: t->sw[i  ][j+1][k  ]        .       .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4:                           .         O         .  *  b5: t->sw[i+1][j  ][k+1]      .       .   .       .  *  b6: t->sw[i  ][j+1][k+1]      .     .       .     .  *  b7: t->sw[i+1][j+1][k+1]      .   .           .   .  *                                . .       O       . .  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x711
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x711
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x711
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x722:                           O  *                                        . .  *  b0: t->sw[i  ][j  ][k  ]            .   .  *  b1:                               .     .  *  b2: t->sw[i  ][j+1][k  ]        .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4: t->sw[i  ][j  ][k+1]      . .       O  *  b5:                           .   .   .  *  b6: t->sw[i  ][j+1][k+1]      .     .  *  b7: t->sw[i+1][j+1][k+1]      .   .   .  *                                . .       O  *                                O         .         O  *                                  .       .  *                                    .     .  *                                      .   .  *                                        . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x722
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x722
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x722
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x730:                           O  *                                        . .  *  b0: t->sw[i  ][j  ][k  ]            .   .  *  b1: t->sw[i+1][j  ][k  ]          .     .  *  b2: t->sw[i  ][j+1][k  ]        .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4:                           .         O  *  b5:                           .       .   .  *  b6: t->sw[i  ][j+1][k+1]      .     .       .  *  b7: t->sw[i+1][j+1][k+1]      .   .           .  *                                . .       O       .  *                                O                   O  *                                  .               .  *                                    .           .  *                                      .       .  *                                        .   .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x730
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x730
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x730
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x744:                           O  *                                          . .  *  b0: t->sw[i  ][j  ][k  ]                .   .  *  b1: t->sw[i+1][j  ][k  ]                .     .  *  b2:                                     .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4: t->sw[i  ][j  ][k+1]                O       . .  *  b5: t->sw[i+1][j  ][k+1]                  .   .   .  *  b6:                                         .     .  *  b7: t->sw[i+1][j+1][k+1]                  .   .   .  *                                          O       . .  *                                O         .         O  *                                          .       .  *                                          .     .  *                                          .   .  *                                          . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x744
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x744
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x744
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x750:                           O  *                                          . .  *  b0: t->sw[i  ][j  ][k  ]                .   .  *  b1: t->sw[i+1][j  ][k  ]                .     .  *  b2: t->sw[i  ][j+1][k  ]                .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4:                                     O         .  *  b5: t->sw[i+1][j  ][k+1]              .   .       .  *  b6:                                 .       .     .  *  b7: t->sw[i+1][j+1][k+1]          .           .   .  *                                  .       O       . .  *                                O                   O  *                                  .               .  *                                    .           .  *                                      .       .  *                                        .   .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x750
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x750
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x750
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x788:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1: t->sw[ip1][j  ][k  ]  *  b2: t->sw[i  ][j+1][k  ]  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]      . .       O       . .  *  b5: t->sw[i+1][j  ][k+1]      .   .           .   .  *  b6: t->sw[i  ][j+1][k+1]      .     .       .     .  *  b7:                           .       .   .       .  *                                .         O         .  *                                O         .         O  *                                  .       .       .  *                                    .     .     .  *                                      .   .   .  *                                        . . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x788
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x788
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x788
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7a0:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1: t->sw[i+1][j  ][k  ]  *  b2: t->sw[i  ][j+1][k  ]  *  b3: t->sw[i+1][j+1][k  ]      O                   O  *  b4: t->sw[i  ][j  ][k+1]      . .       O  *  b5:                           .   .   .   .  *  b6: t->sw[i  ][j+1][k+1]      .     .       .  *  b7:                           .   .   .       .  *                                . .       O       .  *                                O         .         O  *                                  .       .       .  *                                    .     .     .  *                                      .   .   .  *                                        . . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7a0
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7a0
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7a0
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x7c0:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1: t->sw[i+1][j  ][k  ]  *  b2: t->sw[i  ][j+1][k  ]  *  b3: t->sw[i+1][j+1][k  ]      O                   O  *  b4: t->sw[i  ][j  ][k+1]                O       . .  *  b5: t->sw[i+1][j  ][k+1]              .   .   .   .  *  b6:                                 .       .     .  *  b7:                               .       .   .   .  *                                  .       O       . .  *                                O         .         O  *                                  .       .       .  *                                    .     .     .  *                                      .   .   .  *                                        . . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x7c0
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7c0
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x7c0
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * Handle the cases where a single corner is missing.  */
end_comment

begin_comment
comment|/*  * 3D case 0x701:                           O  *                                        . . .  *  b0:                                     .   .   .  *  b1: t->sw[i+1][j  ][k  ]          .     .     .  *  b2: t->sw[i  ][j+1][k  ]        .       .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4: t->sw[i  ][j  ][k+1]      . .       O       . .  *  b5: t->sw[i+1][j  ][k+1]      .   .   .   .   .   .  *  b6: t->sw[i  ][j+1][k+1]      .     .       .     .  *  b7: t->sw[i+1][j+1][k+1]      .   .   .   .   .   .  *                                . .       O       . .  *                                O                   O  *  *  *  *  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x701
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x701
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x702:                           O  *                                        . . .  *  b0: t->sw[i  ][j  ][k  ]            .   .   .  *  b1:                               .     .     .  *  b2: t->sw[i  ][j+1][k  ]        .       .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4: t->sw[i  ][j  ][k+1]      . .       O       .  *  b5: t->sw[i+1][j  ][k+1]      .   .   .       .  *  b6: t->sw[i  ][j+1][k+1]      .     .       .  *  b7: t->sw[i+1][j+1][k+1]      .   .   .   .  *                                . .       O  *                                O         .         O  *                                  .       .  *                                    .     .  *                                      .   .  *                                        . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x702
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x702
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x704:                           O  *                                        . . .  *  b0: t->sw[i  ][j  ][k  ]            .   .   .  *  b1: t->sw[i+1][j  ][k  ]          .     .     .  *  b2:                             .       .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4: t->sw[i  ][j  ][k+1]        .       O       . .  *  b5: t->sw[i+1][j  ][k+1]          .       .   .   .  *  b6: t->sw[i  ][j+1][k+1]            .       .     .  *  b7: t->sw[i+1][j+1][k+1]              .   .   .   .  *                                          O       . .  *                                O         .         O  *                                          .       .  *                                          .     .  *                                          .   .  *                                          . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x704
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x704
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x708:                           O  *                                        .   .  *  b0: t->sw[i  ][j  ][k  ]            .       .  *  b1: t->sw[i+1][j  ][k  ]          .           .  *  b2: t->sw[i  ][j+1][k  ]        .               .  *  b3:                           O                   O  *  b4: t->sw[i  ][j  ][k+1]      . .       O       . .  *  b5: t->sw[i+1][j  ][k+1]      .   .           .   .  *  b6: t->sw[i  ][j+1][k+1]      .     .       .     .  *  b7: t->sw[i+1][j+1][k+1]      .       .   .       .  *                                .         O         .  *                                O         .         O  *                                  .       .       .  *                                    .     .     .  *                                      .   .   .  *                                        . . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x708
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x708
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x710:                           O  *                                        . . .  *  b0: t->sw[i  ][j  ][k  ]            .   .   .  *  b1: t->sw[i+1][j  ][k  ]          .     .     .  *  b2: t->sw[i  ][j+1][k  ]        .       .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4:                           .         O         .  *  b5: t->sw[i+1][j  ][k+1]      .       .   .       .  *  b6: t->sw[i  ][j+1][k+1]      .     .       .     .  *  b7: t->sw[i+1][j+1][k+1]      .   .           .   .  *                                . .       O       . .  *                                O                   O  *                                  .               .  *                                    .           .  *                                      .       .  *                                        .   .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x710
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x710
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x720:                           O  *                                        . .  *  b0: t->sw[i  ][j  ][k  ]            .   .  *  b1: t->sw[i+1][j  ][k  ]          .     .  *  b2: t->sw[i  ][j+1][k  ]        .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4: t->sw[i  ][j  ][k+1]      . .       O  *  b5:                           .   .   .   .  *  b6: t->sw[i  ][j+1][k+1]      .     .       .  *  b7: t->sw[i+1][j+1][k+1]      .   .   .       .  *                                . .       O       .  *                                O         .         O  *                                  .       .       .  *                                    .     .     .  *                                      .   .   .  *                                        . . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x720
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x720
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x740:                           O  *                                          . .  *  b0: t->sw[i  ][j  ][k  ]                .   .  *  b1: t->sw[i+1][j  ][k  ]                .     .  *  b2: t->sw[i  ][j+1][k  ]                .       .  *  b3: t->sw[i+1][j+1][k  ]      O         .         O  *  b4: t->sw[i  ][j  ][k+1]                O       . .  *  b5: t->sw[i+1][j  ][k+1]              .   .   .   .  *  b6:                                 .       .     .  *  b7: t->sw[i+1][j+1][k+1]          .       .   .   .  *                                  .       O       . .  *                                O         .         O  *                                  .       .       .  *                                    .     .     .  *                                      .   .   .  *                                        . . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x740
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x740
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * 3D case 0x780:                           O  *  *  b0: t->sw[i  ][j  ][k  ]  *  b1: t->sw[i+1][j  ][k  ]  *  b2: t->sw[i  ][j+1][k  ]  *  b3: t->sw[i+1][j+1][k  ]      O                   O  *  b4: t->sw[i  ][j  ][k+1]      . .       O       . .  *  b5: t->sw[i+1][j  ][k+1]      .   .   .   .   .   .  *  b6: t->sw[i  ][j+1][k+1]      .     .       .     .  *  b7:                           .   .   .   .   .   .  *                                . .       O       . .  *                                O         .         O  *                                  .       .       .  *                                    .     .     .  *                                      .   .   .  *                                        . . .  *                                          @  */
end_comment

begin_function
specifier|static
name|bool
name|handle_case_0x780
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|,
name|tfind_face_corner
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|t
operator|->
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|true
return|;
block|}
name|log_no_crnr
argument_list|(
name|t
argument_list|,
literal|0x780
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|ip1
argument_list|,
name|jp1
argument_list|,
name|kp1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * Make sure links between all known torus/mesh switches are installed.  *  * We don't have to worry about links that wrap on a mesh coordinate, as  * there shouldn't be any; if there are it indicates an input error.  */
end_comment

begin_function
specifier|static
name|void
name|check_tlinks
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|struct
name|t_switch
modifier|*
modifier|*
modifier|*
modifier|*
name|sw
init|=
name|t
operator|->
name|sw
decl_stmt|;
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
comment|/* 	 * Don't waste time/code checking return status of link_tswitches() 	 * here.  It is unlikely to fail, and the result of any failure here 	 * will be caught elsewhere anyway. 	 */
if|if
condition|(
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|&&
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
condition|)
name|link_tswitches
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
operator|&&
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
condition|)
name|link_tswitches
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
operator|&&
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
condition|)
name|link_tswitches
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
operator|&&
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
condition|)
name|link_tswitches
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|,
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|&&
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
condition|)
name|link_tswitches
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|&&
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
condition|)
name|link_tswitches
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
operator|&&
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
condition|)
name|link_tswitches
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
operator|&&
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
condition|)
name|link_tswitches
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|,
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|&&
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
condition|)
name|link_tswitches
argument_list|(
name|t
argument_list|,
literal|2
argument_list|,
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|&&
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
condition|)
name|link_tswitches
argument_list|(
name|t
argument_list|,
literal|2
argument_list|,
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|sw
index|[
name|ip1
index|]
index|[
name|j
index|]
index|[
name|kp1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
operator|&&
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
condition|)
name|link_tswitches
argument_list|(
name|t
argument_list|,
literal|2
argument_list|,
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|sw
index|[
name|i
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
operator|&&
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
condition|)
name|link_tswitches
argument_list|(
name|t
argument_list|,
literal|2
argument_list|,
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|k
index|]
argument_list|,
name|sw
index|[
name|ip1
index|]
index|[
name|jp1
index|]
index|[
name|kp1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|locate_sw
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|)
block|{
name|unsigned
name|fp
decl_stmt|;
name|bool
name|success
decl_stmt|;
name|i
operator|=
name|canonicalize
argument_list|(
name|i
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
expr_stmt|;
name|j
operator|=
name|canonicalize
argument_list|(
name|j
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
expr_stmt|;
name|k
operator|=
name|canonicalize
argument_list|(
name|k
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
expr_stmt|;
comment|/* 	 * By definition, if a coordinate direction is meshed, we don't 	 * allow it to wrap to zero. 	 */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|X_MESH
condition|)
block|{
name|int
name|ip1
init|=
name|canonicalize
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|ip1
operator|<
name|i
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|Y_MESH
condition|)
block|{
name|int
name|jp1
init|=
name|canonicalize
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|jp1
operator|<
name|j
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|Z_MESH
condition|)
block|{
name|int
name|kp1
init|=
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
decl_stmt|;
if|if
condition|(
name|kp1
operator|<
name|k
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* 	 * There are various reasons that the links are not installed between 	 * known torus switches.  These include cases where the search for 	 * new switches only partially succeeds due to missing switches, and 	 * cases where we haven't processed this position yet, but processing 	 * of multiple independent neighbor positions has installed switches 	 * into corners of our case. 	 * 	 * In any event, the topology assumptions made in handling the 	 * fingerprint for this position require that all links be installed 	 * between installed switches for this position. 	 */
name|again
label|:
name|check_tlinks
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fingerprint
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fp
condition|)
block|{
comment|/* 	 * When all switches are present, we are done.  Otherwise, one of 	 * the cases below will be unsuccessful, and we'll be done also. 	 * 	 * Note that check_tlinks() above will ensure all links that are 	 * present are connected, in the event that all our switches are 	 * present due to successful case handling in the surrounding 	 * torus/mesh. 	 */
case|case
literal|0x300
case|:
case|case
literal|0x500
case|:
case|case
literal|0x600
case|:
case|case
literal|0x700
case|:
goto|goto
name|out
goto|;
comment|/* 	 * Ignore the 2D cases where there isn't enough information to uniquely 	 * locate/place a switch into the cube. 	 */
case|case
literal|0x30f
case|:
comment|/* 0 corners available */
case|case
literal|0x533
case|:
comment|/* 0 corners available */
case|case
literal|0x655
case|:
comment|/* 0 corners available */
case|case
literal|0x30e
case|:
comment|/* 1 corner available */
case|case
literal|0x532
case|:
comment|/* 1 corner available */
case|case
literal|0x654
case|:
comment|/* 1 corner available */
case|case
literal|0x30d
case|:
comment|/* 1 corner available */
case|case
literal|0x531
case|:
comment|/* 1 corner available */
case|case
literal|0x651
case|:
comment|/* 1 corner available */
case|case
literal|0x30b
case|:
comment|/* 1 corner available */
case|case
literal|0x523
case|:
comment|/* 1 corner available */
case|case
literal|0x645
case|:
comment|/* 1 corner available */
case|case
literal|0x307
case|:
comment|/* 1 corner available */
case|case
literal|0x513
case|:
comment|/* 1 corner available */
case|case
literal|0x615
case|:
comment|/* 1 corner available */
goto|goto
name|out
goto|;
comment|/* 	 * Handle the 2D cases with a single existing edge. 	 * 	 */
case|case
literal|0x30c
case|:
name|success
operator|=
name|handle_case_0x30c
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x303
case|:
name|success
operator|=
name|handle_case_0x303
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x305
case|:
name|success
operator|=
name|handle_case_0x305
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x30a
case|:
name|success
operator|=
name|handle_case_0x30a
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x503
case|:
name|success
operator|=
name|handle_case_0x503
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x511
case|:
name|success
operator|=
name|handle_case_0x511
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x522
case|:
name|success
operator|=
name|handle_case_0x522
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x530
case|:
name|success
operator|=
name|handle_case_0x530
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x605
case|:
name|success
operator|=
name|handle_case_0x605
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x611
case|:
name|success
operator|=
name|handle_case_0x611
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x644
case|:
name|success
operator|=
name|handle_case_0x644
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x650
case|:
name|success
operator|=
name|handle_case_0x650
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Handle the 2D cases where two existing edges meet at a corner. 	 */
case|case
literal|0x301
case|:
name|success
operator|=
name|handle_case_0x301
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x302
case|:
name|success
operator|=
name|handle_case_0x302
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x304
case|:
name|success
operator|=
name|handle_case_0x304
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x308
case|:
name|success
operator|=
name|handle_case_0x308
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x501
case|:
name|success
operator|=
name|handle_case_0x501
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x502
case|:
name|success
operator|=
name|handle_case_0x502
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x520
case|:
name|success
operator|=
name|handle_case_0x520
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x510
case|:
name|success
operator|=
name|handle_case_0x510
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x601
case|:
name|success
operator|=
name|handle_case_0x601
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x604
case|:
name|success
operator|=
name|handle_case_0x604
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x610
case|:
name|success
operator|=
name|handle_case_0x610
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x640
case|:
name|success
operator|=
name|handle_case_0x640
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Ignore the 3D cases where there isn't enough information to uniquely 	 * locate/place a switch into the cube. 	 */
case|case
literal|0x7ff
case|:
comment|/* 0 corners available */
case|case
literal|0x7fe
case|:
comment|/* 1 corner available */
case|case
literal|0x7fd
case|:
comment|/* 1 corner available */
case|case
literal|0x7fb
case|:
comment|/* 1 corner available */
case|case
literal|0x7f7
case|:
comment|/* 1 corner available */
case|case
literal|0x7ef
case|:
comment|/* 1 corner available */
case|case
literal|0x7df
case|:
comment|/* 1 corner available */
case|case
literal|0x7bf
case|:
comment|/* 1 corner available */
case|case
literal|0x77f
case|:
comment|/* 1 corner available */
case|case
literal|0x7fc
case|:
comment|/* 2 adj corners available */
case|case
literal|0x7fa
case|:
comment|/* 2 adj corners available */
case|case
literal|0x7f5
case|:
comment|/* 2 adj corners available */
case|case
literal|0x7f3
case|:
comment|/* 2 adj corners available */
case|case
literal|0x7cf
case|:
comment|/* 2 adj corners available */
case|case
literal|0x7af
case|:
comment|/* 2 adj corners available */
case|case
literal|0x75f
case|:
comment|/* 2 adj corners available */
case|case
literal|0x73f
case|:
comment|/* 2 adj corners available */
case|case
literal|0x7ee
case|:
comment|/* 2 adj corners available */
case|case
literal|0x7dd
case|:
comment|/* 2 adj corners available */
case|case
literal|0x7bb
case|:
comment|/* 2 adj corners available */
case|case
literal|0x777
case|:
comment|/* 2 adj corners available */
goto|goto
name|out
goto|;
comment|/* 	 * Handle the 3D cases where two existing edges meet at a corner. 	 * 	 */
case|case
literal|0x71f
case|:
name|success
operator|=
name|handle_case_0x71f
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x72f
case|:
name|success
operator|=
name|handle_case_0x72f
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x737
case|:
name|success
operator|=
name|handle_case_0x737
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x73b
case|:
name|success
operator|=
name|handle_case_0x73b
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x74f
case|:
name|success
operator|=
name|handle_case_0x74f
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x757
case|:
name|success
operator|=
name|handle_case_0x757
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x75d
case|:
name|success
operator|=
name|handle_case_0x75d
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x773
case|:
name|success
operator|=
name|handle_case_0x773
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x775
case|:
name|success
operator|=
name|handle_case_0x775
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x78f
case|:
name|success
operator|=
name|handle_case_0x78f
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7ab
case|:
name|success
operator|=
name|handle_case_0x7ab
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7ae
case|:
name|success
operator|=
name|handle_case_0x7ae
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7b3
case|:
name|success
operator|=
name|handle_case_0x7b3
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7ba
case|:
name|success
operator|=
name|handle_case_0x7ba
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7cd
case|:
name|success
operator|=
name|handle_case_0x7cd
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7ce
case|:
name|success
operator|=
name|handle_case_0x7ce
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7d5
case|:
name|success
operator|=
name|handle_case_0x7d5
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7dc
case|:
name|success
operator|=
name|handle_case_0x7dc
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7ea
case|:
name|success
operator|=
name|handle_case_0x7ea
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7ec
case|:
name|success
operator|=
name|handle_case_0x7ec
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7f1
case|:
name|success
operator|=
name|handle_case_0x7f1
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7f2
case|:
name|success
operator|=
name|handle_case_0x7f2
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7f4
case|:
name|success
operator|=
name|handle_case_0x7f4
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7f8
case|:
name|success
operator|=
name|handle_case_0x7f8
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Handle the cases where three existing edges meet at a corner. 	 * 	 */
case|case
literal|0x717
case|:
name|success
operator|=
name|handle_case_0x717
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x72b
case|:
name|success
operator|=
name|handle_case_0x72b
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x74d
case|:
name|success
operator|=
name|handle_case_0x74d
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x771
case|:
name|success
operator|=
name|handle_case_0x771
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x78e
case|:
name|success
operator|=
name|handle_case_0x78e
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7b2
case|:
name|success
operator|=
name|handle_case_0x7b2
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7d4
case|:
name|success
operator|=
name|handle_case_0x7d4
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7e8
case|:
name|success
operator|=
name|handle_case_0x7e8
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Handle the cases where four corners on a single face are missing. 	 */
case|case
literal|0x70f
case|:
name|success
operator|=
name|handle_case_0x70f
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x733
case|:
name|success
operator|=
name|handle_case_0x733
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x755
case|:
name|success
operator|=
name|handle_case_0x755
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7aa
case|:
name|success
operator|=
name|handle_case_0x7aa
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7cc
case|:
name|success
operator|=
name|handle_case_0x7cc
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7f0
case|:
name|success
operator|=
name|handle_case_0x7f0
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Handle the cases where three corners on a single face are missing. 	 */
case|case
literal|0x707
case|:
name|success
operator|=
name|handle_case_0x707
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x70b
case|:
name|success
operator|=
name|handle_case_0x70b
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x70d
case|:
name|success
operator|=
name|handle_case_0x70d
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x70e
case|:
name|success
operator|=
name|handle_case_0x70e
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x713
case|:
name|success
operator|=
name|handle_case_0x713
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x715
case|:
name|success
operator|=
name|handle_case_0x715
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x723
case|:
name|success
operator|=
name|handle_case_0x723
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x72a
case|:
name|success
operator|=
name|handle_case_0x72a
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x731
case|:
name|success
operator|=
name|handle_case_0x731
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x732
case|:
name|success
operator|=
name|handle_case_0x732
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x745
case|:
name|success
operator|=
name|handle_case_0x745
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x74c
case|:
name|success
operator|=
name|handle_case_0x74c
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x751
case|:
name|success
operator|=
name|handle_case_0x751
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x754
case|:
name|success
operator|=
name|handle_case_0x754
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x770
case|:
name|success
operator|=
name|handle_case_0x770
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x78a
case|:
name|success
operator|=
name|handle_case_0x78a
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x78c
case|:
name|success
operator|=
name|handle_case_0x78c
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7a2
case|:
name|success
operator|=
name|handle_case_0x7a2
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7a8
case|:
name|success
operator|=
name|handle_case_0x7a8
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7b0
case|:
name|success
operator|=
name|handle_case_0x7b0
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7c4
case|:
name|success
operator|=
name|handle_case_0x7c4
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7c8
case|:
name|success
operator|=
name|handle_case_0x7c8
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7d0
case|:
name|success
operator|=
name|handle_case_0x7d0
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7e0
case|:
name|success
operator|=
name|handle_case_0x7e0
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Handle the cases where two corners on a single edge are missing. 	 */
case|case
literal|0x703
case|:
name|success
operator|=
name|handle_case_0x703
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x705
case|:
name|success
operator|=
name|handle_case_0x705
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x70a
case|:
name|success
operator|=
name|handle_case_0x70a
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x70c
case|:
name|success
operator|=
name|handle_case_0x70c
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x711
case|:
name|success
operator|=
name|handle_case_0x711
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x722
case|:
name|success
operator|=
name|handle_case_0x722
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x730
case|:
name|success
operator|=
name|handle_case_0x730
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x744
case|:
name|success
operator|=
name|handle_case_0x744
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x750
case|:
name|success
operator|=
name|handle_case_0x750
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x788
case|:
name|success
operator|=
name|handle_case_0x788
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7a0
case|:
name|success
operator|=
name|handle_case_0x7a0
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7c0
case|:
name|success
operator|=
name|handle_case_0x7c0
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Handle the cases where a single corner is missing. 	 */
case|case
literal|0x701
case|:
name|success
operator|=
name|handle_case_0x701
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x702
case|:
name|success
operator|=
name|handle_case_0x702
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x704
case|:
name|success
operator|=
name|handle_case_0x704
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x708
case|:
name|success
operator|=
name|handle_case_0x708
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x710
case|:
name|success
operator|=
name|handle_case_0x710
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x720
case|:
name|success
operator|=
name|handle_case_0x720
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x740
case|:
name|success
operator|=
name|handle_case_0x740
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x780
case|:
name|success
operator|=
name|handle_case_0x780
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 		 * There's lots of unhandled cases still, but it's not clear 		 * we care.  Let debugging show us what they are so we can 		 * learn if we care. 		 */
if|if
condition|(
name|t
operator|->
name|debug
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"Unhandled fingerprint 0x%03x @ %d %d %d\n"
argument_list|,
name|fp
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * If we successfully handled a case, we may be able to make more 	 * progress at this position, so try again.  Otherwise, even though 	 * we didn't successfully handle a case, we may have installed a 	 * switch into the torus/mesh, so try to install links as well. 	 * Then we'll have another go at the next position. 	 */
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|debug
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"Success on fingerprint 0x%03x @ %d %d %d\n"
argument_list|,
name|fp
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
else|else
block|{
name|check_tlinks
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|debug
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"Failed on fingerprint 0x%03x @ %d %d %d\n"
argument_list|,
name|fp
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return;
block|}
end_function

begin_define
define|#
directive|define
name|LINK_ERR_STR
value|" direction link required for topology seed configuration since radix == 4! See torus-2QoS.conf(5).\n"
end_define

begin_define
define|#
directive|define
name|LINK_ERR2_STR
value|" direction link required for topology seed configuration! See torus-2QoS.conf(5).\n"
end_define

begin_define
define|#
directive|define
name|SEED_ERR_STR
value|" direction links for topology seed do not share a common switch! See torus-2QoS.conf(5).\n"
end_define

begin_function
specifier|static
name|bool
name|verify_setup
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|struct
name|fabric
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|coord_dirs
modifier|*
name|o
decl_stmt|;
name|struct
name|f_switch
modifier|*
name|sw
decl_stmt|;
name|unsigned
name|p
decl_stmt|,
name|s
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|;
name|bool
name|success
init|=
name|false
decl_stmt|;
name|bool
name|all_sw_present
decl_stmt|,
name|need_seed
init|=
name|true
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|x_sz
operator|&&
name|t
operator|->
name|y_sz
operator|&&
name|t
operator|->
name|z_sz
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E20: missing required torus size specification!\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|t
operator|->
name|osm
operator|->
name|subn
operator|.
name|min_sw_data_vls
operator|<
literal|2
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E48: Too few data VLs to support torus routing "
literal|"without credit loops (have switchport %d need 2)\n"
argument_list|,
operator|(
name|int
operator|)
name|t
operator|->
name|osm
operator|->
name|subn
operator|.
name|min_sw_data_vls
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|t
operator|->
name|osm
operator|->
name|subn
operator|.
name|min_sw_data_vls
operator|<
literal|4
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Warning: Too few data VLs to support torus routing "
literal|"with a failed switch without credit loops "
literal|"(have switchport %d need 4)\n"
argument_list|,
operator|(
name|int
operator|)
name|t
operator|->
name|osm
operator|->
name|subn
operator|.
name|min_sw_data_vls
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|osm
operator|->
name|subn
operator|.
name|min_sw_data_vls
operator|<
literal|8
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Warning: Too few data VLs to support torus routing "
literal|"with two QoS levels (have switchport %d need 8)\n"
argument_list|,
operator|(
name|int
operator|)
name|t
operator|->
name|osm
operator|->
name|subn
operator|.
name|min_sw_data_vls
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|osm
operator|->
name|subn
operator|.
name|min_data_vls
operator|<
literal|2
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Warning: Too few data VLs to support torus routing "
literal|"with two QoS levels (have endport %d need 2)\n"
argument_list|,
operator|(
name|int
operator|)
name|t
operator|->
name|osm
operator|->
name|subn
operator|.
name|min_data_vls
argument_list|)
expr_stmt|;
comment|/* 	 * Be sure all the switches in the torus support the port 	 * ordering that might have been configured. 	 */
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|f
operator|->
name|switch_cnt
condition|;
name|s
operator|++
control|)
block|{
name|sw
operator|=
name|f
operator|->
name|sw
index|[
name|s
index|]
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|sw
operator|->
name|port_cnt
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|t
operator|->
name|port_order
index|[
name|p
index|]
operator|>=
name|sw
operator|->
name|port_cnt
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E21: port_order configured using "
literal|"port %u, but only %u ports in "
literal|"switch w/ GUID 0x%04"
name|PRIx64
literal|"\n"
argument_list|,
name|t
operator|->
name|port_order
index|[
name|p
index|]
argument_list|,
name|sw
operator|->
name|port_cnt
operator|-
literal|1
argument_list|,
name|cl_ntoh64
argument_list|(
name|sw
operator|->
name|n_id
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
comment|/* 	 * Unfortunately, there is a problem with non-unique topology for any 	 * torus dimension which has radix four.  This problem requires extra 	 * input, in the form of specifying both the positive and negative 	 * coordinate directions from a common switch, for any torus dimension 	 * with radix four (see also build_torus()). 	 * 	 * Do the checking required to ensure that the required information 	 * is present, but more than the needed information is not required. 	 * 	 * So, verify that we learned the coordinate directions correctly for 	 * the fabric.  The coordinate direction links get an invalid port 	 * set on their ends when parsed. 	 */
name|again
label|:
name|all_sw_present
operator|=
name|true
expr_stmt|;
name|o
operator|=
operator|&
name|t
operator|->
name|seed
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|x_sz
operator|==
literal|4
operator|&&
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|X_MESH
operator|)
condition|)
block|{
if|if
condition|(
name|o
operator|->
name|xp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|>=
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E22: Positive x"
name|LINK_ERR_STR
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|o
operator|->
name|xm_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|>=
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E23: Negative x"
name|LINK_ERR_STR
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|o
operator|->
name|xp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|!=
name|o
operator|->
name|xm_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E24: Positive/negative x"
name|SEED_ERR_STR
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|t
operator|->
name|y_sz
operator|==
literal|4
operator|&&
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|Y_MESH
operator|)
condition|)
block|{
if|if
condition|(
name|o
operator|->
name|yp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|>=
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E25: Positive y"
name|LINK_ERR_STR
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|o
operator|->
name|ym_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|>=
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E26: Negative y"
name|LINK_ERR_STR
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|o
operator|->
name|yp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|!=
name|o
operator|->
name|ym_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E27: Positive/negative y"
name|SEED_ERR_STR
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|t
operator|->
name|z_sz
operator|==
literal|4
operator|&&
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|Z_MESH
operator|)
condition|)
block|{
if|if
condition|(
name|o
operator|->
name|zp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|>=
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E28: Positive z"
name|LINK_ERR_STR
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|o
operator|->
name|zm_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|>=
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E29: Negative z"
name|LINK_ERR_STR
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|o
operator|->
name|zp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|!=
name|o
operator|->
name|zm_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E2A: Positive/negative z"
name|SEED_ERR_STR
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|t
operator|->
name|x_sz
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|o
operator|->
name|xp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|>=
literal|0
operator|&&
name|o
operator|->
name|xm_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|>=
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E2B: Positive or negative x"
name|LINK_ERR2_STR
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|o
operator|->
name|xp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
operator|!
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|o
operator|->
name|xp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
argument_list|)
condition|)
name|all_sw_present
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|xp_link
operator|.
name|end
index|[
literal|1
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
operator|!
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|o
operator|->
name|xp_link
operator|.
name|end
index|[
literal|1
index|]
operator|.
name|n_id
argument_list|)
condition|)
name|all_sw_present
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|xm_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
operator|!
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|o
operator|->
name|xm_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
argument_list|)
condition|)
name|all_sw_present
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|xm_link
operator|.
name|end
index|[
literal|1
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
operator|!
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|o
operator|->
name|xm_link
operator|.
name|end
index|[
literal|1
index|]
operator|.
name|n_id
argument_list|)
condition|)
name|all_sw_present
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|z_sz
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|o
operator|->
name|zp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|>=
literal|0
operator|&&
name|o
operator|->
name|zm_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|>=
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E2C: Positive or negative z"
name|LINK_ERR2_STR
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|o
operator|->
name|xp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
name|o
operator|->
name|zp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
name|o
operator|->
name|zp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|!=
name|o
operator|->
name|xp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|)
operator|||
operator|(
name|o
operator|->
name|xp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
name|o
operator|->
name|zm_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
name|o
operator|->
name|zm_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|!=
name|o
operator|->
name|xp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|)
operator|||
operator|(
name|o
operator|->
name|xm_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
name|o
operator|->
name|zp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
name|o
operator|->
name|zp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|!=
name|o
operator|->
name|xm_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|)
operator|||
operator|(
name|o
operator|->
name|xm_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
name|o
operator|->
name|zm_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
name|o
operator|->
name|zm_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|!=
name|o
operator|->
name|xm_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E2D: x and z"
name|SEED_ERR_STR
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|o
operator|->
name|zp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
operator|!
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|o
operator|->
name|zp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
argument_list|)
condition|)
name|all_sw_present
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|zp_link
operator|.
name|end
index|[
literal|1
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
operator|!
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|o
operator|->
name|zp_link
operator|.
name|end
index|[
literal|1
index|]
operator|.
name|n_id
argument_list|)
condition|)
name|all_sw_present
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|zm_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
operator|!
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|o
operator|->
name|zm_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
argument_list|)
condition|)
name|all_sw_present
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|zm_link
operator|.
name|end
index|[
literal|1
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
operator|!
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|o
operator|->
name|zm_link
operator|.
name|end
index|[
literal|1
index|]
operator|.
name|n_id
argument_list|)
condition|)
name|all_sw_present
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|y_sz
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|o
operator|->
name|yp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|>=
literal|0
operator|&&
name|o
operator|->
name|ym_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|>=
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E2E: Positive or negative y"
name|LINK_ERR2_STR
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|o
operator|->
name|xp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
name|o
operator|->
name|yp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
name|o
operator|->
name|yp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|!=
name|o
operator|->
name|xp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|)
operator|||
operator|(
name|o
operator|->
name|xp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
name|o
operator|->
name|ym_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
name|o
operator|->
name|ym_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|!=
name|o
operator|->
name|xp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|)
operator|||
operator|(
name|o
operator|->
name|xm_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
name|o
operator|->
name|yp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
name|o
operator|->
name|yp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|!=
name|o
operator|->
name|xm_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|)
operator|||
operator|(
name|o
operator|->
name|xm_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
name|o
operator|->
name|ym_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
name|o
operator|->
name|ym_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|!=
name|o
operator|->
name|xm_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E2F: x and y"
name|SEED_ERR_STR
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|o
operator|->
name|yp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
operator|!
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|o
operator|->
name|yp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
argument_list|)
condition|)
name|all_sw_present
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|yp_link
operator|.
name|end
index|[
literal|1
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
operator|!
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|o
operator|->
name|yp_link
operator|.
name|end
index|[
literal|1
index|]
operator|.
name|n_id
argument_list|)
condition|)
name|all_sw_present
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|ym_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
operator|!
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|o
operator|->
name|ym_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
argument_list|)
condition|)
name|all_sw_present
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|ym_link
operator|.
name|end
index|[
literal|1
index|]
operator|.
name|port
operator|<
literal|0
operator|&&
operator|!
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|o
operator|->
name|ym_link
operator|.
name|end
index|[
literal|1
index|]
operator|.
name|n_id
argument_list|)
condition|)
name|all_sw_present
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|all_sw_present
operator|&&
name|need_seed
condition|)
block|{
name|t
operator|->
name|seed_idx
operator|=
name|n
expr_stmt|;
name|need_seed
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|n
operator|<
name|t
operator|->
name|seed_cnt
condition|)
goto|goto
name|again
goto|;
if|if
condition|(
name|need_seed
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E30: Every configured torus seed has at "
literal|"least one switch missing in fabric! See "
literal|"torus-2QoS.conf(5) and TORUS TOPOLOGY DISCOVERY "
literal|"in torus-2QoS(8)\n"
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
name|true
expr_stmt|;
name|out
label|:
return|return
name|success
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|build_torus
parameter_list|(
name|struct
name|fabric
modifier|*
name|f
parameter_list|,
name|struct
name|torus
modifier|*
name|t
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|im1
decl_stmt|,
name|jm1
decl_stmt|,
name|km1
decl_stmt|;
name|int
name|ip1
decl_stmt|,
name|jp1
decl_stmt|,
name|kp1
decl_stmt|;
name|unsigned
name|nlink
decl_stmt|;
name|struct
name|coord_dirs
modifier|*
name|o
decl_stmt|;
name|struct
name|f_switch
modifier|*
name|fsw0
decl_stmt|,
modifier|*
name|fsw1
decl_stmt|;
name|struct
name|t_switch
modifier|*
modifier|*
modifier|*
modifier|*
name|sw
init|=
name|t
operator|->
name|sw
decl_stmt|;
name|bool
name|success
init|=
name|true
decl_stmt|;
name|t
operator|->
name|link_pool_sz
operator|=
name|f
operator|->
name|link_cnt
expr_stmt|;
name|t
operator|->
name|link_pool
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|t
operator|->
name|link_pool_sz
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|t
operator|->
name|link_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|link_pool
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E31: Allocating torus link pool: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|t
operator|->
name|fabric
operator|=
name|f
expr_stmt|;
comment|/* 	 * Get things started by locating the up to seven switches that 	 * define the torus "seed", coordinate directions, and datelines. 	 */
name|o
operator|=
operator|&
name|t
operator|->
name|seed
index|[
name|t
operator|->
name|seed_idx
index|]
expr_stmt|;
name|i
operator|=
name|canonicalize
argument_list|(
operator|-
name|o
operator|->
name|x_dateline
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
expr_stmt|;
name|j
operator|=
name|canonicalize
argument_list|(
operator|-
name|o
operator|->
name|y_dateline
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
expr_stmt|;
name|k
operator|=
name|canonicalize
argument_list|(
operator|-
name|o
operator|->
name|z_dateline
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|xp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
condition|)
block|{
name|ip1
operator|=
name|canonicalize
argument_list|(
literal|1
operator|-
name|o
operator|->
name|x_dateline
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
expr_stmt|;
name|fsw0
operator|=
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|o
operator|->
name|xp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
argument_list|)
expr_stmt|;
name|fsw1
operator|=
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|o
operator|->
name|xp_link
operator|.
name|end
index|[
literal|1
index|]
operator|.
name|n_id
argument_list|)
expr_stmt|;
name|success
operator|=
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|fsw0
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|ip1
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|fsw1
argument_list|)
operator|&&
name|success
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|->
name|xm_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
condition|)
block|{
name|im1
operator|=
name|canonicalize
argument_list|(
operator|-
literal|1
operator|-
name|o
operator|->
name|x_dateline
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
expr_stmt|;
name|fsw0
operator|=
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|o
operator|->
name|xm_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
argument_list|)
expr_stmt|;
name|fsw1
operator|=
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|o
operator|->
name|xm_link
operator|.
name|end
index|[
literal|1
index|]
operator|.
name|n_id
argument_list|)
expr_stmt|;
name|success
operator|=
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|fsw0
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|im1
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|fsw1
argument_list|)
operator|&&
name|success
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|->
name|yp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
condition|)
block|{
name|jp1
operator|=
name|canonicalize
argument_list|(
literal|1
operator|-
name|o
operator|->
name|y_dateline
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
expr_stmt|;
name|fsw0
operator|=
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|o
operator|->
name|yp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
argument_list|)
expr_stmt|;
name|fsw1
operator|=
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|o
operator|->
name|yp_link
operator|.
name|end
index|[
literal|1
index|]
operator|.
name|n_id
argument_list|)
expr_stmt|;
name|success
operator|=
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|fsw0
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jp1
argument_list|,
name|k
argument_list|,
name|fsw1
argument_list|)
operator|&&
name|success
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|->
name|ym_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
condition|)
block|{
name|jm1
operator|=
name|canonicalize
argument_list|(
operator|-
literal|1
operator|-
name|o
operator|->
name|y_dateline
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
expr_stmt|;
name|fsw0
operator|=
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|o
operator|->
name|ym_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
argument_list|)
expr_stmt|;
name|fsw1
operator|=
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|o
operator|->
name|ym_link
operator|.
name|end
index|[
literal|1
index|]
operator|.
name|n_id
argument_list|)
expr_stmt|;
name|success
operator|=
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|fsw0
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|jm1
argument_list|,
name|k
argument_list|,
name|fsw1
argument_list|)
operator|&&
name|success
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|->
name|zp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
condition|)
block|{
name|kp1
operator|=
name|canonicalize
argument_list|(
literal|1
operator|-
name|o
operator|->
name|z_dateline
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
expr_stmt|;
name|fsw0
operator|=
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|o
operator|->
name|zp_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
argument_list|)
expr_stmt|;
name|fsw1
operator|=
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|o
operator|->
name|zp_link
operator|.
name|end
index|[
literal|1
index|]
operator|.
name|n_id
argument_list|)
expr_stmt|;
name|success
operator|=
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|fsw0
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|kp1
argument_list|,
name|fsw1
argument_list|)
operator|&&
name|success
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|->
name|zm_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|port
operator|<
literal|0
condition|)
block|{
name|km1
operator|=
name|canonicalize
argument_list|(
operator|-
literal|1
operator|-
name|o
operator|->
name|z_dateline
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
expr_stmt|;
name|fsw0
operator|=
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|o
operator|->
name|zm_link
operator|.
name|end
index|[
literal|0
index|]
operator|.
name|n_id
argument_list|)
expr_stmt|;
name|fsw1
operator|=
name|find_f_sw
argument_list|(
name|f
argument_list|,
name|o
operator|->
name|zm_link
operator|.
name|end
index|[
literal|1
index|]
operator|.
name|n_id
argument_list|)
expr_stmt|;
name|success
operator|=
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|fsw0
argument_list|)
operator|&&
name|install_tswitch
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|km1
argument_list|,
name|fsw1
argument_list|)
operator|&&
name|success
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|success
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|t
operator|->
name|seed_idx
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Using torus seed configured as default "
literal|"(seed sw %d,%d,%d GUID 0x%04"
name|PRIx64
literal|").\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|cl_ntoh64
argument_list|(
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|->
name|n_id
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Using torus seed configured as backup #%u "
literal|"(seed sw %d,%d,%d GUID 0x%04"
name|PRIx64
literal|").\n"
argument_list|,
name|t
operator|->
name|seed_idx
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|cl_ntoh64
argument_list|(
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|->
name|n_id
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Search the fabric and construct the expected torus topology. 	 * 	 * The algorithm is to consider the "cube" formed by eight switch 	 * locations bounded by the corners i, j, k and i+1, j+1, k+1. 	 * For each such cube look at the topology of the switches already 	 * placed in the torus, and deduce which new switches can be placed 	 * into their proper locations in the torus.  Examine each cube 	 * multiple times, until the number of links moved into the torus 	 * topology does not change. 	 */
name|again
label|:
name|nlink
operator|=
name|t
operator|->
name|link_cnt
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
operator|(
name|int
operator|)
name|t
operator|->
name|z_sz
condition|;
name|k
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|int
operator|)
name|t
operator|->
name|y_sz
condition|;
name|j
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|t
operator|->
name|x_sz
condition|;
name|i
operator|++
control|)
name|locate_sw
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|link_cnt
operator|!=
name|nlink
condition|)
goto|goto
name|again
goto|;
comment|/* 	 * Move all other endpoints into torus/mesh. 	 */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
operator|(
name|int
operator|)
name|t
operator|->
name|z_sz
condition|;
name|k
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|int
operator|)
name|t
operator|->
name|y_sz
condition|;
name|j
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|t
operator|->
name|x_sz
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|link_srcsink
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
condition|)
block|{
name|success
operator|=
name|false
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/*  * Returns a count of differences between old and new switches.  */
end_comment

begin_function
specifier|static
name|unsigned
name|tsw_changes
parameter_list|(
name|struct
name|t_switch
modifier|*
name|nsw
parameter_list|,
name|struct
name|t_switch
modifier|*
name|osw
parameter_list|)
block|{
name|unsigned
name|p
decl_stmt|,
name|cnt
init|=
literal|0
decl_stmt|,
name|port_cnt
decl_stmt|;
name|struct
name|endpoint
modifier|*
name|npt
decl_stmt|,
modifier|*
name|opt
decl_stmt|;
name|struct
name|endpoint
modifier|*
name|rnpt
decl_stmt|,
modifier|*
name|ropt
decl_stmt|;
if|if
condition|(
name|nsw
operator|&&
operator|!
name|osw
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|nsw
operator|->
name|torus
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"New torus switch %d,%d,%d GUID 0x%04"
name|PRIx64
literal|"\n"
argument_list|,
name|nsw
operator|->
name|i
argument_list|,
name|nsw
operator|->
name|j
argument_list|,
name|nsw
operator|->
name|k
argument_list|,
name|cl_ntoh64
argument_list|(
name|nsw
operator|->
name|n_id
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|osw
operator|&&
operator|!
name|nsw
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|osw
operator|->
name|torus
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Lost torus switch %d,%d,%d GUID 0x%04"
name|PRIx64
literal|"\n"
argument_list|,
name|osw
operator|->
name|i
argument_list|,
name|osw
operator|->
name|j
argument_list|,
name|osw
operator|->
name|k
argument_list|,
name|cl_ntoh64
argument_list|(
name|osw
operator|->
name|n_id
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|nsw
operator|&&
name|osw
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|nsw
operator|->
name|n_id
operator|!=
name|osw
operator|->
name|n_id
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|nsw
operator|->
name|torus
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Torus switch %d,%d,%d GUID "
literal|"was 0x%04"
name|PRIx64
literal|", now 0x%04"
name|PRIx64
literal|"\n"
argument_list|,
name|nsw
operator|->
name|i
argument_list|,
name|nsw
operator|->
name|j
argument_list|,
name|nsw
operator|->
name|k
argument_list|,
name|cl_ntoh64
argument_list|(
name|osw
operator|->
name|n_id
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|nsw
operator|->
name|n_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nsw
operator|->
name|port_cnt
operator|!=
name|osw
operator|->
name|port_cnt
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|nsw
operator|->
name|torus
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Torus switch %d,%d,%d GUID 0x%04"
name|PRIx64
literal|" "
literal|"had %d ports, now has %d\n"
argument_list|,
name|nsw
operator|->
name|i
argument_list|,
name|nsw
operator|->
name|j
argument_list|,
name|nsw
operator|->
name|k
argument_list|,
name|cl_ntoh64
argument_list|(
name|nsw
operator|->
name|n_id
argument_list|)
argument_list|,
name|osw
operator|->
name|port_cnt
argument_list|,
name|nsw
operator|->
name|port_cnt
argument_list|)
expr_stmt|;
block|}
name|port_cnt
operator|=
name|nsw
operator|->
name|port_cnt
expr_stmt|;
if|if
condition|(
name|port_cnt
operator|>
name|osw
operator|->
name|port_cnt
condition|)
name|port_cnt
operator|=
name|osw
operator|->
name|port_cnt
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|port_cnt
condition|;
name|p
operator|++
control|)
block|{
name|npt
operator|=
name|nsw
operator|->
name|port
index|[
name|p
index|]
expr_stmt|;
name|opt
operator|=
name|osw
operator|->
name|port
index|[
name|p
index|]
expr_stmt|;
if|if
condition|(
name|npt
operator|&&
name|npt
operator|->
name|link
condition|)
block|{
if|if
condition|(
operator|&
name|npt
operator|->
name|link
operator|->
name|end
index|[
literal|0
index|]
operator|==
name|npt
condition|)
name|rnpt
operator|=
operator|&
name|npt
operator|->
name|link
operator|->
name|end
index|[
literal|1
index|]
expr_stmt|;
else|else
name|rnpt
operator|=
operator|&
name|npt
operator|->
name|link
operator|->
name|end
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
name|rnpt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|opt
operator|&&
name|opt
operator|->
name|link
condition|)
block|{
if|if
condition|(
operator|&
name|opt
operator|->
name|link
operator|->
name|end
index|[
literal|0
index|]
operator|==
name|opt
condition|)
name|ropt
operator|=
operator|&
name|opt
operator|->
name|link
operator|->
name|end
index|[
literal|1
index|]
expr_stmt|;
else|else
name|ropt
operator|=
operator|&
name|opt
operator|->
name|link
operator|->
name|end
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
name|ropt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rnpt
operator|&&
operator|!
name|ropt
condition|)
block|{
operator|++
name|cnt
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|nsw
operator|->
name|torus
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Torus switch %d,%d,%d GUID 0x%04"
name|PRIx64
literal|"[%d] "
literal|"remote now %s GUID 0x%04"
name|PRIx64
literal|"[%d], "
literal|"was missing\n"
argument_list|,
name|nsw
operator|->
name|i
argument_list|,
name|nsw
operator|->
name|j
argument_list|,
name|nsw
operator|->
name|k
argument_list|,
name|cl_ntoh64
argument_list|(
name|nsw
operator|->
name|n_id
argument_list|)
argument_list|,
name|p
argument_list|,
name|rnpt
operator|->
name|type
operator|==
name|PASSTHRU
condition|?
literal|"sw"
else|:
literal|"node"
argument_list|,
name|cl_ntoh64
argument_list|(
name|rnpt
operator|->
name|n_id
argument_list|)
argument_list|,
name|rnpt
operator|->
name|port
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ropt
operator|&&
operator|!
name|rnpt
condition|)
block|{
operator|++
name|cnt
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|nsw
operator|->
name|torus
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Torus switch %d,%d,%d GUID 0x%04"
name|PRIx64
literal|"[%d] "
literal|"remote now missing, "
literal|"was %s GUID 0x%04"
name|PRIx64
literal|"[%d]\n"
argument_list|,
name|osw
operator|->
name|i
argument_list|,
name|osw
operator|->
name|j
argument_list|,
name|osw
operator|->
name|k
argument_list|,
name|cl_ntoh64
argument_list|(
name|nsw
operator|->
name|n_id
argument_list|)
argument_list|,
name|p
argument_list|,
name|ropt
operator|->
name|type
operator|==
name|PASSTHRU
condition|?
literal|"sw"
else|:
literal|"node"
argument_list|,
name|cl_ntoh64
argument_list|(
name|ropt
operator|->
name|n_id
argument_list|)
argument_list|,
name|ropt
operator|->
name|port
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|rnpt
operator|&&
name|ropt
operator|)
condition|)
continue|continue;
if|if
condition|(
name|rnpt
operator|->
name|n_id
operator|!=
name|ropt
operator|->
name|n_id
condition|)
block|{
operator|++
name|cnt
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|nsw
operator|->
name|torus
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Torus switch %d,%d,%d GUID 0x%04"
name|PRIx64
literal|"[%d] "
literal|"remote now %s GUID 0x%04"
name|PRIx64
literal|"[%d], "
literal|"was %s GUID 0x%04"
name|PRIx64
literal|"[%d]\n"
argument_list|,
name|nsw
operator|->
name|i
argument_list|,
name|nsw
operator|->
name|j
argument_list|,
name|nsw
operator|->
name|k
argument_list|,
name|cl_ntoh64
argument_list|(
name|nsw
operator|->
name|n_id
argument_list|)
argument_list|,
name|p
argument_list|,
name|rnpt
operator|->
name|type
operator|==
name|PASSTHRU
condition|?
literal|"sw"
else|:
literal|"node"
argument_list|,
name|cl_ntoh64
argument_list|(
name|rnpt
operator|->
name|n_id
argument_list|)
argument_list|,
name|rnpt
operator|->
name|port
argument_list|,
name|ropt
operator|->
name|type
operator|==
name|PASSTHRU
condition|?
literal|"sw"
else|:
literal|"node"
argument_list|,
name|cl_ntoh64
argument_list|(
name|ropt
operator|->
name|n_id
argument_list|)
argument_list|,
name|ropt
operator|->
name|port
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|out
label|:
return|return
name|cnt
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_torus
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|unsigned
name|x_sz
init|=
name|t
operator|->
name|x_sz
decl_stmt|;
name|unsigned
name|y_sz
init|=
name|t
operator|->
name|y_sz
decl_stmt|;
name|unsigned
name|z_sz
init|=
name|t
operator|->
name|z_sz
decl_stmt|;
name|char
name|path
index|[
literal|1024
index|]
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|t
operator|->
name|osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|dump_files_dir
argument_list|,
literal|"opensm-torus.dump"
argument_list|)
expr_stmt|;
name|file
operator|=
name|fopen
argument_list|(
name|path
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E47: cannot create file \'%s\'\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|z_sz
condition|;
name|k
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|y_sz
condition|;
name|j
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|x_sz
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"switch %u,%u,%u GUID 0x%04"
name|PRIx64
literal|" (%s)\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|cl_ntoh64
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|->
name|n_id
argument_list|)
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|->
name|osm_switch
operator|->
name|p_node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|report_torus_changes
parameter_list|(
name|struct
name|torus
modifier|*
name|nt
parameter_list|,
name|struct
name|torus
modifier|*
name|ot
parameter_list|)
block|{
name|unsigned
name|cnt
init|=
literal|0
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|unsigned
name|x_sz
init|=
name|nt
operator|->
name|x_sz
decl_stmt|;
name|unsigned
name|y_sz
init|=
name|nt
operator|->
name|y_sz
decl_stmt|;
name|unsigned
name|z_sz
init|=
name|nt
operator|->
name|z_sz
decl_stmt|;
name|unsigned
name|max_changes
init|=
name|nt
operator|->
name|max_changes
decl_stmt|;
if|if
condition|(
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
operator|&
name|nt
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ROUTING
argument_list|)
condition|)
name|dump_torus
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ot
condition|)
return|return;
if|if
condition|(
name|x_sz
operator|!=
name|ot
operator|->
name|x_sz
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|nt
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Torus x radix was %d now %d\n"
argument_list|,
name|ot
operator|->
name|x_sz
argument_list|,
name|nt
operator|->
name|x_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_sz
operator|>
name|ot
operator|->
name|x_sz
condition|)
name|x_sz
operator|=
name|ot
operator|->
name|x_sz
expr_stmt|;
block|}
if|if
condition|(
name|y_sz
operator|!=
name|ot
operator|->
name|y_sz
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|nt
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Torus y radix was %d now %d\n"
argument_list|,
name|ot
operator|->
name|y_sz
argument_list|,
name|nt
operator|->
name|y_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|y_sz
operator|>
name|ot
operator|->
name|y_sz
condition|)
name|y_sz
operator|=
name|ot
operator|->
name|y_sz
expr_stmt|;
block|}
if|if
condition|(
name|z_sz
operator|!=
name|ot
operator|->
name|z_sz
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|nt
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Torus z radix was %d now %d\n"
argument_list|,
name|ot
operator|->
name|z_sz
argument_list|,
name|nt
operator|->
name|z_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|z_sz
operator|>
name|ot
operator|->
name|z_sz
condition|)
name|z_sz
operator|=
name|ot
operator|->
name|z_sz
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|z_sz
condition|;
name|k
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|y_sz
condition|;
name|j
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|x_sz
condition|;
name|i
operator|++
control|)
block|{
name|cnt
operator|+=
name|tsw_changes
argument_list|(
name|nt
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
name|ot
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|)
expr_stmt|;
comment|/* 				 * Booting a big fabric will cause lots of 				 * changes as hosts come up, so don't spew. 				 * We want to log changes to learn more about 				 * bouncing links, etc, so they can be fixed. 				 */
if|if
condition|(
name|cnt
operator|>
name|max_changes
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|nt
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Too many torus changes; "
literal|"stopping reporting early\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rpt_torus_missing
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|,
name|int
name|k
parameter_list|,
name|struct
name|t_switch
modifier|*
name|sw
parameter_list|,
name|int
modifier|*
name|missing_z
parameter_list|)
block|{
name|uint64_t
name|guid_ho
decl_stmt|;
if|if
condition|(
operator|!
name|sw
condition|)
block|{
comment|/* 		 * We can have multiple missing switches without deadlock 		 * if and only if they are adajacent in the Z direction. 		 */
if|if
condition|(
operator|(
name|t
operator|->
name|switch_cnt
operator|+
literal|1
operator|)
operator|<
name|t
operator|->
name|sw_pool_sz
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|canonicalize
argument_list|(
name|k
operator|-
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
index|]
operator|&&
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|canonicalize
argument_list|(
name|k
operator|+
literal|1
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
index|]
condition|)
name|t
operator|->
name|flags
operator||=
name|MSG_DEADLOCK
expr_stmt|;
block|}
comment|/* 		 * There can be only one such Z-column of missing switches. 		 */
if|if
condition|(
operator|*
name|missing_z
operator|<
literal|0
condition|)
operator|*
name|missing_z
operator|=
name|i
operator|+
name|j
operator|*
name|t
operator|->
name|x_sz
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|missing_z
operator|!=
name|i
operator|+
name|j
operator|*
name|t
operator|->
name|x_sz
condition|)
name|t
operator|->
name|flags
operator||=
name|MSG_DEADLOCK
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Missing torus switch at %d,%d,%d\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return;
block|}
name|guid_ho
operator|=
name|cl_ntoh64
argument_list|(
name|sw
operator|->
name|n_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sw
operator|->
name|ptgrp
index|[
literal|0
index|]
operator|.
name|port_cnt
operator|||
operator|(
name|t
operator|->
name|x_sz
operator|==
literal|1
operator|)
operator|||
operator|(
operator|(
name|t
operator|->
name|flags
operator|&
name|X_MESH
operator|)
operator|&&
name|i
operator|==
literal|0
operator|)
operator|)
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Missing torus -x link on "
literal|"switch %d,%d,%d GUID 0x%04"
name|PRIx64
literal|"\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|guid_ho
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sw
operator|->
name|ptgrp
index|[
literal|1
index|]
operator|.
name|port_cnt
operator|||
operator|(
name|t
operator|->
name|x_sz
operator|==
literal|1
operator|)
operator|||
operator|(
operator|(
name|t
operator|->
name|flags
operator|&
name|X_MESH
operator|)
operator|&&
operator|(
name|i
operator|+
literal|1
operator|)
operator|==
name|t
operator|->
name|x_sz
operator|)
operator|)
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Missing torus +x link on "
literal|"switch %d,%d,%d GUID 0x%04"
name|PRIx64
literal|"\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|guid_ho
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sw
operator|->
name|ptgrp
index|[
literal|2
index|]
operator|.
name|port_cnt
operator|||
operator|(
name|t
operator|->
name|y_sz
operator|==
literal|1
operator|)
operator|||
operator|(
operator|(
name|t
operator|->
name|flags
operator|&
name|Y_MESH
operator|)
operator|&&
name|j
operator|==
literal|0
operator|)
operator|)
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Missing torus -y link on "
literal|"switch %d,%d,%d GUID 0x%04"
name|PRIx64
literal|"\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|guid_ho
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sw
operator|->
name|ptgrp
index|[
literal|3
index|]
operator|.
name|port_cnt
operator|||
operator|(
name|t
operator|->
name|y_sz
operator|==
literal|1
operator|)
operator|||
operator|(
operator|(
name|t
operator|->
name|flags
operator|&
name|Y_MESH
operator|)
operator|&&
operator|(
name|j
operator|+
literal|1
operator|)
operator|==
name|t
operator|->
name|y_sz
operator|)
operator|)
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Missing torus +y link on "
literal|"switch %d,%d,%d GUID 0x%04"
name|PRIx64
literal|"\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|guid_ho
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sw
operator|->
name|ptgrp
index|[
literal|4
index|]
operator|.
name|port_cnt
operator|||
operator|(
name|t
operator|->
name|z_sz
operator|==
literal|1
operator|)
operator|||
operator|(
operator|(
name|t
operator|->
name|flags
operator|&
name|Z_MESH
operator|)
operator|&&
name|k
operator|==
literal|0
operator|)
operator|)
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Missing torus -z link on "
literal|"switch %d,%d,%d GUID 0x%04"
name|PRIx64
literal|"\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|guid_ho
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sw
operator|->
name|ptgrp
index|[
literal|5
index|]
operator|.
name|port_cnt
operator|||
operator|(
name|t
operator|->
name|z_sz
operator|==
literal|1
operator|)
operator|||
operator|(
operator|(
name|t
operator|->
name|flags
operator|&
name|Z_MESH
operator|)
operator|&&
operator|(
name|k
operator|+
literal|1
operator|)
operator|==
name|t
operator|->
name|z_sz
operator|)
operator|)
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Missing torus +z link on "
literal|"switch %d,%d,%d GUID 0x%04"
name|PRIx64
literal|"\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|guid_ho
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns true if the torus can be successfully routed, false otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|routable_torus
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|struct
name|fabric
modifier|*
name|f
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|tmp
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|b2g_cnt
decl_stmt|,
name|g2b_cnt
decl_stmt|;
name|bool
name|success
init|=
name|true
decl_stmt|;
name|t
operator|->
name|flags
operator|&=
operator|~
name|MSG_DEADLOCK
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|link_cnt
operator|!=
name|f
operator|->
name|link_cnt
operator|||
name|t
operator|->
name|switch_cnt
operator|!=
name|f
operator|->
name|switch_cnt
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Warning: Could not construct torus using all "
literal|"known fabric switches and/or links.\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
operator|(
name|int
operator|)
name|t
operator|->
name|z_sz
condition|;
name|k
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|int
operator|)
name|t
operator|->
name|y_sz
condition|;
name|j
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|t
operator|->
name|x_sz
condition|;
name|i
operator|++
control|)
name|rpt_torus_missing
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
comment|/* 	 * Check for multiple failures that create disjoint regions on a ring. 	 */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
operator|(
name|int
operator|)
name|t
operator|->
name|z_sz
condition|;
name|k
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|int
operator|)
name|t
operator|->
name|y_sz
condition|;
name|j
operator|++
control|)
block|{
name|b2g_cnt
operator|=
literal|0
expr_stmt|;
name|g2b_cnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|t
operator|->
name|x_sz
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
condition|)
continue|continue;
if|if
condition|(
operator|!
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|->
name|ptgrp
index|[
literal|0
index|]
operator|.
name|port_cnt
condition|)
name|b2g_cnt
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|->
name|ptgrp
index|[
literal|1
index|]
operator|.
name|port_cnt
condition|)
name|g2b_cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|b2g_cnt
operator|!=
name|g2b_cnt
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E32: strange failures in "
literal|"x ring at y=%d  z=%d"
literal|" b2g_cnt %u g2b_cnt %u\n"
argument_list|,
name|j
argument_list|,
name|k
argument_list|,
name|b2g_cnt
argument_list|,
name|g2b_cnt
argument_list|)
expr_stmt|;
name|success
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|b2g_cnt
operator|>
literal|1
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E33: disjoint failures in "
literal|"x ring at y=%d  z=%d\n"
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|success
operator|=
name|false
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|t
operator|->
name|x_sz
condition|;
name|i
operator|++
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
operator|(
name|int
operator|)
name|t
operator|->
name|z_sz
condition|;
name|k
operator|++
control|)
block|{
name|b2g_cnt
operator|=
literal|0
expr_stmt|;
name|g2b_cnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|int
operator|)
name|t
operator|->
name|y_sz
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
condition|)
continue|continue;
if|if
condition|(
operator|!
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|->
name|ptgrp
index|[
literal|2
index|]
operator|.
name|port_cnt
condition|)
name|b2g_cnt
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|->
name|ptgrp
index|[
literal|3
index|]
operator|.
name|port_cnt
condition|)
name|g2b_cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|b2g_cnt
operator|!=
name|g2b_cnt
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E34: strange failures in "
literal|"y ring at x=%d  z=%d"
literal|" b2g_cnt %u g2b_cnt %u\n"
argument_list|,
name|i
argument_list|,
name|k
argument_list|,
name|b2g_cnt
argument_list|,
name|g2b_cnt
argument_list|)
expr_stmt|;
name|success
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|b2g_cnt
operator|>
literal|1
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E35: disjoint failures in "
literal|"y ring at x=%d  z=%d\n"
argument_list|,
name|i
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|success
operator|=
name|false
expr_stmt|;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|int
operator|)
name|t
operator|->
name|y_sz
condition|;
name|j
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|t
operator|->
name|x_sz
condition|;
name|i
operator|++
control|)
block|{
name|b2g_cnt
operator|=
literal|0
expr_stmt|;
name|g2b_cnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
operator|(
name|int
operator|)
name|t
operator|->
name|z_sz
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
condition|)
continue|continue;
if|if
condition|(
operator|!
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|->
name|ptgrp
index|[
literal|4
index|]
operator|.
name|port_cnt
condition|)
name|b2g_cnt
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
operator|->
name|ptgrp
index|[
literal|5
index|]
operator|.
name|port_cnt
condition|)
name|g2b_cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|b2g_cnt
operator|!=
name|g2b_cnt
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E36: strange failures in "
literal|"z ring at x=%d  y=%d"
literal|" b2g_cnt %u g2b_cnt %u\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|b2g_cnt
argument_list|,
name|g2b_cnt
argument_list|)
expr_stmt|;
name|success
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|b2g_cnt
operator|>
literal|1
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E37: disjoint failures in "
literal|"z ring at x=%d  y=%d\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|success
operator|=
name|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|MSG_DEADLOCK
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E38: missing switch topology "
literal|"==> message deadlock!\n"
argument_list|)
expr_stmt|;
name|success
operator|=
name|false
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/*  * Use this function to re-establish the pointers between a torus endpoint  * and an opensm osm_port_t.  *  * Typically this is only needed when "opensm --ucast-cache" is used, and  * a CA link bounces.  When the CA port goes away, the osm_port_t object  * is destroyed, invalidating the endpoint osm_port_t pointer.  When the  * link comes back, a new osm_port_t object is created with a NULL priv  * member.  Thus, when osm_get_torus_sl() is called it is missing the data  * needed to do its work.  Use this function to fix things up.  */
end_comment

begin_function
specifier|static
name|struct
name|endpoint
modifier|*
name|osm_port_relink_endpoint
parameter_list|(
specifier|const
name|osm_port_t
modifier|*
name|osm_port
parameter_list|)
block|{
name|guid_t
name|node_guid
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|,
name|r_port_num
decl_stmt|;
name|struct
name|t_switch
modifier|*
name|sw
decl_stmt|;
name|struct
name|endpoint
modifier|*
name|ep
init|=
name|NULL
decl_stmt|;
name|osm_switch_t
modifier|*
name|osm_sw
decl_stmt|;
name|osm_physp_t
modifier|*
name|osm_physp
decl_stmt|;
name|osm_node_t
modifier|*
name|osm_node
decl_stmt|,
modifier|*
name|r_osm_node
decl_stmt|;
comment|/* 	 * We need to find the torus endpoint that has the same GUID as 	 * the osm_port.  Rather than search the entire set of endpoints, 	 * we'll try to follow pointers. 	 */
name|osm_physp
operator|=
name|osm_port
operator|->
name|p_physp
expr_stmt|;
name|osm_node
operator|=
name|osm_port
operator|->
name|p_node
expr_stmt|;
name|port_num
operator|=
name|osm_physp_get_port_num
argument_list|(
name|osm_physp
argument_list|)
expr_stmt|;
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|osm_node
argument_list|)
expr_stmt|;
comment|/* 	 * Switch management port? 	 */
if|if
condition|(
name|port_num
operator|==
literal|0
operator|&&
name|osm_node_get_type
argument_list|(
name|osm_node
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
condition|)
block|{
name|osm_sw
operator|=
name|osm_node
operator|->
name|sw
expr_stmt|;
if|if
condition|(
name|osm_sw
operator|&&
name|osm_sw
operator|->
name|priv
condition|)
block|{
name|sw
operator|=
name|osm_sw
operator|->
name|priv
expr_stmt|;
if|if
condition|(
name|sw
operator|->
name|osm_switch
operator|==
name|osm_sw
operator|&&
name|sw
operator|->
name|port
index|[
literal|0
index|]
operator|->
name|n_id
operator|==
name|node_guid
condition|)
block|{
name|ep
operator|=
name|sw
operator|->
name|port
index|[
literal|0
index|]
expr_stmt|;
goto|goto
name|relink_priv
goto|;
block|}
block|}
block|}
comment|/* 	 * CA port?  Try other end of link.  This should also catch a 	 * router port if it is connected to a switch. 	 */
name|r_osm_node
operator|=
name|osm_node_get_remote_node
argument_list|(
name|osm_node
argument_list|,
name|port_num
argument_list|,
operator|&
name|r_port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r_osm_node
condition|)
goto|goto
name|out
goto|;
name|osm_sw
operator|=
name|r_osm_node
operator|->
name|sw
expr_stmt|;
if|if
condition|(
operator|!
name|osm_sw
condition|)
goto|goto
name|out
goto|;
name|sw
operator|=
name|osm_sw
operator|->
name|priv
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sw
operator|&&
name|sw
operator|->
name|osm_switch
operator|==
name|osm_sw
operator|)
condition|)
goto|goto
name|out
goto|;
name|ep
operator|=
name|sw
operator|->
name|port
index|[
name|r_port_num
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ep
operator|&&
name|ep
operator|->
name|link
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|ep
operator|->
name|link
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|n_id
operator|==
name|node_guid
condition|)
block|{
name|ep
operator|=
operator|&
name|ep
operator|->
name|link
operator|->
name|end
index|[
literal|0
index|]
expr_stmt|;
goto|goto
name|relink_priv
goto|;
block|}
if|if
condition|(
name|ep
operator|->
name|link
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|n_id
operator|==
name|node_guid
condition|)
block|{
name|ep
operator|=
operator|&
name|ep
operator|->
name|link
operator|->
name|end
index|[
literal|1
index|]
expr_stmt|;
goto|goto
name|relink_priv
goto|;
block|}
name|ep
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
name|relink_priv
label|:
comment|/* FIXME: 	 * Unfortunately, we need to cast away const to rebuild the links 	 * between the torus endpoint and the osm_port_t. 	 * 	 * What is really needed is to check whether pr_rcv_get_path_parms() 	 * needs its port objects to be const.  If so, why, and whether 	 * anything can be done about it. 	 */
operator|(
operator|(
name|osm_port_t
operator|*
operator|)
name|osm_port
operator|)
operator|->
name|priv
operator|=
name|ep
expr_stmt|;
name|ep
operator|->
name|osm_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|osm_port
expr_stmt|;
name|out
label|:
return|return
name|ep
return|;
block|}
end_function

begin_comment
comment|/*  * Computing LFT entries and path SL values:  *  * For a pristine torus, we compute LFT entries using XYZ DOR, and select  * which direction to route on a ring (i.e., the 1-D torus for the coordinate  * in question) based on shortest path.  We compute the SL to use for the  * path based on whether we crossed a dateline (where a ring coordinate  * wraps to zero) for each coordinate.  *  * When there is a link/switch failure, we want to compute LFT entries  * to route around the failure, without changing the path SL.  I.e., we  * want the SL to reach a given destination from a given source to be  * independent of the presence or number of failed components in the fabric.  *  * In order to make this feasible, we will assume that no ring is broken  * into disjoint pieces by multiple failures  *  * We handle failure by attempting to take the long way around any ring  * with connectivity interrupted by failed components, unless the path  * requires a turn on a failed switch.  *  * For paths that require a turn on a failed switch, we head towards the  * failed switch, then turn when progress is blocked by a failure, using a  * turn allowed under XYZ DOR.  However, such a path will also require a turn  * that is not a legal XYZ DOR turn, so we construct the SL2VL mapping tables  * such that XYZ DOR turns use one set of VLs and ZYX DOR turns use a  * separate set of VLs.  *  * Under these rules the algorithm guarantees credit-loop-free routing for a  * single failed switch, without any change in path SL values.  We can also  * guarantee credit-loop-free routing for failures of multiple switches, if  * they are adjacent in the last DOR direction.  Since we use XYZ-DOR,  * that means failed switches at i,j,k and i,j,k+1 will not cause credit  * loops.  *  * These failure routing rules are intended to prevent paths that cross any  * coordinate dateline twice (over and back), so we don't need to worry about  * any ambiguity over which SL to use for such a case.  Also, we cannot have  * a ring deadlock when a ring is broken by failure and we route the long  * way around, so we don't need to worry about the impact of such routing  * on SL choice.  */
end_comment

begin_comment
comment|/*  * Functions to set our SL bit encoding for routing/QoS info.  Combine the  * resuts of these functions with bitwise or to get final SL.  *  * SL bits 0-2 encode whether we "looped" in a given direction  * on the torus on the path from source to destination.  *  * SL bit 3 encodes the QoS level.  We only support two QoS levels.  *  * Below we assume TORUS_MAX_DIM == 3 and 0<= coord_dir< TORUS_MAX_DIM.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|sl_set_use_loop_vl
parameter_list|(
name|bool
name|use_loop_vl
parameter_list|,
name|unsigned
name|coord_dir
parameter_list|)
block|{
return|return
operator|(
name|coord_dir
operator|<
name|TORUS_MAX_DIM
operator|)
condition|?
operator|(
operator|(
name|unsigned
operator|)
name|use_loop_vl
operator|<<
name|coord_dir
operator|)
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|sl_set_qos
parameter_list|(
name|unsigned
name|qos
parameter_list|)
block|{
return|return
call|(
name|unsigned
call|)
argument_list|(
operator|!
operator|!
name|qos
argument_list|)
operator|<<
name|TORUS_MAX_DIM
return|;
block|}
end_function

begin_comment
comment|/*  * Functions to crack our SL bit encoding for routing/QoS info.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|sl_get_use_loop_vl
parameter_list|(
name|unsigned
name|sl
parameter_list|,
name|unsigned
name|coord_dir
parameter_list|)
block|{
return|return
operator|(
name|coord_dir
operator|<
name|TORUS_MAX_DIM
operator|)
condition|?
operator|(
name|sl
operator|>>
name|coord_dir
operator|)
operator|&
literal|0x1
else|:
name|false
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|sl_get_qos
parameter_list|(
name|unsigned
name|sl
parameter_list|)
block|{
return|return
operator|(
name|sl
operator|>>
name|TORUS_MAX_DIM
operator|)
operator|&
literal|0x1
return|;
block|}
end_function

begin_comment
comment|/*  * Functions to encode routing/QoS info into VL bits.  Combine the resuts of  * these functions with bitwise or to get final VL.  *  * For interswitch links:  * VL bit 0 encodes whether we need to leave on the "loop" VL.  *  * VL bit 1 encodes whether turn is XYZ DOR or ZYX DOR. A 3d mesh/torus  * has 6 turn types: x-y, y-z, x-z, y-x, z-y, z-x.  The first three are  * legal XYZ DOR turns, and the second three are legal ZYX DOR turns.  * Straight-through (x-x, y-y, z-z) paths are legal in both DOR variants,  * so we'll assign them to XYZ DOR VLs.  *  * Note that delivery to switch-local ports (i.e. those that source/sink  * traffic, rather than forwarding it) cannot cause a deadlock, so that  * can also use either XYZ or ZYX DOR.  *  * VL bit 2 encodes QoS level.  *  * For end port links:  * VL bit 0 encodes QoS level.  *  * Note that if VL bit encodings are changed here, the available fabric VL  * verification in verify_setup() needs to be updated as well.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|vl_set_loop_vl
parameter_list|(
name|bool
name|use_loop_vl
parameter_list|)
block|{
return|return
name|use_loop_vl
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|vl_set_qos_vl
parameter_list|(
name|unsigned
name|qos
parameter_list|)
block|{
return|return
operator|(
name|qos
operator|&
literal|0x1
operator|)
operator|<<
literal|2
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|vl_set_ca_qos_vl
parameter_list|(
name|unsigned
name|qos
parameter_list|)
block|{
return|return
name|qos
operator|&
literal|0x1
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|vl_set_turn_vl
parameter_list|(
name|unsigned
name|in_coord_dir
parameter_list|,
name|unsigned
name|out_coord_dir
parameter_list|)
block|{
name|unsigned
name|vl
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|in_coord_dir
operator|!=
name|TORUS_MAX_DIM
operator|&&
name|out_coord_dir
operator|!=
name|TORUS_MAX_DIM
condition|)
name|vl
operator|=
operator|(
name|in_coord_dir
operator|>
name|out_coord_dir
operator|)
condition|?
literal|0x1
operator|<<
literal|1
else|:
literal|0
expr_stmt|;
return|return
name|vl
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|sl2vl_entry
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|struct
name|t_switch
modifier|*
name|sw
parameter_list|,
name|int
name|input_pt
parameter_list|,
name|int
name|output_pt
parameter_list|,
name|unsigned
name|sl
parameter_list|)
block|{
name|unsigned
name|id
decl_stmt|,
name|od
decl_stmt|,
name|vl
decl_stmt|,
name|data_vls
decl_stmt|;
if|if
condition|(
name|sw
operator|&&
name|sw
operator|->
name|port
index|[
name|input_pt
index|]
condition|)
name|id
operator|=
name|sw
operator|->
name|port
index|[
name|input_pt
index|]
operator|->
name|pgrp
operator|->
name|port_grp
operator|/
literal|2
expr_stmt|;
else|else
name|id
operator|=
name|TORUS_MAX_DIM
expr_stmt|;
if|if
condition|(
name|sw
operator|&&
name|sw
operator|->
name|port
index|[
name|output_pt
index|]
condition|)
name|od
operator|=
name|sw
operator|->
name|port
index|[
name|output_pt
index|]
operator|->
name|pgrp
operator|->
name|port_grp
operator|/
literal|2
expr_stmt|;
else|else
name|od
operator|=
name|TORUS_MAX_DIM
expr_stmt|;
if|if
condition|(
name|sw
condition|)
name|data_vls
operator|=
name|t
operator|->
name|osm
operator|->
name|subn
operator|.
name|min_sw_data_vls
expr_stmt|;
else|else
name|data_vls
operator|=
name|t
operator|->
name|osm
operator|->
name|subn
operator|.
name|min_data_vls
expr_stmt|;
name|vl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sw
operator|&&
name|od
operator|!=
name|TORUS_MAX_DIM
condition|)
block|{
if|if
condition|(
name|data_vls
operator|>=
literal|2
condition|)
name|vl
operator||=
name|vl_set_loop_vl
argument_list|(
name|sl_get_use_loop_vl
argument_list|(
name|sl
argument_list|,
name|od
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_vls
operator|>=
literal|4
condition|)
name|vl
operator||=
name|vl_set_turn_vl
argument_list|(
name|id
argument_list|,
name|od
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_vls
operator|>=
literal|8
condition|)
name|vl
operator||=
name|vl_set_qos_vl
argument_list|(
name|sl_get_qos
argument_list|(
name|sl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|data_vls
operator|>=
literal|2
condition|)
name|vl
operator||=
name|vl_set_ca_qos_vl
argument_list|(
name|sl_get_qos
argument_list|(
name|sl
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|vl
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|torus_update_osm_sl2vl
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|osm_physp_t
modifier|*
name|osm_phys_port
parameter_list|,
name|uint8_t
name|iport_num
parameter_list|,
name|uint8_t
name|oport_num
parameter_list|,
name|ib_slvl_table_t
modifier|*
name|osm_oport_sl2vl
parameter_list|)
block|{
name|osm_node_t
modifier|*
name|node
init|=
name|osm_physp_get_node_ptr
argument_list|(
name|osm_phys_port
argument_list|)
decl_stmt|;
name|struct
name|torus_context
modifier|*
name|ctx
init|=
name|context
decl_stmt|;
name|struct
name|t_switch
modifier|*
name|sw
init|=
name|NULL
decl_stmt|;
name|int
name|sl
decl_stmt|,
name|vl
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|sw
condition|)
block|{
name|sw
operator|=
name|node
operator|->
name|sw
operator|->
name|priv
expr_stmt|;
if|if
condition|(
name|sw
operator|&&
name|sw
operator|->
name|osm_switch
operator|!=
name|node
operator|->
name|sw
condition|)
block|{
name|osm_log_t
modifier|*
name|log
init|=
operator|&
name|ctx
operator|->
name|osm
operator|->
name|log
decl_stmt|;
name|guid_t
name|guid
decl_stmt|;
name|guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Note: osm_switch (GUID 0x%04"
name|PRIx64
literal|") "
literal|"not in torus fabric description\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|guid
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
for|for
control|(
name|sl
operator|=
literal|0
init|;
name|sl
operator|<
literal|16
condition|;
name|sl
operator|++
control|)
block|{
name|vl
operator|=
name|sl2vl_entry
argument_list|(
name|ctx
operator|->
name|torus
argument_list|,
name|sw
argument_list|,
name|iport_num
argument_list|,
name|oport_num
argument_list|,
name|sl
argument_list|)
expr_stmt|;
name|ib_slvl_table_set
argument_list|(
name|osm_oport_sl2vl
argument_list|,
name|sl
argument_list|,
name|vl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|torus_update_osm_vlarb
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|osm_physp_t
modifier|*
name|osm_phys_port
parameter_list|,
name|uint8_t
name|port_num
parameter_list|,
name|ib_vl_arb_table_t
modifier|*
name|block
parameter_list|,
name|unsigned
name|block_length
parameter_list|,
name|unsigned
name|block_num
parameter_list|)
block|{
name|osm_node_t
modifier|*
name|node
init|=
name|osm_physp_get_node_ptr
argument_list|(
name|osm_phys_port
argument_list|)
decl_stmt|;
name|struct
name|torus_context
modifier|*
name|ctx
init|=
name|context
decl_stmt|;
name|struct
name|t_switch
modifier|*
name|sw
init|=
name|NULL
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|next
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|sw
condition|)
block|{
name|sw
operator|=
name|node
operator|->
name|sw
operator|->
name|priv
expr_stmt|;
if|if
condition|(
name|sw
operator|&&
name|sw
operator|->
name|osm_switch
operator|!=
name|node
operator|->
name|sw
condition|)
block|{
name|osm_log_t
modifier|*
name|log
init|=
operator|&
name|ctx
operator|->
name|osm
operator|->
name|log
decl_stmt|;
name|guid_t
name|guid
decl_stmt|;
name|guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Note: osm_switch (GUID 0x%04"
name|PRIx64
literal|") "
literal|"not in torus fabric description\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|guid
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * If osm_phys_port is a switch port that connects to a CA, then 	 * we're using at most VL 0 (for QoS level 0) and VL 1 (for QoS 	 * level 1).  We've been passed the VLarb values for a switch 	 * external port, so we need to fix them up to avoid unexpected 	 * results depending on how the switch handles VLarb values for 	 * unprogrammed VLs. 	 * 	 * For inter-switch links torus-2QoS uses VLs 0-3 to implement 	 * QoS level 0, and VLs 4-7 to implement QoS level 1. 	 * 	 * So, leave VL 0 alone, remap VL 4 to VL 1, zero out the rest, 	 * and compress out the zero entries to the end. 	 */
if|if
condition|(
operator|!
name|sw
operator|||
operator|!
name|port_num
operator|||
operator|!
name|sw
operator|->
name|port
index|[
name|port_num
index|]
operator|||
name|sw
operator|->
name|port
index|[
name|port_num
index|]
operator|->
name|pgrp
operator|->
name|port_grp
operator|!=
literal|2
operator|*
name|TORUS_MAX_DIM
condition|)
return|return;
name|next
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|block_length
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|block
operator|->
name|vl_entry
index|[
name|i
index|]
operator|.
name|vl
condition|)
block|{
case|case
literal|4
case|:
name|block
operator|->
name|vl_entry
index|[
name|i
index|]
operator|.
name|vl
operator|=
literal|1
expr_stmt|;
comment|/* fall through */
case|case
literal|0
case|:
name|block
operator|->
name|vl_entry
index|[
name|next
index|]
operator|.
name|vl
operator|=
name|block
operator|->
name|vl_entry
index|[
name|i
index|]
operator|.
name|vl
expr_stmt|;
name|block
operator|->
name|vl_entry
index|[
name|next
index|]
operator|.
name|weight
operator|=
name|block
operator|->
name|vl_entry
index|[
name|i
index|]
operator|.
name|weight
expr_stmt|;
name|next
operator|++
expr_stmt|;
comment|/* 			 * If we didn't update vl_entry[i] in place, 			 * fall through to zero it out. 			 */
if|if
condition|(
name|next
operator|>
name|i
condition|)
break|break;
default|default:
name|block
operator|->
name|vl_entry
index|[
name|i
index|]
operator|.
name|vl
operator|=
literal|0
expr_stmt|;
name|block
operator|->
name|vl_entry
index|[
name|i
index|]
operator|.
name|weight
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Computes the path lengths *vl0_len and *vl1_len to get from src  * to dst on a ring with count switches.  *  * *vl0_len is the path length for a direct path; it corresponds to a path  * that should be assigned to use VL0 in a switch.  *vl1_len is the path  * length for a path that wraps aroung the ring, i.e. where the ring index  * goes from count to zero or from zero to count.  It corresponds to the path  * that should be assigned to use VL1 in a switch.  */
end_comment

begin_function
specifier|static
name|void
name|get_pathlen
parameter_list|(
name|unsigned
name|src
parameter_list|,
name|unsigned
name|dst
parameter_list|,
name|unsigned
name|count
parameter_list|,
name|unsigned
modifier|*
name|vl0_len
parameter_list|,
name|unsigned
modifier|*
name|vl1_len
parameter_list|)
block|{
name|unsigned
name|s
decl_stmt|,
name|l
decl_stmt|;
comment|/* assume s< l */
if|if
condition|(
name|dst
operator|>
name|src
condition|)
block|{
name|s
operator|=
name|src
expr_stmt|;
name|l
operator|=
name|dst
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|dst
expr_stmt|;
name|l
operator|=
name|src
expr_stmt|;
block|}
operator|*
name|vl0_len
operator|=
name|l
operator|-
name|s
expr_stmt|;
operator|*
name|vl1_len
operator|=
name|s
operator|+
name|count
operator|-
name|l
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns a positive number if we should take the "positive" ring direction  * to reach dst from src, a negative number if we should take the "negative"  * ring direction, and 0 if src and dst are the same.  The choice is strictly  * based on which path is shorter.  */
end_comment

begin_function
specifier|static
name|int
name|ring_dir_idx
parameter_list|(
name|unsigned
name|src
parameter_list|,
name|unsigned
name|dst
parameter_list|,
name|unsigned
name|count
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|unsigned
name|vl0_len
decl_stmt|,
name|vl1_len
decl_stmt|;
if|if
condition|(
name|dst
operator|==
name|src
condition|)
return|return
literal|0
return|;
name|get_pathlen
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|count
argument_list|,
operator|&
name|vl0_len
argument_list|,
operator|&
name|vl1_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|>
name|src
condition|)
name|r
operator|=
name|vl0_len
operator|<=
name|vl1_len
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
else|else
name|r
operator|=
name|vl0_len
operator|<=
name|vl1_len
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if the VL1 path should be used to reach src from dst on a  * ring, based on which path is shorter.  */
end_comment

begin_function
specifier|static
name|bool
name|use_vl1
parameter_list|(
name|unsigned
name|src
parameter_list|,
name|unsigned
name|dst
parameter_list|,
name|unsigned
name|count
parameter_list|)
block|{
name|unsigned
name|vl0_len
decl_stmt|,
name|vl1_len
decl_stmt|;
name|get_pathlen
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|count
argument_list|,
operator|&
name|vl0_len
argument_list|,
operator|&
name|vl1_len
argument_list|)
expr_stmt|;
return|return
name|vl0_len
operator|<=
name|vl1_len
condition|?
name|false
else|:
name|true
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the next switch in the ring of switches along coordinate direction  * cdir, in the positive ring direction if rdir is positive, and in the  * negative ring direction if rdir is negative.  *  * Returns NULL if rdir is zero, or there is no next switch.  */
end_comment

begin_function
specifier|static
name|struct
name|t_switch
modifier|*
name|ring_next_sw
parameter_list|(
name|struct
name|t_switch
modifier|*
name|sw
parameter_list|,
name|unsigned
name|cdir
parameter_list|,
name|int
name|rdir
parameter_list|)
block|{
name|unsigned
name|pt_grp
decl_stmt|,
name|far_end
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|rdir
condition|)
return|return
name|NULL
return|;
comment|/* 	 * Recall that links are installed into the torus so that their 1 end 	 * is in the "positive" coordinate direction relative to their 0 end 	 * (see link_tswitches() and connect_tlink()).  Recall also that for 	 * interswitch links, all links in a given switch port group have the 	 * same endpoints, so we just need to look at the first link. 	 */
name|pt_grp
operator|=
literal|2
operator|*
name|cdir
expr_stmt|;
if|if
condition|(
name|rdir
operator|>
literal|0
condition|)
block|{
name|pt_grp
operator|++
expr_stmt|;
name|far_end
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sw
operator|->
name|ptgrp
index|[
name|pt_grp
index|]
operator|.
name|port_cnt
condition|)
return|return
name|NULL
return|;
return|return
name|sw
operator|->
name|ptgrp
index|[
name|pt_grp
index|]
operator|.
name|port
index|[
literal|0
index|]
operator|->
name|link
operator|->
name|end
index|[
name|far_end
index|]
operator|.
name|sw
return|;
block|}
end_function

begin_comment
comment|/*  * Returns a positive number if we should take the "positive" ring direction  * to reach dsw from ssw, a negative number if we should take the "negative"  * ring direction, and 0 if src and dst are the same, or if dsw is not  * reachable from ssw because the path is interrupted by failure.  */
end_comment

begin_function
specifier|static
name|int
name|ring_dir_path
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|unsigned
name|cdir
parameter_list|,
name|struct
name|t_switch
modifier|*
name|ssw
parameter_list|,
name|struct
name|t_switch
modifier|*
name|dsw
parameter_list|)
block|{
name|int
name|d
init|=
literal|0
decl_stmt|;
name|struct
name|t_switch
modifier|*
name|sw
decl_stmt|;
switch|switch
condition|(
name|cdir
condition|)
block|{
case|case
literal|0
case|:
name|d
operator|=
name|ring_dir_idx
argument_list|(
name|ssw
operator|->
name|i
argument_list|,
name|dsw
operator|->
name|i
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|d
operator|=
name|ring_dir_idx
argument_list|(
name|ssw
operator|->
name|j
argument_list|,
name|dsw
operator|->
name|j
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|d
operator|=
name|ring_dir_idx
argument_list|(
name|ssw
operator|->
name|k
argument_list|,
name|dsw
operator|->
name|k
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|d
condition|)
goto|goto
name|out
goto|;
name|sw
operator|=
name|ssw
expr_stmt|;
while|while
condition|(
name|sw
condition|)
block|{
name|sw
operator|=
name|ring_next_sw
argument_list|(
name|sw
argument_list|,
name|cdir
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
operator|==
name|dsw
condition|)
goto|goto
name|out
goto|;
block|}
name|d
operator|*=
operator|-
literal|1
expr_stmt|;
name|sw
operator|=
name|ssw
expr_stmt|;
while|while
condition|(
name|sw
condition|)
block|{
name|sw
operator|=
name|ring_next_sw
argument_list|(
name|sw
argument_list|,
name|cdir
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
operator|==
name|dsw
condition|)
goto|goto
name|out
goto|;
block|}
name|d
operator|=
literal|0
expr_stmt|;
name|out
label|:
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true, and sets *pt_grp to the port group index to use for the  * next hop, if it is possible to make progress from ssw to dsw along the  * coordinate direction cdir, taking into account whether there are  * interruptions in the path.  *  * This next hop result can be used without worrying about ring deadlocks -  * if we don't choose the shortest path it is because there is a failure in  * the ring, which removes the possibilility of a ring deadlock on that ring.  */
end_comment

begin_function
specifier|static
name|bool
name|next_hop_path
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|unsigned
name|cdir
parameter_list|,
name|struct
name|t_switch
modifier|*
name|ssw
parameter_list|,
name|struct
name|t_switch
modifier|*
name|dsw
parameter_list|,
name|unsigned
modifier|*
name|pt_grp
parameter_list|)
block|{
name|struct
name|t_switch
modifier|*
name|tsw
init|=
name|NULL
decl_stmt|;
name|bool
name|success
init|=
name|false
decl_stmt|;
name|int
name|d
decl_stmt|;
comment|/* 	 * If the path from ssw to dsw turns, this is the switch where the 	 * turn happens. 	 */
switch|switch
condition|(
name|cdir
condition|)
block|{
case|case
literal|0
case|:
name|tsw
operator|=
name|t
operator|->
name|sw
index|[
name|dsw
operator|->
name|i
index|]
index|[
name|ssw
operator|->
name|j
index|]
index|[
name|ssw
operator|->
name|k
index|]
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|tsw
operator|=
name|t
operator|->
name|sw
index|[
name|ssw
operator|->
name|i
index|]
index|[
name|dsw
operator|->
name|j
index|]
index|[
name|ssw
operator|->
name|k
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|tsw
operator|=
name|t
operator|->
name|sw
index|[
name|ssw
operator|->
name|i
index|]
index|[
name|ssw
operator|->
name|j
index|]
index|[
name|dsw
operator|->
name|k
index|]
expr_stmt|;
break|break;
default|default:
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|tsw
condition|)
block|{
name|d
operator|=
name|ring_dir_path
argument_list|(
name|t
argument_list|,
name|cdir
argument_list|,
name|ssw
argument_list|,
name|tsw
argument_list|)
expr_stmt|;
name|cdir
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|d
operator|>
literal|0
condition|)
operator|*
name|pt_grp
operator|=
name|cdir
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|<
literal|0
condition|)
operator|*
name|pt_grp
operator|=
name|cdir
expr_stmt|;
else|else
goto|goto
name|out
goto|;
name|success
operator|=
name|true
expr_stmt|;
block|}
name|out
label|:
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true, and sets *pt_grp to the port group index to use for the  * next hop, if it is possible to make progress from ssw to dsw along the  * coordinate direction cdir.  This decision is made strictly on a  * shortest-path basis without regard for path availability.  */
end_comment

begin_function
specifier|static
name|bool
name|next_hop_idx
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|unsigned
name|cdir
parameter_list|,
name|struct
name|t_switch
modifier|*
name|ssw
parameter_list|,
name|struct
name|t_switch
modifier|*
name|dsw
parameter_list|,
name|unsigned
modifier|*
name|pt_grp
parameter_list|)
block|{
name|int
name|d
decl_stmt|;
name|unsigned
name|g
decl_stmt|;
name|bool
name|success
init|=
name|false
decl_stmt|;
switch|switch
condition|(
name|cdir
condition|)
block|{
case|case
literal|0
case|:
name|d
operator|=
name|ring_dir_idx
argument_list|(
name|ssw
operator|->
name|i
argument_list|,
name|dsw
operator|->
name|i
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|d
operator|=
name|ring_dir_idx
argument_list|(
name|ssw
operator|->
name|j
argument_list|,
name|dsw
operator|->
name|j
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|d
operator|=
name|ring_dir_idx
argument_list|(
name|ssw
operator|->
name|k
argument_list|,
name|dsw
operator|->
name|k
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|out
goto|;
block|}
name|cdir
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|d
operator|>
literal|0
condition|)
name|g
operator|=
name|cdir
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|<
literal|0
condition|)
name|g
operator|=
name|cdir
expr_stmt|;
else|else
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|ssw
operator|->
name|ptgrp
index|[
name|g
index|]
operator|.
name|port_cnt
condition|)
goto|goto
name|out
goto|;
operator|*
name|pt_grp
operator|=
name|g
expr_stmt|;
name|success
operator|=
name|true
expr_stmt|;
name|out
label|:
return|return
name|success
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|warn_on_routing
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|struct
name|t_switch
modifier|*
name|sw
parameter_list|,
name|struct
name|t_switch
modifier|*
name|dsw
parameter_list|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|sw
operator|->
name|torus
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"%s from sw 0x%04"
name|PRIx64
literal|" (%d,%d,%d) "
literal|"to sw 0x%04"
name|PRIx64
literal|" (%d,%d,%d)\n"
argument_list|,
name|msg
argument_list|,
name|cl_ntoh64
argument_list|(
name|sw
operator|->
name|n_id
argument_list|)
argument_list|,
name|sw
operator|->
name|i
argument_list|,
name|sw
operator|->
name|j
argument_list|,
name|sw
operator|->
name|k
argument_list|,
name|cl_ntoh64
argument_list|(
name|dsw
operator|->
name|n_id
argument_list|)
argument_list|,
name|dsw
operator|->
name|i
argument_list|,
name|dsw
operator|->
name|j
argument_list|,
name|dsw
operator|->
name|k
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|next_hop_x
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|struct
name|t_switch
modifier|*
name|ssw
parameter_list|,
name|struct
name|t_switch
modifier|*
name|dsw
parameter_list|,
name|unsigned
modifier|*
name|pt_grp
parameter_list|)
block|{
if|if
condition|(
name|t
operator|->
name|sw
index|[
name|dsw
operator|->
name|i
index|]
index|[
name|ssw
operator|->
name|j
index|]
index|[
name|ssw
operator|->
name|k
index|]
condition|)
comment|/* 		 * The next turning switch on this path is available, 		 * so head towards it by the shortest available path. 		 */
return|return
name|next_hop_path
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
name|ssw
argument_list|,
name|dsw
argument_list|,
name|pt_grp
argument_list|)
return|;
else|else
comment|/* 		 * The next turning switch on this path is not 		 * available, so head towards it in the shortest 		 * path direction. 		 */
return|return
name|next_hop_idx
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
name|ssw
argument_list|,
name|dsw
argument_list|,
name|pt_grp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|next_hop_y
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|struct
name|t_switch
modifier|*
name|ssw
parameter_list|,
name|struct
name|t_switch
modifier|*
name|dsw
parameter_list|,
name|unsigned
modifier|*
name|pt_grp
parameter_list|)
block|{
if|if
condition|(
name|t
operator|->
name|sw
index|[
name|ssw
operator|->
name|i
index|]
index|[
name|dsw
operator|->
name|j
index|]
index|[
name|ssw
operator|->
name|k
index|]
condition|)
comment|/* 		 * The next turning switch on this path is available, 		 * so head towards it by the shortest available path. 		 */
return|return
name|next_hop_path
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
name|ssw
argument_list|,
name|dsw
argument_list|,
name|pt_grp
argument_list|)
return|;
else|else
comment|/* 		 * The next turning switch on this path is not 		 * available, so head towards it in the shortest 		 * path direction. 		 */
return|return
name|next_hop_idx
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
name|ssw
argument_list|,
name|dsw
argument_list|,
name|pt_grp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|next_hop_z
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|struct
name|t_switch
modifier|*
name|ssw
parameter_list|,
name|struct
name|t_switch
modifier|*
name|dsw
parameter_list|,
name|unsigned
modifier|*
name|pt_grp
parameter_list|)
block|{
return|return
name|next_hop_path
argument_list|(
name|t
argument_list|,
literal|2
argument_list|,
name|ssw
argument_list|,
name|dsw
argument_list|,
name|pt_grp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the port number on *sw to use to reach *dsw, or -1 if unable to  * route.  */
end_comment

begin_function
specifier|static
name|int
name|lft_port
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|struct
name|t_switch
modifier|*
name|sw
parameter_list|,
name|struct
name|t_switch
modifier|*
name|dsw
parameter_list|,
name|bool
name|update_port_cnt
parameter_list|,
name|bool
name|ca
parameter_list|)
block|{
name|unsigned
name|g
decl_stmt|,
name|p
decl_stmt|;
name|struct
name|port_grp
modifier|*
name|pg
decl_stmt|;
comment|/* 	 * The IBA does not provide a way to preserve path history for 	 * routing decisions and VL assignment, and the only mechanism to 	 * provide global fabric knowledge to the routing engine is via 	 * the four SL bits.  This severely constrains the ability to deal 	 * with missing/dead switches. 	 * 	 * Also, if routing a torus with XYZ-DOR, the only way to route 	 * around a missing/dead switch is to introduce a turn that is 	 * illegal under XYZ-DOR. 	 * 	 * But here's what we can do: 	 * 	 * We have a VL bit we use to flag illegal turns, thus putting the 	 * hop directly after an illegal turn on a separate set of VLs. 	 * Unfortunately, since there is no path history,  the _second_ 	 * and subsequent hops after an illegal turn use the standard 	 * XYZ-DOR VL set.  This is enough to introduce credit loops in 	 * many cases. 	 * 	 * To minimize the number of cases such illegal turns can introduce 	 * credit loops, we try to introduce the illegal turn as late in a 	 * path as possible. 	 * 	 * Define a turning switch as a switch where a path turns from one 	 * coordinate direction onto another.  If a turning switch in a path 	 * is missing, construct the LFT entries so that the path progresses 	 * as far as possible on the shortest path to the turning switch. 	 * When progress is not possible, turn onto the next coordinate 	 * direction. 	 * 	 * The next turn after that will be an illegal turn, after which 	 * point the path will continue to use a standard XYZ-DOR path. 	 */
if|if
condition|(
name|dsw
operator|->
name|i
operator|!=
name|sw
operator|->
name|i
condition|)
block|{
if|if
condition|(
name|next_hop_x
argument_list|(
name|t
argument_list|,
name|sw
argument_list|,
name|dsw
argument_list|,
operator|&
name|g
argument_list|)
condition|)
goto|goto
name|done
goto|;
comment|/* 		 * This path has made as much progress in this direction as 		 * is possible, so turn it now. 		 */
if|if
condition|(
name|dsw
operator|->
name|j
operator|!=
name|sw
operator|->
name|j
operator|&&
name|next_hop_y
argument_list|(
name|t
argument_list|,
name|sw
argument_list|,
name|dsw
argument_list|,
operator|&
name|g
argument_list|)
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|dsw
operator|->
name|k
operator|!=
name|sw
operator|->
name|k
operator|&&
name|next_hop_z
argument_list|(
name|t
argument_list|,
name|sw
argument_list|,
name|dsw
argument_list|,
operator|&
name|g
argument_list|)
condition|)
goto|goto
name|done
goto|;
name|warn_on_routing
argument_list|(
literal|"Error: unable to route"
argument_list|,
name|sw
argument_list|,
name|dsw
argument_list|)
expr_stmt|;
goto|goto
name|no_route
goto|;
block|}
elseif|else
if|if
condition|(
name|dsw
operator|->
name|j
operator|!=
name|sw
operator|->
name|j
condition|)
block|{
if|if
condition|(
name|next_hop_y
argument_list|(
name|t
argument_list|,
name|sw
argument_list|,
name|dsw
argument_list|,
operator|&
name|g
argument_list|)
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|dsw
operator|->
name|k
operator|!=
name|sw
operator|->
name|k
operator|&&
name|next_hop_z
argument_list|(
name|t
argument_list|,
name|sw
argument_list|,
name|dsw
argument_list|,
operator|&
name|g
argument_list|)
condition|)
goto|goto
name|done
goto|;
name|warn_on_routing
argument_list|(
literal|"Error: unable to route"
argument_list|,
name|sw
argument_list|,
name|dsw
argument_list|)
expr_stmt|;
goto|goto
name|no_route
goto|;
block|}
else|else
block|{
if|if
condition|(
name|dsw
operator|->
name|k
operator|==
name|sw
operator|->
name|k
condition|)
name|warn_on_routing
argument_list|(
literal|"Warning: bad routing"
argument_list|,
name|sw
argument_list|,
name|dsw
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_hop_z
argument_list|(
name|t
argument_list|,
name|sw
argument_list|,
name|dsw
argument_list|,
operator|&
name|g
argument_list|)
condition|)
goto|goto
name|done
goto|;
name|warn_on_routing
argument_list|(
literal|"Error: unable to route"
argument_list|,
name|sw
argument_list|,
name|dsw
argument_list|)
expr_stmt|;
goto|goto
name|no_route
goto|;
block|}
name|done
label|:
name|pg
operator|=
operator|&
name|sw
operator|->
name|ptgrp
index|[
name|g
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|pg
operator|->
name|port_cnt
condition|)
goto|goto
name|no_route
goto|;
if|if
condition|(
name|update_port_cnt
condition|)
block|{
if|if
condition|(
name|ca
condition|)
name|p
operator|=
name|pg
operator|->
name|ca_dlid_cnt
operator|++
operator|%
name|pg
operator|->
name|port_cnt
expr_stmt|;
else|else
name|p
operator|=
name|pg
operator|->
name|sw_dlid_cnt
operator|++
operator|%
name|pg
operator|->
name|port_cnt
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If we're not updating port counts, then we're just running 		 * routes for SL path checking, and it doesn't matter which 		 * of several parallel links we use.  Use the first one. 		 */
name|p
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|=
name|pg
operator|->
name|port
index|[
name|p
index|]
operator|->
name|port
expr_stmt|;
return|return
name|p
return|;
name|no_route
label|:
comment|/* 	 * We can't get there from here. 	 */
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E39: routing on sw 0x%04"
name|PRIx64
literal|": sending "
literal|"traffic for dest sw 0x%04"
name|PRIx64
literal|" to port %u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|sw
operator|->
name|n_id
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|dsw
operator|->
name|n_id
argument_list|)
argument_list|,
name|OSM_NO_PATH
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|get_lid
parameter_list|(
name|struct
name|port_grp
modifier|*
name|pg
parameter_list|,
name|unsigned
name|p
parameter_list|,
name|uint16_t
modifier|*
name|dlid_base
parameter_list|,
name|uint8_t
modifier|*
name|dlid_lmc
parameter_list|,
name|bool
modifier|*
name|ca
parameter_list|)
block|{
name|struct
name|endpoint
modifier|*
name|ep
decl_stmt|;
name|osm_port_t
modifier|*
name|osm_port
decl_stmt|;
if|if
condition|(
name|p
operator|>=
name|pg
operator|->
name|port_cnt
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|pg
operator|->
name|sw
operator|->
name|torus
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E3A: Port group index %u too large: sw "
literal|"0x%04"
name|PRIx64
literal|" pt_grp %u pt_grp_cnt %u\n"
argument_list|,
name|p
argument_list|,
name|cl_ntoh64
argument_list|(
name|pg
operator|->
name|sw
operator|->
name|n_id
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|pg
operator|->
name|port_grp
argument_list|,
operator|(
name|unsigned
operator|)
name|pg
operator|->
name|port_cnt
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|pg
operator|->
name|port
index|[
name|p
index|]
operator|->
name|type
operator|==
name|SRCSINK
condition|)
block|{
name|ep
operator|=
name|pg
operator|->
name|port
index|[
name|p
index|]
expr_stmt|;
if|if
condition|(
name|ca
condition|)
operator|*
name|ca
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pg
operator|->
name|port
index|[
name|p
index|]
operator|->
name|type
operator|==
name|PASSTHRU
operator|&&
name|pg
operator|->
name|port
index|[
name|p
index|]
operator|->
name|link
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|type
operator|==
name|SRCSINK
condition|)
block|{
comment|/* 		 * If this port is connected via a link to a CA, then we 		 * know link->end[0] is the switch end and link->end[1] is 		 * the CA end; see build_ca_link() and link_srcsink(). 		 */
name|ep
operator|=
operator|&
name|pg
operator|->
name|port
index|[
name|p
index|]
operator|->
name|link
operator|->
name|end
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|ca
condition|)
operator|*
name|ca
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
operator|&
name|pg
operator|->
name|sw
operator|->
name|torus
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E3B: Switch 0x%04"
name|PRIx64
literal|" port %d improperly connected\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|pg
operator|->
name|sw
operator|->
name|n_id
argument_list|)
argument_list|,
name|pg
operator|->
name|port
index|[
name|p
index|]
operator|->
name|port
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|osm_port
operator|=
name|ep
operator|->
name|osm_port
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|osm_port
operator|&&
name|osm_port
operator|->
name|priv
operator|==
name|ep
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|pg
operator|->
name|sw
operator|->
name|torus
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E3C: ep->osm_port->priv != ep "
literal|"for sw 0x%04"
name|PRIx64
literal|" port %d\n"
argument_list|,
name|cl_ntoh64
argument_list|(
operator|(
operator|(
expr|struct
name|t_switch
operator|*
operator|)
operator|(
name|ep
operator|->
name|sw
operator|)
operator|)
operator|->
name|n_id
argument_list|)
argument_list|,
name|ep
operator|->
name|port
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|dlid_base
operator|=
name|cl_ntoh16
argument_list|(
name|osm_physp_get_base_lid
argument_list|(
name|osm_port
operator|->
name|p_physp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|dlid_lmc
operator|=
name|osm_physp_get_lmc
argument_list|(
name|osm_port
operator|->
name|p_physp
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|torus_lft
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
name|struct
name|t_switch
modifier|*
name|sw
parameter_list|)
block|{
name|bool
name|success
init|=
name|true
decl_stmt|;
name|int
name|dp
decl_stmt|;
name|unsigned
name|p
decl_stmt|,
name|s
decl_stmt|;
name|uint16_t
name|l
decl_stmt|,
name|dlid_base
decl_stmt|;
name|uint8_t
name|dlid_lmc
decl_stmt|;
name|bool
name|ca
decl_stmt|;
name|struct
name|port_grp
modifier|*
name|pgrp
decl_stmt|;
name|struct
name|t_switch
modifier|*
name|dsw
decl_stmt|;
name|osm_switch_t
modifier|*
name|osm_sw
decl_stmt|;
name|uint8_t
name|order
index|[
name|IB_NODE_NUM_PORTS_MAX
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sw
operator|->
name|osm_switch
operator|&&
name|sw
operator|->
name|osm_switch
operator|->
name|priv
operator|==
name|sw
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E3D: sw->osm_switch->priv != sw "
literal|"for sw 0x%04"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|sw
operator|->
name|n_id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|osm_sw
operator|=
name|sw
operator|->
name|osm_switch
expr_stmt|;
name|memset
argument_list|(
name|osm_sw
operator|->
name|new_lft
argument_list|,
name|OSM_NO_PATH
argument_list|,
name|osm_sw
operator|->
name|lft_size
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|t
operator|->
name|switch_cnt
condition|;
name|s
operator|++
control|)
block|{
name|dsw
operator|=
name|t
operator|->
name|sw_pool
index|[
name|s
index|]
expr_stmt|;
name|pgrp
operator|=
operator|&
name|dsw
operator|->
name|ptgrp
index|[
literal|2
operator|*
name|TORUS_MAX_DIM
index|]
expr_stmt|;
name|memset
argument_list|(
name|order
argument_list|,
name|IB_INVALID_PORT_NUM
argument_list|,
sizeof|sizeof
argument_list|(
name|order
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|pgrp
operator|->
name|port_cnt
condition|;
name|p
operator|++
control|)
name|order
index|[
name|pgrp
operator|->
name|port
index|[
name|p
index|]
operator|->
name|port
index|]
operator|=
name|p
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|ARRAY_SIZE
argument_list|(
name|order
argument_list|)
condition|;
name|p
operator|++
control|)
block|{
name|uint8_t
name|px
init|=
name|order
index|[
name|t
operator|->
name|port_order
index|[
name|p
index|]
index|]
decl_stmt|;
if|if
condition|(
name|px
operator|==
name|IB_INVALID_PORT_NUM
condition|)
continue|continue;
if|if
condition|(
operator|!
name|get_lid
argument_list|(
name|pgrp
argument_list|,
name|px
argument_list|,
operator|&
name|dlid_base
argument_list|,
operator|&
name|dlid_lmc
argument_list|,
operator|&
name|ca
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|sw
operator|->
name|n_id
operator|==
name|dsw
operator|->
name|n_id
condition|)
name|dp
operator|=
name|pgrp
operator|->
name|port
index|[
name|px
index|]
operator|->
name|port
expr_stmt|;
else|else
name|dp
operator|=
name|lft_port
argument_list|(
name|t
argument_list|,
name|sw
argument_list|,
name|dsw
argument_list|,
name|true
argument_list|,
name|ca
argument_list|)
expr_stmt|;
comment|/* 			 * LMC> 0 doesn't really make sense for torus-2QoS. 			 * So, just make sure traffic gets delivered if 			 * non-zero LMC is used. 			 */
if|if
condition|(
name|dp
operator|>=
literal|0
condition|)
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
operator|(
literal|1U
operator|<<
name|dlid_lmc
operator|)
condition|;
name|l
operator|++
control|)
name|osm_sw
operator|->
name|new_lft
index|[
name|dlid_base
operator|+
name|l
index|]
operator|=
name|dp
expr_stmt|;
else|else
name|success
operator|=
name|false
expr_stmt|;
block|}
block|}
return|return
name|success
return|;
block|}
end_function

begin_function
specifier|static
name|osm_mtree_node_t
modifier|*
name|mcast_stree_branch
parameter_list|(
name|struct
name|t_switch
modifier|*
name|sw
parameter_list|,
name|osm_switch_t
modifier|*
name|osm_sw
parameter_list|,
name|osm_mgrp_box_t
modifier|*
name|mgb
parameter_list|,
name|unsigned
name|depth
parameter_list|,
name|unsigned
modifier|*
name|port_cnt
parameter_list|,
name|unsigned
modifier|*
name|max_depth
parameter_list|)
block|{
name|osm_mtree_node_t
modifier|*
name|mtn
init|=
name|NULL
decl_stmt|;
name|osm_mcast_tbl_t
modifier|*
name|mcast_tbl
decl_stmt|,
modifier|*
name|ds_mcast_tbl
decl_stmt|;
name|osm_node_t
modifier|*
name|ds_node
decl_stmt|;
name|struct
name|t_switch
modifier|*
name|ds_sw
decl_stmt|;
name|struct
name|port_grp
modifier|*
name|ptgrp
decl_stmt|;
name|struct
name|link
modifier|*
name|link
decl_stmt|;
name|struct
name|endpoint
modifier|*
name|port
decl_stmt|;
name|unsigned
name|g
decl_stmt|,
name|p
decl_stmt|;
name|unsigned
name|mcast_fwd_ports
init|=
literal|0
decl_stmt|,
name|mcast_end_ports
init|=
literal|0
decl_stmt|;
name|depth
operator|++
expr_stmt|;
if|if
condition|(
name|osm_sw
operator|->
name|priv
operator|!=
name|sw
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|sw
operator|->
name|torus
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E3E: osm_sw (GUID 0x%04"
name|PRIx64
literal|") "
literal|"not in torus fabric description\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|osm_sw
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|osm_switch_supports_mcast
argument_list|(
name|osm_sw
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|sw
operator|->
name|torus
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E3F: osm_sw (GUID 0x%04"
name|PRIx64
literal|") "
literal|"does not support multicast\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|osm_sw
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mtn
operator|=
name|osm_mtree_node_new
argument_list|(
name|osm_sw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mtn
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|sw
operator|->
name|torus
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E46: Insufficient memory to build multicast tree\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mcast_tbl
operator|=
name|osm_switch_get_mcast_tbl_ptr
argument_list|(
name|osm_sw
argument_list|)
expr_stmt|;
comment|/* 	 * Recurse to downstream switches, i.e. those closer to master 	 * spanning tree branch tips. 	 * 	 * Note that if there are multiple ports in this port group, i.e., 	 * multiple parallel links, we can pick any one of them to use for 	 * any individual MLID without causing loops.  Pick one based on MLID 	 * for now, until someone turns up evidence we need to be smarter. 	 * 	 * Also, it might be we got called in a window between a switch getting 	 * removed from the fabric, and torus-2QoS getting to rebuild its 	 * fabric representation.  If that were to happen, our next hop 	 * osm_switch pointer might be stale.  Look it up via opensm's fabric 	 * description to be sure it's not. 	 */
for|for
control|(
name|g
operator|=
literal|0
init|;
name|g
operator|<
literal|2
operator|*
name|TORUS_MAX_DIM
condition|;
name|g
operator|++
control|)
block|{
name|ptgrp
operator|=
operator|&
name|sw
operator|->
name|ptgrp
index|[
name|g
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|ptgrp
operator|->
name|to_stree_tip
condition|)
continue|continue;
name|p
operator|=
name|mgb
operator|->
name|mlid
operator|%
name|ptgrp
operator|->
name|port_cnt
expr_stmt|;
comment|/* port # in port group */
name|p
operator|=
name|ptgrp
operator|->
name|port
index|[
name|p
index|]
operator|->
name|port
expr_stmt|;
comment|/* now port # in switch */
name|ds_node
operator|=
name|osm_node_get_remote_node
argument_list|(
name|osm_sw
operator|->
name|p_node
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ds_sw
operator|=
name|ptgrp
operator|->
name|to_stree_tip
operator|->
name|sw
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ds_node
operator|&&
name|ds_node
operator|->
name|sw
operator|&&
name|ds_sw
operator|->
name|osm_switch
operator|==
name|ds_node
operator|->
name|sw
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|sw
operator|->
name|torus
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E40: stale pointer to osm_sw "
literal|"(GUID 0x%04"
name|PRIx64
literal|")\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|ds_sw
operator|->
name|n_id
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mtn
operator|->
name|child_array
index|[
name|p
index|]
operator|=
name|mcast_stree_branch
argument_list|(
name|ds_sw
argument_list|,
name|ds_node
operator|->
name|sw
argument_list|,
name|mgb
argument_list|,
name|depth
argument_list|,
name|port_cnt
argument_list|,
name|max_depth
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mtn
operator|->
name|child_array
index|[
name|p
index|]
condition|)
continue|continue;
name|osm_mcast_tbl_set
argument_list|(
name|mcast_tbl
argument_list|,
name|mgb
operator|->
name|mlid
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|mcast_fwd_ports
operator|++
expr_stmt|;
comment|/* 		 * Since we forward traffic for this multicast group on this 		 * port, cause the switch on the other end of the link 		 * to forward traffic back to us.  Do it now since have at 		 * hand the link used; otherwise it'll be hard to figure out 		 * later, and if we get it wrong we get a MC routing loop. 		 */
name|link
operator|=
name|sw
operator|->
name|port
index|[
name|p
index|]
operator|->
name|link
expr_stmt|;
name|ds_mcast_tbl
operator|=
name|osm_switch_get_mcast_tbl_ptr
argument_list|(
name|ds_node
operator|->
name|sw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|link
operator|->
name|end
index|[
literal|0
index|]
operator|==
name|sw
operator|->
name|port
index|[
name|p
index|]
condition|)
name|osm_mcast_tbl_set
argument_list|(
name|ds_mcast_tbl
argument_list|,
name|mgb
operator|->
name|mlid
argument_list|,
name|link
operator|->
name|end
index|[
literal|1
index|]
operator|.
name|port
argument_list|)
expr_stmt|;
else|else
name|osm_mcast_tbl_set
argument_list|(
name|ds_mcast_tbl
argument_list|,
name|mgb
operator|->
name|mlid
argument_list|,
name|link
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|port
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Add any host ports marked as in mcast group into spanning tree. 	 */
name|ptgrp
operator|=
operator|&
name|sw
operator|->
name|ptgrp
index|[
literal|2
operator|*
name|TORUS_MAX_DIM
index|]
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|ptgrp
operator|->
name|port_cnt
condition|;
name|p
operator|++
control|)
block|{
name|port
operator|=
name|ptgrp
operator|->
name|port
index|[
name|p
index|]
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|tmp
condition|)
block|{
name|port
operator|->
name|tmp
operator|=
name|NULL
expr_stmt|;
name|mtn
operator|->
name|child_array
index|[
name|port
operator|->
name|port
index|]
operator|=
name|OSM_MTREE_LEAF
expr_stmt|;
name|osm_mcast_tbl_set
argument_list|(
name|mcast_tbl
argument_list|,
name|mgb
operator|->
name|mlid
argument_list|,
name|port
operator|->
name|port
argument_list|)
expr_stmt|;
name|mcast_end_ports
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|mcast_end_ports
operator|||
name|mcast_fwd_ports
operator|)
condition|)
block|{
name|osm_mtree_destroy
argument_list|(
name|mtn
argument_list|)
expr_stmt|;
name|mtn
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|depth
operator|>
operator|*
name|max_depth
condition|)
operator|*
name|max_depth
operator|=
name|depth
expr_stmt|;
operator|*
name|port_cnt
operator|+=
name|mcast_end_ports
expr_stmt|;
name|out
label|:
return|return
name|mtn
return|;
block|}
end_function

begin_function
specifier|static
name|osm_port_t
modifier|*
name|next_mgrp_box_port
parameter_list|(
name|osm_mgrp_box_t
modifier|*
name|mgb
parameter_list|,
name|cl_list_item_t
modifier|*
modifier|*
name|list_iterator
parameter_list|,
name|cl_map_item_t
modifier|*
modifier|*
name|map_iterator
parameter_list|)
block|{
name|osm_mgrp_t
modifier|*
name|mgrp
decl_stmt|;
name|osm_mcm_port_t
modifier|*
name|mcm_port
decl_stmt|;
name|osm_port_t
modifier|*
name|osm_port
init|=
name|NULL
decl_stmt|;
name|cl_map_item_t
modifier|*
name|m_item
init|=
operator|*
name|map_iterator
decl_stmt|;
name|cl_list_item_t
modifier|*
name|l_item
init|=
operator|*
name|list_iterator
decl_stmt|;
name|next_mgrp
label|:
if|if
condition|(
operator|!
name|l_item
condition|)
name|l_item
operator|=
name|cl_qlist_head
argument_list|(
operator|&
name|mgb
operator|->
name|mgrp_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_item
operator|==
name|cl_qlist_end
argument_list|(
operator|&
name|mgb
operator|->
name|mgrp_list
argument_list|)
condition|)
block|{
name|l_item
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mgrp
operator|=
name|cl_item_obj
argument_list|(
name|l_item
argument_list|,
name|mgrp
argument_list|,
name|list_item
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m_item
condition|)
name|m_item
operator|=
name|cl_qmap_head
argument_list|(
operator|&
name|mgrp
operator|->
name|mcm_port_tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_item
operator|==
name|cl_qmap_end
argument_list|(
operator|&
name|mgrp
operator|->
name|mcm_port_tbl
argument_list|)
condition|)
block|{
name|m_item
operator|=
name|NULL
expr_stmt|;
name|l_item
operator|=
name|cl_qlist_next
argument_list|(
name|l_item
argument_list|)
expr_stmt|;
goto|goto
name|next_mgrp
goto|;
block|}
name|mcm_port
operator|=
name|cl_item_obj
argument_list|(
name|m_item
argument_list|,
name|mcm_port
argument_list|,
name|map_item
argument_list|)
expr_stmt|;
name|m_item
operator|=
name|cl_qmap_next
argument_list|(
name|m_item
argument_list|)
expr_stmt|;
name|osm_port
operator|=
name|mcm_port
operator|->
name|port
expr_stmt|;
name|out
label|:
operator|*
name|list_iterator
operator|=
name|l_item
expr_stmt|;
operator|*
name|map_iterator
operator|=
name|m_item
expr_stmt|;
return|return
name|osm_port
return|;
block|}
end_function

begin_function
specifier|static
name|ib_api_status_t
name|torus_mcast_stree
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|osm_mgrp_box_t
modifier|*
name|mgb
parameter_list|)
block|{
name|struct
name|torus_context
modifier|*
name|ctx
init|=
name|context
decl_stmt|;
name|struct
name|torus
modifier|*
name|t
init|=
name|ctx
operator|->
name|torus
decl_stmt|;
name|cl_map_item_t
modifier|*
name|m_item
init|=
name|NULL
decl_stmt|;
name|cl_list_item_t
modifier|*
name|l_item
init|=
name|NULL
decl_stmt|;
name|osm_port_t
modifier|*
name|osm_port
decl_stmt|;
name|osm_switch_t
modifier|*
name|osm_sw
decl_stmt|;
name|struct
name|endpoint
modifier|*
name|port
decl_stmt|;
name|unsigned
name|port_cnt
init|=
literal|0
decl_stmt|,
name|max_depth
init|=
literal|0
decl_stmt|;
name|osm_purge_mtree
argument_list|(
operator|&
name|ctx
operator|->
name|osm
operator|->
name|sm
argument_list|,
name|mgb
argument_list|)
expr_stmt|;
comment|/* 	 * Build a spanning tree for a multicast group by first marking 	 * the torus endpoints that are participating in the group. 	 * Then do a depth-first search of the torus master spanning 	 * tree to build up the spanning tree specific to this group. 	 * 	 * Since the torus master spanning tree is constructed specifically 	 * to guarantee that multicast will not deadlock against unicast 	 * when they share VLs, we can be sure that any multicast group 	 * spanning tree constructed this way has the same property. 	 */
while|while
condition|(
operator|(
name|osm_port
operator|=
name|next_mgrp_box_port
argument_list|(
name|mgb
argument_list|,
operator|&
name|l_item
argument_list|,
operator|&
name|m_item
argument_list|)
operator|)
condition|)
block|{
name|port
operator|=
name|osm_port
operator|->
name|priv
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|port
operator|&&
name|port
operator|->
name|osm_port
operator|==
name|osm_port
operator|)
condition|)
block|{
name|port
operator|=
name|osm_port_relink_endpoint
argument_list|(
name|osm_port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port
condition|)
block|{
name|guid_t
name|id
decl_stmt|;
name|id
operator|=
name|osm_node_get_node_guid
argument_list|(
name|osm_port
operator|->
name|p_node
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|ctx
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E41: osm_port (GUID 0x%04"
name|PRIx64
literal|") "
literal|"not in torus fabric description\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 		 * If this is a CA port, mark the switch port at the 		 * other end of this port's link. 		 * 		 * By definition, a CA port is connected to end[1] of a link, 		 * and the switch port is end[0].  See build_ca_link() and 		 * link_srcsink(). 		 */
if|if
condition|(
name|port
operator|->
name|link
condition|)
name|port
operator|=
operator|&
name|port
operator|->
name|link
operator|->
name|end
index|[
literal|0
index|]
expr_stmt|;
name|port
operator|->
name|tmp
operator|=
name|osm_port
expr_stmt|;
block|}
comment|/* 	 * It might be we got called in a window between a switch getting 	 * removed from the fabric, and torus-2QoS getting to rebuild its 	 * fabric representation.  If that were to happen, our 	 * master_stree_root->osm_switch pointer might be stale.  Look up 	 * the osm_switch by GUID to be sure it's not. 	 * 	 * Also, call into mcast_stree_branch with depth = -1, because 	 * depth at root switch needs to be 0. 	 */
name|osm_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_get
argument_list|(
operator|&
name|ctx
operator|->
name|osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|,
name|t
operator|->
name|master_stree_root
operator|->
name|n_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|osm_sw
operator|&&
name|t
operator|->
name|master_stree_root
operator|->
name|osm_switch
operator|==
name|osm_sw
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|ctx
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E42: stale pointer to osm_sw (GUID 0x%04"
name|PRIx64
literal|")\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|t
operator|->
name|master_stree_root
operator|->
name|n_id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|IB_ERROR
return|;
block|}
name|mgb
operator|->
name|root
operator|=
name|mcast_stree_branch
argument_list|(
name|t
operator|->
name|master_stree_root
argument_list|,
name|osm_sw
argument_list|,
name|mgb
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|port_cnt
argument_list|,
operator|&
name|max_depth
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|ctx
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Configured MLID 0x%X for %u ports, max tree depth = %u\n"
argument_list|,
name|mgb
operator|->
name|mlid
argument_list|,
name|port_cnt
argument_list|,
name|max_depth
argument_list|)
expr_stmt|;
return|return
name|IB_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|good_xy_ring
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
specifier|const
name|int
name|x
parameter_list|,
specifier|const
name|int
name|y
parameter_list|,
specifier|const
name|int
name|z
parameter_list|)
block|{
name|struct
name|t_switch
modifier|*
modifier|*
modifier|*
modifier|*
name|sw
init|=
name|t
operator|->
name|sw
decl_stmt|;
name|bool
name|good_ring
init|=
name|true
decl_stmt|;
name|int
name|x_tst
decl_stmt|,
name|y_tst
decl_stmt|;
for|for
control|(
name|x_tst
operator|=
literal|0
init|;
name|x_tst
operator|<
name|t
operator|->
name|x_sz
operator|&&
name|good_ring
condition|;
name|x_tst
operator|++
control|)
name|good_ring
operator|=
name|sw
index|[
name|x_tst
index|]
index|[
name|y
index|]
index|[
name|z
index|]
expr_stmt|;
for|for
control|(
name|y_tst
operator|=
literal|0
init|;
name|y_tst
operator|<
name|t
operator|->
name|y_sz
operator|&&
name|good_ring
condition|;
name|y_tst
operator|++
control|)
name|good_ring
operator|=
name|sw
index|[
name|x
index|]
index|[
name|y_tst
index|]
index|[
name|z
index|]
expr_stmt|;
return|return
name|good_ring
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|t_switch
modifier|*
name|find_plane_mid
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|,
specifier|const
name|int
name|z
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|dx
decl_stmt|,
name|xm
init|=
name|t
operator|->
name|x_sz
operator|/
literal|2
decl_stmt|;
name|int
name|y
decl_stmt|,
name|dy
decl_stmt|,
name|ym
init|=
name|t
operator|->
name|y_sz
operator|/
literal|2
decl_stmt|;
name|struct
name|t_switch
modifier|*
modifier|*
modifier|*
modifier|*
name|sw
init|=
name|t
operator|->
name|sw
decl_stmt|;
if|if
condition|(
name|good_xy_ring
argument_list|(
name|t
argument_list|,
name|xm
argument_list|,
name|ym
argument_list|,
name|z
argument_list|)
condition|)
return|return
name|sw
index|[
name|xm
index|]
index|[
name|ym
index|]
index|[
name|z
index|]
return|;
for|for
control|(
name|dx
operator|=
literal|1
operator|,
name|dy
operator|=
literal|1
init|;
name|dx
operator|<=
name|xm
operator|&&
name|dy
operator|<=
name|ym
condition|;
name|dx
operator|++
operator|,
name|dy
operator|++
control|)
block|{
name|x
operator|=
name|canonicalize
argument_list|(
name|xm
operator|-
name|dx
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
expr_stmt|;
name|y
operator|=
name|canonicalize
argument_list|(
name|ym
operator|-
name|dy
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|good_xy_ring
argument_list|(
name|t
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
condition|)
return|return
name|sw
index|[
name|x
index|]
index|[
name|y
index|]
index|[
name|z
index|]
return|;
name|x
operator|=
name|canonicalize
argument_list|(
name|xm
operator|+
name|dx
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
expr_stmt|;
name|y
operator|=
name|canonicalize
argument_list|(
name|ym
operator|+
name|dy
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|good_xy_ring
argument_list|(
name|t
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
condition|)
return|return
name|sw
index|[
name|x
index|]
index|[
name|y
index|]
index|[
name|z
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|t_switch
modifier|*
name|find_stree_root
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|,
name|dz
decl_stmt|,
name|zm
init|=
name|t
operator|->
name|z_sz
operator|/
literal|2
decl_stmt|;
name|struct
name|t_switch
modifier|*
modifier|*
modifier|*
modifier|*
name|sw
init|=
name|t
operator|->
name|sw
decl_stmt|;
name|struct
name|t_switch
modifier|*
name|root
decl_stmt|;
name|bool
name|good_plane
decl_stmt|;
comment|/* 	 * Look for a switch near the "center" (wrt. the datelines) of the 	 * torus, as that will be the most optimum spanning tree root.  Use 	 * a search that is not exhaustive, on the theory that this routing 	 * engine isn't useful anyway if too many switches are missing. 	 * 	 * Also, want to pick an x-y plane with no missing switches, so that 	 * the master spanning tree construction algorithm doesn't have to 	 * deal with needing a turn on a missing switch. 	 */
for|for
control|(
name|dz
operator|=
literal|0
init|;
name|dz
operator|<=
name|zm
condition|;
name|dz
operator|++
control|)
block|{
name|z
operator|=
name|canonicalize
argument_list|(
name|zm
operator|-
name|dz
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
expr_stmt|;
name|good_plane
operator|=
name|true
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|t
operator|->
name|y_sz
operator|&&
name|good_plane
condition|;
name|y
operator|++
control|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|t
operator|->
name|x_sz
operator|&&
name|good_plane
condition|;
name|x
operator|++
control|)
name|good_plane
operator|=
name|sw
index|[
name|x
index|]
index|[
name|y
index|]
index|[
name|z
index|]
expr_stmt|;
if|if
condition|(
name|good_plane
condition|)
block|{
name|root
operator|=
name|find_plane_mid
argument_list|(
name|t
argument_list|,
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|dz
condition|)
continue|continue;
name|z
operator|=
name|canonicalize
argument_list|(
name|zm
operator|+
name|dz
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
expr_stmt|;
name|good_plane
operator|=
name|true
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|t
operator|->
name|y_sz
operator|&&
name|good_plane
condition|;
name|y
operator|++
control|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|t
operator|->
name|x_sz
operator|&&
name|good_plane
condition|;
name|x
operator|++
control|)
name|good_plane
operator|=
name|sw
index|[
name|x
index|]
index|[
name|y
index|]
index|[
name|z
index|]
expr_stmt|;
if|if
condition|(
name|good_plane
condition|)
block|{
name|root
operator|=
name|find_plane_mid
argument_list|(
name|t
argument_list|,
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
condition|)
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * Note that torus-2QoS can route a torus that is missing an entire 	 * column (switches with x,y constant, for all z values) without 	 * deadlocks. 	 * 	 * if we've reached this point, we must have a column of missing 	 * switches, as routable_torus() would have returned false for 	 * any other configuration of missing switches that made it through 	 * the above. 	 * 	 * So any switch in the mid-z plane will do as the root. 	 */
name|root
operator|=
name|find_plane_mid
argument_list|(
name|t
argument_list|,
name|zm
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|root
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|sw_in_master_stree
parameter_list|(
name|struct
name|t_switch
modifier|*
name|sw
parameter_list|)
block|{
name|int
name|g
decl_stmt|;
name|bool
name|connected
decl_stmt|;
name|connected
operator|=
name|sw
operator|==
name|sw
operator|->
name|torus
operator|->
name|master_stree_root
expr_stmt|;
for|for
control|(
name|g
operator|=
literal|0
init|;
name|g
operator|<
literal|2
operator|*
name|TORUS_MAX_DIM
condition|;
name|g
operator|++
control|)
name|connected
operator|=
name|connected
operator|||
name|sw
operator|->
name|ptgrp
index|[
name|g
index|]
operator|.
name|to_stree_root
expr_stmt|;
return|return
name|connected
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|grow_master_stree_branch
parameter_list|(
name|struct
name|t_switch
modifier|*
name|root
parameter_list|,
name|struct
name|t_switch
modifier|*
name|tip
parameter_list|,
name|unsigned
name|to_root_pg
parameter_list|,
name|unsigned
name|to_tip_pg
parameter_list|)
block|{
name|root
operator|->
name|ptgrp
index|[
name|to_tip_pg
index|]
operator|.
name|to_stree_tip
operator|=
operator|&
name|tip
operator|->
name|ptgrp
index|[
name|to_root_pg
index|]
expr_stmt|;
name|tip
operator|->
name|ptgrp
index|[
name|to_root_pg
index|]
operator|.
name|to_stree_root
operator|=
operator|&
name|root
operator|->
name|ptgrp
index|[
name|to_tip_pg
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_master_stree_branch
parameter_list|(
name|struct
name|t_switch
modifier|*
name|branch_root
parameter_list|,
name|int
name|cdir
parameter_list|)
block|{
name|struct
name|t_switch
modifier|*
name|sw
decl_stmt|,
modifier|*
name|n_sw
decl_stmt|,
modifier|*
name|p_sw
decl_stmt|;
name|unsigned
name|l
decl_stmt|,
name|idx
decl_stmt|,
name|cnt
decl_stmt|,
name|pg
decl_stmt|,
name|ng
decl_stmt|;
switch|switch
condition|(
name|cdir
condition|)
block|{
case|case
literal|0
case|:
name|idx
operator|=
name|branch_root
operator|->
name|i
expr_stmt|;
name|cnt
operator|=
name|branch_root
operator|->
name|torus
operator|->
name|x_sz
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|idx
operator|=
name|branch_root
operator|->
name|j
expr_stmt|;
name|cnt
operator|=
name|branch_root
operator|->
name|torus
operator|->
name|y_sz
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|idx
operator|=
name|branch_root
operator|->
name|k
expr_stmt|;
name|cnt
operator|=
name|branch_root
operator|->
name|torus
operator|->
name|z_sz
expr_stmt|;
break|break;
default|default:
goto|goto
name|out
goto|;
block|}
comment|/* 	 * This algorithm intends that a spanning tree branch never crosses 	 * a dateline unless the 1-D ring for which we're building the branch 	 * is interrupted by failure.  We need that guarantee to prevent 	 * multicast/unicast credit loops. 	 */
name|n_sw
operator|=
name|branch_root
expr_stmt|;
comment|/* tip of negative cdir branch */
name|ng
operator|=
literal|2
operator|*
name|cdir
expr_stmt|;
comment|/* negative cdir port group index */
name|p_sw
operator|=
name|branch_root
expr_stmt|;
comment|/* tip of positive cdir branch */
name|pg
operator|=
literal|2
operator|*
name|cdir
operator|+
literal|1
expr_stmt|;
comment|/* positive cdir port group index */
for|for
control|(
name|l
operator|=
name|idx
init|;
name|n_sw
operator|&&
name|l
operator|>=
literal|1
condition|;
name|l
operator|--
control|)
block|{
name|sw
operator|=
name|ring_next_sw
argument_list|(
name|n_sw
argument_list|,
name|cdir
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
operator|&&
operator|!
name|sw_in_master_stree
argument_list|(
name|sw
argument_list|)
condition|)
block|{
name|grow_master_stree_branch
argument_list|(
name|n_sw
argument_list|,
name|sw
argument_list|,
name|pg
argument_list|,
name|ng
argument_list|)
expr_stmt|;
name|n_sw
operator|=
name|sw
expr_stmt|;
block|}
else|else
name|n_sw
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|l
operator|=
name|idx
init|;
name|p_sw
operator|&&
name|l
operator|<
operator|(
name|cnt
operator|-
literal|1
operator|)
condition|;
name|l
operator|++
control|)
block|{
name|sw
operator|=
name|ring_next_sw
argument_list|(
name|p_sw
argument_list|,
name|cdir
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
operator|&&
operator|!
name|sw_in_master_stree
argument_list|(
name|sw
argument_list|)
condition|)
block|{
name|grow_master_stree_branch
argument_list|(
name|p_sw
argument_list|,
name|sw
argument_list|,
name|ng
argument_list|,
name|pg
argument_list|)
expr_stmt|;
name|p_sw
operator|=
name|sw
expr_stmt|;
block|}
else|else
name|p_sw
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|n_sw
operator|&&
name|p_sw
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * At least one branch couldn't grow to the dateline for this ring. 	 * That means it is acceptable to grow the branch by crossing the 	 * dateline. 	 */
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|cnt
condition|;
name|l
operator|++
control|)
block|{
if|if
condition|(
name|n_sw
condition|)
block|{
name|sw
operator|=
name|ring_next_sw
argument_list|(
name|n_sw
argument_list|,
name|cdir
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
operator|&&
operator|!
name|sw_in_master_stree
argument_list|(
name|sw
argument_list|)
condition|)
block|{
name|grow_master_stree_branch
argument_list|(
name|n_sw
argument_list|,
name|sw
argument_list|,
name|pg
argument_list|,
name|ng
argument_list|)
expr_stmt|;
name|n_sw
operator|=
name|sw
expr_stmt|;
block|}
else|else
name|n_sw
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|p_sw
condition|)
block|{
name|sw
operator|=
name|ring_next_sw
argument_list|(
name|p_sw
argument_list|,
name|cdir
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
operator|&&
operator|!
name|sw_in_master_stree
argument_list|(
name|sw
argument_list|)
condition|)
block|{
name|grow_master_stree_branch
argument_list|(
name|p_sw
argument_list|,
name|sw
argument_list|,
name|ng
argument_list|,
name|pg
argument_list|)
expr_stmt|;
name|p_sw
operator|=
name|sw
expr_stmt|;
block|}
else|else
name|p_sw
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|n_sw
operator|||
name|p_sw
operator|)
condition|)
break|break;
block|}
name|out
label|:
return|return;
block|}
end_function

begin_function
specifier|static
name|bool
name|torus_master_stree
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|bool
name|success
init|=
name|false
decl_stmt|;
name|struct
name|t_switch
modifier|*
name|stree_root
init|=
name|find_stree_root
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|stree_root
condition|)
name|build_master_stree_branch
argument_list|(
name|stree_root
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
goto|goto
name|out
goto|;
name|k
operator|=
name|stree_root
operator|->
name|k
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|x_sz
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|stree_root
operator|->
name|j
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
condition|)
name|build_master_stree_branch
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|t
operator|->
name|y_sz
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
condition|)
name|build_master_stree_branch
argument_list|(
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|t
operator|->
name|master_stree_root
operator|=
name|stree_root
expr_stmt|;
comment|/* 	 * At this point we should have a master spanning tree that contains 	 * every present switch, for all fabrics that torus-2QoS can route 	 * without deadlocks.  Make sure this is the case; otherwise warn 	 * and return failure so we get bug reports. 	 */
name|success
operator|=
name|true
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|x_sz
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|t
operator|->
name|y_sz
condition|;
name|j
operator|++
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|t
operator|->
name|z_sz
condition|;
name|k
operator|++
control|)
block|{
name|struct
name|t_switch
modifier|*
name|sw
init|=
name|t
operator|->
name|sw
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|sw
operator|||
name|sw_in_master_stree
argument_list|(
name|sw
argument_list|)
condition|)
continue|continue;
name|success
operator|=
name|false
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|t
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E43: sw 0x%04"
name|PRIx64
literal|" (%d,%d,%d) not in "
literal|"torus multicast master spanning tree\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|sw
operator|->
name|n_id
argument_list|)
argument_list|,
name|i
argument_list|,
name|j
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|success
return|;
block|}
end_function

begin_function
name|int
name|route_torus
parameter_list|(
name|struct
name|torus
modifier|*
name|t
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|bool
name|success
init|=
name|true
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
operator|(
name|int
operator|)
name|t
operator|->
name|switch_cnt
condition|;
name|s
operator|++
control|)
name|success
operator|=
name|torus_lft
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|sw_pool
index|[
name|s
index|]
argument_list|)
operator|&&
name|success
expr_stmt|;
name|success
operator|=
name|success
operator|&&
name|torus_master_stree
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|success
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|uint8_t
name|torus_path_sl
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|uint8_t
name|path_sl_hint
parameter_list|,
specifier|const
name|ib_net16_t
name|slid
parameter_list|,
specifier|const
name|ib_net16_t
name|dlid
parameter_list|)
block|{
name|struct
name|torus_context
modifier|*
name|ctx
init|=
name|context
decl_stmt|;
name|osm_opensm_t
modifier|*
name|p_osm
init|=
name|ctx
operator|->
name|osm
decl_stmt|;
name|osm_log_t
modifier|*
name|log
init|=
operator|&
name|p_osm
operator|->
name|log
decl_stmt|;
name|osm_port_t
modifier|*
name|osm_sport
decl_stmt|,
modifier|*
name|osm_dport
decl_stmt|;
name|struct
name|endpoint
modifier|*
name|sport
decl_stmt|,
modifier|*
name|dport
decl_stmt|;
name|struct
name|t_switch
modifier|*
name|ssw
decl_stmt|,
modifier|*
name|dsw
decl_stmt|;
name|struct
name|torus
modifier|*
name|t
decl_stmt|;
name|guid_t
name|guid
decl_stmt|;
name|unsigned
name|sl
init|=
literal|0
decl_stmt|;
name|osm_sport
operator|=
name|osm_get_port_by_lid
argument_list|(
operator|&
name|p_osm
operator|->
name|subn
argument_list|,
name|slid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|osm_sport
condition|)
goto|goto
name|out
goto|;
name|osm_dport
operator|=
name|osm_get_port_by_lid
argument_list|(
operator|&
name|p_osm
operator|->
name|subn
argument_list|,
name|dlid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|osm_dport
condition|)
goto|goto
name|out
goto|;
name|sport
operator|=
name|osm_sport
operator|->
name|priv
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sport
operator|&&
name|sport
operator|->
name|osm_port
operator|==
name|osm_sport
operator|)
condition|)
block|{
name|sport
operator|=
name|osm_port_relink_endpoint
argument_list|(
name|osm_sport
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sport
condition|)
block|{
name|guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|osm_sport
operator|->
name|p_node
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Note: osm_sport (GUID 0x%04"
name|PRIx64
literal|") "
literal|"not in torus fabric description\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|guid
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|dport
operator|=
name|osm_dport
operator|->
name|priv
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dport
operator|&&
name|dport
operator|->
name|osm_port
operator|==
name|osm_dport
operator|)
condition|)
block|{
name|dport
operator|=
name|osm_port_relink_endpoint
argument_list|(
name|osm_dport
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dport
condition|)
block|{
name|guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|osm_dport
operator|->
name|p_node
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Note: osm_dport (GUID 0x%04"
name|PRIx64
literal|") "
literal|"not in torus fabric description\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|guid
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * We're only supposed to be called for CA ports, and maybe 	 * switch management ports. 	 */
if|if
condition|(
name|sport
operator|->
name|type
operator|!=
name|SRCSINK
condition|)
block|{
name|guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|osm_sport
operator|->
name|p_node
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Error: osm_sport (GUID 0x%04"
name|PRIx64
literal|") "
literal|"not a data src/sink port\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|guid
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|dport
operator|->
name|type
operator|!=
name|SRCSINK
condition|)
block|{
name|guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|osm_dport
operator|->
name|p_node
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Error: osm_dport (GUID 0x%04"
name|PRIx64
literal|") "
literal|"not a data src/sink port\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|guid
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * By definition, a CA port is connected to end[1] of a link, and 	 * the switch port is end[0].  See build_ca_link() and link_srcsink(). 	 */
if|if
condition|(
name|sport
operator|->
name|link
condition|)
block|{
name|ssw
operator|=
name|sport
operator|->
name|link
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|sw
expr_stmt|;
block|}
else|else
block|{
name|ssw
operator|=
name|sport
operator|->
name|sw
expr_stmt|;
block|}
if|if
condition|(
name|dport
operator|->
name|link
condition|)
name|dsw
operator|=
name|dport
operator|->
name|link
operator|->
name|end
index|[
literal|0
index|]
operator|.
name|sw
expr_stmt|;
else|else
name|dsw
operator|=
name|dport
operator|->
name|sw
expr_stmt|;
name|t
operator|=
name|ssw
operator|->
name|torus
expr_stmt|;
name|sl
operator|=
name|sl_set_use_loop_vl
argument_list|(
name|use_vl1
argument_list|(
name|ssw
operator|->
name|i
argument_list|,
name|dsw
operator|->
name|i
argument_list|,
name|t
operator|->
name|x_sz
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sl
operator||=
name|sl_set_use_loop_vl
argument_list|(
name|use_vl1
argument_list|(
name|ssw
operator|->
name|j
argument_list|,
name|dsw
operator|->
name|j
argument_list|,
name|t
operator|->
name|y_sz
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sl
operator||=
name|sl_set_use_loop_vl
argument_list|(
name|use_vl1
argument_list|(
name|ssw
operator|->
name|k
argument_list|,
name|dsw
operator|->
name|k
argument_list|,
name|t
operator|->
name|z_sz
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sl
operator||=
name|sl_set_qos
argument_list|(
name|sl_get_qos
argument_list|(
name|path_sl_hint
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|sl
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sum_vlarb_weights
parameter_list|(
specifier|const
name|char
modifier|*
name|vlarb_str
parameter_list|,
name|unsigned
name|total_weight
index|[
name|IB_MAX_NUM_VLS
index|]
parameter_list|)
block|{
name|unsigned
name|i
init|=
literal|0
decl_stmt|,
name|v
decl_stmt|,
name|vl
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
while|while
condition|(
operator|*
name|vlarb_str
operator|&&
name|i
operator|++
operator|<
literal|2
operator|*
name|IB_NUM_VL_ARB_ELEMENTS_IN_BLOCK
condition|)
block|{
name|v
operator|=
name|strtoul
argument_list|(
name|vlarb_str
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
condition|)
name|end
operator|++
expr_stmt|;
name|vlarb_str
operator|=
name|end
expr_stmt|;
if|if
condition|(
name|i
operator|&
literal|0x1
condition|)
name|vl
operator|=
name|v
operator|&
literal|0xf
expr_stmt|;
else|else
name|total_weight
index|[
name|vl
index|]
operator|+=
name|v
operator|&
literal|0xff
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|uniform_vlarb_weight_value
parameter_list|(
name|unsigned
modifier|*
name|weight
parameter_list|,
name|unsigned
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|v
init|=
name|weight
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|v
operator|!=
name|weight
index|[
name|i
index|]
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
name|v
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_vlarb_config
parameter_list|(
specifier|const
name|char
modifier|*
name|vlarb_str
parameter_list|,
name|bool
name|is_default
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|pri
parameter_list|,
name|osm_log_t
modifier|*
name|log
parameter_list|)
block|{
name|unsigned
name|total_weight
index|[
name|IB_MAX_NUM_VLS
index|]
init|=
block|{
literal|0
block|,}
decl_stmt|;
name|sum_vlarb_weights
argument_list|(
name|vlarb_str
argument_list|,
name|total_weight
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|uniform_vlarb_weight_value
argument_list|(
operator|&
name|total_weight
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|)
operator|>=
literal|0
operator|&&
name|uniform_vlarb_weight_value
argument_list|(
operator|&
name|total_weight
index|[
literal|4
index|]
argument_list|,
literal|4
argument_list|)
operator|>=
literal|0
operator|)
condition|)
name|OSM_LOG
argument_list|(
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Warning: torus-2QoS requires same VLarb weights for "
literal|"VLs 0-3; also for VLs 4-7: not true for %s "
literal|"%s_vlarb_%s\n"
argument_list|,
operator|(
name|is_default
condition|?
literal|"default"
else|:
literal|"configured"
operator|)
argument_list|,
name|str
argument_list|,
name|pri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Use this to check the qos_config for switch external ports.  */
end_comment

begin_function
specifier|static
name|void
name|check_qos_swe_config
parameter_list|(
name|osm_qos_options_t
modifier|*
name|opt
parameter_list|,
name|osm_qos_options_t
modifier|*
name|def
parameter_list|,
name|osm_log_t
modifier|*
name|log
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|vlarb_str
decl_stmt|,
modifier|*
name|tstr
decl_stmt|;
name|bool
name|is_default
decl_stmt|;
name|unsigned
name|max_vls
decl_stmt|;
name|max_vls
operator|=
name|def
operator|->
name|max_vls
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|max_vls
operator|>
literal|0
condition|)
name|max_vls
operator|=
name|opt
operator|->
name|max_vls
expr_stmt|;
if|if
condition|(
name|max_vls
operator|>
literal|0
operator|&&
name|max_vls
operator|<
literal|8
condition|)
name|OSM_LOG
argument_list|(
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Warning: full torus-2QoS functionality not available "
literal|"for configured %s_max_vls = %d\n"
argument_list|,
operator|(
name|opt
operator|->
name|max_vls
operator|>
literal|0
condition|?
literal|"qos_swe"
else|:
literal|"qos"
operator|)
argument_list|,
name|opt
operator|->
name|max_vls
argument_list|)
expr_stmt|;
name|vlarb_str
operator|=
name|opt
operator|->
name|vlarb_high
expr_stmt|;
name|is_default
operator|=
name|false
expr_stmt|;
name|tstr
operator|=
literal|"qos_swe"
expr_stmt|;
if|if
condition|(
operator|!
name|vlarb_str
condition|)
block|{
name|vlarb_str
operator|=
name|def
operator|->
name|vlarb_high
expr_stmt|;
name|tstr
operator|=
literal|"qos"
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vlarb_str
condition|)
block|{
name|vlarb_str
operator|=
name|OSM_DEFAULT_QOS_VLARB_HIGH
expr_stmt|;
name|is_default
operator|=
name|true
expr_stmt|;
block|}
name|check_vlarb_config
argument_list|(
name|vlarb_str
argument_list|,
name|is_default
argument_list|,
name|tstr
argument_list|,
literal|"high"
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|vlarb_str
operator|=
name|opt
operator|->
name|vlarb_low
expr_stmt|;
name|is_default
operator|=
name|false
expr_stmt|;
name|tstr
operator|=
literal|"qos_swe"
expr_stmt|;
if|if
condition|(
operator|!
name|vlarb_str
condition|)
block|{
name|vlarb_str
operator|=
name|def
operator|->
name|vlarb_low
expr_stmt|;
name|tstr
operator|=
literal|"qos"
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vlarb_str
condition|)
block|{
name|vlarb_str
operator|=
name|OSM_DEFAULT_QOS_VLARB_LOW
expr_stmt|;
name|is_default
operator|=
name|true
expr_stmt|;
block|}
name|check_vlarb_config
argument_list|(
name|vlarb_str
argument_list|,
name|is_default
argument_list|,
name|tstr
argument_list|,
literal|"low"
argument_list|,
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|sl2vl
condition|)
name|OSM_LOG
argument_list|(
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Warning: torus-2QoS must override configured "
literal|"qos_swe_sl2vl to generate deadlock-free routes\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_ep_vlarb_config
parameter_list|(
specifier|const
name|char
modifier|*
name|vlarb_str
parameter_list|,
name|bool
name|is_default
parameter_list|,
name|bool
name|is_specific
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|pri
parameter_list|,
name|osm_log_t
modifier|*
name|log
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|total_weight
index|[
name|IB_MAX_NUM_VLS
index|]
init|=
block|{
literal|0
block|,}
decl_stmt|;
name|int
name|val
init|=
literal|0
decl_stmt|;
name|sum_vlarb_weights
argument_list|(
name|vlarb_str
argument_list|,
name|total_weight
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|+=
name|total_weight
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|val
condition|)
return|return;
if|if
condition|(
name|is_specific
condition|)
name|OSM_LOG
argument_list|(
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Warning: torus-2QoS recommends 0 VLarb weights"
literal|" for VLs 2-7 on endpoint links; not true for "
literal|" configured %s_vlarb_%s\n"
argument_list|,
name|str
argument_list|,
name|pri
argument_list|)
expr_stmt|;
else|else
name|OSM_LOG
argument_list|(
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Warning: torus-2QoS recommends 0 VLarb weights "
literal|"for VLs 2-7 on endpoint links; not true for %s "
literal|"qos_vlarb_%s values used for %s_vlarb_%s\n"
argument_list|,
operator|(
name|is_default
condition|?
literal|"default"
else|:
literal|"configured"
operator|)
argument_list|,
name|pri
argument_list|,
name|str
argument_list|,
name|pri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Use this to check the qos_config for endports  */
end_comment

begin_function
specifier|static
name|void
name|check_qos_ep_config
parameter_list|(
name|osm_qos_options_t
modifier|*
name|opt
parameter_list|,
name|osm_qos_options_t
modifier|*
name|def
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|osm_log_t
modifier|*
name|log
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|vlarb_str
decl_stmt|;
name|bool
name|is_default
decl_stmt|,
name|is_specific
decl_stmt|;
name|unsigned
name|max_vls
decl_stmt|;
name|max_vls
operator|=
name|def
operator|->
name|max_vls
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|max_vls
operator|>
literal|0
condition|)
name|max_vls
operator|=
name|opt
operator|->
name|max_vls
expr_stmt|;
if|if
condition|(
name|max_vls
operator|>
literal|0
operator|&&
name|max_vls
operator|<
literal|2
condition|)
name|OSM_LOG
argument_list|(
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Warning: full torus-2QoS functionality not available "
literal|"for configured %s_max_vls = %d\n"
argument_list|,
operator|(
name|opt
operator|->
name|max_vls
operator|>
literal|0
condition|?
name|str
else|:
literal|"qos"
operator|)
argument_list|,
name|opt
operator|->
name|max_vls
argument_list|)
expr_stmt|;
name|vlarb_str
operator|=
name|opt
operator|->
name|vlarb_high
expr_stmt|;
name|is_default
operator|=
name|false
expr_stmt|;
name|is_specific
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|vlarb_str
condition|)
block|{
name|vlarb_str
operator|=
name|def
operator|->
name|vlarb_high
expr_stmt|;
name|is_specific
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vlarb_str
condition|)
block|{
name|vlarb_str
operator|=
name|OSM_DEFAULT_QOS_VLARB_HIGH
expr_stmt|;
name|is_default
operator|=
name|true
expr_stmt|;
block|}
name|check_ep_vlarb_config
argument_list|(
name|vlarb_str
argument_list|,
name|is_default
argument_list|,
name|is_specific
argument_list|,
name|str
argument_list|,
literal|"high"
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|vlarb_str
operator|=
name|opt
operator|->
name|vlarb_low
expr_stmt|;
name|is_default
operator|=
name|false
expr_stmt|;
name|is_specific
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|vlarb_str
condition|)
block|{
name|vlarb_str
operator|=
name|def
operator|->
name|vlarb_low
expr_stmt|;
name|is_specific
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vlarb_str
condition|)
block|{
name|vlarb_str
operator|=
name|OSM_DEFAULT_QOS_VLARB_LOW
expr_stmt|;
name|is_default
operator|=
name|true
expr_stmt|;
block|}
name|check_ep_vlarb_config
argument_list|(
name|vlarb_str
argument_list|,
name|is_default
argument_list|,
name|is_specific
argument_list|,
name|str
argument_list|,
literal|"low"
argument_list|,
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|->
name|sl2vl
condition|)
name|OSM_LOG
argument_list|(
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Warning: torus-2QoS must override configured "
literal|"%s_sl2vl to generate deadlock-free routes\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|torus_build_lfts
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|int
name|status
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|torus_context
modifier|*
name|ctx
init|=
name|context
decl_stmt|;
name|struct
name|fabric
modifier|*
name|fabric
decl_stmt|;
name|struct
name|torus
modifier|*
name|torus
decl_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|qos
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|ctx
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E44: Routing engine list contains torus-2QoS. "
literal|"Enable QoS for correct operation "
literal|"(-Q or 'qos TRUE' in opensm.conf).\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|fabric
operator|=
operator|&
name|ctx
operator|->
name|fabric
expr_stmt|;
name|teardown_fabric
argument_list|(
name|fabric
argument_list|)
expr_stmt|;
name|torus
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|torus
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|torus
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|ctx
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E45: allocating torus: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|torus
operator|->
name|osm
operator|=
name|ctx
operator|->
name|osm
expr_stmt|;
name|fabric
operator|->
name|osm
operator|=
name|ctx
operator|->
name|osm
expr_stmt|;
if|if
condition|(
operator|!
name|parse_config
argument_list|(
name|ctx
operator|->
name|osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|torus_conf_file
argument_list|,
name|fabric
argument_list|,
name|torus
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|capture_fabric
argument_list|(
name|fabric
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|OSM_LOG
argument_list|(
operator|&
name|torus
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Found fabric w/ %d links, %d switches, %d CA ports, "
literal|"minimum data VLs: endport %d, switchport %d\n"
argument_list|,
operator|(
name|int
operator|)
name|fabric
operator|->
name|link_cnt
argument_list|,
operator|(
name|int
operator|)
name|fabric
operator|->
name|switch_cnt
argument_list|,
operator|(
name|int
operator|)
name|fabric
operator|->
name|ca_cnt
argument_list|,
operator|(
name|int
operator|)
name|ctx
operator|->
name|osm
operator|->
name|subn
operator|.
name|min_data_vls
argument_list|,
operator|(
name|int
operator|)
name|ctx
operator|->
name|osm
operator|->
name|subn
operator|.
name|min_sw_data_vls
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|verify_setup
argument_list|(
name|torus
argument_list|,
name|fabric
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|OSM_LOG
argument_list|(
operator|&
name|torus
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Looking for %d x %d x %d %s\n"
argument_list|,
operator|(
name|int
operator|)
name|torus
operator|->
name|x_sz
argument_list|,
operator|(
name|int
operator|)
name|torus
operator|->
name|y_sz
argument_list|,
operator|(
name|int
operator|)
name|torus
operator|->
name|z_sz
argument_list|,
operator|(
name|ALL_MESH
argument_list|(
name|torus
operator|->
name|flags
argument_list|)
condition|?
literal|"mesh"
else|:
literal|"torus"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|build_torus
argument_list|(
name|fabric
argument_list|,
name|torus
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|torus
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4E57: "
literal|"build_torus finished with errors\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|OSM_LOG
argument_list|(
operator|&
name|torus
operator|->
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Built %d x %d x %d %s w/ %d links, %d switches, %d CA ports\n"
argument_list|,
operator|(
name|int
operator|)
name|torus
operator|->
name|x_sz
argument_list|,
operator|(
name|int
operator|)
name|torus
operator|->
name|y_sz
argument_list|,
operator|(
name|int
operator|)
name|torus
operator|->
name|z_sz
argument_list|,
operator|(
name|ALL_MESH
argument_list|(
name|torus
operator|->
name|flags
argument_list|)
condition|?
literal|"mesh"
else|:
literal|"torus"
operator|)
argument_list|,
operator|(
name|int
operator|)
name|torus
operator|->
name|link_cnt
argument_list|,
operator|(
name|int
operator|)
name|torus
operator|->
name|switch_cnt
argument_list|,
operator|(
name|int
operator|)
name|torus
operator|->
name|ca_cnt
argument_list|)
expr_stmt|;
name|diagnose_fabric
argument_list|(
name|fabric
argument_list|)
expr_stmt|;
comment|/* 	 * Since we found some sort of torus fabric, report on any topology 	 * changes vs. the last torus we found. 	 */
if|if
condition|(
name|torus
operator|->
name|flags
operator|&
name|NOTIFY_CHANGES
condition|)
name|report_torus_changes
argument_list|(
name|torus
argument_list|,
name|ctx
operator|->
name|torus
argument_list|)
expr_stmt|;
if|if
condition|(
name|routable_torus
argument_list|(
name|torus
argument_list|,
name|fabric
argument_list|)
condition|)
name|status
operator|=
name|route_torus
argument_list|(
name|torus
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|status
condition|)
block|{
comment|/* bad torus!! */
if|if
condition|(
name|torus
condition|)
name|teardown_torus
argument_list|(
name|torus
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|osm_subn_opt_t
modifier|*
name|opt
init|=
operator|&
name|torus
operator|->
name|osm
operator|->
name|subn
operator|.
name|opt
decl_stmt|;
name|osm_log_t
modifier|*
name|log
init|=
operator|&
name|torus
operator|->
name|osm
operator|->
name|log
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|torus
condition|)
name|teardown_torus
argument_list|(
name|ctx
operator|->
name|torus
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|torus
operator|=
name|torus
expr_stmt|;
name|check_qos_swe_config
argument_list|(
operator|&
name|opt
operator|->
name|qos_swe_options
argument_list|,
operator|&
name|opt
operator|->
name|qos_options
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|check_qos_ep_config
argument_list|(
operator|&
name|opt
operator|->
name|qos_ca_options
argument_list|,
operator|&
name|opt
operator|->
name|qos_options
argument_list|,
literal|"qos_ca"
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|check_qos_ep_config
argument_list|(
operator|&
name|opt
operator|->
name|qos_sw0_options
argument_list|,
operator|&
name|opt
operator|->
name|qos_options
argument_list|,
literal|"qos_sw0"
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|check_qos_ep_config
argument_list|(
operator|&
name|opt
operator|->
name|qos_rtr_options
argument_list|,
operator|&
name|opt
operator|->
name|qos_options
argument_list|,
literal|"qos_rtr"
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
name|teardown_fabric
argument_list|(
name|fabric
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|int
name|osm_ucast_torus2QoS_setup
parameter_list|(
name|struct
name|osm_routing_engine
modifier|*
name|r
parameter_list|,
name|osm_opensm_t
modifier|*
name|osm
parameter_list|)
block|{
name|struct
name|torus_context
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
name|torus_context_create
argument_list|(
name|osm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
condition|)
return|return
operator|-
literal|1
return|;
name|r
operator|->
name|context
operator|=
name|ctx
expr_stmt|;
name|r
operator|->
name|ucast_build_fwd_tables
operator|=
name|torus_build_lfts
expr_stmt|;
name|r
operator|->
name|build_lid_matrices
operator|=
name|ucast_dummy_build_lid_matrices
expr_stmt|;
name|r
operator|->
name|update_sl2vl
operator|=
name|torus_update_osm_sl2vl
expr_stmt|;
name|r
operator|->
name|update_vlarb
operator|=
name|torus_update_osm_vlarb
expr_stmt|;
name|r
operator|->
name|path_sl
operator|=
name|torus_path_sl
expr_stmt|;
name|r
operator|->
name|mcast_build_stree
operator|=
name|torus_mcast_stree
expr_stmt|;
name|r
operator|->
name|destroy
operator|=
name|torus_context_delete
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

