begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2011 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  * Copyright (c) 2008 Xsigo Systems Inc.  All rights reserved.  * Copyright (c) 2009 Sun Microsystems, Inc. All rights reserved.  * Copyright (c) 2010 HNR Consulting. All rights reserved.  * Copyright (C) 2012-2013 Tokyo Institute of Technology. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_mcast_mgr_t.  * This file implements the Multicast Manager object.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_MCAST_MGR_C
end_define

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_sm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_multicast.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_node.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_switch.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_msgdef.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_mcast_mgr.h>
end_include

begin_function
specifier|static
name|osm_mcast_work_obj_t
modifier|*
name|mcast_work_obj_new
parameter_list|(
name|IN
name|osm_port_t
modifier|*
name|p_port
parameter_list|)
block|{
name|osm_mcast_work_obj_t
modifier|*
name|p_obj
decl_stmt|;
comment|/* 	   clean allocated memory to avoid assertion when trying to insert to 	   qlist. 	   see cl_qlist_insert_tail(): CL_ASSERT(p_list_item->p_list != p_list) 	 */
name|p_obj
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p_obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_obj
condition|)
block|{
name|memset
argument_list|(
name|p_obj
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_obj
argument_list|)
argument_list|)
expr_stmt|;
name|p_obj
operator|->
name|p_port
operator|=
name|p_port
expr_stmt|;
block|}
return|return
name|p_obj
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mcast_work_obj_delete
parameter_list|(
name|IN
name|osm_mcast_work_obj_t
modifier|*
name|p_wobj
parameter_list|)
block|{
name|free
argument_list|(
name|p_wobj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|osm_mcast_make_port_list_and_map
parameter_list|(
name|cl_qlist_t
modifier|*
name|list
parameter_list|,
name|cl_qmap_t
modifier|*
name|map
parameter_list|,
name|osm_mgrp_box_t
modifier|*
name|mbox
parameter_list|)
block|{
name|cl_map_item_t
modifier|*
name|map_item
decl_stmt|;
name|cl_list_item_t
modifier|*
name|list_item
decl_stmt|;
name|osm_mgrp_t
modifier|*
name|mgrp
decl_stmt|;
name|osm_mcm_port_t
modifier|*
name|mcm_port
decl_stmt|;
name|osm_mcast_work_obj_t
modifier|*
name|wobj
decl_stmt|;
name|cl_qmap_init
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|cl_qlist_init
argument_list|(
name|list
argument_list|)
expr_stmt|;
for|for
control|(
name|list_item
operator|=
name|cl_qlist_head
argument_list|(
operator|&
name|mbox
operator|->
name|mgrp_list
argument_list|)
init|;
name|list_item
operator|!=
name|cl_qlist_end
argument_list|(
operator|&
name|mbox
operator|->
name|mgrp_list
argument_list|)
condition|;
name|list_item
operator|=
name|cl_qlist_next
argument_list|(
name|list_item
argument_list|)
control|)
block|{
name|mgrp
operator|=
name|cl_item_obj
argument_list|(
name|list_item
argument_list|,
name|mgrp
argument_list|,
name|list_item
argument_list|)
expr_stmt|;
for|for
control|(
name|map_item
operator|=
name|cl_qmap_head
argument_list|(
operator|&
name|mgrp
operator|->
name|mcm_port_tbl
argument_list|)
init|;
name|map_item
operator|!=
name|cl_qmap_end
argument_list|(
operator|&
name|mgrp
operator|->
name|mcm_port_tbl
argument_list|)
condition|;
name|map_item
operator|=
name|cl_qmap_next
argument_list|(
name|map_item
argument_list|)
control|)
block|{
comment|/* Acquire the port object for this port guid, then 			   create the new worker object to build the list. */
name|mcm_port
operator|=
name|cl_item_obj
argument_list|(
name|map_item
argument_list|,
name|mcm_port
argument_list|,
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl_qmap_get
argument_list|(
name|map
argument_list|,
name|mcm_port
operator|->
name|port
operator|->
name|guid
argument_list|)
operator|!=
name|cl_qmap_end
argument_list|(
name|map
argument_list|)
condition|)
continue|continue;
name|wobj
operator|=
name|mcast_work_obj_new
argument_list|(
name|mcm_port
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wobj
condition|)
return|return
operator|-
literal|1
return|;
name|cl_qlist_insert_tail
argument_list|(
name|list
argument_list|,
operator|&
name|wobj
operator|->
name|list_item
argument_list|)
expr_stmt|;
name|cl_qmap_insert
argument_list|(
name|map
argument_list|,
name|mcm_port
operator|->
name|port
operator|->
name|guid
argument_list|,
operator|&
name|wobj
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|osm_mcast_drop_port_list
parameter_list|(
name|cl_qlist_t
modifier|*
name|list
parameter_list|)
block|{
while|while
condition|(
name|cl_qlist_count
argument_list|(
name|list
argument_list|)
condition|)
name|mcast_work_obj_delete
argument_list|(
operator|(
name|osm_mcast_work_obj_t
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
name|list
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_purge_mtree
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_mgrp_box_t
modifier|*
name|mbox
parameter_list|)
block|{
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbox
operator|->
name|root
condition|)
name|osm_mtree_destroy
argument_list|(
name|mbox
operator|->
name|root
argument_list|)
expr_stmt|;
name|mbox
operator|->
name|root
operator|=
name|NULL
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|create_mgrp_switch_map
parameter_list|(
name|cl_qmap_t
modifier|*
name|m
parameter_list|,
name|cl_qlist_t
modifier|*
name|port_list
parameter_list|)
block|{
name|osm_mcast_work_obj_t
modifier|*
name|wobj
decl_stmt|;
name|osm_port_t
modifier|*
name|port
decl_stmt|;
name|osm_switch_t
modifier|*
name|sw
decl_stmt|;
name|ib_net64_t
name|guid
decl_stmt|;
name|cl_list_item_t
modifier|*
name|i
decl_stmt|;
name|cl_qmap_init
argument_list|(
name|m
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cl_qlist_head
argument_list|(
name|port_list
argument_list|)
init|;
name|i
operator|!=
name|cl_qlist_end
argument_list|(
name|port_list
argument_list|)
condition|;
name|i
operator|=
name|cl_qlist_next
argument_list|(
name|i
argument_list|)
control|)
block|{
name|wobj
operator|=
name|cl_item_obj
argument_list|(
name|i
argument_list|,
name|wobj
argument_list|,
name|list_item
argument_list|)
expr_stmt|;
name|port
operator|=
name|wobj
operator|->
name|p_port
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|p_node
operator|->
name|sw
condition|)
block|{
name|sw
operator|=
name|port
operator|->
name|p_node
operator|->
name|sw
expr_stmt|;
name|sw
operator|->
name|is_mc_member
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|port
operator|->
name|p_physp
operator|->
name|p_remote_physp
condition|)
block|{
name|sw
operator|=
name|port
operator|->
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
expr_stmt|;
name|sw
operator|->
name|num_of_mcm
operator|++
expr_stmt|;
block|}
else|else
continue|continue;
name|guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|sw
operator|->
name|p_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl_qmap_get
argument_list|(
name|m
argument_list|,
name|guid
argument_list|)
operator|==
name|cl_qmap_end
argument_list|(
name|m
argument_list|)
condition|)
name|cl_qmap_insert
argument_list|(
name|m
argument_list|,
name|guid
argument_list|,
operator|&
name|sw
operator|->
name|mgrp_item
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_mgrp_switch_map
parameter_list|(
name|cl_qmap_t
modifier|*
name|m
parameter_list|)
block|{
name|osm_switch_t
modifier|*
name|sw
decl_stmt|;
name|cl_map_item_t
modifier|*
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|cl_qmap_head
argument_list|(
name|m
argument_list|)
init|;
name|i
operator|!=
name|cl_qmap_end
argument_list|(
name|m
argument_list|)
condition|;
name|i
operator|=
name|cl_qmap_next
argument_list|(
name|i
argument_list|)
control|)
block|{
name|sw
operator|=
name|cl_item_obj
argument_list|(
name|i
argument_list|,
name|sw
argument_list|,
name|mgrp_item
argument_list|)
expr_stmt|;
name|sw
operator|->
name|num_of_mcm
operator|=
literal|0
expr_stmt|;
name|sw
operator|->
name|is_mc_member
operator|=
literal|0
expr_stmt|;
block|}
name|cl_qmap_remove_all
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Calculate the maximal "min hops" from the given switch to any  of the group HCAs  **********************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OSM_VENDOR_INTF_ANAFA
end_ifdef

begin_function
specifier|static
name|float
name|mcast_mgr_compute_avg_hops
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|cl_qmap_t
modifier|*
name|m
parameter_list|,
specifier|const
name|osm_switch_t
modifier|*
name|this_sw
parameter_list|)
block|{
name|float
name|avg_hops
init|=
literal|0
decl_stmt|;
name|uint32_t
name|hops
init|=
literal|0
decl_stmt|;
name|uint32_t
name|num_ports
init|=
literal|0
decl_stmt|;
name|uint16_t
name|lid
decl_stmt|;
name|uint32_t
name|least_hops
decl_stmt|;
name|cl_map_item_t
modifier|*
name|i
decl_stmt|;
name|osm_switch_t
modifier|*
name|sw
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cl_qmap_head
argument_list|(
name|m
argument_list|)
init|;
name|i
operator|!=
name|cl_qmap_end
argument_list|(
name|m
argument_list|)
condition|;
name|i
operator|=
name|cl_qmap_next
argument_list|(
name|i
argument_list|)
control|)
block|{
name|sw
operator|=
name|cl_item_obj
argument_list|(
name|i
argument_list|,
name|sw
argument_list|,
name|mcast_item
argument_list|)
expr_stmt|;
name|lid
operator|=
name|cl_ntoh16
argument_list|(
name|osm_node_get_base_lid
argument_list|(
name|sw
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|least_hops
operator|=
name|osm_switch_get_least_hops
argument_list|(
name|this_sw
argument_list|,
name|lid
argument_list|)
expr_stmt|;
comment|/* for all host that are MC members and attached to the switch, 		   we should add the (least_hops + 1) * number_of_such_hosts. 		   If switch itself is in the MC, we should add the least_hops only */
name|hops
operator|+=
operator|(
name|least_hops
operator|+
literal|1
operator|)
operator|*
name|sw
operator|->
name|num_of_mcm
operator|+
name|least_hops
operator|*
name|sw
operator|->
name|is_mc_member
expr_stmt|;
name|num_ports
operator|+=
name|sw
operator|->
name|num_of_mcm
operator|+
name|sw
operator|->
name|is_mc_member
expr_stmt|;
block|}
comment|/* We shouldn't be here if there aren't any ports in the group. */
name|CL_ASSERT
argument_list|(
name|num_ports
argument_list|)
expr_stmt|;
name|avg_hops
operator|=
call|(
name|float
call|)
argument_list|(
name|hops
operator|/
name|num_ports
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|avg_hops
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|float
name|mcast_mgr_compute_max_hops
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|cl_qmap_t
modifier|*
name|m
parameter_list|,
specifier|const
name|osm_switch_t
modifier|*
name|this_sw
parameter_list|)
block|{
name|uint32_t
name|max_hops
init|=
literal|0
decl_stmt|,
name|hops
decl_stmt|;
name|uint16_t
name|lid
decl_stmt|;
name|cl_map_item_t
modifier|*
name|i
decl_stmt|;
name|osm_switch_t
modifier|*
name|sw
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	   For each member of the multicast group, compute the 	   number of hops to its base LID. 	 */
for|for
control|(
name|i
operator|=
name|cl_qmap_head
argument_list|(
name|m
argument_list|)
init|;
name|i
operator|!=
name|cl_qmap_end
argument_list|(
name|m
argument_list|)
condition|;
name|i
operator|=
name|cl_qmap_next
argument_list|(
name|i
argument_list|)
control|)
block|{
name|sw
operator|=
name|cl_item_obj
argument_list|(
name|i
argument_list|,
name|sw
argument_list|,
name|mgrp_item
argument_list|)
expr_stmt|;
name|lid
operator|=
name|cl_ntoh16
argument_list|(
name|osm_node_get_base_lid
argument_list|(
name|sw
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|hops
operator|=
name|osm_switch_get_least_hops
argument_list|(
name|this_sw
argument_list|,
name|lid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sw
operator|->
name|is_mc_member
condition|)
name|hops
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|hops
operator|>
name|max_hops
condition|)
name|max_hops
operator|=
name|hops
expr_stmt|;
block|}
comment|/* Note that at this point we might get (max_hops == 0), 	   which means that there's only one member in the mcast 	   group, and it's the current switch */
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|float
operator|)
name|max_hops
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**********************************************************************    This function attempts to locate the optimal switch for the    center of the spanning tree.  The current algorithm chooses    a switch with the lowest average hop count to the members    of the multicast group. **********************************************************************/
end_comment

begin_function
specifier|static
name|osm_switch_t
modifier|*
name|mcast_mgr_find_optimal_switch
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|cl_qlist_t
modifier|*
name|list
parameter_list|)
block|{
name|cl_qmap_t
name|mgrp_sw_map
decl_stmt|;
name|cl_qmap_t
modifier|*
name|p_sw_tbl
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|,
modifier|*
name|p_best_sw
init|=
name|NULL
decl_stmt|;
name|float
name|hops
init|=
literal|0
decl_stmt|;
name|float
name|best_hops
init|=
literal|10000
decl_stmt|;
comment|/* any big # will do */
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_sw_tbl
operator|=
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
expr_stmt|;
name|create_mgrp_switch_map
argument_list|(
operator|&
name|mgrp_sw_map
argument_list|,
name|list
argument_list|)
expr_stmt|;
for|for
control|(
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_sw_tbl
argument_list|)
init|;
name|p_sw
operator|!=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_sw_tbl
argument_list|)
condition|;
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|osm_switch_supports_mcast
argument_list|(
name|p_sw
argument_list|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|OSM_VENDOR_INTF_ANAFA
name|hops
operator|=
name|mcast_mgr_compute_avg_hops
argument_list|(
name|sm
argument_list|,
operator|&
name|mgrp_sw_map
argument_list|,
name|p_sw
argument_list|)
expr_stmt|;
else|#
directive|else
name|hops
operator|=
name|mcast_mgr_compute_max_hops
argument_list|(
name|sm
argument_list|,
operator|&
name|mgrp_sw_map
argument_list|,
name|p_sw
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Switch 0x%016"
name|PRIx64
literal|", hops = %f\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|hops
argument_list|)
expr_stmt|;
if|if
condition|(
name|hops
operator|<
name|best_hops
condition|)
block|{
name|p_best_sw
operator|=
name|p_sw
expr_stmt|;
name|best_hops
operator|=
name|hops
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_best_sw
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Best switch is 0x%"
name|PRIx64
literal|" (%s), hops = %f\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_best_sw
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|p_best_sw
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|best_hops
argument_list|)
expr_stmt|;
else|else
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"No multicast capable switches detected\n"
argument_list|)
expr_stmt|;
name|destroy_mgrp_switch_map
argument_list|(
operator|&
name|mgrp_sw_map
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|p_best_sw
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************    This function returns the existing or optimal root switch for the tree. **********************************************************************/
end_comment

begin_function
name|osm_switch_t
modifier|*
name|osm_mcast_mgr_find_root_switch
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|cl_qlist_t
modifier|*
name|list
parameter_list|)
block|{
name|osm_switch_t
modifier|*
name|p_sw
init|=
name|NULL
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	   We always look for the best multicast tree root switch. 	   Otherwise since we always start with a a single join 	   the root will be always on the first switch attached to it. 	   - Very bad ... 	 */
name|p_sw
operator|=
name|mcast_mgr_find_optimal_switch
argument_list|(
name|sm
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|p_sw
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mcast_mgr_set_mft_block
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_switch_t
modifier|*
name|p_sw
parameter_list|,
name|uint32_t
name|block_num
parameter_list|,
name|uint32_t
name|position
parameter_list|)
block|{
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|osm_dr_path_t
modifier|*
name|p_path
decl_stmt|;
name|osm_madw_context_t
name|context
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|uint32_t
name|block_id_ho
decl_stmt|;
name|osm_mcast_tbl_t
modifier|*
name|p_tbl
decl_stmt|;
name|ib_net16_t
name|block
index|[
name|IB_MCAST_BLOCK_SIZE
index|]
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
name|p_node
operator|=
name|p_sw
operator|->
name|p_node
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p_path
operator|=
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
comment|/* 	   Send multicast forwarding table blocks to the switch 	   as long as the switch indicates it has blocks needing 	   configuration. 	 */
name|context
operator|.
name|mft_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|context
operator|.
name|mft_context
operator|.
name|set_method
operator|=
name|TRUE
expr_stmt|;
name|p_tbl
operator|=
name|osm_switch_get_mcast_tbl_ptr
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_mcast_tbl_get_block
argument_list|(
name|p_tbl
argument_list|,
operator|(
name|uint16_t
operator|)
name|block_num
argument_list|,
operator|(
name|uint8_t
operator|)
name|position
argument_list|,
name|block
argument_list|)
condition|)
block|{
name|block_id_ho
operator|=
name|block_num
operator|+
operator|(
name|position
operator|<<
literal|28
operator|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Writing MFT block %u position %u to switch 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|block_num
argument_list|,
name|position
argument_list|,
name|cl_ntoh64
argument_list|(
name|context
operator|.
name|mft_context
operator|.
name|node_guid
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_req_set
argument_list|(
name|sm
argument_list|,
name|p_path
argument_list|,
operator|(
name|void
operator|*
operator|)
name|block
argument_list|,
sizeof|sizeof
argument_list|(
name|block
argument_list|)
argument_list|,
name|IB_MAD_ATTR_MCAST_FWD_TBL
argument_list|,
name|cl_hton32
argument_list|(
name|block_id_ho
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|ib_port_info_get_m_key
argument_list|(
operator|&
name|p_physp
operator|->
name|port_info
argument_list|)
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A02: "
literal|"Sending multicast fwd. tbl. block 0x%X to %s "
literal|"failed (%s)\n"
argument_list|,
name|block_id_ho
argument_list|,
name|p_node
operator|->
name|print_desc
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************   This is part of the recursive function to compute the paths in the   spanning tree that emanate from this switch.  On input, the p_list   contains the group members that must be routed from this switch. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|mcast_mgr_subdivide
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|uint16_t
name|mlid_ho
parameter_list|,
name|osm_switch_t
modifier|*
name|p_sw
parameter_list|,
name|cl_qlist_t
modifier|*
name|p_list
parameter_list|,
name|cl_qlist_t
modifier|*
name|list_array
parameter_list|,
name|uint8_t
name|array_size
parameter_list|)
block|{
name|uint8_t
name|port_num
decl_stmt|;
name|boolean_t
name|ignore_existing
decl_stmt|;
name|osm_mcast_work_obj_t
modifier|*
name|p_wobj
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	   For Multicast Groups, we don't want to count on previous 	   configurations - since we can easily generate a storm 	   by loops. 	 */
name|ignore_existing
operator|=
name|TRUE
expr_stmt|;
comment|/* 	   Subdivide the set of ports into non-overlapping subsets 	   that will be routed to other switches. 	 */
while|while
condition|(
operator|(
name|p_wobj
operator|=
operator|(
name|osm_mcast_work_obj_t
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
name|p_list
argument_list|)
operator|)
operator|!=
operator|(
name|osm_mcast_work_obj_t
operator|*
operator|)
name|cl_qlist_end
argument_list|(
name|p_list
argument_list|)
condition|)
block|{
name|port_num
operator|=
name|osm_switch_recommend_mcast_path
argument_list|(
name|p_sw
argument_list|,
name|p_wobj
operator|->
name|p_port
argument_list|,
name|mlid_ho
argument_list|,
name|ignore_existing
argument_list|)
expr_stmt|;
if|if
condition|(
name|port_num
operator|==
name|OSM_NO_PATH
condition|)
block|{
comment|/* 			   This typically occurs if the switch does not support 			   multicast and the multicast tree must branch at this 			   switch. 			 */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A03: "
literal|"Error routing MLID 0x%X through switch 0x%"
name|PRIx64
literal|" %s\n"
literal|"\t\t\t\tNo multicast paths from this switch "
literal|"for port with LID %u\n"
argument_list|,
name|mlid_ho
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|p_sw
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|cl_ntoh16
argument_list|(
name|osm_port_get_base_lid
argument_list|(
name|p_wobj
operator|->
name|p_port
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mcast_work_obj_delete
argument_list|(
name|p_wobj
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|port_num
operator|>=
name|array_size
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A04: "
literal|"Error routing MLID 0x%X through switch 0x%"
name|PRIx64
literal|" %s\n"
literal|"\t\t\t\tNo multicast paths from this switch "
literal|"to port with LID %u\n"
argument_list|,
name|mlid_ho
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|p_sw
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|cl_ntoh16
argument_list|(
name|osm_port_get_base_lid
argument_list|(
name|p_wobj
operator|->
name|p_port
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mcast_work_obj_delete
argument_list|(
name|p_wobj
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|cl_qlist_insert_tail
argument_list|(
operator|&
name|list_array
index|[
name|port_num
index|]
argument_list|,
operator|&
name|p_wobj
operator|->
name|list_item
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mcast_mgr_purge_list
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|uint16_t
name|mlid
parameter_list|,
name|cl_qlist_t
modifier|*
name|list
parameter_list|)
block|{
if|if
condition|(
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|)
condition|)
block|{
name|osm_mcast_work_obj_t
modifier|*
name|wobj
decl_stmt|;
name|cl_list_item_t
modifier|*
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|cl_qlist_head
argument_list|(
name|list
argument_list|)
init|;
name|i
operator|!=
name|cl_qlist_end
argument_list|(
name|list
argument_list|)
condition|;
name|i
operator|=
name|cl_qlist_next
argument_list|(
name|i
argument_list|)
control|)
block|{
name|wobj
operator|=
name|cl_item_obj
argument_list|(
name|i
argument_list|,
name|wobj
argument_list|,
name|list_item
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A06: "
literal|"Unable to route MLID 0x%X for port 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|mlid
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_port_get_guid
argument_list|(
name|wobj
operator|->
name|p_port
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|osm_mcast_drop_port_list
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************   This is the recursive function to compute the paths in the spanning   tree that emanate from this switch.  On input, the p_list contains   the group members that must be routed from this switch.    The function returns the newly created mtree node element. **********************************************************************/
end_comment

begin_function
specifier|static
name|osm_mtree_node_t
modifier|*
name|mcast_mgr_branch
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|uint16_t
name|mlid_ho
parameter_list|,
name|osm_switch_t
modifier|*
name|p_sw
parameter_list|,
name|cl_qlist_t
modifier|*
name|p_list
parameter_list|,
name|uint8_t
name|depth
parameter_list|,
name|uint8_t
name|upstream_port
parameter_list|,
name|uint8_t
modifier|*
name|p_max_depth
parameter_list|)
block|{
name|uint8_t
name|max_children
decl_stmt|;
name|osm_mtree_node_t
modifier|*
name|p_mtn
init|=
name|NULL
decl_stmt|;
name|cl_qlist_t
modifier|*
name|list_array
init|=
name|NULL
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|ib_net64_t
name|node_guid
decl_stmt|;
name|osm_mcast_work_obj_t
modifier|*
name|p_wobj
decl_stmt|;
name|cl_qlist_t
modifier|*
name|p_port_list
decl_stmt|;
name|size_t
name|count
decl_stmt|;
name|osm_mcast_tbl_t
modifier|*
name|p_tbl
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_list
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_max_depth
argument_list|)
expr_stmt|;
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Routing MLID 0x%X through switch 0x%"
name|PRIx64
literal|" %s, %u nodes at depth %u\n"
argument_list|,
name|mlid_ho
argument_list|,
name|cl_ntoh64
argument_list|(
name|node_guid
argument_list|)
argument_list|,
name|p_sw
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|cl_qlist_count
argument_list|(
name|p_list
argument_list|)
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|cl_qlist_count
argument_list|(
name|p_list
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|depth
operator|++
expr_stmt|;
if|if
condition|(
name|depth
operator|>=
literal|64
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A21: "
literal|"Maximal hops number is reached for MLID 0x%x."
literal|" Break processing\n"
argument_list|,
name|mlid_ho
argument_list|)
expr_stmt|;
name|mcast_mgr_purge_list
argument_list|(
name|sm
argument_list|,
name|mlid_ho
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|depth
operator|>
operator|*
name|p_max_depth
condition|)
block|{
name|CL_ASSERT
argument_list|(
name|depth
operator|==
operator|*
name|p_max_depth
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p_max_depth
operator|=
name|depth
expr_stmt|;
block|}
if|if
condition|(
name|osm_switch_supports_mcast
argument_list|(
name|p_sw
argument_list|)
operator|==
name|FALSE
condition|)
block|{
comment|/* 		   This switch doesn't do multicast.  Clean-up. 		 */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A14: "
literal|"Switch 0x%"
name|PRIx64
literal|" %s does not support multicast\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|node_guid
argument_list|)
argument_list|,
name|p_sw
operator|->
name|p_node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
comment|/* 		   Deallocate all the work objects on this branch of the tree. 		 */
name|mcast_mgr_purge_list
argument_list|(
name|sm
argument_list|,
name|mlid_ho
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_mtn
operator|=
name|osm_mtree_node_new
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_mtn
operator|==
name|NULL
condition|)
block|{
comment|/* 		   We are unable to continue routing down this 		   leg of the tree.  Clean-up. 		 */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A15: "
literal|"Insufficient memory to build multicast tree\n"
argument_list|)
expr_stmt|;
comment|/* 		   Deallocate all the work objects on this branch of the tree. 		 */
name|mcast_mgr_purge_list
argument_list|(
name|sm
argument_list|,
name|mlid_ho
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|max_children
operator|=
name|osm_mtree_node_get_max_children
argument_list|(
name|p_mtn
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|max_children
operator|>
literal|1
argument_list|)
expr_stmt|;
comment|/* 	   Prepare an empty list for each port in the switch. 	   TO DO - this list array could probably be moved 	   inside the switch element to save on malloc thrashing. 	 */
name|list_array
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cl_qlist_t
argument_list|)
operator|*
name|max_children
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_array
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A16: "
literal|"Unable to allocate list array\n"
argument_list|)
expr_stmt|;
name|mcast_mgr_purge_list
argument_list|(
name|sm
argument_list|,
name|mlid_ho
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
name|osm_mtree_destroy
argument_list|(
name|p_mtn
argument_list|)
expr_stmt|;
name|p_mtn
operator|=
name|NULL
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|memset
argument_list|(
name|list_array
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cl_qlist_t
argument_list|)
operator|*
name|max_children
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_children
condition|;
name|i
operator|++
control|)
name|cl_qlist_init
argument_list|(
operator|&
name|list_array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mcast_mgr_subdivide
argument_list|(
name|sm
argument_list|,
name|mlid_ho
argument_list|,
name|p_sw
argument_list|,
name|p_list
argument_list|,
name|list_array
argument_list|,
name|max_children
argument_list|)
expr_stmt|;
name|p_tbl
operator|=
name|osm_switch_get_mcast_tbl_ptr
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
comment|/* 	   Add the upstream port to the forwarding table unless 	   we're at the root of the spanning tree. 	 */
if|if
condition|(
name|depth
operator|>
literal|1
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Adding upstream port %u\n"
argument_list|,
name|upstream_port
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|upstream_port
argument_list|)
expr_stmt|;
name|osm_mcast_tbl_set
argument_list|(
name|p_tbl
argument_list|,
name|mlid_ho
argument_list|,
name|upstream_port
argument_list|)
expr_stmt|;
block|}
comment|/* 	   For each port that was allocated some routes, 	   recurse into this function to continue building the tree 	   if the node on the other end of that port is another switch. 	   Otherwise, the node is an endpoint, and we've found a leaf 	   of the tree.  Mark leaves with our special pointer value. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_children
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
specifier|const
name|osm_physp_t
modifier|*
name|p_remote_physp
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
specifier|const
name|osm_node_t
modifier|*
name|p_remote_node
decl_stmt|;
name|p_port_list
operator|=
operator|&
name|list_array
index|[
name|i
index|]
expr_stmt|;
name|count
operator|=
name|cl_qlist_count
argument_list|(
name|p_port_list
argument_list|)
expr_stmt|;
comment|/* 		   There should be no children routed through the upstream port! 		 */
name|CL_ASSERT
argument_list|(
name|upstream_port
operator|==
literal|0
operator|||
name|i
operator|!=
name|upstream_port
operator|||
operator|(
name|i
operator|==
name|upstream_port
operator|&&
name|count
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
continue|continue;
comment|/* No routes down this port. */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Routing %zu destinations via switch port %u\n"
argument_list|,
name|count
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* This means we are adding the switch to the MC group. 			   We do not need to continue looking at the remote 			   port, just needed to add the port to the table */
name|CL_ASSERT
argument_list|(
name|count
operator|==
literal|1
argument_list|)
expr_stmt|;
name|osm_mcast_tbl_set
argument_list|(
name|p_tbl
argument_list|,
name|mlid_ho
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p_wobj
operator|=
operator|(
name|osm_mcast_work_obj_t
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
name|p_port_list
argument_list|)
expr_stmt|;
name|mcast_work_obj_delete
argument_list|(
name|p_wobj
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|p_node
operator|=
name|p_sw
operator|->
name|p_node
expr_stmt|;
name|p_remote_node
operator|=
name|osm_node_get_remote_node
argument_list|(
name|p_node
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_remote_node
condition|)
block|{
comment|/* 			 * If we reached here, it means the minhop table has 			 * invalid entries that leads to disconnected ports. 			 * 			 * A possible reason for the code to reach here is 			 * that ucast cache is enabled, and a leaf switch that 			 * is used as a non-leaf switch in a multicast has been 			 * removed from the fabric. 			 * 			 * When it happens, we should invalidate the cache 			 * and force rerouting of the fabric. 			 */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A1E: Tried to route MLID 0x%X through "
literal|"disconnected switch 0x%"
name|PRIx64
literal|" port %d\n"
argument_list|,
name|mlid_ho
argument_list|,
name|cl_ntoh64
argument_list|(
name|node_guid
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Free memory */
name|mcast_mgr_purge_list
argument_list|(
name|sm
argument_list|,
name|mlid_ho
argument_list|,
name|p_port_list
argument_list|)
expr_stmt|;
comment|/* Invalidate ucast cache */
if|if
condition|(
name|sm
operator|->
name|ucast_mgr
operator|.
name|p_subn
operator|->
name|opt
operator|.
name|use_ucast_cache
operator|&&
name|sm
operator|->
name|ucast_mgr
operator|.
name|cache_valid
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Unicast Cache will be invalidated due "
literal|"to multicast routing errors\n"
argument_list|)
expr_stmt|;
name|osm_ucast_cache_invalidate
argument_list|(
operator|&
name|sm
operator|->
name|ucast_mgr
argument_list|)
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|force_heavy_sweep
operator|=
name|TRUE
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* 		   This port routes frames for this mcast group.  Therefore, 		   set the appropriate bit in the multicast forwarding 		   table for this switch. 		 */
name|osm_mcast_tbl_set
argument_list|(
name|p_tbl
argument_list|,
name|mlid_ho
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|p_remote_node
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
condition|)
block|{
comment|/* 			   Acquire a pointer to the remote switch then recurse. 			 */
name|CL_ASSERT
argument_list|(
name|p_remote_node
operator|->
name|sw
argument_list|)
expr_stmt|;
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|p_remote_physp
operator|=
name|osm_physp_get_remote
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_remote_physp
argument_list|)
expr_stmt|;
name|p_mtn
operator|->
name|child_array
index|[
name|i
index|]
operator|=
name|mcast_mgr_branch
argument_list|(
name|sm
argument_list|,
name|mlid_ho
argument_list|,
name|p_remote_node
operator|->
name|sw
argument_list|,
name|p_port_list
argument_list|,
name|depth
argument_list|,
name|osm_physp_get_port_num
argument_list|(
name|p_remote_physp
argument_list|)
argument_list|,
name|p_max_depth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			   The neighbor node is not a switch, so this 			   must be a leaf. 			 */
name|CL_ASSERT
argument_list|(
name|count
operator|==
literal|1
argument_list|)
expr_stmt|;
name|p_mtn
operator|->
name|child_array
index|[
name|i
index|]
operator|=
name|OSM_MTREE_LEAF
expr_stmt|;
name|p_wobj
operator|=
operator|(
name|osm_mcast_work_obj_t
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
name|p_port_list
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|cl_is_qlist_empty
argument_list|(
name|p_port_list
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Found leaf for port 0x%016"
name|PRIx64
literal|" on switch port %u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_port_get_guid
argument_list|(
name|p_wobj
operator|->
name|p_port
argument_list|)
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mcast_work_obj_delete
argument_list|(
name|p_wobj
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|list_array
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|p_mtn
return|;
block|}
end_function

begin_function
specifier|static
name|ib_api_status_t
name|mcast_mgr_build_spanning_tree
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|osm_mgrp_box_t
modifier|*
name|mbox
parameter_list|)
block|{
name|cl_qlist_t
name|port_list
decl_stmt|;
name|cl_qmap_t
name|port_map
decl_stmt|;
name|uint32_t
name|num_ports
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|uint8_t
name|max_depth
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	   TO DO - for now, just blow away the old tree. 	   In the future we'll need to construct the tree based 	   on multicast forwarding table information if the user wants to 	   preserve existing multicast routes. 	 */
name|osm_purge_mtree
argument_list|(
name|sm
argument_list|,
name|mbox
argument_list|)
expr_stmt|;
comment|/* build the first "subset" containing all member ports */
if|if
condition|(
name|osm_mcast_make_port_list_and_map
argument_list|(
operator|&
name|port_list
argument_list|,
operator|&
name|port_map
argument_list|,
name|mbox
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A10: "
literal|"Insufficient memory to make port list\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|num_ports
operator|=
name|cl_qlist_count
argument_list|(
operator|&
name|port_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_ports
operator|<
literal|2
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"MLID 0x%X has %u members - nothing to do\n"
argument_list|,
name|mbox
operator|->
name|mlid
argument_list|,
name|num_ports
argument_list|)
expr_stmt|;
name|osm_mcast_drop_port_list
argument_list|(
operator|&
name|port_list
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	   This function builds the single spanning tree recursively. 	   At each stage, the ports to be reached are divided into 	   non-overlapping subsets of member ports that can be reached through 	   a given switch port.  Construction then moves down each 	   branch, and the process starts again with each branch computing 	   for its own subset of the member ports.  	   The maximum recursion depth is at worst the maximum hop count in the 	   subnet, which is spec limited to 64. 	 */
comment|/* 	   Locate the switch around which to create the spanning 	   tree for this multicast group. 	 */
name|p_sw
operator|=
name|osm_mcast_mgr_find_root_switch
argument_list|(
name|sm
argument_list|,
operator|&
name|port_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A08: "
literal|"Unable to locate a suitable switch for group 0x%X\n"
argument_list|,
name|mbox
operator|->
name|mlid
argument_list|)
expr_stmt|;
name|osm_mcast_drop_port_list
argument_list|(
operator|&
name|port_list
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|mbox
operator|->
name|root
operator|=
name|mcast_mgr_branch
argument_list|(
name|sm
argument_list|,
name|mbox
operator|->
name|mlid
argument_list|,
name|p_sw
argument_list|,
operator|&
name|port_list
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|max_depth
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Configured MLID 0x%X for %u ports, max tree depth = %u\n"
argument_list|,
name|mbox
operator|->
name|mlid
argument_list|,
name|num_ports
argument_list|,
name|max_depth
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* unused */
end_comment

begin_comment
unit|void osm_mcast_mgr_set_table(osm_sm_t * sm, IN const osm_mgrp_t * p_mgrp, 			     IN const osm_mtree_node_t * p_mtn) { 	uint8_t i; 	uint8_t max_children; 	osm_mtree_node_t *p_child_mtn; 	uint16_t mlid_ho; 	osm_mcast_tbl_t *p_tbl; 	osm_switch_t *p_sw;  	OSM_LOG_ENTER(sm->p_log);  	mlid_ho = cl_ntoh16(osm_mgrp_get_mlid(p_mgrp)); 	p_sw = osm_mtree_node_get_switch_ptr(p_mtn);  	CL_ASSERT(p_sw);  	OSM_LOG(sm->p_log, OSM_LOG_VERBOSE, 		"Configuring MLID 0x%X on switch 0x%" PRIx64 "\n", 		mlid_ho, osm_node_get_node_guid(p_sw->p_node));
comment|/* 	   For every child of this tree node, set the corresponding 	   bit in the switch's mcast table. 	 */
end_comment

begin_endif
unit|p_tbl = osm_switch_get_mcast_tbl_ptr(p_sw); 	max_children = osm_mtree_node_get_max_children(p_mtn);  	CL_ASSERT(max_children<= osm_switch_get_num_ports(p_sw));  	osm_mcast_tbl_clear_mlid(p_tbl, mlid_ho);  	for (i = 0; i< max_children; i++) { 		p_child_mtn = osm_mtree_node_get_child(p_mtn, i); 		if (p_child_mtn == NULL) 			continue;  		osm_mcast_tbl_set(p_tbl, mlid_ho, i); 	}  	OSM_LOG_EXIT(sm->p_log); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|mcast_mgr_clear
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|uint16_t
name|mlid
parameter_list|)
block|{
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|cl_qmap_t
modifier|*
name|p_sw_tbl
decl_stmt|;
name|osm_mcast_tbl_t
modifier|*
name|p_mcast_tbl
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* Walk the switches and clear the routing entries for this MLID. */
name|p_sw_tbl
operator|=
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
expr_stmt|;
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_sw_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_sw
operator|!=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_sw_tbl
argument_list|)
condition|)
block|{
name|p_mcast_tbl
operator|=
name|osm_switch_get_mcast_tbl_ptr
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
name|osm_mcast_tbl_clear_mlid
argument_list|(
name|p_mcast_tbl
argument_list|,
name|mlid
argument_list|)
expr_stmt|;
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* TO DO - make this real -- at least update spanning tree */
end_comment

begin_comment
comment|/**********************************************************************    Lock must be held on entry. **********************************************************************/
end_comment

begin_comment
unit|ib_api_status_t osm_mcast_mgr_process_single(osm_sm_t * sm, 					     IN ib_net16_t const mlid, 					     IN ib_net64_t const port_guid, 					     IN uint8_t const join_state) { 	uint8_t port_num; 	uint16_t mlid_ho; 	ib_net64_t sw_guid; 	osm_port_t *p_port; 	osm_physp_t *p_physp; 	osm_physp_t *p_remote_physp; 	osm_node_t *p_remote_node; 	osm_mcast_tbl_t *p_mcast_tbl; 	ib_api_status_t status = IB_SUCCESS;  	OSM_LOG_ENTER(sm->p_log);  	CL_ASSERT(mlid); 	CL_ASSERT(port_guid);  	mlid_ho = cl_ntoh16(mlid);  	OSM_LOG(sm->p_log, OSM_LOG_DEBUG, 		"Attempting to add port 0x%" PRIx64 " to MLID 0x%X, " 		"\n\t\t\t\tjoin state = 0x%X\n", 		cl_ntoh64(port_guid), mlid_ho, join_state);
comment|/* 	   Acquire the Port object. 	 */
end_comment

begin_comment
unit|p_port = osm_get_port_by_guid(sm->p_subn, port_guid); 	if (!p_port) { 		OSM_LOG(sm->p_log, OSM_LOG_ERROR, "ERR 0A01: " 			"Unable to acquire port object for 0x%" PRIx64 "\n", 			cl_ntoh64(port_guid)); 		status = IB_ERROR; 		goto Exit; 	}  	p_physp = p_port->p_physp; 	if (p_physp == NULL) { 		OSM_LOG(sm->p_log, OSM_LOG_ERROR, "ERR 0A05: " 			"Unable to acquire phsyical port object for 0x%" PRIx64 			"\n", cl_ntoh64(port_guid)); 		status = IB_ERROR; 		goto Exit; 	}  	p_remote_physp = osm_physp_get_remote(p_physp); 	if (p_remote_physp == NULL) { 		OSM_LOG(sm->p_log, OSM_LOG_ERROR, "ERR 0A11: " 			"Unable to acquire remote phsyical port object " 			"for 0x%" PRIx64 "\n", cl_ntoh64(port_guid)); 		status = IB_ERROR; 		goto Exit; 	}  	p_remote_node = osm_physp_get_node_ptr(p_remote_physp);  	CL_ASSERT(p_remote_node);  	sw_guid = osm_node_get_node_guid(p_remote_node);  	if (osm_node_get_type(p_remote_node) != IB_NODE_TYPE_SWITCH) { 		OSM_LOG(sm->p_log, OSM_LOG_ERROR, "ERR 0A22: " 			"Remote node not a switch node 0x%" PRIx64 "\n", 			cl_ntoh64(sw_guid)); 		status = IB_ERROR; 		goto Exit; 	}  	if (!p_remote_node->sw) { 		OSM_LOG(sm->p_log, OSM_LOG_ERROR, "ERR 0A12: " 			"No switch object 0x%" PRIx64 "\n", cl_ntoh64(sw_guid)); 		status = IB_ERROR; 		goto Exit; 	}  	if (osm_switch_is_in_mcast_tree(p_remote_node->sw, mlid_ho)) {
comment|/* 		   We're in luck. The switch attached to this port 		   is already in the multicast group, so we can just 		   add the specified port as a new leaf of the tree. 		 */
end_comment

begin_comment
unit|if (join_state& (IB_JOIN_STATE_FULL | IB_JOIN_STATE_NON)) {
comment|/* 			   This node wants to receive multicast frames. 			   Get the switch port number to which the new member port 			   is attached, then configure this single mcast table. 			 */
end_comment

begin_endif
unit|port_num = osm_physp_get_port_num(p_remote_physp); 			CL_ASSERT(port_num);  			p_mcast_tbl = 			    osm_switch_get_mcast_tbl_ptr(p_remote_node->sw); 			osm_mcast_tbl_set(p_mcast_tbl, mlid_ho, port_num); 		} else { 			if (join_state& IB_JOIN_STATE_SEND_ONLY) 				OSM_LOG(sm->p_log, OSM_LOG_DEBUG, 					"Success.  Nothing to do for send" 					"only member\n"); 			else { 				OSM_LOG(sm->p_log, OSM_LOG_ERROR, "ERR 0A13: " 					"Unknown join state 0x%X\n", 					join_state); 				status = IB_ERROR; 				goto Exit; 			} 		} 	} else 		OSM_LOG(sm->p_log, OSM_LOG_DEBUG, "Unable to add port\n");  Exit: 	OSM_LOG_EXIT(sm->p_log); 	return status; }
endif|#
directive|endif
end_endif

begin_comment
comment|/**********************************************************************  Process the entire group.  NOTE : The lock should be held externally!  **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|mcast_mgr_process_mlid
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|uint16_t
name|mlid
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|struct
name|osm_routing_engine
modifier|*
name|re
init|=
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
operator|->
name|routing_engine_used
decl_stmt|;
name|osm_mgrp_box_t
modifier|*
name|mbox
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Processing multicast group with mlid 0x%X\n"
argument_list|,
name|mlid
argument_list|)
expr_stmt|;
comment|/* Clear the multicast tables to start clean, then build 	   the spanning tree which sets the mcast table bits for each 	   port in the group. */
name|mcast_mgr_clear
argument_list|(
name|sm
argument_list|,
name|mlid
argument_list|)
expr_stmt|;
name|mbox
operator|=
name|osm_get_mbox_by_mlid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|cl_hton16
argument_list|(
name|mlid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbox
condition|)
block|{
if|if
condition|(
name|re
operator|&&
name|re
operator|->
name|mcast_build_stree
condition|)
name|status
operator|=
name|re
operator|->
name|mcast_build_stree
argument_list|(
name|re
operator|->
name|context
argument_list|,
name|mbox
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|mcast_mgr_build_spanning_tree
argument_list|(
name|sm
argument_list|,
name|mbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A17: "
literal|"Unable to create spanning tree (%s) for mlid "
literal|"0x%x\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|,
name|mlid
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mcast_mgr_set_mfttop
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_switch_t
modifier|*
name|p_sw
parameter_list|)
block|{
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|osm_dr_path_t
modifier|*
name|p_path
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|osm_mcast_tbl_t
modifier|*
name|p_tbl
decl_stmt|;
name|osm_madw_context_t
name|context
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|ib_switch_info_t
name|si
decl_stmt|;
name|ib_net16_t
name|mcast_top
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
name|p_node
operator|=
name|p_sw
operator|->
name|p_node
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p_path
operator|=
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|p_tbl
operator|=
name|osm_switch_get_mcast_tbl_ptr
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|use_mfttop
operator|&&
name|p_physp
operator|->
name|port_info
operator|.
name|capability_mask
operator|&
name|IB_PORT_CAP_HAS_MCAST_FDB_TOP
condition|)
block|{
comment|/* 		   Set the top of the multicast forwarding table. 		 */
name|si
operator|=
name|p_sw
operator|->
name|switch_info
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|first_time_master_sweep
operator|==
name|TRUE
condition|)
name|mcast_top
operator|=
name|cl_hton16
argument_list|(
name|sm
operator|->
name|mlids_init_max
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|p_tbl
operator|->
name|max_block_in_use
operator|==
operator|-
literal|1
condition|)
name|mcast_top
operator|=
name|cl_hton16
argument_list|(
name|IB_LID_MCAST_START_HO
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|mcast_top
operator|=
name|cl_hton16
argument_list|(
name|IB_LID_MCAST_START_HO
operator|+
operator|(
name|p_tbl
operator|->
name|max_block_in_use
operator|+
literal|1
operator|)
operator|*
name|IB_MCAST_BLOCK_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mcast_top
operator|==
name|si
operator|.
name|mcast_top
condition|)
return|return;
name|si
operator|.
name|mcast_top
operator|=
name|mcast_top
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Setting switch MFT top to MLID 0x%x\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|si
operator|.
name|mcast_top
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|si_context
operator|.
name|light_sweep
operator|=
name|FALSE
expr_stmt|;
name|context
operator|.
name|si_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|context
operator|.
name|si_context
operator|.
name|set_method
operator|=
name|TRUE
expr_stmt|;
name|context
operator|.
name|si_context
operator|.
name|lft_top_change
operator|=
name|FALSE
expr_stmt|;
name|status
operator|=
name|osm_req_set
argument_list|(
name|sm
argument_list|,
name|p_path
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|si
argument_list|,
sizeof|sizeof
argument_list|(
name|si
argument_list|)
argument_list|,
name|IB_MAD_ATTR_SWITCH_INFO
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|ib_port_info_get_m_key
argument_list|(
operator|&
name|p_physp
operator|->
name|port_info
argument_list|)
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A1B: "
literal|"Sending SwitchInfo attribute failed (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mcast_mgr_set_mftables
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|cl_qmap_t
modifier|*
name|p_sw_tbl
init|=
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|osm_mcast_tbl_t
modifier|*
name|p_tbl
decl_stmt|;
name|int
name|block_notdone
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|int16_t
name|block_num
decl_stmt|,
name|max_block
init|=
operator|-
literal|1
decl_stmt|;
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_sw_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_sw
operator|!=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_sw_tbl
argument_list|)
condition|)
block|{
name|p_sw
operator|->
name|mft_block_num
operator|=
literal|0
expr_stmt|;
name|p_sw
operator|->
name|mft_position
operator|=
literal|0
expr_stmt|;
name|p_tbl
operator|=
name|osm_switch_get_mcast_tbl_ptr
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_mcast_tbl_get_max_block_in_use
argument_list|(
name|p_tbl
argument_list|)
operator|>
name|max_block
condition|)
name|max_block
operator|=
name|osm_mcast_tbl_get_max_block_in_use
argument_list|(
name|p_tbl
argument_list|)
expr_stmt|;
name|mcast_mgr_set_mfttop
argument_list|(
name|sm
argument_list|,
name|p_sw
argument_list|)
expr_stmt|;
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
comment|/* Stripe the MFT blocks across the switches */
for|for
control|(
name|block_num
operator|=
literal|0
init|;
name|block_num
operator|<=
name|max_block
condition|;
name|block_num
operator|++
control|)
block|{
name|block_notdone
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|block_notdone
condition|)
block|{
name|block_notdone
operator|=
literal|0
expr_stmt|;
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_sw_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_sw
operator|!=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_sw_tbl
argument_list|)
condition|)
block|{
if|if
condition|(
name|p_sw
operator|->
name|mft_block_num
operator|==
name|block_num
condition|)
block|{
name|block_notdone
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mcast_mgr_set_mft_block
argument_list|(
name|sm
argument_list|,
name|p_sw
argument_list|,
name|p_sw
operator|->
name|mft_block_num
argument_list|,
name|p_sw
operator|->
name|mft_position
argument_list|)
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
name|p_tbl
operator|=
name|osm_switch_get_mcast_tbl_ptr
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|p_sw
operator|->
name|mft_position
operator|>
name|p_tbl
operator|->
name|max_position
condition|)
block|{
name|p_sw
operator|->
name|mft_position
operator|=
literal|0
expr_stmt|;
name|p_sw
operator|->
name|mft_block_num
operator|++
expr_stmt|;
block|}
block|}
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_mfts
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|cl_map_item_t
modifier|*
name|item
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|;
for|for
control|(
name|i
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|max_mcast_lid_ho
operator|-
name|IB_LID_MCAST_START_HO
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|mboxes
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Now, walk switches and (re)allocate multicast tables */
for|for
control|(
name|item
operator|=
name|cl_qmap_head
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|)
init|;
name|item
operator|!=
name|cl_qmap_end
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|)
condition|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
control|)
block|{
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|item
expr_stmt|;
if|if
condition|(
name|osm_mcast_tbl_realloc
argument_list|(
operator|&
name|p_sw
operator|->
name|mcast_tbl
argument_list|,
name|i
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************   This is the function that is invoked during idle time and sweep to   handle the process request for mcast groups where join/leave/delete   was required.  **********************************************************************/
end_comment

begin_function
name|int
name|osm_mcast_mgr_process
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|boolean_t
name|config_all
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|unsigned
name|max_mlid
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
comment|/* If there are no switches in the subnet we have nothing to do. */
if|if
condition|(
name|cl_qmap_count
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"No switches in subnet. Nothing to do\n"
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|alloc_mfts
argument_list|(
name|sm
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A09: alloc_mfts failed\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
name|max_mlid
operator|=
name|config_all
condition|?
name|sm
operator|->
name|p_subn
operator|->
name|max_mcast_lid_ho
operator|-
name|IB_LID_MCAST_START_HO
else|:
name|sm
operator|->
name|mlids_req_max
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max_mlid
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sm
operator|->
name|mlids_req
index|[
name|i
index|]
operator|||
operator|(
name|config_all
operator|&&
name|sm
operator|->
name|p_subn
operator|->
name|mboxes
index|[
name|i
index|]
operator|)
condition|)
block|{
name|sm
operator|->
name|mlids_req
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|mcast_mgr_process_mlid
argument_list|(
name|sm
argument_list|,
name|i
operator|+
name|IB_LID_MCAST_START_HO
argument_list|)
expr_stmt|;
block|}
block|}
name|sm
operator|->
name|mlids_req_max
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|mcast_mgr_set_mftables
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|osm_dump_mcast_routes
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
argument_list|)
expr_stmt|;
name|exit
label|:
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

