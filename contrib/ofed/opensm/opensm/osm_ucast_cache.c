begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2008-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 2008-2009 Mellanox Technologies LTD. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of OpenSM Cached Unicast Routing  *  * Environment:  *    Linux User Mode  *  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qmap.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_pool.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_UCAST_CACHE_C
end_define

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_ucast_mgr.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_ucast_cache.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_switch.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_node.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_port.h>
end_include

begin_typedef
typedef|typedef
struct|struct
name|cache_port
block|{
name|boolean_t
name|is_leaf
decl_stmt|;
name|uint16_t
name|remote_lid_ho
decl_stmt|;
block|}
name|cache_port_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|cache_switch
block|{
name|cl_map_item_t
name|map_item
decl_stmt|;
name|boolean_t
name|dropped
decl_stmt|;
name|uint16_t
name|max_lid_ho
decl_stmt|;
name|uint16_t
name|num_hops
decl_stmt|;
name|uint8_t
modifier|*
modifier|*
name|hops
decl_stmt|;
name|uint8_t
modifier|*
name|lft
decl_stmt|;
name|uint8_t
name|num_ports
decl_stmt|;
name|cache_port_t
name|ports
index|[
literal|0
index|]
decl_stmt|;
block|}
name|cache_switch_t
typedef|;
end_typedef

begin_function
specifier|static
name|uint16_t
name|cache_sw_get_base_lid_ho
parameter_list|(
name|cache_switch_t
modifier|*
name|p_sw
parameter_list|)
block|{
return|return
name|p_sw
operator|->
name|ports
index|[
literal|0
index|]
operator|.
name|remote_lid_ho
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|cache_sw_is_leaf
parameter_list|(
name|cache_switch_t
modifier|*
name|p_sw
parameter_list|)
block|{
return|return
name|p_sw
operator|->
name|ports
index|[
literal|0
index|]
operator|.
name|is_leaf
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cache_sw_set_leaf
parameter_list|(
name|cache_switch_t
modifier|*
name|p_sw
parameter_list|)
block|{
name|p_sw
operator|->
name|ports
index|[
literal|0
index|]
operator|.
name|is_leaf
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|cache_switch_t
modifier|*
name|cache_sw_new
parameter_list|(
name|uint16_t
name|lid_ho
parameter_list|,
name|unsigned
name|num_ports
parameter_list|)
block|{
name|cache_switch_t
modifier|*
name|p_cache_sw
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cache_switch_t
argument_list|)
operator|+
name|num_ports
operator|*
sizeof|sizeof
argument_list|(
name|cache_port_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p_cache_sw
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|p_cache_sw
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_cache_sw
argument_list|)
operator|+
name|num_ports
operator|*
sizeof|sizeof
argument_list|(
name|cache_port_t
argument_list|)
argument_list|)
expr_stmt|;
name|p_cache_sw
operator|->
name|num_ports
operator|=
name|num_ports
expr_stmt|;
comment|/* port[0] fields represent this switch details - lid and type */
name|p_cache_sw
operator|->
name|ports
index|[
literal|0
index|]
operator|.
name|remote_lid_ho
operator|=
name|lid_ho
expr_stmt|;
name|p_cache_sw
operator|->
name|ports
index|[
literal|0
index|]
operator|.
name|is_leaf
operator|=
name|FALSE
expr_stmt|;
return|return
name|p_cache_sw
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cache_sw_destroy
parameter_list|(
name|cache_switch_t
modifier|*
name|p_sw
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|p_sw
condition|)
return|return;
if|if
condition|(
name|p_sw
operator|->
name|lft
condition|)
name|free
argument_list|(
name|p_sw
operator|->
name|lft
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|hops
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|num_hops
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p_sw
operator|->
name|hops
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|p_sw
operator|->
name|hops
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_sw
operator|->
name|hops
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|cache_switch_t
modifier|*
name|cache_get_sw
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|,
name|uint16_t
name|lid_ho
parameter_list|)
block|{
name|cache_switch_t
modifier|*
name|p_cache_sw
init|=
operator|(
name|cache_switch_t
operator|*
operator|)
name|cl_qmap_get
argument_list|(
operator|&
name|p_mgr
operator|->
name|cache_sw_tbl
argument_list|,
name|lid_ho
argument_list|)
decl_stmt|;
if|if
condition|(
name|p_cache_sw
operator|==
operator|(
name|cache_switch_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_mgr
operator|->
name|cache_sw_tbl
argument_list|)
condition|)
name|p_cache_sw
operator|=
name|NULL
expr_stmt|;
return|return
name|p_cache_sw
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cache_add_sw_link
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|,
name|osm_physp_t
modifier|*
name|p
parameter_list|,
name|uint16_t
name|remote_lid_ho
parameter_list|,
name|boolean_t
name|is_ca
parameter_list|)
block|{
name|cache_switch_t
modifier|*
name|p_cache_sw
decl_stmt|;
name|uint16_t
name|lid_ho
init|=
name|cl_ntoh16
argument_list|(
name|osm_node_get_base_lid
argument_list|(
name|p
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lid_ho
operator|||
operator|!
name|remote_lid_ho
operator|||
operator|!
name|p
operator|->
name|port_num
condition|)
goto|goto
name|Exit
goto|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Caching switch port: lid %u [port %u] -> lid %u (%s)\n"
argument_list|,
name|lid_ho
argument_list|,
name|p
operator|->
name|port_num
argument_list|,
name|remote_lid_ho
argument_list|,
operator|(
name|is_ca
operator|)
condition|?
literal|"CA/RTR"
else|:
literal|"SW"
argument_list|)
expr_stmt|;
name|p_cache_sw
operator|=
name|cache_get_sw
argument_list|(
name|p_mgr
argument_list|,
name|lid_ho
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_cache_sw
condition|)
block|{
name|p_cache_sw
operator|=
name|cache_sw_new
argument_list|(
name|lid_ho
argument_list|,
name|p
operator|->
name|p_node
operator|->
name|sw
operator|->
name|num_ports
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_cache_sw
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD01: Out of memory - cache is invalid\n"
argument_list|)
expr_stmt|;
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|cl_qmap_insert
argument_list|(
operator|&
name|p_mgr
operator|->
name|cache_sw_tbl
argument_list|,
name|lid_ho
argument_list|,
operator|&
name|p_cache_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|port_num
operator|>=
name|p_cache_sw
operator|->
name|num_ports
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD02: Wrong switch? - cache is invalid\n"
argument_list|)
expr_stmt|;
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|is_ca
condition|)
name|cache_sw_set_leaf
argument_list|(
name|p_cache_sw
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_cache_sw
operator|->
name|ports
index|[
name|p
operator|->
name|port_num
index|]
operator|.
name|remote_lid_ho
operator|==
literal|0
condition|)
block|{
comment|/* cache this link only if it hasn't been already cached */
name|p_cache_sw
operator|->
name|ports
index|[
name|p
operator|->
name|port_num
index|]
operator|.
name|remote_lid_ho
operator|=
name|remote_lid_ho
expr_stmt|;
name|p_cache_sw
operator|->
name|ports
index|[
name|p
operator|->
name|port_num
index|]
operator|.
name|is_leaf
operator|=
name|is_ca
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cache_cleanup_switches
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|)
block|{
name|cache_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|cache_switch_t
modifier|*
name|p_next_sw
decl_stmt|;
name|unsigned
name|port_num
decl_stmt|;
name|boolean_t
name|found_port
decl_stmt|;
if|if
condition|(
operator|!
name|p_mgr
operator|->
name|cache_valid
condition|)
return|return;
name|p_next_sw
operator|=
operator|(
name|cache_switch_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_mgr
operator|->
name|cache_sw_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_sw
operator|!=
operator|(
name|cache_switch_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_mgr
operator|->
name|cache_sw_tbl
argument_list|)
condition|)
block|{
name|p_sw
operator|=
name|p_next_sw
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|cache_switch_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
name|found_port
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|port_num
operator|=
literal|1
init|;
name|port_num
operator|<
name|p_sw
operator|->
name|num_ports
condition|;
name|port_num
operator|++
control|)
if|if
condition|(
name|p_sw
operator|->
name|ports
index|[
name|port_num
index|]
operator|.
name|remote_lid_ho
condition|)
name|found_port
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|found_port
condition|)
block|{
name|cl_qmap_remove_item
argument_list|(
operator|&
name|p_mgr
operator|->
name|cache_sw_tbl
argument_list|,
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
name|cache_sw_destroy
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cache_check_link_change
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|,
name|osm_physp_t
modifier|*
name|p_physp_1
parameter_list|,
name|osm_physp_t
modifier|*
name|p_physp_2
parameter_list|)
block|{
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_physp_1
operator|&&
name|p_physp_2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_mgr
operator|->
name|cache_valid
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
operator|!
name|p_physp_1
operator|->
name|p_remote_physp
operator|&&
operator|!
name|p_physp_2
operator|->
name|p_remote_physp
condition|)
comment|/* both ports were down - new link */
goto|goto
name|Exit
goto|;
comment|/* unicast cache cannot tolerate any link location change */
if|if
condition|(
operator|(
name|p_physp_1
operator|->
name|p_remote_physp
operator|&&
name|p_physp_1
operator|->
name|p_remote_physp
operator|->
name|p_remote_physp
operator|)
operator|||
operator|(
name|p_physp_2
operator|->
name|p_remote_physp
operator|&&
name|p_physp_2
operator|->
name|p_remote_physp
operator|->
name|p_remote_physp
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Link location change discovered\n"
argument_list|)
expr_stmt|;
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cache_remove_port
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|,
name|uint16_t
name|lid_ho
parameter_list|,
name|uint8_t
name|port_num
parameter_list|,
name|uint16_t
name|remote_lid_ho
parameter_list|,
name|boolean_t
name|is_ca
parameter_list|)
block|{
name|cache_switch_t
modifier|*
name|p_cache_sw
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_mgr
operator|->
name|cache_valid
condition|)
goto|goto
name|Exit
goto|;
name|p_cache_sw
operator|=
name|cache_get_sw
argument_list|(
name|p_mgr
argument_list|,
name|lid_ho
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_cache_sw
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Found uncached switch/link (lid %u, port %u)\n"
argument_list|,
name|lid_ho
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|port_num
operator|>=
name|p_cache_sw
operator|->
name|num_ports
operator|||
operator|!
name|p_cache_sw
operator|->
name|ports
index|[
name|port_num
index|]
operator|.
name|remote_lid_ho
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Found uncached switch link (lid %u, port %u)\n"
argument_list|,
name|lid_ho
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|p_cache_sw
operator|->
name|ports
index|[
name|port_num
index|]
operator|.
name|remote_lid_ho
operator|!=
name|remote_lid_ho
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Remote lid change on switch lid %u, port %u "
literal|"(was %u, now %u)\n"
argument_list|,
name|lid_ho
argument_list|,
name|port_num
argument_list|,
name|p_cache_sw
operator|->
name|ports
index|[
name|port_num
index|]
operator|.
name|remote_lid_ho
argument_list|,
name|remote_lid_ho
argument_list|)
expr_stmt|;
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|(
name|p_cache_sw
operator|->
name|ports
index|[
name|port_num
index|]
operator|.
name|is_leaf
operator|&&
operator|!
name|is_ca
operator|)
operator|||
operator|(
operator|!
name|p_cache_sw
operator|->
name|ports
index|[
name|port_num
index|]
operator|.
name|is_leaf
operator|&&
name|is_ca
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Remote node type change on switch lid %u, port %u\n"
argument_list|,
name|lid_ho
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"New link from lid %u, port %u to lid %u - "
literal|"found in cache\n"
argument_list|,
name|lid_ho
argument_list|,
name|port_num
argument_list|,
name|remote_lid_ho
argument_list|)
expr_stmt|;
comment|/* the new link was cached - clean it from the cache */
name|p_cache_sw
operator|->
name|ports
index|[
name|port_num
index|]
operator|.
name|remote_lid_ho
operator|=
literal|0
expr_stmt|;
name|p_cache_sw
operator|->
name|ports
index|[
name|port_num
index|]
operator|.
name|is_leaf
operator|=
name|FALSE
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* cache_remove_port() */
end_comment

begin_function
specifier|static
name|void
name|cache_restore_ucast_info
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|,
name|cache_switch_t
modifier|*
name|p_cache_sw
parameter_list|,
name|osm_switch_t
modifier|*
name|p_sw
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p_mgr
operator|->
name|cache_valid
condition|)
return|return;
comment|/* when seting unicast info, the cached port 	   should have all the required info */
name|CL_ASSERT
argument_list|(
name|p_cache_sw
operator|->
name|max_lid_ho
operator|&&
name|p_cache_sw
operator|->
name|lft
operator|&&
name|p_cache_sw
operator|->
name|num_hops
operator|&&
name|p_cache_sw
operator|->
name|hops
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|max_lid_ho
operator|=
name|p_cache_sw
operator|->
name|max_lid_ho
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|new_lft
condition|)
name|free
argument_list|(
name|p_sw
operator|->
name|new_lft
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|new_lft
operator|=
name|p_cache_sw
operator|->
name|lft
expr_stmt|;
name|p_cache_sw
operator|->
name|lft
operator|=
name|NULL
expr_stmt|;
name|p_sw
operator|->
name|num_hops
operator|=
name|p_cache_sw
operator|->
name|num_hops
expr_stmt|;
name|p_cache_sw
operator|->
name|num_hops
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|hops
condition|)
name|free
argument_list|(
name|p_sw
operator|->
name|hops
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|hops
operator|=
name|p_cache_sw
operator|->
name|hops
expr_stmt|;
name|p_cache_sw
operator|->
name|hops
operator|=
name|NULL
expr_stmt|;
name|p_sw
operator|->
name|need_update
operator|=
literal|2
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ucast_cache_dump
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|)
block|{
name|cache_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Dumping missing nodes/links as logged by unicast cache:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|p_sw
operator|=
operator|(
name|cache_switch_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_mgr
operator|->
name|cache_sw_tbl
argument_list|)
init|;
name|p_sw
operator|!=
operator|(
name|cache_switch_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_mgr
operator|->
name|cache_sw_tbl
argument_list|)
condition|;
name|p_sw
operator|=
operator|(
name|cache_switch_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
control|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"\t Switch lid %u %s%s\n"
argument_list|,
name|cache_sw_get_base_lid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|,
operator|(
name|cache_sw_is_leaf
argument_list|(
name|p_sw
argument_list|)
operator|)
condition|?
literal|"[leaf switch] "
else|:
literal|""
argument_list|,
operator|(
name|p_sw
operator|->
name|dropped
operator|)
condition|?
literal|"[whole switch missing]"
else|:
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|p_sw
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p_sw
operator|->
name|ports
index|[
name|i
index|]
operator|.
name|remote_lid_ho
operator|>
literal|0
condition|)
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"\t     - port %u -> lid %u %s\n"
argument_list|,
name|i
argument_list|,
name|p_sw
operator|->
name|ports
index|[
name|i
index|]
operator|.
name|remote_lid_ho
argument_list|,
operator|(
name|p_sw
operator|->
name|ports
index|[
name|i
index|]
operator|.
name|is_leaf
operator|)
condition|?
literal|"[remote node is leaf]"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_ucast_cache_invalidate
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|)
block|{
name|cache_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|cache_switch_t
modifier|*
name|p_next_sw
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_mgr
operator|->
name|cache_valid
condition|)
goto|goto
name|Exit
goto|;
name|p_mgr
operator|->
name|cache_valid
operator|=
name|FALSE
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|cache_switch_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_mgr
operator|->
name|cache_sw_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_sw
operator|!=
operator|(
name|cache_switch_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_mgr
operator|->
name|cache_sw_tbl
argument_list|)
condition|)
block|{
name|p_sw
operator|=
name|p_next_sw
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|cache_switch_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
name|cache_sw_destroy
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
block|}
name|cl_qmap_remove_all
argument_list|(
operator|&
name|p_mgr
operator|->
name|cache_sw_tbl
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Unicast Cache invalidated\n"
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ucast_cache_validate
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|)
block|{
name|cache_switch_t
modifier|*
name|p_cache_sw
decl_stmt|;
name|cache_switch_t
modifier|*
name|p_remote_cache_sw
decl_stmt|;
name|unsigned
name|port_num
decl_stmt|;
name|unsigned
name|max_ports
decl_stmt|;
name|uint8_t
name|remote_node_type
decl_stmt|;
name|uint16_t
name|lid_ho
decl_stmt|;
name|uint16_t
name|remote_lid_ho
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_remote_sw
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_remote_physp
decl_stmt|;
name|osm_port_t
modifier|*
name|p_remote_port
decl_stmt|;
name|cl_qmap_t
modifier|*
name|p_sw_tbl
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_mgr
operator|->
name|cache_valid
condition|)
goto|goto
name|Exit
goto|;
comment|/* If there are no switches in the subnet, we are done */
name|p_sw_tbl
operator|=
operator|&
name|p_mgr
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
expr_stmt|;
if|if
condition|(
name|cl_qmap_count
argument_list|(
name|p_sw_tbl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	 * Scan all the physical switch ports in the subnet. 	 * If the port need_update flag is on, check whether 	 * it's just some node/port reset or a cached topology 	 * change. Otherwise the cache is invalid. 	 */
for|for
control|(
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_sw_tbl
argument_list|)
init|;
name|p_sw
operator|!=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_sw_tbl
argument_list|)
condition|;
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
control|)
block|{
name|p_node
operator|=
name|p_sw
operator|->
name|p_node
expr_stmt|;
name|lid_ho
operator|=
name|cl_ntoh16
argument_list|(
name|osm_node_get_base_lid
argument_list|(
name|p_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|p_cache_sw
operator|=
name|cache_get_sw
argument_list|(
name|p_mgr
argument_list|,
name|lid_ho
argument_list|)
expr_stmt|;
name|max_ports
operator|=
name|osm_node_get_num_physp
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
comment|/* skip port 0 */
for|for
control|(
name|port_num
operator|=
literal|1
init|;
name|port_num
operator|<
name|max_ports
condition|;
name|port_num
operator|++
control|)
block|{
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
operator|||
operator|!
name|p_physp
operator|->
name|p_remote_physp
operator|||
operator|!
name|osm_physp_link_exists
argument_list|(
name|p_physp
argument_list|,
name|p_physp
operator|->
name|p_remote_physp
argument_list|)
condition|)
comment|/* no valid link */
continue|continue;
comment|/* 			 * While scanning all the physical ports in the subnet, 			 * mark corresponding leaf switches in the cache. 			 */
if|if
condition|(
name|p_cache_sw
operator|&&
operator|!
name|p_cache_sw
operator|->
name|dropped
operator|&&
operator|!
name|cache_sw_is_leaf
argument_list|(
name|p_cache_sw
argument_list|)
operator|&&
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|p_node
operator|&&
name|osm_node_get_type
argument_list|(
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|p_node
argument_list|)
operator|!=
name|IB_NODE_TYPE_SWITCH
condition|)
name|cache_sw_set_leaf
argument_list|(
name|p_cache_sw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
operator|->
name|need_update
condition|)
continue|continue;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Checking switch lid %u, port %u\n"
argument_list|,
name|lid_ho
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|p_remote_physp
operator|=
name|osm_physp_get_remote
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|remote_node_type
operator|=
name|osm_node_get_type
argument_list|(
name|p_remote_physp
operator|->
name|p_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_node_type
operator|==
name|IB_NODE_TYPE_SWITCH
condition|)
name|remote_lid_ho
operator|=
name|cl_ntoh16
argument_list|(
name|osm_node_get_base_lid
argument_list|(
name|p_remote_physp
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|remote_lid_ho
operator|=
name|cl_ntoh16
argument_list|(
name|osm_node_get_base_lid
argument_list|(
name|p_remote_physp
operator|->
name|p_node
argument_list|,
name|osm_physp_get_port_num
argument_list|(
name|p_remote_physp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_cache_sw
operator|||
name|port_num
operator|>=
name|p_cache_sw
operator|->
name|num_ports
operator|||
operator|!
name|p_cache_sw
operator|->
name|ports
index|[
name|port_num
index|]
operator|.
name|remote_lid_ho
condition|)
block|{
comment|/* 				 * There is some uncached change on the port. 				 * In general, the reasons might be as follows: 				 *  - switch reset 				 *  - port reset (or port down/up) 				 *  - quick connection location change 				 *  - new link (or new switch) 				 * 				 * First two reasons allow cache usage, while 				 * the last two reasons should invalidate cache. 				 * 				 * In case of quick connection location change, 				 * cache would have been invalidated by 				 * osm_ucast_cache_check_new_link() function. 				 * 				 * In case of new link between two known nodes, 				 * cache also would have been invalidated by 				 * osm_ucast_cache_check_new_link() function. 				 * 				 * Another reason is cached link between two 				 * known switches went back. In this case the 				 * osm_ucast_cache_check_new_link() function would 				 * clear both sides of the link from the cache 				 * during the discovery process, so effectively 				 * this would be equivalent to port reset. 				 * 				 * So three possible reasons remain: 				 *  - switch reset 				 *  - port reset (or port down/up) 				 *  - link of a new switch 				 * 				 * To validate cache, we need to check only the 				 * third reason - link of a new node/switch: 				 *  - If this is the local switch that is new, 				 *    then it should have (p_sw->need_update == 2). 				 *  - If the remote node is switch and it's new, 				 *    then it also should have 				 *    (p_sw->need_update == 2). 				 *  - If the remote node is CA/RTR and it's new, 				 *    then its port should have is_new flag on. 				 */
if|if
condition|(
name|p_sw
operator|->
name|need_update
operator|==
literal|2
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"New switch found (lid %u)\n"
argument_list|,
name|lid_ho
argument_list|)
expr_stmt|;
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|remote_node_type
operator|==
name|IB_NODE_TYPE_SWITCH
condition|)
block|{
name|p_remote_sw
operator|=
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
expr_stmt|;
if|if
condition|(
name|p_remote_sw
operator|->
name|need_update
operator|==
literal|2
condition|)
block|{
comment|/* this could also be case of 						   switch coming back with an 						   additional link that it 						   didn't have before */
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"New switch/link found (lid %u)\n"
argument_list|,
name|remote_lid_ho
argument_list|)
expr_stmt|;
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
else|else
block|{
comment|/* 					 * Remote node is CA/RTR. 					 * Get p_port of the remote node and 					 * check its p_port->is_new flag. 					 */
name|p_remote_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|p_mgr
operator|->
name|p_subn
argument_list|,
name|osm_physp_get_port_guid
argument_list|(
name|p_remote_physp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_remote_port
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD04: No port was found for "
literal|"port GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_remote_physp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|p_remote_port
operator|->
name|is_new
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"New CA/RTR found (lid %u)\n"
argument_list|,
name|remote_lid_ho
argument_list|)
expr_stmt|;
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
block|}
else|else
block|{
comment|/* 				 * The change on the port is cached. 				 * In general, the reasons might be as follows: 				 *  - link between two known nodes went back 				 *  - one or more nodes went back, causing all 				 *    the links to reappear 				 * 				 * If it was link that went back, then this case 				 * would have been taken care of during the 				 * discovery by osm_ucast_cache_check_new_link(), 				 * so it's some node that went back. 				 */
if|if
condition|(
operator|(
name|p_cache_sw
operator|->
name|ports
index|[
name|port_num
index|]
operator|.
name|is_leaf
operator|&&
name|remote_node_type
operator|==
name|IB_NODE_TYPE_SWITCH
operator|)
operator|||
operator|(
operator|!
name|p_cache_sw
operator|->
name|ports
index|[
name|port_num
index|]
operator|.
name|is_leaf
operator|&&
name|remote_node_type
operator|!=
name|IB_NODE_TYPE_SWITCH
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Remote node type change on switch lid %u, port %u\n"
argument_list|,
name|lid_ho
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|p_cache_sw
operator|->
name|ports
index|[
name|port_num
index|]
operator|.
name|remote_lid_ho
operator|!=
name|remote_lid_ho
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Remote lid change on switch lid %u, port %u"
literal|"(was %u, now %u)\n"
argument_list|,
name|lid_ho
argument_list|,
name|port_num
argument_list|,
name|p_cache_sw
operator|->
name|ports
index|[
name|port_num
index|]
operator|.
name|remote_lid_ho
argument_list|,
name|remote_lid_ho
argument_list|)
expr_stmt|;
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 				 * We don't care who is the node that has 				 * reappeared in the subnet (local or remote). 				 * What's important that the cached link matches 				 * the real fabrics link. 				 * Just clean it from cache. 				 */
name|p_cache_sw
operator|->
name|ports
index|[
name|port_num
index|]
operator|.
name|remote_lid_ho
operator|=
literal|0
expr_stmt|;
name|p_cache_sw
operator|->
name|ports
index|[
name|port_num
index|]
operator|.
name|is_leaf
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|p_cache_sw
operator|->
name|dropped
condition|)
block|{
name|cache_restore_ucast_info
argument_list|(
name|p_mgr
argument_list|,
name|p_cache_sw
argument_list|,
name|p_sw
argument_list|)
expr_stmt|;
name|p_cache_sw
operator|->
name|dropped
operator|=
name|FALSE
expr_stmt|;
block|}
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Restored link from cache: lid %u, port %u to lid %u\n"
argument_list|,
name|lid_ho
argument_list|,
name|port_num
argument_list|,
name|remote_lid_ho
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Remove all the cached switches that 	   have all their ports restored */
name|cache_cleanup_switches
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
comment|/* 	 * Done scanning all the physical switch ports in the subnet. 	 * Now we need to check the other side: 	 * Scan all the cached switches and their ports: 	 *  - If the cached switch is missing in the subnet 	 *    (dropped flag is on), check that it's a leaf switch. 	 *    If it's not a leaf, the cache is invalid, because 	 *    cache can tolerate only leaf switch removal. 	 *  - If the cached switch exists in fabric, check all 	 *    its cached ports. These cached ports represent 	 *    missing link in the fabric. 	 *    The missing links that can be tolerated are: 	 *      + link to missing CA/RTR 	 *      + link to missing leaf switch 	 */
for|for
control|(
name|p_cache_sw
operator|=
operator|(
name|cache_switch_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_mgr
operator|->
name|cache_sw_tbl
argument_list|)
init|;
name|p_cache_sw
operator|!=
operator|(
name|cache_switch_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_mgr
operator|->
name|cache_sw_tbl
argument_list|)
condition|;
name|p_cache_sw
operator|=
operator|(
name|cache_switch_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_cache_sw
operator|->
name|map_item
argument_list|)
control|)
block|{
if|if
condition|(
name|p_cache_sw
operator|->
name|dropped
condition|)
block|{
if|if
condition|(
operator|!
name|cache_sw_is_leaf
argument_list|(
name|p_cache_sw
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Missing non-leaf switch (lid %u)\n"
argument_list|,
name|cache_sw_get_base_lid_ho
argument_list|(
name|p_cache_sw
argument_list|)
argument_list|)
expr_stmt|;
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Missing leaf switch (lid %u) - "
literal|"continuing validation\n"
argument_list|,
name|cache_sw_get_base_lid_ho
argument_list|(
name|p_cache_sw
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|port_num
operator|=
literal|1
init|;
name|port_num
operator|<
name|p_cache_sw
operator|->
name|num_ports
condition|;
name|port_num
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|p_cache_sw
operator|->
name|ports
index|[
name|port_num
index|]
operator|.
name|remote_lid_ho
condition|)
continue|continue;
if|if
condition|(
name|p_cache_sw
operator|->
name|ports
index|[
name|port_num
index|]
operator|.
name|is_leaf
condition|)
block|{
name|CL_ASSERT
argument_list|(
name|cache_sw_is_leaf
argument_list|(
name|p_cache_sw
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Switch lid %u, port %u: missing link to CA/RTR - "
literal|"continuing validation\n"
argument_list|,
name|cache_sw_get_base_lid_ho
argument_list|(
name|p_cache_sw
argument_list|)
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|p_remote_cache_sw
operator|=
name|cache_get_sw
argument_list|(
name|p_mgr
argument_list|,
name|p_cache_sw
operator|->
name|ports
index|[
name|port_num
index|]
operator|.
name|remote_lid_ho
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_remote_cache_sw
operator|||
operator|!
name|p_remote_cache_sw
operator|->
name|dropped
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Switch lid %u, port %u: missing link to existing switch\n"
argument_list|,
name|cache_sw_get_base_lid_ho
argument_list|(
name|p_cache_sw
argument_list|)
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|!
name|cache_sw_is_leaf
argument_list|(
name|p_remote_cache_sw
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Switch lid %u, port %u: missing link to non-leaf switch\n"
argument_list|,
name|cache_sw_get_base_lid_ho
argument_list|(
name|p_cache_sw
argument_list|)
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 			 * At this point we know that the missing link is to 			 * a leaf switch. However, one case deserves a special 			 * treatment. If there was a link between two leaf 			 * switches, then missing leaf switch might break 			 * routing. It is possible that there are routes 			 * that use leaf switches to get from switch to switch 			 * and not just to get to the CAs behind the leaf switch. 			 */
if|if
condition|(
name|cache_sw_is_leaf
argument_list|(
name|p_cache_sw
argument_list|)
operator|&&
name|cache_sw_is_leaf
argument_list|(
name|p_remote_cache_sw
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Switch lid %u, port %u: missing leaf-2-leaf link\n"
argument_list|,
name|cache_sw_get_base_lid_ho
argument_list|(
name|p_cache_sw
argument_list|)
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Switch lid %u, port %u: missing remote leaf switch - "
literal|"continuing validation\n"
argument_list|,
name|cache_sw_get_base_lid_ho
argument_list|(
name|p_cache_sw
argument_list|)
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
block|}
block|}
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Unicast cache is valid\n"
argument_list|)
expr_stmt|;
name|ucast_cache_dump
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* osm_ucast_cache_validate() */
end_comment

begin_function
name|void
name|osm_ucast_cache_check_new_link
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|,
name|osm_node_t
modifier|*
name|p_node_1
parameter_list|,
name|uint8_t
name|port_num_1
parameter_list|,
name|osm_node_t
modifier|*
name|p_node_2
parameter_list|,
name|uint8_t
name|port_num_2
parameter_list|)
block|{
name|uint16_t
name|lid_ho_1
decl_stmt|;
name|uint16_t
name|lid_ho_2
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_mgr
operator|->
name|cache_valid
condition|)
goto|goto
name|Exit
goto|;
name|cache_check_link_change
argument_list|(
name|p_mgr
argument_list|,
name|osm_node_get_physp_ptr
argument_list|(
name|p_node_1
argument_list|,
name|port_num_1
argument_list|)
argument_list|,
name|osm_node_get_physp_ptr
argument_list|(
name|p_node_2
argument_list|,
name|port_num_2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_mgr
operator|->
name|cache_valid
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|p_node_1
argument_list|)
operator|!=
name|IB_NODE_TYPE_SWITCH
operator|&&
name|osm_node_get_type
argument_list|(
name|p_node_2
argument_list|)
operator|!=
name|IB_NODE_TYPE_SWITCH
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Found CA-2-CA link\n"
argument_list|)
expr_stmt|;
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* for code simplicity, we want the first node to be switch */
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|p_node_1
argument_list|)
operator|!=
name|IB_NODE_TYPE_SWITCH
condition|)
block|{
name|osm_node_t
modifier|*
name|tmp_node
init|=
name|p_node_1
decl_stmt|;
name|uint8_t
name|tmp_port_num
init|=
name|port_num_1
decl_stmt|;
name|p_node_1
operator|=
name|p_node_2
expr_stmt|;
name|port_num_1
operator|=
name|port_num_2
expr_stmt|;
name|p_node_2
operator|=
name|tmp_node
expr_stmt|;
name|port_num_2
operator|=
name|tmp_port_num
expr_stmt|;
block|}
name|lid_ho_1
operator|=
name|cl_ntoh16
argument_list|(
name|osm_node_get_base_lid
argument_list|(
name|p_node_1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|p_node_2
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
condition|)
name|lid_ho_2
operator|=
name|cl_ntoh16
argument_list|(
name|osm_node_get_base_lid
argument_list|(
name|p_node_2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|lid_ho_2
operator|=
name|cl_ntoh16
argument_list|(
name|osm_node_get_base_lid
argument_list|(
name|p_node_2
argument_list|,
name|port_num_2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lid_ho_1
operator|||
operator|!
name|lid_ho_2
condition|)
block|{
comment|/* 		 * No lid assigned, which means that one of the nodes is new. 		 * Need to wait for lid manager to process this node. 		 * The switches and their links will be checked later when 		 * the whole cache validity will be verified. 		 */
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Link port %u<-> %u reveals new node - cache will "
literal|"be validated later\n"
argument_list|,
name|port_num_1
argument_list|,
name|port_num_2
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|cache_remove_port
argument_list|(
name|p_mgr
argument_list|,
name|lid_ho_1
argument_list|,
name|port_num_1
argument_list|,
name|lid_ho_2
argument_list|,
operator|(
name|osm_node_get_type
argument_list|(
name|p_node_2
argument_list|)
operator|!=
name|IB_NODE_TYPE_SWITCH
operator|)
argument_list|)
expr_stmt|;
comment|/* if node_2 is a switch, the link should be cleaned from its cache */
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|p_node_2
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
condition|)
name|cache_remove_port
argument_list|(
name|p_mgr
argument_list|,
name|lid_ho_2
argument_list|,
name|port_num_2
argument_list|,
name|lid_ho_1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* osm_ucast_cache_check_new_link() */
end_comment

begin_function
name|void
name|osm_ucast_cache_add_link
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|,
name|osm_physp_t
modifier|*
name|p_physp1
parameter_list|,
name|osm_physp_t
modifier|*
name|p_physp2
parameter_list|)
block|{
name|osm_node_t
modifier|*
name|p_node_1
init|=
name|p_physp1
operator|->
name|p_node
decl_stmt|,
modifier|*
name|p_node_2
init|=
name|p_physp2
operator|->
name|p_node
decl_stmt|;
name|uint16_t
name|lid_ho_1
decl_stmt|,
name|lid_ho_2
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_mgr
operator|->
name|cache_valid
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|p_node_1
argument_list|)
operator|!=
name|IB_NODE_TYPE_SWITCH
operator|&&
name|osm_node_get_type
argument_list|(
name|p_node_2
argument_list|)
operator|!=
name|IB_NODE_TYPE_SWITCH
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Dropping CA-2-CA link\n"
argument_list|)
expr_stmt|;
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|(
name|osm_node_get_type
argument_list|(
name|p_node_1
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
operator|&&
operator|!
name|osm_node_get_physp_ptr
argument_list|(
name|p_node_1
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
operator|(
name|osm_node_get_type
argument_list|(
name|p_node_2
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
operator|&&
operator|!
name|osm_node_get_physp_ptr
argument_list|(
name|p_node_2
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
comment|/* we're caching a link when one of the nodes 		   has already been dropped and cached */
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Port %u<-> port %u: port0 on one of the nodes "
literal|"has already been dropped and cached\n"
argument_list|,
name|p_physp1
operator|->
name|port_num
argument_list|,
name|p_physp2
operator|->
name|port_num
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* One of the nodes is switch. Just for code 	   simplicity, make sure that it's the first node. */
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|p_node_1
argument_list|)
operator|!=
name|IB_NODE_TYPE_SWITCH
condition|)
block|{
name|osm_physp_t
modifier|*
name|tmp
init|=
name|p_physp1
decl_stmt|;
name|p_physp1
operator|=
name|p_physp2
expr_stmt|;
name|p_physp2
operator|=
name|tmp
expr_stmt|;
name|p_node_1
operator|=
name|p_physp1
operator|->
name|p_node
expr_stmt|;
name|p_node_2
operator|=
name|p_physp2
operator|->
name|p_node
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p_node_1
operator|->
name|sw
condition|)
block|{
comment|/* something is wrong - we'd better not use cache */
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|lid_ho_1
operator|=
name|cl_ntoh16
argument_list|(
name|osm_node_get_base_lid
argument_list|(
name|p_node_1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|p_node_2
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
condition|)
block|{
if|if
condition|(
operator|!
name|p_node_2
operator|->
name|sw
condition|)
block|{
comment|/* something is wrong - we'd better not use cache */
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|lid_ho_2
operator|=
name|cl_ntoh16
argument_list|(
name|osm_node_get_base_lid
argument_list|(
name|p_node_2
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* lost switch-2-switch link - cache both sides */
name|cache_add_sw_link
argument_list|(
name|p_mgr
argument_list|,
name|p_physp1
argument_list|,
name|lid_ho_2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|cache_add_sw_link
argument_list|(
name|p_mgr
argument_list|,
name|p_physp2
argument_list|,
name|lid_ho_1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lid_ho_2
operator|=
name|cl_ntoh16
argument_list|(
name|osm_physp_get_base_lid
argument_list|(
name|p_physp2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* lost link to CA/RTR - cache only switch side */
name|cache_add_sw_link
argument_list|(
name|p_mgr
argument_list|,
name|p_physp1
argument_list|,
name|lid_ho_2
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* osm_ucast_cache_add_link() */
end_comment

begin_function
name|void
name|osm_ucast_cache_add_node
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|,
name|osm_node_t
modifier|*
name|p_node
parameter_list|)
block|{
name|uint16_t
name|lid_ho
decl_stmt|;
name|uint8_t
name|max_ports
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|cache_switch_t
modifier|*
name|p_cache_sw
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_mgr
operator|->
name|cache_valid
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|p_node
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
condition|)
block|{
name|lid_ho
operator|=
name|cl_ntoh16
argument_list|(
name|osm_node_get_base_lid
argument_list|(
name|p_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lid_ho
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Skip caching. Switch dropped before "
literal|"it gets a valid lid.\n"
argument_list|)
expr_stmt|;
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Caching dropped switch lid %u\n"
argument_list|,
name|lid_ho
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_node
operator|->
name|sw
condition|)
block|{
comment|/* something is wrong - forget about cache */
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AD03: no switch info for node lid %u - "
literal|"clearing cache\n"
argument_list|,
name|lid_ho
argument_list|)
expr_stmt|;
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* unlink (add to cache) all the ports of this switch */
name|max_ports
operator|=
name|osm_node_get_num_physp
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
for|for
control|(
name|port_num
operator|=
literal|1
init|;
name|port_num
operator|<
name|max_ports
condition|;
name|port_num
operator|++
control|)
block|{
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
operator|||
operator|!
name|p_physp
operator|->
name|p_remote_physp
condition|)
continue|continue;
name|osm_ucast_cache_add_link
argument_list|(
name|p_mgr
argument_list|,
name|p_physp
argument_list|,
name|p_physp
operator|->
name|p_remote_physp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * All the ports have been dropped (cached). 		 * If one of the ports was connected to CA/RTR, 		 * then the cached switch would be marked as leaf. 		 * If it isn't, then the dropped switch isn't a leaf, 		 * and cache can't handle it. 		 */
name|p_cache_sw
operator|=
name|cache_get_sw
argument_list|(
name|p_mgr
argument_list|,
name|lid_ho
argument_list|)
expr_stmt|;
comment|/* p_cache_sw could be NULL if it has no remote phys ports */
if|if
condition|(
operator|!
name|p_cache_sw
operator|||
operator|!
name|cache_sw_is_leaf
argument_list|(
name|p_cache_sw
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Dropped non-leaf switch (lid %u)\n"
argument_list|,
name|lid_ho
argument_list|)
expr_stmt|;
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_cache_sw
operator|->
name|dropped
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|p_node
operator|->
name|sw
operator|->
name|num_hops
operator|||
operator|!
name|p_node
operator|->
name|sw
operator|->
name|hops
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"No LID matrices for switch lid %u\n"
argument_list|,
name|lid_ho
argument_list|)
expr_stmt|;
name|osm_ucast_cache_invalidate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* lid matrices */
name|p_cache_sw
operator|->
name|num_hops
operator|=
name|p_node
operator|->
name|sw
operator|->
name|num_hops
expr_stmt|;
name|p_node
operator|->
name|sw
operator|->
name|num_hops
operator|=
literal|0
expr_stmt|;
name|p_cache_sw
operator|->
name|hops
operator|=
name|p_node
operator|->
name|sw
operator|->
name|hops
expr_stmt|;
name|p_node
operator|->
name|sw
operator|->
name|hops
operator|=
name|NULL
expr_stmt|;
comment|/* linear forwarding table */
if|if
condition|(
name|p_node
operator|->
name|sw
operator|->
name|new_lft
condition|)
block|{
comment|/* LFT buffer exists - we use it, because 			   it is more updated than the switch's LFT */
name|p_cache_sw
operator|->
name|lft
operator|=
name|p_node
operator|->
name|sw
operator|->
name|new_lft
expr_stmt|;
name|p_node
operator|->
name|sw
operator|->
name|new_lft
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* no LFT buffer, so we use the switch's LFT */
name|p_cache_sw
operator|->
name|lft
operator|=
name|p_node
operator|->
name|sw
operator|->
name|lft
expr_stmt|;
name|p_node
operator|->
name|sw
operator|->
name|lft
operator|=
name|NULL
expr_stmt|;
name|p_node
operator|->
name|sw
operator|->
name|lft_size
operator|=
literal|0
expr_stmt|;
block|}
name|p_cache_sw
operator|->
name|max_lid_ho
operator|=
name|p_node
operator|->
name|sw
operator|->
name|max_lid_ho
expr_stmt|;
block|}
else|else
block|{
comment|/* dropping CA/RTR: add to cache all the ports of this node */
name|max_ports
operator|=
name|osm_node_get_num_physp
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
for|for
control|(
name|port_num
operator|=
literal|1
init|;
name|port_num
operator|<
name|max_ports
condition|;
name|port_num
operator|++
control|)
block|{
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
operator|||
operator|!
name|p_physp
operator|->
name|p_remote_physp
condition|)
continue|continue;
name|CL_ASSERT
argument_list|(
name|osm_node_get_type
argument_list|(
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|p_node
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
argument_list|)
expr_stmt|;
name|osm_ucast_cache_add_link
argument_list|(
name|p_mgr
argument_list|,
name|p_physp
operator|->
name|p_remote_physp
argument_list|,
name|p_physp
argument_list|)
expr_stmt|;
block|}
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* osm_ucast_cache_add_node() */
end_comment

begin_function
name|int
name|osm_ucast_cache_process
parameter_list|(
name|osm_ucast_mgr_t
modifier|*
name|p_mgr
parameter_list|)
block|{
name|cl_qmap_t
modifier|*
name|tbl
init|=
operator|&
name|p_mgr
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
decl_stmt|;
name|cl_map_item_t
modifier|*
name|item
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|uint16_t
name|lft_size
decl_stmt|;
if|if
condition|(
operator|!
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|use_ucast_cache
condition|)
return|return
literal|1
return|;
name|ucast_cache_validate
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_mgr
operator|->
name|cache_valid
condition|)
return|return
literal|1
return|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Configuring switch tables using cached routing\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
name|cl_qmap_head
argument_list|(
name|tbl
argument_list|)
init|;
name|item
operator|!=
name|cl_qmap_end
argument_list|(
name|tbl
argument_list|)
condition|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
control|)
block|{
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|item
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_sw
operator|->
name|new_lft
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_sw
operator|->
name|lft
condition|)
block|{
name|lft_size
operator|=
operator|(
name|p_sw
operator|->
name|max_lid_ho
operator|/
name|IB_SMP_DATA_SIZE
operator|+
literal|1
operator|)
operator|*
name|IB_SMP_DATA_SIZE
expr_stmt|;
name|p_sw
operator|->
name|lft
operator|=
name|malloc
argument_list|(
name|lft_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_sw
operator|->
name|lft
condition|)
return|return
name|IB_INSUFFICIENT_MEMORY
return|;
name|p_sw
operator|->
name|lft_size
operator|=
name|lft_size
expr_stmt|;
name|memset
argument_list|(
name|p_sw
operator|->
name|lft
argument_list|,
name|OSM_NO_PATH
argument_list|,
name|p_sw
operator|->
name|lft_size
argument_list|)
expr_stmt|;
block|}
block|}
name|osm_ucast_mgr_set_fwd_tables
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

