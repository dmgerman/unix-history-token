begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2007 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  * Copyright (c) 2013 Oracle and/or its affiliates. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  * Implementation of the osm_db interface using simple text files  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_DB_FILES_C
end_define

begin_include
include|#
directive|include
file|<opensm/st.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_db.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_comment
comment|/****d* Database/OSM_DB_MAX_LINE_LEN  * NAME  * OSM_DB_MAX_LINE_LEN  *  * DESCRIPTION  * The Maximal line length allowed for the file  *  * SYNOPSIS  */
end_comment

begin_define
define|#
directive|define
name|OSM_DB_MAX_LINE_LEN
value|1024
end_define

begin_comment
comment|/**********/
end_comment

begin_comment
comment|/****d* Database/OSM_DB_MAX_GUID_LEN  * NAME  * OSM_DB_MAX_GUID_LEN  *  * DESCRIPTION  * The Maximal word length allowed for the file (guid or lid)  *  * SYNOPSIS  */
end_comment

begin_define
define|#
directive|define
name|OSM_DB_MAX_GUID_LEN
value|32
end_define

begin_comment
comment|/**********/
end_comment

begin_comment
comment|/****s* OpenSM: Database/osm_db_domain_imp  * NAME  * osm_db_domain_imp  *  * DESCRIPTION  * An implementation for domain of the database based on text files and  *  hash tables.  *  * SYNOPSIS  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|osm_db_domain_imp
block|{
name|char
modifier|*
name|file_name
decl_stmt|;
name|st_table
modifier|*
name|p_hash
decl_stmt|;
name|cl_spinlock_t
name|lock
decl_stmt|;
name|boolean_t
name|dirty
decl_stmt|;
block|}
name|osm_db_domain_imp_t
typedef|;
end_typedef

begin_comment
comment|/*  * FIELDS  *  * SEE ALSO  * osm_db_domain_t  *********/
end_comment

begin_comment
comment|/****s* OpenSM: Database/osm_db_imp_t  * NAME  * osm_db_imp_t  *  * DESCRIPTION  * An implementation for file based database  *  * SYNOPSIS  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|osm_db_imp
block|{
specifier|const
name|char
modifier|*
name|db_dir_name
decl_stmt|;
block|}
name|osm_db_imp_t
typedef|;
end_typedef

begin_comment
comment|/*  * FIELDS  *  * db_dir_name  *   The directory holding the database  *  * SEE ALSO  * osm_db_t  *********/
end_comment

begin_function
name|void
name|osm_db_construct
parameter_list|(
name|IN
name|osm_db_t
modifier|*
name|p_db
parameter_list|)
block|{
name|memset
argument_list|(
name|p_db
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|osm_db_t
argument_list|)
argument_list|)
expr_stmt|;
name|cl_list_construct
argument_list|(
operator|&
name|p_db
operator|->
name|domains
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_db_domain_destroy
parameter_list|(
name|IN
name|osm_db_domain_t
modifier|*
name|p_db_domain
parameter_list|)
block|{
name|osm_db_domain_imp_t
modifier|*
name|p_domain_imp
decl_stmt|;
name|p_domain_imp
operator|=
operator|(
name|osm_db_domain_imp_t
operator|*
operator|)
name|p_db_domain
operator|->
name|p_domain_imp
expr_stmt|;
name|osm_db_clear
argument_list|(
name|p_db_domain
argument_list|)
expr_stmt|;
name|cl_spinlock_destroy
argument_list|(
operator|&
name|p_domain_imp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|st_free_table
argument_list|(
name|p_domain_imp
operator|->
name|p_hash
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_domain_imp
operator|->
name|file_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_domain_imp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_db_destroy
parameter_list|(
name|IN
name|osm_db_t
modifier|*
name|p_db
parameter_list|)
block|{
name|osm_db_domain_t
modifier|*
name|p_domain
decl_stmt|;
while|while
condition|(
operator|(
name|p_domain
operator|=
name|cl_list_remove_head
argument_list|(
operator|&
name|p_db
operator|->
name|domains
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|osm_db_domain_destroy
argument_list|(
name|p_domain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_domain
argument_list|)
expr_stmt|;
block|}
name|cl_list_destroy
argument_list|(
operator|&
name|p_db
operator|->
name|domains
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_db
operator|->
name|p_db_imp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|osm_db_init
parameter_list|(
name|IN
name|osm_db_t
modifier|*
name|p_db
parameter_list|,
name|IN
name|osm_log_t
modifier|*
name|p_log
parameter_list|)
block|{
name|osm_db_imp_t
modifier|*
name|p_db_imp
decl_stmt|;
name|struct
name|stat
name|dstat
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|p_db_imp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|osm_db_imp_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_db_imp
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 6100: "
literal|"Failed to allocate db memory\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p_db_imp
operator|->
name|db_dir_name
operator|=
name|getenv
argument_list|(
literal|"OSM_CACHE_DIR"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_db_imp
operator|->
name|db_dir_name
operator|||
operator|!
operator|(
operator|*
name|p_db_imp
operator|->
name|db_dir_name
operator|)
condition|)
name|p_db_imp
operator|->
name|db_dir_name
operator|=
name|OSM_DEFAULT_CACHE_DIR
expr_stmt|;
comment|/* Create the directory if it doesn't exist */
comment|/* There is a difference in creating directory between windows and linux */
ifdef|#
directive|ifdef
name|__WIN__
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|SHCreateDirectoryEx
argument_list|(
name|NULL
argument_list|,
name|p_db_imp
operator|->
name|db_dir_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ERROR_SUCCESS
operator|&&
name|ret
operator|!=
name|ERROR_ALREADY_EXISTS
operator|&&
name|ret
operator|!=
name|ERROR_FILE_EXISTS
condition|)
goto|goto
name|err
goto|;
block|}
else|#
directive|else
comment|/* __WIN__ */
comment|/* make sure the directory exists */
if|if
condition|(
name|lstat
argument_list|(
name|p_db_imp
operator|->
name|db_dir_name
argument_list|,
operator|&
name|dstat
argument_list|)
condition|)
block|{
if|if
condition|(
name|mkdir
argument_list|(
name|p_db_imp
operator|->
name|db_dir_name
argument_list|,
literal|0755
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
endif|#
directive|endif
name|p_db
operator|->
name|p_log
operator|=
name|p_log
expr_stmt|;
name|p_db
operator|->
name|p_db_imp
operator|=
operator|(
name|void
operator|*
operator|)
name|p_db_imp
expr_stmt|;
name|cl_list_init
argument_list|(
operator|&
name|p_db
operator|->
name|domains
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err
label|:
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 6101: "
literal|"Failed to create the db directory:%s\n"
argument_list|,
name|p_db_imp
operator|->
name|db_dir_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_db_imp
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|osm_db_domain_t
modifier|*
name|osm_db_domain_init
parameter_list|(
name|IN
name|osm_db_t
modifier|*
name|p_db
parameter_list|,
name|IN
specifier|const
name|char
modifier|*
name|domain_name
parameter_list|)
block|{
name|osm_db_domain_t
modifier|*
name|p_domain
decl_stmt|;
name|osm_db_domain_imp_t
modifier|*
name|p_domain_imp
decl_stmt|;
name|size_t
name|path_len
decl_stmt|;
name|osm_log_t
modifier|*
name|p_log
init|=
name|p_db
operator|->
name|p_log
decl_stmt|;
name|FILE
modifier|*
name|p_file
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
comment|/* allocate a new domain object */
name|p_domain
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|osm_db_domain_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_domain
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 610C: "
literal|"Failed to allocate domain memory\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_domain_imp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|osm_db_domain_imp_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_domain_imp
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 610D: "
literal|"Failed to allocate domain_imp memory\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_domain
argument_list|)
expr_stmt|;
name|p_domain
operator|=
name|NULL
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|path_len
operator|=
name|strlen
argument_list|(
operator|(
operator|(
name|osm_db_imp_t
operator|*
operator|)
name|p_db
operator|->
name|p_db_imp
operator|)
operator|->
name|db_dir_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|domain_name
argument_list|)
operator|+
literal|2
expr_stmt|;
comment|/* set the domain file name */
name|p_domain_imp
operator|->
name|file_name
operator|=
name|malloc
argument_list|(
name|path_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_domain_imp
operator|->
name|file_name
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 610E: "
literal|"Failed to allocate file_name memory\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_domain_imp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_domain
argument_list|)
expr_stmt|;
name|p_domain
operator|=
name|NULL
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|snprintf
argument_list|(
name|p_domain_imp
operator|->
name|file_name
argument_list|,
name|path_len
argument_list|,
literal|"%s/%s"
argument_list|,
operator|(
operator|(
name|osm_db_imp_t
operator|*
operator|)
name|p_db
operator|->
name|p_db_imp
operator|)
operator|->
name|db_dir_name
argument_list|,
name|domain_name
argument_list|)
expr_stmt|;
comment|/* make sure the file exists - or exit if not writable */
name|p_file
operator|=
name|fopen
argument_list|(
name|p_domain_imp
operator|->
name|file_name
argument_list|,
literal|"a+"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_file
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 6102: "
literal|"Failed to open the db file:%s\n"
argument_list|,
name|p_domain_imp
operator|->
name|file_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_domain_imp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_domain
argument_list|)
expr_stmt|;
name|p_domain
operator|=
name|NULL
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|fclose
argument_list|(
name|p_file
argument_list|)
expr_stmt|;
comment|/* initialize the hash table object */
name|p_domain_imp
operator|->
name|p_hash
operator|=
name|st_init_strtable
argument_list|()
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_domain_imp
operator|->
name|p_hash
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|p_domain_imp
operator|->
name|dirty
operator|=
name|FALSE
expr_stmt|;
name|p_domain
operator|->
name|p_db
operator|=
name|p_db
expr_stmt|;
name|cl_list_insert_tail
argument_list|(
operator|&
name|p_db
operator|->
name|domains
argument_list|,
name|p_domain
argument_list|)
expr_stmt|;
name|p_domain
operator|->
name|p_domain_imp
operator|=
name|p_domain_imp
expr_stmt|;
name|cl_spinlock_construct
argument_list|(
operator|&
name|p_domain_imp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cl_spinlock_init
argument_list|(
operator|&
name|p_domain_imp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
name|p_domain
return|;
block|}
end_function

begin_function
name|int
name|osm_db_restore
parameter_list|(
name|IN
name|osm_db_domain_t
modifier|*
name|p_domain
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
name|p_domain
operator|->
name|p_db
operator|->
name|p_log
decl_stmt|;
name|osm_db_domain_imp_t
modifier|*
name|p_domain_imp
init|=
operator|(
name|osm_db_domain_imp_t
operator|*
operator|)
name|p_domain
operator|->
name|p_domain_imp
decl_stmt|;
name|FILE
modifier|*
name|p_file
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
name|sLine
index|[
name|OSM_DB_MAX_LINE_LEN
index|]
decl_stmt|;
name|boolean_t
name|before_key
decl_stmt|;
name|char
modifier|*
name|p_first_word
decl_stmt|,
modifier|*
name|p_rest_of_line
decl_stmt|,
modifier|*
name|p_last
decl_stmt|;
name|char
modifier|*
name|p_key
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|p_prev_val
init|=
name|NULL
decl_stmt|,
modifier|*
name|p_accum_val
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|endptr
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|line_num
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
comment|/* take the lock on the domain */
name|cl_spinlock_acquire
argument_list|(
operator|&
name|p_domain_imp
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* open the file - read mode */
name|p_file
operator|=
name|fopen
argument_list|(
name|p_domain_imp
operator|->
name|file_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_file
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 6103: "
literal|"Failed to open the db file:%s\n"
argument_list|,
name|p_domain_imp
operator|->
name|file_name
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* parse the file allocating new hash tables as required */
comment|/* 	   states: 	   before_key (0) -> in_key (1)  	   before_key: if a word on the first byte - it is the key. state=in_key 	   the rest of the line is start of the value. 	   in_key: unless the line is empty - add it (with newlines) to the value. 	   if empty: state=before_key 	 */
name|status
operator|=
literal|0
expr_stmt|;
name|before_key
operator|=
name|TRUE
expr_stmt|;
name|line_num
operator|=
literal|0
expr_stmt|;
comment|/* if we got to EOF in the middle of a key we add a last newline */
while|while
condition|(
operator|(
name|fgets
argument_list|(
name|sLine
argument_list|,
name|OSM_DB_MAX_LINE_LEN
argument_list|,
name|p_file
argument_list|)
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
name|before_key
operator|==
name|FALSE
operator|)
operator|&&
name|strcpy
argument_list|(
name|sLine
argument_list|,
literal|"\n"
argument_list|)
operator|)
condition|)
block|{
name|line_num
operator|++
expr_stmt|;
if|if
condition|(
name|before_key
condition|)
block|{
if|if
condition|(
operator|(
name|sLine
index|[
literal|0
index|]
operator|!=
literal|' '
operator|)
operator|&&
operator|(
name|sLine
index|[
literal|0
index|]
operator|!=
literal|'\t'
operator|)
operator|&&
operator|(
name|sLine
index|[
literal|0
index|]
operator|!=
literal|'\n'
operator|)
condition|)
block|{
comment|/* we got a new key */
name|before_key
operator|=
name|FALSE
expr_stmt|;
comment|/* handle the key */
name|p_first_word
operator|=
name|strtok_r
argument_list|(
name|sLine
argument_list|,
literal|" \t\n"
argument_list|,
operator|&
name|p_last
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_first_word
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 6104: "
literal|"Failed to get key from line:%u : %s (file:%s)\n"
argument_list|,
name|line_num
argument_list|,
name|sLine
argument_list|,
name|p_domain_imp
operator|->
name|file_name
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
goto|goto
name|EndParsing
goto|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|p_first_word
argument_list|)
operator|>
name|OSM_DB_MAX_GUID_LEN
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 610A: "
literal|"Illegal key from line:%u : %s (file:%s)\n"
argument_list|,
name|line_num
argument_list|,
name|sLine
argument_list|,
name|p_domain_imp
operator|->
name|file_name
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
goto|goto
name|EndParsing
goto|;
block|}
name|p_key
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
operator|(
name|strlen
argument_list|(
name|p_first_word
argument_list|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p_key
argument_list|,
name|p_first_word
argument_list|)
expr_stmt|;
name|p_rest_of_line
operator|=
name|strtok_r
argument_list|(
name|NULL
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|p_last
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_rest_of_line
operator|!=
name|NULL
condition|)
block|{
name|p_accum_val
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
operator|(
name|strlen
argument_list|(
name|p_rest_of_line
argument_list|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p_accum_val
argument_list|,
name|p_rest_of_line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p_accum_val
operator|=
name|malloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p_accum_val
argument_list|,
literal|"\0"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sLine
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 6105: "
literal|"How did we get here? line:%u : %s (file:%s)\n"
argument_list|,
name|line_num
argument_list|,
name|sLine
argument_list|,
name|p_domain_imp
operator|->
name|file_name
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
goto|goto
name|EndParsing
goto|;
block|}
block|}
comment|/* before key */
else|else
block|{
comment|/* we already have a key */
if|if
condition|(
name|sLine
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
block|{
comment|/* got an end of key */
name|before_key
operator|=
name|TRUE
expr_stmt|;
comment|/* make sure the key was not previously used */
if|if
condition|(
name|st_lookup
argument_list|(
name|p_domain_imp
operator|->
name|p_hash
argument_list|,
operator|(
name|st_data_t
operator|)
name|p_key
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_prev_val
argument_list|)
condition|)
block|{
comment|/* if previously used we ignore this guid */
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 6106: "
literal|"Key:%s already exists in:%s with value:%s."
literal|" Removing it\n"
argument_list|,
name|p_key
argument_list|,
name|p_domain_imp
operator|->
name|file_name
argument_list|,
name|p_prev_val
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_key
argument_list|)
expr_stmt|;
name|p_key
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|p_accum_val
argument_list|)
expr_stmt|;
name|p_accum_val
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|p_prev_val
operator|=
name|NULL
expr_stmt|;
block|}
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Got key:%s value:%s\n"
argument_list|,
name|p_key
argument_list|,
name|p_accum_val
argument_list|)
expr_stmt|;
comment|/* check that the key is a number */
if|if
condition|(
operator|!
name|strtouq
argument_list|(
name|p_key
argument_list|,
operator|&
name|endptr
argument_list|,
literal|0
argument_list|)
operator|&&
operator|*
name|endptr
operator|!=
literal|'\0'
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 610B: "
literal|"Key:%s is invalid\n"
argument_list|,
name|p_key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_key
argument_list|)
expr_stmt|;
name|p_key
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|p_accum_val
argument_list|)
expr_stmt|;
name|p_accum_val
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* store our key and value */
name|st_insert
argument_list|(
name|p_domain_imp
operator|->
name|p_hash
argument_list|,
operator|(
name|st_data_t
operator|)
name|p_key
argument_list|,
operator|(
name|st_data_t
operator|)
name|p_accum_val
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* accumulate into the value */
name|p_prev_val
operator|=
name|p_accum_val
expr_stmt|;
name|p_accum_val
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|p_prev_val
argument_list|)
operator|+
name|strlen
argument_list|(
name|sLine
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p_accum_val
argument_list|,
name|p_prev_val
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_prev_val
argument_list|)
expr_stmt|;
name|p_prev_val
operator|=
name|NULL
expr_stmt|;
name|strcat
argument_list|(
name|p_accum_val
argument_list|,
name|sLine
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* in key */
block|}
comment|/* while lines or last line */
name|EndParsing
label|:
name|fclose
argument_list|(
name|p_file
argument_list|)
expr_stmt|;
name|Exit
label|:
name|cl_spinlock_release
argument_list|(
operator|&
name|p_domain_imp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dump_tbl_entry
parameter_list|(
name|st_data_t
name|key
parameter_list|,
name|st_data_t
name|val
parameter_list|,
name|st_data_t
name|arg
parameter_list|)
block|{
name|FILE
modifier|*
name|p_file
init|=
operator|(
name|FILE
operator|*
operator|)
name|arg
decl_stmt|;
name|char
modifier|*
name|p_key
init|=
operator|(
name|char
operator|*
operator|)
name|key
decl_stmt|;
name|char
modifier|*
name|p_val
init|=
operator|(
name|char
operator|*
operator|)
name|val
decl_stmt|;
name|fprintf
argument_list|(
name|p_file
argument_list|,
literal|"%s %s\n\n"
argument_list|,
name|p_key
argument_list|,
name|p_val
argument_list|)
expr_stmt|;
return|return
name|ST_CONTINUE
return|;
block|}
end_function

begin_function
name|int
name|osm_db_store
parameter_list|(
name|IN
name|osm_db_domain_t
modifier|*
name|p_domain
parameter_list|,
name|IN
name|boolean_t
name|fsync_high_avail_files
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
name|p_domain
operator|->
name|p_db
operator|->
name|p_log
decl_stmt|;
name|osm_db_domain_imp_t
modifier|*
name|p_domain_imp
decl_stmt|;
name|FILE
modifier|*
name|p_file
init|=
name|NULL
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|status
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p_tmp_file_name
init|=
name|NULL
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|p_domain_imp
operator|=
operator|(
name|osm_db_domain_imp_t
operator|*
operator|)
name|p_domain
operator|->
name|p_domain_imp
expr_stmt|;
name|p_tmp_file_name
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
operator|(
name|strlen
argument_list|(
name|p_domain_imp
operator|->
name|file_name
argument_list|)
operator|+
literal|8
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_tmp_file_name
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 6113: "
literal|"Failed to allocate memory for temporary file name\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit2
goto|;
block|}
name|strcpy
argument_list|(
name|p_tmp_file_name
argument_list|,
name|p_domain_imp
operator|->
name|file_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p_tmp_file_name
argument_list|,
literal|".tmp"
argument_list|)
expr_stmt|;
name|cl_spinlock_acquire
argument_list|(
operator|&
name|p_domain_imp
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_domain_imp
operator|->
name|dirty
operator|==
name|FALSE
condition|)
goto|goto
name|Exit
goto|;
comment|/* open up the output file */
name|p_file
operator|=
name|fopen
argument_list|(
name|p_tmp_file_name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_file
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 6107: "
literal|"Failed to open the db file:%s for writing: err:%s\n"
argument_list|,
name|p_domain_imp
operator|->
name|file_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|st_foreach
argument_list|(
name|p_domain_imp
operator|->
name|p_hash
argument_list|,
name|dump_tbl_entry
argument_list|,
operator|(
name|st_data_t
operator|)
name|p_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsync_high_avail_files
condition|)
block|{
if|if
condition|(
name|fflush
argument_list|(
name|p_file
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fd
operator|=
name|fileno
argument_list|(
name|p_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|fsync
argument_list|(
name|fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 6110: fsync() failed (%s) for %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|p_domain_imp
operator|->
name|file_name
argument_list|)
expr_stmt|;
block|}
else|else
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 6111: "
literal|"fileno() failed for %s\n"
argument_list|,
name|p_domain_imp
operator|->
name|file_name
argument_list|)
expr_stmt|;
block|}
else|else
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 6112: "
literal|"fflush() failed (%s) for %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|p_domain_imp
operator|->
name|file_name
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|p_file
argument_list|)
expr_stmt|;
name|status
operator|=
name|rename
argument_list|(
name|p_tmp_file_name
argument_list|,
name|p_domain_imp
operator|->
name|file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 6108: "
literal|"Failed to rename the db file to:%s (err:%s)\n"
argument_list|,
name|p_domain_imp
operator|->
name|file_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_domain_imp
operator|->
name|dirty
operator|=
name|FALSE
expr_stmt|;
name|Exit
label|:
name|cl_spinlock_release
argument_list|(
operator|&
name|p_domain_imp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_tmp_file_name
argument_list|)
expr_stmt|;
name|Exit2
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* simply de-allocate the key and the value and return the code    that makes the st_foreach delete the entry */
end_comment

begin_function
specifier|static
name|int
name|clear_tbl_entry
parameter_list|(
name|st_data_t
name|key
parameter_list|,
name|st_data_t
name|val
parameter_list|,
name|st_data_t
name|arg
parameter_list|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|key
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|val
argument_list|)
expr_stmt|;
return|return
name|ST_DELETE
return|;
block|}
end_function

begin_function
name|int
name|osm_db_clear
parameter_list|(
name|IN
name|osm_db_domain_t
modifier|*
name|p_domain
parameter_list|)
block|{
name|osm_db_domain_imp_t
modifier|*
name|p_domain_imp
init|=
operator|(
name|osm_db_domain_imp_t
operator|*
operator|)
name|p_domain
operator|->
name|p_domain_imp
decl_stmt|;
name|cl_spinlock_acquire
argument_list|(
operator|&
name|p_domain_imp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|st_foreach
argument_list|(
name|p_domain_imp
operator|->
name|p_hash
argument_list|,
name|clear_tbl_entry
argument_list|,
operator|(
name|st_data_t
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|cl_spinlock_release
argument_list|(
operator|&
name|p_domain_imp
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_key_of_tbl_entry
parameter_list|(
name|st_data_t
name|key
parameter_list|,
name|st_data_t
name|val
parameter_list|,
name|st_data_t
name|arg
parameter_list|)
block|{
name|cl_list_t
modifier|*
name|p_list
init|=
operator|(
name|cl_list_t
operator|*
operator|)
name|arg
decl_stmt|;
name|cl_list_insert_tail
argument_list|(
name|p_list
argument_list|,
operator|(
name|void
operator|*
operator|)
name|key
argument_list|)
expr_stmt|;
return|return
name|ST_CONTINUE
return|;
block|}
end_function

begin_function
name|int
name|osm_db_keys
parameter_list|(
name|IN
name|osm_db_domain_t
modifier|*
name|p_domain
parameter_list|,
name|OUT
name|cl_list_t
modifier|*
name|p_key_list
parameter_list|)
block|{
name|osm_db_domain_imp_t
modifier|*
name|p_domain_imp
init|=
operator|(
name|osm_db_domain_imp_t
operator|*
operator|)
name|p_domain
operator|->
name|p_domain_imp
decl_stmt|;
name|cl_spinlock_acquire
argument_list|(
operator|&
name|p_domain_imp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|st_foreach
argument_list|(
name|p_domain_imp
operator|->
name|p_hash
argument_list|,
name|get_key_of_tbl_entry
argument_list|,
operator|(
name|st_data_t
operator|)
name|p_key_list
argument_list|)
expr_stmt|;
name|cl_spinlock_release
argument_list|(
operator|&
name|p_domain_imp
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|osm_db_lookup
parameter_list|(
name|IN
name|osm_db_domain_t
modifier|*
name|p_domain
parameter_list|,
name|IN
name|char
modifier|*
name|p_key
parameter_list|)
block|{
name|osm_db_domain_imp_t
modifier|*
name|p_domain_imp
init|=
operator|(
name|osm_db_domain_imp_t
operator|*
operator|)
name|p_domain
operator|->
name|p_domain_imp
decl_stmt|;
name|char
modifier|*
name|p_val
init|=
name|NULL
decl_stmt|;
name|cl_spinlock_acquire
argument_list|(
operator|&
name|p_domain_imp
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|st_lookup
argument_list|(
name|p_domain_imp
operator|->
name|p_hash
argument_list|,
operator|(
name|st_data_t
operator|)
name|p_key
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_val
argument_list|)
condition|)
name|p_val
operator|=
name|NULL
expr_stmt|;
name|cl_spinlock_release
argument_list|(
operator|&
name|p_domain_imp
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|p_val
return|;
block|}
end_function

begin_function
name|int
name|osm_db_update
parameter_list|(
name|IN
name|osm_db_domain_t
modifier|*
name|p_domain
parameter_list|,
name|IN
name|char
modifier|*
name|p_key
parameter_list|,
name|IN
name|char
modifier|*
name|p_val
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
name|p_domain
operator|->
name|p_db
operator|->
name|p_log
decl_stmt|;
name|osm_db_domain_imp_t
modifier|*
name|p_domain_imp
init|=
operator|(
name|osm_db_domain_imp_t
operator|*
operator|)
name|p_domain
operator|->
name|p_domain_imp
decl_stmt|;
name|char
modifier|*
name|p_prev_val
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|p_new_key
decl_stmt|;
name|char
modifier|*
name|p_new_val
decl_stmt|;
name|cl_spinlock_acquire
argument_list|(
operator|&
name|p_domain_imp
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|st_lookup
argument_list|(
name|p_domain_imp
operator|->
name|p_hash
argument_list|,
operator|(
name|st_data_t
operator|)
name|p_key
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_prev_val
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Key:%s previously exists in:%s with value:%s\n"
argument_list|,
name|p_key
argument_list|,
name|p_domain_imp
operator|->
name|file_name
argument_list|,
name|p_prev_val
argument_list|)
expr_stmt|;
name|p_new_key
operator|=
name|p_key
expr_stmt|;
comment|/* same key, same value - nothing to update */
if|if
condition|(
name|p_prev_val
operator|&&
operator|!
name|strcmp
argument_list|(
name|p_val
argument_list|,
name|p_prev_val
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
block|}
else|else
block|{
comment|/* need to allocate the key */
name|p_new_key
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
operator|(
name|strlen
argument_list|(
name|p_key
argument_list|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p_new_key
argument_list|,
name|p_key
argument_list|)
expr_stmt|;
block|}
comment|/* need to arange a new copy of the  value */
name|p_new_val
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
operator|(
name|strlen
argument_list|(
name|p_val
argument_list|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p_new_val
argument_list|,
name|p_val
argument_list|)
expr_stmt|;
name|st_insert
argument_list|(
name|p_domain_imp
operator|->
name|p_hash
argument_list|,
operator|(
name|st_data_t
operator|)
name|p_new_key
argument_list|,
operator|(
name|st_data_t
operator|)
name|p_new_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_prev_val
condition|)
name|free
argument_list|(
name|p_prev_val
argument_list|)
expr_stmt|;
name|p_domain_imp
operator|->
name|dirty
operator|=
name|TRUE
expr_stmt|;
name|Exit
label|:
name|cl_spinlock_release
argument_list|(
operator|&
name|p_domain_imp
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|osm_db_delete
parameter_list|(
name|IN
name|osm_db_domain_t
modifier|*
name|p_domain
parameter_list|,
name|IN
name|char
modifier|*
name|p_key
parameter_list|)
block|{
name|osm_log_t
modifier|*
name|p_log
init|=
name|p_domain
operator|->
name|p_db
operator|->
name|p_log
decl_stmt|;
name|osm_db_domain_imp_t
modifier|*
name|p_domain_imp
init|=
operator|(
name|osm_db_domain_imp_t
operator|*
operator|)
name|p_domain
operator|->
name|p_domain_imp
decl_stmt|;
name|char
modifier|*
name|p_prev_val
init|=
name|NULL
decl_stmt|;
name|int
name|res
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|cl_spinlock_acquire
argument_list|(
operator|&
name|p_domain_imp
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|st_delete
argument_list|(
name|p_domain_imp
operator|->
name|p_hash
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_key
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_prev_val
argument_list|)
condition|)
block|{
if|if
condition|(
name|st_lookup
argument_list|(
name|p_domain_imp
operator|->
name|p_hash
argument_list|,
operator|(
name|st_data_t
operator|)
name|p_key
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_prev_val
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"key:%s still exists in:%s with value:%s\n"
argument_list|,
name|p_key
argument_list|,
name|p_domain_imp
operator|->
name|file_name
argument_list|,
name|p_prev_val
argument_list|)
expr_stmt|;
name|res
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|p_key
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_prev_val
argument_list|)
expr_stmt|;
name|p_domain_imp
operator|->
name|dirty
operator|=
name|TRUE
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"fail to find key:%s. delete failed\n"
argument_list|,
name|p_key
argument_list|)
expr_stmt|;
name|res
operator|=
literal|1
expr_stmt|;
block|}
name|cl_spinlock_release
argument_list|(
operator|&
name|p_domain_imp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TEST_OSMDB
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|osm_db_t
name|db
decl_stmt|;
name|osm_log_t
name|log
decl_stmt|;
name|osm_db_domain_t
modifier|*
name|p_dbd
decl_stmt|;
name|cl_list_t
name|keys
decl_stmt|;
name|cl_list_iterator_t
name|kI
decl_stmt|;
name|char
modifier|*
name|p_key
decl_stmt|;
name|char
modifier|*
name|p_val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cl_list_construct
argument_list|(
operator|&
name|keys
argument_list|)
expr_stmt|;
name|cl_list_init
argument_list|(
operator|&
name|keys
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|osm_log_init_v2
argument_list|(
operator|&
name|log
argument_list|,
name|TRUE
argument_list|,
literal|0xff
argument_list|,
literal|"/var/log/osm_db_test.log"
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|osm_db_construct
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_db_init
argument_list|(
operator|&
name|db
argument_list|,
operator|&
name|log
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"db init failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|p_dbd
operator|=
name|osm_db_domain_init
argument_list|(
operator|&
name|db
argument_list|,
literal|"lid_by_guid"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_dbd
condition|)
block|{
name|printf
argument_list|(
literal|"db domain init failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|osm_db_restore
argument_list|(
name|p_dbd
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"failed to restore\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|osm_db_keys
argument_list|(
name|p_dbd
argument_list|,
operator|&
name|keys
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"failed to get keys\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kI
operator|=
name|cl_list_head
argument_list|(
operator|&
name|keys
argument_list|)
expr_stmt|;
while|while
condition|(
name|kI
operator|!=
name|cl_list_end
argument_list|(
operator|&
name|keys
argument_list|)
condition|)
block|{
name|p_key
operator|=
name|cl_list_obj
argument_list|(
name|kI
argument_list|)
expr_stmt|;
name|kI
operator|=
name|cl_list_next
argument_list|(
name|kI
argument_list|)
expr_stmt|;
name|p_val
operator|=
name|osm_db_lookup
argument_list|(
name|p_dbd
argument_list|,
name|p_key
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"key = %s val = %s\n"
argument_list|,
name|p_key
argument_list|,
name|p_val
argument_list|)
expr_stmt|;
block|}
block|}
name|cl_list_remove_all
argument_list|(
operator|&
name|keys
argument_list|)
expr_stmt|;
comment|/* randomly add and remove numbers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|int
name|k
decl_stmt|;
name|float
name|v
decl_stmt|;
name|int
name|is_add
decl_stmt|;
name|char
name|val_buf
index|[
literal|16
index|]
decl_stmt|;
name|char
name|key_buf
index|[
literal|16
index|]
decl_stmt|;
name|k
operator|=
name|floor
argument_list|(
literal|1.0
operator|*
name|rand
argument_list|()
operator|/
name|RAND_MAX
operator|*
literal|100
argument_list|)
expr_stmt|;
name|v
operator|=
name|rand
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|key_buf
argument_list|,
literal|"%u"
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|val_buf
argument_list|,
literal|"%u"
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|is_add
operator|=
operator|(
name|rand
argument_list|()
operator|<
name|RAND_MAX
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|is_add
condition|)
block|{
name|osm_db_update
argument_list|(
name|p_dbd
argument_list|,
name|key_buf
argument_list|,
name|val_buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|osm_db_delete
argument_list|(
name|p_dbd
argument_list|,
name|key_buf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|osm_db_keys
argument_list|(
name|p_dbd
argument_list|,
operator|&
name|keys
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"failed to get keys\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kI
operator|=
name|cl_list_head
argument_list|(
operator|&
name|keys
argument_list|)
expr_stmt|;
while|while
condition|(
name|kI
operator|!=
name|cl_list_end
argument_list|(
operator|&
name|keys
argument_list|)
condition|)
block|{
name|p_key
operator|=
name|cl_list_obj
argument_list|(
name|kI
argument_list|)
expr_stmt|;
name|kI
operator|=
name|cl_list_next
argument_list|(
name|kI
argument_list|)
expr_stmt|;
name|p_val
operator|=
name|osm_db_lookup
argument_list|(
name|p_dbd
argument_list|,
name|p_key
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"key = %s val = %s\n"
argument_list|,
name|p_key
argument_list|,
name|p_val
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|osm_db_store
argument_list|(
name|p_dbd
argument_list|,
name|FALSE
argument_list|)
condition|)
name|printf
argument_list|(
literal|"failed to store\n"
argument_list|)
expr_stmt|;
name|osm_db_destroy
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
name|cl_list_destroy
argument_list|(
operator|&
name|keys
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

