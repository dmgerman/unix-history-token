begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2008 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_lid_mgr_t.  * This file implements the LID Manager object which is responsible for  * assigning LIDs to all ports on the subnet.  *  * DATA STRUCTURES:  *  p_subn->port_lid_tbl : a vector pointing from lid to its port.  *  osm db guid2lid domain : a hash from guid to lid (min lid).  *  p_subn->port_guid_tbl : a map from guid to discovered port obj.  *  * ALGORITHM:  *  * 0. we define a function to obtain the correct port lid:  *    lid_mgr_get_port_lid( p_mgr, port,&min_lid,&max_lid ):  *    0.1 if the port info lid matches the guid2lid return 0  *    0.2 if the port info has a lid and that range is empty in  *        port_lid_tbl, return 0 and update the port_lid_tbl and  *        guid2lid  *    0.3 else find an empty space in port_lid_tbl, update the  *    port_lid_tbl and guid2lid, return 1 to flag a change required.  *  * 1. During initialization:  *   1.1 initialize the guid2lid database domain.  *   1.2 if reassign_lid is not set:  *   1.2.1 read the persistent data for the domain.  *   1.2.2 validate no duplicate use of lids and lids are 2^(lmc-1)  *  * 2. During SM port lid assignment:  *   2.1 if reassign_lids is set, make it 2^lmc  *   2.2 cleanup all port_lid_tbl and re-fill it according to guid2lid  *   2.3 call lid_mgr_get_port_lid for the SM port  *   2.4 set the port info  *  * 3. During all other ports lid assignment:  *   3.1 go through all ports in the subnet  *   3.1.1 call lid_mgr_get_port_lid  *   3.1.2 if a change required send the port info  *   3.2 if any change send the signal PENDING...  *  * 4. Store the guid2lid  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qmap.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_LID_MGR_C
end_define

begin_include
include|#
directive|include
file|<opensm/osm_lid_mgr.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_sm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_node.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_switch.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_msgdef.h>
end_include

begin_include
include|#
directive|include
file|<vendor/osm_vendor_api.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_db_pack.h>
end_include

begin_comment
comment|/**********************************************************************   lid range item of qlist  **********************************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
name|osm_lid_mgr_range
block|{
name|cl_list_item_t
name|item
decl_stmt|;
name|uint16_t
name|min_lid
decl_stmt|;
name|uint16_t
name|max_lid
decl_stmt|;
block|}
name|osm_lid_mgr_range_t
typedef|;
end_typedef

begin_function
name|void
name|osm_lid_mgr_construct
parameter_list|(
name|IN
name|osm_lid_mgr_t
modifier|*
name|p_mgr
parameter_list|)
block|{
name|memset
argument_list|(
name|p_mgr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_mgr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_lid_mgr_destroy
parameter_list|(
name|IN
name|osm_lid_mgr_t
modifier|*
name|p_mgr
parameter_list|)
block|{
name|cl_list_item_t
modifier|*
name|p_item
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p_item
operator|=
name|cl_qlist_remove_head
argument_list|(
operator|&
name|p_mgr
operator|->
name|free_ranges
argument_list|)
operator|)
operator|!=
name|cl_qlist_end
argument_list|(
operator|&
name|p_mgr
operator|->
name|free_ranges
argument_list|)
condition|)
name|free
argument_list|(
operator|(
name|osm_lid_mgr_range_t
operator|*
operator|)
name|p_item
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************************************************************** Validate the guid to lid data by making sure that under the current LMC we did not get duplicates. If we do flag them as errors and remove the entry. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|lid_mgr_validate_db
parameter_list|(
name|IN
name|osm_lid_mgr_t
modifier|*
name|p_mgr
parameter_list|)
block|{
name|cl_qlist_t
name|guids
decl_stmt|;
name|osm_db_guid_elem_t
modifier|*
name|p_item
decl_stmt|;
name|uint16_t
name|lid
decl_stmt|;
name|uint16_t
name|min_lid
decl_stmt|;
name|uint16_t
name|max_lid
decl_stmt|;
name|uint16_t
name|lmc_mask
decl_stmt|;
name|boolean_t
name|lids_ok
decl_stmt|;
name|uint8_t
name|lmc_num_lids
init|=
call|(
name|uint8_t
call|)
argument_list|(
literal|1
operator|<<
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|lmc
argument_list|)
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|lmc_mask
operator|=
operator|~
operator|(
name|lmc_num_lids
operator|-
literal|1
operator|)
expr_stmt|;
name|cl_qlist_init
argument_list|(
operator|&
name|guids
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_db_guid2lid_guids
argument_list|(
name|p_mgr
operator|->
name|p_g2l
argument_list|,
operator|&
name|guids
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0310: "
literal|"could not get guid list\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
while|while
condition|(
operator|(
name|p_item
operator|=
operator|(
name|osm_db_guid_elem_t
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
operator|&
name|guids
argument_list|)
operator|)
operator|!=
operator|(
name|osm_db_guid_elem_t
operator|*
operator|)
name|cl_qlist_end
argument_list|(
operator|&
name|guids
argument_list|)
condition|)
block|{
if|if
condition|(
name|osm_db_guid2lid_get
argument_list|(
name|p_mgr
operator|->
name|p_g2l
argument_list|,
name|p_item
operator|->
name|guid
argument_list|,
operator|&
name|min_lid
argument_list|,
operator|&
name|max_lid
argument_list|)
condition|)
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0311: "
literal|"could not get lid for guid:0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|p_item
operator|->
name|guid
argument_list|)
expr_stmt|;
else|else
block|{
name|lids_ok
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|min_lid
operator|>
name|max_lid
operator|||
name|min_lid
operator|==
literal|0
operator|||
name|p_item
operator|->
name|guid
operator|==
literal|0
operator|||
name|max_lid
operator|>
name|p_mgr
operator|->
name|p_subn
operator|->
name|max_ucast_lid_ho
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0312: "
literal|"Illegal LID range [%u:%u] for "
literal|"guid:0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|min_lid
argument_list|,
name|max_lid
argument_list|,
name|p_item
operator|->
name|guid
argument_list|)
expr_stmt|;
name|lids_ok
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|min_lid
operator|!=
name|max_lid
operator|&&
operator|(
name|min_lid
operator|&
name|lmc_mask
operator|)
operator|!=
name|min_lid
condition|)
block|{
comment|/* check that if the lids define a range that is 				   valid for the current LMC mask */
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0313: "
literal|"LID range [%u:%u] for guid:0x%016"
name|PRIx64
literal|" is not aligned according to mask:0x%04x\n"
argument_list|,
name|min_lid
argument_list|,
name|max_lid
argument_list|,
name|p_item
operator|->
name|guid
argument_list|,
name|lmc_mask
argument_list|)
expr_stmt|;
name|lids_ok
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* check if the lids were not previously assigned */
for|for
control|(
name|lid
operator|=
name|min_lid
init|;
name|lid
operator|<=
name|max_lid
condition|;
name|lid
operator|++
control|)
block|{
if|if
condition|(
name|p_mgr
operator|->
name|used_lids
index|[
name|lid
index|]
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0314: "
literal|"0x%04x for guid:0x%016"
name|PRIx64
literal|" was previously used\n"
argument_list|,
name|lid
argument_list|,
name|p_item
operator|->
name|guid
argument_list|)
expr_stmt|;
name|lids_ok
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|lids_ok
condition|)
comment|/* mark that it was visited */
for|for
control|(
name|lid
operator|=
name|min_lid
init|;
name|lid
operator|<=
name|max_lid
condition|;
name|lid
operator|++
control|)
block|{
if|if
condition|(
name|lid
operator|<
name|min_lid
operator|+
name|lmc_num_lids
condition|)
name|p_mgr
operator|->
name|used_lids
index|[
name|lid
index|]
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osm_db_guid2lid_delete
argument_list|(
name|p_mgr
operator|->
name|p_g2l
argument_list|,
name|p_item
operator|->
name|guid
argument_list|)
condition|)
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0315: failed to delete entry for "
literal|"guid:0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|p_item
operator|->
name|guid
argument_list|)
expr_stmt|;
block|}
comment|/* got a lid */
name|free
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
block|}
comment|/* all guids */
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ib_api_status_t
name|osm_lid_mgr_init
parameter_list|(
name|IN
name|osm_lid_mgr_t
modifier|*
name|p_mgr
parameter_list|,
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|osm_lid_mgr_construct
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
name|p_mgr
operator|->
name|sm
operator|=
name|sm
expr_stmt|;
name|p_mgr
operator|->
name|p_log
operator|=
name|sm
operator|->
name|p_log
expr_stmt|;
name|p_mgr
operator|->
name|p_subn
operator|=
name|sm
operator|->
name|p_subn
expr_stmt|;
name|p_mgr
operator|->
name|p_db
operator|=
name|sm
operator|->
name|p_db
expr_stmt|;
name|p_mgr
operator|->
name|p_lock
operator|=
name|sm
operator|->
name|p_lock
expr_stmt|;
comment|/* we initialize and restore the db domain of guid to lid map */
name|p_mgr
operator|->
name|p_g2l
operator|=
name|osm_db_domain_init
argument_list|(
name|p_mgr
operator|->
name|p_db
argument_list|,
literal|"guid2lid"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_mgr
operator|->
name|p_g2l
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0316: "
literal|"Error initializing Guid-to-Lid persistent database\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|cl_qlist_init
argument_list|(
operator|&
name|p_mgr
operator|->
name|free_ranges
argument_list|)
expr_stmt|;
comment|/* we use the stored guid to lid table if not forced to reassign */
if|if
condition|(
operator|!
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|reassign_lids
condition|)
block|{
if|if
condition|(
name|osm_db_restore
argument_list|(
name|p_mgr
operator|->
name|p_g2l
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|__WIN__
comment|/* 			 * When Windows is BSODing, it might corrupt files that 			 * were previously opened for writing, even if the files 			 * are closed, so we might see corrupted guid2lid file. 			 */
if|if
condition|(
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|exit_on_fatal
condition|)
block|{
name|osm_log_v2
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
name|FILE_ID
argument_list|,
literal|"FATAL: Error restoring Guid-to-Lid "
literal|"persistent database\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
else|else
endif|#
directive|endif
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0317: Error restoring Guid-to-Lid "
literal|"persistent database\n"
argument_list|)
expr_stmt|;
block|}
comment|/* we need to make sure we did not get duplicates with 		   current lmc */
name|lid_mgr_validate_db
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|trim_lid
parameter_list|(
name|IN
name|uint16_t
name|lid
parameter_list|)
block|{
if|if
condition|(
name|lid
operator|>
name|IB_LID_UCAST_END_HO
operator|||
name|lid
operator|<
name|IB_LID_UCAST_START_HO
condition|)
return|return
literal|0
return|;
return|return
name|lid
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  initialize the manager for a new sweep:  scans the known persistent assignment and port_lid_tbl  re-calculate all empty ranges.  cleanup invalid port_lid_tbl entries **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|lid_mgr_init_sweep
parameter_list|(
name|IN
name|osm_lid_mgr_t
modifier|*
name|p_mgr
parameter_list|)
block|{
name|cl_ptr_vector_t
modifier|*
name|p_discovered_vec
init|=
operator|&
name|p_mgr
operator|->
name|p_subn
operator|->
name|port_lid_tbl
decl_stmt|;
name|uint16_t
name|max_defined_lid
decl_stmt|,
name|max_persistent_lid
decl_stmt|,
name|max_discovered_lid
decl_stmt|;
name|uint16_t
name|disc_min_lid
decl_stmt|,
name|disc_max_lid
decl_stmt|,
name|db_min_lid
decl_stmt|,
name|db_max_lid
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|cl_list_item_t
modifier|*
name|p_item
decl_stmt|;
name|boolean_t
name|is_free
decl_stmt|;
name|osm_lid_mgr_range_t
modifier|*
name|p_range
init|=
name|NULL
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|cl_qmap_t
modifier|*
name|p_port_guid_tbl
decl_stmt|;
name|uint8_t
name|lmc_num_lids
init|=
call|(
name|uint8_t
call|)
argument_list|(
literal|1
operator|<<
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|lmc
argument_list|)
decl_stmt|;
name|uint16_t
name|lmc_mask
decl_stmt|,
name|req_lid
decl_stmt|,
name|num_lids
decl_stmt|,
name|lid
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|lmc_mask
operator|=
operator|~
operator|(
operator|(
literal|1
operator|<<
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|lmc
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* We must discard previous guid2lid db if this is the first master 	 * sweep and reassign_lids option is TRUE. 	 * If we came out of standby and honor_guid2lid_file option is TRUE, we 	 * must restore guid2lid db. Otherwise if honor_guid2lid_file option is 	 * FALSE we must discard previous guid2lid db. 	 */
if|if
condition|(
name|p_mgr
operator|->
name|p_subn
operator|->
name|first_time_master_sweep
operator|==
name|TRUE
operator|&&
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|reassign_lids
operator|==
name|TRUE
condition|)
block|{
name|osm_db_clear
argument_list|(
name|p_mgr
operator|->
name|p_g2l
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_mgr
operator|->
name|used_lids
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|p_mgr
operator|->
name|used_lids
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_mgr
operator|->
name|p_subn
operator|->
name|coming_out_of_standby
operator|==
name|TRUE
condition|)
block|{
name|osm_db_clear
argument_list|(
name|p_mgr
operator|->
name|p_g2l
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_mgr
operator|->
name|used_lids
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|p_mgr
operator|->
name|used_lids
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|honor_guid2lid_file
operator|==
name|FALSE
condition|)
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Ignore guid2lid file when coming out of standby\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Honor current guid2lid file when coming out "
literal|"of standby\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_db_restore
argument_list|(
name|p_mgr
operator|->
name|p_g2l
argument_list|)
condition|)
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0306: "
literal|"Error restoring Guid-to-Lid "
literal|"persistent database. Ignoring it\n"
argument_list|)
expr_stmt|;
name|lid_mgr_validate_db
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* we need to cleanup the empty ranges list */
while|while
condition|(
operator|(
name|p_item
operator|=
name|cl_qlist_remove_head
argument_list|(
operator|&
name|p_mgr
operator|->
name|free_ranges
argument_list|)
operator|)
operator|!=
name|cl_qlist_end
argument_list|(
operator|&
name|p_mgr
operator|->
name|free_ranges
argument_list|)
condition|)
name|free
argument_list|(
operator|(
name|osm_lid_mgr_range_t
operator|*
operator|)
name|p_item
argument_list|)
expr_stmt|;
comment|/* first clean up the port_by_lid_tbl */
for|for
control|(
name|lid
operator|=
literal|0
init|;
name|lid
operator|<
name|cl_ptr_vector_get_size
argument_list|(
name|p_discovered_vec
argument_list|)
condition|;
name|lid
operator|++
control|)
name|cl_ptr_vector_set
argument_list|(
name|p_discovered_vec
argument_list|,
name|lid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* we if are in the first sweep and in reassign lids mode 	   we should ignore all the available info and simply define one 	   huge empty range */
if|if
condition|(
name|p_mgr
operator|->
name|p_subn
operator|->
name|first_time_master_sweep
operator|==
name|TRUE
operator|&&
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|reassign_lids
operator|==
name|TRUE
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Skipping all lids as we are reassigning them\n"
argument_list|)
expr_stmt|;
name|p_range
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|osm_lid_mgr_range_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_range
condition|)
name|p_range
operator|->
name|min_lid
operator|=
literal|1
expr_stmt|;
goto|goto
name|AfterScanningLids
goto|;
block|}
comment|/* go over all discovered ports and mark their entries */
name|p_port_guid_tbl
operator|=
operator|&
name|p_mgr
operator|->
name|p_subn
operator|->
name|port_guid_tbl
expr_stmt|;
for|for
control|(
name|p_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_port_guid_tbl
argument_list|)
init|;
name|p_port
operator|!=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_port_guid_tbl
argument_list|)
condition|;
name|p_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_port
operator|->
name|map_item
argument_list|)
control|)
block|{
name|osm_port_get_lid_range_ho
argument_list|(
name|p_port
argument_list|,
operator|&
name|disc_min_lid
argument_list|,
operator|&
name|disc_max_lid
argument_list|)
expr_stmt|;
name|disc_min_lid
operator|=
name|trim_lid
argument_list|(
name|disc_min_lid
argument_list|)
expr_stmt|;
name|disc_max_lid
operator|=
name|trim_lid
argument_list|(
name|disc_max_lid
argument_list|)
expr_stmt|;
for|for
control|(
name|lid
operator|=
name|disc_min_lid
init|;
name|lid
operator|<=
name|disc_max_lid
condition|;
name|lid
operator|++
control|)
block|{
if|if
condition|(
name|lid
operator|<
name|disc_min_lid
operator|+
name|lmc_num_lids
condition|)
name|cl_ptr_vector_set
argument_list|(
name|p_discovered_vec
argument_list|,
name|lid
argument_list|,
name|p_port
argument_list|)
expr_stmt|;
else|else
name|cl_ptr_vector_set
argument_list|(
name|p_discovered_vec
argument_list|,
name|lid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* make sure the guid2lid entry is valid. If not, clean it. */
if|if
condition|(
name|osm_db_guid2lid_get
argument_list|(
name|p_mgr
operator|->
name|p_g2l
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_port_get_guid
argument_list|(
name|p_port
argument_list|)
argument_list|)
argument_list|,
operator|&
name|db_min_lid
argument_list|,
operator|&
name|db_max_lid
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|p_port
operator|->
name|p_node
operator|->
name|sw
operator|||
name|osm_switch_sp0_is_lmc_capable
argument_list|(
name|p_port
operator|->
name|p_node
operator|->
name|sw
argument_list|,
name|p_mgr
operator|->
name|p_subn
argument_list|)
condition|)
name|num_lids
operator|=
name|lmc_num_lids
expr_stmt|;
else|else
name|num_lids
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|num_lids
operator|!=
literal|1
operator|&&
operator|(
operator|(
name|db_min_lid
operator|&
name|lmc_mask
operator|)
operator|!=
name|db_min_lid
operator|||
name|db_max_lid
operator|-
name|db_min_lid
operator|+
literal|1
operator|<
name|num_lids
operator|)
condition|)
block|{
comment|/* Not aligned, or not wide enough, then remove the entry */
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Cleaning persistent entry for guid:"
literal|"0x%016"
name|PRIx64
literal|" illegal range:[0x%x:0x%x]\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_port_get_guid
argument_list|(
name|p_port
argument_list|)
argument_list|)
argument_list|,
name|db_min_lid
argument_list|,
name|db_max_lid
argument_list|)
expr_stmt|;
name|osm_db_guid2lid_delete
argument_list|(
name|p_mgr
operator|->
name|p_g2l
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_port_get_guid
argument_list|(
name|p_port
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|lid
operator|=
name|db_min_lid
init|;
name|lid
operator|<=
name|db_max_lid
condition|;
name|lid
operator|++
control|)
name|p_mgr
operator|->
name|used_lids
index|[
name|lid
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	   Our task is to find free lid ranges. 	   A lid can be used if 	   1. a persistent assignment exists 	   2. the lid is used by a discovered port that does not have a 	   persistent assignment.  	   scan through all lid values of both the persistent table and 	   discovered table. 	   If the lid has an assigned port in the discovered table: 	   * make sure the lid matches the persistent table, or 	   * there is no other persistent assignment for that lid. 	   * else cleanup the port_by_lid_tbl, mark this as empty range. 	   Else if the lid does not have an entry in the persistent table 	   mark it as free. 	 */
comment|/* find the range of lids to scan */
name|max_discovered_lid
operator|=
operator|(
name|uint16_t
operator|)
name|cl_ptr_vector_get_size
argument_list|(
name|p_discovered_vec
argument_list|)
expr_stmt|;
name|max_persistent_lid
operator|=
sizeof|sizeof
argument_list|(
name|p_mgr
operator|->
name|used_lids
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* but the vectors have one extra entry for lid=0 */
if|if
condition|(
name|max_discovered_lid
condition|)
name|max_discovered_lid
operator|--
expr_stmt|;
if|if
condition|(
name|max_persistent_lid
operator|>
name|max_discovered_lid
condition|)
name|max_defined_lid
operator|=
name|max_persistent_lid
expr_stmt|;
else|else
name|max_defined_lid
operator|=
name|max_discovered_lid
expr_stmt|;
for|for
control|(
name|lid
operator|=
literal|1
init|;
name|lid
operator|<=
name|max_defined_lid
condition|;
name|lid
operator|++
control|)
block|{
name|is_free
operator|=
name|TRUE
expr_stmt|;
comment|/* first check to see if the lid is used by a persistent assignment */
if|if
condition|(
name|lid
operator|<=
name|max_persistent_lid
operator|&&
name|p_mgr
operator|->
name|used_lids
index|[
name|lid
index|]
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"0x%04x is not free as its mapped by the "
literal|"persistent db\n"
argument_list|,
name|lid
argument_list|)
expr_stmt|;
name|is_free
operator|=
name|FALSE
expr_stmt|;
comment|/* check this is a discovered port */
block|}
elseif|else
if|if
condition|(
name|lid
operator|<=
name|max_discovered_lid
operator|&&
operator|(
name|p_port
operator|=
name|cl_ptr_vector_get
argument_list|(
name|p_discovered_vec
argument_list|,
name|lid
argument_list|)
operator|)
condition|)
block|{
comment|/* we have a port. Now lets see if we can preserve its lid range. */
comment|/* For that, we need to make sure: 			   1. The port has a (legal) persistency entry. Then the 			   local lid is free (we will use the persistency value). 			   2. Can the port keep its local assignment? 			   a. Make sure the lid is aligned. 			   b. Make sure all needed lids (for the lmc) are free 			   according to persistency table. 			 */
comment|/* qualify the guid of the port is not persistently 			   mapped to another range */
if|if
condition|(
operator|!
name|osm_db_guid2lid_get
argument_list|(
name|p_mgr
operator|->
name|p_g2l
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_port_get_guid
argument_list|(
name|p_port
argument_list|)
argument_list|)
argument_list|,
operator|&
name|db_min_lid
argument_list|,
operator|&
name|db_max_lid
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"0x%04x is free as it was "
literal|"discovered but mapped by the "
literal|"persistent db to [0x%04x:0x%04x]\n"
argument_list|,
name|lid
argument_list|,
name|db_min_lid
argument_list|,
name|db_max_lid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* can the port keep its assignment ? */
comment|/* get the lid range of that port, and the 				   required number of lids we are about to 				   assign to it */
name|osm_port_get_lid_range_ho
argument_list|(
name|p_port
argument_list|,
operator|&
name|disc_min_lid
argument_list|,
operator|&
name|disc_max_lid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
operator|->
name|p_node
operator|->
name|sw
operator|||
name|osm_switch_sp0_is_lmc_capable
argument_list|(
name|p_port
operator|->
name|p_node
operator|->
name|sw
argument_list|,
name|p_mgr
operator|->
name|p_subn
argument_list|)
condition|)
block|{
name|disc_max_lid
operator|=
name|disc_min_lid
operator|+
name|lmc_num_lids
operator|-
literal|1
expr_stmt|;
name|num_lids
operator|=
name|lmc_num_lids
expr_stmt|;
block|}
else|else
name|num_lids
operator|=
literal|1
expr_stmt|;
comment|/* Make sure the lid is aligned */
if|if
condition|(
name|num_lids
operator|!=
literal|1
operator|&&
operator|(
name|disc_min_lid
operator|&
name|lmc_mask
operator|)
operator|!=
name|disc_min_lid
condition|)
block|{
comment|/* The lid cannot be used */
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"0x%04x is free as it was "
literal|"discovered but not aligned\n"
argument_list|,
name|lid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* check that all needed lids are not persistently mapped */
name|is_free
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|req_lid
operator|=
name|disc_min_lid
operator|+
literal|1
init|;
name|req_lid
operator|<=
name|disc_max_lid
condition|;
name|req_lid
operator|++
control|)
block|{
if|if
condition|(
name|req_lid
operator|<=
name|max_persistent_lid
operator|&&
name|p_mgr
operator|->
name|used_lids
index|[
name|req_lid
index|]
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"0x%04x is free as it was discovered "
literal|"but mapped\n"
argument_list|,
name|lid
argument_list|)
expr_stmt|;
name|is_free
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|is_free
operator|==
name|FALSE
condition|)
block|{
comment|/* This port will use its local lid, and consume the entire required lid range. 						   Thus we can skip that range. */
comment|/* If the disc_max_lid is greater then lid, we can skip right to it, 						   since we've done all neccessary checks on the lids in between. */
if|if
condition|(
name|disc_max_lid
operator|>
name|lid
condition|)
name|lid
operator|=
name|disc_max_lid
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|is_free
condition|)
block|{
if|if
condition|(
name|p_range
condition|)
name|p_range
operator|->
name|max_lid
operator|=
name|lid
expr_stmt|;
else|else
block|{
name|p_range
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|osm_lid_mgr_range_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_range
condition|)
block|{
name|p_range
operator|->
name|min_lid
operator|=
name|lid
expr_stmt|;
name|p_range
operator|->
name|max_lid
operator|=
name|lid
expr_stmt|;
block|}
block|}
comment|/* this lid is used so we need to finalize the previous free range */
block|}
elseif|else
if|if
condition|(
name|p_range
condition|)
block|{
name|cl_qlist_insert_tail
argument_list|(
operator|&
name|p_mgr
operator|->
name|free_ranges
argument_list|,
operator|&
name|p_range
operator|->
name|item
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"new free lid range [%u:%u]\n"
argument_list|,
name|p_range
operator|->
name|min_lid
argument_list|,
name|p_range
operator|->
name|max_lid
argument_list|)
expr_stmt|;
name|p_range
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|AfterScanningLids
label|:
comment|/* after scanning all known lids we need to extend the last range 	   to the max allowed lid */
if|if
condition|(
operator|!
name|p_range
condition|)
block|{
name|p_range
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|osm_lid_mgr_range_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		   The p_range can be NULL in one of 2 cases: 		   1. If max_defined_lid == 0. In this case, we want the 		   entire range. 		   2. If all lids discovered in the loop where mapped. In this 		   case, no free range exists and we want to define it after the 		   last mapped lid. 		 */
if|if
condition|(
name|p_range
condition|)
name|p_range
operator|->
name|min_lid
operator|=
name|lid
expr_stmt|;
block|}
if|if
condition|(
name|p_range
condition|)
block|{
name|p_range
operator|->
name|max_lid
operator|=
name|p_mgr
operator|->
name|p_subn
operator|->
name|max_ucast_lid_ho
expr_stmt|;
name|cl_qlist_insert_tail
argument_list|(
operator|&
name|p_mgr
operator|->
name|free_ranges
argument_list|,
operator|&
name|p_range
operator|->
name|item
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"final free lid range [%u:%u]\n"
argument_list|,
name|p_range
operator|->
name|min_lid
argument_list|,
name|p_range
operator|->
name|max_lid
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  check if the given range of lids is free **********************************************************************/
end_comment

begin_function
specifier|static
name|boolean_t
name|lid_mgr_is_range_not_persistent
parameter_list|(
name|IN
name|osm_lid_mgr_t
modifier|*
name|p_mgr
parameter_list|,
name|IN
name|uint16_t
name|lid
parameter_list|,
name|IN
name|uint16_t
name|num_lids
parameter_list|)
block|{
name|uint16_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|lid
init|;
name|i
operator|<
name|lid
operator|+
name|num_lids
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p_mgr
operator|->
name|used_lids
index|[
name|i
index|]
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/********************************************************************** find a free lid range **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|lid_mgr_find_free_lid_range
parameter_list|(
name|IN
name|osm_lid_mgr_t
modifier|*
name|p_mgr
parameter_list|,
name|IN
name|uint8_t
name|num_lids
parameter_list|,
name|OUT
name|uint16_t
modifier|*
name|p_min_lid
parameter_list|,
name|OUT
name|uint16_t
modifier|*
name|p_max_lid
parameter_list|)
block|{
name|uint16_t
name|lid
decl_stmt|;
name|cl_list_item_t
modifier|*
name|p_item
decl_stmt|;
name|cl_list_item_t
modifier|*
name|p_next_item
decl_stmt|;
name|osm_lid_mgr_range_t
modifier|*
name|p_range
init|=
name|NULL
decl_stmt|;
name|uint8_t
name|lmc_num_lids
decl_stmt|;
name|uint16_t
name|lmc_mask
decl_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"LMC = %u, number LIDs = %u\n"
argument_list|,
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|lmc
argument_list|,
name|num_lids
argument_list|)
expr_stmt|;
name|lmc_num_lids
operator|=
operator|(
literal|1
operator|<<
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|lmc
operator|)
expr_stmt|;
name|lmc_mask
operator|=
operator|~
operator|(
operator|(
literal|1
operator|<<
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|lmc
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* 	   Search the list of free lid ranges for a range which is big enough 	 */
name|p_item
operator|=
name|cl_qlist_head
argument_list|(
operator|&
name|p_mgr
operator|->
name|free_ranges
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_item
operator|!=
name|cl_qlist_end
argument_list|(
operator|&
name|p_mgr
operator|->
name|free_ranges
argument_list|)
condition|)
block|{
name|p_next_item
operator|=
name|cl_qlist_next
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
name|p_range
operator|=
operator|(
name|osm_lid_mgr_range_t
operator|*
operator|)
name|p_item
expr_stmt|;
name|lid
operator|=
name|p_range
operator|->
name|min_lid
expr_stmt|;
comment|/* if we require more then one lid we must align to LMC */
if|if
condition|(
name|num_lids
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|lid
operator|&
name|lmc_mask
operator|)
operator|!=
name|lid
condition|)
name|lid
operator|=
operator|(
name|lid
operator|+
name|lmc_num_lids
operator|)
operator|&
name|lmc_mask
expr_stmt|;
block|}
comment|/* but we can be out of the range */
if|if
condition|(
name|lid
operator|+
name|num_lids
operator|-
literal|1
operator|<=
name|p_range
operator|->
name|max_lid
condition|)
block|{
comment|/* ok let us use that range */
if|if
condition|(
name|lid
operator|+
name|num_lids
operator|-
literal|1
operator|==
name|p_range
operator|->
name|max_lid
condition|)
block|{
comment|/* we consumed the entire range */
name|cl_qlist_remove_item
argument_list|(
operator|&
name|p_mgr
operator|->
name|free_ranges
argument_list|,
name|p_item
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* only update the available range */
name|p_range
operator|->
name|min_lid
operator|=
name|lid
operator|+
name|num_lids
expr_stmt|;
operator|*
name|p_min_lid
operator|=
name|lid
expr_stmt|;
operator|*
name|p_max_lid
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|lid
operator|+
name|num_lids
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|p_item
operator|=
name|p_next_item
expr_stmt|;
block|}
comment|/* 	   Couldn't find a free range of lids. 	 */
operator|*
name|p_min_lid
operator|=
operator|*
name|p_max_lid
operator|=
literal|0
expr_stmt|;
comment|/* if we run out of lids, give an error and abort! */
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0307: "
literal|"OPENSM RAN OUT OF LIDS!!!\n"
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lid_mgr_cleanup_discovered_port_lid_range
parameter_list|(
name|IN
name|osm_lid_mgr_t
modifier|*
name|p_mgr
parameter_list|,
name|IN
name|osm_port_t
modifier|*
name|p_port
parameter_list|)
block|{
name|cl_ptr_vector_t
modifier|*
name|p_discovered_vec
init|=
operator|&
name|p_mgr
operator|->
name|p_subn
operator|->
name|port_lid_tbl
decl_stmt|;
name|uint16_t
name|lid
decl_stmt|,
name|min_lid
decl_stmt|,
name|max_lid
decl_stmt|;
name|uint16_t
name|max_tbl_lid
init|=
call|(
name|uint16_t
call|)
argument_list|(
name|cl_ptr_vector_get_size
argument_list|(
name|p_discovered_vec
argument_list|)
argument_list|)
decl_stmt|;
name|osm_port_get_lid_range_ho
argument_list|(
name|p_port
argument_list|,
operator|&
name|min_lid
argument_list|,
operator|&
name|max_lid
argument_list|)
expr_stmt|;
name|min_lid
operator|=
name|trim_lid
argument_list|(
name|min_lid
argument_list|)
expr_stmt|;
name|max_lid
operator|=
name|trim_lid
argument_list|(
name|max_lid
argument_list|)
expr_stmt|;
for|for
control|(
name|lid
operator|=
name|min_lid
init|;
name|lid
operator|<=
name|max_lid
condition|;
name|lid
operator|++
control|)
if|if
condition|(
name|lid
operator|<
name|max_tbl_lid
operator|&&
name|p_port
operator|==
name|cl_ptr_vector_get
argument_list|(
name|p_discovered_vec
argument_list|,
name|lid
argument_list|)
condition|)
name|cl_ptr_vector_set
argument_list|(
name|p_discovered_vec
argument_list|,
name|lid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  0.1 if the port info lid matches the guid2lid return 0  0.2 if the port info has a lid and that range is empty in      port_lid_tbl, return 0 and update the port_lid_tbl and      guid2lid  0.3 else find an empty space in port_lid_tbl, update the  port_lid_tbl and guid2lid, return 1 to flag a change required. **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|lid_mgr_get_port_lid
parameter_list|(
name|IN
name|osm_lid_mgr_t
modifier|*
name|p_mgr
parameter_list|,
name|IN
name|osm_port_t
modifier|*
name|p_port
parameter_list|,
name|OUT
name|uint16_t
modifier|*
name|p_min_lid
parameter_list|,
name|OUT
name|uint16_t
modifier|*
name|p_max_lid
parameter_list|)
block|{
name|uint16_t
name|lid
decl_stmt|,
name|min_lid
decl_stmt|,
name|max_lid
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|uint8_t
name|num_lids
init|=
operator|(
literal|1
operator|<<
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|lmc
operator|)
decl_stmt|;
name|int
name|lid_changed
init|=
literal|0
decl_stmt|;
name|uint16_t
name|lmc_mask
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* get the lid from the guid2lid */
name|guid
operator|=
name|cl_ntoh64
argument_list|(
name|osm_port_get_guid
argument_list|(
name|p_port
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if the port is a base switch port 0 then we only need one lid */
if|if
condition|(
name|p_port
operator|->
name|p_node
operator|->
name|sw
operator|&&
operator|!
name|osm_switch_sp0_is_lmc_capable
argument_list|(
name|p_port
operator|->
name|p_node
operator|->
name|sw
argument_list|,
name|p_mgr
operator|->
name|p_subn
argument_list|)
condition|)
name|num_lids
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p_mgr
operator|->
name|p_subn
operator|->
name|first_time_master_sweep
operator|==
name|TRUE
operator|&&
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|reassign_lids
operator|==
name|TRUE
condition|)
goto|goto
name|AssignLid
goto|;
name|lmc_mask
operator|=
operator|~
operator|(
name|num_lids
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* if the port matches the guid2lid */
if|if
condition|(
operator|!
name|osm_db_guid2lid_get
argument_list|(
name|p_mgr
operator|->
name|p_g2l
argument_list|,
name|guid
argument_list|,
operator|&
name|min_lid
argument_list|,
operator|&
name|max_lid
argument_list|)
condition|)
block|{
operator|*
name|p_min_lid
operator|=
name|min_lid
expr_stmt|;
operator|*
name|p_max_lid
operator|=
name|min_lid
operator|+
name|num_lids
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|min_lid
operator|==
name|cl_ntoh16
argument_list|(
name|osm_port_get_base_lid
argument_list|(
name|p_port
argument_list|)
argument_list|)
condition|)
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"0x%016"
name|PRIx64
literal|" matches its known lid:%u\n"
argument_list|,
name|guid
argument_list|,
name|min_lid
argument_list|)
expr_stmt|;
else|else
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"0x%016"
name|PRIx64
literal|" with lid:%u "
literal|"does not match its known lid:%u\n"
argument_list|,
name|guid
argument_list|,
name|cl_ntoh16
argument_list|(
name|osm_port_get_base_lid
argument_list|(
name|p_port
argument_list|)
argument_list|)
argument_list|,
name|min_lid
argument_list|)
expr_stmt|;
name|lid_mgr_cleanup_discovered_port_lid_range
argument_list|(
name|p_mgr
argument_list|,
name|p_port
argument_list|)
expr_stmt|;
comment|/* we still need to send the setting to the target port */
name|lid_changed
operator|=
literal|1
expr_stmt|;
block|}
goto|goto
name|NewLidSet
goto|;
block|}
else|else
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"0x%016"
name|PRIx64
literal|" has no persistent lid assigned\n"
argument_list|,
name|guid
argument_list|)
expr_stmt|;
comment|/* if the port info carries a lid it must be lmc aligned and not mapped 	   by the persistent storage  */
name|min_lid
operator|=
name|cl_ntoh16
argument_list|(
name|osm_port_get_base_lid
argument_list|(
name|p_port
argument_list|)
argument_list|)
expr_stmt|;
comment|/* we want to ignore the discovered lid if we are also on first sweep of 	   reassign lids flow */
if|if
condition|(
name|min_lid
condition|)
block|{
comment|/* make sure lid is valid */
if|if
condition|(
operator|(
name|min_lid
operator|&
name|lmc_mask
operator|)
operator|==
name|min_lid
condition|)
block|{
comment|/* is it free */
if|if
condition|(
name|lid_mgr_is_range_not_persistent
argument_list|(
name|p_mgr
argument_list|,
name|min_lid
argument_list|,
name|num_lids
argument_list|)
condition|)
block|{
operator|*
name|p_min_lid
operator|=
name|min_lid
expr_stmt|;
operator|*
name|p_max_lid
operator|=
name|min_lid
operator|+
name|num_lids
operator|-
literal|1
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"0x%016"
name|PRIx64
literal|" lid range:[%u-%u] is free\n"
argument_list|,
name|guid
argument_list|,
operator|*
name|p_min_lid
argument_list|,
operator|*
name|p_max_lid
argument_list|)
expr_stmt|;
goto|goto
name|NewLidSet
goto|;
block|}
else|else
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"0x%016"
name|PRIx64
literal|" existing lid "
literal|"range:[%u:%u] is not free\n"
argument_list|,
name|guid
argument_list|,
name|min_lid
argument_list|,
name|min_lid
operator|+
name|num_lids
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"0x%016"
name|PRIx64
literal|" existing lid range:"
literal|"[%u:%u] is not lmc aligned\n"
argument_list|,
name|guid
argument_list|,
name|min_lid
argument_list|,
name|min_lid
operator|+
name|num_lids
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|AssignLid
label|:
comment|/* first cleanup the existing discovered lid range */
name|lid_mgr_cleanup_discovered_port_lid_range
argument_list|(
name|p_mgr
argument_list|,
name|p_port
argument_list|)
expr_stmt|;
comment|/* find an empty space */
name|lid_mgr_find_free_lid_range
argument_list|(
name|p_mgr
argument_list|,
name|num_lids
argument_list|,
name|p_min_lid
argument_list|,
name|p_max_lid
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"0x%016"
name|PRIx64
literal|" assigned a new lid range:[%u-%u]\n"
argument_list|,
name|guid
argument_list|,
operator|*
name|p_min_lid
argument_list|,
operator|*
name|p_max_lid
argument_list|)
expr_stmt|;
name|lid_changed
operator|=
literal|1
expr_stmt|;
name|NewLidSet
label|:
comment|/* update the guid2lid db and used_lids */
name|osm_db_guid2lid_set
argument_list|(
name|p_mgr
operator|->
name|p_g2l
argument_list|,
name|guid
argument_list|,
operator|*
name|p_min_lid
argument_list|,
operator|*
name|p_max_lid
argument_list|)
expr_stmt|;
for|for
control|(
name|lid
operator|=
operator|*
name|p_min_lid
init|;
name|lid
operator|<=
operator|*
name|p_max_lid
condition|;
name|lid
operator|++
control|)
name|p_mgr
operator|->
name|used_lids
index|[
name|lid
index|]
operator|=
literal|1
expr_stmt|;
comment|/* make sure the assigned lids are marked in port_lid_tbl */
for|for
control|(
name|lid
operator|=
operator|*
name|p_min_lid
init|;
name|lid
operator|<=
operator|*
name|p_max_lid
condition|;
name|lid
operator|++
control|)
name|cl_ptr_vector_set
argument_list|(
operator|&
name|p_mgr
operator|->
name|p_subn
operator|->
name|port_lid_tbl
argument_list|,
name|lid
argument_list|,
name|p_port
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|lid_changed
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Set to INIT the remote port of the given physical port  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|lid_mgr_set_remote_pi_state_to_init
parameter_list|(
name|IN
name|osm_lid_mgr_t
modifier|*
name|p_mgr
parameter_list|,
name|IN
name|osm_physp_t
modifier|*
name|p_physp
parameter_list|)
block|{
name|osm_physp_t
modifier|*
name|p_rem_physp
init|=
name|osm_physp_get_remote
argument_list|(
name|p_physp
argument_list|)
decl_stmt|;
if|if
condition|(
name|p_rem_physp
operator|==
name|NULL
condition|)
return|return;
comment|/* but in some rare cases the remote side might be non responsive */
name|ib_port_info_set_port_state
argument_list|(
operator|&
name|p_rem_physp
operator|->
name|port_info
argument_list|,
name|IB_LINK_INIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lid_mgr_set_physp_pi
parameter_list|(
name|IN
name|osm_lid_mgr_t
modifier|*
name|p_mgr
parameter_list|,
name|IN
name|osm_port_t
modifier|*
name|p_port
parameter_list|,
name|IN
name|osm_physp_t
modifier|*
name|p_physp
parameter_list|,
name|IN
name|ib_net16_t
name|lid
parameter_list|)
block|{
name|uint8_t
name|payload
index|[
name|IB_SMP_DATA_SIZE
index|]
decl_stmt|;
name|ib_port_info_t
modifier|*
name|p_pi
init|=
operator|(
name|ib_port_info_t
operator|*
operator|)
name|payload
decl_stmt|;
specifier|const
name|ib_port_info_t
modifier|*
name|p_old_pi
decl_stmt|;
name|osm_madw_context_t
name|context
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|uint8_t
name|mtu
decl_stmt|;
name|uint8_t
name|op_vls
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|boolean_t
name|send_set
init|=
name|FALSE
decl_stmt|;
name|boolean_t
name|send_client_rereg
init|=
name|FALSE
decl_stmt|;
name|boolean_t
name|update_mkey
init|=
name|FALSE
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	   Don't bother doing anything if this Physical Port is not valid. 	   This allows simplified code in the caller. 	 */
if|if
condition|(
operator|!
name|p_physp
condition|)
goto|goto
name|Exit
goto|;
name|port_num
operator|=
name|osm_physp_get_port_num
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|p_node
operator|=
name|osm_physp_get_node_ptr
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|p_node
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
operator|&&
name|port_num
operator|!=
literal|0
condition|)
block|{
comment|/* 		   Switch ports that are not numbered 0 should not be set 		   with the following attributes as they are set later 		   (during NO_CHANGE state in link mgr). 		 */
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Skipping switch port %u, GUID 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|port_num
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_physp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_old_pi
operator|=
operator|&
name|p_physp
operator|->
name|port_info
expr_stmt|;
comment|/* 	   First, copy existing parameters from the PortInfo attribute we 	   already have for this node.  	   Second, update with default values that we know must be set for 	   every Physical Port and the LID and set the neighbor MTU field 	   appropriately.  	   Third, send the SMP to this physical port. 	 */
name|memcpy
argument_list|(
name|payload
argument_list|,
name|p_old_pi
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_port_info_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	   Should never write back a value that is bigger then 3 in 	   the PortPhysicalState field, so cannot simply copy!  	   Actually we want to write there: 	   port physical state - no change 	   link down default state = polling 	   port state - no change 	 */
name|p_pi
operator|->
name|state_info2
operator|=
literal|0x02
expr_stmt|;
name|ib_port_info_set_port_state
argument_list|(
name|p_pi
argument_list|,
name|IB_LINK_NO_CHANGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_port_info_get_link_down_def_state
argument_list|(
name|p_pi
argument_list|)
operator|!=
name|ib_port_info_get_link_down_def_state
argument_list|(
name|p_old_pi
argument_list|)
condition|)
name|send_set
operator|=
name|TRUE
expr_stmt|;
comment|/* didn't get PortInfo before */
if|if
condition|(
operator|!
name|ib_port_info_get_port_state
argument_list|(
name|p_old_pi
argument_list|)
condition|)
name|send_set
operator|=
name|TRUE
expr_stmt|;
name|p_pi
operator|->
name|m_key
operator|=
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|m_key
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|p_pi
operator|->
name|m_key
argument_list|,
operator|&
name|p_old_pi
operator|->
name|m_key
argument_list|,
sizeof|sizeof
argument_list|(
name|p_pi
operator|->
name|m_key
argument_list|)
argument_list|)
condition|)
block|{
name|update_mkey
operator|=
name|TRUE
expr_stmt|;
name|send_set
operator|=
name|TRUE
expr_stmt|;
block|}
name|p_pi
operator|->
name|subnet_prefix
operator|=
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|subnet_prefix
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|p_pi
operator|->
name|subnet_prefix
argument_list|,
operator|&
name|p_old_pi
operator|->
name|subnet_prefix
argument_list|,
sizeof|sizeof
argument_list|(
name|p_pi
operator|->
name|subnet_prefix
argument_list|)
argument_list|)
condition|)
name|send_set
operator|=
name|TRUE
expr_stmt|;
name|p_port
operator|->
name|lid
operator|=
name|lid
expr_stmt|;
name|p_pi
operator|->
name|base_lid
operator|=
name|lid
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|p_pi
operator|->
name|base_lid
argument_list|,
operator|&
name|p_old_pi
operator|->
name|base_lid
argument_list|,
sizeof|sizeof
argument_list|(
name|p_pi
operator|->
name|base_lid
argument_list|)
argument_list|)
condition|)
block|{
comment|/* 		 * Reset stored base_lid. 		 * On successful send, we'll update it when we'll get a reply. 		 */
name|osm_physp_set_base_lid
argument_list|(
name|p_physp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_set
operator|=
name|TRUE
expr_stmt|;
name|p_mgr
operator|->
name|dirty
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* 	   We are updating the ports with our local sm_base_lid 	   if for some reason currently received SM LID is different from our SM LID, 	   need to send client reregister to this port 	*/
name|p_pi
operator|->
name|master_sm_base_lid
operator|=
name|p_mgr
operator|->
name|p_subn
operator|->
name|sm_base_lid
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|p_pi
operator|->
name|master_sm_base_lid
argument_list|,
operator|&
name|p_old_pi
operator|->
name|master_sm_base_lid
argument_list|,
sizeof|sizeof
argument_list|(
name|p_pi
operator|->
name|master_sm_base_lid
argument_list|)
argument_list|)
condition|)
block|{
name|send_client_rereg
operator|=
name|TRUE
expr_stmt|;
name|send_set
operator|=
name|TRUE
expr_stmt|;
block|}
name|p_pi
operator|->
name|m_key_lease_period
operator|=
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|m_key_lease_period
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|p_pi
operator|->
name|m_key_lease_period
argument_list|,
operator|&
name|p_old_pi
operator|->
name|m_key_lease_period
argument_list|,
sizeof|sizeof
argument_list|(
name|p_pi
operator|->
name|m_key_lease_period
argument_list|)
argument_list|)
condition|)
name|send_set
operator|=
name|TRUE
expr_stmt|;
name|p_pi
operator|->
name|mkey_lmc
operator|=
literal|0
expr_stmt|;
name|ib_port_info_set_mpb
argument_list|(
name|p_pi
argument_list|,
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|m_key_protect_bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_port_info_get_mpb
argument_list|(
name|p_pi
argument_list|)
operator|!=
name|ib_port_info_get_mpb
argument_list|(
name|p_old_pi
argument_list|)
condition|)
name|send_set
operator|=
name|TRUE
expr_stmt|;
comment|/* 	   we want to set the timeout for both the switch port 0 	   and the CA ports 	 */
name|ib_port_info_set_timeout
argument_list|(
name|p_pi
argument_list|,
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|subnet_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_port_info_get_timeout
argument_list|(
name|p_pi
argument_list|)
operator|!=
name|ib_port_info_get_timeout
argument_list|(
name|p_old_pi
argument_list|)
condition|)
name|send_set
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|port_num
operator|!=
literal|0
condition|)
block|{
comment|/* 		   CAs don't have a port 0, and for switch port 0, 		   the state bits are ignored. 		   This is not the switch management port 		 */
name|p_pi
operator|->
name|link_width_enabled
operator|=
name|p_old_pi
operator|->
name|link_width_supported
expr_stmt|;
if|if
condition|(
name|p_pi
operator|->
name|link_width_enabled
operator|!=
name|p_old_pi
operator|->
name|link_width_enabled
condition|)
name|send_set
operator|=
name|TRUE
expr_stmt|;
comment|/* p_pi->mkey_lmc is initialized earlier */
name|ib_port_info_set_lmc
argument_list|(
name|p_pi
argument_list|,
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|lmc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_port_info_get_lmc
argument_list|(
name|p_pi
argument_list|)
operator|!=
name|ib_port_info_get_lmc
argument_list|(
name|p_old_pi
argument_list|)
condition|)
name|send_set
operator|=
name|TRUE
expr_stmt|;
comment|/* calc new op_vls and mtu */
name|op_vls
operator|=
name|osm_physp_calc_link_op_vls
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|p_mgr
operator|->
name|p_subn
argument_list|,
name|p_physp
argument_list|,
name|ib_port_info_get_op_vls
argument_list|(
name|p_old_pi
argument_list|)
argument_list|)
expr_stmt|;
name|mtu
operator|=
name|osm_physp_calc_link_mtu
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|p_physp
argument_list|,
name|ib_port_info_get_neighbor_mtu
argument_list|(
name|p_old_pi
argument_list|)
argument_list|)
expr_stmt|;
name|ib_port_info_set_neighbor_mtu
argument_list|(
name|p_pi
argument_list|,
name|mtu
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_port_info_get_neighbor_mtu
argument_list|(
name|p_pi
argument_list|)
operator|!=
name|ib_port_info_get_neighbor_mtu
argument_list|(
name|p_old_pi
argument_list|)
condition|)
name|send_set
operator|=
name|TRUE
expr_stmt|;
name|ib_port_info_set_op_vls
argument_list|(
name|p_pi
argument_list|,
name|op_vls
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_port_info_get_op_vls
argument_list|(
name|p_pi
argument_list|)
operator|!=
name|ib_port_info_get_op_vls
argument_list|(
name|p_old_pi
argument_list|)
condition|)
name|send_set
operator|=
name|TRUE
expr_stmt|;
comment|/* 		   Several timeout mechanisms: 		 */
name|ib_port_info_set_phy_and_overrun_err_thd
argument_list|(
name|p_pi
argument_list|,
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|local_phy_errors_threshold
argument_list|,
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|overrun_errors_threshold
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_pi
operator|->
name|error_threshold
operator|!=
name|p_old_pi
operator|->
name|error_threshold
condition|)
name|send_set
operator|=
name|TRUE
expr_stmt|;
comment|/* 		   To reset the port state machine we can send 		   PortInfo.State = DOWN. (see: 7.2.7 p171 lines:10-19) 		 */
if|if
condition|(
name|mtu
operator|!=
name|ib_port_info_get_neighbor_mtu
argument_list|(
name|p_old_pi
argument_list|)
operator|||
name|op_vls
operator|!=
name|ib_port_info_get_op_vls
argument_list|(
name|p_old_pi
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Sending Link Down to GUID 0x%016"
name|PRIx64
literal|" port %d due to op_vls or "
literal|"mtu change. MTU:%u,%u VL_CAP:%u,%u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_physp
argument_list|)
argument_list|)
argument_list|,
name|port_num
argument_list|,
name|mtu
argument_list|,
name|ib_port_info_get_neighbor_mtu
argument_list|(
name|p_old_pi
argument_list|)
argument_list|,
name|op_vls
argument_list|,
name|ib_port_info_get_op_vls
argument_list|(
name|p_old_pi
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			   we need to make sure the internal DB will follow the 			   fact that the remote port is also going through 			   "down" state into "init"... 			 */
name|lid_mgr_set_remote_pi_state_to_init
argument_list|(
name|p_mgr
argument_list|,
name|p_physp
argument_list|)
expr_stmt|;
name|ib_port_info_set_port_state
argument_list|(
name|p_pi
argument_list|,
name|IB_LINK_DOWN
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_port_info_get_port_state
argument_list|(
name|p_pi
argument_list|)
operator|!=
name|ib_port_info_get_port_state
argument_list|(
name|p_old_pi
argument_list|)
condition|)
name|send_set
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ib_switch_info_is_enhanced_port0
argument_list|(
operator|&
name|p_node
operator|->
name|sw
operator|->
name|switch_info
argument_list|)
condition|)
block|{
comment|/* 		 * Configure Enh. SP0: 		 * Set MTU according to the mtu_cap. 		 * Set LMC if lmc_esp0 is defined. 		 */
name|ib_port_info_set_neighbor_mtu
argument_list|(
name|p_pi
argument_list|,
name|ib_port_info_get_mtu_cap
argument_list|(
name|p_old_pi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_port_info_get_neighbor_mtu
argument_list|(
name|p_pi
argument_list|)
operator|!=
name|ib_port_info_get_neighbor_mtu
argument_list|(
name|p_old_pi
argument_list|)
condition|)
name|send_set
operator|=
name|TRUE
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Updating neighbor_mtu on switch GUID 0x%016"
name|PRIx64
literal|" port 0 to:%u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_physp
argument_list|)
argument_list|)
argument_list|,
name|ib_port_info_get_neighbor_mtu
argument_list|(
name|p_pi
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Configure LMC on enhanced SP0 */
if|if
condition|(
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|lmc_esp0
condition|)
block|{
comment|/* p_pi->mkey_lmc is initialized earlier */
name|ib_port_info_set_lmc
argument_list|(
name|p_pi
argument_list|,
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|lmc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_port_info_get_lmc
argument_list|(
name|p_pi
argument_list|)
operator|!=
name|ib_port_info_get_lmc
argument_list|(
name|p_old_pi
argument_list|)
condition|)
name|send_set
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|context
operator|.
name|pi_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|port_guid
operator|=
name|osm_physp_get_port_guid
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|set_method
operator|=
name|TRUE
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|light_sweep
operator|=
name|FALSE
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|active_transition
operator|=
name|FALSE
expr_stmt|;
comment|/* 	  For ports supporting the ClientReregistration Vol1 (v1.2) p811 14.4.11: 	  need to set the cli_rereg bit when current SM LID at the Host 	  is different from our SM LID, 	  also if we are in first_time_master_sweep, 	  also if this port was just now discovered, then we should also set 	  the cli_rereg bit (we know that the port was just discovered 	  if its is_new field is set). 	*/
if|if
condition|(
operator|(
name|send_client_rereg
operator|||
name|p_mgr
operator|->
name|p_subn
operator|->
name|first_time_master_sweep
operator|==
name|TRUE
operator|||
name|p_port
operator|->
name|is_new
operator|)
operator|&&
operator|!
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|no_clients_rereg
operator|&&
operator|(
name|p_old_pi
operator|->
name|capability_mask
operator|&
name|IB_PORT_CAP_HAS_CLIENT_REREG
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Setting client rereg on %s, port %d\n"
argument_list|,
name|p_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|p_port
operator|->
name|p_physp
operator|->
name|port_num
argument_list|)
expr_stmt|;
name|ib_port_info_set_client_rereg
argument_list|(
name|p_pi
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|client_rereg
operator|=
name|TRUE
expr_stmt|;
name|send_set
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|ib_port_info_set_client_rereg
argument_list|(
name|p_pi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|client_rereg
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* We need to send the PortInfo Set request with the new sm_lid 	   in the following cases: 	   1. There is a change in the values (send_set == TRUE) 	   2. first_time_master_sweep flag on the subnet is TRUE. This means the 	   SM just became master, and it then needs to send a PortInfo Set to 	   every port. 	 */
if|if
condition|(
name|p_mgr
operator|->
name|p_subn
operator|->
name|first_time_master_sweep
operator|==
name|TRUE
condition|)
name|send_set
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|send_set
condition|)
goto|goto
name|Exit
goto|;
name|status
operator|=
name|osm_req_set
argument_list|(
name|p_mgr
operator|->
name|sm
argument_list|,
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
argument_list|,
name|payload
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|,
name|IB_MAD_ATTR_PORT_INFO
argument_list|,
name|cl_hton32
argument_list|(
name|osm_physp_get_port_num
argument_list|(
name|p_physp
argument_list|)
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|ib_port_info_get_m_key
argument_list|(
operator|&
name|p_physp
operator|->
name|port_info
argument_list|)
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If we sent a new mkey above, update our guid2mkey map 	   now, on the assumption that the SubnSet succeeds 	*/
if|if
condition|(
name|update_mkey
condition|)
name|osm_db_guid2mkey_set
argument_list|(
name|p_mgr
operator|->
name|p_subn
operator|->
name|p_g2m
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_physp
operator|->
name|port_guid
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_pi
operator|->
name|m_key
argument_list|)
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Processes our own node  Lock must already be held. **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|lid_mgr_process_our_sm_node
parameter_list|(
name|IN
name|osm_lid_mgr_t
modifier|*
name|p_mgr
parameter_list|)
block|{
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|uint16_t
name|min_lid_ho
decl_stmt|;
name|uint16_t
name|max_lid_ho
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	   Acquire our own port object. 	 */
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|p_mgr
operator|->
name|p_subn
argument_list|,
name|p_mgr
operator|->
name|p_subn
operator|->
name|sm_port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0308: "
literal|"Can't acquire SM's port object, GUID 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_mgr
operator|->
name|p_subn
operator|->
name|sm_port_guid
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	   Determine the LID this SM will use for its own port. 	   Be careful.  With an LMC> 0, the bottom of the LID range becomes 	   unusable, since port hardware will mask off least significant bits, 	   leaving a LID of 0 (invalid).  Therefore, make sure that we always 	   configure the SM with a LID that has non-zero bits, even after 	   LMC masking by hardware. 	 */
name|lid_mgr_get_port_lid
argument_list|(
name|p_mgr
argument_list|,
name|p_port
argument_list|,
operator|&
name|min_lid_ho
argument_list|,
operator|&
name|max_lid_ho
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Current base LID is %u\n"
argument_list|,
name|min_lid_ho
argument_list|)
expr_stmt|;
comment|/* 	   Update subnet object. 	 */
name|p_mgr
operator|->
name|p_subn
operator|->
name|master_sm_base_lid
operator|=
name|cl_hton16
argument_list|(
name|min_lid_ho
argument_list|)
expr_stmt|;
name|p_mgr
operator|->
name|p_subn
operator|->
name|sm_base_lid
operator|=
name|cl_hton16
argument_list|(
name|min_lid_ho
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Assigning SM's port 0x%016"
name|PRIx64
literal|"\n\t\t\t\tto LID range [%u,%u]\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_port_get_guid
argument_list|(
name|p_port
argument_list|)
argument_list|)
argument_list|,
name|min_lid_ho
argument_list|,
name|max_lid_ho
argument_list|)
expr_stmt|;
comment|/* 	   Set the PortInfo the Physical Port associated with this Port. 	 */
name|ret
operator|=
name|lid_mgr_set_physp_pi
argument_list|(
name|p_mgr
argument_list|,
name|p_port
argument_list|,
name|p_port
operator|->
name|p_physp
argument_list|,
name|cl_hton16
argument_list|(
name|min_lid_ho
argument_list|)
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|osm_lid_mgr_process_sm
parameter_list|(
name|IN
name|osm_lid_mgr_t
modifier|*
name|p_mgr
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_mgr
operator|->
name|p_subn
operator|->
name|sm_port_guid
argument_list|)
expr_stmt|;
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|p_mgr
operator|->
name|p_lock
argument_list|)
expr_stmt|;
comment|/* initialize the port_lid_tbl and empty ranges list following the 	   persistent db */
name|lid_mgr_init_sweep
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
name|ret
operator|=
name|lid_mgr_process_our_sm_node
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|p_mgr
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  1 go through all ports in the subnet.  1.1 call lid_mgr_get_port_lid  1.2 if a change is required send the port info  2 if any change send the signal PENDING... **********************************************************************/
end_comment

begin_function
name|int
name|osm_lid_mgr_process_subnet
parameter_list|(
name|IN
name|osm_lid_mgr_t
modifier|*
name|p_mgr
parameter_list|)
block|{
name|cl_qmap_t
modifier|*
name|p_port_guid_tbl
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|ib_net64_t
name|port_guid
decl_stmt|;
name|int
name|lid_changed
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|uint16_t
name|min_lid_ho
decl_stmt|,
name|max_lid_ho
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_mgr
argument_list|)
expr_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|p_mgr
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_mgr
operator|->
name|p_subn
operator|->
name|sm_port_guid
argument_list|)
expr_stmt|;
name|p_port_guid_tbl
operator|=
operator|&
name|p_mgr
operator|->
name|p_subn
operator|->
name|port_guid_tbl
expr_stmt|;
for|for
control|(
name|p_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_port_guid_tbl
argument_list|)
init|;
name|p_port
operator|!=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_port_guid_tbl
argument_list|)
condition|;
name|p_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_port
operator|->
name|map_item
argument_list|)
control|)
block|{
name|port_guid
operator|=
name|osm_port_get_guid
argument_list|(
name|p_port
argument_list|)
expr_stmt|;
comment|/* 		   Our own port is a special case in that we want to 		   assign a LID to ourselves first, since we have to 		   advertise that LID value to the other ports.  		   For that reason, our node is treated separately and 		   we will not add it to any of these lists. 		 */
if|if
condition|(
name|port_guid
operator|==
name|p_mgr
operator|->
name|p_subn
operator|->
name|sm_port_guid
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Skipping our own port 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		   get the port lid range - we need to send it on first active 		   sweep or if there was a change (the result of 		   lid_mgr_get_port_lid) 		 */
name|lid_changed
operator|=
name|lid_mgr_get_port_lid
argument_list|(
name|p_mgr
argument_list|,
name|p_port
argument_list|,
operator|&
name|min_lid_ho
argument_list|,
operator|&
name|max_lid_ho
argument_list|)
expr_stmt|;
comment|/* we can call the function to update the port info as it known 		   to look for any field change and will only send an updated 		   if required */
name|OSM_LOG
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Assigned port 0x%016"
name|PRIx64
literal|", %s LID [%u,%u]\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|,
name|lid_changed
condition|?
literal|"new"
else|:
literal|""
argument_list|,
name|min_lid_ho
argument_list|,
name|max_lid_ho
argument_list|)
expr_stmt|;
comment|/* the proc returns the fact it sent a set port info */
if|if
condition|(
name|lid_mgr_set_physp_pi
argument_list|(
name|p_mgr
argument_list|,
name|p_port
argument_list|,
name|p_port
operator|->
name|p_physp
argument_list|,
name|cl_hton16
argument_list|(
name|min_lid_ho
argument_list|)
argument_list|)
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* all ports */
comment|/* store the guid to lid table in persistent db */
name|osm_db_store
argument_list|(
name|p_mgr
operator|->
name|p_g2l
argument_list|,
name|p_mgr
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|fsync_high_avail_files
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|p_mgr
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_mgr
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

