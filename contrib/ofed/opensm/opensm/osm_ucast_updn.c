begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2008 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2007,2009 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  * Copyright (c) 2009 HNR Consulting. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *      Implementation of Up Down Algorithm using ranking& Min Hop  *      Calculation functions  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qmap.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_UCAST_UPDN_C
end_define

begin_include
include|#
directive|include
file|<opensm/osm_switch.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_ucast_mgr.h>
end_include

begin_comment
comment|/* //////////////////////////// */
end_comment

begin_comment
comment|/*  Local types                 */
end_comment

begin_comment
comment|/* //////////////////////////// */
end_comment

begin_comment
comment|/* direction */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|updn_switch_dir
block|{
name|UP
init|=
literal|0
block|,
name|DOWN
block|}
name|updn_switch_dir_t
typedef|;
end_typedef

begin_comment
comment|/* updn structure */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|updn
block|{
name|unsigned
name|num_roots
decl_stmt|;
name|osm_opensm_t
modifier|*
name|p_osm
decl_stmt|;
block|}
name|updn_t
typedef|;
end_typedef

begin_struct
struct|struct
name|updn_node
block|{
name|cl_list_item_t
name|list
decl_stmt|;
name|osm_switch_t
modifier|*
name|sw
decl_stmt|;
name|uint64_t
name|id
decl_stmt|;
name|updn_switch_dir_t
name|dir
decl_stmt|;
name|unsigned
name|rank
decl_stmt|;
name|unsigned
name|visited
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This function returns direction based on rank and guid info of current&    remote ports */
end_comment

begin_function
specifier|static
name|updn_switch_dir_t
name|updn_get_dir
parameter_list|(
name|unsigned
name|cur_rank
parameter_list|,
name|unsigned
name|rem_rank
parameter_list|,
name|uint64_t
name|cur_id
parameter_list|,
name|uint64_t
name|rem_id
parameter_list|)
block|{
comment|/* HACK: comes to solve root nodes connection, in a classic subnet root nodes do not connect 	   directly, but in case they are we assign to root node an UP direction to allow UPDN to discover 	   the subnet correctly (and not from the point of view of the last root node). 	 */
if|if
condition|(
operator|!
name|cur_rank
operator|&&
operator|!
name|rem_rank
condition|)
return|return
name|UP
return|;
if|if
condition|(
name|cur_rank
operator|<
name|rem_rank
condition|)
return|return
name|DOWN
return|;
elseif|else
if|if
condition|(
name|cur_rank
operator|>
name|rem_rank
condition|)
return|return
name|UP
return|;
else|else
block|{
comment|/* Equal rank, decide by id number, bigger == UP direction */
if|if
condition|(
name|cur_id
operator|>
name|rem_id
condition|)
return|return
name|UP
return|;
else|else
return|return
name|DOWN
return|;
block|}
block|}
end_function

begin_comment
comment|/**********************************************************************  * This function does the bfs of min hop table calculation by guid index  * as a starting point.  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|updn_bfs_by_node
parameter_list|(
name|IN
name|osm_log_t
modifier|*
name|p_log
parameter_list|,
name|IN
name|osm_subn_t
modifier|*
name|p_subn
parameter_list|,
name|IN
name|osm_switch_t
modifier|*
name|p_sw
parameter_list|)
block|{
name|uint8_t
name|pn
decl_stmt|,
name|pn_rem
decl_stmt|;
name|cl_qlist_t
name|list
decl_stmt|;
name|uint16_t
name|lid
decl_stmt|;
name|struct
name|updn_node
modifier|*
name|u
decl_stmt|;
name|updn_switch_dir_t
name|next_dir
decl_stmt|,
name|current_dir
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|lid
operator|=
name|osm_node_get_base_lid
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lid
operator|=
name|cl_ntoh16
argument_list|(
name|lid
argument_list|)
expr_stmt|;
name|osm_switch_set_hops
argument_list|(
name|p_sw
argument_list|,
name|lid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Starting from switch - port GUID 0x%"
name|PRIx64
literal|" lid %u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_sw
operator|->
name|p_node
operator|->
name|node_info
operator|.
name|port_guid
argument_list|)
argument_list|,
name|lid
argument_list|)
expr_stmt|;
name|u
operator|=
name|p_sw
operator|->
name|priv
expr_stmt|;
name|u
operator|->
name|dir
operator|=
name|UP
expr_stmt|;
comment|/* Update list with the new element */
name|cl_qlist_init
argument_list|(
operator|&
name|list
argument_list|)
expr_stmt|;
name|cl_qlist_insert_tail
argument_list|(
operator|&
name|list
argument_list|,
operator|&
name|u
operator|->
name|list
argument_list|)
expr_stmt|;
comment|/* BFS the list till no next element */
while|while
condition|(
operator|!
name|cl_is_qlist_empty
argument_list|(
operator|&
name|list
argument_list|)
condition|)
block|{
name|u
operator|=
operator|(
expr|struct
name|updn_node
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
operator|&
name|list
argument_list|)
expr_stmt|;
name|u
operator|->
name|visited
operator|=
literal|0
expr_stmt|;
comment|/* cleanup */
name|current_dir
operator|=
name|u
operator|->
name|dir
expr_stmt|;
comment|/* Go over all ports of the switch and find unvisited remote nodes */
for|for
control|(
name|pn
operator|=
literal|1
init|;
name|pn
operator|<
name|u
operator|->
name|sw
operator|->
name|num_ports
condition|;
name|pn
operator|++
control|)
block|{
name|osm_node_t
modifier|*
name|p_remote_node
decl_stmt|;
name|struct
name|updn_node
modifier|*
name|rem_u
decl_stmt|;
name|uint8_t
name|current_min_hop
decl_stmt|,
name|remote_min_hop
decl_stmt|,
name|set_hop_return_value
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_remote_sw
decl_stmt|;
name|p_remote_node
operator|=
name|osm_node_get_remote_node
argument_list|(
name|u
operator|->
name|sw
operator|->
name|p_node
argument_list|,
name|pn
argument_list|,
operator|&
name|pn_rem
argument_list|)
expr_stmt|;
comment|/* If no remote node OR remote node is not a SWITCH 			   continue to next pn */
if|if
condition|(
operator|!
name|p_remote_node
operator|||
operator|!
name|p_remote_node
operator|->
name|sw
condition|)
continue|continue;
comment|/* Fetch remote guid only after validation of remote node */
name|p_remote_sw
operator|=
name|p_remote_node
operator|->
name|sw
expr_stmt|;
name|rem_u
operator|=
name|p_remote_sw
operator|->
name|priv
expr_stmt|;
comment|/* Decide which direction to mark it (UP/DOWN) */
name|next_dir
operator|=
name|updn_get_dir
argument_list|(
name|u
operator|->
name|rank
argument_list|,
name|rem_u
operator|->
name|rank
argument_list|,
name|u
operator|->
name|id
argument_list|,
name|rem_u
operator|->
name|id
argument_list|)
expr_stmt|;
comment|/* Check if this is a legal step : the only illegal step is going 			   from DOWN to UP */
if|if
condition|(
operator|(
name|current_dir
operator|==
name|DOWN
operator|)
operator|&&
operator|(
name|next_dir
operator|==
name|UP
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Avoiding move from 0x%016"
name|PRIx64
literal|" to 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|u
operator|->
name|sw
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_remote_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Illegal step */
continue|continue;
block|}
comment|/* Set MinHop value for the current lid */
name|current_min_hop
operator|=
name|osm_switch_get_least_hops
argument_list|(
name|u
operator|->
name|sw
argument_list|,
name|lid
argument_list|)
expr_stmt|;
comment|/* Check hop count if better insert into list&& update 			   the remote node Min Hop Table */
name|remote_min_hop
operator|=
name|osm_switch_get_hop_count
argument_list|(
name|p_remote_sw
argument_list|,
name|lid
argument_list|,
name|pn_rem
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_min_hop
operator|+
literal|1
operator|<
name|remote_min_hop
condition|)
block|{
name|set_hop_return_value
operator|=
name|osm_switch_set_hops
argument_list|(
name|p_remote_sw
argument_list|,
name|lid
argument_list|,
name|pn_rem
argument_list|,
name|current_min_hop
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_hop_return_value
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AA01: "
literal|"Invalid value returned from set min hop is: %d\n"
argument_list|,
name|set_hop_return_value
argument_list|)
expr_stmt|;
block|}
comment|/* Check if remote port has already been visited */
if|if
condition|(
operator|!
name|rem_u
operator|->
name|visited
condition|)
block|{
comment|/* Insert updn_switch item into the list */
name|rem_u
operator|->
name|dir
operator|=
name|next_dir
expr_stmt|;
name|rem_u
operator|->
name|visited
operator|=
literal|1
expr_stmt|;
name|cl_qlist_insert_tail
argument_list|(
operator|&
name|list
argument_list|,
operator|&
name|rem_u
operator|->
name|list
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* NOTE : PLS check if we need to decide that the first */
end_comment

begin_comment
comment|/*        rank is a SWITCH for BFS purpose */
end_comment

begin_function
specifier|static
name|int
name|updn_subn_rank
parameter_list|(
name|IN
name|updn_t
modifier|*
name|p_updn
parameter_list|)
block|{
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|,
modifier|*
name|p_remote_physp
decl_stmt|;
name|cl_qlist_t
name|list
decl_stmt|;
name|cl_map_item_t
modifier|*
name|item
decl_stmt|;
name|struct
name|updn_node
modifier|*
name|u
decl_stmt|,
modifier|*
name|remote_u
decl_stmt|;
name|uint8_t
name|num_ports
decl_stmt|,
name|port_num
decl_stmt|;
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|unsigned
name|max_rank
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|cl_qlist_init
argument_list|(
operator|&
name|list
argument_list|)
expr_stmt|;
comment|/* add all roots to the list */
for|for
control|(
name|item
operator|=
name|cl_qmap_head
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
init|;
name|item
operator|!=
name|cl_qmap_end
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
condition|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
control|)
block|{
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|item
expr_stmt|;
name|u
operator|=
name|p_sw
operator|->
name|priv
expr_stmt|;
if|if
condition|(
operator|!
name|u
operator|->
name|rank
condition|)
name|cl_qlist_insert_tail
argument_list|(
operator|&
name|list
argument_list|,
operator|&
name|u
operator|->
name|list
argument_list|)
expr_stmt|;
block|}
comment|/* BFS the list till it's empty */
while|while
condition|(
operator|!
name|cl_is_qlist_empty
argument_list|(
operator|&
name|list
argument_list|)
condition|)
block|{
name|u
operator|=
operator|(
expr|struct
name|updn_node
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
operator|&
name|list
argument_list|)
expr_stmt|;
comment|/* Go over all remote nodes and rank them (if not already visited) */
name|p_sw
operator|=
name|u
operator|->
name|sw
expr_stmt|;
name|num_ports
operator|=
name|p_sw
operator|->
name|num_ports
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Handling switch GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|port_num
operator|=
literal|1
init|;
name|port_num
operator|<
name|num_ports
condition|;
name|port_num
operator|++
control|)
block|{
name|ib_net64_t
name|port_guid
decl_stmt|;
comment|/* Current port fetched in order to get remote side */
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
condition|)
continue|continue;
name|p_remote_physp
operator|=
name|p_physp
operator|->
name|p_remote_physp
expr_stmt|;
comment|/* 			   make sure that all the following occur on p_remote_physp: 			   1. The port isn't NULL 			   2. It is a switch 			 */
if|if
condition|(
name|p_remote_physp
operator|&&
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
condition|)
block|{
name|remote_u
operator|=
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
operator|->
name|priv
expr_stmt|;
name|port_guid
operator|=
name|p_remote_physp
operator|->
name|port_guid
expr_stmt|;
if|if
condition|(
name|remote_u
operator|->
name|rank
operator|>
name|u
operator|->
name|rank
operator|+
literal|1
condition|)
block|{
name|remote_u
operator|->
name|rank
operator|=
name|u
operator|->
name|rank
operator|+
literal|1
expr_stmt|;
name|max_rank
operator|=
name|remote_u
operator|->
name|rank
expr_stmt|;
name|cl_qlist_insert_tail
argument_list|(
operator|&
name|list
argument_list|,
operator|&
name|remote_u
operator|->
name|list
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Rank of port GUID 0x%"
name|PRIx64
literal|" = %u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|,
name|remote_u
operator|->
name|rank
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Print Summary of ranking */
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Subnet ranking completed. Max Node Rank = %d\n"
argument_list|,
name|max_rank
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* hack: preserve min hops entries to any other root switches */
end_comment

begin_function
specifier|static
name|void
name|updn_clear_non_root_hops
parameter_list|(
name|updn_t
modifier|*
name|updn
parameter_list|,
name|osm_switch_t
modifier|*
name|sw
parameter_list|)
block|{
name|osm_port_t
modifier|*
name|port
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sw
operator|->
name|num_hops
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sw
operator|->
name|hops
index|[
name|i
index|]
condition|)
block|{
name|port
operator|=
name|osm_get_port_by_lid_ho
argument_list|(
operator|&
name|updn
operator|->
name|p_osm
operator|->
name|subn
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port
operator|||
operator|!
name|port
operator|->
name|p_node
operator|->
name|sw
operator|||
operator|(
operator|(
expr|struct
name|updn_node
operator|*
operator|)
name|port
operator|->
name|p_node
operator|->
name|sw
operator|->
name|priv
operator|)
operator|->
name|rank
operator|!=
literal|0
condition|)
name|memset
argument_list|(
name|sw
operator|->
name|hops
index|[
name|i
index|]
argument_list|,
literal|0xff
argument_list|,
name|sw
operator|->
name|num_ports
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|updn_set_min_hop_table
parameter_list|(
name|IN
name|updn_t
modifier|*
name|p_updn
parameter_list|)
block|{
name|osm_subn_t
modifier|*
name|p_subn
init|=
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
decl_stmt|;
name|osm_log_t
modifier|*
name|p_log
init|=
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|log
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|cl_map_item_t
modifier|*
name|item
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
comment|/* Go over all the switches in the subnet - for each init their Min Hop 	   Table */
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Init Min Hop Table of all switches [\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
name|cl_qmap_head
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
init|;
name|item
operator|!=
name|cl_qmap_end
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
condition|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
control|)
block|{
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|item
expr_stmt|;
comment|/* Clear Min Hop Table */
if|if
condition|(
name|p_subn
operator|->
name|opt
operator|.
name|connect_roots
condition|)
name|updn_clear_non_root_hops
argument_list|(
name|p_updn
argument_list|,
name|p_sw
argument_list|)
expr_stmt|;
else|else
name|osm_switch_clear_hops
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Init Min Hop Table of all switches ]\n"
argument_list|)
expr_stmt|;
comment|/* Now do the BFS for each port  in the subnet */
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"BFS through all port guids in the subnet [\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
name|cl_qmap_head
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
init|;
name|item
operator|!=
name|cl_qmap_end
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
condition|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
control|)
block|{
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|item
expr_stmt|;
name|updn_bfs_by_node
argument_list|(
name|p_log
argument_list|,
name|p_subn
argument_list|,
name|p_sw
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"BFS through all port guids in the subnet ]\n"
argument_list|)
expr_stmt|;
comment|/* Cleanup */
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|updn_build_lid_matrices
parameter_list|(
name|IN
name|updn_t
modifier|*
name|p_updn
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Ranking all port guids in the list\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_updn
operator|->
name|num_roots
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AA0A: "
literal|"No guids were provided or number of guids is 0\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|_exit
goto|;
block|}
comment|/* Check if it's not a switched subnet */
if|if
condition|(
name|cl_is_qmap_empty
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AA0B: "
literal|"This is not a switched subnet, cannot perform UPDN algorithm\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|_exit
goto|;
block|}
comment|/* Rank the subnet switches */
if|if
condition|(
name|updn_subn_rank
argument_list|(
name|p_updn
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AA0E: "
literal|"Failed to assign ranks\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|_exit
goto|;
block|}
comment|/* After multiple ranking need to set Min Hop Table by UpDn algorithm  */
name|OSM_LOG
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Setting all switches' Min Hop Table\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|updn_set_min_hop_table
argument_list|(
name|p_updn
argument_list|)
expr_stmt|;
name|_exit
label|:
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|updn_node
modifier|*
name|create_updn_node
parameter_list|(
name|osm_switch_t
modifier|*
name|sw
parameter_list|)
block|{
name|struct
name|updn_node
modifier|*
name|u
decl_stmt|;
name|u
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|u
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|u
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|u
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|u
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|->
name|sw
operator|=
name|sw
expr_stmt|;
name|u
operator|->
name|id
operator|=
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|sw
operator|->
name|p_node
argument_list|)
argument_list|)
expr_stmt|;
name|u
operator|->
name|rank
operator|=
literal|0xffffffff
expr_stmt|;
return|return
name|u
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_updn_node
parameter_list|(
name|struct
name|updn_node
modifier|*
name|u
parameter_list|)
block|{
name|u
operator|->
name|sw
operator|->
name|priv
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find Root nodes automatically by Min Hop Table info */
end_comment

begin_function
specifier|static
name|void
name|updn_find_root_nodes_by_min_hop
parameter_list|(
name|OUT
name|updn_t
modifier|*
name|p_updn
parameter_list|)
block|{
name|osm_opensm_t
modifier|*
name|p_osm
init|=
name|p_updn
operator|->
name|p_osm
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|cl_map_item_t
modifier|*
name|item
decl_stmt|;
name|double
name|thd1
decl_stmt|,
name|thd2
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|cas_num
init|=
literal|0
decl_stmt|;
name|unsigned
modifier|*
name|cas_per_sw
decl_stmt|;
name|uint16_t
name|lid_ho
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Current number of ports in the subnet is %d\n"
argument_list|,
name|cl_qmap_count
argument_list|(
operator|&
name|p_osm
operator|->
name|subn
operator|.
name|port_guid_tbl
argument_list|)
argument_list|)
expr_stmt|;
name|lid_ho
operator|=
operator|(
name|uint16_t
operator|)
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|port_lid_tbl
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cas_per_sw
operator|=
name|malloc
argument_list|(
name|lid_ho
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cas_per_sw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cas_per_sw
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AA14: "
literal|"cannot alloc mem for CAs per switch counter array\n"
argument_list|)
expr_stmt|;
goto|goto
name|_exit
goto|;
block|}
name|memset
argument_list|(
name|cas_per_sw
argument_list|,
literal|0
argument_list|,
name|lid_ho
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cas_per_sw
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the Maximum number of CAs (and routers) for histogram normalization */
name|OSM_LOG
argument_list|(
operator|&
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Finding the number of CAs and storing them in cl_map\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
name|cl_qmap_head
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|port_guid_tbl
argument_list|)
init|;
name|item
operator|!=
name|cl_qmap_end
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|port_guid_tbl
argument_list|)
condition|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
control|)
block|{
name|p_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|item
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
operator|->
name|p_node
operator|->
name|sw
condition|)
block|{
name|p_physp
operator|=
name|p_port
operator|->
name|p_physp
operator|->
name|p_remote_physp
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
operator|||
operator|!
name|p_physp
operator|->
name|p_node
operator|->
name|sw
condition|)
continue|continue;
name|lid_ho
operator|=
name|osm_node_get_base_lid
argument_list|(
name|p_physp
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lid_ho
operator|=
name|cl_ntoh16
argument_list|(
name|lid_ho
argument_list|)
expr_stmt|;
name|cas_per_sw
index|[
name|lid_ho
index|]
operator|++
expr_stmt|;
name|cas_num
operator|++
expr_stmt|;
block|}
block|}
name|thd1
operator|=
name|cas_num
operator|*
literal|0.9
expr_stmt|;
name|thd2
operator|=
name|cas_num
operator|*
literal|0.05
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Found %u CAs and RTRs, %u SWs in the subnet. "
literal|"Thresholds are thd1 = %f&& thd2 = %f\n"
argument_list|,
name|cas_num
argument_list|,
name|cl_qmap_count
argument_list|(
operator|&
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
argument_list|,
name|thd1
argument_list|,
name|thd2
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Passing through all switches to collect Min Hop info\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
name|cl_qmap_head
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
init|;
name|item
operator|!=
name|cl_qmap_end
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
condition|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
control|)
block|{
name|unsigned
name|hop_hist
index|[
name|IB_SUBNET_PATH_HOPS_MAX
index|]
decl_stmt|;
name|uint16_t
name|max_lid_ho
decl_stmt|;
name|uint8_t
name|hop_val
decl_stmt|;
name|uint16_t
name|numHopBarsOverThd1
init|=
literal|0
decl_stmt|;
name|uint16_t
name|numHopBarsOverThd2
init|=
literal|0
decl_stmt|;
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|item
expr_stmt|;
name|memset
argument_list|(
name|hop_hist
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hop_hist
argument_list|)
argument_list|)
expr_stmt|;
name|max_lid_ho
operator|=
name|p_sw
operator|->
name|max_lid_ho
expr_stmt|;
for|for
control|(
name|lid_ho
operator|=
literal|1
init|;
name|lid_ho
operator|<=
name|max_lid_ho
condition|;
name|lid_ho
operator|++
control|)
if|if
condition|(
name|cas_per_sw
index|[
name|lid_ho
index|]
condition|)
block|{
name|hop_val
operator|=
name|osm_switch_get_least_hops
argument_list|(
name|p_sw
argument_list|,
name|lid_ho
argument_list|)
expr_stmt|;
if|if
condition|(
name|hop_val
operator|>=
name|IB_SUBNET_PATH_HOPS_MAX
condition|)
continue|continue;
name|hop_hist
index|[
name|hop_val
index|]
operator|+=
name|cas_per_sw
index|[
name|lid_ho
index|]
expr_stmt|;
block|}
comment|/* Now recognize the spines by requiring one bar to be 		   above 90% of the number of CAs and RTRs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IB_SUBNET_PATH_HOPS_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hop_hist
index|[
name|i
index|]
operator|>
name|thd1
condition|)
name|numHopBarsOverThd1
operator|++
expr_stmt|;
if|if
condition|(
name|hop_hist
index|[
name|i
index|]
operator|>
name|thd2
condition|)
name|numHopBarsOverThd2
operator|++
expr_stmt|;
block|}
comment|/* If thd conditions are valid - rank the root node */
if|if
condition|(
name|numHopBarsOverThd1
operator|==
literal|1
operator|&&
name|numHopBarsOverThd2
operator|==
literal|1
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Ranking GUID 0x%"
name|PRIx64
literal|" as root node\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|updn_node
operator|*
operator|)
name|p_sw
operator|->
name|priv
operator|)
operator|->
name|rank
operator|=
literal|0
expr_stmt|;
name|p_updn
operator|->
name|num_roots
operator|++
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|cas_per_sw
argument_list|)
expr_stmt|;
name|_exit
label|:
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_roots
parameter_list|(
name|cl_map_item_t
modifier|*
name|item
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
name|void
modifier|*
name|cxt
parameter_list|)
block|{
name|osm_switch_t
modifier|*
name|sw
init|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|item
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
expr|struct
name|updn_node
operator|*
operator|)
name|sw
operator|->
name|priv
operator|)
operator|->
name|rank
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|sw
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|update_id
parameter_list|(
name|void
modifier|*
name|cxt
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
name|osm_opensm_t
modifier|*
name|osm
init|=
name|cxt
decl_stmt|;
name|osm_switch_t
modifier|*
name|sw
decl_stmt|;
name|uint64_t
name|id
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
name|sw
operator|=
name|osm_get_switch_by_guid
argument_list|(
operator|&
name|osm
operator|->
name|subn
argument_list|,
name|cl_hton64
argument_list|(
name|guid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sw
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"switch with guid 0x%"
name|PRIx64
literal|" is not found\n"
argument_list|,
name|guid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|id
operator|=
name|strtoull
argument_list|(
name|p
argument_list|,
operator|&
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|e
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|e
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AA05: cannot parse node id \'%s\'"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|OSM_LOG
argument_list|(
operator|&
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"update node 0x%"
name|PRIx64
literal|" id to 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|guid
argument_list|,
name|id
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|updn_node
operator|*
operator|)
name|sw
operator|->
name|priv
operator|)
operator|->
name|id
operator|=
name|id
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rank_root_node
parameter_list|(
name|void
modifier|*
name|cxt
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
name|updn_t
modifier|*
name|updn
init|=
name|cxt
decl_stmt|;
name|osm_switch_t
modifier|*
name|sw
decl_stmt|;
name|sw
operator|=
name|osm_get_switch_by_guid
argument_list|(
operator|&
name|updn
operator|->
name|p_osm
operator|->
name|subn
argument_list|,
name|cl_hton64
argument_list|(
name|guid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sw
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|updn
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"switch with guid 0x%"
name|PRIx64
literal|" is not found\n"
argument_list|,
name|guid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|OSM_LOG
argument_list|(
operator|&
name|updn
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Ranking root port GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|guid
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|updn_node
operator|*
operator|)
name|sw
operator|->
name|priv
operator|)
operator|->
name|rank
operator|=
literal|0
expr_stmt|;
name|updn
operator|->
name|num_roots
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* UPDN callback function */
end_comment

begin_function
specifier|static
name|int
name|updn_lid_matrices
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|updn_t
modifier|*
name|p_updn
init|=
name|ctx
decl_stmt|;
name|cl_map_item_t
modifier|*
name|item
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
name|cl_qmap_head
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
init|;
name|item
operator|!=
name|cl_qmap_end
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
condition|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
control|)
block|{
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|item
expr_stmt|;
name|p_sw
operator|->
name|priv
operator|=
name|create_updn_node
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_sw
operator|->
name|priv
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
operator|(
name|p_updn
operator|->
name|p_osm
operator|->
name|log
operator|)
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AA0C: "
literal|"cannot create updn node\n"
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* First setup root nodes */
name|p_updn
operator|->
name|num_roots
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|root_guid_file
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"UPDN - Fetching root nodes from file \'%s\'\n"
argument_list|,
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|root_guid_file
argument_list|)
expr_stmt|;
name|ret
operator|=
name|parse_node_map
argument_list|(
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|root_guid_file
argument_list|,
name|rank_root_node
argument_list|,
name|p_updn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AA02: "
literal|"cannot parse root guids file \'%s\'\n"
argument_list|,
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|root_guid_file
argument_list|)
expr_stmt|;
name|osm_ucast_mgr_build_lid_matrices
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|sm
operator|.
name|ucast_mgr
argument_list|)
expr_stmt|;
name|updn_find_root_nodes_by_min_hop
argument_list|(
name|p_updn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|connect_roots
operator|&&
name|p_updn
operator|->
name|num_roots
operator|>
literal|1
condition|)
name|osm_ucast_mgr_build_lid_matrices
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|sm
operator|.
name|ucast_mgr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|osm_ucast_mgr_build_lid_matrices
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|sm
operator|.
name|ucast_mgr
argument_list|)
expr_stmt|;
name|updn_find_root_nodes_by_min_hop
argument_list|(
name|p_updn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|ids_guid_file
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"UPDN - update node ids from file \'%s\'\n"
argument_list|,
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|ids_guid_file
argument_list|)
expr_stmt|;
name|ret
operator|=
name|parse_node_map
argument_list|(
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|ids_guid_file
argument_list|,
name|update_id
argument_list|,
name|p_updn
operator|->
name|p_osm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AA03: "
literal|"cannot parse node ids file \'%s\'\n"
argument_list|,
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|ids_guid_file
argument_list|)
expr_stmt|;
block|}
comment|/* Only if there are assigned root nodes do the algorithm, otherwise perform do nothing */
if|if
condition|(
name|p_updn
operator|->
name|num_roots
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"activating UPDN algorithm\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|updn_build_lid_matrices
argument_list|(
name|p_updn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"disabling UPDN algorithm, no root nodes were found\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ROUTING
argument_list|)
condition|)
name|osm_dump_qmap_to_file
argument_list|(
name|p_updn
operator|->
name|p_osm
argument_list|,
literal|"opensm-updn-roots.dump"
argument_list|,
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|,
name|dump_roots
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
name|cl_qmap_head
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
init|;
name|item
operator|!=
name|cl_qmap_end
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
condition|;
name|item
operator|=
name|cl_qmap_next
argument_list|(
name|item
argument_list|)
control|)
block|{
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|item
expr_stmt|;
name|delete_updn_node
argument_list|(
name|p_sw
operator|->
name|priv
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_updn
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|updn_delete
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|free
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|osm_ucast_updn_setup
parameter_list|(
name|struct
name|osm_routing_engine
modifier|*
name|r
parameter_list|,
name|osm_opensm_t
modifier|*
name|osm
parameter_list|)
block|{
name|updn_t
modifier|*
name|updn
decl_stmt|;
name|updn
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|updn_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|updn
condition|)
return|return
operator|-
literal|1
return|;
name|memset
argument_list|(
name|updn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|updn_t
argument_list|)
argument_list|)
expr_stmt|;
name|updn
operator|->
name|p_osm
operator|=
name|osm
expr_stmt|;
name|r
operator|->
name|context
operator|=
name|updn
expr_stmt|;
name|r
operator|->
name|destroy
operator|=
name|updn_delete
expr_stmt|;
name|r
operator|->
name|build_lid_matrices
operator|=
name|updn_lid_matrices
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

