begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2010 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  * Copyright (c) 2009-2011 ZIH, TU Dresden, Federal Republic of Germany. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_opensm_t.  * This object represents the opensm super object.  * This object is part of the opensm family of objects.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_dispatcher.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_passivelock.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_OPENSM_C
end_define

begin_include
include|#
directive|include
file|<vendor/osm_vendor_api.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_version.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_base.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_subnet.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_sm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_vl15intf.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_event_plugin.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_congestion_control.h>
end_include

begin_struct
struct|struct
name|routing_engine_module
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
function_decl|(
modifier|*
name|setup
function_decl|)
parameter_list|(
name|struct
name|osm_routing_engine
modifier|*
parameter_list|,
name|osm_opensm_t
modifier|*
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_function_decl
specifier|extern
name|int
name|osm_ucast_minhop_setup
parameter_list|(
name|struct
name|osm_routing_engine
modifier|*
parameter_list|,
name|osm_opensm_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|osm_ucast_updn_setup
parameter_list|(
name|struct
name|osm_routing_engine
modifier|*
parameter_list|,
name|osm_opensm_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|osm_ucast_dnup_setup
parameter_list|(
name|struct
name|osm_routing_engine
modifier|*
parameter_list|,
name|osm_opensm_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|osm_ucast_file_setup
parameter_list|(
name|struct
name|osm_routing_engine
modifier|*
parameter_list|,
name|osm_opensm_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|osm_ucast_ftree_setup
parameter_list|(
name|struct
name|osm_routing_engine
modifier|*
parameter_list|,
name|osm_opensm_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|osm_ucast_lash_setup
parameter_list|(
name|struct
name|osm_routing_engine
modifier|*
parameter_list|,
name|osm_opensm_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|osm_ucast_dor_setup
parameter_list|(
name|struct
name|osm_routing_engine
modifier|*
parameter_list|,
name|osm_opensm_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|osm_ucast_torus2QoS_setup
parameter_list|(
name|struct
name|osm_routing_engine
modifier|*
parameter_list|,
name|osm_opensm_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|osm_ucast_sssp_setup
parameter_list|(
name|struct
name|osm_routing_engine
modifier|*
parameter_list|,
name|osm_opensm_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|osm_ucast_dfsssp_setup
parameter_list|(
name|struct
name|osm_routing_engine
modifier|*
parameter_list|,
name|osm_opensm_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|const
specifier|static
name|struct
name|routing_engine_module
name|routing_modules
index|[]
init|=
block|{
block|{
literal|"minhop"
block|,
name|osm_ucast_minhop_setup
block|}
block|,
block|{
literal|"updn"
block|,
name|osm_ucast_updn_setup
block|}
block|,
block|{
literal|"dnup"
block|,
name|osm_ucast_dnup_setup
block|}
block|,
block|{
literal|"file"
block|,
name|osm_ucast_file_setup
block|}
block|,
block|{
literal|"ftree"
block|,
name|osm_ucast_ftree_setup
block|}
block|,
block|{
literal|"lash"
block|,
name|osm_ucast_lash_setup
block|}
block|,
block|{
literal|"dor"
block|,
name|osm_ucast_dor_setup
block|}
block|,
block|{
literal|"torus-2QoS"
block|,
name|osm_ucast_torus2QoS_setup
block|}
block|,
block|{
literal|"dfsssp"
block|,
name|osm_ucast_dfsssp_setup
block|}
block|,
block|{
literal|"sssp"
block|,
name|osm_ucast_sssp_setup
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|osm_routing_engine_type_str
parameter_list|(
name|IN
name|osm_routing_engine_type_t
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|OSM_ROUTING_ENGINE_TYPE_NONE
case|:
return|return
literal|"none"
return|;
case|case
name|OSM_ROUTING_ENGINE_TYPE_MINHOP
case|:
return|return
literal|"minhop"
return|;
case|case
name|OSM_ROUTING_ENGINE_TYPE_UPDN
case|:
return|return
literal|"updn"
return|;
case|case
name|OSM_ROUTING_ENGINE_TYPE_DNUP
case|:
return|return
literal|"dnup"
return|;
case|case
name|OSM_ROUTING_ENGINE_TYPE_FILE
case|:
return|return
literal|"file"
return|;
case|case
name|OSM_ROUTING_ENGINE_TYPE_FTREE
case|:
return|return
literal|"ftree"
return|;
case|case
name|OSM_ROUTING_ENGINE_TYPE_LASH
case|:
return|return
literal|"lash"
return|;
case|case
name|OSM_ROUTING_ENGINE_TYPE_DOR
case|:
return|return
literal|"dor"
return|;
case|case
name|OSM_ROUTING_ENGINE_TYPE_TORUS_2QOS
case|:
return|return
literal|"torus-2QoS"
return|;
case|case
name|OSM_ROUTING_ENGINE_TYPE_DFSSSP
case|:
return|return
literal|"dfsssp"
return|;
case|case
name|OSM_ROUTING_ENGINE_TYPE_SSSP
case|:
return|return
literal|"sssp"
return|;
default|default:
break|break;
block|}
return|return
literal|"unknown"
return|;
block|}
end_function

begin_function
name|osm_routing_engine_type_t
name|osm_routing_engine_type
parameter_list|(
name|IN
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
comment|/* For legacy reasons, consider a NULL pointer and the string 	 * "null" as the minhop routing engine. 	 */
if|if
condition|(
operator|!
name|str
operator|||
operator|!
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"null"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"minhop"
argument_list|)
condition|)
return|return
name|OSM_ROUTING_ENGINE_TYPE_MINHOP
return|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"none"
argument_list|)
condition|)
return|return
name|OSM_ROUTING_ENGINE_TYPE_NONE
return|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"updn"
argument_list|)
condition|)
return|return
name|OSM_ROUTING_ENGINE_TYPE_UPDN
return|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"dnup"
argument_list|)
condition|)
return|return
name|OSM_ROUTING_ENGINE_TYPE_DNUP
return|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"file"
argument_list|)
condition|)
return|return
name|OSM_ROUTING_ENGINE_TYPE_FILE
return|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"ftree"
argument_list|)
condition|)
return|return
name|OSM_ROUTING_ENGINE_TYPE_FTREE
return|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"lash"
argument_list|)
condition|)
return|return
name|OSM_ROUTING_ENGINE_TYPE_LASH
return|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"dor"
argument_list|)
condition|)
return|return
name|OSM_ROUTING_ENGINE_TYPE_DOR
return|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"torus-2QoS"
argument_list|)
condition|)
return|return
name|OSM_ROUTING_ENGINE_TYPE_TORUS_2QOS
return|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"sssp"
argument_list|)
condition|)
return|return
name|OSM_ROUTING_ENGINE_TYPE_SSSP
return|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"dfsssp"
argument_list|)
condition|)
return|return
name|OSM_ROUTING_ENGINE_TYPE_DFSSSP
return|;
else|else
return|return
name|OSM_ROUTING_ENGINE_TYPE_UNKNOWN
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|append_routing_engine
parameter_list|(
name|osm_opensm_t
modifier|*
name|osm
parameter_list|,
name|struct
name|osm_routing_engine
modifier|*
name|routing_engine
parameter_list|)
block|{
name|struct
name|osm_routing_engine
modifier|*
name|r
decl_stmt|;
name|routing_engine
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|osm
operator|->
name|routing_engine_list
condition|)
block|{
name|osm
operator|->
name|routing_engine_list
operator|=
name|routing_engine
expr_stmt|;
return|return;
block|}
name|r
operator|=
name|osm
operator|->
name|routing_engine_list
expr_stmt|;
while|while
condition|(
name|r
operator|->
name|next
condition|)
name|r
operator|=
name|r
operator|->
name|next
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|routing_engine
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|osm_routing_engine
modifier|*
name|setup_routing_engine
parameter_list|(
name|osm_opensm_t
modifier|*
name|osm
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|osm_routing_engine
modifier|*
name|re
decl_stmt|;
specifier|const
name|struct
name|routing_engine_module
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"no_fallback"
argument_list|)
condition|)
block|{
name|osm
operator|->
name|no_fallback_routing_engine
operator|=
name|TRUE
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|m
operator|=
name|routing_modules
init|;
name|m
operator|->
name|name
operator|&&
operator|*
name|m
operator|->
name|name
condition|;
name|m
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|m
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|re
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|osm_routing_engine
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|re
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"memory allocation failed\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|re
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|osm_routing_engine
argument_list|)
argument_list|)
expr_stmt|;
name|re
operator|->
name|name
operator|=
name|m
operator|->
name|name
expr_stmt|;
name|re
operator|->
name|type
operator|=
name|osm_routing_engine_type
argument_list|(
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|setup
argument_list|(
name|re
argument_list|,
name|osm
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"setup of routing"
literal|" engine \'%s\' failed\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|re
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|OSM_LOG
argument_list|(
operator|&
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"\'%s\' routing engine set up\n"
argument_list|,
name|re
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
operator|->
name|type
operator|==
name|OSM_ROUTING_ENGINE_TYPE_MINHOP
condition|)
name|osm
operator|->
name|default_routing_engine
operator|=
name|re
expr_stmt|;
return|return
name|re
return|;
block|}
block|}
name|OSM_LOG
argument_list|(
operator|&
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"cannot find or setup routing engine \'%s\'\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup_routing_engines
parameter_list|(
name|osm_opensm_t
modifier|*
name|osm
parameter_list|,
specifier|const
name|char
modifier|*
name|engine_names
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|str
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|osm_routing_engine
modifier|*
name|re
decl_stmt|;
if|if
condition|(
name|engine_names
operator|&&
operator|*
name|engine_names
condition|)
block|{
name|str
operator|=
name|strdup
argument_list|(
name|engine_names
argument_list|)
expr_stmt|;
name|name
operator|=
name|strtok_r
argument_list|(
name|str
argument_list|,
literal|", \t\n"
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|name
operator|&&
operator|*
name|name
condition|)
block|{
name|re
operator|=
name|setup_routing_engine
argument_list|(
name|osm
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|re
condition|)
name|append_routing_engine
argument_list|(
name|osm
argument_list|,
name|re
argument_list|)
expr_stmt|;
name|name
operator|=
name|strtok_r
argument_list|(
name|NULL
argument_list|,
literal|", \t\n"
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|osm
operator|->
name|default_routing_engine
condition|)
name|setup_routing_engine
argument_list|(
name|osm
argument_list|,
literal|"minhop"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_opensm_construct
parameter_list|(
name|IN
name|osm_opensm_t
modifier|*
name|p_osm
parameter_list|)
block|{
name|memset
argument_list|(
name|p_osm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_osm
argument_list|)
argument_list|)
expr_stmt|;
name|p_osm
operator|->
name|osm_version
operator|=
name|OSM_VERSION
expr_stmt|;
name|osm_subn_construct
argument_list|(
operator|&
name|p_osm
operator|->
name|subn
argument_list|)
expr_stmt|;
name|osm_db_construct
argument_list|(
operator|&
name|p_osm
operator|->
name|db
argument_list|)
expr_stmt|;
name|osm_log_construct
argument_list|(
operator|&
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_opensm_construct_finish
parameter_list|(
name|IN
name|osm_opensm_t
modifier|*
name|p_osm
parameter_list|)
block|{
name|osm_sm_construct
argument_list|(
operator|&
name|p_osm
operator|->
name|sm
argument_list|)
expr_stmt|;
name|osm_sa_construct
argument_list|(
operator|&
name|p_osm
operator|->
name|sa
argument_list|)
expr_stmt|;
name|osm_mad_pool_construct
argument_list|(
operator|&
name|p_osm
operator|->
name|mad_pool
argument_list|)
expr_stmt|;
name|p_osm
operator|->
name|mad_pool_constructed
operator|=
name|TRUE
expr_stmt|;
name|osm_vl15_construct
argument_list|(
operator|&
name|p_osm
operator|->
name|vl15
argument_list|)
expr_stmt|;
name|p_osm
operator|->
name|vl15_constructed
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_routing_engines
parameter_list|(
name|osm_opensm_t
modifier|*
name|osm
parameter_list|)
block|{
name|struct
name|osm_routing_engine
modifier|*
name|r
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|next
operator|=
name|osm
operator|->
name|routing_engine_list
expr_stmt|;
while|while
condition|(
name|next
condition|)
block|{
name|r
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|r
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|destroy
condition|)
name|r
operator|->
name|destroy
argument_list|(
name|r
operator|->
name|context
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_plugins
parameter_list|(
name|osm_opensm_t
modifier|*
name|osm
parameter_list|)
block|{
name|osm_epi_plugin_t
modifier|*
name|p
decl_stmt|;
comment|/* remove from the list, and destroy it */
while|while
condition|(
operator|!
name|cl_is_qlist_empty
argument_list|(
operator|&
name|osm
operator|->
name|plugin_list
argument_list|)
condition|)
block|{
name|p
operator|=
operator|(
name|osm_epi_plugin_t
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
operator|&
name|osm
operator|->
name|plugin_list
argument_list|)
expr_stmt|;
comment|/* plugin is responsible for freeing its own resources */
name|osm_epi_destroy
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|osm_opensm_destroy
parameter_list|(
name|IN
name|osm_opensm_t
modifier|*
name|p_osm
parameter_list|)
block|{
comment|/* in case of shutdown through exit proc - no ^C */
name|osm_exit_flag
operator|=
name|TRUE
expr_stmt|;
comment|/* 	 * First of all, clear the is_sm bit. 	 */
if|if
condition|(
name|p_osm
operator|->
name|sm
operator|.
name|mad_ctrl
operator|.
name|h_bind
condition|)
name|osm_vendor_set_sm
argument_list|(
name|p_osm
operator|->
name|sm
operator|.
name|mad_ctrl
operator|.
name|h_bind
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_OSM_PERF_MGR
comment|/* Shutdown the PerfMgr */
name|osm_perfmgr_shutdown
argument_list|(
operator|&
name|p_osm
operator|->
name|perfmgr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ENABLE_OSM_PERF_MGR */
name|osm_congestion_control_shutdown
argument_list|(
operator|&
name|p_osm
operator|->
name|cc
argument_list|)
expr_stmt|;
comment|/* shut down the SM 	 * - make sure the SM sweeper thread exited 	 * - unbind from QP0 messages 	 */
name|osm_sm_shutdown
argument_list|(
operator|&
name|p_osm
operator|->
name|sm
argument_list|)
expr_stmt|;
comment|/* shut down the SA 	 * - unbind from QP1 messages 	 */
name|osm_sa_shutdown
argument_list|(
operator|&
name|p_osm
operator|->
name|sa
argument_list|)
expr_stmt|;
comment|/* cleanup all messages on VL15 fifo that were not sent yet */
name|osm_vl15_shutdown
argument_list|(
operator|&
name|p_osm
operator|->
name|vl15
argument_list|,
operator|&
name|p_osm
operator|->
name|mad_pool
argument_list|)
expr_stmt|;
comment|/* shut down the dispatcher - so no new messages cross */
name|cl_disp_shutdown
argument_list|(
operator|&
name|p_osm
operator|->
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_osm
operator|->
name|sa_set_disp_initialized
condition|)
name|cl_disp_shutdown
argument_list|(
operator|&
name|p_osm
operator|->
name|sa_set_disp
argument_list|)
expr_stmt|;
comment|/* dump SA DB */
if|if
condition|(
operator|(
name|p_osm
operator|->
name|sm
operator|.
name|p_subn
operator|->
name|sm_state
operator|==
name|IB_SMINFO_STATE_MASTER
operator|)
operator|&&
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|sa_db_dump
condition|)
name|osm_sa_db_file_dump
argument_list|(
name|p_osm
argument_list|)
expr_stmt|;
comment|/* do the destruction in reverse order as init */
name|destroy_plugins
argument_list|(
name|p_osm
argument_list|)
expr_stmt|;
name|destroy_routing_engines
argument_list|(
name|p_osm
argument_list|)
expr_stmt|;
name|osm_sa_destroy
argument_list|(
operator|&
name|p_osm
operator|->
name|sa
argument_list|)
expr_stmt|;
name|osm_sm_destroy
argument_list|(
operator|&
name|p_osm
operator|->
name|sm
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_OSM_PERF_MGR
name|osm_perfmgr_destroy
argument_list|(
operator|&
name|p_osm
operator|->
name|perfmgr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ENABLE_OSM_PERF_MGR */
name|osm_congestion_control_destroy
argument_list|(
operator|&
name|p_osm
operator|->
name|cc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_opensm_destroy_finish
parameter_list|(
name|IN
name|osm_opensm_t
modifier|*
name|p_osm
parameter_list|)
block|{
name|osm_db_destroy
argument_list|(
operator|&
name|p_osm
operator|->
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_osm
operator|->
name|vl15_constructed
operator|&&
name|p_osm
operator|->
name|mad_pool_constructed
condition|)
name|osm_vl15_destroy
argument_list|(
operator|&
name|p_osm
operator|->
name|vl15
argument_list|,
operator|&
name|p_osm
operator|->
name|mad_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_osm
operator|->
name|mad_pool_constructed
condition|)
name|osm_mad_pool_destroy
argument_list|(
operator|&
name|p_osm
operator|->
name|mad_pool
argument_list|)
expr_stmt|;
name|p_osm
operator|->
name|vl15_constructed
operator|=
name|FALSE
expr_stmt|;
name|p_osm
operator|->
name|mad_pool_constructed
operator|=
name|FALSE
expr_stmt|;
name|osm_vendor_delete
argument_list|(
operator|&
name|p_osm
operator|->
name|p_vendor
argument_list|)
expr_stmt|;
name|osm_subn_destroy
argument_list|(
operator|&
name|p_osm
operator|->
name|subn
argument_list|)
expr_stmt|;
name|cl_disp_destroy
argument_list|(
operator|&
name|p_osm
operator|->
name|disp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_osm
operator|->
name|sa_set_disp_initialized
condition|)
name|cl_disp_destroy
argument_list|(
operator|&
name|p_osm
operator|->
name|sa_set_disp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LIBPTHREAD
name|pthread_cond_destroy
argument_list|(
operator|&
name|p_osm
operator|->
name|stats
operator|.
name|cond
argument_list|)
expr_stmt|;
name|pthread_mutex_destroy
argument_list|(
operator|&
name|p_osm
operator|->
name|stats
operator|.
name|mutex
argument_list|)
expr_stmt|;
else|#
directive|else
name|cl_event_destroy
argument_list|(
operator|&
name|p_osm
operator|->
name|stats
operator|.
name|event
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p_osm
operator|->
name|node_name_map
condition|)
name|close_node_name_map
argument_list|(
name|p_osm
operator|->
name|node_name_map
argument_list|)
expr_stmt|;
name|cl_plock_destroy
argument_list|(
operator|&
name|p_osm
operator|->
name|lock
argument_list|)
expr_stmt|;
name|osm_log_destroy
argument_list|(
operator|&
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|load_plugins
parameter_list|(
name|osm_opensm_t
modifier|*
name|osm
parameter_list|,
specifier|const
name|char
modifier|*
name|plugin_names
parameter_list|)
block|{
name|osm_epi_plugin_t
modifier|*
name|epi
decl_stmt|;
name|char
modifier|*
name|p_names
decl_stmt|,
modifier|*
name|name
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|p_names
operator|=
name|strdup
argument_list|(
name|plugin_names
argument_list|)
expr_stmt|;
name|name
operator|=
name|strtok_r
argument_list|(
name|p_names
argument_list|,
literal|", \t\n"
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|name
operator|&&
operator|*
name|name
condition|)
block|{
name|epi
operator|=
name|osm_epi_construct
argument_list|(
name|osm
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|epi
condition|)
name|osm_log_v2
argument_list|(
operator|&
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
name|FILE_ID
argument_list|,
literal|"ERR 1000: cannot load plugin \'%s\'\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|cl_qlist_insert_tail
argument_list|(
operator|&
name|osm
operator|->
name|plugin_list
argument_list|,
operator|&
name|epi
operator|->
name|list
argument_list|)
expr_stmt|;
name|name
operator|=
name|strtok_r
argument_list|(
name|NULL
argument_list|,
literal|" \t\n"
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|p_names
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ib_api_status_t
name|osm_opensm_init
parameter_list|(
name|IN
name|osm_opensm_t
modifier|*
name|p_osm
parameter_list|,
name|IN
specifier|const
name|osm_subn_opt_t
modifier|*
name|p_opt
parameter_list|)
block|{
name|ib_api_status_t
name|status
decl_stmt|;
comment|/* Can't use log macros here, since we're initializing the log */
name|osm_opensm_construct
argument_list|(
name|p_osm
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_opt
operator|->
name|daemon
condition|)
name|p_osm
operator|->
name|log
operator|.
name|daemon
operator|=
literal|1
expr_stmt|;
name|status
operator|=
name|osm_log_init_v2
argument_list|(
operator|&
name|p_osm
operator|->
name|log
argument_list|,
name|p_opt
operator|->
name|force_log_flush
argument_list|,
name|p_opt
operator|->
name|log_flags
argument_list|,
name|p_opt
operator|->
name|log_file
argument_list|,
name|p_opt
operator|->
name|log_max_size
argument_list|,
name|p_opt
operator|->
name|accum_log_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
return|return
name|status
return|;
name|p_osm
operator|->
name|log
operator|.
name|log_prefix
operator|=
name|p_opt
operator|->
name|log_prefix
expr_stmt|;
comment|/* If there is a log level defined - add the OSM_VERSION to it */
name|osm_log_v2
argument_list|(
operator|&
name|p_osm
operator|->
name|log
argument_list|,
name|osm_log_get_level
argument_list|(
operator|&
name|p_osm
operator|->
name|log
argument_list|)
operator|&
operator|(
name|OSM_LOG_SYS
operator|^
literal|0xFF
operator|)
argument_list|,
name|FILE_ID
argument_list|,
literal|"%s\n"
argument_list|,
name|p_osm
operator|->
name|osm_version
argument_list|)
expr_stmt|;
comment|/* Write the OSM_VERSION to the SYS_LOG */
name|osm_log_v2
argument_list|(
operator|&
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
name|FILE_ID
argument_list|,
literal|"%s\n"
argument_list|,
name|p_osm
operator|->
name|osm_version
argument_list|)
expr_stmt|;
comment|/* Format Waived */
name|OSM_LOG
argument_list|(
operator|&
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_FUNCS
argument_list|,
literal|"[\n"
argument_list|)
expr_stmt|;
comment|/* Format Waived */
name|status
operator|=
name|cl_plock_init
argument_list|(
operator|&
name|p_osm
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
ifdef|#
directive|ifdef
name|HAVE_LIBPTHREAD
name|pthread_mutex_init
argument_list|(
operator|&
name|p_osm
operator|->
name|stats
operator|.
name|mutex
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pthread_cond_init
argument_list|(
operator|&
name|p_osm
operator|->
name|stats
operator|.
name|cond
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|status
operator|=
name|cl_event_init
argument_list|(
operator|&
name|p_osm
operator|->
name|stats
operator|.
name|event
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
endif|#
directive|endif
if|if
condition|(
name|p_opt
operator|->
name|single_thread
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Forcing single threaded dispatcher\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|cl_disp_init
argument_list|(
operator|&
name|p_osm
operator|->
name|disp
argument_list|,
literal|1
argument_list|,
literal|"opensm"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Normal behavior is to initialize the dispatcher with 		 * one thread per CPU, as specified by a thread count of '0'. 		 */
name|status
operator|=
name|cl_disp_init
argument_list|(
operator|&
name|p_osm
operator|->
name|disp
argument_list|,
literal|0
argument_list|,
literal|"opensm"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
comment|/* Unless OpenSM runs in single threaded mode, we create new single 	 * threaded dispatcher for SA Set and Delete requets. 	 */
name|p_osm
operator|->
name|sa_set_disp_initialized
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|p_opt
operator|->
name|single_thread
condition|)
block|{
name|status
operator|=
name|cl_disp_init
argument_list|(
operator|&
name|p_osm
operator|->
name|sa_set_disp
argument_list|,
literal|1
argument_list|,
literal|"subnadmin_set"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
name|p_osm
operator|->
name|sa_set_disp_initialized
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* the DB is in use by subn so init before */
name|status
operator|=
name|osm_db_init
argument_list|(
operator|&
name|p_osm
operator|->
name|db
argument_list|,
operator|&
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
name|status
operator|=
name|osm_subn_init
argument_list|(
operator|&
name|p_osm
operator|->
name|subn
argument_list|,
name|p_osm
argument_list|,
name|p_opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
name|p_osm
operator|->
name|p_vendor
operator|=
name|osm_vendor_new
argument_list|(
operator|&
name|p_osm
operator|->
name|log
argument_list|,
name|p_opt
operator|->
name|transaction_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_osm
operator|->
name|p_vendor
operator|==
name|NULL
condition|)
name|status
operator|=
name|IB_INSUFFICIENT_RESOURCES
expr_stmt|;
name|Exit
label|:
name|OSM_LOG
argument_list|(
operator|&
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_FUNCS
argument_list|,
literal|"]\n"
argument_list|)
expr_stmt|;
comment|/* Format Waived */
return|return
name|status
return|;
block|}
end_function

begin_function
name|ib_api_status_t
name|osm_opensm_init_finish
parameter_list|(
name|IN
name|osm_opensm_t
modifier|*
name|p_osm
parameter_list|,
name|IN
specifier|const
name|osm_subn_opt_t
modifier|*
name|p_opt
parameter_list|)
block|{
name|ib_api_status_t
name|status
decl_stmt|;
name|osm_opensm_construct_finish
argument_list|(
name|p_osm
argument_list|)
expr_stmt|;
name|p_osm
operator|->
name|subn
operator|.
name|sm_port_guid
operator|=
name|p_opt
operator|->
name|guid
expr_stmt|;
name|status
operator|=
name|osm_mad_pool_init
argument_list|(
operator|&
name|p_osm
operator|->
name|mad_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
name|status
operator|=
name|osm_vl15_init
argument_list|(
operator|&
name|p_osm
operator|->
name|vl15
argument_list|,
name|p_osm
operator|->
name|p_vendor
argument_list|,
operator|&
name|p_osm
operator|->
name|log
argument_list|,
operator|&
name|p_osm
operator|->
name|stats
argument_list|,
operator|&
name|p_osm
operator|->
name|subn
argument_list|,
name|p_opt
operator|->
name|max_wire_smps
argument_list|,
name|p_opt
operator|->
name|max_wire_smps2
argument_list|,
name|p_opt
operator|->
name|max_smps_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
name|status
operator|=
name|osm_sm_init
argument_list|(
operator|&
name|p_osm
operator|->
name|sm
argument_list|,
operator|&
name|p_osm
operator|->
name|subn
argument_list|,
operator|&
name|p_osm
operator|->
name|db
argument_list|,
name|p_osm
operator|->
name|p_vendor
argument_list|,
operator|&
name|p_osm
operator|->
name|mad_pool
argument_list|,
operator|&
name|p_osm
operator|->
name|vl15
argument_list|,
operator|&
name|p_osm
operator|->
name|log
argument_list|,
operator|&
name|p_osm
operator|->
name|stats
argument_list|,
operator|&
name|p_osm
operator|->
name|disp
argument_list|,
operator|&
name|p_osm
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
name|status
operator|=
name|osm_sa_init
argument_list|(
operator|&
name|p_osm
operator|->
name|sm
argument_list|,
operator|&
name|p_osm
operator|->
name|sa
argument_list|,
operator|&
name|p_osm
operator|->
name|subn
argument_list|,
name|p_osm
operator|->
name|p_vendor
argument_list|,
operator|&
name|p_osm
operator|->
name|mad_pool
argument_list|,
operator|&
name|p_osm
operator|->
name|log
argument_list|,
operator|&
name|p_osm
operator|->
name|stats
argument_list|,
operator|&
name|p_osm
operator|->
name|disp
argument_list|,
name|p_opt
operator|->
name|single_thread
condition|?
name|NULL
else|:
operator|&
name|p_osm
operator|->
name|sa_set_disp
argument_list|,
operator|&
name|p_osm
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
name|cl_qlist_init
argument_list|(
operator|&
name|p_osm
operator|->
name|plugin_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_opt
operator|->
name|event_plugin_name
condition|)
name|load_plugins
argument_list|(
name|p_osm
argument_list|,
name|p_opt
operator|->
name|event_plugin_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_OSM_PERF_MGR
name|status
operator|=
name|osm_perfmgr_init
argument_list|(
operator|&
name|p_osm
operator|->
name|perfmgr
argument_list|,
name|p_osm
argument_list|,
name|p_opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
endif|#
directive|endif
comment|/* ENABLE_OSM_PERF_MGR */
name|status
operator|=
name|osm_congestion_control_init
argument_list|(
operator|&
name|p_osm
operator|->
name|cc
argument_list|,
name|p_osm
argument_list|,
name|p_opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
name|p_osm
operator|->
name|no_fallback_routing_engine
operator|=
name|FALSE
expr_stmt|;
name|setup_routing_engines
argument_list|(
name|p_osm
argument_list|,
name|p_opt
operator|->
name|routing_engine_names
argument_list|)
expr_stmt|;
name|p_osm
operator|->
name|routing_engine_used
operator|=
name|NULL
comment|/* OSM_ROUTING_ENGINE_TYPE_NONE */
expr_stmt|;
name|p_osm
operator|->
name|node_name_map
operator|=
name|open_node_name_map
argument_list|(
name|p_opt
operator|->
name|node_name_map_name
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG
argument_list|(
operator|&
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_FUNCS
argument_list|,
literal|"]\n"
argument_list|)
expr_stmt|;
comment|/* Format Waived */
return|return
name|status
return|;
block|}
end_function

begin_function
name|ib_api_status_t
name|osm_opensm_bind
parameter_list|(
name|IN
name|osm_opensm_t
modifier|*
name|p_osm
parameter_list|,
name|IN
name|ib_net64_t
name|guid
parameter_list|)
block|{
name|ib_api_status_t
name|status
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_sm_bind
argument_list|(
operator|&
name|p_osm
operator|->
name|sm
argument_list|,
name|guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
name|status
operator|=
name|osm_sa_bind
argument_list|(
operator|&
name|p_osm
operator|->
name|sa
argument_list|,
name|guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
ifdef|#
directive|ifdef
name|ENABLE_OSM_PERF_MGR
name|status
operator|=
name|osm_perfmgr_bind
argument_list|(
operator|&
name|p_osm
operator|->
name|perfmgr
argument_list|,
name|guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
endif|#
directive|endif
comment|/* ENABLE_OSM_PERF_MGR */
name|status
operator|=
name|osm_congestion_control_bind
argument_list|(
operator|&
name|p_osm
operator|->
name|cc
argument_list|,
name|guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
comment|/* setting IS_SM in capability mask */
name|OSM_LOG
argument_list|(
operator|&
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Setting IS_SM on port 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|guid
argument_list|)
argument_list|)
expr_stmt|;
name|osm_vendor_set_sm
argument_list|(
name|p_osm
operator|->
name|sm
operator|.
name|mad_ctrl
operator|.
name|h_bind
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|void
name|osm_opensm_report_event
parameter_list|(
name|osm_opensm_t
modifier|*
name|osm
parameter_list|,
name|osm_epi_event_id_t
name|event_id
parameter_list|,
name|void
modifier|*
name|event_data
parameter_list|)
block|{
name|cl_list_item_t
modifier|*
name|item
decl_stmt|;
for|for
control|(
name|item
operator|=
name|cl_qlist_head
argument_list|(
operator|&
name|osm
operator|->
name|plugin_list
argument_list|)
init|;
operator|!
name|osm_exit_flag
operator|&&
name|item
operator|!=
name|cl_qlist_end
argument_list|(
operator|&
name|osm
operator|->
name|plugin_list
argument_list|)
condition|;
name|item
operator|=
name|cl_qlist_next
argument_list|(
name|item
argument_list|)
control|)
block|{
name|osm_epi_plugin_t
modifier|*
name|p
init|=
operator|(
name|osm_epi_plugin_t
operator|*
operator|)
name|item
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|impl
operator|->
name|report
condition|)
name|p
operator|->
name|impl
operator|->
name|report
argument_list|(
name|p
operator|->
name|plugin_data
argument_list|,
name|event_id
argument_list|,
name|event_data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

