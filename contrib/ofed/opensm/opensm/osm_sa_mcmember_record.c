begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2015 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  * Copyright (c) 2008 Xsigo Systems Inc.  All rights reserved.  * Copyright (c) 2013 Oracle and/or its affiliates. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_mcmr_recv_t.  * This object represents the MCMemberRecord Receiver object.  * This object is part of the opensm family of objects.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qmap.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_passivelock.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qlist.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_SA_MCMEMBER_RECORD_C
end_define

begin_include
include|#
directive|include
file|<vendor/osm_vendor_api.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_madw.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_subnet.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_mad_pool.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_msgdef.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_pkey.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_inform.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_sa.h>
end_include

begin_define
define|#
directive|define
name|SA_MCM_RESP_SIZE
value|SA_ITEM_RESP_SIZE(mc_rec)
end_define

begin_define
define|#
directive|define
name|JOIN_MC_COMP_MASK
value|(IB_MCR_COMPMASK_MGID | \ 				IB_MCR_COMPMASK_PORT_GID | \ 				IB_MCR_COMPMASK_JOIN_STATE)
end_define

begin_define
define|#
directive|define
name|REQUIRED_MC_CREATE_COMP_MASK
value|(IB_MCR_COMPMASK_MGID | \ 					IB_MCR_COMPMASK_PORT_GID | \ 					IB_MCR_COMPMASK_JOIN_STATE | \ 					IB_MCR_COMPMASK_QKEY | \ 					IB_MCR_COMPMASK_TCLASS | \ 					IB_MCR_COMPMASK_PKEY | \ 					IB_MCR_COMPMASK_FLOW | \ 					IB_MCR_COMPMASK_SL)
end_define

begin_define
define|#
directive|define
name|IPV4_BCAST_MGID_PREFIX
value|CL_HTON64(0xff10401b00000000ULL)
end_define

begin_define
define|#
directive|define
name|IPV4_BCAST_MGID_INT_ID
value|CL_HTON64(0x00000000ffffffffULL)
end_define

begin_function_decl
specifier|static
name|int
name|validate_other_comp_fields
parameter_list|(
name|osm_log_t
modifier|*
name|p_log
parameter_list|,
name|ib_net64_t
name|comp_mask
parameter_list|,
specifier|const
name|ib_member_rec_t
modifier|*
name|p_mcmr
parameter_list|,
name|osm_mgrp_t
modifier|*
name|p_mgrp
parameter_list|,
name|osm_log_level_t
name|log_level
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*********************************************************************  Copy certain fields between two mcmember records  used during the process of join request to copy data from the mgrp  to the port record. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|copy_from_create_mc_rec
parameter_list|(
name|IN
name|ib_member_rec_t
modifier|*
name|dest
parameter_list|,
name|IN
specifier|const
name|ib_member_rec_t
modifier|*
name|src
parameter_list|)
block|{
name|dest
operator|->
name|qkey
operator|=
name|src
operator|->
name|qkey
expr_stmt|;
name|dest
operator|->
name|mlid
operator|=
name|src
operator|->
name|mlid
expr_stmt|;
name|dest
operator|->
name|tclass
operator|=
name|src
operator|->
name|tclass
expr_stmt|;
name|dest
operator|->
name|pkey
operator|=
name|src
operator|->
name|pkey
expr_stmt|;
name|dest
operator|->
name|sl_flow_hop
operator|=
name|src
operator|->
name|sl_flow_hop
expr_stmt|;
name|dest
operator|->
name|scope_state
operator|=
name|ib_member_set_scope_state
argument_list|(
name|src
operator|->
name|scope_state
operator|>>
literal|4
argument_list|,
name|dest
operator|->
name|scope_state
operator|&
literal|0x0F
argument_list|)
expr_stmt|;
name|dest
operator|->
name|mtu
operator|=
name|src
operator|->
name|mtu
expr_stmt|;
name|dest
operator|->
name|rate
operator|=
name|src
operator|->
name|rate
expr_stmt|;
name|dest
operator|->
name|pkt_life
operator|=
name|src
operator|->
name|pkt_life
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  Return mlid to the pool of free mlids.  But this implementation is not a pool - it simply scans through  the MGRP database for unused mlids... *********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|free_mlid
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
name|uint16_t
name|mlid
parameter_list|)
block|{
name|UNUSED_PARAM
argument_list|(
name|sa
argument_list|)
expr_stmt|;
name|UNUSED_PARAM
argument_list|(
name|mlid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  Get a new unused mlid by scanning all the used ones in the subnet. **********************************************************************/
end_comment

begin_comment
comment|/* Special Case IPv6 Solicited Node Multicast (SNM) addresses */
end_comment

begin_comment
comment|/* 0xff1Z601bXXXX0000 : 0x00000001ffYYYYYY */
end_comment

begin_comment
comment|/* Where Z is the scope, XXXX is the P_Key, and  * YYYYYY is the last 24 bits of the port guid */
end_comment

begin_define
define|#
directive|define
name|PREFIX_MASK
value|CL_HTON64(0xff10ffff0000ffffULL)
end_define

begin_define
define|#
directive|define
name|PREFIX_SIGNATURE
value|CL_HTON64(0xff10601b00000000ULL)
end_define

begin_define
define|#
directive|define
name|INT_ID_MASK
value|CL_HTON64(0xfffffff1ff000000ULL)
end_define

begin_define
define|#
directive|define
name|INT_ID_SIGNATURE
value|CL_HTON64(0x00000001ff000000ULL)
end_define

begin_function
specifier|static
name|int
name|compare_ipv6_snm_mgids
parameter_list|(
specifier|const
name|void
modifier|*
name|m1
parameter_list|,
specifier|const
name|void
modifier|*
name|m2
parameter_list|)
block|{
return|return
name|memcmp
argument_list|(
name|m1
argument_list|,
name|m2
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_gid_t
argument_list|)
operator|-
literal|3
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ib_net16_t
name|find_ipv6_snm_mlid
parameter_list|(
name|osm_subn_t
modifier|*
name|subn
parameter_list|,
name|ib_gid_t
modifier|*
name|mgid
parameter_list|)
block|{
name|osm_mgrp_t
modifier|*
name|m
init|=
operator|(
name|osm_mgrp_t
operator|*
operator|)
name|cl_fmap_match
argument_list|(
operator|&
name|subn
operator|->
name|mgrp_mgid_tbl
argument_list|,
name|mgid
argument_list|,
name|compare_ipv6_snm_mgids
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|!=
operator|(
name|osm_mgrp_t
operator|*
operator|)
name|cl_fmap_end
argument_list|(
operator|&
name|subn
operator|->
name|mgrp_mgid_tbl
argument_list|)
condition|)
return|return
name|m
operator|->
name|mlid
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|match_ipv6_snm_mgid
parameter_list|(
name|ib_gid_t
modifier|*
name|mgid
parameter_list|)
block|{
return|return
operator|(
operator|(
name|mgid
operator|->
name|unicast
operator|.
name|prefix
operator|&
name|PREFIX_MASK
operator|)
operator|==
name|PREFIX_SIGNATURE
operator|&&
operator|(
name|mgid
operator|->
name|unicast
operator|.
name|interface_id
operator|&
name|INT_ID_MASK
operator|)
operator|==
name|INT_ID_SIGNATURE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ib_net16_t
name|get_new_mlid
parameter_list|(
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|ib_member_rec_t
modifier|*
name|mcmr
parameter_list|)
block|{
name|osm_subn_t
modifier|*
name|p_subn
init|=
name|sa
operator|->
name|p_subn
decl_stmt|;
name|ib_net16_t
name|requested_mlid
init|=
name|mcmr
operator|->
name|mlid
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|max
decl_stmt|;
if|if
condition|(
name|requested_mlid
operator|&&
name|cl_ntoh16
argument_list|(
name|requested_mlid
argument_list|)
operator|>=
name|IB_LID_MCAST_START_HO
operator|&&
name|cl_ntoh16
argument_list|(
name|requested_mlid
argument_list|)
operator|<=
name|p_subn
operator|->
name|max_mcast_lid_ho
operator|&&
operator|!
name|osm_get_mbox_by_mlid
argument_list|(
name|p_subn
argument_list|,
name|requested_mlid
argument_list|)
condition|)
return|return
name|requested_mlid
return|;
if|if
condition|(
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|consolidate_ipv6_snm_req
operator|&&
name|match_ipv6_snm_mgid
argument_list|(
operator|&
name|mcmr
operator|->
name|mgid
argument_list|)
operator|&&
operator|(
name|requested_mlid
operator|=
name|find_ipv6_snm_mlid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
operator|&
name|mcmr
operator|->
name|mgid
argument_list|)
operator|)
condition|)
block|{
name|char
name|str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Special Case Solicited Node Mcast Join for MGID %s\n"
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|mcmr
operator|->
name|mgid
operator|.
name|raw
argument_list|,
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|requested_mlid
return|;
block|}
name|max
operator|=
name|p_subn
operator|->
name|max_mcast_lid_ho
operator|-
name|IB_LID_MCAST_START_HO
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|sa
operator|->
name|p_subn
operator|->
name|mboxes
index|[
name|i
index|]
condition|)
return|return
name|cl_hton16
argument_list|(
name|i
operator|+
name|IB_LID_MCAST_START_HO
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|boolean_t
name|check_join_comp_mask
parameter_list|(
name|ib_net64_t
name|comp_mask
parameter_list|)
block|{
return|return
operator|(
operator|(
name|comp_mask
operator|&
name|JOIN_MC_COMP_MASK
operator|)
operator|==
name|JOIN_MC_COMP_MASK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|check_create_comp_mask
parameter_list|(
name|ib_net64_t
name|comp_mask
parameter_list|,
name|ib_member_rec_t
modifier|*
name|p_recvd_mcmember_rec
parameter_list|)
block|{
return|return
operator|(
operator|(
name|comp_mask
operator|&
name|REQUIRED_MC_CREATE_COMP_MASK
operator|)
operator|==
name|REQUIRED_MC_CREATE_COMP_MASK
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Generate the response MAD **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|mcmr_rcv_respond
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|,
name|IN
name|ib_member_rec_t
modifier|*
name|p_mcmember_rec
parameter_list|)
block|{
name|cl_qlist_t
name|rec_list
decl_stmt|;
name|osm_sa_item_t
modifier|*
name|item
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|item
operator|=
name|malloc
argument_list|(
name|SA_MCM_RESP_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B16: "
literal|"rec_item alloc failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|item
operator|->
name|resp
operator|.
name|mc_rec
operator|=
operator|*
name|p_mcmember_rec
expr_stmt|;
comment|/* Fill in the mtu, rate, and packet lifetime selectors */
name|item
operator|->
name|resp
operator|.
name|mc_rec
operator|.
name|mtu
operator|&=
literal|0x3f
expr_stmt|;
name|item
operator|->
name|resp
operator|.
name|mc_rec
operator|.
name|mtu
operator||=
name|IB_PATH_SELECTOR_EXACTLY
operator|<<
literal|6
expr_stmt|;
name|item
operator|->
name|resp
operator|.
name|mc_rec
operator|.
name|rate
operator|&=
literal|0x3f
expr_stmt|;
name|item
operator|->
name|resp
operator|.
name|mc_rec
operator|.
name|rate
operator||=
name|IB_PATH_SELECTOR_EXACTLY
operator|<<
literal|6
expr_stmt|;
name|item
operator|->
name|resp
operator|.
name|mc_rec
operator|.
name|pkt_life
operator|&=
literal|0x3f
expr_stmt|;
name|item
operator|->
name|resp
operator|.
name|mc_rec
operator|.
name|pkt_life
operator||=
name|IB_PATH_SELECTOR_EXACTLY
operator|<<
literal|6
expr_stmt|;
name|cl_qlist_init
argument_list|(
operator|&
name|rec_list
argument_list|)
expr_stmt|;
name|cl_qlist_insert_tail
argument_list|(
operator|&
name|rec_list
argument_list|,
operator|&
name|item
operator|->
name|list_item
argument_list|)
expr_stmt|;
name|osm_sa_respond
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_member_rec_t
argument_list|)
argument_list|,
operator|&
name|rec_list
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  In joining an existing group, or when querying the mc groups,  we make sure the following components provided match: MTU and RATE  HACK: Currently we ignore the PKT_LIFETIME field. **********************************************************************/
end_comment

begin_function
specifier|static
name|boolean_t
name|validate_more_comp_fields
parameter_list|(
name|osm_log_t
modifier|*
name|p_log
parameter_list|,
specifier|const
name|osm_mgrp_t
modifier|*
name|p_mgrp
parameter_list|,
specifier|const
name|ib_member_rec_t
modifier|*
name|p_recvd_mcmember_rec
parameter_list|,
name|ib_net64_t
name|comp_mask
parameter_list|)
block|{
name|uint8_t
name|mtu_sel
decl_stmt|;
name|uint8_t
name|mtu_required
decl_stmt|;
name|uint8_t
name|mtu_mgrp
decl_stmt|;
name|uint8_t
name|rate_sel
decl_stmt|;
name|uint8_t
name|rate_required
decl_stmt|;
name|uint8_t
name|rate_mgrp
decl_stmt|;
if|if
condition|(
name|comp_mask
operator|&
name|IB_MCR_COMPMASK_MTU_SEL
condition|)
block|{
name|mtu_sel
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_recvd_mcmember_rec
operator|->
name|mtu
operator|>>
literal|6
argument_list|)
expr_stmt|;
comment|/* Clearing last 2 bits */
name|mtu_required
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_recvd_mcmember_rec
operator|->
name|mtu
operator|&
literal|0x3F
argument_list|)
expr_stmt|;
name|mtu_mgrp
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|mtu
operator|&
literal|0x3F
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mtu_sel
condition|)
block|{
case|case
literal|0
case|:
comment|/* Greater than MTU specified */
if|if
condition|(
name|mtu_mgrp
operator|<=
name|mtu_required
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Requested mcast group has MTU %x, "
literal|"which is not greater than %x\n"
argument_list|,
name|mtu_mgrp
argument_list|,
name|mtu_required
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
case|case
literal|1
case|:
comment|/* Less than MTU specified */
if|if
condition|(
name|mtu_mgrp
operator|>=
name|mtu_required
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Requested mcast group has MTU %x, "
literal|"which is not less than %x\n"
argument_list|,
name|mtu_mgrp
argument_list|,
name|mtu_required
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* Exactly MTU specified */
if|if
condition|(
name|mtu_mgrp
operator|!=
name|mtu_required
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Requested mcast group has MTU %x, "
literal|"which is not equal to %x\n"
argument_list|,
name|mtu_mgrp
argument_list|,
name|mtu_required
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
comment|/* what about rate ? */
if|if
condition|(
name|comp_mask
operator|&
name|IB_MCR_COMPMASK_RATE_SEL
condition|)
block|{
name|rate_sel
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_recvd_mcmember_rec
operator|->
name|rate
operator|>>
literal|6
argument_list|)
expr_stmt|;
comment|/* Clearing last 2 bits */
name|rate_required
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_recvd_mcmember_rec
operator|->
name|rate
operator|&
literal|0x3F
argument_list|)
expr_stmt|;
name|rate_mgrp
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|rate
operator|&
literal|0x3F
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rate_sel
condition|)
block|{
case|case
literal|0
case|:
comment|/* Greater than RATE specified */
if|if
condition|(
name|ib_path_compare_rates
argument_list|(
name|rate_mgrp
argument_list|,
name|rate_required
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Requested mcast group has RATE %x, "
literal|"which is not greater than %x\n"
argument_list|,
name|rate_mgrp
argument_list|,
name|rate_required
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
case|case
literal|1
case|:
comment|/* Less than RATE specified */
if|if
condition|(
name|ib_path_compare_rates
argument_list|(
name|rate_mgrp
argument_list|,
name|rate_required
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Requested mcast group has RATE %x, "
literal|"which is not less than %x\n"
argument_list|,
name|rate_mgrp
argument_list|,
name|rate_required
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* Exactly RATE specified */
if|if
condition|(
name|ib_path_compare_rates
argument_list|(
name|rate_mgrp
argument_list|,
name|rate_required
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Requested mcast group has RATE %x, "
literal|"which is not equal to %x\n"
argument_list|,
name|rate_mgrp
argument_list|,
name|rate_required
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  In joining an existing group, we make sure the following components  are physically realizable: MTU and RATE **********************************************************************/
end_comment

begin_function
specifier|static
name|boolean_t
name|validate_port_caps
parameter_list|(
name|osm_log_t
modifier|*
name|p_log
parameter_list|,
specifier|const
name|osm_mgrp_t
modifier|*
name|p_mgrp
parameter_list|,
specifier|const
name|osm_physp_t
modifier|*
name|p_physp
parameter_list|)
block|{
specifier|const
name|ib_port_info_t
modifier|*
name|p_pi
decl_stmt|;
name|uint8_t
name|mtu_required
decl_stmt|;
name|uint8_t
name|mtu_mgrp
decl_stmt|;
name|uint8_t
name|rate_required
decl_stmt|;
name|uint8_t
name|rate_mgrp
decl_stmt|;
name|int
name|extended
decl_stmt|;
name|mtu_required
operator|=
name|ib_port_info_get_neighbor_mtu
argument_list|(
operator|&
name|p_physp
operator|->
name|port_info
argument_list|)
expr_stmt|;
name|mtu_mgrp
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|mtu
operator|&
literal|0x3F
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtu_required
operator|<
name|mtu_mgrp
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Port's MTU %x is less than %x\n"
argument_list|,
name|mtu_required
argument_list|,
name|mtu_mgrp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|p_pi
operator|=
operator|&
name|p_physp
operator|->
name|port_info
expr_stmt|;
name|extended
operator|=
name|p_pi
operator|->
name|capability_mask
operator|&
name|IB_PORT_CAP_HAS_EXT_SPEEDS
expr_stmt|;
name|rate_required
operator|=
name|ib_port_info_compute_rate
argument_list|(
name|p_pi
argument_list|,
name|extended
argument_list|)
expr_stmt|;
name|rate_mgrp
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|rate
operator|&
literal|0x3F
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_path_compare_rates
argument_list|(
name|rate_required
argument_list|,
name|rate_mgrp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Port's RATE %x is less than %x\n"
argument_list|,
name|rate_required
argument_list|,
name|rate_mgrp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * o15-0.2.1: If SA supports UD multicast, then if SA receives a SubnAdmSet()  * or SubnAdmDelete() method that would modify an existing  * MCMemberRecord, SA shall not modify that MCMemberRecord and shall  * return an error status of ERR_REQ_INVALID in response in the  * following cases:  * 1. Saved MCMemberRecord.ProxyJoin is not set and the request is  * issued by a requester with a GID other than the Port-GID.  * 2. Saved MCMemberRecord.ProxyJoin is set and the requester is not  * part of the partition for that MCMemberRecord.  **********************************************************************/
end_comment

begin_function
specifier|static
name|boolean_t
name|validate_modify
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
name|osm_mgrp_t
modifier|*
name|p_mgrp
parameter_list|,
name|IN
name|osm_mad_addr_t
modifier|*
name|p_mad_addr
parameter_list|,
name|IN
name|ib_member_rec_t
modifier|*
name|p_recvd_mcmember_rec
parameter_list|,
name|OUT
name|osm_mcm_alias_guid_t
modifier|*
modifier|*
name|pp_mcm_alias_guid
parameter_list|)
block|{
name|ib_net64_t
name|portguid
decl_stmt|;
name|ib_gid_t
name|request_gid
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_request_physp
decl_stmt|;
name|ib_api_status_t
name|res
decl_stmt|;
name|portguid
operator|=
name|p_recvd_mcmember_rec
operator|->
name|port_gid
operator|.
name|unicast
operator|.
name|interface_id
expr_stmt|;
operator|*
name|pp_mcm_alias_guid
operator|=
name|osm_mgrp_get_mcm_alias_guid
argument_list|(
name|p_mgrp
argument_list|,
name|portguid
argument_list|)
expr_stmt|;
comment|/* o15-0.2.1: If this is a new port being added - nothing to check */
if|if
condition|(
operator|!
operator|*
name|pp_mcm_alias_guid
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"This is a new port in the MC group\n"
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* We validate the request according the the proxy_join. 	   Check if the proxy_join is set or not */
if|if
condition|(
operator|(
operator|*
name|pp_mcm_alias_guid
operator|)
operator|->
name|proxy_join
operator|==
name|FALSE
condition|)
block|{
comment|/* The proxy_join is not set. Modifying can by done only 		   if the requester GID == PortGID */
name|res
operator|=
name|osm_get_gid_by_mad_addr
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|sa
operator|->
name|p_subn
argument_list|,
name|p_mad_addr
argument_list|,
operator|&
name|request_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Could not find port for requested address\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|pp_mcm_alias_guid
operator|)
operator|->
name|p_base_mcm_port
operator|->
name|port
operator|->
name|guid
operator|!=
name|request_gid
operator|.
name|unicast
operator|.
name|interface_id
operator|||
operator|(
operator|*
name|pp_mcm_alias_guid
operator|)
operator|->
name|port_gid
operator|.
name|unicast
operator|.
name|prefix
operator|!=
name|request_gid
operator|.
name|unicast
operator|.
name|prefix
condition|)
block|{
name|ib_gid_t
name|base_port_gid
decl_stmt|;
name|char
name|gid_str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|char
name|gid_str2
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|base_port_gid
operator|.
name|unicast
operator|.
name|prefix
operator|=
operator|(
operator|*
name|pp_mcm_alias_guid
operator|)
operator|->
name|port_gid
operator|.
name|unicast
operator|.
name|prefix
expr_stmt|;
name|base_port_gid
operator|.
name|unicast
operator|.
name|interface_id
operator|=
operator|(
operator|*
name|pp_mcm_alias_guid
operator|)
operator|->
name|p_base_mcm_port
operator|->
name|port
operator|->
name|guid
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"No ProxyJoin but different ports: stored:"
literal|"%s request:%s\n"
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|base_port_gid
operator|.
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
name|gid_str
argument_list|)
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|request_gid
operator|.
name|raw
argument_list|,
name|gid_str2
argument_list|,
sizeof|sizeof
name|gid_str2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
block|{
comment|/* The proxy_join is set. Modification allowed only if the 		   requester is part of the partition for this MCMemberRecord */
name|p_request_physp
operator|=
name|osm_get_physp_by_mad_addr
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|sa
operator|->
name|p_subn
argument_list|,
name|p_mad_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_request_physp
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|osm_physp_has_pkey
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|pkey
argument_list|,
name|p_request_physp
argument_list|)
condition|)
block|{
comment|/* the request port is not part of the partition for this mgrp */
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Requesting port 0x%016"
name|PRIx64
literal|" has no PKey 0x%04x\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_request_physp
operator|->
name|port_guid
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|pkey
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Check legality of the requested MGID DELETE  * o15-0.1.14 = VALID DELETE:  * To be a valid delete MAD needs to:  * 1 the MADs PortGID and MGID components match the PortGID and  *   MGID of a stored MCMemberRecord;  * 2 the MADs JoinState component contains at least one bit set to 1  *   in the same position as that stored MCMemberRecords JoinState  *   has a bit set to 1,  *   i.e., the logical AND of the two JoinState components  *   is not all zeros;  * 3 the MADs JoinState component does not have some bits set  *   which are not set in the stored MCMemberRecords JoinState component;  * 4 either the stored MCMemberRecord:ProxyJoin is reset (0), and the  *   MADs source is the stored PortGID;  *   OR  *   the stored MCMemberRecord:ProxyJoin is set (1), (see o15-  *   0.1.2:); and the MADs source is a member of the partition indicated  *   by the stored MCMemberRecord:P_Key.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|validate_delete
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
name|osm_mgrp_t
modifier|*
name|p_mgrp
parameter_list|,
name|IN
name|osm_mad_addr_t
modifier|*
name|p_mad_addr
parameter_list|,
name|IN
name|ib_member_rec_t
modifier|*
name|p_recvd_mcmember_rec
parameter_list|,
name|OUT
name|osm_mcm_alias_guid_t
modifier|*
modifier|*
name|pp_mcm_alias_guid
parameter_list|)
block|{
name|ib_net64_t
name|portguid
decl_stmt|;
name|portguid
operator|=
name|p_recvd_mcmember_rec
operator|->
name|port_gid
operator|.
name|unicast
operator|.
name|interface_id
expr_stmt|;
operator|*
name|pp_mcm_alias_guid
operator|=
name|osm_mgrp_get_mcm_alias_guid
argument_list|(
name|p_mgrp
argument_list|,
name|portguid
argument_list|)
expr_stmt|;
comment|/* 1 */
if|if
condition|(
operator|!
operator|*
name|pp_mcm_alias_guid
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Failed to find the port in the MC group\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* 2 */
if|if
condition|(
operator|!
operator|(
name|p_recvd_mcmember_rec
operator|->
name|scope_state
operator|&
literal|0x0F
operator|&
operator|(
operator|*
name|pp_mcm_alias_guid
operator|)
operator|->
name|scope_state
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Could not find any matching bits in the stored "
literal|"and requested JoinStates\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* 3 */
if|if
condition|(
operator|(
operator|(
name|p_recvd_mcmember_rec
operator|->
name|scope_state
operator|&
literal|0x0F
operator|)
operator||
operator|(
literal|0x0F
operator|&
operator|(
operator|*
name|pp_mcm_alias_guid
operator|)
operator|->
name|scope_state
operator|)
operator|)
operator|!=
operator|(
literal|0x0F
operator|&
operator|(
operator|*
name|pp_mcm_alias_guid
operator|)
operator|->
name|scope_state
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Some bits in the request JoinState (0x%X) are not "
literal|"set in the stored port (0x%X)\n"
argument_list|,
operator|(
name|p_recvd_mcmember_rec
operator|->
name|scope_state
operator|&
literal|0x0F
operator|)
argument_list|,
operator|(
literal|0x0F
operator|&
operator|(
operator|*
name|pp_mcm_alias_guid
operator|)
operator|->
name|scope_state
operator|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* 4 */
comment|/* Validate according the the proxy_join (o15-0.1.2) */
if|if
condition|(
name|validate_modify
argument_list|(
name|sa
argument_list|,
name|p_mgrp
argument_list|,
name|p_mad_addr
argument_list|,
name|p_recvd_mcmember_rec
argument_list|,
name|pp_mcm_alias_guid
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"proxy_join validation failure\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Check legality of the requested MGID (note this does not hold for SA  * created MGIDs)  *  * Implementing o15-0.1.5:  * A multicast GID is considered to be invalid if:  * 1. It does not comply with the rules as specified in 4.1.1 "GID Usage and  *    Properties" on page 145:  *  * 14) The multicast GID format is (bytes are comma sep):  *     0xff,<Fl><Sc>,<Si>,<Si>,<P>,<P>,<P>,<P>,<P>,<P>,<P>,<P>,<Id>,<Id>,<Id>,<Id>  *     Fl  4bit = Flags (b)  *     Sc  4bit = Scope (c)  *     Si 16bit = Signature (2)  *     P  64bit = GID Prefix (should be a subnet unique ID - normally Subnet Prefix)  *     Id 32bit = Unique ID in the Subnet (might be MLID or P_Key ?)  *  *  a) 8-bits of 11111111 at the start of the GID identifies this as being a  *     multicast GID.  *  b) Flags is a set of four 1-bit flags: 000T with three flags reserved  *     and defined as zero (0). The T flag is defined as follows:  *     i) T = 0 indicates this is a permanently assigned (i.e. wellknown)  *        multicast GID. See RFC 2373 and RFC 2375 as reference  *        for these permanently assigned GIDs.  *     ii) T = 1 indicates this is a non-permanently assigned (i.e. transient)  *        multicast GID.  *  c) Scope is a 4-bit multicast scope value used to limit the scope of  *     the multicast group. The following table defines scope value and  *     interpretation.  *  *     Multicast Address Scope Values:  *     0x2 Link-local  *     0x5 Site-local  *     0x8 Organization-local  *     0xE Global  *  * 2. It contains the SA-specific signature of 0xA01B and has the link-local  *    scope bits set. (EZ: the idea here is that SA created MGIDs are the  *    only source for this signature with link-local scope)  */
end_comment

begin_function
specifier|static
name|boolean_t
name|validate_requested_mgid
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|ib_member_rec_t
modifier|*
name|p_mcm_rec
parameter_list|)
block|{
name|uint16_t
name|signature
decl_stmt|;
name|boolean_t
name|valid
init|=
name|TRUE
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 14-a: mcast GID must start with 0xFF */
if|if
condition|(
name|p_mcm_rec
operator|->
name|mgid
operator|.
name|multicast
operator|.
name|header
index|[
literal|0
index|]
operator|!=
literal|0xFF
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B01: "
literal|"Invalid prefix 0x%02X in requested MGID, "
literal|"must be 0xFF\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_mcm_rec
operator|->
name|mgid
operator|.
name|multicast
operator|.
name|header
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|valid
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* the MGID signature can mark IPoIB or SA assigned MGIDs */
name|memcpy
argument_list|(
operator|&
name|signature
argument_list|,
operator|&
operator|(
name|p_mcm_rec
operator|->
name|mgid
operator|.
name|multicast
operator|.
name|raw_group_id
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|signature
argument_list|)
argument_list|)
expr_stmt|;
name|signature
operator|=
name|cl_ntoh16
argument_list|(
name|signature
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"MGID Signed as 0x%04X\n"
argument_list|,
name|signature
argument_list|)
expr_stmt|;
comment|/* 	 * We skip any checks for MGIDs that follow IPoIB 	 * GID structure as defined by the IETF ipoib-link-multicast. 	 * 	 * For IPv4 over IB, the signature will be "0x401B". 	 * 	 * |   8    |  4 |  4 |     16 bits     | 16 bits | 48 bits  | 32 bits | 	 * +--------+----+----+-----------------+---------+----------+---------+ 	 * |11111111|0001|scop|<IPoIB signature>|< P_Key>|00.......0|<all 1's>| 	 * +--------+----+----+-----------------+---------+----------+---------+ 	 * 	 * For IPv6 over IB, the signature will be "0x601B". 	 * 	 * |   8    |  4 |  4 |     16 bits     | 16 bits |       80 bits      | 	 * +--------+----+----+-----------------+---------+--------------------+ 	 * |11111111|0001|scop|<IPoIB signature>|< P_Key>|000.............0001| 	 * +--------+----+----+-----------------+---------+--------------------+ 	 * 	 */
if|if
condition|(
name|signature
operator|==
literal|0x401B
operator|||
name|signature
operator|==
literal|0x601B
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Skipping MGID Validation for IPoIB Signed (0x%04X) MGIDs\n"
argument_list|,
name|signature
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 14-b: the 3 upper bits in the "flags" should be zero: */
if|if
condition|(
name|p_mcm_rec
operator|->
name|mgid
operator|.
name|multicast
operator|.
name|header
index|[
literal|1
index|]
operator|&
literal|0xE0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B28: "
literal|"Requested MGID invalid, uses Reserved Flags: flags=0x%X\n"
argument_list|,
operator|(
name|p_mcm_rec
operator|->
name|mgid
operator|.
name|multicast
operator|.
name|header
index|[
literal|1
index|]
operator|&
literal|0xE0
operator|)
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|valid
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 2 - now what if the link local format 0xA01B is used - 	   the scope should not be link local */
if|if
condition|(
name|signature
operator|==
literal|0xA01B
operator|&&
operator|(
name|p_mcm_rec
operator|->
name|mgid
operator|.
name|multicast
operator|.
name|header
index|[
literal|1
index|]
operator|&
literal|0x0F
operator|)
operator|==
name|IB_MC_SCOPE_LINK_LOCAL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B24: "
literal|"Requested MGID invalid, "
literal|"uses 0xA01B signature but with link-local scope\n"
argument_list|)
expr_stmt|;
name|valid
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	 * For SA assigned MGIDs (signature 0xA01B): 	 * There is no real way to make sure the GID Prefix is really unique. 	 * If we could enforce using the Subnet Prefix for that purpose it would 	 * have been nice. But the spec does not require it. 	 */
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|valid
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Check if the requested new MC group parameters are realizable.  Also set the default MTU and Rate if not provided by the user. **********************************************************************/
end_comment

begin_function
specifier|static
name|boolean_t
name|mgrp_request_is_realizable
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
name|ib_net64_t
name|comp_mask
parameter_list|,
name|IN
name|ib_member_rec_t
modifier|*
name|p_mcm_rec
parameter_list|,
name|IN
specifier|const
name|osm_physp_t
modifier|*
name|p_physp
parameter_list|)
block|{
name|uint8_t
name|mtu_sel
init|=
literal|2
decl_stmt|;
comment|/* exactly */
name|uint8_t
name|mtu_required
decl_stmt|,
name|mtu
decl_stmt|,
name|port_mtu
decl_stmt|;
name|uint8_t
name|rate_sel
init|=
literal|2
decl_stmt|;
comment|/* exactly */
name|uint8_t
name|rate_required
decl_stmt|,
name|rate
decl_stmt|,
name|port_rate
decl_stmt|;
specifier|const
name|ib_port_info_t
modifier|*
name|p_pi
decl_stmt|;
name|osm_log_t
modifier|*
name|p_log
init|=
name|sa
operator|->
name|p_log
decl_stmt|;
name|int
name|extended
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	 * End of o15-0.2.3 specifies: 	 * .... 	 * The entity may also supply the other components such as HopLimit, 	 * MTU, etc. during group creation time. If these components are not 	 * provided during group creation time, SA will provide them for the 	 * group. The values chosen are vendor-dependent and beyond the scope 	 * of the specification. 	 * 	 * so we might also need to assign RATE/MTU if they are not comp 	 * masked in. 	 */
name|p_pi
operator|=
operator|&
name|p_physp
operator|->
name|port_info
expr_stmt|;
name|port_mtu
operator|=
name|p_physp
condition|?
name|ib_port_info_get_mtu_cap
argument_list|(
name|p_pi
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|comp_mask
operator|&
name|IB_MCR_COMPMASK_MTU
operator|)
operator|||
operator|!
operator|(
name|comp_mask
operator|&
name|IB_MCR_COMPMASK_MTU_SEL
operator|)
operator|||
operator|(
name|mtu_sel
operator|=
operator|(
name|p_mcm_rec
operator|->
name|mtu
operator|>>
literal|6
operator|)
operator|)
operator|==
literal|3
condition|)
name|mtu
operator|=
name|port_mtu
condition|?
name|port_mtu
else|:
name|sa
operator|->
name|p_subn
operator|->
name|min_ca_mtu
expr_stmt|;
else|else
block|{
name|mtu_required
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_mcm_rec
operator|->
name|mtu
operator|&
literal|0x3F
argument_list|)
expr_stmt|;
name|mtu
operator|=
name|mtu_required
expr_stmt|;
switch|switch
condition|(
name|mtu_sel
condition|)
block|{
case|case
literal|0
case|:
comment|/* Greater than MTU specified */
if|if
condition|(
name|port_mtu
operator|&&
name|mtu_required
operator|>=
name|port_mtu
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Requested MTU %x>= the port\'s mtu:%x\n"
argument_list|,
name|mtu_required
argument_list|,
name|port_mtu
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* we provide the largest MTU possible if we can */
if|if
condition|(
name|port_mtu
condition|)
name|mtu
operator|=
name|port_mtu
expr_stmt|;
elseif|else
if|if
condition|(
name|mtu_required
operator|<
name|sa
operator|->
name|p_subn
operator|->
name|min_ca_mtu
condition|)
name|mtu
operator|=
name|sa
operator|->
name|p_subn
operator|->
name|min_ca_mtu
expr_stmt|;
else|else
name|mtu
operator|++
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Less than MTU specified */
comment|/* use the smaller of the two: 			   a. one lower then the required 			   b. the mtu of the requesting port (if exists) */
if|if
condition|(
name|port_mtu
operator|&&
name|mtu_required
operator|>
name|port_mtu
condition|)
name|mtu
operator|=
name|port_mtu
expr_stmt|;
else|else
name|mtu
operator|--
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Exactly MTU specified */
default|default:
break|break;
block|}
comment|/* make sure it still is in the range */
if|if
condition|(
name|mtu
operator|<
name|IB_MIN_MTU
operator|||
name|mtu
operator|>
name|IB_MAX_MTU
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Calculated MTU %x is out of range\n"
argument_list|,
name|mtu
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|p_mcm_rec
operator|->
name|mtu
operator|=
operator|(
name|mtu_sel
operator|<<
literal|6
operator|)
operator||
name|mtu
expr_stmt|;
if|if
condition|(
name|p_physp
condition|)
block|{
name|extended
operator|=
name|p_pi
operator|->
name|capability_mask
operator|&
name|IB_PORT_CAP_HAS_EXT_SPEEDS
expr_stmt|;
name|port_rate
operator|=
name|ib_port_info_compute_rate
argument_list|(
name|p_pi
argument_list|,
name|extended
argument_list|)
expr_stmt|;
block|}
else|else
name|port_rate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|comp_mask
operator|&
name|IB_MCR_COMPMASK_RATE
operator|)
operator|||
operator|!
operator|(
name|comp_mask
operator|&
name|IB_MCR_COMPMASK_RATE_SEL
operator|)
operator|||
operator|(
name|rate_sel
operator|=
operator|(
name|p_mcm_rec
operator|->
name|rate
operator|>>
literal|6
operator|)
operator|)
operator|==
literal|3
condition|)
name|rate
operator|=
name|port_rate
condition|?
name|port_rate
else|:
name|sa
operator|->
name|p_subn
operator|->
name|min_ca_rate
expr_stmt|;
else|else
block|{
name|rate_required
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_mcm_rec
operator|->
name|rate
operator|&
literal|0x3F
argument_list|)
expr_stmt|;
name|rate
operator|=
name|rate_required
expr_stmt|;
switch|switch
condition|(
name|rate_sel
condition|)
block|{
case|case
literal|0
case|:
comment|/* Greater than RATE specified */
if|if
condition|(
name|ib_path_compare_rates
argument_list|(
name|rate_required
argument_list|,
name|port_rate
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Requested RATE %x>= the port\'s rate:%x\n"
argument_list|,
name|rate_required
argument_list|,
name|port_rate
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* we provide the largest RATE possible if we can */
if|if
condition|(
name|port_rate
condition|)
name|rate
operator|=
name|port_rate
expr_stmt|;
elseif|else
if|if
condition|(
name|ib_path_compare_rates
argument_list|(
name|rate_required
argument_list|,
name|sa
operator|->
name|p_subn
operator|->
name|min_ca_rate
argument_list|)
operator|<
literal|0
condition|)
name|rate
operator|=
name|sa
operator|->
name|p_subn
operator|->
name|min_ca_rate
expr_stmt|;
else|else
name|rate
operator|=
name|ib_path_rate_get_next
argument_list|(
name|rate
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Less than RATE specified */
comment|/* use the smaller of the two: 			   a. one lower then the required 			   b. the rate of the requesting port (if exists) */
if|if
condition|(
name|ib_path_compare_rates
argument_list|(
name|rate_required
argument_list|,
name|port_rate
argument_list|)
operator|>
literal|0
condition|)
name|rate
operator|=
name|port_rate
expr_stmt|;
else|else
name|rate
operator|=
name|ib_path_rate_get_prev
argument_list|(
name|rate
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Exactly RATE specified */
default|default:
break|break;
block|}
comment|/* make sure it still is in the range */
if|if
condition|(
name|rate
operator|<
name|IB_MIN_RATE
operator|||
name|rate
operator|>
name|IB_MAX_RATE
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Calculated RATE %x is out of range\n"
argument_list|,
name|rate
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|p_mcm_rec
operator|->
name|rate
operator|=
operator|(
name|rate_sel
operator|<<
literal|6
operator|)
operator||
name|rate
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|build_new_mgid
parameter_list|(
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|ib_net64_t
name|comp_mask
parameter_list|,
name|ib_member_rec_t
modifier|*
name|mcmr
parameter_list|)
block|{
specifier|static
name|uint32_t
name|uniq_count
decl_stmt|;
name|ib_gid_t
modifier|*
name|mgid
init|=
operator|&
name|mcmr
operator|->
name|mgid
decl_stmt|;
name|uint8_t
name|scope
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
comment|/* use the given scope state only if requested! */
if|if
condition|(
name|comp_mask
operator|&
name|IB_MCR_COMPMASK_SCOPE
condition|)
name|ib_member_get_scope_state
argument_list|(
name|mcmr
operator|->
name|scope_state
argument_list|,
operator|&
name|scope
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
comment|/* to guarantee no collision with other subnets use local scope! */
name|scope
operator|=
name|IB_MC_SCOPE_LINK_LOCAL
expr_stmt|;
name|mgid
operator|->
name|raw
index|[
literal|0
index|]
operator|=
literal|0xff
expr_stmt|;
name|mgid
operator|->
name|raw
index|[
literal|1
index|]
operator|=
literal|0x10
operator||
name|scope
expr_stmt|;
name|mgid
operator|->
name|raw
index|[
literal|2
index|]
operator|=
literal|0xa0
expr_stmt|;
name|mgid
operator|->
name|raw
index|[
literal|3
index|]
operator|=
literal|0x1b
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|mgid
operator|->
name|raw
index|[
literal|4
index|]
argument_list|,
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|subnet_prefix
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|mgid
operator|->
name|raw
index|[
literal|10
index|]
argument_list|,
operator|&
name|uniq_count
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|uniq_count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|osm_get_mgrp_by_mgid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|mgid
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Call this function to create a new mgrp. **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|mcmr_rcv_create_new_mgrp
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
name|ib_net64_t
name|comp_mask
parameter_list|,
name|IN
specifier|const
name|ib_member_rec_t
modifier|*
name|p_recvd_mcmember_rec
parameter_list|,
name|IN
specifier|const
name|osm_physp_t
modifier|*
name|p_physp
parameter_list|,
name|OUT
name|osm_mgrp_t
modifier|*
modifier|*
name|pp_mgrp
parameter_list|)
block|{
name|ib_net16_t
name|mlid
decl_stmt|;
name|uint16_t
name|signature
decl_stmt|;
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|osm_mgrp_t
modifier|*
name|bcast_mgrp
decl_stmt|;
name|ib_gid_t
name|bcast_mgid
decl_stmt|;
name|ib_member_rec_t
name|mcm_rec
init|=
operator|*
name|p_recvd_mcmember_rec
decl_stmt|;
comment|/* copy for modifications */
name|char
name|gid_str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* we need to create the new MGID if it was not defined */
if|if
condition|(
operator|!
name|ib_gid_is_notzero
argument_list|(
operator|&
name|p_recvd_mcmember_rec
operator|->
name|mgid
argument_list|)
condition|)
block|{
comment|/* create a new MGID */
if|if
condition|(
operator|!
name|build_new_mgid
argument_list|(
name|sa
argument_list|,
name|comp_mask
argument_list|,
operator|&
name|mcm_rec
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B23: "
literal|"cannot allocate unique MGID value\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_SA_MAD_STATUS_NO_RESOURCES
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Allocated new MGID:%s\n"
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|mcm_rec
operator|.
name|mgid
operator|.
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
name|gid_str
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|ipoib_mcgroup_creation_validation
condition|)
block|{
comment|/* a specific MGID was requested so validate the resulting MGID */
if|if
condition|(
name|validate_requested_mgid
argument_list|(
name|sa
argument_list|,
operator|&
name|mcm_rec
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|signature
argument_list|,
operator|&
operator|(
name|mcm_rec
operator|.
name|mgid
operator|.
name|multicast
operator|.
name|raw_group_id
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|signature
argument_list|)
argument_list|)
expr_stmt|;
name|signature
operator|=
name|cl_ntoh16
argument_list|(
name|signature
argument_list|)
expr_stmt|;
comment|/* Check for IPoIB signature in MGID */
if|if
condition|(
name|signature
operator|==
literal|0x401B
operator|||
name|signature
operator|==
literal|0x601B
condition|)
block|{
comment|/* Derive IPoIB broadcast MGID */
name|bcast_mgid
operator|.
name|unicast
operator|.
name|prefix
operator|=
name|IPV4_BCAST_MGID_PREFIX
expr_stmt|;
name|bcast_mgid
operator|.
name|unicast
operator|.
name|interface_id
operator|=
name|IPV4_BCAST_MGID_INT_ID
expr_stmt|;
comment|/* Set scope in IPoIB broadcast MGID */
name|bcast_mgid
operator|.
name|multicast
operator|.
name|header
index|[
literal|1
index|]
operator|=
operator|(
name|bcast_mgid
operator|.
name|multicast
operator|.
name|header
index|[
literal|1
index|]
operator|&
literal|0xF0
operator|)
operator||
operator|(
name|mcm_rec
operator|.
name|mgid
operator|.
name|multicast
operator|.
name|header
index|[
literal|1
index|]
operator|&
literal|0x0F
operator|)
expr_stmt|;
comment|/* Set P_Key in IPoIB broadcast MGID */
name|bcast_mgid
operator|.
name|multicast
operator|.
name|raw_group_id
index|[
literal|2
index|]
operator|=
name|mcm_rec
operator|.
name|mgid
operator|.
name|multicast
operator|.
name|raw_group_id
index|[
literal|2
index|]
expr_stmt|;
name|bcast_mgid
operator|.
name|multicast
operator|.
name|raw_group_id
index|[
literal|3
index|]
operator|=
name|mcm_rec
operator|.
name|mgid
operator|.
name|multicast
operator|.
name|raw_group_id
index|[
literal|3
index|]
expr_stmt|;
comment|/* Check MC group for the IPoIB broadcast group */
if|if
condition|(
name|signature
operator|!=
literal|0x401B
operator|||
name|memcmp
argument_list|(
operator|&
name|bcast_mgid
argument_list|,
operator|&
operator|(
name|mcm_rec
operator|.
name|mgid
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_gid_t
argument_list|)
argument_list|)
condition|)
block|{
name|bcast_mgrp
operator|=
name|osm_get_mgrp_by_mgid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
operator|&
name|bcast_mgid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bcast_mgrp
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B1B: Broadcast group %s not found, sending IB_SA_MAD_STATUS_REQ_INVALID\n"
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|bcast_mgid
operator|.
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
name|gid_str
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_SA_MAD_STATUS_REQ_INVALID
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|!
name|validate_other_comp_fields
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|comp_mask
argument_list|,
name|p_recvd_mcmember_rec
argument_list|,
name|bcast_mgrp
argument_list|,
name|OSM_LOG_ERROR
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B1C: validate_other_comp_fields failed for MGID: %s, sending IB_SA_MAD_STATUS_REQ_INVALID\n"
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|p_recvd_mcmember_rec
operator|->
name|mgid
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
name|gid_str
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_SA_MAD_STATUS_REQ_INVALID
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
block|}
block|}
else|else
block|{
name|status
operator|=
name|IB_SA_MAD_STATUS_REQ_INVALID
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/* check the requested parameters are realizable */
if|if
condition|(
name|mgrp_request_is_realizable
argument_list|(
name|sa
argument_list|,
name|comp_mask
argument_list|,
operator|&
name|mcm_rec
argument_list|,
name|p_physp
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B26: "
literal|"Requested MGRP parameters are not realizable\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_SA_MAD_STATUS_REQ_INVALID
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|mlid
operator|=
name|get_new_mlid
argument_list|(
name|sa
argument_list|,
operator|&
name|mcm_rec
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlid
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B19: "
literal|"get_new_mlid failed request mlid 0x%04x\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|mcm_rec
operator|.
name|mlid
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_SA_MAD_STATUS_NO_RESOURCES
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Obtained new mlid 0x%X\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|mlid
argument_list|)
argument_list|)
expr_stmt|;
name|mcm_rec
operator|.
name|mlid
operator|=
name|mlid
expr_stmt|;
comment|/* create a new MC Group */
operator|*
name|pp_mgrp
operator|=
name|osm_mgrp_new
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|mlid
argument_list|,
operator|&
name|mcm_rec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pp_mgrp
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B08: "
literal|"osm_mgrp_new failed\n"
argument_list|)
expr_stmt|;
name|free_mlid
argument_list|(
name|sa
argument_list|,
name|mlid
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_SA_MAD_STATUS_NO_RESOURCES
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* the mcmember_record should have mtu_sel, rate_sel, and pkt_lifetime_sel = 2 */
operator|(
operator|*
name|pp_mgrp
operator|)
operator|->
name|mcmember_rec
operator|.
name|mtu
operator|&=
literal|0x3f
expr_stmt|;
operator|(
operator|*
name|pp_mgrp
operator|)
operator|->
name|mcmember_rec
operator|.
name|mtu
operator||=
name|IB_PATH_SELECTOR_EXACTLY
operator|<<
literal|6
expr_stmt|;
operator|(
operator|*
name|pp_mgrp
operator|)
operator|->
name|mcmember_rec
operator|.
name|rate
operator|&=
literal|0x3f
expr_stmt|;
operator|(
operator|*
name|pp_mgrp
operator|)
operator|->
name|mcmember_rec
operator|.
name|rate
operator||=
name|IB_PATH_SELECTOR_EXACTLY
operator|<<
literal|6
expr_stmt|;
operator|(
operator|*
name|pp_mgrp
operator|)
operator|->
name|mcmember_rec
operator|.
name|pkt_life
operator|&=
literal|0x3f
expr_stmt|;
operator|(
operator|*
name|pp_mgrp
operator|)
operator|->
name|mcmember_rec
operator|.
name|pkt_life
operator||=
name|IB_PATH_SELECTOR_EXACTLY
operator|<<
literal|6
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Call this function to find or create a new mgrp. **********************************************************************/
end_comment

begin_function
name|osm_mgrp_t
modifier|*
name|osm_mcmr_rcv_find_or_create_new_mgrp
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
name|ib_net64_t
name|comp_mask
parameter_list|,
name|IN
name|ib_member_rec_t
modifier|*
name|p_recvd_mcmember_rec
parameter_list|)
block|{
name|osm_mgrp_t
modifier|*
name|mgrp
decl_stmt|;
if|if
condition|(
operator|(
name|mgrp
operator|=
name|osm_get_mgrp_by_mgid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
operator|&
name|p_recvd_mcmember_rec
operator|->
name|mgid
argument_list|)
operator|)
condition|)
return|return
name|mgrp
return|;
if|if
condition|(
name|mcmr_rcv_create_new_mgrp
argument_list|(
name|sa
argument_list|,
name|comp_mask
argument_list|,
name|p_recvd_mcmember_rec
argument_list|,
name|NULL
argument_list|,
operator|&
name|mgrp
argument_list|)
operator|==
name|IB_SUCCESS
condition|)
return|return
name|mgrp
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/********************************************************************* Process a request for leaving the group **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|mcmr_rcv_leave_mgrp
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|)
block|{
name|osm_mgrp_t
modifier|*
name|p_mgrp
decl_stmt|;
name|ib_sa_mad_t
modifier|*
name|p_sa_mad
decl_stmt|;
name|ib_member_rec_t
modifier|*
name|p_recvd_mcmember_rec
decl_stmt|;
name|ib_member_rec_t
name|mcmember_rec
decl_stmt|;
name|osm_mcm_alias_guid_t
modifier|*
name|p_mcm_alias_guid
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_sa_mad
operator|=
name|osm_madw_get_sa_mad_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_recvd_mcmember_rec
operator|=
operator|(
name|ib_member_rec_t
operator|*
operator|)
name|ib_sa_mad_get_payload_ptr
argument_list|(
name|p_sa_mad
argument_list|)
expr_stmt|;
name|mcmember_rec
operator|=
operator|*
name|p_recvd_mcmember_rec
expr_stmt|;
comment|/* Validate the subnet prefix in the PortGID */
if|if
condition|(
name|p_recvd_mcmember_rec
operator|->
name|port_gid
operator|.
name|unicast
operator|.
name|prefix
operator|!=
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|subnet_prefix
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"PortGID subnet prefix 0x%"
name|PRIx64
literal|" does not match configured prefix 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_recvd_mcmember_rec
operator|->
name|port_gid
operator|.
name|unicast
operator|.
name|prefix
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|subnet_prefix
argument_list|)
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_INVALID_GID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
block|{
name|osm_physp_t
modifier|*
name|p_req_physp
decl_stmt|;
name|p_req_physp
operator|=
name|osm_get_physp_by_mad_addr
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|sa
operator|->
name|p_subn
argument_list|,
name|osm_madw_get_mad_addr_ptr
argument_list|(
name|p_madw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_req_physp
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B02: "
literal|"Cannot find requester physical port\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Requester port GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_req_physp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Dump of record\n"
argument_list|)
expr_stmt|;
name|osm_dump_mc_record_v2
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
operator|&
name|mcmember_rec
argument_list|,
name|FILE_ID
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
expr_stmt|;
block|}
name|p_mgrp
operator|=
name|osm_get_mgrp_by_mgid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
operator|&
name|p_recvd_mcmember_rec
operator|->
name|mgid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_mgrp
condition|)
block|{
name|char
name|gid_str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Failed since multicast group %s not present\n"
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|p_recvd_mcmember_rec
operator|->
name|mgid
operator|.
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
name|gid_str
argument_list|)
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* check validity of the delete request o15-0.1.14 */
if|if
condition|(
operator|!
name|validate_delete
argument_list|(
name|sa
argument_list|,
name|p_mgrp
argument_list|,
name|osm_madw_get_mad_addr_ptr
argument_list|(
name|p_madw
argument_list|)
argument_list|,
name|p_recvd_mcmember_rec
argument_list|,
operator|&
name|p_mcm_alias_guid
argument_list|)
condition|)
block|{
name|char
name|gid_str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|char
name|gid_str2
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B25: "
literal|"Received an invalid delete request for "
literal|"MGID: %s for PortGID: %s\n"
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|p_recvd_mcmember_rec
operator|->
name|mgid
operator|.
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
name|gid_str
argument_list|)
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|p_recvd_mcmember_rec
operator|->
name|port_gid
operator|.
name|raw
argument_list|,
name|gid_str2
argument_list|,
sizeof|sizeof
name|gid_str2
argument_list|)
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* remove port and/or update join state */
name|osm_mgrp_remove_port
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|sa
operator|->
name|p_log
argument_list|,
name|p_mgrp
argument_list|,
name|p_mcm_alias_guid
argument_list|,
operator|&
name|mcmember_rec
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|mcmr_rcv_respond
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
operator|&
name|mcmember_rec
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|validate_other_comp_fields
parameter_list|(
name|osm_log_t
modifier|*
name|p_log
parameter_list|,
name|ib_net64_t
name|comp_mask
parameter_list|,
specifier|const
name|ib_member_rec_t
modifier|*
name|p_mcmr
parameter_list|,
name|osm_mgrp_t
modifier|*
name|p_mgrp
parameter_list|,
name|osm_log_level_t
name|log_level
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|IB_MCR_COMPMASK_QKEY
operator|&
name|comp_mask
operator|)
operator|&&
name|p_mcmr
operator|->
name|qkey
operator|!=
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|qkey
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|log_level
argument_list|,
literal|"ERR 1B30: "
literal|"Q_Key mismatch: query 0x%x group 0x%x\n"
argument_list|,
name|cl_ntoh32
argument_list|(
name|p_mcmr
operator|->
name|qkey
argument_list|)
argument_list|,
name|cl_ntoh32
argument_list|(
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|qkey
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|IB_MCR_COMPMASK_PKEY
operator|&
name|comp_mask
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ib_pkey_is_full_member
argument_list|(
name|p_mcmr
operator|->
name|pkey
argument_list|)
operator|||
name|ib_pkey_is_full_member
argument_list|(
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|pkey
argument_list|)
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|log_level
argument_list|,
literal|"ERR 1B31: "
literal|"Both limited P_Keys: query 0x%x group 0x%x\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_mcmr
operator|->
name|pkey
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|pkey
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|ib_pkey_get_base
argument_list|(
name|p_mcmr
operator|->
name|pkey
argument_list|)
operator|!=
name|ib_pkey_get_base
argument_list|(
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|pkey
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|log_level
argument_list|,
literal|"ERR 1B32: "
literal|"P_Key base mismatch: query 0x%x group 0x%x\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_mcmr
operator|->
name|pkey
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|pkey
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|IB_MCR_COMPMASK_TCLASS
operator|&
name|comp_mask
operator|)
operator|&&
name|p_mcmr
operator|->
name|tclass
operator|!=
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|tclass
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|log_level
argument_list|,
literal|"ERR 1B33: "
literal|"TClass mismatch: query %d group %d\n"
argument_list|,
name|p_mcmr
operator|->
name|tclass
argument_list|,
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|tclass
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* check SL, Flow, and Hop limit */
block|{
name|uint32_t
name|mgrp_flow
decl_stmt|,
name|query_flow
decl_stmt|;
name|uint8_t
name|mgrp_sl
decl_stmt|,
name|query_sl
decl_stmt|;
name|uint8_t
name|mgrp_hop
decl_stmt|,
name|query_hop
decl_stmt|;
name|ib_member_get_sl_flow_hop
argument_list|(
name|p_mcmr
operator|->
name|sl_flow_hop
argument_list|,
operator|&
name|query_sl
argument_list|,
operator|&
name|query_flow
argument_list|,
operator|&
name|query_hop
argument_list|)
expr_stmt|;
name|ib_member_get_sl_flow_hop
argument_list|(
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|sl_flow_hop
argument_list|,
operator|&
name|mgrp_sl
argument_list|,
operator|&
name|mgrp_flow
argument_list|,
operator|&
name|mgrp_hop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|IB_MCR_COMPMASK_SL
operator|&
name|comp_mask
operator|)
operator|&&
name|query_sl
operator|!=
name|mgrp_sl
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|log_level
argument_list|,
literal|"ERR 1B34: "
literal|"SL mismatch: query %d group %d\n"
argument_list|,
name|query_sl
argument_list|,
name|mgrp_sl
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|(
name|IB_MCR_COMPMASK_FLOW
operator|&
name|comp_mask
operator|)
operator|&&
name|query_flow
operator|!=
name|mgrp_flow
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|log_level
argument_list|,
literal|"ERR 1B35: "
literal|"FlowLabel mismatch: query 0x%x group 0x%x\n"
argument_list|,
name|query_flow
argument_list|,
name|mgrp_flow
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|(
name|IB_MCR_COMPMASK_HOP
operator|&
name|comp_mask
operator|)
operator|&&
name|query_hop
operator|!=
name|mgrp_hop
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|log_level
argument_list|,
literal|"ERR 1B36: "
literal|"Hop mismatch: query %d group %d\n"
argument_list|,
name|query_hop
argument_list|,
name|mgrp_hop
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
name|ret
operator|=
literal|1
expr_stmt|;
name|Exit
label|:
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Handle a join (or create) request **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|mcmr_rcv_join_mgrp
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|)
block|{
name|osm_mgrp_t
modifier|*
name|p_mgrp
init|=
name|NULL
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|ib_sa_mad_t
modifier|*
name|p_sa_mad
decl_stmt|;
name|ib_member_rec_t
modifier|*
name|p_recvd_mcmember_rec
decl_stmt|;
name|ib_member_rec_t
name|mcmember_rec
decl_stmt|;
name|osm_mcm_port_t
modifier|*
name|p_mcmr_port
decl_stmt|;
name|osm_mcm_alias_guid_t
modifier|*
name|p_mcm_alias_guid
decl_stmt|;
name|ib_net64_t
name|portguid
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_request_physp
decl_stmt|;
name|uint8_t
name|is_new_group
decl_stmt|;
comment|/* TRUE = there is a need to create a group */
name|uint8_t
name|join_state
decl_stmt|;
name|boolean_t
name|proxy
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_sa_mad
operator|=
name|osm_madw_get_sa_mad_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_recvd_mcmember_rec
operator|=
name|ib_sa_mad_get_payload_ptr
argument_list|(
name|p_sa_mad
argument_list|)
expr_stmt|;
name|portguid
operator|=
name|p_recvd_mcmember_rec
operator|->
name|port_gid
operator|.
name|unicast
operator|.
name|interface_id
expr_stmt|;
name|mcmember_rec
operator|=
operator|*
name|p_recvd_mcmember_rec
expr_stmt|;
comment|/* Validate the subnet prefix in the PortGID */
if|if
condition|(
name|p_recvd_mcmember_rec
operator|->
name|port_gid
operator|.
name|unicast
operator|.
name|prefix
operator|!=
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|subnet_prefix
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"PortGID subnet prefix 0x%"
name|PRIx64
literal|" does not match configured prefix 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_recvd_mcmember_rec
operator|->
name|port_gid
operator|.
name|unicast
operator|.
name|prefix
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|subnet_prefix
argument_list|)
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_INVALID_GID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
block|{
name|osm_physp_t
modifier|*
name|p_req_physp
decl_stmt|;
name|p_req_physp
operator|=
name|osm_get_physp_by_mad_addr
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|sa
operator|->
name|p_subn
argument_list|,
name|osm_madw_get_mad_addr_ptr
argument_list|(
name|p_madw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_req_physp
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B03: "
literal|"Cannot find requester physical port\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Requester port GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_req_physp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Dump of incoming record\n"
argument_list|)
expr_stmt|;
name|osm_dump_mc_record_v2
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
operator|&
name|mcmember_rec
argument_list|,
name|FILE_ID
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
expr_stmt|;
block|}
comment|/* make sure the requested port guid is known to the SM */
name|p_port
operator|=
name|osm_get_port_by_alias_guid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|portguid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
block|{
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Unknown port GUID 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|portguid
argument_list|)
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_physp
operator|=
name|p_port
operator|->
name|p_physp
expr_stmt|;
comment|/* Check that the p_physp and the requester physp are in the same 	   partition. */
name|p_request_physp
operator|=
name|osm_get_physp_by_mad_addr
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|sa
operator|->
name|p_subn
argument_list|,
name|osm_madw_get_mad_addr_ptr
argument_list|(
name|p_madw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_request_physp
operator|==
name|NULL
condition|)
block|{
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|proxy
operator|=
operator|(
name|p_physp
operator|!=
name|p_request_physp
operator|)
expr_stmt|;
if|if
condition|(
name|proxy
operator|&&
operator|!
name|osm_physp_share_pkey
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_physp
argument_list|,
name|p_request_physp
argument_list|,
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|allow_both_pkeys
argument_list|)
condition|)
block|{
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Port and requester don't share PKey\n"
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|(
name|p_sa_mad
operator|->
name|comp_mask
operator|&
name|IB_MCR_COMPMASK_PKEY
operator|)
operator|&&
name|ib_pkey_is_invalid
argument_list|(
name|p_recvd_mcmember_rec
operator|->
name|pkey
argument_list|)
condition|)
block|{
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Invalid PKey supplied in request\n"
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|ib_member_get_scope_state
argument_list|(
name|p_recvd_mcmember_rec
operator|->
name|scope_state
argument_list|,
name|NULL
argument_list|,
operator|&
name|join_state
argument_list|)
expr_stmt|;
comment|/* do we need to create a new group? */
name|p_mgrp
operator|=
name|osm_get_mgrp_by_mgid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
operator|&
name|p_recvd_mcmember_rec
operator|->
name|mgid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_mgrp
condition|)
block|{
comment|/* check for JoinState.FullMember = 1 o15.0.1.9 */
if|if
condition|(
operator|(
name|join_state
operator|&
literal|0x01
operator|)
operator|!=
literal|0x01
condition|)
block|{
name|char
name|gid_str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B10: "
literal|"Failed to create multicast group "
literal|"because Join State != FullMember, "
literal|"MGID: %s from port 0x%016"
name|PRIx64
literal|" (%s)\n"
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|p_recvd_mcmember_rec
operator|->
name|mgid
operator|.
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
name|gid_str
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|portguid
argument_list|)
argument_list|,
name|p_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* check the comp_mask */
if|if
condition|(
operator|!
name|check_create_comp_mask
argument_list|(
name|p_sa_mad
operator|->
name|comp_mask
argument_list|,
name|p_recvd_mcmember_rec
argument_list|)
condition|)
block|{
name|char
name|gid_str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B11: "
literal|"Port 0x%016"
name|PRIx64
literal|" (%s) failed to join "
literal|"non-existing multicast group with MGID %s, "
literal|"insufficient components specified for "
literal|"implicit create (comp_mask 0x%"
name|PRIx64
literal|")\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|portguid
argument_list|)
argument_list|,
name|p_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|p_recvd_mcmember_rec
operator|->
name|mgid
operator|.
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
name|gid_str
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_sa_mad
operator|->
name|comp_mask
argument_list|)
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_INSUF_COMPS
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|status
operator|=
name|mcmr_rcv_create_new_mgrp
argument_list|(
name|sa
argument_list|,
name|p_sa_mad
operator|->
name|comp_mask
argument_list|,
name|p_recvd_mcmember_rec
argument_list|,
name|p_physp
argument_list|,
operator|&
name|p_mgrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|status
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* copy the MGID to the result */
name|mcmember_rec
operator|.
name|mgid
operator|=
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|mgid
expr_stmt|;
name|is_new_group
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* no need for a new group */
name|is_new_group
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|mcgroup_join_validation
operator|&&
operator|!
name|validate_other_comp_fields
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_sa_mad
operator|->
name|comp_mask
argument_list|,
name|p_recvd_mcmember_rec
argument_list|,
name|p_mgrp
argument_list|,
name|OSM_LOG_ERROR
argument_list|)
condition|)
block|{
name|char
name|gid_str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B1A: "
literal|"validate_other_comp_fields failed for "
literal|"MGID: %s port 0x%016"
name|PRIx64
literal|" (%s), sending IB_SA_MAD_STATUS_REQ_INVALID\n"
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|mgid
operator|.
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
name|gid_str
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|portguid
argument_list|)
argument_list|,
name|p_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
name|CL_ASSERT
argument_list|(
name|p_mgrp
argument_list|)
expr_stmt|;
comment|/* 	 * o15-0.2.4: If SA supports UD multicast, then SA shall cause an 	 * endport to join an existing multicast group if: 	 * 1. It receives a SubnAdmSet() method for a MCMemberRecord, and 	 *    - WE KNOW THAT ALREADY 	 * 2. The MGID is specified and matches an existing multicast 	 *    group, and 	 *    - WE KNOW THAT ALREADY 	 * 3. The MCMemberRecord:JoinState is not all 0s, and 	 * 4. PortGID is specified and 	 *    - WE KNOW THAT ALREADY (as it matched a real one) 	 * 5. All other components match that existing group, either by 	 *    being wildcarded or by having values identical to those specified 	 *    by the component mask and in use by the group with the exception 	 *    of components such as ProxyJoin and Reserved, which are ignored 	 *    by SA. 	 * 	 * We need to check #3 and #5 here: 	 */
if|if
condition|(
operator|!
name|validate_more_comp_fields
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_mgrp
argument_list|,
name|p_recvd_mcmember_rec
argument_list|,
name|p_sa_mad
operator|->
name|comp_mask
argument_list|)
operator|||
operator|!
name|validate_port_caps
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_mgrp
argument_list|,
name|p_physp
argument_list|)
operator|||
operator|!
operator|(
name|join_state
operator|!=
literal|0
operator|)
condition|)
block|{
name|char
name|gid_str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
comment|/* since we might have created the new group we need to cleanup */
if|if
condition|(
name|is_new_group
condition|)
name|osm_mgrp_cleanup
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|p_mgrp
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B12: "
literal|"validate_more_comp_fields, validate_port_caps, "
literal|"or JoinState = 0 failed for MGID: %s port 0x%016"
name|PRIx64
literal|" (%s), sending IB_SA_MAD_STATUS_REQ_INVALID\n"
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|mgid
operator|.
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
name|gid_str
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|portguid
argument_list|)
argument_list|,
name|p_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* verify that the joining port is in the partition of the group */
if|if
condition|(
operator|!
name|osm_physp_has_pkey
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|pkey
argument_list|,
name|p_physp
argument_list|)
condition|)
block|{
name|char
name|gid_str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
if|if
condition|(
name|is_new_group
condition|)
name|osm_mgrp_cleanup
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|p_mgrp
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|gid_str
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gid_str
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B14: "
literal|"Cannot join port 0x%016"
name|PRIx64
literal|" to MGID %s - "
literal|"Port is not in partition of this MC group\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|portguid
argument_list|)
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|mgid
operator|.
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
argument_list|(
name|gid_str
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	 * o15-0.2.1 requires validation of the requesting port 	 * in the case of modification: 	 */
if|if
condition|(
operator|!
name|is_new_group
operator|&&
operator|!
name|validate_modify
argument_list|(
name|sa
argument_list|,
name|p_mgrp
argument_list|,
name|osm_madw_get_mad_addr_ptr
argument_list|(
name|p_madw
argument_list|)
argument_list|,
name|p_recvd_mcmember_rec
argument_list|,
operator|&
name|p_mcm_alias_guid
argument_list|)
condition|)
block|{
name|char
name|gid_str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B13: "
literal|"validate_modify failed from port 0x%016"
name|PRIx64
literal|" (%s) for MGID: %s, sending IB_SA_MAD_STATUS_REQ_INVALID\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|portguid
argument_list|)
argument_list|,
name|p_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|mgid
operator|.
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
argument_list|(
name|gid_str
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* copy qkey mlid tclass pkey sl_flow_hop mtu rate pkt_life */
name|copy_from_create_mc_rec
argument_list|(
operator|&
name|mcmember_rec
argument_list|,
operator|&
name|p_mgrp
operator|->
name|mcmember_rec
argument_list|)
expr_stmt|;
comment|/* create or update existing port (join-state will be updated) */
name|p_mcmr_port
operator|=
name|osm_mgrp_add_port
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|sa
operator|->
name|p_log
argument_list|,
name|p_mgrp
argument_list|,
name|p_port
argument_list|,
operator|&
name|mcmember_rec
argument_list|,
name|proxy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_mcmr_port
condition|)
block|{
comment|/* we fail to add the port so we might need to delete the group */
if|if
condition|(
name|is_new_group
condition|)
name|osm_mgrp_cleanup
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|p_mgrp
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B06: "
literal|"osm_mgrp_add_port failed\n"
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_NO_RESOURCES
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Release the lock as we don't need it. */
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
name|osm_dump_mc_record_v2
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
operator|&
name|mcmember_rec
argument_list|,
name|FILE_ID
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
expr_stmt|;
name|mcmr_rcv_respond
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
operator|&
name|mcmember_rec
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Add a patched multicast group to the results list **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|mcmr_rcv_new_mcmr
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|ib_member_rec_t
modifier|*
name|p_rcvd_rec
parameter_list|,
name|IN
name|cl_qlist_t
modifier|*
name|p_list
parameter_list|)
block|{
name|osm_sa_item_t
modifier|*
name|p_rec_item
decl_stmt|;
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_rec_item
operator|=
name|malloc
argument_list|(
name|SA_MCM_RESP_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_rec_item
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B15: "
literal|"rec_item alloc failed\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_INSUFFICIENT_RESOURCES
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|memset
argument_list|(
name|p_rec_item
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cl_list_item_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* HACK: Untrusted requesters should result with 0 Join 	   State, Port Guid, and Proxy */
name|p_rec_item
operator|->
name|resp
operator|.
name|mc_rec
operator|=
operator|*
name|p_rcvd_rec
expr_stmt|;
name|cl_qlist_insert_tail
argument_list|(
name|p_list
argument_list|,
operator|&
name|p_rec_item
operator|->
name|list_item
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Match the given mgrp to the requested mcmr **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|mcmr_by_comp_mask
parameter_list|(
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
specifier|const
name|ib_member_rec_t
modifier|*
name|p_rcvd_rec
parameter_list|,
name|ib_net64_t
name|comp_mask
parameter_list|,
name|osm_mgrp_t
modifier|*
name|p_mgrp
parameter_list|,
specifier|const
name|osm_physp_t
modifier|*
name|p_req_physp
parameter_list|,
name|boolean_t
name|trusted_req
parameter_list|,
name|cl_qlist_t
modifier|*
name|list
parameter_list|)
block|{
comment|/* since we might change scope_state */
name|ib_member_rec_t
name|match_rec
decl_stmt|;
name|osm_mcm_alias_guid_t
modifier|*
name|p_mcm_alias_guid
decl_stmt|;
name|ib_net64_t
name|portguid
init|=
name|p_rcvd_rec
operator|->
name|port_gid
operator|.
name|unicast
operator|.
name|interface_id
decl_stmt|;
comment|/* will be used for group or port info */
name|uint8_t
name|scope_state
decl_stmt|;
name|uint8_t
name|scope_state_mask
init|=
literal|0
decl_stmt|;
name|cl_map_item_t
modifier|*
name|p_item
decl_stmt|;
name|ib_gid_t
name|port_gid
decl_stmt|;
name|boolean_t
name|proxy_join
init|=
name|FALSE
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Checking mlid:0x%X\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_mgrp
operator|->
name|mlid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* first try to eliminate the group by MGID, MLID, or P_Key */
if|if
condition|(
operator|(
name|IB_MCR_COMPMASK_MGID
operator|&
name|comp_mask
operator|)
operator|&&
name|memcmp
argument_list|(
operator|&
name|p_rcvd_rec
operator|->
name|mgid
argument_list|,
operator|&
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|mgid
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_gid_t
argument_list|)
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
operator|(
name|IB_MCR_COMPMASK_MLID
operator|&
name|comp_mask
operator|)
operator|&&
name|memcmp
argument_list|(
operator|&
name|p_rcvd_rec
operator|->
name|mlid
argument_list|,
operator|&
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|mlid
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* if the requester physical port doesn't have the pkey that is defined 	   for the group - exit. */
if|if
condition|(
operator|!
name|osm_physp_has_pkey
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|pkey
argument_list|,
name|p_req_physp
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* now do the rest of the match */
if|if
condition|(
operator|!
name|validate_other_comp_fields
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|comp_mask
argument_list|,
name|p_rcvd_rec
argument_list|,
name|p_mgrp
argument_list|,
name|OSM_LOG_NONE
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
operator|(
name|IB_MCR_COMPMASK_PROXY
operator|&
name|comp_mask
operator|)
operator|&&
name|p_rcvd_rec
operator|->
name|proxy_join
operator|!=
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|proxy_join
condition|)
goto|goto
name|Exit
goto|;
comment|/* need to validate mtu, rate, and pkt_lifetime fields */
if|if
condition|(
name|validate_more_comp_fields
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_mgrp
argument_list|,
name|p_rcvd_rec
argument_list|,
name|comp_mask
argument_list|)
operator|==
name|FALSE
condition|)
goto|goto
name|Exit
goto|;
comment|/* Port specific fields */
comment|/* so did we get the PortGUID mask */
if|if
condition|(
name|IB_MCR_COMPMASK_PORT_GID
operator|&
name|comp_mask
condition|)
block|{
comment|/* try to find this port */
name|p_mcm_alias_guid
operator|=
name|osm_mgrp_get_mcm_alias_guid
argument_list|(
name|p_mgrp
argument_list|,
name|portguid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_mcm_alias_guid
condition|)
comment|/* port not in group */
goto|goto
name|Exit
goto|;
name|scope_state
operator|=
name|p_mcm_alias_guid
operator|->
name|scope_state
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|port_gid
argument_list|,
operator|&
operator|(
name|p_mcm_alias_guid
operator|->
name|port_gid
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_gid_t
argument_list|)
argument_list|)
expr_stmt|;
name|proxy_join
operator|=
name|p_mcm_alias_guid
operator|->
name|proxy_join
expr_stmt|;
block|}
else|else
comment|/* point to the group information */
name|scope_state
operator|=
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|scope_state
expr_stmt|;
if|if
condition|(
name|IB_MCR_COMPMASK_SCOPE
operator|&
name|comp_mask
condition|)
name|scope_state_mask
operator|=
literal|0xF0
expr_stmt|;
if|if
condition|(
name|IB_MCR_COMPMASK_JOIN_STATE
operator|&
name|comp_mask
condition|)
name|scope_state_mask
operator|=
name|scope_state_mask
operator||
literal|0x0F
expr_stmt|;
comment|/* Many MC records returned */
if|if
condition|(
name|trusted_req
operator|==
name|TRUE
operator|&&
operator|!
operator|(
name|IB_MCR_COMPMASK_PORT_GID
operator|&
name|comp_mask
operator|)
condition|)
block|{
name|char
name|gid_str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Trusted req is TRUE and no specific port defined\n"
argument_list|)
expr_stmt|;
comment|/* return all the ports that match in this MC group */
name|p_item
operator|=
name|cl_qmap_head
argument_list|(
operator|&
operator|(
name|p_mgrp
operator|->
name|mcm_alias_port_tbl
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_item
operator|!=
name|cl_qmap_end
argument_list|(
operator|&
operator|(
name|p_mgrp
operator|->
name|mcm_alias_port_tbl
operator|)
argument_list|)
condition|)
block|{
name|p_mcm_alias_guid
operator|=
operator|(
name|osm_mcm_alias_guid_t
operator|*
operator|)
name|p_item
expr_stmt|;
if|if
condition|(
operator|(
name|scope_state_mask
operator|&
name|p_rcvd_rec
operator|->
name|scope_state
operator|)
operator|==
operator|(
name|scope_state_mask
operator|&
name|p_mcm_alias_guid
operator|->
name|scope_state
operator|)
condition|)
block|{
comment|/* add to the list */
name|match_rec
operator|=
name|p_mgrp
operator|->
name|mcmember_rec
expr_stmt|;
name|match_rec
operator|.
name|scope_state
operator|=
name|p_mcm_alias_guid
operator|->
name|scope_state
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|match_rec
operator|.
name|port_gid
argument_list|,
operator|&
name|p_mcm_alias_guid
operator|->
name|port_gid
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_gid_t
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Record of port_gid: %s"
literal|" in multicast_lid: 0x%X is returned\n"
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|match_rec
operator|.
name|port_gid
operator|.
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
name|gid_str
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_mgrp
operator|->
name|mlid
argument_list|)
argument_list|)
expr_stmt|;
name|match_rec
operator|.
name|proxy_join
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_mcm_alias_guid
operator|->
name|proxy_join
argument_list|)
expr_stmt|;
name|mcmr_rcv_new_mcmr
argument_list|(
name|sa
argument_list|,
operator|&
name|match_rec
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|p_item
operator|=
name|cl_qmap_next
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* One MC record returned */
if|if
condition|(
operator|(
name|scope_state_mask
operator|&
name|p_rcvd_rec
operator|->
name|scope_state
operator|)
operator|!=
operator|(
name|scope_state_mask
operator|&
name|scope_state
operator|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* add to the list */
name|match_rec
operator|=
name|p_mgrp
operator|->
name|mcmember_rec
expr_stmt|;
name|match_rec
operator|.
name|scope_state
operator|=
name|scope_state
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
name|match_rec
operator|.
name|port_gid
operator|)
argument_list|,
operator|&
name|port_gid
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_gid_t
argument_list|)
argument_list|)
expr_stmt|;
name|match_rec
operator|.
name|proxy_join
operator|=
operator|(
name|uint8_t
operator|)
name|proxy_join
expr_stmt|;
name|mcmr_rcv_new_mcmr
argument_list|(
name|sa
argument_list|,
operator|&
name|match_rec
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Handle a query request **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|mcmr_query_mgrp
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|)
block|{
specifier|const
name|ib_sa_mad_t
modifier|*
name|p_rcvd_mad
decl_stmt|;
specifier|const
name|ib_member_rec_t
modifier|*
name|p_rcvd_rec
decl_stmt|;
name|cl_qlist_t
name|rec_list
decl_stmt|;
name|ib_net64_t
name|comp_mask
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_req_physp
decl_stmt|;
name|boolean_t
name|trusted_req
decl_stmt|;
name|osm_mgrp_t
modifier|*
name|p_mgrp
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_rcvd_mad
operator|=
name|osm_madw_get_sa_mad_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_rcvd_rec
operator|=
operator|(
name|ib_member_rec_t
operator|*
operator|)
name|ib_sa_mad_get_payload_ptr
argument_list|(
name|p_rcvd_mad
argument_list|)
expr_stmt|;
name|comp_mask
operator|=
name|p_rcvd_mad
operator|->
name|comp_mask
expr_stmt|;
comment|/* 	   if sm_key is not zero and does not match we never get here 	   see main SA receiver 	 */
name|trusted_req
operator|=
operator|(
name|p_rcvd_mad
operator|->
name|sm_key
operator|!=
literal|0
operator|)
expr_stmt|;
name|CL_PLOCK_ACQUIRE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
comment|/* update the requester physical port */
name|p_req_physp
operator|=
name|osm_get_physp_by_mad_addr
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|sa
operator|->
name|p_subn
argument_list|,
name|osm_madw_get_mad_addr_ptr
argument_list|(
name|p_madw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_req_physp
operator|==
name|NULL
condition|)
block|{
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B04: "
literal|"Cannot find requester physical port\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Requester port GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_req_physp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Dump of record\n"
argument_list|)
expr_stmt|;
name|osm_dump_mc_record
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_rcvd_rec
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
expr_stmt|;
block|}
name|cl_qlist_init
argument_list|(
operator|&
name|rec_list
argument_list|)
expr_stmt|;
comment|/* simply go over all MCGs and match */
for|for
control|(
name|p_mgrp
operator|=
operator|(
name|osm_mgrp_t
operator|*
operator|)
name|cl_fmap_head
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|mgrp_mgid_tbl
argument_list|)
init|;
name|p_mgrp
operator|!=
operator|(
name|osm_mgrp_t
operator|*
operator|)
name|cl_fmap_end
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|mgrp_mgid_tbl
argument_list|)
condition|;
name|p_mgrp
operator|=
operator|(
name|osm_mgrp_t
operator|*
operator|)
name|cl_fmap_next
argument_list|(
operator|&
name|p_mgrp
operator|->
name|map_item
argument_list|)
control|)
name|mcmr_by_comp_mask
argument_list|(
name|sa
argument_list|,
name|p_rcvd_rec
argument_list|,
name|comp_mask
argument_list|,
name|p_mgrp
argument_list|,
name|p_req_physp
argument_list|,
name|trusted_req
argument_list|,
operator|&
name|rec_list
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
comment|/* 	   p923 - The PortGID, JoinState and ProxyJoin shall be zero, 	   except in the case of a trusted request. 	   Note: In the mad controller we check that the SM_Key received on 	   the mad is valid. Meaning - is either zero or equal to the local 	   sm_key. 	 */
if|if
condition|(
operator|!
name|p_rcvd_mad
operator|->
name|sm_key
condition|)
block|{
name|osm_sa_item_t
modifier|*
name|item
decl_stmt|;
for|for
control|(
name|item
operator|=
operator|(
name|osm_sa_item_t
operator|*
operator|)
name|cl_qlist_head
argument_list|(
operator|&
name|rec_list
argument_list|)
init|;
name|item
operator|!=
operator|(
name|osm_sa_item_t
operator|*
operator|)
name|cl_qlist_end
argument_list|(
operator|&
name|rec_list
argument_list|)
condition|;
name|item
operator|=
operator|(
name|osm_sa_item_t
operator|*
operator|)
name|cl_qlist_next
argument_list|(
operator|&
name|item
operator|->
name|list_item
argument_list|)
control|)
block|{
name|memset
argument_list|(
operator|&
name|item
operator|->
name|resp
operator|.
name|mc_rec
operator|.
name|port_gid
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_gid_t
argument_list|)
argument_list|)
expr_stmt|;
name|ib_member_set_join_state
argument_list|(
operator|&
name|item
operator|->
name|resp
operator|.
name|mc_rec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|item
operator|->
name|resp
operator|.
name|mc_rec
operator|.
name|proxy_join
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|osm_sa_respond
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_member_rec_t
argument_list|)
argument_list|,
operator|&
name|rec_list
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|rate_is_valid
parameter_list|(
name|IN
specifier|const
name|ib_sa_mad_t
modifier|*
name|p_sa_mad
parameter_list|,
name|IN
specifier|const
name|ib_member_rec_t
modifier|*
name|p_recvd_mcmember_rec
parameter_list|)
block|{
name|uint8_t
name|rate
decl_stmt|;
comment|/* Validate rate if supplied */
if|if
condition|(
operator|(
name|p_sa_mad
operator|->
name|comp_mask
operator|&
name|IB_MCR_COMPMASK_RATE_SEL
operator|)
operator|&&
operator|(
name|p_sa_mad
operator|->
name|comp_mask
operator|&
name|IB_MCR_COMPMASK_RATE
operator|)
condition|)
block|{
name|rate
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_recvd_mcmember_rec
operator|->
name|rate
operator|&
literal|0x3F
argument_list|)
expr_stmt|;
return|return
name|ib_rate_is_valid
argument_list|(
name|rate
argument_list|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mtu_is_valid
parameter_list|(
name|IN
specifier|const
name|ib_sa_mad_t
modifier|*
name|p_sa_mad
parameter_list|,
name|IN
specifier|const
name|ib_member_rec_t
modifier|*
name|p_recvd_mcmember_rec
parameter_list|)
block|{
name|uint8_t
name|mtu
decl_stmt|;
comment|/* Validate MTU if supplied */
if|if
condition|(
operator|(
name|p_sa_mad
operator|->
name|comp_mask
operator|&
name|IB_MCR_COMPMASK_MTU_SEL
operator|)
operator|&&
operator|(
name|p_sa_mad
operator|->
name|comp_mask
operator|&
name|IB_MCR_COMPMASK_MTU
operator|)
condition|)
block|{
name|mtu
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_recvd_mcmember_rec
operator|->
name|mtu
operator|&
literal|0x3F
argument_list|)
expr_stmt|;
return|return
name|ib_mtu_is_valid
argument_list|(
name|mtu
argument_list|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|osm_mcmr_rcv_process
parameter_list|(
name|IN
name|void
modifier|*
name|context
parameter_list|,
name|IN
name|void
modifier|*
name|data
parameter_list|)
block|{
name|osm_sa_t
modifier|*
name|sa
init|=
name|context
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_madw
init|=
name|data
decl_stmt|;
name|ib_sa_mad_t
modifier|*
name|p_sa_mad
decl_stmt|;
name|ib_member_rec_t
modifier|*
name|p_recvd_mcmember_rec
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|sa
argument_list|)
expr_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_sa_mad
operator|=
name|osm_madw_get_sa_mad_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_recvd_mcmember_rec
operator|=
operator|(
name|ib_member_rec_t
operator|*
operator|)
name|ib_sa_mad_get_payload_ptr
argument_list|(
name|p_sa_mad
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_sa_mad
operator|->
name|attr_id
operator|==
name|IB_MAD_ATTR_MCMEMBER_RECORD
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_sa_mad
operator|->
name|method
condition|)
block|{
case|case
name|IB_MAD_METHOD_SET
case|:
if|if
condition|(
operator|!
name|check_join_comp_mask
argument_list|(
name|p_sa_mad
operator|->
name|comp_mask
argument_list|)
condition|)
block|{
name|char
name|gid_str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|char
name|gid_str2
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B18: "
literal|"component mask = 0x%016"
name|PRIx64
literal|", "
literal|"expected comp mask = 0x%016"
name|PRIx64
literal|", "
literal|"MGID: %s for PortGID: %s\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_sa_mad
operator|->
name|comp_mask
argument_list|)
argument_list|,
name|CL_NTOH64
argument_list|(
name|JOIN_MC_COMP_MASK
argument_list|)
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|p_recvd_mcmember_rec
operator|->
name|mgid
operator|.
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
name|gid_str
argument_list|)
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|p_recvd_mcmember_rec
operator|->
name|port_gid
operator|.
name|raw
argument_list|,
name|gid_str2
argument_list|,
sizeof|sizeof
name|gid_str2
argument_list|)
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_INSUF_COMPS
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|!
name|rate_is_valid
argument_list|(
name|p_sa_mad
argument_list|,
name|p_recvd_mcmember_rec
argument_list|)
operator|||
operator|!
name|mtu_is_valid
argument_list|(
name|p_sa_mad
argument_list|,
name|p_recvd_mcmember_rec
argument_list|)
condition|)
block|{
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 		 * Join or Create Multicast Group 		 */
name|mcmr_rcv_join_mgrp
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_MAD_METHOD_DELETE
case|:
if|if
condition|(
operator|!
name|check_join_comp_mask
argument_list|(
name|p_sa_mad
operator|->
name|comp_mask
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B20: "
literal|"component mask = 0x%016"
name|PRIx64
literal|", "
literal|"expected comp mask = 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_sa_mad
operator|->
name|comp_mask
argument_list|)
argument_list|,
name|CL_NTOH64
argument_list|(
name|JOIN_MC_COMP_MASK
argument_list|)
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_INSUF_COMPS
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|!
name|rate_is_valid
argument_list|(
name|p_sa_mad
argument_list|,
name|p_recvd_mcmember_rec
argument_list|)
operator|||
operator|!
name|mtu_is_valid
argument_list|(
name|p_sa_mad
argument_list|,
name|p_recvd_mcmember_rec
argument_list|)
condition|)
block|{
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 		 * Leave Multicast Group 		 */
name|mcmr_rcv_leave_mgrp
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_MAD_METHOD_GET
case|:
case|case
name|IB_MAD_METHOD_GETTABLE
case|:
if|if
condition|(
operator|!
name|rate_is_valid
argument_list|(
name|p_sa_mad
argument_list|,
name|p_recvd_mcmember_rec
argument_list|)
operator|||
operator|!
name|mtu_is_valid
argument_list|(
name|p_sa_mad
argument_list|,
name|p_recvd_mcmember_rec
argument_list|)
condition|)
block|{
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 		 * Querying a Multicast Group 		 */
name|mcmr_query_mgrp
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
break|break;
default|default:
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B21: "
literal|"Unsupported Method (%s) for MCMemberRecord request\n"
argument_list|,
name|ib_get_sa_method_str
argument_list|(
name|p_sa_mad
operator|->
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_MAD_STATUS_UNSUP_METHOD_ATTR
argument_list|)
expr_stmt|;
break|break;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

