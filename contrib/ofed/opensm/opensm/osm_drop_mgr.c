begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2015 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  * Copyright (c) 2008 Xsigo Systems Inc.  All rights reserved.  * Copyright (c) 2013 Oracle and/or its affiliates. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_drop_mgr_t.  * This object represents the Drop Manager object.  * This object is part of the opensm family of objects.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qmap.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_passivelock.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_ptr_vector.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_DROP_MGR_C
end_define

begin_include
include|#
directive|include
file|<opensm/osm_sm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_router.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_switch.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_node.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_guid.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_multicast.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_remote_sm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_inform.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_ucast_mgr.h>
end_include

begin_function
specifier|static
name|void
name|drop_mgr_remove_router
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
specifier|const
name|ib_net64_t
name|portguid
parameter_list|)
block|{
name|osm_router_t
modifier|*
name|p_rtr
decl_stmt|;
name|cl_qmap_t
modifier|*
name|p_rtr_guid_tbl
decl_stmt|;
name|p_rtr_guid_tbl
operator|=
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|rtr_guid_tbl
expr_stmt|;
name|p_rtr
operator|=
operator|(
name|osm_router_t
operator|*
operator|)
name|cl_qmap_remove
argument_list|(
name|p_rtr_guid_tbl
argument_list|,
name|portguid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_rtr
operator|!=
operator|(
name|osm_router_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_rtr_guid_tbl
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Cleaned router for port guid 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|portguid
argument_list|)
argument_list|)
expr_stmt|;
name|osm_router_delete
argument_list|(
operator|&
name|p_rtr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|drop_mgr_clean_physp
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_physp_t
modifier|*
name|p_physp
parameter_list|)
block|{
name|osm_physp_t
modifier|*
name|p_remote_physp
decl_stmt|;
name|osm_port_t
modifier|*
name|p_remote_port
decl_stmt|;
name|p_remote_physp
operator|=
name|osm_physp_get_remote
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_remote_physp
condition|)
block|{
name|p_remote_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|p_remote_physp
operator|->
name|port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_remote_port
condition|)
block|{
comment|/* Let's check if this is a case of link that is lost 			   (both ports weren't recognized), or a "hiccup" in the 			   subnet - in which case the remote port was 			   recognized, and its state is ACTIVE. 			   If this is just a "hiccup" - force a heavy sweep in 			   the next sweep. We don't want to lose that part of 			   the subnet. */
if|if
condition|(
name|p_remote_port
operator|->
name|discovery_count
operator|&&
name|osm_physp_get_port_state
argument_list|(
name|p_remote_physp
argument_list|)
operator|==
name|IB_LINK_ACTIVE
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Forcing new heavy sweep. Remote "
literal|"port 0x%016"
name|PRIx64
literal|" port num: %u "
literal|"was recognized in ACTIVE state\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_remote_physp
operator|->
name|port_guid
argument_list|)
argument_list|,
name|p_remote_physp
operator|->
name|port_num
argument_list|)
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|force_heavy_sweep
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If the remote node is ca or router - need to remove 			   the remote port, since it is no longer reachable. 			   This can be done if we reset the discovery count 			   of the remote port. */
if|if
condition|(
operator|!
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
operator|&&
name|p_remote_physp
operator|->
name|port_guid
operator|!=
name|sm
operator|->
name|p_subn
operator|->
name|sm_port_guid
condition|)
block|{
name|p_remote_port
operator|->
name|discovery_count
operator|=
literal|0
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Resetting discovery count of node: "
literal|"0x%016"
name|PRIx64
literal|" port num:%u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_remote_physp
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|p_remote_physp
operator|->
name|port_num
argument_list|)
expr_stmt|;
block|}
block|}
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Unlinking local node 0x%016"
name|PRIx64
literal|", port %u"
literal|"\n\t\t\t\tand remote node 0x%016"
name|PRIx64
literal|", port %u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_physp
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|p_physp
operator|->
name|port_num
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_remote_physp
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|p_remote_physp
operator|->
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|ucast_mgr
operator|.
name|cache_valid
condition|)
name|osm_ucast_cache_add_link
argument_list|(
operator|&
name|sm
operator|->
name|ucast_mgr
argument_list|,
name|p_physp
argument_list|,
name|p_remote_physp
argument_list|)
expr_stmt|;
name|osm_physp_unlink
argument_list|(
name|p_physp
argument_list|,
name|p_remote_physp
argument_list|)
expr_stmt|;
block|}
comment|/* Make port as undiscovered */
name|p_physp
operator|->
name|p_node
operator|->
name|physp_discovered
index|[
name|p_physp
operator|->
name|port_num
index|]
operator|=
literal|0
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Clearing node 0x%016"
name|PRIx64
literal|" physical port number %u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_physp
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|p_physp
operator|->
name|port_num
argument_list|)
expr_stmt|;
name|osm_physp_destroy
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|drop_mgr_remove_port
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_port_t
modifier|*
name|p_port
parameter_list|)
block|{
name|ib_net64_t
name|port_guid
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port_check
decl_stmt|;
name|cl_qmap_t
modifier|*
name|p_alias_guid_tbl
decl_stmt|;
name|cl_qmap_t
modifier|*
name|p_sm_guid_tbl
decl_stmt|;
name|osm_mcm_port_t
modifier|*
name|mcm_port
decl_stmt|;
name|cl_ptr_vector_t
modifier|*
name|p_port_lid_tbl
decl_stmt|;
name|uint16_t
name|min_lid_ho
decl_stmt|;
name|uint16_t
name|max_lid_ho
decl_stmt|;
name|uint16_t
name|lid_ho
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|osm_remote_sm_t
modifier|*
name|p_sm
decl_stmt|;
name|osm_alias_guid_t
modifier|*
name|p_alias_guid
decl_stmt|,
modifier|*
name|p_alias_guid_check
decl_stmt|;
name|osm_guidinfo_work_obj_t
modifier|*
name|wobj
decl_stmt|;
name|cl_list_item_t
modifier|*
name|item
decl_stmt|,
modifier|*
name|next_item
decl_stmt|;
name|ib_gid_t
name|port_gid
decl_stmt|;
name|ib_mad_notice_attr_t
name|notice
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|port_guid
operator|=
name|osm_port_get_guid
argument_list|(
name|p_port
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Unreachable port 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
name|p_port_check
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_get
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|port_guid_tbl
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_port_check
operator|!=
name|p_port
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0101: "
literal|"Port 0x%016"
name|PRIx64
literal|" not in guid table\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* issue a notice - trap 65 (SM_GID_OUT_OF_SERVICE_TRAP) */
comment|/* details of the notice */
name|notice
operator|.
name|generic_type
operator|=
literal|0x80
operator||
name|IB_NOTICE_TYPE_SUBN_MGMT
expr_stmt|;
comment|/* is generic subn mgt type */
name|ib_notice_set_prod_type_ho
argument_list|(
operator|&
name|notice
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* A class manager generator */
comment|/* endport ceases to be reachable */
name|notice
operator|.
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
operator|=
name|CL_HTON16
argument_list|(
name|SM_GID_OUT_OF_SERVICE_TRAP
argument_list|)
expr_stmt|;
comment|/* 65 */
comment|/* The sm_base_lid is saved in network order already. */
name|notice
operator|.
name|issuer_lid
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|sm_base_lid
expr_stmt|;
comment|/* following C14-72.1.2 and table 119 p725 */
comment|/* we need to provide the GID */
name|port_gid
operator|.
name|unicast
operator|.
name|prefix
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|subnet_prefix
expr_stmt|;
name|port_gid
operator|.
name|unicast
operator|.
name|interface_id
operator|=
name|port_guid
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
name|notice
operator|.
name|data_details
operator|.
name|ntc_64_67
operator|.
name|gid
operator|)
argument_list|,
operator|&
operator|(
name|port_gid
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_gid_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* According to page 653 - the issuer gid in this case of trap 	   is the SM gid, since the SM is the initiator of this trap. */
name|notice
operator|.
name|issuer_gid
operator|.
name|unicast
operator|.
name|prefix
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|subnet_prefix
expr_stmt|;
name|notice
operator|.
name|issuer_gid
operator|.
name|unicast
operator|.
name|interface_id
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|sm_port_guid
expr_stmt|;
name|status
operator|=
name|osm_report_notice
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|sm
operator|->
name|p_subn
argument_list|,
operator|&
name|notice
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0103: "
literal|"Error sending trap reports (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|next_item
operator|=
name|cl_qlist_head
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|alias_guid_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|next_item
operator|!=
name|cl_qlist_end
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|alias_guid_list
argument_list|)
condition|)
block|{
name|item
operator|=
name|next_item
expr_stmt|;
name|next_item
operator|=
name|cl_qlist_next
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|wobj
operator|=
name|cl_item_obj
argument_list|(
name|item
argument_list|,
name|wobj
argument_list|,
name|list_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|wobj
operator|->
name|p_port
operator|==
name|p_port
condition|)
block|{
name|cl_qlist_remove_item
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|alias_guid_list
argument_list|,
operator|&
name|wobj
operator|->
name|list_item
argument_list|)
expr_stmt|;
name|osm_guid_work_obj_delete
argument_list|(
name|wobj
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|!
name|cl_is_qlist_empty
argument_list|(
operator|&
name|p_port
operator|->
name|mcm_list
argument_list|)
condition|)
block|{
name|mcm_port
operator|=
name|cl_item_obj
argument_list|(
name|cl_qlist_head
argument_list|(
operator|&
name|p_port
operator|->
name|mcm_list
argument_list|)
argument_list|,
name|mcm_port
argument_list|,
name|list_item
argument_list|)
expr_stmt|;
name|osm_mgrp_delete_port
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|sm
operator|->
name|p_log
argument_list|,
name|mcm_port
operator|->
name|mgrp
argument_list|,
name|p_port
argument_list|)
expr_stmt|;
block|}
name|p_alias_guid_tbl
operator|=
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|alias_port_guid_tbl
expr_stmt|;
name|p_alias_guid_check
operator|=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_alias_guid_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_alias_guid_check
operator|!=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_alias_guid_tbl
argument_list|)
condition|)
block|{
if|if
condition|(
name|p_alias_guid_check
operator|->
name|p_base_port
operator|==
name|p_port
condition|)
name|p_alias_guid
operator|=
name|p_alias_guid_check
expr_stmt|;
else|else
name|p_alias_guid
operator|=
name|NULL
expr_stmt|;
name|p_alias_guid_check
operator|=
operator|(
name|osm_alias_guid_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_alias_guid_check
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_alias_guid
condition|)
block|{
name|cl_qmap_remove_item
argument_list|(
name|p_alias_guid_tbl
argument_list|,
operator|&
name|p_alias_guid
operator|->
name|map_item
argument_list|)
expr_stmt|;
name|osm_alias_guid_delete
argument_list|(
operator|&
name|p_alias_guid
argument_list|)
expr_stmt|;
block|}
block|}
name|cl_qmap_remove
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|port_guid_tbl
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
name|p_sm_guid_tbl
operator|=
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sm_guid_tbl
expr_stmt|;
name|p_sm
operator|=
operator|(
name|osm_remote_sm_t
operator|*
operator|)
name|cl_qmap_remove
argument_list|(
name|p_sm_guid_tbl
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sm
operator|!=
operator|(
name|osm_remote_sm_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_sm_guid_tbl
argument_list|)
condition|)
block|{
comment|/* need to remove this item */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Cleaned SM for port guid 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_sm
argument_list|)
expr_stmt|;
block|}
name|drop_mgr_remove_router
argument_list|(
name|sm
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
name|osm_port_get_lid_range_ho
argument_list|(
name|p_port
argument_list|,
operator|&
name|min_lid_ho
argument_list|,
operator|&
name|max_lid_ho
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Clearing abandoned LID range [%u,%u]\n"
argument_list|,
name|min_lid_ho
argument_list|,
name|max_lid_ho
argument_list|)
expr_stmt|;
name|p_port_lid_tbl
operator|=
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|port_lid_tbl
expr_stmt|;
for|for
control|(
name|lid_ho
operator|=
name|min_lid_ho
init|;
name|lid_ho
operator|<=
name|max_lid_ho
condition|;
name|lid_ho
operator|++
control|)
name|cl_ptr_vector_set
argument_list|(
name|p_port_lid_tbl
argument_list|,
name|lid_ho
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|drop_mgr_clean_physp
argument_list|(
name|sm
argument_list|,
name|p_port
operator|->
name|p_physp
argument_list|)
expr_stmt|;
comment|/* Delete event forwarding subscriptions */
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|drop_event_subscriptions
condition|)
block|{
if|if
condition|(
name|osm_infr_remove_subscriptions
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|sm
operator|->
name|p_log
argument_list|,
name|port_guid
argument_list|)
operator|==
name|CL_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Removed event subscriptions for port 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* initialize the p_node - may need to get node_desc later */
name|p_node
operator|=
name|p_port
operator|->
name|p_node
expr_stmt|;
name|osm_port_delete
argument_list|(
operator|&
name|p_port
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Removed port with GUID:0x%016"
name|PRIx64
literal|" LID range [%u, %u] of node:%s\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_gid
operator|.
name|unicast
operator|.
name|interface_id
argument_list|)
argument_list|,
name|min_lid_ho
argument_list|,
name|max_lid_ho
argument_list|,
name|p_node
condition|?
name|p_node
operator|->
name|print_desc
else|:
literal|"UNKNOWN"
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|drop_mgr_remove_switch
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
name|p_node
parameter_list|)
block|{
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|cl_qmap_t
modifier|*
name|p_sw_guid_tbl
decl_stmt|;
name|ib_net64_t
name|node_guid
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|p_sw_guid_tbl
operator|=
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
expr_stmt|;
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_remove
argument_list|(
name|p_sw_guid_tbl
argument_list|,
name|node_guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|==
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_sw_guid_tbl
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0102: "
literal|"Node 0x%016"
name|PRIx64
literal|" not in switch table\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p_node
operator|->
name|sw
operator|=
name|NULL
expr_stmt|;
name|osm_switch_delete
argument_list|(
operator|&
name|p_sw
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|drop_mgr_process_node
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
name|p_node
parameter_list|)
block|{
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node_check
decl_stmt|;
name|uint32_t
name|port_num
decl_stmt|;
name|uint32_t
name|max_ports
decl_stmt|;
name|ib_net64_t
name|port_guid
decl_stmt|;
name|boolean_t
name|return_val
init|=
name|FALSE
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Unreachable node 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|ucast_mgr
operator|.
name|cache_valid
condition|)
name|osm_ucast_cache_add_node
argument_list|(
operator|&
name|sm
operator|->
name|ucast_mgr
argument_list|,
name|p_node
argument_list|)
expr_stmt|;
comment|/* 	   Delete all the logical and physical port objects 	   associated with this node. 	 */
name|max_ports
operator|=
name|osm_node_get_num_physp
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
for|for
control|(
name|port_num
operator|=
literal|0
init|;
name|port_num
operator|<
name|max_ports
condition|;
name|port_num
operator|++
control|)
block|{
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_physp
condition|)
block|{
name|port_guid
operator|=
name|osm_physp_get_port_guid
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_port
condition|)
name|drop_mgr_remove_port
argument_list|(
name|sm
argument_list|,
name|p_port
argument_list|)
expr_stmt|;
else|else
name|drop_mgr_clean_physp
argument_list|(
name|sm
argument_list|,
name|p_physp
argument_list|)
expr_stmt|;
block|}
block|}
name|return_val
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|p_node
operator|->
name|sw
condition|)
name|drop_mgr_remove_switch
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|)
expr_stmt|;
name|p_node_check
operator|=
operator|(
name|osm_node_t
operator|*
operator|)
name|cl_qmap_remove
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|node_guid_tbl
argument_list|,
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_node_check
operator|!=
name|p_node
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0105: "
literal|"Node 0x%016"
name|PRIx64
literal|" not in guid table\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* free memory allocated to node */
name|osm_node_delete
argument_list|(
operator|&
name|p_node
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|return_val
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|drop_mgr_check_switch_node
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
name|p_node
parameter_list|)
block|{
name|ib_net64_t
name|node_guid
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|,
modifier|*
name|p_remote_physp
decl_stmt|;
name|osm_node_t
modifier|*
name|p_remote_node
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|ib_net64_t
name|port_guid
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|,
name|remote_port_num
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
comment|/* Make sure we have a switch object for this node */
if|if
condition|(
operator|!
name|p_node
operator|->
name|sw
condition|)
block|{
comment|/* We do not have switch info for this node */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Node 0x%016"
name|PRIx64
literal|" no switch in table\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|node_guid
argument_list|)
argument_list|)
expr_stmt|;
name|drop_mgr_process_node
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Make sure we have a port object for port zero */
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Node 0x%016"
name|PRIx64
literal|" no valid physical port 0\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|node_guid
argument_list|)
argument_list|)
expr_stmt|;
name|drop_mgr_process_node
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|port_guid
operator|=
name|osm_physp_get_port_guid
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Node 0x%016"
name|PRIx64
literal|" has no port object\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|node_guid
argument_list|)
argument_list|)
expr_stmt|;
name|drop_mgr_process_node
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|!
name|p_node
operator|->
name|physp_discovered
index|[
literal|0
index|]
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Node 0x%016"
name|PRIx64
literal|" port has discovery count zero\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|node_guid
argument_list|)
argument_list|)
expr_stmt|;
name|drop_mgr_process_node
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	 * Unlink all ports that havn't been discovered during the last sweep. 	 * Optimization: Skip the check if discovered all the ports of the switch. 	 */
if|if
condition|(
name|p_port
operator|->
name|discovery_count
operator|<
name|p_node
operator|->
name|physp_tbl_size
condition|)
block|{
for|for
control|(
name|port_num
operator|=
literal|1
init|;
name|port_num
operator|<
name|p_node
operator|->
name|physp_tbl_size
condition|;
name|port_num
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|p_node
operator|->
name|physp_discovered
index|[
name|port_num
index|]
condition|)
block|{
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
condition|)
continue|continue;
name|p_remote_physp
operator|=
name|osm_physp_get_remote
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_remote_physp
condition|)
continue|continue;
name|p_remote_node
operator|=
name|osm_physp_get_node_ptr
argument_list|(
name|p_remote_physp
argument_list|)
expr_stmt|;
name|remote_port_num
operator|=
name|osm_physp_get_port_num
argument_list|(
name|p_remote_physp
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Unlinking local node 0x%"
name|PRIx64
literal|", port %u"
literal|"\n\t\t\t\tand remote node 0x%"
name|PRIx64
literal|", port %u due to missing PortInfo\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|port_num
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_remote_node
argument_list|)
argument_list|)
argument_list|,
name|remote_port_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|ucast_mgr
operator|.
name|cache_valid
condition|)
name|osm_ucast_cache_add_link
argument_list|(
operator|&
name|sm
operator|->
name|ucast_mgr
argument_list|,
name|p_physp
argument_list|,
name|p_remote_physp
argument_list|)
expr_stmt|;
name|osm_node_unlink
argument_list|(
name|p_node
argument_list|,
operator|(
name|uint8_t
operator|)
name|port_num
argument_list|,
name|p_remote_node
argument_list|,
operator|(
name|uint8_t
operator|)
name|remote_port_num
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|osm_drop_mgr_process
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|cl_qmap_t
modifier|*
name|p_node_guid_tbl
decl_stmt|,
modifier|*
name|p_port_guid_tbl
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|,
modifier|*
name|p_next_port
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
decl_stmt|,
modifier|*
name|p_next_node
decl_stmt|;
name|int
name|max_ports
decl_stmt|,
name|port_num
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|ib_net64_t
name|port_guid
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_node_guid_tbl
operator|=
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|node_guid_tbl
expr_stmt|;
name|p_port_guid_tbl
operator|=
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|port_guid_tbl
expr_stmt|;
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|p_next_node
operator|=
operator|(
name|osm_node_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_node_guid_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_node
operator|!=
operator|(
name|osm_node_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_node_guid_tbl
argument_list|)
condition|)
block|{
name|p_node
operator|=
name|p_next_node
expr_stmt|;
name|p_next_node
operator|=
operator|(
name|osm_node_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_next_node
operator|->
name|map_item
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|cl_qmap_key
argument_list|(
operator|&
name|p_node
operator|->
name|map_item
argument_list|)
operator|==
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Checking node 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		   Check if this node was discovered during the last sweep. 		   If not, it is unreachable in the current subnet, and 		   should therefore be removed from the subnet object. 		 */
if|if
condition|(
name|p_node
operator|->
name|discovery_count
operator|==
literal|0
condition|)
name|drop_mgr_process_node
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 			 * We want to preserve the configured pkey indexes, 			 * so if we don't receive GetResp P_KeyTable for some block, 			 * do the following: 			 *   1. Drop node if the node is sw and got timeout for port 0. 			 *   2. Drop node if node is HCA/RTR. 			 *   3. Drop only physp if got timeout for sw when the port isn't 0. 			 * We'll set error during initialization in order to 			 * cause an immediate heavy sweep and try to get the 			 * configured P_KeyTable again. 			 */
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|p_node
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
condition|)
name|port_num
operator|=
literal|0
expr_stmt|;
else|else
name|port_num
operator|=
literal|1
expr_stmt|;
name|max_ports
operator|=
name|osm_node_get_num_physp
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|port_num
operator|<
name|max_ports
condition|;
name|port_num
operator|++
control|)
block|{
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
operator|||
name|p_physp
operator|->
name|pkeys
operator|.
name|rcv_blocks_cnt
operator|==
literal|0
condition|)
continue|continue;
name|p_physp
operator|->
name|pkeys
operator|.
name|rcv_blocks_cnt
operator|=
literal|0
expr_stmt|;
name|p_physp
operator|->
name|need_update
operator|=
literal|2
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|subnet_initialization_error
operator|=
name|TRUE
expr_stmt|;
name|port_guid
operator|=
name|osm_physp_get_port_guid
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_node
operator|->
name|physp_discovered
index|[
name|port_num
index|]
condition|)
block|{
name|p_node
operator|->
name|physp_discovered
index|[
name|port_num
index|]
operator|=
literal|0
expr_stmt|;
name|p_port
operator|->
name|discovery_count
operator|--
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	   Go over all the nodes. If the node is a switch - make sure 	   there is also a switch record for it, and a portInfo record for 	   port zero of of the node. 	   If not - this means that there was some error in getting the data 	   of this node. Drop the node. 	 */
name|p_next_node
operator|=
operator|(
name|osm_node_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_node_guid_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_node
operator|!=
operator|(
name|osm_node_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_node_guid_tbl
argument_list|)
condition|)
block|{
name|p_node
operator|=
name|p_next_node
expr_stmt|;
name|p_next_node
operator|=
operator|(
name|osm_node_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_next_node
operator|->
name|map_item
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Checking full discovery of node 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|p_node
argument_list|)
operator|!=
name|IB_NODE_TYPE_SWITCH
condition|)
continue|continue;
comment|/* We are handling a switch node */
name|drop_mgr_check_switch_node
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|)
expr_stmt|;
block|}
name|p_next_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_port_guid_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_port
operator|!=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_port_guid_tbl
argument_list|)
condition|)
block|{
name|p_port
operator|=
name|p_next_port
expr_stmt|;
name|p_next_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_next_port
operator|->
name|map_item
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|cl_qmap_key
argument_list|(
operator|&
name|p_port
operator|->
name|map_item
argument_list|)
operator|==
name|osm_port_get_guid
argument_list|(
name|p_port
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Checking port 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_port_get_guid
argument_list|(
name|p_port
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		   If the port is unreachable, remove it from the guid table. 		 */
if|if
condition|(
name|p_port
operator|->
name|discovery_count
operator|==
literal|0
condition|)
name|drop_mgr_remove_port
argument_list|(
name|sm
argument_list|,
name|p_port
argument_list|)
expr_stmt|;
block|}
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

