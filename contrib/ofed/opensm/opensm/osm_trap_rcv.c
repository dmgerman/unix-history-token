begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2007 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  * Copyright (c) 2009,2010 HNR Consulting. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_trap_rcv_t.  * This object represents the Trap Receiver object.  * This object is part of the opensm family of objects.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qmap.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_file_ids.h>
end_include

begin_define
define|#
directive|define
name|FILE_ID
value|OSM_FILE_TRAP_RCV_C
end_define

begin_include
include|#
directive|include
file|<opensm/osm_madw.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_node.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_subnet.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_inform.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_function_decl
specifier|extern
name|void
name|osm_req_get_node_desc
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|osm_physp_t
modifier|*
name|p_physp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**********************************************************************  *  * TRAP HANDLING:  *  * Assuming traps can be caused by bad hardware we should provide  * a mechanism for filtering their propagation into the actual logic  * of OpenSM such that it is not overloaded by them.  *  * We will provide a trap filtering mechanism with "Aging" capability.  * This mechanism will track incoming traps, clasify them by their  * source and content and provide back their age.  *  * A timer running in the background will toggle a timer counter  * that should be referenced by the aging algorithm.  * To provide an efficient handling of aging, we also track all traps  * in a sorted list by their aging.  *  * The generic Aging Tracker mechanism is implemented in the  * cl_aging_tracker object.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|osm_physp_t
modifier|*
name|get_physp_by_lid_and_num
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|ib_net16_t
name|lid
parameter_list|,
name|IN
name|uint8_t
name|num
parameter_list|)
block|{
name|osm_port_t
modifier|*
name|p_port
init|=
name|osm_get_port_by_lid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|lid
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|osm_node_get_num_physp
argument_list|(
name|p_port
operator|->
name|p_node
argument_list|)
operator|<=
name|num
condition|)
return|return
name|NULL
return|;
return|return
name|osm_node_get_physp_ptr
argument_list|(
name|p_port
operator|->
name|p_node
argument_list|,
name|num
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|aging_tracker_callback
parameter_list|(
name|IN
name|uint64_t
name|key
parameter_list|,
name|IN
name|uint32_t
name|num_regs
parameter_list|,
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
name|osm_sm_t
modifier|*
name|sm
init|=
name|context
decl_stmt|;
name|ib_net16_t
name|lid
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_exit_flag
condition|)
comment|/* We got an exit flag - do nothing */
return|return
literal|0
return|;
name|lid
operator|=
call|(
name|ib_net16_t
call|)
argument_list|(
operator|(
name|key
operator|&
literal|0x0000FFFF00000000ULL
operator|)
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|port_num
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|key
operator|&
literal|0x00FF000000000000ULL
operator|)
operator|>>
literal|48
argument_list|)
expr_stmt|;
name|CL_PLOCK_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|p_physp
operator|=
name|get_physp_by_lid_and_num
argument_list|(
name|sm
argument_list|,
name|lid
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Cannot find port num:%u with lid:%u\n"
argument_list|,
name|port_num
argument_list|,
name|cl_ntoh16
argument_list|(
name|lid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* make sure the physp is still valid */
comment|/* If the health port was false - set it to true */
elseif|else
if|if
condition|(
operator|!
name|osm_physp_is_healthy
argument_list|(
name|p_physp
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Clearing health bit of port num:%u with lid:%u\n"
argument_list|,
name|port_num
argument_list|,
name|cl_ntoh16
argument_list|(
name|lid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Clear its health bit */
name|osm_physp_set_health
argument_list|(
name|p_physp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* We want to remove the event from the tracker - so 	   need to return zero. */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * CRC calculation for notice identification  **********************************************************************/
end_comment

begin_define
define|#
directive|define
name|CRC32_POLYNOMIAL
value|0xEDB88320L
end_define

begin_comment
comment|/* calculate the crc for a given buffer */
end_comment

begin_function
specifier|static
name|uint32_t
name|trap_calc_crc32
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|uint32_t
name|count
parameter_list|)
block|{
name|uint32_t
name|temp1
decl_stmt|,
name|temp2
decl_stmt|;
name|uint32_t
name|crc
init|=
operator|-
literal|1L
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buffer
decl_stmt|;
comment|/* precalculated table for faster crc calculation */
specifier|static
name|uint32_t
name|crc_table
index|[
literal|256
index|]
decl_stmt|;
specifier|static
name|boolean_t
name|first
init|=
name|TRUE
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* if we need to initialize the lookup table */
if|if
condition|(
name|first
condition|)
block|{
comment|/* calc the CRC table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|255
condition|;
name|i
operator|++
control|)
block|{
name|crc
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|8
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|crc
operator|&
literal|1
condition|)
name|crc
operator|=
operator|(
name|crc
operator|>>
literal|1
operator|)
operator|^
name|CRC32_POLYNOMIAL
expr_stmt|;
else|else
name|crc
operator|>>=
literal|1
expr_stmt|;
name|crc_table
index|[
name|i
index|]
operator|=
name|crc
expr_stmt|;
block|}
name|first
operator|=
name|FALSE
expr_stmt|;
block|}
name|crc
operator|=
operator|-
literal|1L
expr_stmt|;
comment|/* do the calculation */
while|while
condition|(
name|count
operator|--
operator|!=
literal|0
condition|)
block|{
name|temp1
operator|=
operator|(
name|crc
operator|>>
literal|8
operator|)
operator|&
literal|0x00FFFFFFL
expr_stmt|;
name|temp2
operator|=
name|crc_table
index|[
operator|(
operator|(
name|int
operator|)
name|crc
operator|^
operator|*
name|p
operator|++
operator|)
operator|&
literal|0xFF
index|]
expr_stmt|;
name|crc
operator|=
name|temp1
operator|^
name|temp2
expr_stmt|;
block|}
return|return
name|crc
return|;
block|}
end_function

begin_comment
comment|/* The key is created in the following manner:    port_num  lid   crc    \______/ \___/ \___/      16b     16b   32b */
end_comment

begin_function
specifier|static
name|uint64_t
name|trap_get_key
parameter_list|(
name|IN
name|uint16_t
name|lid
parameter_list|,
name|IN
name|uint8_t
name|port_num
parameter_list|,
name|IN
name|ib_mad_notice_attr_t
modifier|*
name|p_ntci
parameter_list|)
block|{
name|uint32_t
name|crc
init|=
name|trap_calc_crc32
argument_list|(
name|p_ntci
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_mad_notice_attr_t
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|uint64_t
operator|)
name|port_num
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|lid
operator|<<
literal|32
operator|)
operator||
name|crc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|print_num_received
parameter_list|(
name|IN
name|uint32_t
name|num_received
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
comment|/* Series is 10, 20, 50, 100, 200, 500, ... */
name|i
operator|=
name|num_received
expr_stmt|;
while|while
condition|(
name|i
operator|>=
literal|10
condition|)
block|{
if|if
condition|(
name|i
operator|%
literal|10
condition|)
break|break;
name|i
operator|=
name|i
operator|/
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|1
operator|||
name|i
operator|==
literal|2
operator|||
name|i
operator|==
literal|5
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|disable_port
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|osm_physp_t
modifier|*
name|p
parameter_list|)
block|{
name|uint8_t
name|payload
index|[
name|IB_SMP_DATA_SIZE
index|]
decl_stmt|;
name|osm_madw_context_t
name|context
decl_stmt|;
name|ib_port_info_t
modifier|*
name|pi
init|=
operator|(
name|ib_port_info_t
operator|*
operator|)
name|payload
decl_stmt|;
name|osm_physp_t
modifier|*
name|physp0
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|ib_net64_t
name|m_key
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
comment|/* select the nearest port to master opensm */
if|if
condition|(
name|p
operator|->
name|p_remote_physp
operator|&&
name|p
operator|->
name|dr_path
operator|.
name|hop_count
operator|>
name|p
operator|->
name|p_remote_physp
operator|->
name|dr_path
operator|.
name|hop_count
condition|)
name|p
operator|=
name|p
operator|->
name|p_remote_physp
expr_stmt|;
comment|/* If trap 131, might want to disable peer port if available */
comment|/* but peer port has been observed not to respond to SM requests */
name|memcpy
argument_list|(
name|payload
argument_list|,
operator|&
name|p
operator|->
name|port_info
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_port_info_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set port to disabled/down */
name|ib_port_info_set_port_state
argument_list|(
name|pi
argument_list|,
name|IB_LINK_DOWN
argument_list|)
expr_stmt|;
name|ib_port_info_set_port_phys_state
argument_list|(
name|IB_PORT_PHYS_STATE_DISABLED
argument_list|,
name|pi
argument_list|)
expr_stmt|;
comment|/* Issue set of PortInfo */
name|context
operator|.
name|pi_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p
operator|->
name|p_node
argument_list|)
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|port_guid
operator|=
name|osm_physp_get_port_guid
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|set_method
operator|=
name|TRUE
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|light_sweep
operator|=
name|FALSE
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|active_transition
operator|=
name|FALSE
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|client_rereg
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|p
operator|->
name|p_node
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
operator|&&
name|osm_physp_get_port_num
argument_list|(
name|p
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|physp0
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m_key
operator|=
name|ib_port_info_get_m_key
argument_list|(
operator|&
name|physp0
operator|->
name|port_info
argument_list|)
expr_stmt|;
block|}
else|else
name|m_key
operator|=
name|ib_port_info_get_m_key
argument_list|(
operator|&
name|p
operator|->
name|port_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|p
operator|->
name|p_node
argument_list|)
operator|!=
name|IB_NODE_TYPE_SWITCH
condition|)
block|{
if|if
condition|(
operator|!
name|pi
operator|->
name|base_lid
condition|)
block|{
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|osm_physp_get_port_guid
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|pi
operator|->
name|base_lid
operator|=
name|p_port
operator|->
name|lid
expr_stmt|;
block|}
name|pi
operator|->
name|master_sm_base_lid
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|sm_base_lid
expr_stmt|;
block|}
name|status
operator|=
name|osm_req_set
argument_list|(
name|sm
argument_list|,
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p
argument_list|)
argument_list|,
name|payload
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|,
name|IB_MAD_ATTR_PORT_INFO
argument_list|,
name|cl_hton32
argument_list|(
name|osm_physp_get_port_num
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|m_key
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|log_trap_info
parameter_list|(
name|osm_log_t
modifier|*
name|p_log
parameter_list|,
name|ib_mad_notice_attr_t
modifier|*
name|p_ntci
parameter_list|,
name|ib_net16_t
name|source_lid
parameter_list|,
name|ib_net64_t
name|trans_id
parameter_list|)
block|{
if|if
condition|(
operator|!
name|OSM_LOG_IS_ACTIVE_V2
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|)
condition|)
return|return;
if|if
condition|(
name|ib_notice_is_generic
argument_list|(
name|p_ntci
argument_list|)
condition|)
block|{
name|char
name|str
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
operator|==
name|CL_HTON16
argument_list|(
name|SM_LINK_INTEGRITY_THRESHOLD_TRAP
argument_list|)
operator|)
operator|||
operator|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
operator|==
name|CL_HTON16
argument_list|(
name|SM_BUFFER_OVERRUN_THRESHOLD_TRAP
argument_list|)
operator|)
operator|||
operator|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
operator|==
name|CL_HTON16
argument_list|(
name|SM_WATCHDOG_TIMER_EXPIRED_TRAP
argument_list|)
operator|)
condition|)
name|snprintf
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|" Port %u"
argument_list|,
name|p_ntci
operator|->
name|data_details
operator|.
name|ntc_129_131
operator|.
name|port_num
argument_list|)
expr_stmt|;
else|else
name|str
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"Received Generic Notice type:%u "
literal|"num:%u (%s) Producer:%u (%s) "
literal|"from LID:%u%s TID:0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|ib_notice_get_type
argument_list|(
name|p_ntci
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
argument_list|)
argument_list|,
name|ib_get_trap_str
argument_list|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
argument_list|)
argument_list|,
name|cl_ntoh32
argument_list|(
name|ib_notice_get_prod_type
argument_list|(
name|p_ntci
argument_list|)
argument_list|)
argument_list|,
name|ib_get_producer_type_str
argument_list|(
name|ib_notice_get_prod_type
argument_list|(
name|p_ntci
argument_list|)
argument_list|)
argument_list|,
name|cl_hton16
argument_list|(
name|source_lid
argument_list|)
argument_list|,
name|str
argument_list|,
name|cl_ntoh64
argument_list|(
name|trans_id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
operator|==
name|CL_HTON16
argument_list|(
name|SM_BAD_PKEY_TRAP
argument_list|)
operator|)
operator|||
operator|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
operator|==
name|CL_HTON16
argument_list|(
name|SM_BAD_QKEY_TRAP
argument_list|)
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"Bad %s_Key:0x%x on SL:%d from "
literal|"LID1:%u QP1:0x%x to "
literal|"LID2:%u QP2:0x%x\n"
argument_list|,
operator|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
operator|==
name|CL_HTON16
argument_list|(
literal|257
argument_list|)
operator|)
condition|?
literal|"P"
else|:
literal|"Q"
argument_list|,
name|cl_ntoh32
argument_list|(
name|p_ntci
operator|->
name|data_details
operator|.
name|ntc_257_258
operator|.
name|key
argument_list|)
argument_list|,
name|cl_ntoh32
argument_list|(
name|p_ntci
operator|->
name|data_details
operator|.
name|ntc_257_258
operator|.
name|qp1
argument_list|)
operator|>>
literal|28
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_ntci
operator|->
name|data_details
operator|.
name|ntc_257_258
operator|.
name|lid1
argument_list|)
argument_list|,
name|cl_ntoh32
argument_list|(
name|p_ntci
operator|->
name|data_details
operator|.
name|ntc_257_258
operator|.
name|qp1
argument_list|)
operator|&
literal|0xfff
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_ntci
operator|->
name|data_details
operator|.
name|ntc_257_258
operator|.
name|lid2
argument_list|)
argument_list|,
name|cl_ntoh32
argument_list|(
name|p_ntci
operator|->
name|data_details
operator|.
name|ntc_257_258
operator|.
name|qp2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"Received Vendor Notice type:%u vend:0x%06X "
literal|"dev:%u from LID:%u TID:0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|ib_notice_get_type
argument_list|(
name|p_ntci
argument_list|)
argument_list|,
name|cl_ntoh32
argument_list|(
name|ib_notice_get_vend_id
argument_list|(
name|p_ntci
argument_list|)
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|vend
operator|.
name|dev_id
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|source_lid
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|trans_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|shutup_noisy_port
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|ib_net16_t
name|lid
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|unsigned
name|num
parameter_list|)
block|{
name|osm_physp_t
modifier|*
name|p
init|=
name|get_physp_by_lid_and_num
argument_list|(
name|sm
argument_list|,
name|lid
argument_list|,
name|port
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3805: "
literal|"Failed to find physical port by lid:%u num:%u\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|lid
argument_list|)
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* When babbling port policy option is enabled and 	   Threshold for disabling a "babbling" port is exceeded */
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|babbling_port_policy
operator|&&
name|num
operator|>=
literal|250
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Disabling noisy physical port 0x%016"
name|PRIx64
literal|": lid %u, num %u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|lid
argument_list|)
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|disable_port
argument_list|(
name|sm
argument_list|,
name|p
argument_list|)
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3811: "
literal|"Failed to disable noisy physical port 0x%016"
name|PRIx64
literal|": lid %u, num %u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|lid
argument_list|)
argument_list|,
name|port
argument_list|)
expr_stmt|;
else|else
return|return
literal|1
return|;
block|}
comment|/* check if the current state of the p_physp is healthy. If 	   it is - then this is a first change of state. Run a heavy sweep. */
if|if
condition|(
name|osm_physp_is_healthy
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Marking unhealthy physical port by lid:%u num:%u\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|lid
argument_list|)
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|osm_physp_set_health
argument_list|(
name|p
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trap_rcv_process_request
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|)
block|{
name|uint8_t
name|payload
index|[
sizeof|sizeof
argument_list|(
name|ib_mad_notice_attr_t
argument_list|)
index|]
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|ib_mad_notice_attr_t
modifier|*
name|p_ntci
init|=
operator|(
name|ib_mad_notice_attr_t
operator|*
operator|)
name|payload
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|osm_madw_t
name|tmp_madw
decl_stmt|;
comment|/* we need a copy to last after repress */
name|uint64_t
name|trap_key
decl_stmt|;
name|uint32_t
name|num_received
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|ib_net16_t
name|source_lid
init|=
literal|0
decl_stmt|;
name|boolean_t
name|is_gsi
init|=
name|TRUE
decl_stmt|;
name|uint8_t
name|port_num
init|=
literal|0
decl_stmt|;
name|boolean_t
name|physp_change_trap
init|=
name|FALSE
decl_stmt|;
name|uint64_t
name|event_wheel_timeout
init|=
name|OSM_DEFAULT_TRAP_SUPRESSION_TIMEOUT
decl_stmt|;
name|boolean_t
name|run_heavy_sweep
init|=
name|FALSE
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|osm_dr_path_t
modifier|*
name|p_path
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_exit_flag
condition|)
comment|/* 		   We got an exit flag - do nothing 		   Otherwise we start a sweep on the trap 144 caused by 		   cleaning up SM Cap bit... 		 */
goto|goto
name|Exit2
goto|;
comment|/* update the is_gsi flag according to the mgmt_class field */
if|if
condition|(
name|p_madw
operator|->
name|p_mad
operator|->
name|mgmt_class
operator|==
name|IB_MCLASS_SUBN_LID
operator|||
name|p_madw
operator|->
name|p_mad
operator|->
name|mgmt_class
operator|==
name|IB_MCLASS_SUBN_DIR
condition|)
name|is_gsi
operator|=
name|FALSE
expr_stmt|;
comment|/* No real need to grab the lock for this function. */
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|tmp_madw
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp_madw
argument_list|)
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_smp
operator|->
name|method
operator|!=
name|IB_MAD_METHOD_TRAP
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3801: "
literal|"Unsupported method 0x%X\n"
argument_list|,
name|p_smp
operator|->
name|method
argument_list|)
expr_stmt|;
goto|goto
name|Exit2
goto|;
block|}
comment|/* 	 * The NOTICE Attribute is part of the SMP CLASS attributes 	 * As such the actual attribute data resides inside the SMP 	 * payload. 	 */
name|memcpy
argument_list|(
name|payload
argument_list|,
operator|&
name|p_smp
operator|->
name|data
argument_list|,
name|IB_SMP_DATA_SIZE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|tmp_madw
argument_list|,
name|p_madw
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp_madw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_gsi
operator|==
name|FALSE
condition|)
block|{
comment|/* We are in smi flow */
comment|/* 		 * When we receive a TRAP with dlid = 0 - it means it 		 * came from our own node. So we need to fix it. 		 */
if|if
condition|(
name|p_madw
operator|->
name|mad_addr
operator|.
name|addr_type
operator|.
name|smi
operator|.
name|source_lid
operator|==
literal|0
condition|)
block|{
comment|/* Check if the sm_base_lid is 0. If yes - this means 			   that the local lid wasn't configured yet. Don't send 			   a response to the trap. */
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_base_lid
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Received SLID=0 Trap with local LID=0. Ignoring MAD\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit2
goto|;
block|}
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Received SLID=0 Trap. Using local LID:%u instead\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_base_lid
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_madw
operator|.
name|mad_addr
operator|.
name|addr_type
operator|.
name|smi
operator|.
name|source_lid
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|sm_base_lid
expr_stmt|;
block|}
name|source_lid
operator|=
name|tmp_madw
operator|.
name|mad_addr
operator|.
name|addr_type
operator|.
name|smi
operator|.
name|source_lid
expr_stmt|;
comment|/* Print some info about the incoming Trap */
name|log_trap_info
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|p_ntci
argument_list|,
name|source_lid
argument_list|,
name|p_smp
operator|->
name|trans_id
argument_list|)
expr_stmt|;
block|}
name|osm_dump_notice_v2
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|p_ntci
argument_list|,
name|FILE_ID
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|)
expr_stmt|;
name|CL_PLOCK_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|p_physp
operator|=
name|osm_get_physp_by_mad_addr
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|sm
operator|->
name|p_subn
argument_list|,
operator|&
name|tmp_madw
operator|.
name|mad_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_physp
condition|)
name|p_smp
operator|->
name|m_key
operator|=
name|ib_port_info_get_m_key
argument_list|(
operator|&
name|p_physp
operator|->
name|port_info
argument_list|)
expr_stmt|;
else|else
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3809: "
literal|"Failed to find source physical port for trap\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_resp_send
argument_list|(
name|sm
argument_list|,
operator|&
name|tmp_madw
argument_list|,
literal|0
argument_list|,
name|payload
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3802: "
literal|"Error sending response (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	 * We would like to filter out recurring Traps so we track them by 	 * their source lid and content. If the same trap was already 	 * received within the aging time window more than 10 times, 	 * we simply ignore it. This is done only if we are in smi mode 	 */
if|if
condition|(
name|is_gsi
operator|==
name|FALSE
condition|)
block|{
if|if
condition|(
name|ib_notice_is_generic
argument_list|(
name|p_ntci
argument_list|)
operator|&&
operator|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
operator|==
name|CL_HTON16
argument_list|(
name|SM_LINK_INTEGRITY_THRESHOLD_TRAP
argument_list|)
operator|||
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
operator|==
name|CL_HTON16
argument_list|(
name|SM_BUFFER_OVERRUN_THRESHOLD_TRAP
argument_list|)
operator|||
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
operator|==
name|CL_HTON16
argument_list|(
name|SM_WATCHDOG_TIMER_EXPIRED_TRAP
argument_list|)
operator|)
condition|)
block|{
comment|/* If this is a trap 129, 130, or 131 - then this is a 			 * trap signaling a change on a physical port. 			 * Mark the physp_change_trap flag as TRUE. 			 */
name|physp_change_trap
operator|=
name|TRUE
expr_stmt|;
comment|/* The source_lid should be based on the source_lid from the trap */
name|source_lid
operator|=
name|p_ntci
operator|->
name|data_details
operator|.
name|ntc_129_131
operator|.
name|lid
expr_stmt|;
name|port_num
operator|=
name|p_ntci
operator|->
name|data_details
operator|.
name|ntc_129_131
operator|.
name|port_num
expr_stmt|;
block|}
comment|/* try to find it in the aging tracker */
name|trap_key
operator|=
name|trap_get_key
argument_list|(
name|source_lid
argument_list|,
name|port_num
argument_list|,
name|p_ntci
argument_list|)
expr_stmt|;
name|num_received
operator|=
name|cl_event_wheel_num_regs
argument_list|(
operator|&
name|sm
operator|->
name|trap_aging_tracker
argument_list|,
name|trap_key
argument_list|)
expr_stmt|;
comment|/* Now we know how many times it provided this trap */
if|if
condition|(
name|num_received
operator|>
literal|10
condition|)
block|{
if|if
condition|(
name|print_num_received
argument_list|(
name|num_received
argument_list|)
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Received trap %u times consecutively\n"
argument_list|,
name|num_received
argument_list|)
expr_stmt|;
comment|/* 			 * If the trap provides info about a bad port 			 * we mark it as unhealthy. 			 */
if|if
condition|(
name|physp_change_trap
operator|==
name|TRUE
condition|)
block|{
name|int
name|ret
init|=
name|shutup_noisy_port
argument_list|(
name|sm
argument_list|,
name|source_lid
argument_list|,
name|port_num
argument_list|,
name|num_received
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
comment|/* port disabled */
goto|goto
name|Exit
goto|;
elseif|else
if|if
condition|(
name|ret
operator|==
literal|2
condition|)
comment|/* unhealthy - run sweep */
name|run_heavy_sweep
operator|=
name|TRUE
expr_stmt|;
comment|/* in any case increase timeout interval */
name|event_wheel_timeout
operator|=
name|OSM_DEFAULT_UNHEALTHY_TIMEOUT
expr_stmt|;
block|}
block|}
comment|/* restart the aging anyway */
comment|/* If physp_change_trap is TRUE - then use a callback to unset 		   the healthy bit. If not - no need to use a callback. */
if|if
condition|(
name|physp_change_trap
operator|==
name|TRUE
condition|)
name|cl_event_wheel_reg
argument_list|(
operator|&
name|sm
operator|->
name|trap_aging_tracker
argument_list|,
name|trap_key
argument_list|,
name|cl_get_time_stamp
argument_list|()
operator|+
name|event_wheel_timeout
argument_list|,
name|aging_tracker_callback
argument_list|,
name|sm
argument_list|)
expr_stmt|;
else|else
name|cl_event_wheel_reg
argument_list|(
operator|&
name|sm
operator|->
name|trap_aging_tracker
argument_list|,
name|trap_key
argument_list|,
name|cl_get_time_stamp
argument_list|()
operator|+
name|event_wheel_timeout
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If was already registered do nothing more */
if|if
condition|(
name|num_received
operator|>
literal|10
operator|&&
name|run_heavy_sweep
operator|==
name|FALSE
condition|)
block|{
if|if
condition|(
name|print_num_received
argument_list|(
name|num_received
argument_list|)
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Ignoring noisy traps.\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/* Check for node description update. IB Spec v1.2.1 pg 823 */
if|if
condition|(
operator|!
name|ib_notice_is_generic
argument_list|(
name|p_ntci
argument_list|)
condition|)
goto|goto
name|check_sweep
goto|;
if|if
condition|(
name|cl_ntoh16
argument_list|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
argument_list|)
operator|==
name|SM_LOCAL_CHANGES_TRAP
operator|&&
name|p_ntci
operator|->
name|data_details
operator|.
name|ntc_144
operator|.
name|local_changes
operator|&
name|TRAP_144_MASK_OTHER_LOCAL_CHANGES
operator|&&
name|p_ntci
operator|->
name|data_details
operator|.
name|ntc_144
operator|.
name|change_flgs
operator|&
name|TRAP_144_MASK_NODE_DESCRIPTION_CHANGE
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Trap 144 Node description update\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_physp
condition|)
block|{
name|osm_req_get_node_desc
argument_list|(
name|sm
argument_list|,
name|p_physp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_ntci
operator|->
name|data_details
operator|.
name|ntc_144
operator|.
name|change_flgs
operator|&
operator|~
name|TRAP_144_MASK_NODE_DESCRIPTION_CHANGE
operator|)
operator|&&
name|p_ntci
operator|->
name|data_details
operator|.
name|ntc_144
operator|.
name|new_cap_mask
operator|==
name|p_physp
operator|->
name|port_info
operator|.
name|capability_mask
condition|)
goto|goto
name|check_report
goto|;
block|}
else|else
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3812: No physical port found for "
literal|"trap 144: \"node description update\"\n"
argument_list|)
expr_stmt|;
goto|goto
name|check_sweep
goto|;
block|}
elseif|else
if|if
condition|(
name|cl_ntoh16
argument_list|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
argument_list|)
operator|==
name|SM_SYS_IMG_GUID_CHANGED_TRAP
condition|)
block|{
if|if
condition|(
name|p_physp
condition|)
block|{
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|p_physp
operator|=
name|osm_get_physp_by_mad_addr
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|sm
operator|->
name|p_subn
argument_list|,
operator|&
name|tmp_madw
operator|.
name|mad_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_physp
condition|)
block|{
comment|/* this assumes that trap 145 content is not broken? */
name|p_physp
operator|->
name|p_node
operator|->
name|node_info
operator|.
name|sys_guid
operator|=
name|p_ntci
operator|->
name|data_details
operator|.
name|ntc_145
operator|.
name|new_sys_guid
expr_stmt|;
block|}
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|CL_PLOCK_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
block|}
else|else
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3813: No physical port found for "
literal|"trap 145: \"SystemImageGUID update\"\n"
argument_list|)
expr_stmt|;
goto|goto
name|check_report
goto|;
block|}
name|check_sweep
label|:
if|if
condition|(
name|osm_log_is_active_v2
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
name|FILE_ID
argument_list|)
condition|)
block|{
if|if
condition|(
name|ib_notice_is_generic
argument_list|(
name|p_ntci
argument_list|)
operator|&&
name|cl_ntoh16
argument_list|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
argument_list|)
operator|==
name|SM_LINK_STATE_CHANGED_TRAP
condition|)
block|{
name|p_path
operator|=
operator|(
name|p_physp
operator|)
condition|?
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|p_path
condition|)
block|{
name|n
operator|=
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"SM class trap %u: "
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|n
argument_list|,
literal|"Directed Path Dump of %u hop path: "
literal|"Path = "
argument_list|,
name|p_path
operator|->
name|hop_count
argument_list|)
expr_stmt|;
name|osm_dump_dr_path_as_buf
argument_list|(
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|n
argument_list|,
name|p_path
argument_list|,
name|buf
operator|+
name|n
argument_list|)
expr_stmt|;
name|osm_log_v2
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
name|FILE_ID
argument_list|,
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* do a sweep if we received a trap */
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|sweep_on_trap
condition|)
block|{
comment|/* if this is trap number 128 or run_heavy_sweep is TRUE - 		   update the force_heavy_sweep flag of the subnet. 		   Sweep also on traps 144 - these traps signal a change of 		   certain port capabilities. 		   TODO: In the future this can be changed to just getting 		   PortInfo on this port instead of sweeping the entire subnet. */
if|if
condition|(
name|ib_notice_is_generic
argument_list|(
name|p_ntci
argument_list|)
operator|&&
operator|(
name|cl_ntoh16
argument_list|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
argument_list|)
operator|==
name|SM_LINK_STATE_CHANGED_TRAP
operator|||
name|cl_ntoh16
argument_list|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
argument_list|)
operator|==
name|SM_LOCAL_CHANGES_TRAP
operator|||
name|run_heavy_sweep
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Forcing heavy sweep. Received trap:%u\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
argument_list|)
argument_list|)
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|force_heavy_sweep
operator|=
name|TRUE
expr_stmt|;
block|}
name|osm_sm_signal
argument_list|(
name|sm
argument_list|,
name|OSM_SIGNAL_SWEEP
argument_list|)
expr_stmt|;
block|}
comment|/* If we reached here due to trap 129/130/131 - do not need to do 	   the notice report. Just goto exit. We know this is the case 	   if physp_change_trap is TRUE. */
if|if
condition|(
name|physp_change_trap
operator|==
name|TRUE
condition|)
goto|goto
name|Exit
goto|;
name|check_report
label|:
comment|/* We are going to report the notice - so need to fix the IssuerGID 	   accordingly. See IBA 1.2 p.739 or IBA 1.1 p.653 for details. */
if|if
condition|(
name|is_gsi
condition|)
block|{
if|if
condition|(
operator|!
name|tmp_madw
operator|.
name|mad_addr
operator|.
name|addr_type
operator|.
name|gsi
operator|.
name|global_route
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3806: "
literal|"Received gsi trap with global_route FALSE. "
literal|"Cannot update issuer_gid!\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|memcpy
argument_list|(
operator|&
name|p_ntci
operator|->
name|issuer_gid
argument_list|,
operator|&
name|tmp_madw
operator|.
name|mad_addr
operator|.
name|addr_type
operator|.
name|gsi
operator|.
name|grh_info
operator|.
name|src_gid
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_gid_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Need to use the IssuerLID */
name|p_port
operator|=
name|osm_get_port_by_lid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|source_lid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Cannot find port corresponding to lid:%u\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|source_lid
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_ntci
operator|->
name|issuer_gid
operator|.
name|unicast
operator|.
name|prefix
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|subnet_prefix
expr_stmt|;
name|p_ntci
operator|->
name|issuer_gid
operator|.
name|unicast
operator|.
name|interface_id
operator|=
name|p_port
operator|->
name|guid
expr_stmt|;
block|}
comment|/* we need a lock here as the InformInfo DB must be stable */
name|status
operator|=
name|osm_report_notice
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|sm
operator|->
name|p_subn
argument_list|,
name|p_ntci
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3803: "
literal|"Error sending trap reports (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|Exit
label|:
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|Exit2
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_trap_rcv_process
parameter_list|(
name|IN
name|void
modifier|*
name|context
parameter_list|,
name|IN
name|void
modifier|*
name|data
parameter_list|)
block|{
name|osm_sm_t
modifier|*
name|sm
init|=
name|context
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_madw
init|=
name|data
decl_stmt|;
name|ib_smp_t
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
modifier|*
name|p_smp
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
comment|/* Only Trap requests get here */
name|CL_ASSERT
argument_list|(
operator|!
name|ib_smp_is_response
argument_list|(
name|p_smp
argument_list|)
argument_list|)
expr_stmt|;
name|trap_rcv_process_request
argument_list|(
name|sm
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

