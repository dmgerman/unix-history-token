begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2008 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2005 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<vendor/osm_vendor_mlx.h>
end_include

begin_include
include|#
directive|include
file|<vendor/osm_vendor_mlx_defs.h>
end_include

begin_include
include|#
directive|include
file|<vendor/osm_vendor_mlx_svc.h>
end_include

begin_include
include|#
directive|include
file|<vendor/osm_vendor_mlx_transport.h>
end_include

begin_include
include|#
directive|include
file|<vendor/osm_vendor_mlx_sender.h>
end_include

begin_include
include|#
directive|include
file|<vendor/osm_pkt_randomizer.h>
end_include

begin_typedef
typedef|typedef
enum|enum
name|_osmv_disp_route
block|{
name|OSMV_ROUTE_DROP
block|,
name|OSMV_ROUTE_SIMPLE
block|,
name|OSMV_ROUTE_RMPP
block|,  }
name|osmv_disp_route_t
typedef|;
end_typedef

begin_comment
comment|/**  *   FORWARD REFERENCES TO PRIVATE FUNCTIONS  */
end_comment

begin_function_decl
specifier|static
name|osmv_disp_route_t
name|__osmv_dispatch_route
parameter_list|(
name|IN
name|osm_bind_handle_t
name|h_bind
parameter_list|,
name|IN
specifier|const
name|ib_mad_t
modifier|*
name|p_mad
parameter_list|,
name|OUT
name|osmv_txn_ctx_t
modifier|*
modifier|*
name|pp_txn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__osmv_dispatch_simple_mad
parameter_list|(
name|IN
name|osm_bind_handle_t
name|h_bind
parameter_list|,
name|IN
specifier|const
name|ib_mad_t
modifier|*
name|p_mad
parameter_list|,
name|IN
name|osmv_txn_ctx_t
modifier|*
name|p_txn
parameter_list|,
name|IN
specifier|const
name|osm_mad_addr_t
modifier|*
name|p_mad_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__osmv_dispatch_rmpp_mad
parameter_list|(
name|IN
name|osm_bind_handle_t
name|h_bind
parameter_list|,
name|IN
specifier|const
name|ib_mad_t
modifier|*
name|p_mad
parameter_list|,
name|IN
name|osmv_txn_ctx_t
modifier|*
name|p_txn
parameter_list|,
name|IN
specifier|const
name|osm_mad_addr_t
modifier|*
name|p_mad_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__osmv_dispatch_rmpp_snd
parameter_list|(
name|IN
name|osm_bind_handle_t
name|h_bind
parameter_list|,
name|IN
specifier|const
name|ib_mad_t
modifier|*
name|p_mad
parameter_list|,
name|IN
name|osmv_txn_ctx_t
modifier|*
name|p_txn
parameter_list|,
name|IN
specifier|const
name|osm_mad_addr_t
modifier|*
name|p_mad_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ib_api_status_t
name|__osmv_dispatch_rmpp_rcv
parameter_list|(
name|IN
name|osm_bind_handle_t
name|h_bind
parameter_list|,
name|IN
specifier|const
name|ib_mad_t
modifier|*
name|p_mad
parameter_list|,
name|IN
name|osmv_txn_ctx_t
modifier|*
name|p_txn
parameter_list|,
name|IN
specifier|const
name|osm_mad_addr_t
modifier|*
name|p_mad_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ib_api_status_t
name|__osmv_dispatch_accept_seg
parameter_list|(
name|IN
name|osm_bind_handle_t
name|h_bind
parameter_list|,
name|IN
name|osmv_txn_ctx_t
modifier|*
name|p_txn
parameter_list|,
name|IN
specifier|const
name|ib_mad_t
modifier|*
name|p_mad
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__osmv_dispatch_send_ack
parameter_list|(
name|IN
name|osm_bind_handle_t
name|h_bind
parameter_list|,
name|IN
specifier|const
name|ib_mad_t
modifier|*
name|p_req_mad
parameter_list|,
name|IN
name|osmv_txn_ctx_t
modifier|*
name|p_txn
parameter_list|,
name|IN
specifier|const
name|osm_mad_addr_t
modifier|*
name|p_mad_addr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * NAME  *   osmv_dispatch_mad  *  * DESCRIPTION  *   Lower-level MAD dispatcher.  *   Implements a switch between the following MAD consumers:  *   (1) Non-RMPP consumer (DATA)  *   (2) RMPP receiver     (DATA/ABORT/STOP)  *   (3) RMPP sender       (ACK/ABORT/STOP)  *  * PARAMETERS  *   h_bind                The bind handle  *   p_mad_buf             The 256 byte buffer of individual MAD  *   p_mad_addr            The MAD originator's address  */
end_comment

begin_function
name|ib_api_status_t
name|osmv_dispatch_mad
parameter_list|(
name|IN
name|osm_bind_handle_t
name|h_bind
parameter_list|,
name|IN
specifier|const
name|void
modifier|*
name|p_mad_buf
parameter_list|,
name|IN
specifier|const
name|osm_mad_addr_t
modifier|*
name|p_mad_addr
parameter_list|)
block|{
name|ib_api_status_t
name|ret
init|=
name|IB_SUCCESS
decl_stmt|;
specifier|const
name|ib_mad_t
modifier|*
name|p_mad
init|=
operator|(
name|ib_mad_t
operator|*
operator|)
name|p_mad_buf
decl_stmt|;
name|osmv_bind_obj_t
modifier|*
name|p_bo
init|=
operator|(
name|osmv_bind_obj_t
operator|*
operator|)
name|h_bind
decl_stmt|;
name|osmv_txn_ctx_t
modifier|*
name|p_txn
init|=
name|NULL
decl_stmt|;
name|osm_log_t
modifier|*
name|p_log
init|=
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|NULL
operator|!=
name|h_bind
operator|&&
name|NULL
operator|!=
name|p_mad
operator|&&
name|NULL
operator|!=
name|p_mad_addr
argument_list|)
expr_stmt|;
name|osmv_txn_lock
argument_list|(
name|p_bo
argument_list|)
expr_stmt|;
if|if
condition|(
name|TRUE
operator|==
name|p_bo
operator|->
name|is_closing
condition|)
block|{
name|osm_log
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"The bind handle %p is being closed. "
literal|"The MAD will not be dispatched.\n"
argument_list|,
name|p_bo
argument_list|)
expr_stmt|;
name|ret
operator|=
name|IB_INTERRUPTED
expr_stmt|;
goto|goto
name|dispatch_mad_done
goto|;
block|}
comment|/* 	   Add call for packet drop randomizer. 	   This is a testing feature. If run_randomizer flag is set to TRUE, 	   the randomizer will be called, and randomally will drop 	   a packet. This is used for simulating unstable fabric. 	 */
if|if
condition|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|run_randomizer
operator|==
name|TRUE
condition|)
block|{
comment|/* Try the randomizer */
if|if
condition|(
name|osm_pkt_randomizer_mad_drop
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|,
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_pkt_randomizer
argument_list|,
name|p_mad
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|osm_log
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"The MAD will not be dispatched.\n"
argument_list|)
expr_stmt|;
goto|goto
name|dispatch_mad_done
goto|;
block|}
block|}
switch|switch
condition|(
name|__osmv_dispatch_route
argument_list|(
name|h_bind
argument_list|,
name|p_mad
argument_list|,
operator|&
name|p_txn
argument_list|)
condition|)
block|{
case|case
name|OSMV_ROUTE_DROP
case|:
break|break;
comment|/* Do nothing */
case|case
name|OSMV_ROUTE_SIMPLE
case|:
name|__osmv_dispatch_simple_mad
argument_list|(
name|h_bind
argument_list|,
name|p_mad
argument_list|,
name|p_txn
argument_list|,
name|p_mad_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|OSMV_ROUTE_RMPP
case|:
name|__osmv_dispatch_rmpp_mad
argument_list|(
name|h_bind
argument_list|,
name|p_mad
argument_list|,
name|p_txn
argument_list|,
name|p_mad_addr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|CL_ASSERT
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|dispatch_mad_done
label|:
name|osmv_txn_unlock
argument_list|(
name|p_bo
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  *  NAME            __osmv_dispatch_route()  *  *  DESCRIPTION     Decide which way to handle the received MAD: simple txn/RMPP/drop  */
end_comment

begin_function
specifier|static
name|osmv_disp_route_t
name|__osmv_dispatch_route
parameter_list|(
name|IN
name|osm_bind_handle_t
name|h_bind
parameter_list|,
name|IN
specifier|const
name|ib_mad_t
modifier|*
name|p_mad
parameter_list|,
name|OUT
name|osmv_txn_ctx_t
modifier|*
modifier|*
name|pp_txn
parameter_list|)
block|{
name|ib_api_status_t
name|ret
decl_stmt|;
name|osmv_bind_obj_t
modifier|*
name|p_bo
init|=
operator|(
name|osmv_bind_obj_t
operator|*
operator|)
name|h_bind
decl_stmt|;
name|boolean_t
name|is_resp
init|=
name|ib_mad_is_response
argument_list|(
name|p_mad
argument_list|)
decl_stmt|;
name|boolean_t
name|is_txn
decl_stmt|;
name|uint64_t
name|key
init|=
name|cl_ntoh64
argument_list|(
name|p_mad
operator|->
name|trans_id
argument_list|)
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|NULL
operator|!=
name|pp_txn
argument_list|)
expr_stmt|;
name|ret
operator|=
name|osmv_txn_lookup
argument_list|(
name|h_bind
argument_list|,
name|key
argument_list|,
name|pp_txn
argument_list|)
expr_stmt|;
name|is_txn
operator|=
operator|(
name|IB_SUCCESS
operator|==
name|ret
operator|)
expr_stmt|;
if|if
condition|(
name|FALSE
operator|==
name|is_txn
operator|&&
name|TRUE
operator|==
name|is_resp
condition|)
block|{
name|osm_log
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Received a response to a non-started/aged-out transaction (tid=0x%"
name|PRIx64
literal|"). "
literal|"Dropping the MAD.\n"
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
name|OSMV_ROUTE_DROP
return|;
block|}
if|if
condition|(
name|TRUE
operator|==
name|osmv_mad_is_rmpp
argument_list|(
name|p_mad
argument_list|)
condition|)
block|{
comment|/* An RMPP transaction. The filtering is more delicate there */
return|return
name|OSMV_ROUTE_RMPP
return|;
block|}
if|if
condition|(
name|TRUE
operator|==
name|is_txn
operator|&&
name|FALSE
operator|==
name|is_resp
condition|)
block|{
comment|/* Does this MAD try to start a transaction with duplicate tid? */
name|osm_log
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Duplicate TID 0x%"
name|PRIx64
literal|" received (not a response). "
literal|"Dropping the MAD.\n"
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
name|OSMV_ROUTE_DROP
return|;
block|}
return|return
name|OSMV_ROUTE_SIMPLE
return|;
block|}
end_function

begin_comment
comment|/*  *  NAME            __osmv_dispatch_simple_mad()  *  *  DESCRIPTION     Handle a MAD that is part of non-RMPP transfer  */
end_comment

begin_function
specifier|static
name|void
name|__osmv_dispatch_simple_mad
parameter_list|(
name|IN
name|osm_bind_handle_t
name|h_bind
parameter_list|,
name|IN
specifier|const
name|ib_mad_t
modifier|*
name|p_mad
parameter_list|,
name|IN
name|osmv_txn_ctx_t
modifier|*
name|p_txn
parameter_list|,
name|IN
specifier|const
name|osm_mad_addr_t
modifier|*
name|p_mad_addr
parameter_list|)
block|{
name|osm_madw_t
modifier|*
name|p_madw
decl_stmt|;
name|ib_mad_t
modifier|*
name|p_mad_buf
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_req_madw
init|=
name|NULL
decl_stmt|;
name|osmv_bind_obj_t
modifier|*
name|p_bo
init|=
operator|(
name|osmv_bind_obj_t
operator|*
operator|)
name|h_bind
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* Build the MAD wrapper to be returned to the user. 	 * The actual storage for the MAD is allocated there. 	 */
name|p_madw
operator|=
name|osm_mad_pool_get
argument_list|(
name|p_bo
operator|->
name|p_osm_pool
argument_list|,
name|h_bind
argument_list|,
name|MAD_BLOCK_SIZE
argument_list|,
name|p_mad_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|p_madw
condition|)
block|{
name|osm_log
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"__osmv_dispatch_simple_mad: ERR 6501: "
literal|"Out Of Memory - could not allocate a buffer of size %d\n"
argument_list|,
name|MAD_BLOCK_SIZE
argument_list|)
expr_stmt|;
goto|goto
name|dispatch_simple_mad_done
goto|;
block|}
name|p_mad_buf
operator|=
name|osm_madw_get_mad_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
comment|/* Copy the payload to the MAD buffer */
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|p_mad_buf
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p_mad
argument_list|,
name|MAD_BLOCK_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|p_txn
condition|)
block|{
comment|/* This is a RESPONSE MAD. Pair it with the REQUEST MAD, pass upstream */
name|p_req_madw
operator|=
name|p_txn
operator|->
name|p_madw
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|NULL
operator|!=
name|p_req_madw
argument_list|)
expr_stmt|;
name|p_mad_buf
operator|->
name|trans_id
operator|=
name|cl_hton64
argument_list|(
name|osmv_txn_get_tid
argument_list|(
name|p_txn
argument_list|)
argument_list|)
expr_stmt|;
name|osm_log
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Restoring the original TID to 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_mad_buf
operator|->
name|trans_id
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Reply matched, transaction complete */
name|osmv_txn_done
argument_list|(
name|h_bind
argument_list|,
name|osmv_txn_get_key
argument_list|(
name|p_txn
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a REQUEST  MAD. Don't create a context, pass upstream */
block|}
comment|/* Do the job ! */
name|p_bo
operator|->
name|recv_cb
argument_list|(
name|p_madw
argument_list|,
name|p_bo
operator|->
name|cb_context
argument_list|,
name|p_req_madw
argument_list|)
expr_stmt|;
name|dispatch_simple_mad_done
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  NAME            __osmv_dispatch_rmpp_mad()  *  *  DESCRIPTION     Handle a MAD that is part of RMPP transfer  */
end_comment

begin_function
specifier|static
name|void
name|__osmv_dispatch_rmpp_mad
parameter_list|(
name|IN
name|osm_bind_handle_t
name|h_bind
parameter_list|,
name|IN
specifier|const
name|ib_mad_t
modifier|*
name|p_mad
parameter_list|,
name|IN
name|osmv_txn_ctx_t
modifier|*
name|p_txn
parameter_list|,
name|IN
specifier|const
name|osm_mad_addr_t
modifier|*
name|p_mad_addr
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|uint64_t
name|key
init|=
name|cl_ntoh64
argument_list|(
name|p_mad
operator|->
name|trans_id
argument_list|)
decl_stmt|;
name|boolean_t
name|is_init_by_peer
init|=
name|FALSE
decl_stmt|;
name|osmv_bind_obj_t
modifier|*
name|p_bo
init|=
operator|(
name|osmv_bind_obj_t
operator|*
operator|)
name|h_bind
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_madw
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|p_txn
condition|)
block|{
if|if
condition|(
name|FALSE
operator|==
name|osmv_rmpp_is_data
argument_list|(
name|p_mad
argument_list|)
operator|||
name|FALSE
operator|==
name|osmv_rmpp_is_first
argument_list|(
name|p_mad
argument_list|)
condition|)
block|{
name|osm_log
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"The MAD does not match any transaction "
literal|"and does not start a sender-initiated RMPP transfer.\n"
argument_list|)
expr_stmt|;
goto|goto
name|dispatch_rmpp_mad_done
goto|;
block|}
comment|/* IB Spec 13.6.2.2. This is a Sender Initiated Transfer. 		   My peer is the requester and RMPP Sender. I am the RMPP Receiver. 		 */
name|status
operator|=
name|osmv_txn_init
argument_list|(
name|h_bind
argument_list|,
comment|/*tid==key */
name|key
argument_list|,
name|key
argument_list|,
operator|&
name|p_txn
argument_list|)
expr_stmt|;
if|if
condition|(
name|IB_SUCCESS
operator|!=
name|status
condition|)
block|{
goto|goto
name|dispatch_rmpp_mad_done
goto|;
block|}
name|is_init_by_peer
operator|=
name|TRUE
expr_stmt|;
name|osm_log
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"A new sender-initiated transfer (TID=0x%"
name|PRIx64
literal|") started\n"
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|OSMV_TXN_RMPP_NONE
operator|==
name|osmv_txn_get_rmpp_state
argument_list|(
name|p_txn
argument_list|)
condition|)
block|{
comment|/* Case 1: Fall through from above. 		 * Case 2: When the transaction was initiated by me 		 *         (a single request MAD), there was an uncertainty 		 *         whether the reply will be RMPP. Now it's resolved, 		 *         since the reply is RMPP! 		 */
name|status
operator|=
name|osmv_txn_init_rmpp_receiver
argument_list|(
name|h_bind
argument_list|,
name|p_txn
argument_list|,
name|is_init_by_peer
argument_list|)
expr_stmt|;
if|if
condition|(
name|IB_SUCCESS
operator|!=
name|status
condition|)
block|{
goto|goto
name|dispatch_rmpp_mad_done
goto|;
block|}
block|}
switch|switch
condition|(
name|osmv_txn_get_rmpp_state
argument_list|(
name|p_txn
argument_list|)
condition|)
block|{
case|case
name|OSMV_TXN_RMPP_RECEIVER
case|:
name|status
operator|=
name|__osmv_dispatch_rmpp_rcv
argument_list|(
name|h_bind
argument_list|,
name|p_mad
argument_list|,
name|p_txn
argument_list|,
name|p_mad_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|IB_SUCCESS
operator|!=
name|status
condition|)
block|{
if|if
condition|(
name|FALSE
operator|==
name|osmv_txn_is_rmpp_init_by_peer
argument_list|(
name|p_txn
argument_list|)
condition|)
block|{
comment|/* This is a requester, still waiting for the reply. Apply the callback */
comment|/* update the status of the p_madw */
name|p_madw
operator|=
name|osmv_txn_get_madw
argument_list|(
name|p_txn
argument_list|)
expr_stmt|;
name|p_madw
operator|->
name|status
operator|=
name|status
expr_stmt|;
name|p_bo
operator|->
name|send_err_cb
argument_list|(
name|p_bo
operator|->
name|cb_context
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
block|}
comment|/* ABORT/STOP/LOCAL ERROR */
name|osmv_txn_done
argument_list|(
name|h_bind
argument_list|,
name|osmv_txn_get_key
argument_list|(
name|p_txn
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OSMV_TXN_RMPP_SENDER
case|:
name|__osmv_dispatch_rmpp_snd
argument_list|(
name|h_bind
argument_list|,
name|p_mad
argument_list|,
name|p_txn
argument_list|,
name|p_mad_addr
argument_list|)
expr_stmt|;
comment|/* If an error happens here, it's the sender thread to cleanup the txn */
break|break;
default|default:
name|CL_ASSERT
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|dispatch_rmpp_mad_done
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  NAME            __osmv_dispatch_rmpp_snd()  *  *  DESCRIPTION     MAD handling by an RMPP sender (ACK/ABORT/STOP)  */
end_comment

begin_function
specifier|static
name|void
name|__osmv_dispatch_rmpp_snd
parameter_list|(
name|IN
name|osm_bind_handle_t
name|h_bind
parameter_list|,
name|IN
specifier|const
name|ib_mad_t
modifier|*
name|p_mad
parameter_list|,
name|IN
name|osmv_txn_ctx_t
modifier|*
name|p_txn
parameter_list|,
name|IN
specifier|const
name|osm_mad_addr_t
modifier|*
name|p_mad_addr
parameter_list|)
block|{
name|osmv_rmpp_send_ctx_t
modifier|*
name|p_send_ctx
init|=
name|osmv_txn_get_rmpp_send_ctx
argument_list|(
name|p_txn
argument_list|)
decl_stmt|;
name|uint32_t
name|old_wl
init|=
name|p_send_ctx
operator|->
name|window_last
decl_stmt|;
name|uint32_t
name|total_segs
init|=
name|osmv_rmpp_send_ctx_get_num_segs
argument_list|(
name|p_send_ctx
argument_list|)
decl_stmt|;
name|uint32_t
name|seg_num
init|=
name|cl_ntoh32
argument_list|(
operator|(
operator|(
name|ib_rmpp_mad_t
operator|*
operator|)
name|p_mad
operator|)
operator|->
name|seg_num
argument_list|)
decl_stmt|;
name|uint32_t
name|new_wl
init|=
name|cl_ntoh32
argument_list|(
operator|(
operator|(
name|ib_rmpp_mad_t
operator|*
operator|)
name|p_mad
operator|)
operator|->
name|paylen_newwin
argument_list|)
decl_stmt|;
name|osmv_bind_obj_t
modifier|*
name|p_bo
init|=
operator|(
name|osmv_bind_obj_t
operator|*
operator|)
name|h_bind
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
name|TRUE
operator|==
name|osmv_rmpp_is_abort_stop
argument_list|(
name|p_mad
argument_list|)
condition|)
block|{
name|osm_log
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"__osmv_dispatch_rmpp_snd: ERR 6502: "
literal|"The remote side sent an ABORT/STOP indication.\n"
argument_list|)
expr_stmt|;
name|osmv_rmpp_snd_error
argument_list|(
name|p_send_ctx
argument_list|,
name|IB_REMOTE_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|dispatch_rmpp_snd_done
goto|;
block|}
if|if
condition|(
name|FALSE
operator|==
name|osmv_rmpp_is_ack
argument_list|(
name|p_mad
argument_list|)
condition|)
block|{
name|osm_log
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Not supposed to receive DATA packets --> dropping the MAD\n"
argument_list|)
expr_stmt|;
goto|goto
name|dispatch_rmpp_snd_done
goto|;
block|}
comment|/* Continue processing the ACK */
if|if
condition|(
name|seg_num
operator|>
name|old_wl
condition|)
block|{
name|osm_log
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"__osmv_dispatch_rmpp_snd: ERR 6503: "
literal|"ACK received for a non-sent segment %d\n"
argument_list|,
name|seg_num
argument_list|)
expr_stmt|;
name|osmv_rmpp_send_nak
argument_list|(
name|h_bind
argument_list|,
name|p_mad
argument_list|,
name|p_mad_addr
argument_list|,
name|IB_RMPP_TYPE_ABORT
argument_list|,
name|IB_RMPP_STATUS_S2B
argument_list|)
expr_stmt|;
name|osmv_rmpp_snd_error
argument_list|(
name|p_send_ctx
argument_list|,
name|IB_REMOTE_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|dispatch_rmpp_snd_done
goto|;
block|}
name|osm_log
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"__osmv_dispatch_rmpp_snd: "
literal|"New WL = %u Old WL = %u Total Segs = %u\n"
argument_list|,
name|new_wl
argument_list|,
name|old_wl
argument_list|,
name|total_segs
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_wl
operator|<
name|old_wl
condition|)
block|{
name|osm_log
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"__osmv_dispatch_rmpp_snd: ERR 6508: "
literal|"The receiver requests a smaller WL (%d) than before (%d)\n"
argument_list|,
name|new_wl
argument_list|,
name|old_wl
argument_list|)
expr_stmt|;
name|osmv_rmpp_send_nak
argument_list|(
name|h_bind
argument_list|,
name|p_mad
argument_list|,
name|p_mad_addr
argument_list|,
name|IB_RMPP_TYPE_ABORT
argument_list|,
name|IB_RMPP_STATUS_W2S
argument_list|)
expr_stmt|;
name|osmv_rmpp_snd_error
argument_list|(
name|p_send_ctx
argument_list|,
name|IB_REMOTE_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|dispatch_rmpp_snd_done
goto|;
block|}
comment|/* Update the sender's window, and optionally wake up the sender thread 	 * Note! A single ACK can acknowledge a whole range of segments: [WF..SEG_NUM] 	 */
name|osm_log
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"ACK for seg_num #%d accepted.\n"
argument_list|,
name|seg_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg_num
operator|==
name|old_wl
condition|)
block|{
name|osm_log
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"The send window [%d:%d] is totally acknowledged.\n"
argument_list|,
name|p_send_ctx
operator|->
name|window_first
argument_list|,
name|old_wl
argument_list|)
expr_stmt|;
name|p_send_ctx
operator|->
name|window_first
operator|=
name|seg_num
operator|+
literal|1
expr_stmt|;
name|p_send_ctx
operator|->
name|window_last
operator|=
operator|(
name|new_wl
operator|<
name|total_segs
operator|)
condition|?
name|new_wl
else|:
name|total_segs
expr_stmt|;
comment|/* Remove the response timeout event for the window */
name|osmv_txn_remove_timeout_ev
argument_list|(
name|h_bind
argument_list|,
name|osmv_txn_get_key
argument_list|(
name|p_txn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Wake up the sending thread */
name|cl_event_signal
argument_list|(
operator|&
name|p_send_ctx
operator|->
name|event
argument_list|)
expr_stmt|;
block|}
name|dispatch_rmpp_snd_done
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  NAME           __osmv_dispatch_rmpp_rcv()  *  *  DESCRIPTION    MAD handling by an RMPP receiver (DATA/ABORT/STOP)  */
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|__osmv_dispatch_rmpp_rcv
parameter_list|(
name|IN
name|osm_bind_handle_t
name|h_bind
parameter_list|,
name|IN
specifier|const
name|ib_mad_t
modifier|*
name|p_mad
parameter_list|,
name|IN
name|osmv_txn_ctx_t
modifier|*
name|p_txn
parameter_list|,
name|IN
specifier|const
name|osm_mad_addr_t
modifier|*
name|p_mad_addr
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|osmv_rmpp_recv_ctx_t
modifier|*
name|p_recv_ctx
init|=
name|osmv_txn_get_rmpp_recv_ctx
argument_list|(
name|p_txn
argument_list|)
decl_stmt|;
name|osmv_bind_obj_t
modifier|*
name|p_bo
init|=
operator|(
name|osmv_bind_obj_t
operator|*
operator|)
name|h_bind
decl_stmt|;
name|boolean_t
name|is_last1
init|=
name|FALSE
decl_stmt|,
name|is_last2
init|=
name|FALSE
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_new_madw
init|=
name|NULL
decl_stmt|,
modifier|*
name|p_req_madw
init|=
name|NULL
decl_stmt|;
name|ib_mad_t
modifier|*
name|p_mad_buf
decl_stmt|;
name|uint32_t
name|size
init|=
literal|0
decl_stmt|;
name|uint64_t
name|key
init|=
name|osmv_txn_get_key
argument_list|(
name|p_txn
argument_list|)
decl_stmt|;
name|uint64_t
name|tid
init|=
name|osmv_txn_get_tid
argument_list|(
name|p_txn
argument_list|)
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
name|TRUE
operator|==
name|osmv_rmpp_is_ack
argument_list|(
name|p_mad
argument_list|)
condition|)
block|{
name|osm_log
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Not supposed to receive ACK's --> dropping the MAD\n"
argument_list|)
expr_stmt|;
goto|goto
name|dispatch_rmpp_rcv_done
goto|;
block|}
if|if
condition|(
name|TRUE
operator|==
name|osmv_rmpp_is_abort_stop
argument_list|(
name|p_mad
argument_list|)
condition|)
block|{
name|osm_log
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"__osmv_dispatch_rmpp_rcv: ERR 6504: "
literal|"The Remote Side stopped sending\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_REMOTE_ERROR
expr_stmt|;
goto|goto
name|dispatch_rmpp_rcv_done
goto|;
block|}
name|status
operator|=
name|__osmv_dispatch_accept_seg
argument_list|(
name|h_bind
argument_list|,
name|p_txn
argument_list|,
name|p_mad
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|IB_SUCCESS
case|:
comment|/* Check wheter this is the legal last MAD */
comment|/* Criteria #1: the received MAD is marked last */
name|is_last1
operator|=
name|osmv_rmpp_is_last
argument_list|(
name|p_mad
argument_list|)
expr_stmt|;
comment|/* Criteria #2: the total accumulated length hits the advertised one */
name|is_last2
operator|=
name|is_last1
expr_stmt|;
name|size
operator|=
name|osmv_rmpp_recv_ctx_get_byte_num_from_first
argument_list|(
name|p_recv_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|is_last2
operator|=
operator|(
name|osmv_rmpp_recv_ctx_get_cur_byte_num
argument_list|(
name|p_recv_ctx
argument_list|)
operator|>=
name|size
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|is_last1
operator|!=
name|is_last2
condition|)
block|{
name|osmv_rmpp_send_nak
argument_list|(
name|h_bind
argument_list|,
name|p_mad
argument_list|,
name|p_mad_addr
argument_list|,
name|IB_RMPP_TYPE_ABORT
argument_list|,
name|IB_RMPP_STATUS_BAD_LEN
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|dispatch_rmpp_rcv_done
goto|;
block|}
comment|/* TBD Consider an optimization - sending an ACK 		 * only for the last segment in the window 		 */
name|__osmv_dispatch_send_ack
argument_list|(
name|h_bind
argument_list|,
name|p_mad
argument_list|,
name|p_txn
argument_list|,
name|p_mad_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_INSUFFICIENT_RESOURCES
case|:
comment|/* An out-of-order segment received. Send the ACK anyway */
name|__osmv_dispatch_send_ack
argument_list|(
name|h_bind
argument_list|,
name|p_mad
argument_list|,
name|p_txn
argument_list|,
name|p_mad_addr
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_SUCCESS
expr_stmt|;
goto|goto
name|dispatch_rmpp_rcv_done
goto|;
case|case
name|IB_INSUFFICIENT_MEMORY
case|:
name|osmv_rmpp_send_nak
argument_list|(
name|h_bind
argument_list|,
name|p_mad
argument_list|,
name|p_mad_addr
argument_list|,
name|IB_RMPP_TYPE_STOP
argument_list|,
name|IB_RMPP_STATUS_RESX
argument_list|)
expr_stmt|;
goto|goto
name|dispatch_rmpp_rcv_done
goto|;
default|default:
comment|/* Illegal return code */
name|CL_ASSERT
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TRUE
operator|!=
name|is_last1
condition|)
block|{
name|osm_log
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"RMPP MADW assembly continues, TID=0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
goto|goto
name|dispatch_rmpp_rcv_done
goto|;
block|}
comment|/* This is the last packet. */
if|if
condition|(
literal|0
operator|==
name|size
condition|)
block|{
comment|/* The total size was not advertised in the first packet */
name|size
operator|=
name|osmv_rmpp_recv_ctx_get_byte_num_from_last
argument_list|(
name|p_recv_ctx
argument_list|)
expr_stmt|;
block|}
comment|/* 	   NOTE: the received mad might not be>= 256 bytes. 	   some MADs might contain several SA records but still be 	   less then a full MAD. 	   We have to use RMPP to send them over since on a regular 	   "simple" MAD there is no way to know how many records were sent 	 */
comment|/* Build the MAD wrapper to be returned to the user. 	 * The actual storage for the MAD is allocated there. 	 */
name|p_new_madw
operator|=
name|osm_mad_pool_get
argument_list|(
name|p_bo
operator|->
name|p_osm_pool
argument_list|,
name|h_bind
argument_list|,
name|size
argument_list|,
name|p_mad_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|p_new_madw
condition|)
block|{
name|osm_log
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"__osmv_dispatch_rmpp_rcv: ERR 6506: "
literal|"Out Of Memory - could not allocate %d bytes for the MADW\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_INSUFFICIENT_MEMORY
expr_stmt|;
goto|goto
name|dispatch_rmpp_rcv_done
goto|;
block|}
name|p_req_madw
operator|=
name|osmv_txn_get_madw
argument_list|(
name|p_txn
argument_list|)
expr_stmt|;
name|p_mad_buf
operator|=
name|osm_madw_get_mad_ptr
argument_list|(
name|p_new_madw
argument_list|)
expr_stmt|;
name|status
operator|=
name|osmv_rmpp_recv_ctx_reassemble_arbt_mad
argument_list|(
name|p_recv_ctx
argument_list|,
name|size
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|p_mad_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|IB_SUCCESS
operator|!=
name|status
condition|)
block|{
name|osm_log
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"__osmv_dispatch_rmpp_rcv: ERR 6507: "
literal|"Internal error - could not reassemble the result MAD\n"
argument_list|)
expr_stmt|;
goto|goto
name|dispatch_rmpp_rcv_done
goto|;
comment|/* What can happen here? */
block|}
comment|/* The MAD is assembled, we are about to apply the callback. 	 * Delete the transaction context, unless the transaction is double sided */
if|if
condition|(
name|FALSE
operator|==
name|osmv_txn_is_rmpp_init_by_peer
argument_list|(
name|p_txn
argument_list|)
operator|||
name|FALSE
operator|==
name|osmv_mad_is_multi_resp
argument_list|(
name|p_mad
argument_list|)
condition|)
block|{
name|osmv_txn_done
argument_list|(
name|h_bind
argument_list|,
name|key
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|osm_log
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"RMPP MADW %p assembly complete, TID=0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|p_new_madw
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|p_mad_buf
operator|->
name|trans_id
operator|=
name|cl_hton64
argument_list|(
name|tid
argument_list|)
expr_stmt|;
name|osm_log
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Restoring the original TID to 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_mad_buf
operator|->
name|trans_id
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Finally, do the job! */
name|p_bo
operator|->
name|recv_cb
argument_list|(
name|p_new_madw
argument_list|,
name|p_bo
operator|->
name|cb_context
argument_list|,
name|p_req_madw
argument_list|)
expr_stmt|;
name|dispatch_rmpp_rcv_done
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  *  NAME            __osmv_dispatch_accept_seg()  *  *  DESCRIPTION     Store a DATA segment at the RMPP receiver side,  *                  if one is received in order.  */
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|__osmv_dispatch_accept_seg
parameter_list|(
name|IN
name|osm_bind_handle_t
name|h_bind
parameter_list|,
name|IN
name|osmv_txn_ctx_t
modifier|*
name|p_txn
parameter_list|,
name|IN
specifier|const
name|ib_mad_t
modifier|*
name|p_mad
parameter_list|)
block|{
name|ib_api_status_t
name|ret
init|=
name|IB_SUCCESS
decl_stmt|;
name|uint32_t
name|seg_num
init|=
name|cl_ntoh32
argument_list|(
operator|(
operator|(
name|ib_rmpp_mad_t
operator|*
operator|)
name|p_mad
operator|)
operator|->
name|seg_num
argument_list|)
decl_stmt|;
name|osmv_rmpp_recv_ctx_t
modifier|*
name|p_recv_ctx
init|=
name|osmv_txn_get_rmpp_recv_ctx
argument_list|(
name|p_txn
argument_list|)
decl_stmt|;
name|osmv_bind_obj_t
modifier|*
name|p_bo
init|=
operator|(
name|osmv_bind_obj_t
operator|*
operator|)
name|h_bind
decl_stmt|;
name|uint64_t
name|tid
init|=
name|osmv_txn_get_tid
argument_list|(
name|p_txn
argument_list|)
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg_num
operator|!=
name|p_recv_ctx
operator|->
name|expected_seg
condition|)
block|{
name|osm_log
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"TID 0x%"
name|PRIx64
literal|": can't accept this segment (%d) - "
literal|"this is a Go-Back-N implementation\n"
argument_list|,
name|tid
argument_list|,
name|seg_num
argument_list|)
expr_stmt|;
return|return
name|IB_INSUFFICIENT_RESOURCES
return|;
block|}
comment|/* Store the packet's copy in the reassembly list. 	 * Promote the expected segment counter. 	 */
name|ret
operator|=
name|osmv_rmpp_recv_ctx_store_mad_seg
argument_list|(
name|p_recv_ctx
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|p_mad
argument_list|)
expr_stmt|;
if|if
condition|(
name|IB_SUCCESS
operator|!=
name|ret
condition|)
block|{
return|return
name|ret
return|;
block|}
name|osm_log
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"TID 0x%"
name|PRIx64
literal|": segment %d accepted\n"
argument_list|,
name|tid
argument_list|,
name|seg_num
argument_list|)
expr_stmt|;
name|p_recv_ctx
operator|->
name|expected_seg
operator|=
name|seg_num
operator|+
literal|1
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_bo
operator|->
name|p_vendor
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|IB_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  *  NAME              __osmv_dispatch_send_ack()  *  *  DESCRIPTION  *  *  ISSUES  *    Consider sending the ACK from an async thread  *    if problems with the receiving side processing arise.  */
end_comment

begin_function
specifier|static
name|void
name|__osmv_dispatch_send_ack
parameter_list|(
name|IN
name|osm_bind_handle_t
name|h_bind
parameter_list|,
name|IN
specifier|const
name|ib_mad_t
modifier|*
name|p_req_mad
parameter_list|,
name|IN
name|osmv_txn_ctx_t
modifier|*
name|p_txn
parameter_list|,
name|IN
specifier|const
name|osm_mad_addr_t
modifier|*
name|p_mad_addr
parameter_list|)
block|{
name|osmv_rmpp_recv_ctx_t
modifier|*
name|p_recv_ctx
init|=
name|osmv_txn_get_rmpp_recv_ctx
argument_list|(
name|p_txn
argument_list|)
decl_stmt|;
comment|/* ACK the segment # that was accepted */
name|uint32_t
name|seg_num
init|=
name|cl_ntoh32
argument_list|(
operator|(
operator|(
name|ib_rmpp_mad_t
operator|*
operator|)
name|p_req_mad
operator|)
operator|->
name|seg_num
argument_list|)
decl_stmt|;
comment|/* NOTE! The receiver can publish the New Window Last (NWL) value 	 * that is greater than the total number of segments to be sent. 	 * It's the sender's responsibility to compute the correct number 	 * of segments to send in the next burst. 	 */
name|uint32_t
name|nwl
init|=
name|p_recv_ctx
operator|->
name|expected_seg
operator|+
name|OSMV_RMPP_RECV_WIN
operator|-
literal|1
decl_stmt|;
name|osmv_rmpp_send_ack
argument_list|(
name|h_bind
argument_list|,
name|p_req_mad
argument_list|,
name|seg_num
argument_list|,
name|nwl
argument_list|,
name|p_mad_addr
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

