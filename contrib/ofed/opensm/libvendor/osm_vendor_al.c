begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2009 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2005 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_req_t.  * This object represents the generic attribute requester.  * This object is part of the opensm family of objects.  *  */
end_comment

begin_comment
comment|/*   Next available error code: 0x300 */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OSM_VENDOR_INTF_AL
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qlist.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_thread.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_math.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_madw.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_mad_pool.h>
end_include

begin_include
include|#
directive|include
file|<vendor/osm_vendor_api.h>
end_include

begin_comment
comment|/****s* OpenSM: Vendor AL/osm_al_bind_info_t  * NAME  *   osm_al_bind_info_t  *  * DESCRIPTION  *    Structure containing bind information.  *  * SYNOPSIS  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_osm_al_bind_info
block|{
name|osm_vendor_t
modifier|*
name|p_vend
decl_stmt|;
name|void
modifier|*
name|client_context
decl_stmt|;
name|ib_qp_handle_t
name|h_qp
decl_stmt|;
name|ib_mad_svc_handle_t
name|h_svc
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|ib_pool_key_t
name|pool_key
decl_stmt|;
name|osm_vend_mad_recv_callback_t
name|rcv_callback
decl_stmt|;
name|osm_vend_mad_send_err_callback_t
name|send_err_callback
decl_stmt|;
name|osm_mad_pool_t
modifier|*
name|p_osm_pool
decl_stmt|;
name|ib_av_handle_t
name|h_dr_av
decl_stmt|;
block|}
name|osm_al_bind_info_t
typedef|;
end_typedef

begin_comment
comment|/*  * FIELDS  * p_vend  *    Pointer to the vendor object.  *  * client_context  *    User's context passed during osm_bind  *  * h_qp  *    Handle the QP for this bind.  *  * h_qp_svc  *    Handle the QP mad service for this bind.  *  * port_num  *    Port number (within the HCA) of the bound port.  *  * pool_key  *    Pool key returned by all for this QP.  *  * h_dr_av  *    Address vector handle used for all directed route SMPs.  *  * SEE ALSO  *********/
end_comment

begin_function
specifier|inline
specifier|static
name|ib_api_status_t
name|__osm_al_convert_wcs
parameter_list|(
name|IN
name|ib_wc_status_t
specifier|const
name|wc_status
parameter_list|)
block|{
switch|switch
condition|(
name|wc_status
condition|)
block|{
case|case
name|IB_WCS_SUCCESS
case|:
return|return
operator|(
name|IB_SUCCESS
operator|)
return|;
case|case
name|IB_WCS_TIMEOUT_RETRY_ERR
case|:
return|return
operator|(
name|IB_TIMEOUT
operator|)
return|;
default|default:
return|return
operator|(
name|IB_ERROR
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|__osm_al_ca_err_callback
parameter_list|(
name|IN
name|ib_async_event_rec_t
modifier|*
name|p_async_rec
parameter_list|)
block|{
name|osm_vendor_t
modifier|*
name|p_vend
init|=
operator|(
name|osm_vendor_t
operator|*
operator|)
name|p_async_rec
operator|->
name|context
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"__osm_al_ca_err_callback: ERR 3B01: "
literal|"Event on channel adapter (%s).\n"
argument_list|,
name|ib_get_async_event_str
argument_list|(
name|p_async_rec
operator|->
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__osm_al_ca_destroy_callback
parameter_list|(
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
name|osm_al_bind_info_t
modifier|*
name|p_bind
init|=
operator|(
name|osm_al_bind_info_t
operator|*
operator|)
name|context
decl_stmt|;
name|osm_vendor_t
modifier|*
name|p_vend
init|=
name|p_bind
operator|->
name|p_vend
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"__osm_al_ca_destroy_callback: "
literal|"Closing local channel adapter.\n"
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__osm_al_err_callback
parameter_list|(
name|IN
name|ib_async_event_rec_t
modifier|*
name|p_async_rec
parameter_list|)
block|{
name|osm_al_bind_info_t
modifier|*
name|p_bind
init|=
operator|(
name|osm_al_bind_info_t
operator|*
operator|)
name|p_async_rec
operator|->
name|context
decl_stmt|;
name|osm_vendor_t
modifier|*
name|p_vend
init|=
name|p_bind
operator|->
name|p_vend
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"__osm_al_err_callback: ERR 3B02: "
literal|"Error on QP (%s).\n"
argument_list|,
name|ib_get_async_event_str
argument_list|(
name|p_async_rec
operator|->
name|code
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__osm_al_send_callback
parameter_list|(
name|IN
name|void
modifier|*
name|mad_svc_context
parameter_list|,
name|IN
name|ib_mad_element_t
modifier|*
name|p_elem
parameter_list|)
block|{
name|osm_al_bind_info_t
modifier|*
specifier|const
name|p_bind
init|=
operator|(
name|osm_al_bind_info_t
operator|*
operator|)
name|mad_svc_context
decl_stmt|;
name|osm_vendor_t
modifier|*
specifier|const
name|p_vend
init|=
name|p_bind
operator|->
name|p_vend
decl_stmt|;
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
init|=
operator|(
name|osm_madw_t
operator|*
operator|)
name|p_elem
operator|->
name|context1
decl_stmt|;
name|osm_vend_wrap_t
modifier|*
specifier|const
name|p_vw
init|=
name|osm_madw_get_vend_ptr
argument_list|(
name|p_madw
argument_list|)
decl_stmt|;
name|ib_mad_t
modifier|*
name|p_mad
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_vw
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_vw
operator|->
name|h_av
argument_list|)
expr_stmt|;
comment|/* 	   Destroy the address vector as necessary. 	 */
if|if
condition|(
name|p_vw
operator|->
name|h_av
operator|!=
name|p_bind
operator|->
name|h_dr_av
condition|)
block|{
if|if
condition|(
name|osm_log_is_active
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"__osm_al_send_callback: "
literal|"Destroying av handle %p.\n"
argument_list|,
name|p_vw
operator|->
name|h_av
argument_list|)
expr_stmt|;
block|}
name|ib_destroy_av
argument_list|(
name|p_vw
operator|->
name|h_av
argument_list|)
expr_stmt|;
block|}
name|p_mad
operator|=
name|ib_get_mad_buf
argument_list|(
name|p_elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_elem
operator|->
name|resp_expected
condition|)
block|{
comment|/* 		   If the send was unsuccessful, notify the user 		   for MADs that were expecting a response. 		   A NULL mad wrapper parameter is the user's clue 		   that the transaction turned sour.  		   Otherwise, do nothing for successful sends when a 		   reponse is expected.  The mad will be returned to the 		   pool later. 		 */
name|p_madw
operator|->
name|status
operator|=
name|__osm_al_convert_wcs
argument_list|(
name|p_elem
operator|->
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_elem
operator|->
name|status
operator|!=
name|IB_WCS_SUCCESS
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"__osm_al_send_callback: "
literal|"MAD completed with work queue error: %s.\n"
argument_list|,
name|ib_get_wc_status_str
argument_list|(
name|p_elem
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			   Return any wrappers to the pool that may have been 			   pre-emptively allocated to handle a receive. 			 */
if|if
condition|(
name|p_vw
operator|->
name|p_resp_madw
condition|)
block|{
name|osm_mad_pool_put
argument_list|(
name|p_bind
operator|->
name|p_osm_pool
argument_list|,
name|p_vw
operator|->
name|p_resp_madw
argument_list|)
expr_stmt|;
name|p_vw
operator|->
name|p_resp_madw
operator|=
name|NULL
expr_stmt|;
block|}
name|p_bind
operator|->
name|send_err_callback
argument_list|(
name|p_bind
operator|->
name|client_context
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"__osm_al_send_callback: "
literal|"Returning MAD to pool, TID = 0x%"
name|PRIx64
literal|".\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_mad
operator|->
name|trans_id
argument_list|)
argument_list|)
expr_stmt|;
name|osm_mad_pool_put
argument_list|(
name|p_bind
operator|->
name|p_osm_pool
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__osm_al_rcv_callback
parameter_list|(
name|IN
name|void
modifier|*
name|mad_svc_context
parameter_list|,
name|IN
name|ib_mad_element_t
modifier|*
name|p_elem
parameter_list|)
block|{
name|osm_al_bind_info_t
modifier|*
specifier|const
name|p_bind
init|=
operator|(
name|osm_al_bind_info_t
operator|*
operator|)
name|mad_svc_context
decl_stmt|;
name|osm_vendor_t
modifier|*
specifier|const
name|p_vend
init|=
name|p_bind
operator|->
name|p_vend
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_old_madw
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_new_madw
decl_stmt|;
name|osm_vend_wrap_t
modifier|*
name|p_old_vw
decl_stmt|;
name|osm_vend_wrap_t
modifier|*
name|p_new_vw
decl_stmt|;
name|ib_mad_t
modifier|*
name|p_new_mad
decl_stmt|;
name|osm_mad_addr_t
name|mad_addr
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_elem
operator|->
name|context1
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_elem
operator|->
name|context2
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|p_new_mad
operator|=
name|ib_get_mad_buf
argument_list|(
name|p_elem
argument_list|)
expr_stmt|;
comment|/* 	   In preperation for initializing the new mad wrapper, 	   Initialize the mad_addr structure for the received wire MAD. 	 */
name|mad_addr
operator|.
name|dest_lid
operator|=
name|p_elem
operator|->
name|remote_lid
expr_stmt|;
name|mad_addr
operator|.
name|path_bits
operator|=
name|p_elem
operator|->
name|path_bits
expr_stmt|;
comment|/* TO DO - figure out which #define to use for the 2.5 Gb rate... */
name|mad_addr
operator|.
name|static_rate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p_new_mad
operator|->
name|mgmt_class
operator|==
name|IB_MCLASS_SUBN_LID
operator|||
name|p_new_mad
operator|->
name|mgmt_class
operator|==
name|IB_MCLASS_SUBN_DIR
condition|)
block|{
name|mad_addr
operator|.
name|addr_type
operator|.
name|smi
operator|.
name|source_lid
operator|=
name|p_elem
operator|->
name|remote_lid
expr_stmt|;
block|}
else|else
block|{
name|mad_addr
operator|.
name|addr_type
operator|.
name|gsi
operator|.
name|remote_qp
operator|=
name|p_elem
operator|->
name|remote_qp
expr_stmt|;
name|mad_addr
operator|.
name|addr_type
operator|.
name|gsi
operator|.
name|remote_qkey
operator|=
name|p_elem
operator|->
name|remote_qkey
expr_stmt|;
name|mad_addr
operator|.
name|addr_type
operator|.
name|gsi
operator|.
name|pkey_ix
operator|=
name|p_elem
operator|->
name|pkey_index
expr_stmt|;
name|mad_addr
operator|.
name|addr_type
operator|.
name|gsi
operator|.
name|service_level
operator|=
name|p_elem
operator|->
name|remote_sl
expr_stmt|;
name|mad_addr
operator|.
name|addr_type
operator|.
name|gsi
operator|.
name|global_route
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* 	   If this MAD is a response to a previous request, 	   then grab our pre-allocated MAD wrapper. 	   Otherwise, allocate a new MAD wrapper. 	 */
if|if
condition|(
name|ib_mad_is_response
argument_list|(
name|p_new_mad
argument_list|)
condition|)
block|{
name|CL_ASSERT
argument_list|(
name|p_elem
operator|->
name|send_context1
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_elem
operator|->
name|send_context2
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|p_old_madw
operator|=
operator|(
name|osm_madw_t
operator|*
operator|)
name|p_elem
operator|->
name|send_context1
expr_stmt|;
name|p_old_vw
operator|=
name|osm_madw_get_vend_ptr
argument_list|(
name|p_old_madw
argument_list|)
expr_stmt|;
name|p_new_madw
operator|=
name|p_old_vw
operator|->
name|p_resp_madw
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_new_madw
argument_list|)
expr_stmt|;
name|osm_madw_init
argument_list|(
name|p_new_madw
argument_list|,
name|p_bind
argument_list|,
name|p_elem
operator|->
name|size
argument_list|,
operator|&
name|mad_addr
argument_list|)
expr_stmt|;
name|osm_madw_set_mad
argument_list|(
name|p_new_madw
argument_list|,
name|p_new_mad
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CL_ASSERT
argument_list|(
name|p_elem
operator|->
name|send_context1
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_elem
operator|->
name|send_context2
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|p_new_madw
operator|=
name|osm_mad_pool_get_wrapper
argument_list|(
name|p_bind
operator|->
name|p_osm_pool
argument_list|,
name|p_bind
argument_list|,
name|p_elem
operator|->
name|size
argument_list|,
name|p_new_mad
argument_list|,
operator|&
name|mad_addr
argument_list|)
expr_stmt|;
block|}
name|CL_ASSERT
argument_list|(
name|p_new_madw
argument_list|)
expr_stmt|;
name|p_new_vw
operator|=
name|osm_madw_get_vend_ptr
argument_list|(
name|p_new_madw
argument_list|)
expr_stmt|;
name|p_new_vw
operator|->
name|h_bind
operator|=
name|p_bind
expr_stmt|;
name|p_new_vw
operator|->
name|size
operator|=
name|p_elem
operator|->
name|size
expr_stmt|;
name|p_new_vw
operator|->
name|p_elem
operator|=
name|p_elem
expr_stmt|;
name|p_new_vw
operator|->
name|h_av
operator|=
literal|0
expr_stmt|;
name|p_new_vw
operator|->
name|p_resp_madw
operator|=
name|NULL
expr_stmt|;
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"__osm_al_rcv_callback: "
literal|"Calling receive callback function %p.\n"
argument_list|,
name|p_bind
operator|->
name|rcv_callback
argument_list|)
expr_stmt|;
name|p_bind
operator|->
name|rcv_callback
argument_list|(
name|p_new_madw
argument_list|,
name|p_bind
operator|->
name|client_context
argument_list|,
name|p_elem
operator|->
name|send_context1
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ib_api_status_t
name|osm_vendor_init
parameter_list|(
name|IN
name|osm_vendor_t
modifier|*
specifier|const
name|p_vend
parameter_list|,
name|IN
name|osm_log_t
modifier|*
specifier|const
name|p_log
parameter_list|,
name|IN
specifier|const
name|uint32_t
name|timeout
parameter_list|)
block|{
name|ib_api_status_t
name|status
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|p_vend
operator|->
name|p_log
operator|=
name|p_log
expr_stmt|;
comment|/* 	   Open our instance of AL. 	 */
name|status
operator|=
name|ib_open_al
argument_list|(
operator|&
name|p_vend
operator|->
name|h_al
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"osm_vendor_init: ERR 3B03: "
literal|"Error opening AL (%s).\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_vend
operator|->
name|timeout
operator|=
name|timeout
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|osm_vendor_t
modifier|*
name|osm_vendor_new
parameter_list|(
name|IN
name|osm_log_t
modifier|*
specifier|const
name|p_log
parameter_list|,
name|IN
specifier|const
name|uint32_t
name|timeout
parameter_list|)
block|{
name|ib_api_status_t
name|status
decl_stmt|;
name|osm_vendor_t
modifier|*
name|p_vend
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|p_vend
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p_vend
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_vend
operator|==
name|NULL
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"osm_vendor_new: ERR 3B04: "
literal|"Unable to allocate vendor object.\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|memset
argument_list|(
name|p_vend
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_vend
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_vendor_init
argument_list|(
name|p_vend
argument_list|,
name|p_log
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|free
argument_list|(
name|p_vend
argument_list|)
expr_stmt|;
name|p_vend
operator|=
name|NULL
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|p_vend
operator|)
return|;
block|}
end_function

begin_function
name|void
name|osm_vendor_delete
parameter_list|(
name|IN
name|osm_vendor_t
modifier|*
modifier|*
specifier|const
name|pp_vend
parameter_list|)
block|{
comment|/* TO DO - fill this in */
name|ib_close_al
argument_list|(
operator|(
operator|*
name|pp_vend
operator|)
operator|->
name|h_al
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|pp_vend
argument_list|)
expr_stmt|;
operator|*
name|pp_vend
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ib_api_status_t
name|__osm_ca_info_init
parameter_list|(
name|IN
name|osm_vendor_t
modifier|*
specifier|const
name|p_vend
parameter_list|,
name|IN
name|osm_ca_info_t
modifier|*
specifier|const
name|p_ca_info
parameter_list|,
name|IN
specifier|const
name|ib_net64_t
name|ca_guid
parameter_list|)
block|{
name|ib_api_status_t
name|status
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_ca_info
operator|->
name|guid
operator|=
name|ca_guid
expr_stmt|;
if|if
condition|(
name|osm_log_is_active
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|)
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"__osm_ca_info_init: "
literal|"Querying CA 0x%"
name|PRIx64
literal|".\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|ca_guid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|ib_query_ca_by_guid
argument_list|(
name|p_vend
operator|->
name|h_al
argument_list|,
name|ca_guid
argument_list|,
name|NULL
argument_list|,
operator|&
name|p_ca_info
operator|->
name|attr_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|!=
name|IB_INSUFFICIENT_MEMORY
operator|)
operator|&&
operator|(
name|status
operator|!=
name|IB_SUCCESS
operator|)
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"__osm_ca_info_init: ERR 3B05: "
literal|"Unexpected status getting CA attributes (%s).\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|CL_ASSERT
argument_list|(
name|p_ca_info
operator|->
name|attr_size
argument_list|)
expr_stmt|;
name|p_ca_info
operator|->
name|p_attr
operator|=
name|malloc
argument_list|(
name|p_ca_info
operator|->
name|attr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ca_info
operator|->
name|p_attr
operator|==
name|NULL
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"__osm_ca_info_init: ERR 3B06: "
literal|"Unable to allocate attribute storage.\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|status
operator|=
name|ib_query_ca_by_guid
argument_list|(
name|p_vend
operator|->
name|h_al
argument_list|,
name|ca_guid
argument_list|,
name|p_ca_info
operator|->
name|p_attr
argument_list|,
operator|&
name|p_ca_info
operator|->
name|attr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"__osm_ca_info_init: ERR 3B07: "
literal|"Unexpected status getting CA attributes (%s).\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|void
name|osm_ca_info_destroy
parameter_list|(
name|IN
name|osm_vendor_t
modifier|*
specifier|const
name|p_vend
parameter_list|,
name|IN
name|osm_ca_info_t
modifier|*
specifier|const
name|p_ca_info
parameter_list|)
block|{
name|OSM_LOG_ENTER
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ca_info
operator|->
name|p_attr
condition|)
name|free
argument_list|(
name|p_ca_info
operator|->
name|p_attr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_ca_info
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|osm_ca_info_t
modifier|*
name|osm_ca_info_new
parameter_list|(
name|IN
name|osm_vendor_t
modifier|*
specifier|const
name|p_vend
parameter_list|,
name|IN
specifier|const
name|ib_net64_t
name|ca_guid
parameter_list|)
block|{
name|ib_api_status_t
name|status
decl_stmt|;
name|osm_ca_info_t
modifier|*
name|p_ca_info
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|ca_guid
argument_list|)
expr_stmt|;
name|p_ca_info
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p_ca_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ca_info
operator|==
name|NULL
condition|)
goto|goto
name|Exit
goto|;
name|memset
argument_list|(
name|p_ca_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_ca_info
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|__osm_ca_info_init
argument_list|(
name|p_vend
argument_list|,
name|p_ca_info
argument_list|,
name|ca_guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|osm_ca_info_destroy
argument_list|(
name|p_vend
argument_list|,
name|p_ca_info
argument_list|)
expr_stmt|;
name|p_ca_info
operator|=
name|NULL
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|p_ca_info
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ib_api_status_t
name|__osm_vendor_get_ca_guids
parameter_list|(
name|IN
name|osm_vendor_t
modifier|*
specifier|const
name|p_vend
parameter_list|,
name|IN
name|ib_net64_t
modifier|*
modifier|*
specifier|const
name|p_guids
parameter_list|,
name|IN
name|unsigned
modifier|*
specifier|const
name|p_num_guids
parameter_list|)
block|{
name|ib_api_status_t
name|status
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_guids
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_num_guids
argument_list|)
expr_stmt|;
name|status
operator|=
name|ib_get_ca_guids
argument_list|(
name|p_vend
operator|->
name|h_al
argument_list|,
name|NULL
argument_list|,
name|p_num_guids
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|!=
name|IB_INSUFFICIENT_MEMORY
operator|)
operator|&&
operator|(
name|status
operator|!=
name|IB_SUCCESS
operator|)
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"__osm_vendor_get_ca_guids: ERR 3B08: "
literal|"Unexpected status getting CA GUID array (%s).\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|*
name|p_num_guids
operator|==
literal|0
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"__osm_vendor_get_ca_guids: ERR 3B09: "
literal|"No available channel adapters.\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_INSUFFICIENT_RESOURCES
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
operator|*
name|p_guids
operator|=
name|malloc
argument_list|(
operator|*
name|p_num_guids
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|p_guids
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p_guids
operator|==
name|NULL
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"__osm_vendor_get_ca_guids: ERR 3B10: "
literal|"Unable to allocate CA GUID array.\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|status
operator|=
name|ib_get_ca_guids
argument_list|(
name|p_vend
operator|->
name|h_al
argument_list|,
operator|*
name|p_guids
argument_list|,
name|p_num_guids
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
operator|*
name|p_num_guids
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_log_is_active
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|)
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"__osm_vendor_get_ca_guids: "
literal|"Detected %u local channel adapters.\n"
argument_list|,
operator|*
name|p_num_guids
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/****f* OpenSM: CA Info/osm_ca_info_get_pi_ptr  * NAME  * osm_ca_info_get_pi_ptr  *  * DESCRIPTION  * Returns a pointer to the port attribute of the specified port  * owned by this CA.  *  * SYNOPSIS  */
end_comment

begin_function
specifier|static
name|ib_port_attr_t
modifier|*
name|__osm_ca_info_get_port_attr_ptr
parameter_list|(
name|IN
specifier|const
name|osm_ca_info_t
modifier|*
specifier|const
name|p_ca_info
parameter_list|,
name|IN
specifier|const
name|uint8_t
name|index
parameter_list|)
block|{
return|return
operator|(
operator|&
name|p_ca_info
operator|->
name|p_attr
operator|->
name|p_port_attr
index|[
name|index
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * PARAMETERS  * p_ca_info  *    [in] Pointer to a CA Info object.  *  * index  *    [in] Port "index" for which to retrieve the port attribute.  *    The index is the offset into the ca's internal array  *    of port attributes.  *  * RETURN VALUE  * Returns a pointer to the port attribute of the specified port  * owned by this CA.  *  * NOTES  *  * SEE ALSO  *********/
end_comment

begin_function
name|ib_api_status_t
name|osm_vendor_get_all_port_attr
parameter_list|(
name|IN
name|osm_vendor_t
modifier|*
specifier|const
name|p_vend
parameter_list|,
name|IN
name|ib_port_attr_t
modifier|*
specifier|const
name|p_attr_array
parameter_list|,
name|IN
name|uint32_t
modifier|*
specifier|const
name|p_num_ports
parameter_list|)
block|{
name|ib_api_status_t
name|status
decl_stmt|;
name|uint32_t
name|ca
decl_stmt|;
name|unsigned
name|ca_count
decl_stmt|;
name|uint32_t
name|port_count
init|=
literal|0
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|uint32_t
name|total_ports
init|=
literal|0
decl_stmt|;
name|ib_net64_t
modifier|*
name|p_ca_guid
init|=
name|NULL
decl_stmt|;
name|osm_ca_info_t
modifier|*
name|p_ca_info
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_vend
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_vend
operator|->
name|p_ca_info
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	   1) Determine the number of CA's 	   2) Allocate an array big enough to hold the ca info objects. 	   3) Call again to retrieve the guids. 	 */
name|status
operator|=
name|__osm_vendor_get_ca_guids
argument_list|(
name|p_vend
argument_list|,
operator|&
name|p_ca_guid
argument_list|,
operator|&
name|ca_count
argument_list|)
expr_stmt|;
name|p_vend
operator|->
name|p_ca_info
operator|=
name|malloc
argument_list|(
name|ca_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|p_vend
operator|->
name|p_ca_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_vend
operator|->
name|p_ca_info
operator|==
name|NULL
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"osm_vendor_get_all_port_attr: ERR 3B11: "
literal|"Unable to allocate CA information array.\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|memset
argument_list|(
name|p_vend
operator|->
name|p_ca_info
argument_list|,
literal|0
argument_list|,
name|ca_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|p_vend
operator|->
name|p_ca_info
argument_list|)
argument_list|)
expr_stmt|;
name|p_vend
operator|->
name|ca_count
operator|=
name|ca_count
expr_stmt|;
comment|/* 	   For each CA, retrieve the port info attributes 	 */
for|for
control|(
name|ca
operator|=
literal|0
init|;
name|ca
operator|<
name|ca_count
condition|;
name|ca
operator|++
control|)
block|{
name|p_ca_info
operator|=
operator|&
name|p_vend
operator|->
name|p_ca_info
index|[
name|ca
index|]
expr_stmt|;
name|status
operator|=
name|__osm_ca_info_init
argument_list|(
name|p_vend
argument_list|,
name|p_ca_info
argument_list|,
name|p_ca_guid
index|[
name|ca
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"osm_vendor_get_all_port_attr: ERR 3B12: "
literal|"Unable to initialize CA Info object (%s).\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|total_ports
operator|+=
name|osm_ca_info_get_num_ports
argument_list|(
name|p_ca_info
argument_list|)
expr_stmt|;
block|}
comment|/* 	   If the user supplied enough storage, return the port guids, 	   otherwise, return the appropriate error. 	 */
if|if
condition|(
operator|*
name|p_num_ports
operator|>=
name|total_ports
condition|)
block|{
for|for
control|(
name|ca
operator|=
literal|0
init|;
name|ca
operator|<
name|ca_count
condition|;
name|ca
operator|++
control|)
block|{
name|uint32_t
name|num_ports
decl_stmt|;
name|p_ca_info
operator|=
operator|&
name|p_vend
operator|->
name|p_ca_info
index|[
name|ca
index|]
expr_stmt|;
name|num_ports
operator|=
name|osm_ca_info_get_num_ports
argument_list|(
name|p_ca_info
argument_list|)
expr_stmt|;
for|for
control|(
name|port_num
operator|=
literal|0
init|;
name|port_num
operator|<
name|num_ports
condition|;
name|port_num
operator|++
control|)
block|{
name|p_attr_array
index|[
name|port_count
index|]
operator|=
operator|*
name|__osm_ca_info_get_port_attr_ptr
argument_list|(
name|p_ca_info
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|port_count
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|status
operator|=
name|IB_INSUFFICIENT_MEMORY
expr_stmt|;
block|}
operator|*
name|p_num_ports
operator|=
name|total_ports
expr_stmt|;
name|Exit
label|:
if|if
condition|(
name|p_ca_guid
condition|)
name|free
argument_list|(
name|p_ca_guid
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|ib_net64_t
name|osm_vendor_get_ca_guid
parameter_list|(
name|IN
name|osm_vendor_t
modifier|*
specifier|const
name|p_vend
parameter_list|,
name|IN
specifier|const
name|ib_net64_t
name|port_guid
parameter_list|)
block|{
name|uint8_t
name|index
decl_stmt|;
name|uint8_t
name|num_ports
decl_stmt|;
name|uint32_t
name|num_guids
init|=
literal|0
decl_stmt|;
name|osm_ca_info_t
modifier|*
name|p_ca_info
decl_stmt|;
name|uint32_t
name|ca
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|port_guid
argument_list|)
expr_stmt|;
comment|/* 	   First, locate the HCA that owns this port. 	 */
if|if
condition|(
name|p_vend
operator|->
name|p_ca_info
operator|==
name|NULL
condition|)
block|{
comment|/* 		   Initialize the osm_ca_info_t array which allows 		   us to match port GUID to CA. 		 */
name|osm_vendor_get_all_port_attr
argument_list|(
name|p_vend
argument_list|,
name|NULL
argument_list|,
operator|&
name|num_guids
argument_list|)
expr_stmt|;
block|}
name|CL_ASSERT
argument_list|(
name|p_vend
operator|->
name|p_ca_info
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_vend
operator|->
name|ca_count
argument_list|)
expr_stmt|;
for|for
control|(
name|ca
operator|=
literal|0
init|;
name|ca
operator|<
name|p_vend
operator|->
name|ca_count
condition|;
name|ca
operator|++
control|)
block|{
name|p_ca_info
operator|=
operator|&
name|p_vend
operator|->
name|p_ca_info
index|[
name|ca
index|]
expr_stmt|;
name|num_ports
operator|=
name|osm_ca_info_get_num_ports
argument_list|(
name|p_ca_info
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|num_ports
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|num_ports
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|port_guid
operator|==
name|osm_ca_info_get_port_guid
argument_list|(
name|p_ca_info
argument_list|,
name|index
argument_list|)
condition|)
block|{
name|OSM_LOG_EXIT
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|osm_ca_info_get_ca_guid
argument_list|(
name|p_ca_info
argument_list|)
operator|)
return|;
block|}
block|}
block|}
comment|/* 	   No local CA owns this guid! 	 */
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"osm_vendor_get_ca_guid: ERR 3B13: "
literal|"Unable to determine CA guid.\n"
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|osm_vendor_get_port_num
parameter_list|(
name|IN
name|osm_vendor_t
modifier|*
specifier|const
name|p_vend
parameter_list|,
name|IN
specifier|const
name|ib_net64_t
name|port_guid
parameter_list|)
block|{
name|uint8_t
name|index
decl_stmt|;
name|uint8_t
name|num_ports
decl_stmt|;
name|uint32_t
name|num_guids
init|=
literal|0
decl_stmt|;
name|osm_ca_info_t
modifier|*
name|p_ca_info
decl_stmt|;
name|uint32_t
name|ca
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|port_guid
argument_list|)
expr_stmt|;
comment|/* 	   First, locate the HCA that owns this port. 	 */
if|if
condition|(
name|p_vend
operator|->
name|p_ca_info
operator|==
name|NULL
condition|)
block|{
comment|/* 		   Initialize the osm_ca_info_t array which allows 		   us to match port GUID to CA. 		 */
name|osm_vendor_get_all_port_attr
argument_list|(
name|p_vend
argument_list|,
name|NULL
argument_list|,
operator|&
name|num_guids
argument_list|)
expr_stmt|;
block|}
name|CL_ASSERT
argument_list|(
name|p_vend
operator|->
name|p_ca_info
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_vend
operator|->
name|ca_count
argument_list|)
expr_stmt|;
for|for
control|(
name|ca
operator|=
literal|0
init|;
name|ca
operator|<
name|p_vend
operator|->
name|ca_count
condition|;
name|ca
operator|++
control|)
block|{
name|p_ca_info
operator|=
operator|&
name|p_vend
operator|->
name|p_ca_info
index|[
name|ca
index|]
expr_stmt|;
name|num_ports
operator|=
name|osm_ca_info_get_num_ports
argument_list|(
name|p_ca_info
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|num_ports
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|num_ports
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|port_guid
operator|==
name|osm_ca_info_get_port_guid
argument_list|(
name|p_ca_info
argument_list|,
name|index
argument_list|)
condition|)
block|{
name|OSM_LOG_EXIT
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|osm_ca_info_get_port_num
argument_list|(
name|p_ca_info
argument_list|,
name|index
argument_list|)
operator|)
return|;
block|}
block|}
block|}
comment|/* 	   No local CA owns this guid! 	 */
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"osm_vendor_get_port_num: ERR 3B30: "
literal|"Unable to determine CA guid.\n"
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ib_api_status_t
name|__osm_vendor_open_ca
parameter_list|(
name|IN
name|osm_vendor_t
modifier|*
specifier|const
name|p_vend
parameter_list|,
name|IN
specifier|const
name|ib_net64_t
name|port_guid
parameter_list|)
block|{
name|ib_net64_t
name|ca_guid
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|ca_guid
operator|=
name|osm_vendor_get_ca_guid
argument_list|(
name|p_vend
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ca_guid
operator|==
literal|0
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"__osm_vendor_open_ca: ERR 3B31: "
literal|"Bad port GUID value 0x%"
name|PRIx64
literal|".\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"__osm_vendor_open_ca: "
literal|"Opening HCA 0x%"
name|PRIx64
literal|".\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|ca_guid
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|ib_open_ca
argument_list|(
name|p_vend
operator|->
name|h_al
argument_list|,
name|ca_guid
argument_list|,
name|__osm_al_ca_err_callback
argument_list|,
name|p_vend
argument_list|,
operator|&
name|p_vend
operator|->
name|h_ca
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"__osm_vendor_open_ca: ERR 3B15: "
literal|"Unable to open CA (%s).\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|CL_ASSERT
argument_list|(
name|p_vend
operator|->
name|h_ca
argument_list|)
expr_stmt|;
name|status
operator|=
name|ib_alloc_pd
argument_list|(
name|p_vend
operator|->
name|h_ca
argument_list|,
name|IB_PDT_ALIAS
argument_list|,
name|p_vend
argument_list|,
operator|&
name|p_vend
operator|->
name|h_pd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|ib_close_ca
argument_list|(
name|p_vend
operator|->
name|h_ca
argument_list|,
name|__osm_al_ca_destroy_callback
argument_list|)
expr_stmt|;
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"__osm_vendor_open_ca: ERR 3B16: "
literal|"Unable to allocate protection domain (%s).\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|CL_ASSERT
argument_list|(
name|p_vend
operator|->
name|h_pd
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__osm_vendor_init_av
parameter_list|(
name|IN
specifier|const
name|osm_al_bind_info_t
modifier|*
name|p_bind
parameter_list|,
name|IN
name|ib_av_attr_t
modifier|*
name|p_av
parameter_list|)
block|{
name|memset
argument_list|(
name|p_av
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_av
argument_list|)
argument_list|)
expr_stmt|;
name|p_av
operator|->
name|port_num
operator|=
name|p_bind
operator|->
name|port_num
expr_stmt|;
name|p_av
operator|->
name|dlid
operator|=
name|IB_LID_PERMISSIVE
expr_stmt|;
block|}
end_function

begin_function
name|osm_bind_handle_t
name|osm_vendor_bind
parameter_list|(
name|IN
name|osm_vendor_t
modifier|*
specifier|const
name|p_vend
parameter_list|,
name|IN
name|osm_bind_info_t
modifier|*
specifier|const
name|p_user_bind
parameter_list|,
name|IN
name|osm_mad_pool_t
modifier|*
specifier|const
name|p_mad_pool
parameter_list|,
name|IN
name|osm_vend_mad_recv_callback_t
name|mad_recv_callback
parameter_list|,
name|IN
name|osm_vend_mad_send_err_callback_t
name|send_err_callback
parameter_list|,
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
name|ib_net64_t
name|port_guid
decl_stmt|;
name|osm_al_bind_info_t
modifier|*
name|p_bind
init|=
literal|0
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|ib_qp_create_t
name|qp_create
decl_stmt|;
name|ib_mad_svc_t
name|mad_svc
decl_stmt|;
name|ib_av_attr_t
name|av
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_user_bind
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_mad_pool
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|mad_recv_callback
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|send_err_callback
argument_list|)
expr_stmt|;
name|port_guid
operator|=
name|p_user_bind
operator|->
name|port_guid
expr_stmt|;
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"osm_vendor_bind: "
literal|"Binding to port 0x%"
name|PRIx64
literal|".\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_vend
operator|->
name|h_ca
operator|==
literal|0
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"osm_vendor_bind: "
literal|"Opening CA that owns port 0x%"
name|PRIx64
literal|".\n"
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
name|status
operator|=
name|__osm_vendor_open_ca
argument_list|(
name|p_vend
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"osm_vendor_bind: ERR 3B17: "
literal|"Unable to Open CA (%s).\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
name|p_bind
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p_bind
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_bind
operator|==
name|NULL
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"osm_vendor_bind: ERR 3B18: "
literal|"Unable to allocate internal bind object.\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|memset
argument_list|(
name|p_bind
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_bind
argument_list|)
argument_list|)
expr_stmt|;
name|p_bind
operator|->
name|p_vend
operator|=
name|p_vend
expr_stmt|;
name|p_bind
operator|->
name|client_context
operator|=
name|context
expr_stmt|;
name|p_bind
operator|->
name|port_num
operator|=
name|osm_vendor_get_port_num
argument_list|(
name|p_vend
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
name|p_bind
operator|->
name|rcv_callback
operator|=
name|mad_recv_callback
expr_stmt|;
name|p_bind
operator|->
name|send_err_callback
operator|=
name|send_err_callback
expr_stmt|;
name|p_bind
operator|->
name|p_osm_pool
operator|=
name|p_mad_pool
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_bind
operator|->
name|port_num
argument_list|)
expr_stmt|;
comment|/* 	   Get the proper QP. 	 */
name|memset
argument_list|(
operator|&
name|qp_create
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|qp_create
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_user_bind
operator|->
name|mad_class
condition|)
block|{
case|case
name|IB_MCLASS_SUBN_LID
case|:
case|case
name|IB_MCLASS_SUBN_DIR
case|:
name|qp_create
operator|.
name|qp_type
operator|=
name|IB_QPT_QP0_ALIAS
expr_stmt|;
break|break;
case|case
name|IB_MCLASS_SUBN_ADM
case|:
default|default:
name|qp_create
operator|.
name|qp_type
operator|=
name|IB_QPT_QP1_ALIAS
expr_stmt|;
break|break;
block|}
name|qp_create
operator|.
name|sq_depth
operator|=
name|p_user_bind
operator|->
name|send_q_size
expr_stmt|;
name|qp_create
operator|.
name|rq_depth
operator|=
name|p_user_bind
operator|->
name|recv_q_size
expr_stmt|;
name|qp_create
operator|.
name|sq_sge
operator|=
name|OSM_AL_SQ_SGE
expr_stmt|;
name|qp_create
operator|.
name|rq_sge
operator|=
name|OSM_AL_RQ_SGE
expr_stmt|;
name|status
operator|=
name|ib_get_spl_qp
argument_list|(
name|p_vend
operator|->
name|h_pd
argument_list|,
name|port_guid
argument_list|,
operator|&
name|qp_create
argument_list|,
name|p_bind
argument_list|,
name|__osm_al_err_callback
argument_list|,
operator|&
name|p_bind
operator|->
name|pool_key
argument_list|,
operator|&
name|p_bind
operator|->
name|h_qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|free
argument_list|(
name|p_bind
argument_list|)
expr_stmt|;
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"osm_vendor_bind: ERR 3B19: "
literal|"Unable to get QP handle (%s).\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|CL_ASSERT
argument_list|(
name|p_bind
operator|->
name|h_qp
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_bind
operator|->
name|pool_key
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mad_svc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mad_svc
argument_list|)
argument_list|)
expr_stmt|;
name|mad_svc
operator|.
name|mad_svc_context
operator|=
name|p_bind
expr_stmt|;
name|mad_svc
operator|.
name|pfn_mad_send_cb
operator|=
name|__osm_al_send_callback
expr_stmt|;
name|mad_svc
operator|.
name|pfn_mad_recv_cb
operator|=
name|__osm_al_rcv_callback
expr_stmt|;
name|mad_svc
operator|.
name|mgmt_class
operator|=
name|p_user_bind
operator|->
name|mad_class
expr_stmt|;
name|mad_svc
operator|.
name|mgmt_version
operator|=
name|p_user_bind
operator|->
name|class_version
expr_stmt|;
name|mad_svc
operator|.
name|support_unsol
operator|=
name|p_user_bind
operator|->
name|is_responder
expr_stmt|;
name|mad_svc
operator|.
name|method_array
index|[
name|IB_MAD_METHOD_GET
index|]
operator|=
name|TRUE
expr_stmt|;
name|mad_svc
operator|.
name|method_array
index|[
name|IB_MAD_METHOD_SET
index|]
operator|=
name|TRUE
expr_stmt|;
name|mad_svc
operator|.
name|method_array
index|[
name|IB_MAD_METHOD_DELETE
index|]
operator|=
name|TRUE
expr_stmt|;
name|mad_svc
operator|.
name|method_array
index|[
name|IB_MAD_METHOD_TRAP
index|]
operator|=
name|TRUE
expr_stmt|;
name|mad_svc
operator|.
name|method_array
index|[
name|IB_MAD_METHOD_GETTABLE
index|]
operator|=
name|TRUE
expr_stmt|;
name|status
operator|=
name|ib_reg_mad_svc
argument_list|(
name|p_bind
operator|->
name|h_qp
argument_list|,
operator|&
name|mad_svc
argument_list|,
operator|&
name|p_bind
operator|->
name|h_svc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|free
argument_list|(
name|p_bind
argument_list|)
expr_stmt|;
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"osm_vendor_bind: ERR 3B21: "
literal|"Unable to register QP0 MAD service (%s).\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|__osm_vendor_init_av
argument_list|(
name|p_bind
argument_list|,
operator|&
name|av
argument_list|)
expr_stmt|;
name|status
operator|=
name|ib_create_av
argument_list|(
name|p_vend
operator|->
name|h_pd
argument_list|,
operator|&
name|av
argument_list|,
operator|&
name|p_bind
operator|->
name|h_dr_av
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"osm_vendor_bind: ERR 3B22: "
literal|"Unable to create address vector (%s).\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|osm_log_is_active
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"osm_vendor_bind: "
literal|"Allocating av handle %p.\n"
argument_list|,
name|p_bind
operator|->
name|h_dr_av
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|osm_bind_handle_t
operator|)
name|p_bind
operator|)
return|;
block|}
end_function

begin_function
name|ib_mad_t
modifier|*
name|osm_vendor_get
parameter_list|(
name|IN
name|osm_bind_handle_t
name|h_bind
parameter_list|,
name|IN
specifier|const
name|uint32_t
name|mad_size
parameter_list|,
name|IN
name|osm_vend_wrap_t
modifier|*
specifier|const
name|p_vw
parameter_list|)
block|{
name|ib_mad_t
modifier|*
name|p_mad
decl_stmt|;
name|osm_al_bind_info_t
modifier|*
name|p_bind
init|=
operator|(
name|osm_al_bind_info_t
operator|*
operator|)
name|h_bind
decl_stmt|;
name|osm_vendor_t
modifier|*
name|p_vend
init|=
name|p_bind
operator|->
name|p_vend
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_vw
argument_list|)
expr_stmt|;
name|p_vw
operator|->
name|size
operator|=
name|mad_size
expr_stmt|;
name|p_vw
operator|->
name|h_bind
operator|=
name|h_bind
expr_stmt|;
comment|/* 	   Retrieve a MAD element from the pool and give the user direct 	   access to its buffer. 	 */
name|status
operator|=
name|ib_get_mad
argument_list|(
name|p_bind
operator|->
name|pool_key
argument_list|,
name|mad_size
argument_list|,
operator|&
name|p_vw
operator|->
name|p_elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"osm_vendor_get: ERR 3B25: "
literal|"Unable to acquire MAD (%s).\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|p_mad
operator|=
name|NULL
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|CL_ASSERT
argument_list|(
name|p_vw
operator|->
name|p_elem
argument_list|)
expr_stmt|;
name|p_mad
operator|=
name|ib_get_mad_buf
argument_list|(
name|p_vw
operator|->
name|p_elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_log_get_level
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
operator|>=
name|OSM_LOG_DEBUG
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"osm_vendor_get: "
literal|"Acquired MAD %p, size = %u.\n"
argument_list|,
name|p_mad
argument_list|,
name|mad_size
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|p_mad
operator|)
return|;
block|}
end_function

begin_function
name|void
name|osm_vendor_put
parameter_list|(
name|IN
name|osm_bind_handle_t
name|h_bind
parameter_list|,
name|IN
name|osm_vend_wrap_t
modifier|*
specifier|const
name|p_vw
parameter_list|)
block|{
name|osm_al_bind_info_t
modifier|*
name|p_bind
init|=
operator|(
name|osm_al_bind_info_t
operator|*
operator|)
name|h_bind
decl_stmt|;
name|osm_vendor_t
modifier|*
name|p_vend
init|=
name|p_bind
operator|->
name|p_vend
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_vw
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_vw
operator|->
name|p_elem
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_vw
operator|->
name|h_bind
operator|==
name|h_bind
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_log_get_level
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
operator|>=
name|OSM_LOG_DEBUG
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"osm_vendor_put: "
literal|"Retiring MAD %p.\n"
argument_list|,
name|ib_get_mad_buf
argument_list|(
name|p_vw
operator|->
name|p_elem
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|ib_put_mad
argument_list|(
name|p_vw
operator|->
name|p_elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"osm_vendor_put: ERR 3B26: "
literal|"Unable to retire MAD (%s).\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ib_api_status_t
name|osm_vendor_send
parameter_list|(
name|IN
name|osm_bind_handle_t
name|h_bind
parameter_list|,
name|IN
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|,
name|IN
name|boolean_t
specifier|const
name|resp_expected
parameter_list|)
block|{
name|osm_al_bind_info_t
modifier|*
specifier|const
name|p_bind
init|=
name|h_bind
decl_stmt|;
name|osm_vendor_t
modifier|*
specifier|const
name|p_vend
init|=
name|p_bind
operator|->
name|p_vend
decl_stmt|;
name|osm_vend_wrap_t
modifier|*
specifier|const
name|p_vw
init|=
name|osm_madw_get_vend_ptr
argument_list|(
name|p_madw
argument_list|)
decl_stmt|;
name|osm_mad_addr_t
modifier|*
specifier|const
name|p_mad_addr
init|=
name|osm_madw_get_mad_addr_ptr
argument_list|(
name|p_madw
argument_list|)
decl_stmt|;
name|ib_mad_t
modifier|*
specifier|const
name|p_mad
init|=
name|osm_madw_get_mad_ptr
argument_list|(
name|p_madw
argument_list|)
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|ib_mad_element_t
modifier|*
name|p_elem
decl_stmt|;
name|ib_av_attr_t
name|av
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_vw
operator|->
name|h_bind
operator|==
name|h_bind
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_vw
operator|->
name|p_elem
argument_list|)
expr_stmt|;
name|p_elem
operator|=
name|p_vw
operator|->
name|p_elem
expr_stmt|;
comment|/* 	   If a response is expected to this MAD, then preallocate 	   a mad wrapper to contain the wire MAD received in the 	   response.  Allocating a wrapper here allows for easier 	   failure paths than after we already received the wire mad. 	 */
if|if
condition|(
name|resp_expected
condition|)
block|{
name|p_vw
operator|->
name|p_resp_madw
operator|=
name|osm_mad_pool_get_wrapper_raw
argument_list|(
name|p_bind
operator|->
name|p_osm_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_vw
operator|->
name|p_resp_madw
operator|==
name|NULL
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"osm_vendor_send: ERR 3B27: "
literal|"Unable to allocate MAD wrapper.\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_INSUFFICIENT_RESOURCES
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
else|else
name|p_vw
operator|->
name|p_resp_madw
operator|=
name|NULL
expr_stmt|;
comment|/* 	   For all sends other than directed route SM MADs, 	   acquire an address vector for the destination. 	 */
if|if
condition|(
name|p_mad
operator|->
name|mgmt_class
operator|!=
name|IB_MCLASS_SUBN_DIR
condition|)
block|{
name|memset
argument_list|(
operator|&
name|av
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|av
argument_list|)
argument_list|)
expr_stmt|;
name|av
operator|.
name|port_num
operator|=
name|p_bind
operator|->
name|port_num
expr_stmt|;
name|av
operator|.
name|dlid
operator|=
name|p_mad_addr
operator|->
name|dest_lid
expr_stmt|;
name|av
operator|.
name|static_rate
operator|=
name|p_mad_addr
operator|->
name|static_rate
expr_stmt|;
name|av
operator|.
name|path_bits
operator|=
name|p_mad_addr
operator|->
name|path_bits
expr_stmt|;
if|if
condition|(
operator|(
name|p_mad
operator|->
name|mgmt_class
operator|!=
name|IB_MCLASS_SUBN_LID
operator|)
operator|&&
operator|(
name|p_mad
operator|->
name|mgmt_class
operator|!=
name|IB_MCLASS_SUBN_DIR
operator|)
condition|)
block|{
name|av
operator|.
name|sl
operator|=
name|p_mad_addr
operator|->
name|addr_type
operator|.
name|gsi
operator|.
name|service_level
expr_stmt|;
if|if
condition|(
name|p_mad_addr
operator|->
name|addr_type
operator|.
name|gsi
operator|.
name|global_route
condition|)
block|{
name|av
operator|.
name|grh_valid
operator|=
name|TRUE
expr_stmt|;
comment|/* ANIL */
comment|/* av.grh = p_mad_addr->addr_type.gsi.grh_info; */
block|}
block|}
if|if
condition|(
name|osm_log_is_active
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"osm_vendor_send: "
literal|"av.port_num 0x%X, "
literal|"av.dlid 0x%X, "
literal|"av.static_rate   %d, "
literal|"av.path_bits %d.\n"
argument_list|,
name|av
operator|.
name|port_num
argument_list|,
name|cl_ntoh16
argument_list|(
name|av
operator|.
name|dlid
argument_list|)
argument_list|,
name|av
operator|.
name|static_rate
argument_list|,
name|av
operator|.
name|path_bits
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|ib_create_av
argument_list|(
name|p_vend
operator|->
name|h_pd
argument_list|,
operator|&
name|av
argument_list|,
operator|&
name|p_vw
operator|->
name|h_av
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"osm_vendor_send: ERR 3B28: "
literal|"Unable to create address vector (%s).\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_vw
operator|->
name|p_resp_madw
condition|)
name|osm_mad_pool_put
argument_list|(
name|p_bind
operator|->
name|p_osm_pool
argument_list|,
name|p_vw
operator|->
name|p_resp_madw
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|osm_log_is_active
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"osm_vendor_send: "
literal|"Allocating av handle %p.\n"
argument_list|,
name|p_vw
operator|->
name|h_av
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|p_vw
operator|->
name|h_av
operator|=
name|p_bind
operator|->
name|h_dr_av
expr_stmt|;
block|}
name|p_elem
operator|->
name|h_av
operator|=
name|p_vw
operator|->
name|h_av
expr_stmt|;
name|p_elem
operator|->
name|context1
operator|=
name|p_madw
expr_stmt|;
name|p_elem
operator|->
name|context2
operator|=
name|NULL
expr_stmt|;
name|p_elem
operator|->
name|immediate_data
operator|=
literal|0
expr_stmt|;
name|p_elem
operator|->
name|p_grh
operator|=
name|NULL
expr_stmt|;
name|p_elem
operator|->
name|resp_expected
operator|=
name|resp_expected
expr_stmt|;
name|p_elem
operator|->
name|retry_cnt
operator|=
name|OSM_DEFAULT_RETRY_COUNT
expr_stmt|;
name|p_elem
operator|->
name|send_opt
operator|=
name|IB_SEND_OPT_SIGNALED
expr_stmt|;
name|p_elem
operator|->
name|timeout_ms
operator|=
name|p_vend
operator|->
name|timeout
expr_stmt|;
comment|/* Completion information. */
name|p_elem
operator|->
name|status
operator|=
literal|0
expr_stmt|;
comment|/* Not trusting AL */
if|if
condition|(
operator|(
name|p_mad
operator|->
name|mgmt_class
operator|==
name|IB_MCLASS_SUBN_LID
operator|)
operator|||
operator|(
name|p_mad
operator|->
name|mgmt_class
operator|==
name|IB_MCLASS_SUBN_DIR
operator|)
condition|)
block|{
name|p_elem
operator|->
name|remote_qp
operator|=
literal|0
expr_stmt|;
name|p_elem
operator|->
name|remote_qkey
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p_elem
operator|->
name|remote_qp
operator|=
name|p_mad_addr
operator|->
name|addr_type
operator|.
name|gsi
operator|.
name|remote_qp
expr_stmt|;
name|p_elem
operator|->
name|remote_qkey
operator|=
name|p_mad_addr
operator|->
name|addr_type
operator|.
name|gsi
operator|.
name|remote_qkey
expr_stmt|;
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"osm_vendor_send: "
literal|"remote qp = 0x%X, remote qkey = 0x%X.\n"
argument_list|,
name|cl_ntoh32
argument_list|(
name|p_elem
operator|->
name|remote_qp
argument_list|)
argument_list|,
name|cl_ntoh32
argument_list|(
name|p_elem
operator|->
name|remote_qkey
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|ib_send_mad
argument_list|(
name|p_bind
operator|->
name|h_svc
argument_list|,
name|p_elem
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"osm_vendor_send: ERR 3B29: "
literal|"Send failed (%s).\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_vw
operator|->
name|p_resp_madw
condition|)
name|osm_mad_pool_put
argument_list|(
name|p_bind
operator|->
name|p_osm_pool
argument_list|,
name|p_vw
operator|->
name|p_resp_madw
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|ib_api_status_t
name|osm_vendor_local_lid_change
parameter_list|(
name|IN
name|osm_bind_handle_t
name|h_bind
parameter_list|)
block|{
name|osm_al_bind_info_t
modifier|*
name|p_bind
init|=
operator|(
name|osm_al_bind_info_t
operator|*
operator|)
name|h_bind
decl_stmt|;
name|osm_vendor_t
modifier|*
name|p_vend
init|=
name|p_bind
operator|->
name|p_vend
decl_stmt|;
name|ib_av_attr_t
name|av
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	   The only thing we need to do is refresh the directed 	   route address vector. 	 */
name|__osm_vendor_init_av
argument_list|(
name|p_bind
argument_list|,
operator|&
name|av
argument_list|)
expr_stmt|;
name|status
operator|=
name|ib_destroy_av
argument_list|(
name|p_bind
operator|->
name|h_dr_av
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"osm_vendor_local_lid_change: ERR 3B32: "
literal|"Unable to destroy address vector (%s).\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|status
operator|=
name|ib_create_av
argument_list|(
name|p_vend
operator|->
name|h_pd
argument_list|,
operator|&
name|av
argument_list|,
operator|&
name|p_bind
operator|->
name|h_dr_av
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"osm_vendor_local_lid_change: ERR 3B33: "
literal|"Unable to create address vector (%s).\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|void
name|osm_vendor_set_sm
parameter_list|(
name|IN
name|osm_bind_handle_t
name|h_bind
parameter_list|,
name|IN
name|boolean_t
name|is_sm_val
parameter_list|)
block|{
name|osm_al_bind_info_t
modifier|*
name|p_bind
init|=
operator|(
name|osm_al_bind_info_t
operator|*
operator|)
name|h_bind
decl_stmt|;
name|osm_vendor_t
modifier|*
name|p_vend
init|=
name|p_bind
operator|->
name|p_vend
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|ib_port_attr_mod_t
name|attr_mod
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|attr_mod
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|attr_mod
argument_list|)
argument_list|)
expr_stmt|;
name|attr_mod
operator|.
name|cap
operator|.
name|sm
operator|=
name|is_sm_val
expr_stmt|;
name|status
operator|=
name|ib_modify_ca
argument_list|(
name|p_vend
operator|->
name|h_ca
argument_list|,
name|p_bind
operator|->
name|port_num
argument_list|,
name|IB_CA_MOD_IS_SM
argument_list|,
operator|&
name|attr_mod
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|osm_log
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"osm_vendor_set_sm: ERR 3B34: "
literal|"Unable set 'IS_SM' bit to:%u in port attributes (%s).\n"
argument_list|,
name|is_sm_val
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|p_vend
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_vendor_set_debug
parameter_list|(
name|IN
name|osm_vendor_t
modifier|*
specifier|const
name|p_vend
parameter_list|,
name|IN
name|int32_t
name|level
parameter_list|)
block|{  }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OSM_VENDOR_INTF_AL */
end_comment

end_unit

