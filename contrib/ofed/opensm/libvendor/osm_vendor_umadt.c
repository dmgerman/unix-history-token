begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2008 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2005 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_req_t.  * This object represents the generic attribute requester.  * This object is part of the opensm family of objects.  *  */
end_comment

begin_comment
comment|/*   Next available error code: 0x300 */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OSM_VENDOR_INTF_UMADT
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qlist.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_thread.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_timer.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_madw.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_mad_pool.h>
end_include

begin_include
include|#
directive|include
file|<vendor/osm_vendor_umadt.h>
end_include

begin_include
include|#
directive|include
file|<vendor/osm_umadt.h>
end_include

begin_comment
comment|/*  GEN1 includes */
end_comment

begin_include
include|#
directive|include
file|"umadt_so.h"
end_include

begin_include
include|#
directive|include
file|"ibt.h"
end_include

begin_include
include|#
directive|include
file|"statustext.h"
end_include

begin_comment
comment|/* //////////////////////////////////////////////////////////////////////// */
end_comment

begin_comment
comment|/* //////////////////////////////////////////////////////////////////////// */
end_comment

begin_comment
comment|/* //////////////////////////////////////////////////////////////////////// */
end_comment

begin_comment
comment|/* //////////////////////////////////////////////////////////////////////// */
end_comment

begin_comment
comment|/* //////////////////////////////////////////////////////////////////////// */
end_comment

begin_comment
comment|/*  */
end_comment

begin_comment
comment|/*      VENDOR_MAD_INTF */
end_comment

begin_comment
comment|/*  */
end_comment

begin_comment
comment|/* //////////////////////////////////////////////////////////////////////// */
end_comment

begin_comment
comment|/* //////////////////////////////////////////////////////////////////////// */
end_comment

begin_comment
comment|/* //////////////////////////////////////////////////////////////////////// */
end_comment

begin_comment
comment|/* //////////////////////////////////////////////////////////////////////// */
end_comment

begin_comment
comment|/* //////////////////////////////////////////////////////////////////////// */
end_comment

begin_comment
comment|/* //////////////////// */
end_comment

begin_comment
comment|/*  Globals        // */
end_comment

begin_comment
comment|/* //////////////////// */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_ib_sa_mad_vM3
block|{
name|uint8_t
name|base_ver
decl_stmt|;
name|uint8_t
name|mgmt_class
decl_stmt|;
name|uint8_t
name|class_ver
decl_stmt|;
name|uint8_t
name|method
decl_stmt|;
name|ib_net16_t
name|status
decl_stmt|;
name|ib_net16_t
name|resv
decl_stmt|;
name|ib_net64_t
name|trans_id
decl_stmt|;
name|ib_net16_t
name|attr_id
decl_stmt|;
name|ib_net16_t
name|resv1
decl_stmt|;
name|ib_net32_t
name|attr_mod
decl_stmt|;
name|ib_net64_t
name|resv2
decl_stmt|;
name|ib_net64_t
name|sm_key
decl_stmt|;
name|ib_net32_t
name|seg_num
decl_stmt|;
name|ib_net32_t
name|payload_len
decl_stmt|;
name|uint8_t
name|frag_flag
decl_stmt|;
name|uint8_t
name|edit_mod
decl_stmt|;
name|ib_net16_t
name|window
decl_stmt|;
name|ib_net16_t
name|attr_offset
decl_stmt|;
name|ib_net16_t
name|resv3
decl_stmt|;
name|ib_net64_t
name|comp_mask
decl_stmt|;
name|uint8_t
name|data
index|[
name|IB_SA_DATA_SIZE
index|]
decl_stmt|;
block|}
name|ib_sa_mad_t_vM3
typedef|;
end_typedef

begin_define
define|#
directive|define
name|DEFAULT_TIMER_INTERVAL_MSEC
value|500
end_define

begin_comment
comment|/*  500msec timer interval */
end_comment

begin_function_decl
name|void
name|__mad_recv_processor
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|boolean_t
name|__valid_mad_handle
parameter_list|(
name|IN
name|mad_bind_info_t
modifier|*
name|p_mad_bind_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|cl_status_t
name|__match_tid_context
parameter_list|(
specifier|const
name|cl_list_item_t
modifier|*
specifier|const
name|p_list_item
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__osm_vendor_timer_callback
parameter_list|(
name|IN
name|void
modifier|*
name|context
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|osm_vendor_t
modifier|*
name|osm_vendor_new
parameter_list|(
name|IN
name|osm_log_t
modifier|*
specifier|const
name|p_log
parameter_list|,
name|IN
specifier|const
name|uint32_t
name|timeout
parameter_list|)
block|{
name|ib_api_status_t
name|status
decl_stmt|;
name|umadt_obj_t
modifier|*
name|p_umadt_obj
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|p_umadt_obj
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|umadt_obj_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_umadt_obj
condition|)
block|{
name|memset
argument_list|(
name|p_umadt_obj
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|umadt_obj_t
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_vendor_init
argument_list|(
operator|(
name|osm_vendor_t
operator|*
operator|)
name|p_umadt_obj
argument_list|,
name|p_log
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|osm_vendor_delete
argument_list|(
operator|(
name|osm_vendor_t
operator|*
operator|*
operator|)
operator|&
name|p_umadt_obj
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"osm_vendor_construct: ERROR! Unable to create Umadt object!\n"
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|osm_vendor_t
operator|*
operator|)
name|p_umadt_obj
operator|)
return|;
block|}
end_function

begin_function
name|void
name|osm_vendor_delete
parameter_list|(
name|IN
name|osm_vendor_t
modifier|*
modifier|*
specifier|const
name|pp_vend
parameter_list|)
block|{
name|umadt_obj_t
modifier|*
name|p_umadt_obj
init|=
operator|(
name|umadt_obj_t
operator|*
operator|)
operator|*
name|pp_vend
decl_stmt|;
name|cl_list_item_t
modifier|*
name|p_list_item
decl_stmt|;
name|uint32_t
name|count
decl_stmt|,
name|i
decl_stmt|;
name|mad_bind_info_t
modifier|*
name|p_mad_bind_info
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_umadt_obj
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|cl_spinlock_acquire
argument_list|(
operator|&
name|p_umadt_obj
operator|->
name|register_lock
argument_list|)
expr_stmt|;
name|p_mad_bind_info
operator|=
operator|(
name|mad_bind_info_t
operator|*
operator|)
name|cl_qlist_head
argument_list|(
operator|&
name|p_umadt_obj
operator|->
name|register_list
argument_list|)
expr_stmt|;
name|count
operator|=
name|cl_qlist_count
argument_list|(
operator|&
name|p_umadt_obj
operator|->
name|register_list
argument_list|)
expr_stmt|;
name|cl_spinlock_release
argument_list|(
operator|&
name|p_umadt_obj
operator|->
name|register_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|cl_spinlock_acquire
argument_list|(
operator|&
name|p_umadt_obj
operator|->
name|register_lock
argument_list|)
expr_stmt|;
name|p_list_item
operator|=
name|cl_qlist_next
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|list_item
argument_list|)
expr_stmt|;
name|cl_spinlock_release
argument_list|(
operator|&
name|p_umadt_obj
operator|->
name|register_lock
argument_list|)
expr_stmt|;
comment|/*  Unbind this handle */
comment|/*  osm_vendor_ubind also removesd the item from the list */
comment|/*  osm_vendor_unbind takes the list lock so release it here */
name|osm_vendor_unbind
argument_list|(
operator|(
name|osm_bind_handle_t
operator|)
name|p_mad_bind_info
argument_list|)
expr_stmt|;
name|p_mad_bind_info
operator|=
operator|(
name|mad_bind_info_t
operator|*
operator|)
name|p_list_item
expr_stmt|;
block|}
name|dlclose
argument_list|(
name|p_umadt_obj
operator|->
name|umadt_handle
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_umadt_obj
argument_list|)
expr_stmt|;
operator|*
name|pp_vend
operator|=
name|NULL
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_umadt_obj
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* //////////////////////////////////////////////////////////////////////// */
end_comment

begin_comment
comment|/*  See VendorAbstractMadIntf.h for info */
end_comment

begin_comment
comment|/* //////////////////////////////////////////////////////////////////////// */
end_comment

begin_comment
comment|/*  */
end_comment

begin_function
name|ib_api_status_t
name|osm_vendor_init
parameter_list|(
name|IN
name|osm_vendor_t
modifier|*
specifier|const
name|p_vend
parameter_list|,
name|IN
name|osm_log_t
modifier|*
specifier|const
name|p_log
parameter_list|,
name|IN
specifier|const
name|uint32_t
name|timeout
parameter_list|)
block|{
name|FSTATUS
name|Status
decl_stmt|;
name|PUMADT_GET_INTERFACE
name|uMadtGetInterface
decl_stmt|;
name|char
modifier|*
name|error
decl_stmt|;
name|umadt_obj_t
modifier|*
name|p_umadt_obj
init|=
operator|(
name|umadt_obj_t
operator|*
operator|)
name|p_vend
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|p_umadt_obj
operator|->
name|p_log
operator|=
name|p_log
expr_stmt|;
name|p_umadt_obj
operator|->
name|timeout
operator|=
name|timeout
expr_stmt|;
name|p_umadt_obj
operator|->
name|umadt_handle
operator|=
name|dlopen
argument_list|(
literal|"libibt.so"
argument_list|,
name|RTLD_NOW
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_umadt_obj
operator|->
name|umadt_handle
condition|)
block|{
name|printf
argument_list|(
literal|"Could not load libibt.so<%s>\n"
argument_list|,
name|dlerror
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|IB_ERROR
return|;
block|}
name|uMadtGetInterface
operator|=
name|dlsym
argument_list|(
name|p_umadt_obj
operator|->
name|umadt_handle
argument_list|,
literal|"uMadtGetInterface"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|dlerror
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Could not resolve symbol uMadtGetInterface ERROR<%s>\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|IB_ERROR
return|;
block|}
name|Status
operator|=
call|(
modifier|*
name|uMadtGetInterface
call|)
argument_list|(
operator|&
name|p_umadt_obj
operator|->
name|uMadtInterface
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|!=
name|FSUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|" Error in getting uMADT interface ERROR<%d>\n"
argument_list|,
name|Status
argument_list|)
expr_stmt|;
return|return
name|IB_ERROR
return|;
block|}
comment|/*  Initialize the register list and register list lock */
name|cl_qlist_init
argument_list|(
operator|&
name|p_umadt_obj
operator|->
name|register_list
argument_list|)
expr_stmt|;
name|cl_spinlock_construct
argument_list|(
operator|&
name|p_umadt_obj
operator|->
name|register_lock
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|cl_spinlock_init
argument_list|(
operator|&
name|p_umadt_obj
operator|->
name|register_lock
argument_list|)
operator|==
name|CL_SUCCESS
argument_list|)
expr_stmt|;
name|p_umadt_obj
operator|->
name|init_done
operator|=
name|TRUE
expr_stmt|;
name|printf
argument_list|(
literal|"*****SUCCESS*****\n"
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
name|IB_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* //////////////////////////////////////////////////////////////////////// */
end_comment

begin_comment
comment|/*  See VendorAbstractMadIntf.h for info */
end_comment

begin_comment
comment|/* //////////////////////////////////////////////////////////////////////// */
end_comment

begin_function
name|ib_api_status_t
name|osm_vendor_get_ports
parameter_list|(
name|IN
name|osm_vendor_t
modifier|*
specifier|const
name|p_vend
parameter_list|,
name|IN
name|ib_net64_t
modifier|*
specifier|const
name|p_guids
parameter_list|,
name|IN
name|uint32_t
modifier|*
specifier|const
name|p_num_guids
parameter_list|)
block|{
name|char
modifier|*
name|error
init|=
name|NULL
decl_stmt|;
name|PIBT_GET_INTERFACE
name|pfnIbtGetInterface
decl_stmt|;
name|PIBT_INIT
name|pfnIbtInitFunc
decl_stmt|;
name|FSTATUS
name|Status
decl_stmt|;
name|uint32_t
name|caCount
decl_stmt|,
name|caGuidCount
decl_stmt|;
name|IB_CA_ATTRIBUTES
name|caAttributes
decl_stmt|;
name|IB_HANDLE
name|caHandle
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|IB_PORT_ATTRIBUTES
modifier|*
name|pPortAttributesList
decl_stmt|;
name|EUI64
name|CaGuidArray
index|[
literal|8
index|]
decl_stmt|;
name|void
modifier|*
name|context
decl_stmt|;
name|uint64_t
modifier|*
name|p_port_guid
decl_stmt|;
name|uint32_t
name|free_guids
decl_stmt|;
name|umadt_obj_t
modifier|*
name|p_umadt_obj
init|=
operator|(
name|umadt_obj_t
operator|*
operator|)
name|p_vend
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_umadt_obj
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_guids
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_num_guids
argument_list|)
expr_stmt|;
name|pfnIbtInitFunc
operator|=
operator|(
name|PIBT_INIT
operator|)
name|dlsym
argument_list|(
name|p_umadt_obj
operator|->
name|umadt_handle
argument_list|,
literal|"IbtInit"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pfnIbtInitFunc
condition|)
block|{
name|printf
argument_list|(
literal|"Error getting IbtInit function address.\n"
argument_list|)
expr_stmt|;
return|return
name|IB_ERROR
return|;
block|}
call|(
modifier|*
name|pfnIbtInitFunc
call|)
argument_list|()
expr_stmt|;
name|pfnIbtGetInterface
operator|=
operator|(
name|PIBT_GET_INTERFACE
operator|)
name|dlsym
argument_list|(
name|p_umadt_obj
operator|->
name|umadt_handle
argument_list|,
literal|"IbtGetInterface"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pfnIbtGetInterface
operator|||
operator|(
name|error
operator|=
name|dlerror
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Error getting IbtGetInterface function address.<%s>\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
call|(
modifier|*
name|pfnIbtGetInterface
call|)
argument_list|(
operator|&
name|p_umadt_obj
operator|->
name|IbtInterface
argument_list|)
expr_stmt|;
name|caGuidCount
operator|=
literal|8
expr_stmt|;
name|Status
operator|=
name|p_umadt_obj
operator|->
name|IbtInterface
operator|.
name|GetCaGuidArray
argument_list|(
operator|&
name|caGuidCount
argument_list|,
operator|&
name|CaGuidArray
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Status
operator|!=
name|FSUCCESS
operator|)
operator|||
operator|(
name|caGuidCount
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|FALSE
return|;
block|}
name|free_guids
operator|=
operator|*
name|p_num_guids
expr_stmt|;
name|p_port_guid
operator|=
name|p_guids
expr_stmt|;
comment|/* query each ca& copy its info into callers buffer */
for|for
control|(
name|caCount
operator|=
literal|0
init|;
name|caCount
operator|<
name|caGuidCount
condition|;
name|caCount
operator|++
control|)
block|{
name|memset
argument_list|(
operator|&
name|caAttributes
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|IB_CA_ATTRIBUTES
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Open the CA */
name|Status
operator|=
name|p_umadt_obj
operator|->
name|IbtInterface
operator|.
name|Vpi
operator|.
name|OpenCA
argument_list|(
name|CaGuidArray
index|[
name|caCount
index|]
argument_list|,
name|NULL
argument_list|,
comment|/*  CACompletionCallback */
name|NULL
argument_list|,
comment|/*  AsyncEventCallback */
name|NULL
argument_list|,
operator|&
name|caHandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|!=
name|FSUCCESS
condition|)
block|{
return|return
name|IB_ERROR
return|;
block|}
name|Status
operator|=
name|p_umadt_obj
operator|->
name|IbtInterface
operator|.
name|Vpi
operator|.
name|QueryCA
argument_list|(
name|caHandle
argument_list|,
operator|&
name|caAttributes
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|!=
name|FSUCCESS
condition|)
block|{
name|p_umadt_obj
operator|->
name|IbtInterface
operator|.
name|Vpi
operator|.
name|CloseCA
argument_list|(
name|caHandle
argument_list|)
expr_stmt|;
return|return
name|IB_ERROR
return|;
block|}
if|if
condition|(
name|caAttributes
operator|.
name|Ports
operator|>
name|free_guids
condition|)
block|{
operator|*
name|p_num_guids
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|p_guids
argument_list|,
literal|0
argument_list|,
operator|(
operator|*
name|p_num_guids
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|IB_INSUFFICIENT_MEMORY
return|;
block|}
name|pPortAttributesList
operator|=
operator|(
name|IB_PORT_ATTRIBUTES
operator|*
operator|)
name|malloc
argument_list|(
name|caAttributes
operator|.
name|PortAttributesListSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|pPortAttributesList
operator|==
name|NULL
condition|)
block|{
name|p_umadt_obj
operator|->
name|IbtInterface
operator|.
name|Vpi
operator|.
name|CloseCA
argument_list|(
name|caHandle
argument_list|)
expr_stmt|;
operator|*
name|p_num_guids
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|p_guids
argument_list|,
literal|0
argument_list|,
operator|(
operator|*
name|p_num_guids
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|IB_INSUFFICIENT_MEMORY
return|;
block|}
name|memset
argument_list|(
name|pPortAttributesList
argument_list|,
literal|0
argument_list|,
name|caAttributes
operator|.
name|PortAttributesListSize
argument_list|)
expr_stmt|;
name|caAttributes
operator|.
name|PortAttributesList
operator|=
name|pPortAttributesList
expr_stmt|;
name|Status
operator|=
name|p_umadt_obj
operator|->
name|IbtInterface
operator|.
name|Vpi
operator|.
name|QueryCA
argument_list|(
name|caHandle
argument_list|,
operator|&
name|caAttributes
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|!=
name|FSUCCESS
condition|)
block|{
name|p_umadt_obj
operator|->
name|IbtInterface
operator|.
name|Vpi
operator|.
name|CloseCA
argument_list|(
name|caHandle
argument_list|)
expr_stmt|;
operator|*
name|p_num_guids
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|p_guids
argument_list|,
literal|0
argument_list|,
operator|(
operator|*
name|p_num_guids
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|IB_ERROR
return|;
block|}
name|pPortAttributesList
operator|=
name|caAttributes
operator|.
name|PortAttributesList
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|caAttributes
operator|.
name|Ports
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
name|p_port_guid
operator|)
operator|=
name|cl_hton64
argument_list|(
operator|(
name|uint64_t
operator|)
name|pPortAttributesList
operator|->
name|GUID
argument_list|)
expr_stmt|;
name|pPortAttributesList
operator|=
name|pPortAttributesList
operator|->
name|Next
expr_stmt|;
name|p_port_guid
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|caAttributes
operator|.
name|PortAttributesList
argument_list|)
expr_stmt|;
name|p_umadt_obj
operator|->
name|IbtInterface
operator|.
name|Vpi
operator|.
name|CloseCA
argument_list|(
name|caHandle
argument_list|)
expr_stmt|;
name|free_guids
operator|=
name|free_guids
operator|-
name|caAttributes
operator|.
name|Ports
expr_stmt|;
block|}
operator|*
name|p_num_guids
operator|=
operator|*
name|p_num_guids
operator|-
name|free_guids
expr_stmt|;
return|return
name|IB_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* //////////////////////////////////////////////////////////////////////// */
end_comment

begin_comment
comment|/*  See VendorAbstractMadIntf.h for info */
end_comment

begin_comment
comment|/* //////////////////////////////////////////////////////////////////////// */
end_comment

begin_function
name|ib_mad_t
modifier|*
name|osm_vendor_get
parameter_list|(
name|IN
name|osm_bind_handle_t
name|h_bind
parameter_list|,
name|IN
specifier|const
name|uint32_t
name|mad_size
parameter_list|,
name|IN
name|osm_vend_wrap_t
modifier|*
name|p_vend_wrap
parameter_list|)
block|{
comment|/* FSTATUS Status; */
comment|/* uint32_t mad_count = 0; */
comment|/* MadtStruct *p_madt_struct; */
name|mad_bind_info_t
modifier|*
name|p_mad_bind_info
init|=
operator|(
name|mad_bind_info_t
operator|*
operator|)
name|h_bind
decl_stmt|;
name|umadt_obj_t
modifier|*
name|p_umadt_obj
init|=
name|p_mad_bind_info
operator|->
name|p_umadt_obj
decl_stmt|;
name|ib_mad_t
modifier|*
name|p_mad
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_umadt_obj
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|h_bind
argument_list|)
expr_stmt|;
name|p_umadt_obj
operator|=
name|p_mad_bind_info
operator|->
name|p_umadt_obj
expr_stmt|;
comment|/*  Sanity check */
name|CL_ASSERT
argument_list|(
name|p_umadt_obj
operator|->
name|init_done
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_vend_wrap
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|__valid_mad_handle
argument_list|(
name|p_mad_bind_info
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|mad_count = 1; 	Status = 	    p_umadt_obj->uMadtInterface.uMadtGetSendMad(p_mad_bind_info-> 							umadt_handle,&mad_count,&p_madt_struct);  	if (Status != FSUCCESS || p_madt_struct == NULL) { 		p_vend_wrap->p_madt_struct = NULL; 		return NULL; 	} 	p_vend_wrap->p_madt_struct = p_madt_struct; 	p_vend_wrap->direction = SEND; 	return ((ib_mad_t *)& p_madt_struct->IBMad);
endif|#
directive|endif
comment|/*  0 */
name|p_mad
operator|=
operator|(
name|ib_mad_t
operator|*
operator|)
name|malloc
argument_list|(
name|mad_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_mad
condition|)
block|{
name|p_vend_wrap
operator|->
name|p_madt_struct
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|p_mad
argument_list|,
literal|0
argument_list|,
name|mad_size
argument_list|)
expr_stmt|;
name|p_vend_wrap
operator|->
name|p_madt_struct
operator|=
name|NULL
expr_stmt|;
name|p_vend_wrap
operator|->
name|direction
operator|=
name|SEND
expr_stmt|;
name|p_vend_wrap
operator|->
name|size
operator|=
name|mad_size
expr_stmt|;
return|return
operator|(
name|p_mad
operator|)
return|;
block|}
end_function

begin_comment
comment|/* //////////////////////////////////////////////////////////////////////// */
end_comment

begin_comment
comment|/*  See VendorAbstractMadIntf.h for info */
end_comment

begin_comment
comment|/* //////////////////////////////////////////////////////////////////////// */
end_comment

begin_function
name|void
name|osm_vendor_put
parameter_list|(
name|IN
name|osm_bind_handle_t
name|h_bind
parameter_list|,
name|IN
name|osm_vend_wrap_t
modifier|*
specifier|const
name|p_vend_wrap
parameter_list|,
name|IN
name|ib_mad_t
modifier|*
specifier|const
name|p_mad
parameter_list|)
block|{
name|FSTATUS
name|Status
decl_stmt|;
name|mad_bind_info_t
modifier|*
name|p_mad_bind_info
decl_stmt|;
name|umadt_obj_t
modifier|*
name|p_umadt_obj
decl_stmt|;
comment|/*  */
comment|/*  Validate the vendor mad transport handle */
comment|/*  */
name|CL_ASSERT
argument_list|(
name|h_bind
argument_list|)
expr_stmt|;
name|p_mad_bind_info
operator|=
operator|(
name|mad_bind_info_t
operator|*
operator|)
name|h_bind
expr_stmt|;
name|p_umadt_obj
operator|=
name|p_mad_bind_info
operator|->
name|p_umadt_obj
expr_stmt|;
comment|/*  sanity check */
name|CL_ASSERT
argument_list|(
name|p_umadt_obj
operator|->
name|init_done
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|h_bind
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|__valid_mad_handle
argument_list|(
name|p_mad_bind_info
argument_list|)
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_vend_wrap
argument_list|)
expr_stmt|;
comment|/* CL_ASSERT( (ib_mad_t*)&p_vend_wrap->p_madt_struct->IBMad == p_mad ); */
comment|/*  Release the MAD based on the direction of the MAD */
if|if
condition|(
name|p_vend_wrap
operator|->
name|direction
operator|==
name|SEND
condition|)
block|{
comment|/*  */
comment|/* For a send the PostSend released the MAD with Umadt. Simply dealloacte the */
comment|/* local memory that was allocated on the osm_vendor_get() call. */
comment|/*  */
name|free
argument_list|(
name|p_mad
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|Status = 		    p_umadt_obj->uMadtInterface. 		    uMadtReleaseSendMad(p_mad_bind_info->umadt_handle, 					p_vend_wrap->p_madt_struct); 		if (Status != FSUCCESS) {
comment|/* printf("uMadtReleaseSendMad: Status  =<%d>\n", Status); */
block|return; 		}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|p_vend_wrap
operator|->
name|direction
operator|==
name|RECEIVE
condition|)
block|{
name|CL_ASSERT
argument_list|(
operator|(
name|ib_mad_t
operator|*
operator|)
operator|&
name|p_vend_wrap
operator|->
name|p_madt_struct
operator|->
name|IBMad
operator|==
name|p_mad
argument_list|)
expr_stmt|;
name|Status
operator|=
name|p_umadt_obj
operator|->
name|uMadtInterface
operator|.
name|uMadtReleaseRecvMad
argument_list|(
name|p_mad_bind_info
operator|->
name|umadt_handle
argument_list|,
name|p_vend_wrap
operator|->
name|p_madt_struct
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|!=
name|FSUCCESS
condition|)
block|{
comment|/* printf("uMadtReleaseRecvMad Status=<%d>\n", Status); */
return|return;
block|}
block|}
else|else
block|{
return|return;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* //////////////////////////////////////////////////////////////////////// */
end_comment

begin_comment
comment|/*  See VendorAbstractMadIntf.h for info */
end_comment

begin_comment
comment|/* //////////////////////////////////////////////////////////////////////// */
end_comment

begin_function
name|ib_api_status_t
name|osm_vendor_send
parameter_list|(
name|IN
name|osm_bind_handle_t
name|h_bind
parameter_list|,
name|IN
name|osm_vend_wrap_t
modifier|*
specifier|const
name|p_vend_wrap
parameter_list|,
name|IN
name|osm_mad_addr_t
modifier|*
specifier|const
name|p_mad_addr
parameter_list|,
name|IN
name|ib_mad_t
modifier|*
specifier|const
name|p_mad
parameter_list|,
name|IN
name|void
modifier|*
name|transaction_context
parameter_list|,
name|IN
name|boolean_t
specifier|const
name|resp_expected
parameter_list|)
block|{
name|FSTATUS
name|Status
decl_stmt|;
name|MadAddrStruct
name|destAddr
init|=
block|{
literal|0
block|}
decl_stmt|;
name|mad_bind_info_t
modifier|*
name|p_mad_bind_info
decl_stmt|;
name|trans_context_t
modifier|*
name|p_trans_context
decl_stmt|;
name|umadt_obj_t
modifier|*
name|p_umadt_obj
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|mad_count
init|=
literal|0
decl_stmt|;
name|MadtStruct
modifier|*
name|p_madt_struct
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|num_mads
init|=
literal|0
decl_stmt|;
name|uint32_t
name|seg_num
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|p_frag_data
init|=
name|NULL
decl_stmt|;
name|ib_sa_mad_t_vM3
modifier|*
name|p_sa_mad
init|=
name|NULL
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|h_bind
argument_list|)
expr_stmt|;
name|p_mad_bind_info
operator|=
operator|(
name|mad_bind_info_t
operator|*
operator|)
name|h_bind
expr_stmt|;
name|p_umadt_obj
operator|=
name|p_mad_bind_info
operator|->
name|p_umadt_obj
expr_stmt|;
comment|/*  sanity check */
name|CL_ASSERT
argument_list|(
name|p_umadt_obj
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_umadt_obj
operator|->
name|init_done
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|__valid_mad_handle
argument_list|(
name|p_mad_bind_info
argument_list|)
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_vend_wrap
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_mad_addr
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_mad
argument_list|)
expr_stmt|;
comment|/* CL_ASSERT( (ib_mad_t*)&p_vend_wrap->p_madt_struct->IBMad == p_mad ); */
comment|/*  */
comment|/*  based on the class, fill out the address info */
comment|/*  */
name|destAddr
operator|.
name|DestLid
operator|=
name|p_mad_addr
operator|->
name|dest_lid
expr_stmt|;
name|destAddr
operator|.
name|PathBits
operator|=
name|p_mad_addr
operator|->
name|path_bits
expr_stmt|;
name|destAddr
operator|.
name|StaticRate
operator|=
name|p_mad_addr
operator|->
name|static_rate
expr_stmt|;
if|if
condition|(
name|p_mad_bind_info
operator|->
name|umadt_reg_class
operator|.
name|ClassId
operator|==
name|IB_MCLASS_SUBN_LID
operator|||
name|p_mad_bind_info
operator|->
name|umadt_reg_class
operator|.
name|ClassId
operator|==
name|IB_MCLASS_SUBN_DIR
condition|)
block|{
name|CL_ASSERT
argument_list|(
name|p_mad_addr
operator|->
name|addr_type
operator|.
name|smi
operator|.
name|source_lid
argument_list|)
expr_stmt|;
name|destAddr
operator|.
name|AddrType
operator|.
name|Smi
operator|.
name|SourceLid
operator|=
name|p_mad_addr
operator|->
name|addr_type
operator|.
name|smi
operator|.
name|source_lid
expr_stmt|;
block|}
else|else
block|{
name|destAddr
operator|.
name|AddrType
operator|.
name|Gsi
operator|.
name|RemoteQpNumber
operator|=
name|p_mad_addr
operator|->
name|addr_type
operator|.
name|gsi
operator|.
name|remote_qp
expr_stmt|;
name|destAddr
operator|.
name|AddrType
operator|.
name|Gsi
operator|.
name|RemoteQkey
operator|=
name|p_mad_addr
operator|->
name|addr_type
operator|.
name|gsi
operator|.
name|remote_qkey
expr_stmt|;
name|destAddr
operator|.
name|AddrType
operator|.
name|Gsi
operator|.
name|PKey
operator|=
name|OSM_DEFAULT_PKEY
expr_stmt|;
name|destAddr
operator|.
name|AddrType
operator|.
name|Gsi
operator|.
name|ServiceLevel
operator|=
name|p_mad_addr
operator|->
name|addr_type
operator|.
name|gsi
operator|.
name|service_level
expr_stmt|;
name|destAddr
operator|.
name|AddrType
operator|.
name|Gsi
operator|.
name|GlobalRoute
operator|=
name|p_mad_addr
operator|->
name|addr_type
operator|.
name|gsi
operator|.
name|global_route
expr_stmt|;
comment|/* destAddr.AddrType.Gsi.GRHInfo = p_mad_addr->addr_type.gsi.grh_info; */
block|}
name|p_mad
operator|->
name|trans_id
operator|=
name|cl_ntoh64
argument_list|(
name|p_mad
operator|->
name|trans_id
argument_list|)
operator|<<
literal|24
expr_stmt|;
comment|/*  */
comment|/*  Create a transaction context for this send and save the TID and client context. */
comment|/*  */
if|if
condition|(
name|resp_expected
condition|)
block|{
name|p_trans_context
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|trans_context_t
argument_list|)
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_trans_context
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_trans_context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|trans_context_t
argument_list|)
argument_list|)
expr_stmt|;
name|p_trans_context
operator|->
name|trans_id
operator|=
name|p_mad
operator|->
name|trans_id
expr_stmt|;
name|p_trans_context
operator|->
name|context
operator|=
name|transaction_context
expr_stmt|;
name|p_trans_context
operator|->
name|sent_time
operator|=
name|cl_get_time_stamp
argument_list|()
expr_stmt|;
name|cl_spinlock_acquire
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|trans_ctxt_lock
argument_list|)
expr_stmt|;
name|cl_qlist_insert_tail
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|trans_ctxt_list
argument_list|,
operator|&
name|p_trans_context
operator|->
name|list_item
argument_list|)
expr_stmt|;
name|cl_spinlock_release
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|trans_ctxt_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_mad_bind_info
operator|->
name|umadt_reg_class
operator|.
name|ClassId
operator|==
name|IB_MCLASS_SUBN_LID
operator|||
name|p_mad_bind_info
operator|->
name|umadt_reg_class
operator|.
name|ClassId
operator|==
name|IB_MCLASS_SUBN_DIR
condition|)
block|{
comment|/*  Get one mad from uMadt */
name|mad_count
operator|=
literal|1
expr_stmt|;
name|Status
operator|=
name|p_umadt_obj
operator|->
name|uMadtInterface
operator|.
name|uMadtGetSendMad
argument_list|(
name|p_mad_bind_info
operator|->
name|umadt_handle
argument_list|,
operator|&
name|mad_count
argument_list|,
operator|&
name|p_madt_struct
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|!=
name|FSUCCESS
operator|||
name|p_madt_struct
operator|==
name|NULL
condition|)
block|{
return|return
name|IB_ERROR
return|;
block|}
comment|/*  No Segmentation required */
name|memcpy
argument_list|(
operator|&
name|p_madt_struct
operator|->
name|IBMad
argument_list|,
name|p_mad
argument_list|,
name|MAD_BLOCK_SIZE
argument_list|)
expr_stmt|;
comment|/*  Post the MAD */
name|Status
operator|=
name|p_umadt_obj
operator|->
name|uMadtInterface
operator|.
name|uMadtPostSend
argument_list|(
name|p_mad_bind_info
operator|->
name|umadt_handle
argument_list|,
name|p_madt_struct
argument_list|,
operator|&
name|destAddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|!=
name|FSUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"uMadtPostSendMad: Status  =<%d>\n"
argument_list|,
name|Status
argument_list|)
expr_stmt|;
return|return
name|IB_ERROR
return|;
block|}
comment|/*  Release send MAD */
name|Status
operator|=
name|p_umadt_obj
operator|->
name|uMadtInterface
operator|.
name|uMadtReleaseSendMad
argument_list|(
name|p_mad_bind_info
operator|->
name|umadt_handle
argument_list|,
name|p_madt_struct
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|!=
name|FSUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"uMadtReleaseSendMad: Status  =<%d>\n"
argument_list|,
name|Status
argument_list|)
expr_stmt|;
return|return
name|IB_ERROR
return|;
block|}
block|}
else|else
block|{
comment|/*  */
comment|/*  Segment the MAD, get the required send mads from uMadt and post the MADs. */
comment|/*  */
name|uint32_t
name|payload_len
decl_stmt|;
name|payload_len
operator|=
name|cl_ntoh32
argument_list|(
operator|(
operator|(
name|ib_sa_mad_t_vM3
operator|*
operator|)
name|p_mad
operator|)
operator|->
name|payload_len
argument_list|)
expr_stmt|;
name|num_mads
operator|=
name|payload_len
operator|/
name|IB_SA_DATA_SIZE
expr_stmt|;
if|if
condition|(
name|payload_len
operator|%
name|IB_SA_DATA_SIZE
operator|!=
literal|0
condition|)
block|{
name|num_mads
operator|++
expr_stmt|;
comment|/*  Get one additional mad for the remainder */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_mads
condition|;
name|i
operator|++
control|)
block|{
comment|/*  Get one mad from uMadt */
name|mad_count
operator|=
literal|1
expr_stmt|;
name|Status
operator|=
name|p_umadt_obj
operator|->
name|uMadtInterface
operator|.
name|uMadtGetSendMad
argument_list|(
name|p_mad_bind_info
operator|->
name|umadt_handle
argument_list|,
operator|&
name|mad_count
argument_list|,
operator|&
name|p_madt_struct
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|!=
name|FSUCCESS
operator|||
name|p_madt_struct
operator|==
name|NULL
condition|)
block|{
return|return
name|IB_ERROR
return|;
block|}
comment|/*  Copy client MAD into uMadt's MAD. */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/*  First Packet */
comment|/*  Since this is the first MAD, copy the entire MAD_SIZE */
name|memcpy
argument_list|(
operator|&
name|p_madt_struct
operator|->
name|IBMad
argument_list|,
name|p_mad
argument_list|,
name|MAD_BLOCK_SIZE
argument_list|)
expr_stmt|;
name|p_frag_data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|p_mad
operator|+
name|MAD_BLOCK_SIZE
expr_stmt|;
name|p_sa_mad
operator|=
operator|(
name|ib_sa_mad_t_vM3
operator|*
operator|)
operator|&
name|p_madt_struct
operator|->
name|IBMad
expr_stmt|;
if|if
condition|(
name|num_mads
operator|==
literal|1
condition|)
block|{
comment|/*  Only one Packet */
name|p_sa_mad
operator|->
name|seg_num
operator|=
literal|0
expr_stmt|;
name|p_sa_mad
operator|->
name|frag_flag
operator|=
literal|5
expr_stmt|;
comment|/*  Set bit 0 for first pkt and b4 for last pkt */
comment|/*  the payload length gets copied with the mad header above */
block|}
else|else
block|{
comment|/*  More than one packet in this response */
name|seg_num
operator|=
literal|1
expr_stmt|;
name|p_sa_mad
operator|->
name|seg_num
operator|=
name|cl_ntoh32
argument_list|(
name|seg_num
operator|++
argument_list|)
expr_stmt|;
name|p_sa_mad
operator|->
name|frag_flag
operator|=
literal|1
expr_stmt|;
comment|/*  Set bit 0 for first pkt */
comment|/*  the payload length gets copied with the mad header above */
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|<
name|num_mads
operator|-
literal|1
condition|)
block|{
comment|/*  Not last packet */
comment|/*  First copy only the header */
name|memcpy
argument_list|(
operator|&
name|p_madt_struct
operator|->
name|IBMad
argument_list|,
name|p_mad
argument_list|,
name|IB_SA_MAD_HDR_SIZE
argument_list|)
expr_stmt|;
comment|/*  Set the relevant fields in the SA_MAD_HEADER */
name|p_sa_mad
operator|=
operator|(
name|ib_sa_mad_t_vM3
operator|*
operator|)
operator|&
name|p_madt_struct
operator|->
name|IBMad
expr_stmt|;
name|p_sa_mad
operator|->
name|payload_len
operator|=
name|cl_ntoh32
argument_list|(
name|IB_SA_DATA_SIZE
argument_list|)
expr_stmt|;
name|p_sa_mad
operator|->
name|seg_num
operator|=
name|cl_ntoh32
argument_list|(
name|seg_num
operator|++
argument_list|)
expr_stmt|;
name|p_sa_mad
operator|->
name|frag_flag
operator|=
literal|0
expr_stmt|;
comment|/*  Now copy the fragmented data */
name|memcpy
argument_list|(
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|p_madt_struct
operator|->
name|IBMad
operator|)
operator|+
name|IB_SA_MAD_HDR_SIZE
argument_list|,
name|p_frag_data
argument_list|,
name|IB_SA_DATA_SIZE
argument_list|)
expr_stmt|;
name|p_frag_data
operator|=
name|p_frag_data
operator|+
name|IB_SA_DATA_SIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|num_mads
operator|-
literal|1
condition|)
block|{
comment|/*  Last packet */
comment|/*  First copy only the header */
name|memcpy
argument_list|(
operator|&
name|p_madt_struct
operator|->
name|IBMad
argument_list|,
name|p_mad
argument_list|,
name|IB_SA_MAD_HDR_SIZE
argument_list|)
expr_stmt|;
comment|/*  Set the relevant fields in the SA_MAD_HEADER */
name|p_sa_mad
operator|=
operator|(
name|ib_sa_mad_t_vM3
operator|*
operator|)
operator|&
name|p_madt_struct
operator|->
name|IBMad
expr_stmt|;
name|p_sa_mad
operator|->
name|seg_num
operator|=
name|cl_ntoh32
argument_list|(
name|seg_num
operator|++
argument_list|)
expr_stmt|;
name|p_sa_mad
operator|->
name|frag_flag
operator|=
literal|4
expr_stmt|;
comment|/*  Set Bit 2 for last pkt */
name|p_sa_mad
operator|->
name|payload_len
operator|=
name|cl_ntoh32
argument_list|(
name|cl_ntoh32
argument_list|(
operator|(
operator|(
name|ib_sa_mad_t_vM3
operator|*
operator|)
name|p_mad
operator|)
operator|->
name|payload_len
argument_list|)
operator|%
name|IB_SA_DATA_SIZE
argument_list|)
expr_stmt|;
comment|/*  Now copy the fragmented data */
name|memcpy
argument_list|(
operator|(
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|p_madt_struct
operator|->
name|IBMad
operator|)
operator|)
operator|+
name|IB_SA_MAD_HDR_SIZE
argument_list|,
name|p_frag_data
argument_list|,
name|cl_ntoh32
argument_list|(
name|p_sa_mad
operator|->
name|payload_len
argument_list|)
argument_list|)
expr_stmt|;
name|p_frag_data
operator|=
name|p_frag_data
operator|+
name|IB_SA_DATA_SIZE
expr_stmt|;
block|}
comment|/*  Post the MAD */
name|Status
operator|=
name|p_umadt_obj
operator|->
name|uMadtInterface
operator|.
name|uMadtPostSend
argument_list|(
name|p_mad_bind_info
operator|->
name|umadt_handle
argument_list|,
name|p_madt_struct
argument_list|,
operator|&
name|destAddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|!=
name|FSUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"uMadtPostSendMad: Status  =<%d>\n"
argument_list|,
name|Status
argument_list|)
expr_stmt|;
return|return
name|IB_ERROR
return|;
block|}
comment|/*  Release send MAD */
name|Status
operator|=
name|p_umadt_obj
operator|->
name|uMadtInterface
operator|.
name|uMadtReleaseSendMad
argument_list|(
name|p_mad_bind_info
operator|->
name|umadt_handle
argument_list|,
name|p_madt_struct
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|!=
name|FSUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"uMadtReleaseSendMad: Status  =<%d>\n"
argument_list|,
name|Status
argument_list|)
expr_stmt|;
return|return
name|IB_ERROR
return|;
block|}
block|}
block|}
return|return
operator|(
name|IB_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/* //////////////////////////////////////////////////////////////////////// */
end_comment

begin_comment
comment|/*  See VendorAbstractMadIntf.h for info */
end_comment

begin_comment
comment|/* //////////////////////////////////////////////////////////////////////// */
end_comment

begin_function
name|osm_bind_handle_t
name|osm_vendor_bind
parameter_list|(
name|IN
name|osm_vendor_t
modifier|*
specifier|const
name|p_vend
parameter_list|,
name|IN
name|osm_bind_info_t
modifier|*
specifier|const
name|p_osm_bind_info
parameter_list|,
name|IN
name|osm_mad_pool_t
modifier|*
specifier|const
name|p_mad_pool
parameter_list|,
name|IN
name|osm_vend_mad_recv_callback_t
name|mad_recv_callback
parameter_list|,
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
name|cl_status_t
name|cl_status
decl_stmt|;
name|FSTATUS
name|Status
decl_stmt|;
comment|/*  GEN1 Status for Umadt */
name|mad_bind_info_t
modifier|*
name|p_mad_bind_info
decl_stmt|;
name|RegisterClassStruct
modifier|*
name|p_umadt_reg_class
decl_stmt|;
name|umadt_obj_t
modifier|*
name|p_umadt_obj
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|(
operator|(
name|umadt_obj_t
operator|*
operator|)
name|p_vend
operator|)
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_vend
argument_list|)
expr_stmt|;
name|p_umadt_obj
operator|=
operator|(
name|umadt_obj_t
operator|*
operator|)
name|p_vend
expr_stmt|;
comment|/*  Sanity check */
name|CL_ASSERT
argument_list|(
name|p_umadt_obj
operator|->
name|init_done
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_osm_bind_info
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_mad_pool
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|mad_recv_callback
argument_list|)
expr_stmt|;
comment|/*  Allocate memory for registering the handle. */
name|p_mad_bind_info
operator|=
operator|(
name|mad_bind_info_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p_mad_bind_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_mad_bind_info
condition|)
block|{
name|memset
argument_list|(
name|p_mad_bind_info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_mad_bind_info
argument_list|)
argument_list|)
expr_stmt|;
name|p_umadt_reg_class
operator|=
operator|&
name|p_mad_bind_info
operator|->
name|umadt_reg_class
expr_stmt|;
block|}
name|p_umadt_reg_class
operator|->
name|PortGuid
operator|=
name|cl_ntoh64
argument_list|(
name|p_osm_bind_info
operator|->
name|port_guid
argument_list|)
expr_stmt|;
name|p_umadt_reg_class
operator|->
name|ClassId
operator|=
name|p_osm_bind_info
operator|->
name|mad_class
expr_stmt|;
name|p_umadt_reg_class
operator|->
name|ClassVersion
operator|=
name|p_osm_bind_info
operator|->
name|class_version
expr_stmt|;
name|p_umadt_reg_class
operator|->
name|isResponder
operator|=
name|p_osm_bind_info
operator|->
name|is_responder
expr_stmt|;
name|p_umadt_reg_class
operator|->
name|isTrapProcessor
operator|=
name|p_osm_bind_info
operator|->
name|is_trap_processor
expr_stmt|;
name|p_umadt_reg_class
operator|->
name|isReportProcessor
operator|=
name|p_osm_bind_info
operator|->
name|is_report_processor
expr_stmt|;
name|p_umadt_reg_class
operator|->
name|SendQueueSize
operator|=
name|p_osm_bind_info
operator|->
name|send_q_size
expr_stmt|;
name|p_umadt_reg_class
operator|->
name|RecvQueueSize
operator|=
name|p_osm_bind_info
operator|->
name|recv_q_size
expr_stmt|;
name|p_umadt_reg_class
operator|->
name|NotifySendCompletion
operator|=
name|TRUE
expr_stmt|;
name|p_mad_bind_info
operator|->
name|p_umadt_obj
operator|=
name|p_umadt_obj
expr_stmt|;
name|p_mad_bind_info
operator|->
name|p_mad_pool
operator|=
name|p_mad_pool
expr_stmt|;
name|p_mad_bind_info
operator|->
name|mad_recv_callback
operator|=
name|mad_recv_callback
expr_stmt|;
name|p_mad_bind_info
operator|->
name|client_context
operator|=
name|context
expr_stmt|;
comment|/*  register with Umadt for MAD interface */
name|Status
operator|=
name|p_umadt_obj
operator|->
name|uMadtInterface
operator|.
name|uMadtRegister
argument_list|(
name|p_umadt_reg_class
argument_list|,
operator|&
name|p_mad_bind_info
operator|->
name|umadt_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|!=
name|FSUCCESS
condition|)
block|{
name|free
argument_list|(
name|p_mad_bind_info
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_umadt_obj
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|OSM_BIND_INVALID_HANDLE
operator|)
return|;
block|}
name|CL_ASSERT
argument_list|(
name|p_mad_bind_info
operator|->
name|umadt_handle
argument_list|)
expr_stmt|;
comment|/*  */
comment|/*  Start a worker thread to process receives. */
comment|/*  */
name|cl_thread_construct
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|recv_processor_thread
argument_list|)
expr_stmt|;
name|cl_status
operator|=
name|cl_thread_init
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|recv_processor_thread
argument_list|,
name|__mad_recv_processor
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p_mad_bind_info
argument_list|,
literal|"mad_recv_worker"
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|cl_status
operator|==
name|CL_SUCCESS
argument_list|)
expr_stmt|;
name|cl_qlist_init
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|trans_ctxt_list
argument_list|)
expr_stmt|;
name|cl_spinlock_construct
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|trans_ctxt_lock
argument_list|)
expr_stmt|;
name|cl_spinlock_init
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|trans_ctxt_lock
argument_list|)
expr_stmt|;
name|cl_spinlock_construct
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|timeout_list_lock
argument_list|)
expr_stmt|;
name|cl_spinlock_init
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|timeout_list_lock
argument_list|)
expr_stmt|;
name|cl_status
operator|=
name|cl_timer_init
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|timeout_timer
argument_list|,
name|__osm_vendor_timer_callback
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p_mad_bind_info
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|cl_status
operator|==
name|CL_SUCCESS
argument_list|)
expr_stmt|;
name|cl_qlist_init
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|timeout_list
argument_list|)
expr_stmt|;
comment|/*  */
comment|/*  Insert the mad_reg_struct in list and return pointer to it as the handle */
comment|/*  */
name|cl_spinlock_acquire
argument_list|(
operator|&
name|p_umadt_obj
operator|->
name|register_lock
argument_list|)
expr_stmt|;
name|cl_qlist_insert_head
argument_list|(
operator|&
name|p_umadt_obj
operator|->
name|register_list
argument_list|,
operator|&
name|p_mad_bind_info
operator|->
name|list_item
argument_list|)
expr_stmt|;
name|cl_spinlock_release
argument_list|(
operator|&
name|p_umadt_obj
operator|->
name|register_lock
argument_list|)
expr_stmt|;
comment|/* 	   A timeout value of 0 means disable timeouts. 	 */
if|if
condition|(
name|p_umadt_obj
operator|->
name|timeout
condition|)
block|{
name|cl_timer_start
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|timeout_timer
argument_list|,
name|DEFAULT_TIMER_INTERVAL_MSEC
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|p_umadt_obj
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|osm_bind_handle_t
operator|)
name|p_mad_bind_info
operator|)
return|;
block|}
end_function

begin_function
name|void
name|osm_vendor_unbind
parameter_list|(
name|IN
name|osm_bind_handle_t
name|h_bind
parameter_list|)
block|{
name|mad_bind_info_t
modifier|*
name|p_mad_bind_info
decl_stmt|;
name|umadt_obj_t
modifier|*
name|p_umadt_obj
decl_stmt|;
name|cl_list_item_t
modifier|*
name|p_list_item
decl_stmt|,
modifier|*
name|p_next_list_item
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|h_bind
argument_list|)
expr_stmt|;
name|p_mad_bind_info
operator|=
operator|(
name|mad_bind_info_t
operator|*
operator|)
name|h_bind
expr_stmt|;
name|p_umadt_obj
operator|=
name|p_mad_bind_info
operator|->
name|p_umadt_obj
expr_stmt|;
comment|/*  sanity check */
name|CL_ASSERT
argument_list|(
name|p_umadt_obj
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_umadt_obj
operator|->
name|init_done
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|__valid_mad_handle
argument_list|(
name|p_mad_bind_info
argument_list|)
argument_list|)
expr_stmt|;
name|p_umadt_obj
operator|->
name|uMadtInterface
operator|.
name|uMadtDestroy
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|umadt_handle
argument_list|)
expr_stmt|;
name|cl_timer_destroy
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|timeout_timer
argument_list|)
expr_stmt|;
name|cl_thread_destroy
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|recv_processor_thread
argument_list|)
expr_stmt|;
name|cl_spinlock_acquire
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|trans_ctxt_lock
argument_list|)
expr_stmt|;
name|p_list_item
operator|=
name|cl_qlist_head
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|trans_ctxt_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_list_item
operator|!=
name|cl_qlist_end
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|trans_ctxt_list
argument_list|)
condition|)
block|{
name|p_next_list_item
operator|=
name|cl_qlist_next
argument_list|(
name|p_list_item
argument_list|)
expr_stmt|;
name|cl_qlist_remove_item
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|trans_ctxt_list
argument_list|,
name|p_list_item
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_list_item
argument_list|)
expr_stmt|;
name|p_list_item
operator|=
name|p_next_list_item
expr_stmt|;
block|}
name|cl_spinlock_release
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|trans_ctxt_lock
argument_list|)
expr_stmt|;
name|cl_spinlock_acquire
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|timeout_list_lock
argument_list|)
expr_stmt|;
name|p_list_item
operator|=
name|cl_qlist_head
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|timeout_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_list_item
operator|!=
name|cl_qlist_end
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|timeout_list
argument_list|)
condition|)
block|{
name|p_next_list_item
operator|=
name|cl_qlist_next
argument_list|(
name|p_list_item
argument_list|)
expr_stmt|;
name|cl_qlist_remove_item
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|timeout_list
argument_list|,
name|p_list_item
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_list_item
argument_list|)
expr_stmt|;
name|p_list_item
operator|=
name|p_next_list_item
expr_stmt|;
block|}
name|cl_spinlock_release
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|timeout_list_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_mad_bind_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__mad_recv_processor
parameter_list|(
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
name|mad_bind_info_t
modifier|*
name|p_mad_bind_info
init|=
operator|(
name|mad_bind_info_t
operator|*
operator|)
name|context
decl_stmt|;
name|umadt_obj_t
modifier|*
name|p_umadt_obj
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_osm_madw
init|=
name|NULL
decl_stmt|;
name|osm_vend_wrap_t
modifier|*
name|p_vend_wrap
init|=
name|NULL
decl_stmt|;
name|osm_mad_addr_t
name|osm_mad_addr
init|=
block|{
literal|0
block|}
decl_stmt|;
name|cl_list_item_t
modifier|*
name|p_list_item
decl_stmt|;
name|void
modifier|*
name|transaction_context
decl_stmt|;
name|FSTATUS
name|Status
decl_stmt|;
name|MadtStruct
modifier|*
name|pRecvMad
init|=
name|NULL
decl_stmt|;
name|MadWorkCompletion
modifier|*
name|pRecvCmp
init|=
name|NULL
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|p_mad_bind_info
operator|=
operator|(
name|mad_bind_info_t
operator|*
operator|)
name|context
expr_stmt|;
name|p_umadt_obj
operator|=
name|p_mad_bind_info
operator|->
name|p_umadt_obj
expr_stmt|;
comment|/*  PollFor a completion */
comment|/*  if FNOTFOND, then wait for a completion then again poll and return the MAD */
while|while
condition|(
literal|1
condition|)
block|{
name|Status
operator|=
name|p_umadt_obj
operator|->
name|uMadtInterface
operator|.
name|uMadtPollForRecvCompletion
argument_list|(
name|p_mad_bind_info
operator|->
name|umadt_handle
argument_list|,
operator|&
name|pRecvMad
argument_list|,
operator|&
name|pRecvCmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|!=
name|FSUCCESS
condition|)
block|{
if|if
condition|(
name|Status
operator|==
name|FNOT_FOUND
condition|)
block|{
comment|/* Wait for a completion */
name|Status
operator|=
name|p_umadt_obj
operator|->
name|uMadtInterface
operator|.
name|uMadtWaitForAnyCompletion
argument_list|(
name|p_mad_bind_info
operator|->
name|umadt_handle
argument_list|,
name|RECV_COMPLETION
argument_list|,
literal|0x5000
argument_list|)
expr_stmt|;
comment|/* 5 sec timeout */
if|if
condition|(
name|Status
operator|==
name|FTIMEOUT
condition|)
block|{
continue|continue;
block|}
name|CL_ASSERT
argument_list|(
name|Status
operator|==
name|FSUCCESS
argument_list|)
expr_stmt|;
name|Status
operator|=
name|p_umadt_obj
operator|->
name|uMadtInterface
operator|.
name|uMadtPollForRecvCompletion
argument_list|(
name|p_mad_bind_info
operator|->
name|umadt_handle
argument_list|,
operator|&
name|pRecvMad
argument_list|,
operator|&
name|pRecvCmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|Status
operator|!=
name|FSUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|" mad_recv_worker: Error in PollForRecv returning<%x>\n"
argument_list|,
name|Status
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"uMadtPollForRecvCompletion Status=<%x>\n"
argument_list|,
name|Status
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|CL_ASSERT
argument_list|(
name|pRecvMad
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|pRecvCmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ib_sa_mad_t_vM3
operator|*
operator|)
operator|(
operator|&
name|pRecvMad
operator|->
name|IBMad
operator|)
operator|)
operator|->
name|frag_flag
operator|&
literal|0x20
condition|)
block|{
comment|/*  Ignore the ACK packet */
name|Status
operator|=
name|p_umadt_obj
operator|->
name|uMadtInterface
operator|.
name|uMadtReleaseRecvMad
argument_list|(
name|p_mad_bind_info
operator|->
name|umadt_handle
argument_list|,
name|pRecvMad
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*  */
comment|/*  Extract the return address to pass it on to the client */
comment|/*  */
name|osm_mad_addr
operator|.
name|dest_lid
operator|=
name|pRecvCmp
operator|->
name|AddressInfo
operator|.
name|DestLid
expr_stmt|;
name|osm_mad_addr
operator|.
name|path_bits
operator|=
name|pRecvCmp
operator|->
name|AddressInfo
operator|.
name|PathBits
expr_stmt|;
name|osm_mad_addr
operator|.
name|static_rate
operator|=
name|pRecvCmp
operator|->
name|AddressInfo
operator|.
name|StaticRate
expr_stmt|;
if|if
condition|(
name|p_mad_bind_info
operator|->
name|umadt_reg_class
operator|.
name|ClassId
operator|==
name|IB_MCLASS_SUBN_LID
operator|||
name|p_mad_bind_info
operator|->
name|umadt_reg_class
operator|.
name|ClassId
operator|==
name|IB_MCLASS_SUBN_DIR
condition|)
block|{
name|osm_mad_addr
operator|.
name|addr_type
operator|.
name|smi
operator|.
name|source_lid
operator|=
name|pRecvCmp
operator|->
name|AddressInfo
operator|.
name|AddrType
operator|.
name|Smi
operator|.
name|SourceLid
expr_stmt|;
comment|/* osm_mad_addr.addr_type.smi.port_num = pRecvCmp->AddressInfo.AddrType.Smi.PortNumber; */
block|}
else|else
block|{
name|osm_mad_addr
operator|.
name|addr_type
operator|.
name|gsi
operator|.
name|remote_qp
operator|=
name|pRecvCmp
operator|->
name|AddressInfo
operator|.
name|AddrType
operator|.
name|Gsi
operator|.
name|RemoteQpNumber
expr_stmt|;
name|osm_mad_addr
operator|.
name|addr_type
operator|.
name|gsi
operator|.
name|remote_qkey
operator|=
name|pRecvCmp
operator|->
name|AddressInfo
operator|.
name|AddrType
operator|.
name|Gsi
operator|.
name|RemoteQkey
expr_stmt|;
name|osm_mad_addr
operator|.
name|addr_type
operator|.
name|gsi
operator|.
name|pkey_ix
operator|=
literal|0
expr_stmt|;
name|osm_mad_addr
operator|.
name|addr_type
operator|.
name|gsi
operator|.
name|service_level
operator|=
name|pRecvCmp
operator|->
name|AddressInfo
operator|.
name|AddrType
operator|.
name|Gsi
operator|.
name|ServiceLevel
expr_stmt|;
name|osm_mad_addr
operator|.
name|addr_type
operator|.
name|gsi
operator|.
name|global_route
operator|=
name|pRecvCmp
operator|->
name|AddressInfo
operator|.
name|AddrType
operator|.
name|Gsi
operator|.
name|GlobalRoute
expr_stmt|;
comment|/* osm_mad_addr.addr_type.gsi.grh_info = pRecvCmp->AddressInfo.AddrType.Gsi.GRHInfo; */
block|}
name|p_osm_madw
operator|=
name|osm_mad_pool_get_wrapper
argument_list|(
name|p_mad_bind_info
operator|->
name|p_mad_pool
argument_list|,
name|p_mad_bind_info
argument_list|,
name|MAD_BLOCK_SIZE
argument_list|,
operator|(
name|ib_mad_t
operator|*
operator|)
operator|&
name|pRecvMad
operator|->
name|IBMad
argument_list|,
operator|&
name|osm_mad_addr
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_osm_madw
argument_list|)
expr_stmt|;
name|p_vend_wrap
operator|=
name|osm_madw_get_vend_ptr
argument_list|(
name|p_osm_madw
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_vend_wrap
argument_list|)
expr_stmt|;
name|p_vend_wrap
operator|->
name|p_madt_struct
operator|=
name|pRecvMad
expr_stmt|;
name|p_vend_wrap
operator|->
name|direction
operator|=
name|RECEIVE
expr_stmt|;
name|osm_log
argument_list|(
name|p_mad_bind_info
operator|->
name|p_umadt_obj
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"__mad_recv_processor: "
literal|"Received data p_osm_madw[0x%p].\n"
argument_list|,
name|p_osm_madw
argument_list|)
expr_stmt|;
comment|/*  */
comment|/*  Do TID Processing. */
comment|/*  */
comment|/*  If R bit is set swap the TID */
name|cl_spinlock_acquire
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|trans_ctxt_lock
argument_list|)
expr_stmt|;
name|p_list_item
operator|=
name|cl_qlist_find_from_head
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|trans_ctxt_list
argument_list|,
name|__match_tid_context
argument_list|,
operator|&
name|p_osm_madw
operator|->
name|p_mad
operator|->
name|trans_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_list_item
operator|==
name|cl_qlist_end
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|trans_ctxt_list
argument_list|)
condition|)
block|{
name|transaction_context
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|transaction_context
operator|=
operator|(
operator|(
name|trans_context_t
operator|*
operator|)
name|p_list_item
operator|)
operator|->
name|context
expr_stmt|;
name|cl_qlist_remove_item
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|trans_ctxt_list
argument_list|,
name|p_list_item
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_list_item
argument_list|)
expr_stmt|;
block|}
name|cl_spinlock_release
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|trans_ctxt_lock
argument_list|)
expr_stmt|;
operator|(
operator|(
name|ib_mad_t
operator|*
operator|)
name|p_osm_madw
operator|->
name|p_mad
operator|)
operator|->
name|trans_id
operator|=
name|cl_ntoh64
argument_list|(
name|p_osm_madw
operator|->
name|p_mad
operator|->
name|trans_id
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|osm_log
argument_list|(
name|p_mad_bind_info
operator|->
name|p_umadt_obj
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"__mad_recv_processor: "
literal|"Received data p_osm_madw [0x%p]"
literal|"\n\t\t\t\tTID[0x%"
name|PRIx64
literal|", context[%p]. \n"
argument_list|,
name|p_osm_madw
argument_list|,
operator|(
operator|(
name|ib_mad_t
operator|*
operator|)
name|p_osm_madw
operator|->
name|p_mad
operator|)
operator|->
name|trans_id
argument_list|,
name|transaction_context
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|p_mad_bind_info
operator|->
name|mad_recv_callback
operator|)
operator|)
operator|(
name|p_osm_madw
operator|,
name|p_mad_bind_info
operator|->
name|client_context
operator|,
name|transaction_context
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|cl_status_t
name|__match_tid_context
parameter_list|(
specifier|const
name|cl_list_item_t
modifier|*
specifier|const
name|p_list_item
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|trans_context_t
operator|*
operator|)
name|p_list_item
operator|)
operator|->
name|trans_id
operator|==
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|context
operator|)
condition|)
return|return
name|CL_SUCCESS
return|;
return|return
name|CL_NOT_FOUND
return|;
block|}
end_function

begin_function
name|boolean_t
name|__valid_mad_handle
parameter_list|(
name|IN
name|mad_bind_info_t
modifier|*
name|p_mad_bind_info
parameter_list|)
block|{
name|umadt_obj_t
modifier|*
name|p_umadt_obj
decl_stmt|;
name|p_umadt_obj
operator|=
name|p_mad_bind_info
operator|->
name|p_umadt_obj
expr_stmt|;
name|cl_spinlock_acquire
argument_list|(
operator|&
name|p_umadt_obj
operator|->
name|register_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cl_is_item_in_qlist
argument_list|(
operator|&
name|p_umadt_obj
operator|->
name|register_list
argument_list|,
operator|&
name|p_mad_bind_info
operator|->
name|list_item
argument_list|)
condition|)
block|{
name|cl_spinlock_release
argument_list|(
operator|&
name|p_umadt_obj
operator|->
name|register_lock
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|cl_spinlock_release
argument_list|(
operator|&
name|p_umadt_obj
operator|->
name|register_lock
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
name|__osm_vendor_timer_callback
parameter_list|(
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
name|uint64_t
name|current_time
decl_stmt|;
name|mad_bind_info_t
modifier|*
name|p_mad_bind_info
decl_stmt|;
name|umadt_obj_t
modifier|*
name|p_umadt_obj
decl_stmt|;
name|uint32_t
name|timeout
decl_stmt|;
name|cl_list_item_t
modifier|*
name|p_list_item
decl_stmt|,
modifier|*
name|p_next_list_item
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|p_mad_bind_info
operator|=
operator|(
name|mad_bind_info_t
operator|*
operator|)
name|context
expr_stmt|;
name|p_umadt_obj
operator|=
name|p_mad_bind_info
operator|->
name|p_umadt_obj
expr_stmt|;
name|timeout
operator|=
name|p_umadt_obj
operator|->
name|timeout
operator|*
literal|1000
expr_stmt|;
name|current_time
operator|=
name|cl_get_time_stamp
argument_list|()
expr_stmt|;
name|cl_spinlock_acquire
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|trans_ctxt_lock
argument_list|)
expr_stmt|;
name|p_list_item
operator|=
name|cl_qlist_head
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|trans_ctxt_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_list_item
operator|!=
name|cl_qlist_end
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|trans_ctxt_list
argument_list|)
condition|)
block|{
name|p_next_list_item
operator|=
name|cl_qlist_next
argument_list|(
name|p_list_item
argument_list|)
expr_stmt|;
comment|/*  DEFAULT_PKT_TIMEOUT is in milli seconds */
if|if
condition|(
name|current_time
operator|-
operator|(
operator|(
name|trans_context_t
operator|*
operator|)
name|p_list_item
operator|)
operator|->
name|sent_time
operator|>
name|timeout
condition|)
block|{
comment|/*  Add this transaction to the timeout_list */
name|cl_qlist_remove_item
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|trans_ctxt_list
argument_list|,
name|p_list_item
argument_list|)
expr_stmt|;
name|cl_qlist_insert_tail
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|timeout_list
argument_list|,
name|p_list_item
argument_list|)
expr_stmt|;
block|}
name|p_list_item
operator|=
name|p_next_list_item
expr_stmt|;
block|}
name|cl_spinlock_release
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|trans_ctxt_lock
argument_list|)
expr_stmt|;
name|p_list_item
operator|=
name|cl_qlist_head
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|timeout_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_list_item
operator|!=
name|cl_qlist_end
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|timeout_list
argument_list|)
condition|)
block|{
name|osm_log
argument_list|(
name|p_mad_bind_info
operator|->
name|p_umadt_obj
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"__osm_vendor_timer_callback: "
literal|"Timing out transaction context [0x%p].\n"
argument_list|,
operator|(
operator|(
name|trans_context_t
operator|*
operator|)
name|p_list_item
operator|)
operator|->
name|context
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|p_mad_bind_info
operator|->
name|mad_recv_callback
operator|)
operator|)
operator|(
name|NULL
operator|,
name|p_mad_bind_info
operator|->
name|client_context
operator|,
operator|(
operator|(
name|trans_context_t
operator|*
operator|)
name|p_list_item
operator|)
operator|->
name|context
operator|)
expr_stmt|;
name|p_next_list_item
operator|=
name|cl_qlist_next
argument_list|(
name|p_list_item
argument_list|)
expr_stmt|;
name|cl_qlist_remove_item
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|timeout_list
argument_list|,
name|p_list_item
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_list_item
argument_list|)
expr_stmt|;
name|p_list_item
operator|=
name|p_next_list_item
expr_stmt|;
block|}
name|cl_timer_start
argument_list|(
operator|&
name|p_mad_bind_info
operator|->
name|timeout_timer
argument_list|,
name|DEFAULT_TIMER_INTERVAL_MSEC
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OSM_VENDOR_INTF_UMADT */
end_comment

end_unit

