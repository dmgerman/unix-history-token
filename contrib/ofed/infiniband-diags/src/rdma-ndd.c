begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2014 Intel Corporation. All Rights Reserved  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<libudev.h>
end_include

begin_decl_stmt
name|struct
name|udev
modifier|*
name|udev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|udev_monitor
modifier|*
name|mon
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"ibdiag_common.h"
end_include

begin_define
define|#
directive|define
name|SYS_HOSTNAME
value|"/proc/sys/kernel/hostname"
end_define

begin_define
define|#
directive|define
name|DEF_SYS_DIR
value|"/sys"
end_define

begin_decl_stmt
name|char
modifier|*
name|sys_dir
init|=
name|DEF_SYS_DIR
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SYS_INFINIBAND
value|"class/infiniband"
end_define

begin_define
define|#
directive|define
name|DEFAULT_RETRY_RATE
value|60
end_define

begin_define
define|#
directive|define
name|DEFAULT_RETRY_COUNT
value|0
end_define

begin_define
define|#
directive|define
name|DEFAULT_ND_FORMAT
value|"%h %d"
end_define

begin_decl_stmt
name|int
name|failure_retry_rate
init|=
name|DEFAULT_RETRY_RATE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|set_retry_cnt
init|=
name|DEFAULT_RETRY_COUNT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|foreground
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|pidfile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|newline_to_null
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|term
init|=
name|index
argument_list|(
name|str
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
if|if
condition|(
name|term
condition|)
operator|*
name|term
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|strip_domain
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|term
init|=
name|index
argument_list|(
name|str
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
name|term
condition|)
operator|*
name|term
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_node_desc
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|device
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|)
block|{
name|char
modifier|*
name|end
init|=
name|dest
operator|+
name|len
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|field
decl_stmt|;
name|char
modifier|*
name|src
init|=
name|ibd_nd_format
decl_stmt|;
while|while
condition|(
operator|*
name|src
operator|&&
operator|(
name|dest
operator|<
name|end
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|src
operator|!=
literal|'%'
condition|)
block|{
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
else|else
block|{
name|src
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|src
condition|)
block|{
case|case
literal|'h'
case|:
name|field
operator|=
name|hostname
expr_stmt|;
while|while
condition|(
operator|*
name|field
operator|&&
operator|(
operator|*
name|field
operator|!=
literal|'.'
operator|)
operator|&&
operator|(
name|dest
operator|<
name|end
operator|)
condition|)
operator|*
name|dest
operator|++
operator|=
operator|*
name|field
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|field
operator|=
name|device
expr_stmt|;
while|while
condition|(
operator|*
name|field
operator|&&
operator|(
name|dest
operator|<
name|end
operator|)
condition|)
operator|*
name|dest
operator|++
operator|=
operator|*
name|field
operator|++
expr_stmt|;
break|break;
block|}
name|src
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|dest
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|update_node_desc
parameter_list|(
specifier|const
name|char
modifier|*
name|device
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|char
name|nd
index|[
literal|128
index|]
decl_stmt|;
name|char
name|new_nd
index|[
literal|64
index|]
decl_stmt|;
name|char
name|nd_file
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|snprintf
argument_list|(
name|nd_file
argument_list|,
sizeof|sizeof
argument_list|(
name|nd_file
argument_list|)
argument_list|,
literal|"%s/%s/%s/node_desc"
argument_list|,
name|sys_dir
argument_list|,
name|SYS_INFINIBAND
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|nd_file
index|[
sizeof|sizeof
argument_list|(
name|nd_file
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|nd_file
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Failed to open %s\n"
argument_list|,
name|nd_file
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|nd
argument_list|,
sizeof|sizeof
argument_list|(
name|nd
argument_list|)
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Failed to read %s\n"
argument_list|,
name|nd_file
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|EIO
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|newline_to_null
argument_list|(
name|nd
argument_list|)
expr_stmt|;
name|build_node_desc
argument_list|(
name|new_nd
argument_list|,
sizeof|sizeof
argument_list|(
name|new_nd
argument_list|)
argument_list|,
name|device
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|force
operator|&&
name|strncmp
argument_list|(
name|new_nd
argument_list|,
name|nd
argument_list|,
sizeof|sizeof
argument_list|(
name|new_nd
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: no change (%s)\n"
argument_list|,
name|device
argument_list|,
name|new_nd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: change (%s) -> (%s)\n"
argument_list|,
name|device
argument_list|,
name|nd
argument_list|,
name|new_nd
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|new_nd
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
literal|0
expr_stmt|;
name|error
label|:
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_rdma_node_desc
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|DIR
modifier|*
name|class_dir
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dent
decl_stmt|;
name|char
name|dev_dir
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|dev_dir
argument_list|,
sizeof|sizeof
argument_list|(
name|dev_dir
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|sys_dir
argument_list|,
name|SYS_INFINIBAND
argument_list|)
expr_stmt|;
name|dev_dir
index|[
sizeof|sizeof
argument_list|(
name|dev_dir
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|class_dir
operator|=
name|opendir
argument_list|(
name|dev_dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|class_dir
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Failed to open %s"
argument_list|,
name|dev_dir
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOSYS
return|;
block|}
while|while
condition|(
operator|(
name|dent
operator|=
name|readdir
argument_list|(
name|class_dir
argument_list|)
operator|)
condition|)
block|{
name|int
name|retry
init|=
name|set_retry_cnt
decl_stmt|;
if|if
condition|(
name|dent
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
continue|continue;
while|while
condition|(
name|update_node_desc
argument_list|(
name|dent
operator|->
name|d_name
argument_list|,
name|hostname
argument_list|,
name|force
argument_list|)
operator|&&
name|retry
operator|>
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"retrying set Node Description on %s\n"
argument_list|,
name|dent
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|retry
operator|--
expr_stmt|;
block|}
block|}
name|closedir
argument_list|(
name|class_dir
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_hostname
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|memset
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|name
argument_list|,
name|len
operator|-
literal|1
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|newline_to_null
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|strip_domain
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Read %s Failed\n"
argument_list|,
name|SYS_HOSTNAME
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|EIO
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_opts
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|ch
parameter_list|,
name|char
modifier|*
name|optarg
parameter_list|)
block|{
name|unsigned
name|long
name|tmp
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|0
case|:
name|pidfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|foreground
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|tmp
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|>=
name|INT_MAX
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Invalid retry rate specified: %lu s\n"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|failure_retry_rate
operator|=
operator|(
name|int
operator|)
name|tmp
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
name|tmp
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|>=
name|INT_MAX
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Invalid retry count specified: %lu\n"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_retry_cnt
operator|=
operator|(
name|int
operator|)
name|tmp
expr_stmt|;
block|}
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MSG_MAX
value|2048
end_define

begin_function
specifier|static
name|void
name|udev_log_fn
parameter_list|(
name|struct
name|udev
modifier|*
name|ud
parameter_list|,
name|int
name|priority
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
name|int
name|off
init|=
literal|0
decl_stmt|;
name|char
name|msg
index|[
name|MSG_MAX
index|]
decl_stmt|;
name|off
operator|=
name|snprintf
argument_list|(
name|msg
argument_list|,
name|MSG_MAX
argument_list|,
literal|"libudev: %s:%d %s"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|<
name|MSG_MAX
operator|-
literal|1
condition|)
name|vsnprintf
argument_list|(
name|msg
operator|+
name|off
argument_list|,
name|MSG_MAX
operator|-
name|off
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup_udev
parameter_list|(
name|void
parameter_list|)
block|{
name|udev
operator|=
name|udev_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|udev
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"udev_new failed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|udev_set_log_fn
argument_list|(
name|udev
argument_list|,
name|udev_log_fn
argument_list|)
expr_stmt|;
name|udev_set_log_priority
argument_list|(
name|udev
argument_list|,
name|LOG_INFO
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_UDEV_GET_SYS_PATH
name|sys_dir
operator|=
operator|(
name|char
operator|*
operator|)
name|udev_get_sys_path
argument_list|(
name|udev
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|get_udev_fd
parameter_list|(
name|void
parameter_list|)
block|{
name|mon
operator|=
name|udev_monitor_new_from_netlink
argument_list|(
name|udev
argument_list|,
literal|"udev"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mon
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"udev monitoring failed\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|udev_monitor_filter_add_match_subsystem_devtype
argument_list|(
name|mon
argument_list|,
literal|"infiniband"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|udev_monitor_enable_receiving
argument_list|(
name|mon
argument_list|)
expr_stmt|;
return|return
name|udev_monitor_get_fd
argument_list|(
name|mon
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_udev_event
parameter_list|(
name|int
name|ud_fd
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|)
block|{
name|struct
name|udev_device
modifier|*
name|dev
decl_stmt|;
name|dev
operator|=
name|udev_monitor_receive_device
argument_list|(
name|mon
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
condition|)
block|{
specifier|const
name|char
modifier|*
name|device
init|=
name|udev_device_get_sysname
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|action
init|=
name|udev_device_get_action
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Device event: %s, %s, %s\n"
argument_list|,
name|udev_device_get_subsystem
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device
argument_list|,
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|device
operator|&&
name|action
operator|&&
name|strncmp
argument_list|(
name|action
argument_list|,
literal|"add"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"add"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|update_node_desc
argument_list|(
name|device
argument_list|,
name|hostname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|udev_device_unref
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|monitor
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|hostname
index|[
literal|128
index|]
decl_stmt|;
name|int
name|hn_fd
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|struct
name|pollfd
name|fds
index|[
literal|2
index|]
decl_stmt|;
name|int
name|numfds
init|=
literal|1
decl_stmt|;
name|int
name|ud_fd
decl_stmt|;
name|ud_fd
operator|=
name|get_udev_fd
argument_list|()
expr_stmt|;
if|if
condition|(
name|ud_fd
operator|>=
literal|0
condition|)
name|numfds
operator|=
literal|2
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|hn_fd
operator|=
name|open
argument_list|(
name|SYS_HOSTNAME
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|hn_fd
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Open %s Failed: retry in %d seconds\n"
argument_list|,
name|SYS_HOSTNAME
argument_list|,
name|failure_retry_rate
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
name|failure_retry_rate
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|fds
index|[
literal|0
index|]
operator|.
name|fd
operator|=
name|hn_fd
expr_stmt|;
name|fds
index|[
literal|0
index|]
operator|.
name|events
operator|=
literal|0
expr_stmt|;
name|fds
index|[
literal|0
index|]
operator|.
name|revents
operator|=
literal|0
expr_stmt|;
name|fds
index|[
literal|1
index|]
operator|.
name|fd
operator|=
name|ud_fd
expr_stmt|;
name|fds
index|[
literal|1
index|]
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
name|fds
index|[
literal|1
index|]
operator|.
name|revents
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
name|poll
argument_list|(
name|fds
argument_list|,
name|numfds
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|read_hostname
argument_list|(
name|hn_fd
argument_list|,
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|hostname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|fds
index|[
literal|0
index|]
operator|.
name|revents
operator|!=
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Hostname change: %s\n"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fds
index|[
literal|1
index|]
operator|.
name|revents
operator|!=
literal|0
condition|)
name|process_udev_event
argument_list|(
name|ud_fd
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|rc
operator|=
name|set_rdma_node_desc
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|hostname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Poll %s Failed\n"
argument_list|,
name|SYS_HOSTNAME
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|-
name|EIO
expr_stmt|;
block|}
name|close
argument_list|(
name|hn_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
name|sleep
argument_list|(
name|failure_retry_rate
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|remove_pidfile
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|pidfile
condition|)
name|unlink
argument_list|(
name|pidfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_pidfile
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|pidfile
condition|)
block|{
name|remove_pidfile
argument_list|()
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|pidfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%d\n"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Failed to write pidfile : %s\n"
argument_list|,
name|pidfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|errno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|char
name|hostname
index|[
literal|128
index|]
decl_stmt|;
name|openlog
argument_list|(
literal|"rdma-ndd"
argument_list|,
name|LOG_PID
operator||
name|LOG_PERROR
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
specifier|const
name|struct
name|ibdiag_opt
name|opts
index|[]
init|=
block|{
block|{
literal|"retry_timer"
block|,
literal|'t'
block|,
literal|1
block|,
literal|"<retry_timer>"
block|,
literal|"Length of time to sleep when system errors occur "
literal|"when attempting to poll and or read the hostname "
literal|"from the system.\n"
block|}
block|,
block|{
literal|"retry_count"
block|,
literal|'r'
block|,
literal|1
block|,
literal|"<retry_count>"
block|,
literal|"Number of times to attempt to retry setting "
literal|"of the node description on failure\n"
block|}
block|,
block|{
literal|"foreground"
block|,
literal|'f'
block|,
literal|0
block|,
name|NULL
block|,
literal|"run in the foreground instead of as a daemon\n"
block|}
block|,
block|{
literal|"pidfile"
block|,
literal|0
block|,
literal|1
block|,
literal|"<pidfile>"
block|,
literal|"specify a pid file (daemon mode only)\n"
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
name|ibdiag_process_opts
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|NULL
argument_list|,
literal|"CPDLGtsKyevd"
argument_list|,
name|opts
argument_list|,
name|process_opts
argument_list|,
literal|""
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ibd_nd_format
condition|)
name|ibd_nd_format
operator|=
name|DEFAULT_ND_FORMAT
expr_stmt|;
if|if
condition|(
operator|!
name|foreground
condition|)
block|{
name|closelog
argument_list|()
expr_stmt|;
name|openlog
argument_list|(
literal|"rdma-ndd"
argument_list|,
name|LOG_PID
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
if|if
condition|(
name|daemon
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Failed to daemonize\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|errno
argument_list|)
expr_stmt|;
block|}
name|write_pidfile
argument_list|()
expr_stmt|;
block|}
name|setup_udev
argument_list|()
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Node Descriptor format (%s)\n"
argument_list|,
name|ibd_nd_format
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|SYS_HOSTNAME
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_hostname
argument_list|(
name|fd
argument_list|,
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|hostname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|set_rdma_node_desc
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|hostname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|monitor
argument_list|()
expr_stmt|;
name|remove_pidfile
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

