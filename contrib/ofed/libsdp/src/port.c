begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   This software is available to you under a choice of one of two   licenses.  You may choose to be licensed under the terms of the GNU   General Public License (GPL) Version 2, available at<http://www.fsf.org/copyleft/gpl.html>, or the OpenIB.org BSD   license, available in the LICENSE.TXT file accompanying this   software.  These details are also available at<http://openib.org/license.html>.    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   SOFTWARE.    Copyright (c) 2004 Topspin Communications.  All rights reserved.   Copyright (c) 2005-2006 Mellanox Technologies Ltd.  All rights reserved.    $Id$ */
end_comment

begin_comment
comment|/*  * system includes  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SOLARIS_BUILD
end_ifdef

begin_comment
comment|/* Our prototypes for ioctl, get*name and accept do not strictly    match the headers - we use the following lines to move the header    versions 'out of the way' temporarily. */
end_comment

begin_define
define|#
directive|define
name|ioctl
value|__real_ioctl
end_define

begin_define
define|#
directive|define
name|getsockname
value|__real_getsockname
end_define

begin_define
define|#
directive|define
name|getpeername
value|__real_getpeername
end_define

begin_define
define|#
directive|define
name|accept
value|__real_accept
end_define

begin_define
define|#
directive|define
name|FASYNC
value|0
end_define

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
define|#
directive|define
name|__USE_GNU
end_define

begin_define
define|#
directive|define
name|_GNU_SOURCE
end_define

begin_comment
comment|/* define RTLD_NEXT */
end_comment

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_include
include|#
directive|include
file|<sys/epoll.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SOLARIS_BUILD
end_ifdef

begin_comment
comment|/* We're done protecting ourselves from the header prototypes */
end_comment

begin_undef
undef|#
directive|undef
name|ioctl
end_undef

begin_undef
undef|#
directive|undef
name|getsockname
end_undef

begin_undef
undef|#
directive|undef
name|getpeername
end_undef

begin_undef
undef|#
directive|undef
name|accept
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * SDP specific includes  */
end_comment

begin_include
include|#
directive|include
file|"libsdp.h"
end_include

begin_comment
comment|/* We can not use sizeof(sockaddr_in6) as the extra scope_id field is not a must have */
end_comment

begin_define
define|#
directive|define
name|IPV6_ADDR_IN_MIN_LEN
value|24
end_define

begin_comment
comment|/* setsockopt() level and optname declarations */
end_comment

begin_define
define|#
directive|define
name|SOL_SDP
value|1025
end_define

begin_define
define|#
directive|define
name|SDP_UNBIND
value|259
end_define

begin_comment
comment|/* Unbind socket */
end_comment

begin_comment
comment|/* Solaris has two entry socket creation functions */
end_comment

begin_define
define|#
directive|define
name|SOCKET_SEMANTIC_DEFAULT
value|0
end_define

begin_define
define|#
directive|define
name|SOCKET_SEMANTIC_XNET
value|1
end_define

begin_comment
comment|/* HACK: filter ioctl errors for FIONREAD */
end_comment

begin_define
define|#
directive|define
name|FIONREAD
value|0x541B
end_define

begin_decl_stmt
name|void
name|__attribute__
argument_list|(
operator|(
name|constructor
operator|)
argument_list|)
name|__sdp_init
argument_list|(
name|void
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|__attribute__
argument_list|(
operator|(
name|destructor
operator|)
argument_list|)
name|__sdp_fini
argument_list|(
name|void
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* library type definitions.                                             */
end_comment

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|ioctl_func_t
function_decl|)
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|request
parameter_list|,
name|void
modifier|*
name|arg0
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|void
modifier|*
name|arg3
parameter_list|,
name|void
modifier|*
name|arg4
parameter_list|,
name|void
modifier|*
name|arg5
parameter_list|,
name|void
modifier|*
name|arg6
parameter_list|,
name|void
modifier|*
name|arg7
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|fcntl_func_t
function_decl|)
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|cmd
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|socket_func_t
function_decl|)
parameter_list|(
name|int
name|domain
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|protocol
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|setsockopt_func_t
function_decl|)
parameter_list|(
name|int
name|s
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|optname
parameter_list|,
specifier|const
name|void
modifier|*
name|optval
parameter_list|,
name|socklen_t
name|optlen
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|connect_func_t
function_decl|)
parameter_list|(
name|int
name|sockfd
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|serv_addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|listen_func_t
function_decl|)
parameter_list|(
name|int
name|s
parameter_list|,
name|int
name|backlog
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|bind_func_t
function_decl|)
parameter_list|(
name|int
name|sockfd
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|my_addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|close_func_t
function_decl|)
parameter_list|(
name|int
name|fd
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|dup_func_t
function_decl|)
parameter_list|(
name|int
name|fd
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|dup2_func_t
function_decl|)
parameter_list|(
name|int
name|oldfd
parameter_list|,
name|int
name|newfd
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|getsockname_func_t
function_decl|)
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|name
parameter_list|,
name|socklen_t
modifier|*
name|namelen
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|getpeername_func_t
function_decl|)
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|name
parameter_list|,
name|socklen_t
modifier|*
name|namelen
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|accept_func_t
function_decl|)
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|socklen_t
modifier|*
name|addrlen
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|select_func_t
function_decl|)
parameter_list|(
name|int
name|n
parameter_list|,
name|fd_set
modifier|*
name|readfds
parameter_list|,
name|fd_set
modifier|*
name|writefds
parameter_list|,
name|fd_set
modifier|*
name|exceptfds
parameter_list|,
name|struct
name|timeval
modifier|*
name|timeout
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|pselect_func_t
function_decl|)
parameter_list|(
name|int
name|n
parameter_list|,
name|fd_set
modifier|*
name|readfds
parameter_list|,
name|fd_set
modifier|*
name|writefds
parameter_list|,
name|fd_set
modifier|*
name|exceptfds
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|,
specifier|const
name|sigset_t
modifier|*
name|sigmask
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|poll_func_t
function_decl|)
parameter_list|(
name|struct
name|pollfd
modifier|*
name|ufds
parameter_list|,
name|unsigned
name|long
name|int
name|nfds
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|epoll_create_func_t
function_decl|)
parameter_list|(
name|int
name|size
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|epoll_ctl_func_t
function_decl|)
parameter_list|(
name|int
name|epfd
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|epoll_event
modifier|*
name|event
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|epoll_wait_func_t
function_decl|)
parameter_list|(
name|int
name|epfd
parameter_list|,
name|struct
name|epoll_event
modifier|*
name|events
parameter_list|,
name|int
name|maxevents
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|epoll_pwait_func_t
function_decl|)
parameter_list|(
name|int
name|epfd
parameter_list|,
name|struct
name|epoll_event
modifier|*
name|events
parameter_list|,
name|int
name|maxevents
parameter_list|,
name|int
name|timeout
parameter_list|,
specifier|const
name|sigset_t
modifier|*
name|sigmask
parameter_list|)
function_decl|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|socket_lib_funcs
block|{
name|ioctl_func_t
name|ioctl
decl_stmt|;
name|fcntl_func_t
name|fcntl
decl_stmt|;
name|socket_func_t
name|socket
decl_stmt|;
name|setsockopt_func_t
name|setsockopt
decl_stmt|;
name|connect_func_t
name|connect
decl_stmt|;
name|listen_func_t
name|listen
decl_stmt|;
name|bind_func_t
name|bind
decl_stmt|;
name|close_func_t
name|close
decl_stmt|;
name|dup_func_t
name|dup
decl_stmt|;
name|dup2_func_t
name|dup2
decl_stmt|;
name|getpeername_func_t
name|getpeername
decl_stmt|;
name|getsockname_func_t
name|getsockname
decl_stmt|;
name|accept_func_t
name|accept
decl_stmt|;
name|select_func_t
name|select
decl_stmt|;
name|pselect_func_t
name|pselect
decl_stmt|;
name|poll_func_t
name|poll
decl_stmt|;
ifdef|#
directive|ifdef
name|__linux__
name|epoll_create_func_t
name|epoll_create
decl_stmt|;
name|epoll_ctl_func_t
name|epoll_ctl
decl_stmt|;
name|epoll_wait_func_t
name|epoll_wait
decl_stmt|;
name|epoll_pwait_func_t
name|epoll_pwait
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/* socket_lib_funcs */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SOLARIS_BUILD
end_ifdef

begin_comment
comment|/* Solaris has another interface to socket functions prefixed with __xnet_ */
end_comment

begin_struct
struct|struct
name|socket_lib_xnet_funcs
block|{
name|socket_func_t
name|socket
decl_stmt|;
name|connect_func_t
name|connect
decl_stmt|;
name|listen_func_t
name|listen
decl_stmt|;
name|bind_func_t
name|bind
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|simple_sdp_library
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_file_descriptors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dev_null_fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
specifier|static
name|int
name|init_status
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0: idle, 1:during, 2:ready */
end_comment

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* library static and global variables                                   */
end_comment

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* glibc provides these symbols - for Solaris builds we fake them  * until _init is called, at which point we quiz libdl.. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SOLARIS_BUILD
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|program_invocation_name
init|=
literal|"[progname]"
decl_stmt|,
modifier|*
name|program_invocation_short_name
init|=
literal|"[short_progname]"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|program_invocation_name
decl_stmt|,
modifier|*
name|program_invocation_short_name
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|RTLD_NEXT
end_ifdef

begin_decl_stmt
specifier|static
name|void
modifier|*
name|__libc_dl_handle
init|=
name|RTLD_NEXT
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|void
modifier|*
name|__libc_dl_handle
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* extra fd attributes we need for our algorithms */
end_comment

begin_struct
struct|struct
name|sdp_extra_fd_attributes
block|{
name|int
name|shadow_fd
decl_stmt|;
comment|/* file descriptor of shadow sdp socket    */
name|short
name|last_accept_was_tcp
decl_stmt|;
comment|/* used by accept to alternate tcp and sdp */
name|short
name|is_sdp
decl_stmt|;
comment|/* 1 if the fd represents an sdp socket    */
block|}
struct|;
end_struct

begin_comment
comment|/* sdp_extra_fd_attributes */
end_comment

begin_comment
comment|/* stores the extra attributes struct by fd */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sdp_extra_fd_attributes
modifier|*
name|libsdp_fd_attributes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|socket_lib_funcs
name|_socket_funcs
init|=
block|{
operator|.
name|socket
operator|=
name|NULL
block|,
comment|/* Automatically sets all other elements to NULL */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* _socket_funcs */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SOLARIS_BUILD
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|socket_lib_xnet_funcs
name|_socket_xnet_funcs
init|=
block|{
operator|.
name|socket
operator|=
name|NULL
block|,
comment|/* Automatically sets all other elements to NULL */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* Prototypes                                                            */
end_comment

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_function_decl
name|void
name|__sdp_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*                                                                       */
end_comment

begin_comment
comment|/* local static functions.                                               */
end_comment

begin_comment
comment|/*                                                                       */
end_comment

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..init_extra_attribute -- initialize the set of extra attributes for a fd */
end_comment

begin_function
specifier|static
name|void
name|init_extra_attribute
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
if|if
condition|(
operator|(
literal|0
operator|<=
name|fd
operator|)
operator|&&
operator|(
name|max_file_descriptors
operator|>
name|fd
operator|)
condition|)
block|{
name|libsdp_fd_attributes
index|[
name|fd
index|]
operator|.
name|shadow_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|libsdp_fd_attributes
index|[
name|fd
index|]
operator|.
name|is_sdp
operator|=
literal|0
expr_stmt|;
name|libsdp_fd_attributes
index|[
name|fd
index|]
operator|.
name|last_accept_was_tcp
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|is_valid_fd
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|<=
name|fd
operator|)
operator|&&
operator|(
name|fd
operator|<
name|max_file_descriptors
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..get_shadow_fd_by_fd -- given an fd return its shadow fd if exists        */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|get_shadow_fd_by_fd
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
if|if
condition|(
name|is_valid_fd
argument_list|(
name|fd
argument_list|)
condition|)
return|return
name|libsdp_fd_attributes
index|[
name|fd
index|]
operator|.
name|shadow_fd
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..set_shadow_for_fd --                                                     */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_shadow_for_fd
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|shadow_fd
parameter_list|)
block|{
if|if
condition|(
name|is_valid_fd
argument_list|(
name|fd
argument_list|)
condition|)
name|libsdp_fd_attributes
index|[
name|fd
index|]
operator|.
name|shadow_fd
operator|=
name|shadow_fd
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..set_is_sdp_socket --                                                     */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_is_sdp_socket
parameter_list|(
name|int
name|fd
parameter_list|,
name|short
name|is_sdp
parameter_list|)
block|{
if|if
condition|(
name|is_valid_fd
argument_list|(
name|fd
argument_list|)
condition|)
name|libsdp_fd_attributes
index|[
name|fd
index|]
operator|.
name|is_sdp
operator|=
name|is_sdp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..get_is_sdp_socket -- given an fd return 1 if it is an SDP socket         */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|get_is_sdp_socket
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
if|if
condition|(
name|is_valid_fd
argument_list|(
name|fd
argument_list|)
condition|)
return|return
name|libsdp_fd_attributes
index|[
name|fd
index|]
operator|.
name|is_sdp
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..last_accept_was_tcp -- given an fd return 1 if last accept was tcp       */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|last_accept_was_tcp
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
if|if
condition|(
name|is_valid_fd
argument_list|(
name|fd
argument_list|)
condition|)
return|return
name|libsdp_fd_attributes
index|[
name|fd
index|]
operator|.
name|last_accept_was_tcp
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..set_last_accept -- given an fd set last accept was tcp                   */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|set_last_accept
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|was_tcp
parameter_list|)
block|{
if|if
condition|(
name|is_valid_fd
argument_list|(
name|fd
argument_list|)
condition|)
name|libsdp_fd_attributes
index|[
name|fd
index|]
operator|.
name|last_accept_was_tcp
operator|=
name|was_tcp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..cleanup_shadow -- an error occured on an SDP socket, cleanup             */
end_comment

begin_function
specifier|static
name|int
name|cleanup_shadow
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|int
name|shadow_fd
init|=
name|get_shadow_fd_by_fd
argument_list|(
name|fd
argument_list|)
decl_stmt|;
if|if
condition|(
name|shadow_fd
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|libsdp_fd_attributes
index|[
name|fd
index|]
operator|.
name|shadow_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|libsdp_fd_attributes
index|[
name|fd
index|]
operator|.
name|last_accept_was_tcp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|_socket_funcs
operator|.
name|close
argument_list|(
name|shadow_fd
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* cleanup_shadow */
end_comment

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..replace_fd_with_its_shadow -- perform all required for such promotion    */
end_comment

begin_function
specifier|static
name|int
name|replace_fd_with_its_shadow
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|int
name|shadow_fd
init|=
name|libsdp_fd_attributes
index|[
name|fd
index|]
operator|.
name|shadow_fd
decl_stmt|;
if|if
condition|(
name|shadow_fd
operator|==
operator|-
literal|1
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error replace_fd_with_its_shadow: no shadow for fd:%d\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* copy the attributes of the shadow before we clean them up */
name|libsdp_fd_attributes
index|[
name|fd
index|]
operator|=
name|libsdp_fd_attributes
index|[
name|shadow_fd
index|]
expr_stmt|;
name|libsdp_fd_attributes
index|[
name|fd
index|]
operator|.
name|shadow_fd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|_socket_funcs
operator|.
name|dup2
argument_list|(
name|shadow_fd
argument_list|,
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|init_extra_attribute
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|_socket_funcs
operator|.
name|close
argument_list|(
name|shadow_fd
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|_socket_funcs
operator|.
name|close
argument_list|(
name|shadow_fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|sa_family_t
name|get_sdp_domain
parameter_list|(
name|int
name|domain
parameter_list|)
block|{
if|if
condition|(
name|AF_INET_SDP
operator|==
name|domain
operator|||
name|AF_INET6_SDP
operator|==
name|domain
condition|)
return|return
name|domain
return|;
if|if
condition|(
name|AF_INET
operator|==
name|domain
condition|)
return|return
name|AF_INET_SDP
return|;
elseif|else
if|if
condition|(
name|AF_INET6
operator|==
name|domain
condition|)
return|return
name|AF_INET6_SDP
return|;
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error %s: unknown TCP domain: %d\n"
argument_list|,
name|__func__
argument_list|,
name|domain
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_sock_domain
parameter_list|(
name|int
name|sd
parameter_list|)
block|{
name|struct
name|sockaddr_storage
name|tmp_sin
decl_stmt|;
name|socklen_t
name|tmp_sinlen
init|=
sizeof|sizeof
argument_list|(
name|tmp_sin
argument_list|)
decl_stmt|;
if|if
condition|(
name|_socket_funcs
operator|.
name|getsockname
argument_list|(
name|sd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|tmp_sin
argument_list|,
operator|&
name|tmp_sinlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error %s: getsockname return<%d> for socket\n"
argument_list|,
name|__func__
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|tmp_sin
operator|)
operator|->
name|sa_family
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..is_filtered_unsuported_sockopt -- return 1 if to filter sockopt failure  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_filtered_unsuported_sockopt
parameter_list|(
name|int
name|level
parameter_list|,
name|int
name|optname
parameter_list|)
block|{
comment|/*  	 * TODO: until we know exactly which unsupported opts are really  	 * a don't care we always pass the error 	 */
return|return
literal|0
return|;
if|#
directive|if
literal|0
comment|/* these are the SOL_TCP OPTS we should consider filterring */
block|TCP_NODELAY 1
comment|/* Don't delay send to coalesce packets  */
block|TCP_MAXSEG 2
comment|/* Set maximum segment size  */
block|TCP_CORK 3
comment|/* Control sending of partial frames  */
block|TCP_KEEPIDLE 4
comment|/* Start keeplives after this period */
block|TCP_KEEPINTVL 5
comment|/* Interval between keepalives */
block|TCP_KEEPCNT 6
comment|/* Number of keepalives before death */
block|TCP_SYNCNT 7
comment|/* Number of SYN retransmits */
block|TCP_LINGER2 8
comment|/* Life time of orphaned FIN-WAIT-2 state */
block|TCP_DEFER_ACCEPT 9
comment|/* Wake up listener only when data arrive */
block|TCP_WINDOW_CLAMP 10
comment|/* Bound advertised window */
block|TCP_INFO 11
comment|/* Information about this connection. */
block|TCP_QUICKACK 12
comment|/* Bock/reenable quick ACKs.  */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..is_invalid_addr -- return 1 if given pointer is not valid                */
end_comment

begin_comment
comment|/* NOTE: invalidation of the size is going to happen during actual call      */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_invalid_addr
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
comment|/* HACK: on some systems we can not write to check for pointer validity */
name|size_t
name|ret
init|=
name|fcntl
argument_list|(
name|dev_null_fd
argument_list|,
name|F_GETLK
argument_list|,
name|p
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|(
name|errno
operator|==
name|EFAULT
operator|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..get_addr_str -- fill in the given buffer with addr str or return 1       */
end_comment

begin_function
specifier|static
name|int
name|get_addr_str
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
decl_stmt|;
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|sin6
init|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
decl_stmt|;
name|char
specifier|const
modifier|*
name|conv_res
decl_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_family
operator|==
name|AF_INET
condition|)
block|{
name|conv_res
operator|=
name|inet_ntop
argument_list|(
name|AF_INET
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|sin
operator|->
name|sin_addr
operator|)
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sin6
operator|->
name|sin6_family
operator|==
name|AF_INET6
condition|)
block|{
name|conv_res
operator|=
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
literal|"unknown address family"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|conv_res
operator|=
operator|(
name|char
operator|*
operator|)
literal|1
expr_stmt|;
block|}
return|return
name|conv_res
operator|==
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*                                                                       */
end_comment

begin_comment
comment|/* Socket library function overrides.                                    */
end_comment

begin_comment
comment|/*                                                                       */
end_comment

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..ioctl -- replacement ioctl call. */
end_comment

begin_function
name|int
name|ioctl
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|request
parameter_list|,
name|void
modifier|*
name|arg0
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|void
modifier|*
name|arg3
parameter_list|,
name|void
modifier|*
name|arg4
parameter_list|,
name|void
modifier|*
name|arg5
parameter_list|,
name|void
modifier|*
name|arg6
parameter_list|,
name|void
modifier|*
name|arg7
parameter_list|)
block|{
name|int
name|shadow_fd
decl_stmt|;
name|int
name|sret
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|init_status
operator|==
literal|0
condition|)
name|__sdp_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|_socket_funcs
operator|.
name|ioctl
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error ioctl: no implementation for ioctl found\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|shadow_fd
operator|=
name|get_shadow_fd_by_fd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"IOCTL:<%s:%d:%d> request<%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|,
name|shadow_fd
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_socket_funcs
operator|.
name|ioctl
argument_list|(
name|fd
argument_list|,
name|request
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|,
name|arg6
argument_list|,
name|arg7
argument_list|)
expr_stmt|;
comment|/* HACK: avoid failing on FIONREAD error as SDP does not support it at the moment */
if|if
condition|(
operator|(
name|ret
operator|<
literal|0
operator|)
operator|&&
name|get_is_sdp_socket
argument_list|(
name|fd
argument_list|)
operator|&&
operator|(
name|request
operator|==
name|FIONREAD
operator|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|8
argument_list|,
literal|"Warning ioctl: "
literal|"Ignoring FIONREAD error for SDP socket.\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
comment|/* if shadow and no error on tcp */
if|if
condition|(
operator|(
name|ret
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|-
literal|1
operator|!=
name|shadow_fd
operator|)
condition|)
block|{
name|sret
operator|=
name|_socket_funcs
operator|.
name|ioctl
argument_list|(
name|shadow_fd
argument_list|,
name|request
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|,
name|arg6
argument_list|,
name|arg7
argument_list|)
expr_stmt|;
comment|/* HACK: avoid failing on FIONREAD error as SDP does not support it at the moment */
if|if
condition|(
operator|(
name|sret
operator|<
literal|0
operator|)
operator|&&
operator|(
name|request
operator|==
name|FIONREAD
operator|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|8
argument_list|,
literal|"Warning ioctl: "
literal|"Ignoring FIONREAD error for shadow SDP socket.\n"
argument_list|)
expr_stmt|;
name|sret
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sret
operator|<
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error ioctl: "
literal|"<%d> calling ioctl for SDP socket, closing it.\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|cleanup_shadow
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"IOCTL:<%s:%d:%d> result<%d:%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|,
name|shadow_fd
argument_list|,
name|ret
argument_list|,
name|sret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* ioctl */
end_comment

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..fcntl -- replacement fcntl call.                                         */
end_comment

begin_function
name|int
name|fcntl
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|cmd
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|shadow_fd
decl_stmt|;
name|int
name|sret
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|arg
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_status
operator|==
literal|0
condition|)
name|__sdp_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|_socket_funcs
operator|.
name|fcntl
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error fcntl: no implementation for fcntl found\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|shadow_fd
operator|=
name|get_shadow_fd_by_fd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"FCNTL:<%s:%d:%d> command<%d> argument<%p>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|,
name|shadow_fd
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_socket_funcs
operator|.
name|fcntl
argument_list|(
name|fd
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|-
literal|1
operator|!=
name|shadow_fd
operator|)
condition|)
block|{
name|sret
operator|=
name|_socket_funcs
operator|.
name|fcntl
argument_list|(
name|shadow_fd
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sret
operator|<
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error fcntl:"
literal|"<%d> calling fcntl(%d, %d, %p) for SDP socket. Closing it.\n"
argument_list|,
name|shadow_fd
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|cleanup_shadow
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"FCNTL:<%s:%d:%d> result<%d:%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|,
name|shadow_fd
argument_list|,
name|ret
argument_list|,
name|sret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* fcntl */
end_comment

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..setsockopt -- replacement setsockopt call.                               */
end_comment

begin_function
name|int
name|setsockopt
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|optname
parameter_list|,
specifier|const
name|void
modifier|*
name|optval
parameter_list|,
name|socklen_t
name|optlen
parameter_list|)
block|{
name|int
name|shadow_fd
decl_stmt|;
name|int
name|sret
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|init_status
operator|==
literal|0
condition|)
name|__sdp_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|_socket_funcs
operator|.
name|setsockopt
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error setsockopt:"
literal|" no implementation for setsockopt found\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|shadow_fd
operator|=
name|get_shadow_fd_by_fd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"SETSOCKOPT:<%s:%d:%d> level<%d> name<%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|,
name|shadow_fd
argument_list|,
name|level
argument_list|,
name|optname
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
name|SOL_SOCKET
operator|&&
name|optname
operator|==
name|SO_KEEPALIVE
operator|&&
name|get_is_sdp_socket
argument_list|(
name|fd
argument_list|)
condition|)
block|{
name|level
operator|=
name|AF_INET_SDP
expr_stmt|;
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"SETSOCKOPT:<%s:%d:%d> substitute level %d\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|,
name|shadow_fd
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|_socket_funcs
operator|.
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|level
argument_list|,
name|optname
argument_list|,
name|optval
argument_list|,
name|optlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|shadow_fd
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|level
operator|==
name|SOL_SOCKET
operator|&&
name|optname
operator|==
name|SO_KEEPALIVE
operator|&&
name|get_is_sdp_socket
argument_list|(
name|shadow_fd
argument_list|)
condition|)
block|{
name|level
operator|=
name|AF_INET_SDP
expr_stmt|;
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"SETSOCKOPT:<%s:%d:%d> substitute level %d\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|,
name|shadow_fd
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
name|sret
operator|=
name|_socket_funcs
operator|.
name|setsockopt
argument_list|(
name|shadow_fd
argument_list|,
name|level
argument_list|,
name|optname
argument_list|,
name|optval
argument_list|,
name|optlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sret
operator|<
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|8
argument_list|,
literal|"Warning sockopts:"
literal|" ignoring error on shadow SDP socket fd:<%d>\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
comment|/*  			 * HACK: we should allow some errors as some sock opts are unsupported   			 * __sdp_log(9, "Error %d calling setsockopt for SDP socket, closing\n", errno);  			 * cleanup_shadow(fd);  			 */
block|}
block|}
comment|/* Due to SDP limited implmentation of sockopts we ignore some errors */
if|if
condition|(
operator|(
name|ret
operator|<
literal|0
operator|)
operator|&&
name|get_is_sdp_socket
argument_list|(
name|fd
argument_list|)
operator|&&
name|is_filtered_unsuported_sockopt
argument_list|(
name|level
argument_list|,
name|optname
argument_list|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|8
argument_list|,
literal|"Warning sockopts: "
literal|"ignoring error on non implemented sockopt on SDP socket"
literal|" fd:<%d> level:<%d> opt:<%d>\n"
argument_list|,
name|fd
argument_list|,
name|level
argument_list|,
name|optval
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"SETSOCKOPT:<%s:%d:%d> result<%d:%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|,
name|shadow_fd
argument_list|,
name|ret
argument_list|,
name|sret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* setsockopt */
end_comment

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..socket -- replacement socket call.                                       */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|__create_socket_semantic
parameter_list|(
name|int
name|domain
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|protocol
parameter_list|,
name|int
name|semantics
parameter_list|)
block|{
return|return
ifdef|#
directive|ifdef
name|SOLARIS_BUILD
operator|(
name|semantics
operator|==
name|SOCKET_SEMANTIC_XNET
operator|)
condition|?
name|_socket_xnet_funcs
operator|.
name|socket
argument_list|(
name|domain
argument_list|,
name|type
argument_list|,
name|protocol
argument_list|)
else|:
endif|#
directive|endif
name|_socket_funcs
operator|.
name|socket
argument_list|(
name|domain
argument_list|,
name|type
argument_list|,
name|protocol
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Contains the main logic for creating shadow SDP sockets */
end_comment

begin_function
specifier|static
name|int
name|__create_socket
parameter_list|(
name|int
name|domain
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|protocol
parameter_list|,
name|int
name|semantics
parameter_list|)
block|{
name|int
name|s
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|shadow_fd
init|=
operator|-
literal|1
decl_stmt|;
name|use_family_t
name|family_by_prog
decl_stmt|;
name|int
name|sdp_domain
decl_stmt|;
if|if
condition|(
name|init_status
operator|==
literal|0
condition|)
name|__sdp_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|_socket_funcs
operator|.
name|socket
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error socket: no implementation for socket found\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"SOCKET:<%s> domain<%d> type<%d> protocol<%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|domain
argument_list|,
name|type
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
name|sdp_domain
operator|=
name|get_sdp_domain
argument_list|(
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdp_domain
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|EAFNOSUPPORT
expr_stmt|;
name|s
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* check to see if we can skip the shadow */
if|if
condition|(
operator|(
name|AF_INET
operator|==
name|domain
operator|||
name|AF_INET6
operator|==
name|domain
operator|)
operator|&&
operator|(
name|SOCK_STREAM
operator|==
name|type
operator|)
condition|)
if|if
condition|(
name|simple_sdp_library
condition|)
name|family_by_prog
operator|=
name|USE_SDP
expr_stmt|;
else|else
name|family_by_prog
operator|=
name|__sdp_match_by_program
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|AF_INET_SDP
operator|==
name|domain
operator|||
name|AF_INET6_SDP
operator|==
name|domain
condition|)
name|family_by_prog
operator|=
name|USE_SDP
expr_stmt|;
else|else
name|family_by_prog
operator|=
name|USE_TCP
expr_stmt|;
if|if
condition|(
name|family_by_prog
operator|==
name|USE_TCP
condition|)
block|{
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"SOCKET: making TCP only socket (no shadow)\n"
argument_list|)
expr_stmt|;
name|s
operator|=
name|__create_socket_semantic
argument_list|(
name|domain
argument_list|,
name|type
argument_list|,
name|protocol
argument_list|,
name|semantics
argument_list|)
expr_stmt|;
name|init_extra_attribute
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|set_is_sdp_socket
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|family_by_prog
operator|==
name|USE_SDP
condition|)
block|{
comment|/* HACK: convert the protocol if IPPROTO_IP */
if|if
condition|(
name|protocol
operator|==
literal|0
condition|)
name|protocol
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"SOCKET: making SDP socket type:%d proto:%d\n"
argument_list|,
name|type
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
name|s
operator|=
name|__create_socket_semantic
argument_list|(
name|sdp_domain
argument_list|,
name|type
argument_list|,
name|protocol
argument_list|,
name|semantics
argument_list|)
expr_stmt|;
name|init_extra_attribute
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|set_is_sdp_socket
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* HACK: if we fail creating the TCP socket should we abort ? */
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"SOCKET: making TCP socket\n"
argument_list|)
expr_stmt|;
name|s
operator|=
name|__create_socket_semantic
argument_list|(
name|domain
argument_list|,
name|type
argument_list|,
name|protocol
argument_list|,
name|semantics
argument_list|)
expr_stmt|;
name|init_extra_attribute
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|set_is_sdp_socket
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_valid_fd
argument_list|(
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|AF_INET
operator|==
name|domain
operator|)
operator|||
operator|(
name|AF_INET6
operator|==
name|domain
operator|)
operator|)
operator|&&
operator|(
name|SOCK_STREAM
operator|==
name|type
operator|)
condition|)
block|{
if|if
condition|(
name|protocol
operator|==
literal|0
condition|)
name|protocol
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"SOCKET: making SDP shadow socket type:%d proto:%d\n"
argument_list|,
name|type
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
name|shadow_fd
operator|=
name|__create_socket_semantic
argument_list|(
name|sdp_domain
argument_list|,
name|type
argument_list|,
name|protocol
argument_list|,
name|semantics
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_valid_fd
argument_list|(
name|shadow_fd
argument_list|)
condition|)
block|{
name|init_extra_attribute
argument_list|(
name|shadow_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|libsdp_fd_attributes
index|[
name|s
index|]
operator|.
name|shadow_fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|__sdp_log
argument_list|(
literal|8
argument_list|,
literal|"Warning socket: "
literal|"overriding existing shadow fd:%d for fd:%d\n"
argument_list|,
name|libsdp_fd_attributes
index|[
name|s
index|]
operator|.
name|shadow_fd
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|set_is_sdp_socket
argument_list|(
name|shadow_fd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_shadow_for_fd
argument_list|(
name|s
argument_list|,
name|shadow_fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error socket:<%d> calling socket for SDP socket\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
comment|/* fail if we did not make the SDP socket */
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"SOCKET: closing TCP socket:<%d>\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|_socket_funcs
operator|.
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error socket: "
literal|"ignoring SDP socket since TCP fd:%d out of range\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"SOCKET:<%s:%d:%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|s
argument_list|,
name|shadow_fd
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* socket */
end_comment

begin_function
name|int
name|socket
parameter_list|(
name|int
name|domain
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|protocol
parameter_list|)
block|{
return|return
name|__create_socket
argument_list|(
name|domain
argument_list|,
name|type
argument_list|,
name|protocol
argument_list|,
name|SOCKET_SEMANTIC_DEFAULT
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SOLARIS_BUILD
end_ifdef

begin_function
name|int
name|__xnet_socket
parameter_list|(
name|int
name|domain
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|protocol
parameter_list|)
block|{
return|return
name|__create_socket
argument_list|(
name|domain
argument_list|,
name|type
argument_list|,
name|protocol
argument_list|,
name|SOCKET_SEMANTIC_XNET
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..get_fd_addr_port_num - obtain the port the fd is attached to             */
end_comment

begin_function
specifier|static
name|int
name|get_fd_addr_port_num
parameter_list|(
name|int
name|sd
parameter_list|)
block|{
name|struct
name|sockaddr_storage
name|addr
decl_stmt|;
name|int
name|ret
decl_stmt|;
specifier|const
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|socklen_t
name|addrlen
init|=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
decl_stmt|;
name|ret
operator|=
name|_socket_funcs
operator|.
name|getsockname
argument_list|(
name|sd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
operator|&
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error: in get_fd_addr_port_num - Failed to get getsockname\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* port num is in same location for IPv4 and IPv6 */
name|sin
operator|=
operator|(
specifier|const
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|addr
expr_stmt|;
return|return
name|ntohs
argument_list|(
name|sin
operator|->
name|sin_port
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..set_addr_port_num - sets the port in the given address                   */
end_comment

begin_function
specifier|static
name|int
name|set_addr_port_num
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
decl_stmt|;
comment|/* port num is in same location for IPv4 and IPv6 */
name|sin
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*  perform a bind with the given socket semantics                           */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|__bind_semantics
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|my_addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|int
name|semantics
parameter_list|)
block|{
return|return
ifdef|#
directive|ifdef
name|SOLARIS_BUILD
operator|(
name|semantics
operator|==
name|SOCKET_SEMANTIC_XNET
operator|)
condition|?
name|_socket_xnet_funcs
operator|.
name|bind
argument_list|(
name|fd
argument_list|,
name|my_addr
argument_list|,
name|addrlen
argument_list|)
else|:
endif|#
directive|endif
name|_socket_funcs
operator|.
name|bind
argument_list|(
name|fd
argument_list|,
name|my_addr
argument_list|,
name|addrlen
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..find_free_port - find same free port on both TCP and SDP                 */
end_comment

begin_define
define|#
directive|define
name|MAX_BIND_ANY_PORT_TRIES
value|20000
end_define

begin_function
specifier|static
name|int
name|find_free_port
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|sin_addr
parameter_list|,
specifier|const
name|socklen_t
name|addrlen
parameter_list|,
name|int
name|orig_sd
parameter_list|,
name|int
modifier|*
name|sdp_sd
parameter_list|,
name|int
modifier|*
name|tcp_sd
parameter_list|,
name|int
name|semantics
parameter_list|)
block|{
specifier|static
name|int
name|tcp_turn
init|=
literal|1
decl_stmt|;
name|int
name|tmp_turn
init|=
name|tcp_turn
decl_stmt|;
name|int
name|num_of_loops
init|=
literal|0
decl_stmt|;
name|int
name|port
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|tmp_sd
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|int
name|yes
init|=
literal|1
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|domain
decl_stmt|,
name|sdp_domain
decl_stmt|;
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"find_free_port: starting search for common free port\n"
argument_list|)
expr_stmt|;
comment|/* need to obtain the address family from the fd */
name|domain
operator|=
name|get_sock_domain
argument_list|(
name|orig_sd
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain
operator|==
operator|-
literal|1
condition|)
block|{
name|errno
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sdp_domain
operator|=
name|get_sdp_domain
argument_list|(
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdp_domain
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
do|do
block|{
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"find_free_port: taking loop (%d)\n"
argument_list|,
operator|++
name|num_of_loops
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"find_free_port: creating the two sockets\n"
argument_list|)
expr_stmt|;
name|tmp_sd
index|[
literal|0
index|]
operator|=
name|_socket_funcs
operator|.
name|socket
argument_list|(
name|sdp_domain
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_sd
index|[
literal|0
index|]
operator|<
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|8
argument_list|,
literal|"Warning find_free_port: creating first socket failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|_socket_funcs
operator|.
name|setsockopt
argument_list|(
name|tmp_sd
index|[
literal|0
index|]
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|&
name|yes
argument_list|,
sizeof|sizeof
argument_list|(
name|yes
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_sd
index|[
literal|1
index|]
operator|=
name|_socket_funcs
operator|.
name|socket
argument_list|(
name|domain
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_sd
index|[
literal|1
index|]
operator|<
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|8
argument_list|,
literal|"Warning find_free_port: creating second socket failed\n"
argument_list|)
expr_stmt|;
name|_socket_funcs
operator|.
name|close
argument_list|(
name|tmp_sd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|_socket_funcs
operator|.
name|setsockopt
argument_list|(
name|tmp_sd
index|[
literal|1
index|]
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|&
name|yes
argument_list|,
sizeof|sizeof
argument_list|(
name|yes
argument_list|)
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"find_free_port: binding first %s socket\n"
argument_list|,
name|tmp_turn
condition|?
literal|"tcp"
else|:
literal|"sdp"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__bind_semantics
argument_list|(
name|tmp_sd
index|[
name|tmp_turn
index|]
argument_list|,
name|sin_addr
argument_list|,
name|addrlen
argument_list|,
name|semantics
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|8
argument_list|,
literal|"Warning find_free_port: binding first socket failed:%s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|_socket_funcs
operator|.
name|close
argument_list|(
name|tmp_sd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|_socket_funcs
operator|.
name|close
argument_list|(
name|tmp_sd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"find_free_port: listening on first socket\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_socket_funcs
operator|.
name|listen
argument_list|(
name|tmp_sd
index|[
name|tmp_turn
index|]
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|8
argument_list|,
literal|"Warning find_free_port: listening on first socket failed:%s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|_socket_funcs
operator|.
name|close
argument_list|(
name|tmp_sd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|_socket_funcs
operator|.
name|close
argument_list|(
name|tmp_sd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|port
operator|=
name|get_fd_addr_port_num
argument_list|(
name|tmp_sd
index|[
name|tmp_turn
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|<
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|8
argument_list|,
literal|"Warning find_free_port: first socket port:%d< 0\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|_socket_funcs
operator|.
name|close
argument_list|(
name|tmp_sd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|_socket_funcs
operator|.
name|close
argument_list|(
name|tmp_sd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"find_free_port: first socket port:%u\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|set_addr_port_num
argument_list|(
name|sin_addr
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"find_free_port: binding second socket\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__bind_semantics
argument_list|(
name|tmp_sd
index|[
literal|1
operator|-
name|tmp_turn
index|]
argument_list|,
name|sin_addr
argument_list|,
name|addrlen
argument_list|,
name|semantics
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/* bind() for sdp socket failed. It is acceptable only 			 * if the IP is not part of IB network. */
if|if
condition|(
name|errno
operator|!=
name|EADDRINUSE
condition|)
block|{
name|__sdp_log
argument_list|(
literal|8
argument_list|,
literal|"Warning find_free_port: "
literal|"binding second socket failed with %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|close_and_mark
goto|;
block|}
else|else
block|{
name|int
name|err
decl_stmt|;
ifdef|#
directive|ifdef
name|__linux__
name|socklen_t
name|len
init|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
name|ret
operator|=
name|getsockopt
argument_list|(
name|tmp_sd
index|[
literal|1
operator|-
name|tmp_turn
index|]
argument_list|,
name|SOL_TCP
argument_list|,
name|SDP_LAST_BIND_ERR
argument_list|,
operator|&
name|err
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|ret
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error %s:getsockopt: %s\n"
argument_list|,
name|__func__
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|close_and_mark
goto|;
block|}
else|#
directive|else
name|err
operator|=
operator|-
name|errno
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|-
name|ENOENT
operator|==
name|err
operator|||
operator|-
name|EADDRINUSE
operator|!=
name|err
condition|)
block|{
comment|/* bind() failed due to either: 					 * 1. IP is ETH, not IB, so can't bind() to sdp socket. 					 * 2. real error. 					 * Continue only with TCP */
goto|goto
name|close_and_mark
goto|;
block|}
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"find_free_port: %s port %u was busy\n"
argument_list|,
literal|1
operator|-
name|tmp_turn
condition|?
literal|"tcp"
else|:
literal|"sdp"
argument_list|,
name|ntohs
argument_list|(
operator|(
operator|(
specifier|const
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sin_addr
operator|)
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* close the sockets - we will need new ones ... */
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"find_free_port: closing the two sockets before next loop\n"
argument_list|)
expr_stmt|;
name|_socket_funcs
operator|.
name|close
argument_list|(
name|tmp_sd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|_socket_funcs
operator|.
name|close
argument_list|(
name|tmp_sd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|port
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* we always start with tcp so we keep the original setting for now */
comment|/* tmp_turn = 1 - tmp_turn; */
block|}
block|}
do|while
condition|(
operator|(
name|port
operator|<
literal|0
operator|)
operator|&&
operator|(
name|num_of_loops
operator|<
name|MAX_BIND_ANY_PORT_TRIES
operator|)
condition|)
do|;
name|setfds
label|:
name|tcp_turn
operator|=
name|tmp_turn
expr_stmt|;
operator|*
name|sdp_sd
operator|=
name|tmp_sd
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tcp_sd
operator|=
name|tmp_sd
index|[
literal|1
index|]
expr_stmt|;
name|done
label|:
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"find_free_port: return port:<%d>\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
name|port
return|;
name|close_and_mark
label|:
name|_socket_funcs
operator|.
name|close
argument_list|(
name|tmp_sd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|tmp_sd
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* mark with error */
goto|goto
name|setfds
goto|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..check_legal_bind - check if given address is okay for both TCP and SDP   */
end_comment

begin_function
specifier|static
name|int
name|check_legal_bind
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|sin_addr
parameter_list|,
specifier|const
name|socklen_t
name|addrlen
parameter_list|,
name|int
name|orig_sd
parameter_list|,
name|int
modifier|*
name|sdp_sd
parameter_list|,
name|int
modifier|*
name|tcp_sd
parameter_list|,
name|int
name|semantics
parameter_list|)
block|{
name|unsigned
name|int
name|yes
init|=
literal|1
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|sret
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|domain
decl_stmt|,
name|sdp_domain
decl_stmt|;
comment|/* need to obtain the address family from the fd */
name|domain
operator|=
name|get_sock_domain
argument_list|(
name|orig_sd
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain
operator|==
operator|-
literal|1
condition|)
block|{
name|errno
operator|=
name|EFAULT
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|sdp_domain
operator|=
name|get_sdp_domain
argument_list|(
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdp_domain
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"check_legal_bind: binding two temporary sockets\n"
argument_list|)
expr_stmt|;
operator|*
name|sdp_sd
operator|=
name|_socket_funcs
operator|.
name|socket
argument_list|(
name|sdp_domain
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sdp_sd
operator|<
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error check_legal_bind: "
literal|"creating SDP socket failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"check_legal_bind: reusing<%d> \n"
argument_list|,
operator|*
name|sdp_sd
argument_list|)
expr_stmt|;
name|sret
operator|=
name|_socket_funcs
operator|.
name|setsockopt
argument_list|(
operator|*
name|sdp_sd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|&
name|yes
argument_list|,
sizeof|sizeof
argument_list|(
name|yes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sret
operator|<
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error bind: Could not setsockopt sdp_sd\n"
argument_list|)
expr_stmt|;
block|}
operator|*
name|tcp_sd
operator|=
name|_socket_funcs
operator|.
name|socket
argument_list|(
name|domain
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tcp_sd
operator|<
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error check_legal_bind: "
literal|"creating second socket failed:%s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|_socket_funcs
operator|.
name|close
argument_list|(
operator|*
name|sdp_sd
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"check_legal_bind: reusing<%d> \n"
argument_list|,
operator|*
name|tcp_sd
argument_list|)
expr_stmt|;
name|sret
operator|=
name|_socket_funcs
operator|.
name|setsockopt
argument_list|(
operator|*
name|tcp_sd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|&
name|yes
argument_list|,
sizeof|sizeof
argument_list|(
name|yes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sret
operator|<
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error bind: Could not setsockopt tcp_sd\n"
argument_list|)
expr_stmt|;
block|}
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"check_legal_bind: binding SDP socket\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__bind_semantics
argument_list|(
operator|*
name|sdp_sd
argument_list|,
name|sin_addr
argument_list|,
name|addrlen
argument_list|,
name|semantics
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/* bind() for sdp socket failed. It is acceptable only if 		 * the IP is not part of IB network. */
name|int
name|err
decl_stmt|;
name|socklen_t
name|len
init|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
if|if
condition|(
name|EADDRINUSE
operator|!=
name|errno
condition|)
goto|goto
name|done
goto|;
ifdef|#
directive|ifdef
name|__linux__
if|if
condition|(
operator|-
literal|1
operator|==
name|getsockopt
argument_list|(
operator|*
name|sdp_sd
argument_list|,
name|SOL_TCP
argument_list|,
name|SDP_LAST_BIND_ERR
argument_list|,
operator|&
name|err
argument_list|,
operator|&
name|len
argument_list|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error check_legal_bind:getsockopt: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|#
directive|else
name|err
operator|=
operator|-
name|errno
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|-
name|ENOENT
operator|!=
name|err
condition|)
block|{
comment|/* bind() failed due to real error. Can't continue */
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error check_legal_bind: "
literal|"binding SDP socket failed:%s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|_socket_funcs
operator|.
name|close
argument_list|(
operator|*
name|sdp_sd
argument_list|)
expr_stmt|;
name|_socket_funcs
operator|.
name|close
argument_list|(
operator|*
name|tcp_sd
argument_list|)
expr_stmt|;
comment|/* TCP and SDP without library return EINVAL */
if|if
condition|(
name|errno
operator|==
name|EADDRINUSE
condition|)
name|errno
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* IP is ETH, not IB, so can't bind() to sdp socket */
comment|/* Continue only with TCP */
name|_socket_funcs
operator|.
name|close
argument_list|(
operator|*
name|sdp_sd
argument_list|)
expr_stmt|;
operator|*
name|sdp_sd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"check_legal_bind: binding TCP socket\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__bind_semantics
argument_list|(
operator|*
name|tcp_sd
argument_list|,
name|sin_addr
argument_list|,
name|addrlen
argument_list|,
name|semantics
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error check_legal_bind: "
literal|"binding TCP socket failed:%s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|!=
operator|*
name|sdp_sd
condition|)
name|_socket_funcs
operator|.
name|close
argument_list|(
operator|*
name|sdp_sd
argument_list|)
expr_stmt|;
name|_socket_funcs
operator|.
name|close
argument_list|(
operator|*
name|tcp_sd
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"check_legal_bind: result:<%d>\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|done
label|:
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..close_and_bind - close an open fd and bind another one immediately       */
end_comment

begin_function
specifier|static
name|int
name|close_and_bind
parameter_list|(
name|int
name|old_sd
parameter_list|,
name|int
name|new_sd
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|int
name|semantics
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"close_and_bind: closing<%d> binding<%d>\n"
argument_list|,
name|old_sd
argument_list|,
name|new_sd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_socket_funcs
operator|.
name|close
argument_list|(
name|old_sd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error bind: Could not close old_sd\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|ret
operator|=
name|__bind_semantics
argument_list|(
name|new_sd
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|,
name|semantics
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error bind: Could not bind new_sd\n"
argument_list|)
expr_stmt|;
name|done
label|:
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"close_and_bind: returning<%d>\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..bind -- replacement bind call.                                           */
end_comment

begin_comment
comment|/*     As we do not know the role of this socket yet so we cannot choose AF.     We need to be able to handle shadow too.    SDP sockets (may be shadow or not) must be using converted address      	Since there is no way to "rebind" a socket we have to avoid "false" bind: 	1. When the given address for the bind includes a port we need to  	   guarantee the port is free on both address families. We do that        by creating temporary sockets and biding them first. Then we close and 		re-use the address on the real sockets.  	2. When ANY_PORT is requested we need to make sure the port we obtain from  	   the first address family is also free on the second one. We use temporary 		sockets for that task too. We loop several times to find such common  		available socket */
end_comment

begin_function
specifier|static
name|int
name|__perform_bind
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|int
name|semantics
parameter_list|)
block|{
name|int
name|shadow_fd
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin_addr
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|sret
init|=
operator|-
literal|1
decl_stmt|;
name|char
name|buf
index|[
name|MAX_ADDR_STR_LEN
index|]
decl_stmt|;
if|if
condition|(
name|init_status
operator|==
literal|0
condition|)
name|__sdp_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|_socket_funcs
operator|.
name|bind
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error bind: no implementation for bind found\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|shadow_fd
operator|=
name|get_shadow_fd_by_fd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|==
name|NULL
operator|)
operator|||
name|is_invalid_addr
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EFAULT
expr_stmt|;
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error bind: illegal address provided\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|get_addr_str
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
name|MAX_ADDR_STR_LEN
argument_list|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error bind: provided illegal address: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"BIND:<%s:%d:%d> type<%d> IP<%s> port<%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|,
name|shadow_fd
argument_list|,
name|sin_addr
operator|->
name|sin_family
argument_list|,
name|buf
argument_list|,
name|ntohs
argument_list|(
name|sin_addr
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_is_sdp_socket
argument_list|(
name|fd
argument_list|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"BIND: binding SDP socket:<%d>\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__bind_semantics
argument_list|(
name|fd
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|,
name|semantics
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|shadow_fd
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* has shadow */
comment|/* we need to validate the given address or find a common port  		 * so we use the following tmp address and sockets */
name|struct
name|sockaddr_storage
name|tmp_addr
decl_stmt|;
name|int
name|sdp_sd
init|=
operator|-
literal|1
decl_stmt|,
name|tcp_sd
init|=
operator|-
literal|1
decl_stmt|,
name|port
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|tmp_addr
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|sin_addr
operator|->
name|sin_port
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* When we get ANY_PORT we need to make sure that both TCP  			 * and SDP sockets will use the same port */
name|port
operator|=
name|find_free_port
argument_list|(
name|addr
argument_list|,
name|addrlen
argument_list|,
name|fd
argument_list|,
operator|&
name|sdp_sd
argument_list|,
operator|&
name|tcp_sd
argument_list|,
name|semantics
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|<
literal|0
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"BIND: Failed to find common free port\n"
argument_list|)
expr_stmt|;
comment|/* We cannot bind both tcp and sdp on the same port, we will close 				 * the sdp and continue with tcp only */
goto|goto
name|done
goto|;
block|}
else|else
block|{
comment|/* copy the port to the tmp address */
name|set_addr_port_num
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|tmp_addr
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* have a shadow but requested specific port - check that we  			 * can actually bind the two addresses and then reuse */
name|ret
operator|=
name|check_legal_bind
argument_list|(
name|addr
argument_list|,
name|addrlen
argument_list|,
name|fd
argument_list|,
operator|&
name|sdp_sd
argument_list|,
operator|&
name|tcp_sd
argument_list|,
name|semantics
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error bind: "
literal|"Provided address can not bind on the two sockets\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if we fail to find a common port or given address can not be used  		 * we return error */
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/* Temporary sockets already closed by check_legal_bind or  			 * find_free_port */
name|errno
operator|=
name|EADDRINUSE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* close temporary sockets and reuse their address */
comment|/* HACK: close_and_bind might race with other applications. */
comment|/* When the race occur we return EADDRINUSE */
name|ret
operator|=
name|close_and_bind
argument_list|(
name|tcp_sd
argument_list|,
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|tmp_addr
argument_list|,
name|addrlen
argument_list|,
name|semantics
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error bind: "
literal|"Could not close_and_bind TCP side\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|!=
name|sdp_sd
condition|)
name|_socket_funcs
operator|.
name|close
argument_list|(
name|sdp_sd
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|-
literal|1
operator|!=
name|sdp_sd
condition|)
block|{
name|ret
operator|=
name|close_and_bind
argument_list|(
name|sdp_sd
argument_list|,
name|shadow_fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|tmp_addr
argument_list|,
name|addrlen
argument_list|,
name|semantics
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error bind: "
literal|"Could not close_and_bind sdp side\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
goto|goto
name|done
goto|;
block|}
comment|/* we can only get here on single TCP socket */
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"BIND: binding TCP socket:<%d>\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__bind_semantics
argument_list|(
name|fd
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|,
name|semantics
argument_list|)
expr_stmt|;
name|done
label|:
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"BIND:<%s:%d:%d> result<%d:%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|,
name|shadow_fd
argument_list|,
name|ret
argument_list|,
name|sret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* bind */
end_comment

begin_function
name|int
name|bind
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|my_addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|)
block|{
return|return
name|__perform_bind
argument_list|(
name|fd
argument_list|,
name|my_addr
argument_list|,
name|addrlen
argument_list|,
name|SOCKET_SEMANTIC_DEFAULT
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SOLARIS_BUILD
end_ifdef

begin_function
name|int
name|__xnet_bind
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|my_addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|)
block|{
return|return
name|__perform_bind
argument_list|(
name|fd
argument_list|,
name|my_addr
argument_list|,
name|addrlen
argument_list|,
name|SOCKET_SEMANTIC_XNET
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..connect -- replacement connect call.                                     */
end_comment

begin_comment
comment|/*   Given the connect address we can take out AF decision                        if target AF == both it means SDP and fall back to TCP                      if any connect worked we are fine */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|__connect_semantics
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|serv_addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|int
name|semantics
parameter_list|)
block|{
return|return
ifdef|#
directive|ifdef
name|SOLARIS_BUILD
operator|(
name|semantics
operator|==
name|SOCKET_SEMANTIC_XNET
operator|)
condition|?
name|_socket_xnet_funcs
operator|.
name|connect
argument_list|(
name|fd
argument_list|,
name|serv_addr
argument_list|,
name|addrlen
argument_list|)
else|:
endif|#
directive|endif
name|_socket_funcs
operator|.
name|connect
argument_list|(
name|fd
argument_list|,
name|serv_addr
argument_list|,
name|addrlen
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__perform_connect
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|serv_addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|,
name|int
name|semantics
parameter_list|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|serv_sin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|serv_addr
decl_stmt|;
name|char
name|buf
index|[
name|MAX_ADDR_STR_LEN
index|]
decl_stmt|;
name|int
name|shadow_fd
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|,
name|dup_ret
decl_stmt|;
name|use_family_t
name|target_family
decl_stmt|;
name|int
name|fopts
decl_stmt|;
if|if
condition|(
name|init_status
operator|==
literal|0
condition|)
name|__sdp_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|_socket_funcs
operator|.
name|connect
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error connect: no implementation for connect found\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|shadow_fd
operator|=
name|get_shadow_fd_by_fd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|serv_addr
operator|==
name|NULL
operator|)
operator|||
name|is_invalid_addr
argument_list|(
name|serv_addr
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EFAULT
expr_stmt|;
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error connect: illegal address provided\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|get_addr_str
argument_list|(
name|serv_addr
argument_list|,
name|buf
argument_list|,
name|MAX_ADDR_STR_LEN
argument_list|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error connect: provided illegal address: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EADDRNOTAVAIL
return|;
block|}
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"CONNECT:<%s:%d:%d> domain<%d> IP<%s> port<%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|,
name|shadow_fd
argument_list|,
name|serv_sin
operator|->
name|sin_family
argument_list|,
name|buf
argument_list|,
name|ntohs
argument_list|(
name|serv_sin
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
comment|/* obtain the target address family */
name|target_family
operator|=
name|__sdp_match_connect
argument_list|(
name|serv_addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
comment|/* if we do not have a shadow - just do the work */
if|if
condition|(
name|shadow_fd
operator|==
operator|-
literal|1
condition|)
block|{
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"CONNECT: connectingthrough %s\n"
argument_list|,
name|get_is_sdp_socket
argument_list|(
name|fd
argument_list|)
condition|?
literal|"SDP"
else|:
literal|"TCP"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__connect_semantics
argument_list|(
name|fd
argument_list|,
name|serv_addr
argument_list|,
name|addrlen
argument_list|,
name|semantics
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|==
literal|0
operator|)
operator|||
operator|(
name|errno
operator|==
name|EINPROGRESS
operator|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|7
argument_list|,
literal|"CONNECT: connected SDP fd:%d to:%s port %d\n"
argument_list|,
name|fd
argument_list|,
name|buf
argument_list|,
name|ntohs
argument_list|(
name|serv_sin
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|target_family
operator|==
name|USE_SDP
operator|)
operator|||
operator|(
name|target_family
operator|==
name|USE_BOTH
operator|)
condition|)
block|{
comment|/* NOTE: the entire if sequence is negative logic */
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"CONNECT: connecting SDP fd:%d\n"
argument_list|,
name|shadow_fd
argument_list|)
expr_stmt|;
comment|/* make the socket blocking on shadow SDP */
name|fopts
operator|=
name|_socket_funcs
operator|.
name|fcntl
argument_list|(
name|shadow_fd
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|target_family
operator|==
name|USE_BOTH
operator|)
operator|&&
operator|(
name|fopts
operator|&
name|O_NONBLOCK
operator|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"CONNECT: shadow_fd<%d> will be blocking during connect\n"
argument_list|,
name|shadow_fd
argument_list|)
expr_stmt|;
name|_socket_funcs
operator|.
name|fcntl
argument_list|(
name|shadow_fd
argument_list|,
name|F_SETFL
argument_list|,
name|fopts
operator|&
operator|(
operator|~
name|O_NONBLOCK
operator|)
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|__connect_semantics
argument_list|(
name|shadow_fd
argument_list|,
name|serv_addr
argument_list|,
name|addrlen
argument_list|,
name|semantics
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|<
literal|0
operator|)
operator|&&
operator|(
name|errno
operator|!=
name|EINPROGRESS
operator|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error connect: "
literal|"failed for SDP fd:%d with error:%m\n"
argument_list|,
name|shadow_fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|__sdp_log
argument_list|(
literal|7
argument_list|,
literal|"CONNECT: connected SDP fd:%d to:%s port %d\n"
argument_list|,
name|fd
argument_list|,
name|buf
argument_list|,
name|ntohs
argument_list|(
name|serv_sin
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* restore socket options */
name|_socket_funcs
operator|.
name|fcntl
argument_list|(
name|shadow_fd
argument_list|,
name|F_SETFL
argument_list|,
name|fopts
argument_list|)
expr_stmt|;
comment|/* if target is SDP or we succeeded we need to dup SDP fd into TCP fd */
if|if
condition|(
operator|(
name|target_family
operator|==
name|USE_SDP
operator|)
operator|||
operator|(
name|ret
operator|>=
literal|0
operator|)
condition|)
block|{
name|dup_ret
operator|=
name|replace_fd_with_its_shadow
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup_ret
operator|<
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error connect: "
literal|"failed to dup2 shadow into orig fd:%d\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|dup_ret
expr_stmt|;
block|}
else|else
block|{
comment|/* we can skip the TCP option if we are done */
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"CONNECT: "
literal|"matched SDP fd:%d so shadow dup into TCP\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|target_family
operator|==
name|USE_TCP
operator|)
operator|||
operator|(
name|target_family
operator|==
name|USE_BOTH
operator|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"CONNECT: connecting TCP fd:%d\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__connect_semantics
argument_list|(
name|fd
argument_list|,
name|serv_addr
argument_list|,
name|addrlen
argument_list|,
name|semantics
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|<
literal|0
operator|)
operator|&&
operator|(
name|errno
operator|!=
name|EINPROGRESS
operator|)
condition|)
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error connect: for TCP fd:%d failed with error:%m\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
else|else
name|__sdp_log
argument_list|(
literal|7
argument_list|,
literal|"CONNECT: connected TCP fd:%d to:%s port %d\n"
argument_list|,
name|fd
argument_list|,
name|buf
argument_list|,
name|ntohs
argument_list|(
name|serv_sin
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|target_family
operator|==
name|USE_TCP
operator|)
operator|||
operator|(
name|ret
operator|>=
literal|0
operator|)
operator|||
operator|(
name|errno
operator|==
name|EINPROGRESS
operator|)
condition|)
block|{
if|if
condition|(
name|cleanup_shadow
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error connect: failed to cleanup shadow for fd:%d\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
name|done
label|:
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"CONNECT:<%s:%d:%d> result<%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|,
name|shadow_fd
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* connect */
end_comment

begin_function
name|int
name|connect
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|serv_addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|)
block|{
return|return
name|__perform_connect
argument_list|(
name|fd
argument_list|,
name|serv_addr
argument_list|,
name|addrlen
argument_list|,
name|SOCKET_SEMANTIC_DEFAULT
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SOLARIS_BUILD
argument_list|)
end_if

begin_function
name|int
name|__xnet_connect
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|serv_addr
parameter_list|,
name|socklen_t
name|addrlen
parameter_list|)
block|{
return|return
name|__perform_connect
argument_list|(
name|fd
argument_list|,
name|serv_addr
argument_list|,
name|addrlen
argument_list|,
name|SOCKET_SEMANTIC_XNET
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..listen -- replacement listen call.                                       */
end_comment

begin_comment
comment|/*     Now we know our role (passive/server) and our address so we can get AF.    If both we should try listening on both */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|__listen_semantics
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|backlog
parameter_list|,
name|int
name|semantics
parameter_list|)
block|{
return|return
ifdef|#
directive|ifdef
name|SOLARIS_BUILD
operator|(
name|semantics
operator|==
name|SOCKET_SEMANTIC_XNET
operator|)
condition|?
name|_socket_xnet_funcs
operator|.
name|listen
argument_list|(
name|fd
argument_list|,
name|backlog
argument_list|)
else|:
endif|#
directive|endif
name|_socket_funcs
operator|.
name|listen
argument_list|(
name|fd
argument_list|,
name|backlog
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__perform_listen
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|backlog
parameter_list|,
name|int
name|semantics
parameter_list|)
block|{
name|use_family_t
name|target_family
decl_stmt|;
name|int
name|shadow_fd
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|sret
init|=
literal|0
decl_stmt|;
name|struct
name|sockaddr_storage
name|tmp_sin
decl_stmt|;
name|socklen_t
name|tmp_sinlen
init|=
sizeof|sizeof
argument_list|(
name|tmp_sin
argument_list|)
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin4
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|tmp_sin
decl_stmt|;
name|char
name|buf
index|[
name|MAX_ADDR_STR_LEN
index|]
decl_stmt|;
name|int
name|actual_port
decl_stmt|;
if|if
condition|(
name|init_status
operator|==
literal|0
condition|)
name|__sdp_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|_socket_funcs
operator|.
name|listen
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error listen: no implementation for listen found\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|shadow_fd
operator|=
name|get_shadow_fd_by_fd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"LISTEN:<%s:%d:%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|,
name|shadow_fd
argument_list|)
expr_stmt|;
comment|/* if there is no shadow - simply call listen */
if|if
condition|(
name|shadow_fd
operator|==
operator|-
literal|1
condition|)
block|{
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"LISTEN: calling listen on fd:%d\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__listen_semantics
argument_list|(
name|fd
argument_list|,
name|backlog
argument_list|,
name|semantics
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* we need to obtain the address from the fd */
if|if
condition|(
name|_socket_funcs
operator|.
name|getsockname
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|tmp_sin
argument_list|,
operator|&
name|tmp_sinlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error listen: getsockname return<%d> for TCP socket\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
name|sret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|get_addr_str
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|tmp_sin
argument_list|,
name|buf
argument_list|,
name|MAX_ADDR_STR_LEN
argument_list|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error listen: provided illegal address: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"LISTEN:<%s:%d:%d> domain<%d> IP<%s> port<%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|,
name|shadow_fd
argument_list|,
name|sin4
operator|->
name|sin_family
argument_list|,
name|buf
argument_list|,
name|ntohs
argument_list|(
name|sin4
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|target_family
operator|=
name|__sdp_match_listen
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|tmp_sin
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp_sin
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  	 * in case of an implicit bind and "USE_BOTH" rule we need to first bind the  	 * two sockets to the same port number  	 */
name|actual_port
operator|=
name|ntohs
argument_list|(
name|sin4
operator|->
name|sin_port
argument_list|)
expr_stmt|;
comment|/* do we need to implicit bind both */
if|if
condition|(
operator|(
name|actual_port
operator|==
literal|0
operator|)
operator|&&
operator|(
name|target_family
operator|==
name|USE_BOTH
operator|)
condition|)
block|{
name|int
name|sdp_sd
init|=
operator|-
literal|1
decl_stmt|,
name|tcp_sd
init|=
operator|-
literal|1
decl_stmt|;
name|actual_port
operator|=
name|find_free_port
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|tmp_sin
argument_list|,
name|tmp_sinlen
argument_list|,
name|fd
argument_list|,
operator|&
name|sdp_sd
argument_list|,
operator|&
name|tcp_sd
argument_list|,
name|semantics
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual_port
operator|<
literal|0
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
name|__sdp_log
argument_list|(
literal|8
argument_list|,
literal|"LISTEN: Failed to find common free port. Only TCP will be used.\n"
argument_list|)
expr_stmt|;
name|target_family
operator|=
name|USE_TCP
expr_stmt|;
block|}
else|else
block|{
comment|/* copy the port to the tmp address */
name|set_addr_port_num
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin4
argument_list|,
name|actual_port
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"LISTEN: BOTH on IP<%s> port<%d>\n"
argument_list|,
name|buf
argument_list|,
name|actual_port
argument_list|)
expr_stmt|;
comment|/* perform the bind */
name|ret
operator|=
name|close_and_bind
argument_list|(
name|tcp_sd
argument_list|,
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin4
argument_list|,
name|tmp_sinlen
argument_list|,
name|semantics
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error listen: "
literal|"Could not close_and_bind TCP side\n"
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|close_and_bind
argument_list|(
name|sdp_sd
argument_list|,
name|shadow_fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin4
argument_list|,
name|tmp_sinlen
argument_list|,
name|semantics
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error listen: "
literal|"Could not close_and_bind SDP side\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|target_family
operator|==
name|USE_TCP
operator|)
operator|||
operator|(
name|target_family
operator|==
name|USE_BOTH
operator|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"LISTEN: calling listen on TCP fd:%d\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__listen_semantics
argument_list|(
name|fd
argument_list|,
name|backlog
argument_list|,
name|semantics
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error listen: failed with code<%d> on TCP fd:<%d>\n"
argument_list|,
name|errno
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|__sdp_log
argument_list|(
literal|7
argument_list|,
literal|"LISTEN: fd:%d listening on TCP bound to:%s port:%d\n"
argument_list|,
name|fd
argument_list|,
name|buf
argument_list|,
name|actual_port
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|target_family
operator|==
name|USE_SDP
operator|)
operator|||
operator|(
name|target_family
operator|==
name|USE_BOTH
operator|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"LISTEN: calling listen on SDP fd:<%d>\n"
argument_list|,
name|shadow_fd
argument_list|)
expr_stmt|;
name|sret
operator|=
name|__listen_semantics
argument_list|(
name|shadow_fd
argument_list|,
name|backlog
argument_list|,
name|semantics
argument_list|)
expr_stmt|;
if|if
condition|(
name|sret
operator|<
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error listen: failed with code<%d> SDP fd:<%d>\n"
argument_list|,
name|errno
argument_list|,
name|shadow_fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|__sdp_log
argument_list|(
literal|7
argument_list|,
literal|"LISTEN: fd:%d listening on SDP bound to:%s port:%d\n"
argument_list|,
name|fd
argument_list|,
name|buf
argument_list|,
name|actual_port
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* cleanup the un-needed shadow if TCP and did not fail */
if|if
condition|(
operator|(
name|target_family
operator|==
name|USE_TCP
operator|)
operator|&&
operator|(
name|ret
operator|>=
literal|0
operator|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"LISTEN: cleaning up shadow SDP\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanup_shadow
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error listen: failed to cleanup shadow for fd:%d\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
comment|/* cleanup the TCP socket and replace with SDP */
if|if
condition|(
operator|(
name|target_family
operator|==
name|USE_SDP
operator|)
operator|&&
operator|(
name|sret
operator|>=
literal|0
operator|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"LISTEN: cleaning TCP socket and dup2 SDP into it\n"
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|>
operator|(
name|sret
operator|=
name|replace_fd_with_its_shadow
argument_list|(
name|fd
argument_list|)
operator|)
condition|)
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error listen: "
literal|"failed to dup2 shadow into orig fd:%d\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"LISTEN:<%s:%d:%d> result<%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|,
name|shadow_fd
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* its a success only if both are ok */
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|sret
operator|<
literal|0
condition|)
return|return
operator|(
name|sret
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* listen */
end_comment

begin_function
name|int
name|listen
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|backlog
parameter_list|)
block|{
return|return
name|__perform_listen
argument_list|(
name|fd
argument_list|,
name|backlog
argument_list|,
name|SOCKET_SEMANTIC_DEFAULT
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SOLARIS_BUILD
end_ifdef

begin_function
name|int
name|__xnet_listen
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|backlog
parameter_list|)
block|{
return|return
name|__perform_listen
argument_list|(
name|fd
argument_list|,
name|backlog
argument_list|,
name|SOCKET_SEMANTIC_XNET
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..close -- replacement close call. */
end_comment

begin_function
name|int
name|close
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|int
name|shadow_fd
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|init_status
operator|==
literal|0
condition|)
name|__sdp_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|_socket_funcs
operator|.
name|close
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error close: no implementation for close found\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|shadow_fd
operator|=
name|get_shadow_fd_by_fd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"CLOSE:<%s:%d:%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|,
name|shadow_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|shadow_fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"CLOSE: closing shadow fd:<%d>\n"
argument_list|,
name|shadow_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanup_shadow
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error close: failed to cleanup shadow for fd:%d\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
name|init_extra_attribute
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_socket_funcs
operator|.
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"CLOSE:<%s:%d:%d> result<%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|,
name|shadow_fd
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* close */
end_comment

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..dup -- replacement dup call.                                             */
end_comment

begin_comment
comment|/* we duplicate the fd and its shadow if exists - ok if the main worked      */
end_comment

begin_function
name|int
name|dup
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|int
name|newfd
decl_stmt|,
name|new_shadow_fd
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|shadow_fd
decl_stmt|;
if|if
condition|(
name|init_status
operator|==
literal|0
condition|)
name|__sdp_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|_socket_funcs
operator|.
name|dup
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error dup: no implementation for dup found\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|shadow_fd
operator|=
name|get_shadow_fd_by_fd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"DUP:<%s:%d:%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|,
name|shadow_fd
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"DUP: duplication fd:<%d>\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|newfd
operator|=
name|_socket_funcs
operator|.
name|dup
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfd
operator|==
name|fd
condition|)
return|return
operator|(
name|fd
operator|)
return|;
if|if
condition|(
operator|!
name|is_valid_fd
argument_list|(
name|newfd
argument_list|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error dup: new fd<%d> out of range.\n"
argument_list|,
name|newfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* copy attributes from old fd */
name|libsdp_fd_attributes
index|[
name|newfd
index|]
operator|=
name|libsdp_fd_attributes
index|[
name|fd
index|]
expr_stmt|;
name|libsdp_fd_attributes
index|[
name|newfd
index|]
operator|.
name|shadow_fd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|shadow_fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"DUP: duplication shadow fd:<%d>\n"
argument_list|,
name|shadow_fd
argument_list|)
expr_stmt|;
name|new_shadow_fd
operator|=
name|_socket_funcs
operator|.
name|dup
argument_list|(
name|shadow_fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new_shadow_fd
operator|>
name|max_file_descriptors
operator|)
operator|||
operator|(
name|new_shadow_fd
operator|<
literal|0
operator|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error dup: new shadow fd<%d> out of range.\n"
argument_list|,
name|new_shadow_fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|libsdp_fd_attributes
index|[
name|new_shadow_fd
index|]
operator|=
name|libsdp_fd_attributes
index|[
name|shadow_fd
index|]
expr_stmt|;
name|libsdp_fd_attributes
index|[
name|newfd
index|]
operator|.
name|shadow_fd
operator|=
name|new_shadow_fd
expr_stmt|;
block|}
block|}
comment|/* shadow exists */
block|}
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"DUP:<%s:%d:%d> return<%d:%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|,
name|shadow_fd
argument_list|,
name|newfd
argument_list|,
name|new_shadow_fd
argument_list|)
expr_stmt|;
return|return
name|newfd
return|;
block|}
end_function

begin_comment
comment|/* dup */
end_comment

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..dup2 -- replacement dup2 call.                                           */
end_comment

begin_comment
comment|/* since only the main new fd is given we only move the shadow if exists     */
end_comment

begin_function
name|int
name|dup2
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|newfd
parameter_list|)
block|{
name|int
name|shadow_fd
decl_stmt|;
name|int
name|shadow_newfd
decl_stmt|;
name|int
name|new_shadow_fd
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|init_status
operator|==
literal|0
condition|)
name|__sdp_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|_socket_funcs
operator|.
name|dup2
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error dup2: no implementation for dup2 found\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|shadow_fd
operator|=
name|get_shadow_fd_by_fd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|shadow_newfd
operator|=
name|get_shadow_fd_by_fd
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"DUP2:<%s:%d:%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|,
name|shadow_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfd
operator|==
name|fd
condition|)
block|{
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"DUP2: skip duplicating fd:<%d> into:<%d>\n"
argument_list|,
name|fd
argument_list|,
name|newfd
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* dup2 closes the target file desc if it is a valid fd */
if|if
condition|(
name|shadow_newfd
operator|!=
operator|-
literal|1
condition|)
block|{
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"DUP2: closing newfd:<%d> shadow:<%d>\n"
argument_list|,
name|newfd
argument_list|,
name|shadow_newfd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_socket_funcs
operator|.
name|close
argument_list|(
name|shadow_newfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"DUP2: fail to close newfd:<%d> shadow:<%d> with: %d %s\n"
argument_list|,
name|newfd
argument_list|,
name|shadow_newfd
argument_list|,
name|ret
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"DUP2: duplicating fd:<%d> into:<%d>\n"
argument_list|,
name|fd
argument_list|,
name|newfd
argument_list|)
expr_stmt|;
name|newfd
operator|=
name|_socket_funcs
operator|.
name|dup2
argument_list|(
name|fd
argument_list|,
name|newfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|newfd
operator|>
name|max_file_descriptors
operator|)
operator|||
operator|(
name|newfd
operator|<
literal|0
operator|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error dup2: new fd<%d> out of range.\n"
argument_list|,
name|newfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* copy attributes from old fd */
name|libsdp_fd_attributes
index|[
name|fd
index|]
operator|.
name|shadow_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|libsdp_fd_attributes
index|[
name|newfd
index|]
operator|=
name|libsdp_fd_attributes
index|[
name|fd
index|]
expr_stmt|;
comment|/* if it had a shadow create a new shadow */
if|if
condition|(
name|shadow_fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"DUP2: duplication shadow fd:<%d>\n"
argument_list|,
name|shadow_fd
argument_list|)
expr_stmt|;
name|new_shadow_fd
operator|=
name|_socket_funcs
operator|.
name|dup
argument_list|(
name|shadow_fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new_shadow_fd
operator|>
name|max_file_descriptors
operator|)
operator|||
operator|(
name|new_shadow_fd
operator|<
literal|0
operator|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error dup2: new shadow fd<%d> out of range.\n"
argument_list|,
name|new_shadow_fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|libsdp_fd_attributes
index|[
name|new_shadow_fd
index|]
operator|=
name|libsdp_fd_attributes
index|[
name|shadow_fd
index|]
expr_stmt|;
name|libsdp_fd_attributes
index|[
name|newfd
index|]
operator|.
name|shadow_fd
operator|=
name|new_shadow_fd
expr_stmt|;
block|}
block|}
comment|/* newfd is ok */
block|}
name|done
label|:
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"DUP2:<%s:%d:%d> return<%d:%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|,
name|shadow_fd
argument_list|,
name|newfd
argument_list|,
name|new_shadow_fd
argument_list|)
expr_stmt|;
return|return
name|newfd
return|;
block|}
end_function

begin_comment
comment|/* dup */
end_comment

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..getsockname -- replacement getsocknanme call.                            */
end_comment

begin_function
name|int
name|getsockname
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|name
parameter_list|,
name|socklen_t
modifier|*
name|namelen
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
name|MAX_ADDR_STR_LEN
index|]
decl_stmt|;
if|if
condition|(
name|init_status
operator|==
literal|0
condition|)
name|__sdp_init
argument_list|()
expr_stmt|;
comment|/* 	 * ensure the SDP protocol family is not exposed to the user, since 	 * this is meant to be a transparency layer. 	 */
if|if
condition|(
name|NULL
operator|==
name|_socket_funcs
operator|.
name|getsockname
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error getsockname: no implementation for getsockname found\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* double check provided pointers */
if|if
condition|(
operator|(
name|name
operator|==
name|NULL
operator|)
operator|||
name|is_invalid_addr
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EFAULT
expr_stmt|;
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error getsockname: illegal address provided\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|namelen
operator|!=
name|NULL
operator|)
operator|&&
name|is_invalid_addr
argument_list|(
name|namelen
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EFAULT
expr_stmt|;
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error getsockname: illegal address length pointer provided\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"GETSOCKNAME<%s:%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_socket_funcs
operator|.
name|getsockname
argument_list|(
name|fd
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|__sdp_log_get_level
argument_list|()
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|get_addr_str
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
name|MAX_ADDR_STR_LEN
argument_list|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"GETSOCKNAME: "
literal|"address is illegal\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"GETSOCKNAME: address is:%s port:%d\n"
argument_list|,
name|buf
argument_list|,
name|ntohs
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|name
operator|)
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"GETSOCKNAME<%s:%d> result<%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* getsockname */
end_comment

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..getpeername -- replacement getpeername call. */
end_comment

begin_function
name|int
name|getpeername
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|name
parameter_list|,
name|socklen_t
modifier|*
name|namelen
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|init_status
operator|==
literal|0
condition|)
name|__sdp_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|_socket_funcs
operator|.
name|getpeername
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error getpeername: "
literal|"no implementation for getpeername found\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* double check provided pointers */
if|if
condition|(
operator|(
name|name
operator|==
name|NULL
operator|)
operator|||
name|is_invalid_addr
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EFAULT
expr_stmt|;
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error getsockname: illegal address provided\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|namelen
operator|!=
name|NULL
operator|)
operator|&&
name|is_invalid_addr
argument_list|(
name|namelen
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EFAULT
expr_stmt|;
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error getsockname: illegal address length pointer provided\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"GETPEERNAME<%s:%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_socket_funcs
operator|.
name|getpeername
argument_list|(
name|fd
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"GETPEERNAME<%s:%d> result<%d:%d> family=%d s_addr=%d\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|,
name|ret
argument_list|,
operator|(
operator|!
operator|(
literal|0
operator|>
name|ret
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
argument_list|,
name|name
operator|->
name|sa_family
argument_list|,
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|name
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* getpeername */
end_comment

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..accept -- replacement accept call.                                       */
end_comment

begin_comment
comment|/*   If we have a shadow we need to decide which socket we want to accept on   so we select first and then give priority based on previous selection */
end_comment

begin_function
name|int
name|accept
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|socklen_t
modifier|*
name|addrlen
parameter_list|)
block|{
name|int
name|shadow_fd
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|fd_set
name|fds
decl_stmt|;
name|socklen_t
name|saved_addrlen
init|=
literal|0
decl_stmt|;
name|int
name|fopts
decl_stmt|;
name|char
name|buf
index|[
name|MAX_ADDR_STR_LEN
index|]
decl_stmt|;
if|if
condition|(
name|init_status
operator|==
literal|0
condition|)
name|__sdp_init
argument_list|()
expr_stmt|;
name|shadow_fd
operator|=
name|get_shadow_fd_by_fd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* 	 * ensure the SDP protocol family is not exposed to the user, since 	 * this is meant to be a transparency layer. 	 */
if|if
condition|(
name|NULL
operator|==
name|_socket_funcs
operator|.
name|accept
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error accept: no implementation for accept found\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* double check provided pointers */
if|if
condition|(
operator|(
name|addr
operator|!=
name|NULL
operator|)
operator|&&
name|is_invalid_addr
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error accept: illegal address provided\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|addrlen
operator|!=
name|NULL
operator|)
operator|&&
name|is_invalid_addr
argument_list|(
name|addrlen
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error accept: illegal address length pointer provided\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|addr
operator|&&
name|addrlen
condition|)
name|saved_addrlen
operator|=
operator|*
name|addrlen
expr_stmt|;
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"ACCEPT:<%s:%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|shadow_fd
operator|==
operator|-
literal|1
condition|)
block|{
name|fopts
operator|=
name|_socket_funcs
operator|.
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"ACCEPT: fd<%d> opts are<0x%x>\n"
argument_list|,
name|fd
argument_list|,
name|fopts
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|7
argument_list|,
literal|"ACCEPT: accepting on single fd:<%d>\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_socket_funcs
operator|.
name|accept
argument_list|(
name|fd
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|fopts
operator|&
name|O_NONBLOCK
operator|&&
name|errno
operator|==
name|EWOULDBLOCK
operator|)
condition|)
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error accept: accept returned :<%d> %s\n"
argument_list|,
name|ret
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_is_sdp_socket
argument_list|(
name|ret
argument_list|,
name|get_is_sdp_socket
argument_list|(
name|fd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fopts
operator|=
name|_socket_funcs
operator|.
name|fcntl
argument_list|(
name|shadow_fd
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"ACCEPT: shadow_fd<%d> opts are<0x%x>\n"
argument_list|,
name|shadow_fd
argument_list|,
name|fopts
argument_list|)
expr_stmt|;
comment|/* we need different behavior for NONBLOCK or signal IO and BLOCK */
if|if
condition|(
operator|(
name|fopts
operator|>
literal|0
operator|)
operator|&&
operator|(
name|fopts
operator|&
operator|(
name|O_NONBLOCK
operator||
name|FASYNC
operator|)
operator|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"ACCEPT: accepting (nonblock) on SDP fd:<%d>\n"
argument_list|,
name|shadow_fd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_socket_funcs
operator|.
name|accept
argument_list|(
name|shadow_fd
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
name|set_is_sdp_socket
argument_list|(
name|ret
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|7
argument_list|,
literal|"ACCEPT: accepted (nonblock) SDP fd:<%d>\n"
argument_list|,
name|shadow_fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"ACCEPT: accept on SDP fd:<%d> return:%d errno:%d\n"
argument_list|,
name|shadow_fd
argument_list|,
name|ret
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"ACCEPT: accepting (nonblock) on TCP fd:<%d>\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_socket_funcs
operator|.
name|accept
argument_list|(
name|fd
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|7
argument_list|,
literal|"ACCEPT: accepted (nonblock) TCP fd:<%d>\n"
argument_list|,
name|shadow_fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"ACCEPT: accept on TCP fd:<%d> "
literal|"return:%d errno:%d\n"
argument_list|,
name|fd
argument_list|,
name|ret
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"ACCEPT: selecting both fd:<%d> and shadow:<%d>\n"
argument_list|,
name|fd
argument_list|,
name|shadow_fd
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|shadow_fd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_socket_funcs
operator|.
name|select
argument_list|(
literal|1
operator|+
operator|(
operator|(
name|fd
operator|>
name|shadow_fd
operator|)
condition|?
name|fd
else|:
name|shadow_fd
operator|)
argument_list|,
operator|&
name|fds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|last_accept_was_tcp
argument_list|(
name|fd
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|fds
argument_list|)
condition|)
block|{
name|set_last_accept
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|7
argument_list|,
literal|"ACCEPT: accepting on TCP fd:<%d>\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_socket_funcs
operator|.
name|accept
argument_list|(
name|fd
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|__sdp_log
argument_list|(
literal|7
argument_list|,
literal|"ACCEPT: accepting on SDP fd:<%d>\n"
argument_list|,
name|shadow_fd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_socket_funcs
operator|.
name|accept
argument_list|(
name|shadow_fd
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
name|set_is_sdp_socket
argument_list|(
name|ret
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|shadow_fd
argument_list|,
operator|&
name|fds
argument_list|)
condition|)
block|{
name|set_last_accept
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|7
argument_list|,
literal|"ACCEPT: accepting on SDP fd:<%d>\n"
argument_list|,
name|shadow_fd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_socket_funcs
operator|.
name|accept
argument_list|(
name|shadow_fd
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
name|set_is_sdp_socket
argument_list|(
name|ret
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|__sdp_log
argument_list|(
literal|7
argument_list|,
literal|"ACCEPT: accepting on TCP fd:<%d>\n"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_socket_funcs
operator|.
name|accept
argument_list|(
name|fd
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error accept: select returned :<%d> (%d) %s\n"
argument_list|,
name|ret
argument_list|,
name|errno
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"ACCEPT: select returned :<%d> (%d) %s\n"
argument_list|,
name|ret
argument_list|,
name|errno
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* blocking mode */
block|}
comment|/* shadow fd */
if|if
condition|(
operator|(
name|__sdp_log_get_level
argument_list|()
operator|<=
literal|1
operator|)
operator|&&
operator|(
name|ret
operator|>=
literal|0
operator|)
operator|&&
name|addr
operator|&&
name|addrlen
condition|)
block|{
name|get_addr_str
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
operator|*
name|addrlen
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"ACCEPT: accepted from:%s port:%d into fd:%d\n"
argument_list|,
name|buf
argument_list|,
name|ntohs
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_port
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"ACCEPT:<%s:%d> return<%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* accept */
end_comment

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..select -- replacement socket call.                                       */
end_comment

begin_comment
comment|/*     if we have shadow we must select on it too - which requires a hack back     and forth */
end_comment

begin_function
name|int
name|select
parameter_list|(
name|int
name|n
parameter_list|,
name|fd_set
modifier|*
name|readfds
parameter_list|,
name|fd_set
modifier|*
name|writefds
parameter_list|,
name|fd_set
modifier|*
name|exceptfds
parameter_list|,
name|struct
name|timeval
modifier|*
name|timeout
parameter_list|)
block|{
name|int
name|shadow_fd
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|current
decl_stmt|;
name|int
name|maxi
init|=
literal|0
decl_stmt|;
name|fd_set
name|new_fds
decl_stmt|;
if|if
condition|(
name|init_status
operator|==
literal|0
condition|)
name|__sdp_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|_socket_funcs
operator|.
name|select
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error select: no implementation for select found\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"SELECT:<%s:%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* if we do not read - nothing to do */
if|if
condition|(
name|readfds
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|_socket_funcs
operator|.
name|select
argument_list|(
name|n
argument_list|,
name|readfds
argument_list|,
name|writefds
argument_list|,
name|exceptfds
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|FD_ZERO
argument_list|(
operator|&
name|new_fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|maxi
operator|=
name|n
operator|-
literal|1
expr_stmt|;
block|}
comment|/* add shadow bits */
for|for
control|(
name|current
operator|=
literal|0
init|;
name|current
operator|<
name|n
condition|;
name|current
operator|++
control|)
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|current
argument_list|,
name|readfds
argument_list|)
condition|)
block|{
name|FD_SET
argument_list|(
name|current
argument_list|,
operator|&
name|new_fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|>
name|maxi
condition|)
block|{
name|maxi
operator|=
name|current
expr_stmt|;
block|}
name|shadow_fd
operator|=
name|get_shadow_fd_by_fd
argument_list|(
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|shadow_fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"SELECT: adding fd:<%d> shadow_fd:<%d> to readfs\n"
argument_list|,
name|current
argument_list|,
name|shadow_fd
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|shadow_fd
argument_list|,
operator|&
name|new_fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|shadow_fd
operator|>
name|maxi
condition|)
block|{
name|maxi
operator|=
name|shadow_fd
expr_stmt|;
block|}
block|}
block|}
block|}
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"SELECT: invoking select n=<%d>\n"
argument_list|,
literal|1
operator|+
name|maxi
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_socket_funcs
operator|.
name|select
argument_list|(
literal|1
operator|+
name|maxi
argument_list|,
operator|&
name|new_fds
argument_list|,
name|writefds
argument_list|,
name|exceptfds
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
comment|/* remove the count and bits of the shadows */
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|current
operator|=
literal|0
init|;
name|current
operator|<
name|n
condition|;
name|current
operator|++
control|)
block|{
name|shadow_fd
operator|=
name|get_shadow_fd_by_fd
argument_list|(
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|shadow_fd
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|current
argument_list|,
name|readfds
argument_list|)
operator|&&
name|FD_ISSET
argument_list|(
name|current
argument_list|,
operator|&
name|new_fds
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FD_CLR
argument_list|(
name|current
argument_list|,
name|readfds
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|current
argument_list|,
name|readfds
argument_list|)
operator|&&
name|FD_ISSET
argument_list|(
name|current
argument_list|,
operator|&
name|new_fds
argument_list|)
operator|&&
name|FD_ISSET
argument_list|(
name|shadow_fd
argument_list|,
operator|&
name|new_fds
argument_list|)
condition|)
block|{
name|ret
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|FD_ISSET
argument_list|(
name|current
argument_list|,
name|readfds
argument_list|)
operator|&&
name|FD_ISSET
argument_list|(
name|current
argument_list|,
operator|&
name|new_fds
argument_list|)
operator|==
literal|0
operator|&&
name|FD_ISSET
argument_list|(
name|shadow_fd
argument_list|,
operator|&
name|new_fds
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FD_CLR
argument_list|(
name|current
argument_list|,
name|readfds
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|done
label|:
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"SELECT:<%s:%d> return<%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|n
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* select */
end_comment

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..pselect -- replacement socket call.                                      */
end_comment

begin_comment
comment|/*     if we have shadow we must pselect on it too - which requires a hack back     and forth */
end_comment

begin_function
name|int
name|pselect
parameter_list|(
name|int
name|n
parameter_list|,
name|fd_set
modifier|*
name|readfds
parameter_list|,
name|fd_set
modifier|*
name|writefds
parameter_list|,
name|fd_set
modifier|*
name|exceptfds
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|,
specifier|const
name|sigset_t
modifier|*
name|sigmask
parameter_list|)
block|{
name|int
name|shadow_fd
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|current
decl_stmt|;
name|int
name|maxi
init|=
literal|0
decl_stmt|;
name|fd_set
name|new_fds
decl_stmt|;
if|if
condition|(
name|init_status
operator|==
literal|0
condition|)
name|__sdp_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|_socket_funcs
operator|.
name|pselect
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error pselect: no implementation for pselect found\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"PSELECT:<%s:%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* if we do not read - nothing to do */
if|if
condition|(
name|readfds
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|_socket_funcs
operator|.
name|pselect
argument_list|(
name|n
argument_list|,
name|readfds
argument_list|,
name|writefds
argument_list|,
name|exceptfds
argument_list|,
name|timeout
argument_list|,
name|sigmask
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|FD_ZERO
argument_list|(
operator|&
name|new_fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|maxi
operator|=
name|n
operator|-
literal|1
expr_stmt|;
block|}
comment|/* add shadow bits */
for|for
control|(
name|current
operator|=
literal|0
init|;
name|current
operator|<
name|n
condition|;
name|current
operator|++
control|)
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|current
argument_list|,
name|readfds
argument_list|)
condition|)
block|{
name|FD_SET
argument_list|(
name|current
argument_list|,
operator|&
name|new_fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|>
name|maxi
condition|)
block|{
name|maxi
operator|=
name|current
expr_stmt|;
block|}
name|shadow_fd
operator|=
name|get_shadow_fd_by_fd
argument_list|(
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|shadow_fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"PSELECT: adding fd:<%d> shadow_fd:<%d> to readfs\n"
argument_list|,
name|current
argument_list|,
name|shadow_fd
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|shadow_fd
argument_list|,
operator|&
name|new_fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|shadow_fd
operator|>
name|maxi
condition|)
block|{
name|maxi
operator|=
name|shadow_fd
expr_stmt|;
block|}
block|}
block|}
block|}
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"PSELECT: invoking pselect n=<%d>\n"
argument_list|,
literal|1
operator|+
name|maxi
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_socket_funcs
operator|.
name|pselect
argument_list|(
literal|1
operator|+
name|maxi
argument_list|,
operator|&
name|new_fds
argument_list|,
name|writefds
argument_list|,
name|exceptfds
argument_list|,
name|timeout
argument_list|,
name|sigmask
argument_list|)
expr_stmt|;
comment|/* remove the count and bits of the shadows */
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
for|for
control|(
name|current
operator|=
literal|0
init|;
name|current
operator|<
name|n
condition|;
name|current
operator|++
control|)
block|{
name|shadow_fd
operator|=
name|get_shadow_fd_by_fd
argument_list|(
name|current
argument_list|)
expr_stmt|;
if|if
condition|(
name|shadow_fd
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|current
argument_list|,
name|readfds
argument_list|)
operator|&&
name|FD_ISSET
argument_list|(
name|current
argument_list|,
operator|&
name|new_fds
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FD_CLR
argument_list|(
name|current
argument_list|,
name|readfds
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|current
argument_list|,
name|readfds
argument_list|)
operator|&&
name|FD_ISSET
argument_list|(
name|current
argument_list|,
operator|&
name|new_fds
argument_list|)
operator|&&
name|FD_ISSET
argument_list|(
name|shadow_fd
argument_list|,
operator|&
name|new_fds
argument_list|)
condition|)
block|{
name|ret
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|FD_ISSET
argument_list|(
name|current
argument_list|,
name|readfds
argument_list|)
operator|&&
name|FD_ISSET
argument_list|(
name|current
argument_list|,
operator|&
name|new_fds
argument_list|)
operator|==
literal|0
operator|&&
name|FD_ISSET
argument_list|(
name|shadow_fd
argument_list|,
operator|&
name|new_fds
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FD_CLR
argument_list|(
name|current
argument_list|,
name|readfds
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|done
label|:
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"PSELECT:<%s:%d> return<%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|n
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* pselect */
end_comment

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..poll -- replacement socket call.                                      */
end_comment

begin_comment
comment|/*     if we have shadow we must poll on it too - which requires a hack back     and forth */
end_comment

begin_function
name|int
name|poll
parameter_list|(
name|struct
name|pollfd
modifier|*
name|ufds
parameter_list|,
name|nfds_t
name|nfds
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|shadow_fd
decl_stmt|;
name|int
name|current
decl_stmt|;
name|int
name|extra
init|=
literal|0
decl_stmt|;
name|struct
name|pollfd
modifier|*
name|poll_fds
init|=
name|NULL
decl_stmt|;
name|struct
name|pollfd
modifier|*
name|poll_fd_ptr
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|init_status
operator|==
literal|0
condition|)
name|__sdp_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|_socket_funcs
operator|.
name|poll
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error poll: no implementation for poll found\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"POLL:<%s:%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|nfds
argument_list|)
expr_stmt|;
comment|/* if we do not have any file desc - nothing to do */
if|if
condition|(
name|ufds
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|_socket_funcs
operator|.
name|poll
argument_list|(
name|ufds
argument_list|,
name|nfds
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* scan for how many extra fds are required */
for|for
control|(
name|current
operator|=
literal|0
init|;
name|current
operator|<
name|nfds
condition|;
name|current
operator|++
control|)
block|{
name|shadow_fd
operator|=
name|get_shadow_fd_by_fd
argument_list|(
name|ufds
index|[
name|current
index|]
operator|.
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|shadow_fd
operator|!=
operator|-
literal|1
condition|)
name|extra
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|extra
condition|)
block|{
name|poll_fds
operator|=
name|ufds
expr_stmt|;
block|}
else|else
block|{
name|poll_fds
operator|=
operator|(
expr|struct
name|pollfd
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|nfds
operator|+
name|extra
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pollfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|poll_fds
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error poll: malloc of extended pollfd array failed\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|poll_fd_ptr
operator|=
name|poll_fds
expr_stmt|;
for|for
control|(
name|current
operator|=
literal|0
init|;
name|current
operator|<
name|nfds
condition|;
name|current
operator|++
control|)
block|{
operator|*
name|poll_fd_ptr
operator|=
name|ufds
index|[
name|current
index|]
expr_stmt|;
name|poll_fd_ptr
operator|++
expr_stmt|;
name|shadow_fd
operator|=
name|get_shadow_fd_by_fd
argument_list|(
name|ufds
index|[
name|current
index|]
operator|.
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|shadow_fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"POLL: adding fd:<%d> shadow_fd:<%d> to readfs\n"
argument_list|,
name|current
argument_list|,
name|shadow_fd
argument_list|)
expr_stmt|;
operator|*
name|poll_fd_ptr
operator|=
name|ufds
index|[
name|current
index|]
expr_stmt|;
name|poll_fd_ptr
operator|->
name|fd
operator|=
name|shadow_fd
expr_stmt|;
name|poll_fd_ptr
operator|++
expr_stmt|;
block|}
block|}
block|}
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"POLL: invoking poll nfds=<%d>\n"
argument_list|,
name|nfds
operator|+
name|extra
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_socket_funcs
operator|.
name|poll
argument_list|(
name|poll_fds
argument_list|,
name|nfds
operator|+
name|extra
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
comment|/* refactor into original list if any events */
if|if
condition|(
operator|(
name|ret
operator|>
literal|0
operator|)
operator|&&
name|extra
condition|)
block|{
name|poll_fd_ptr
operator|=
name|poll_fds
expr_stmt|;
for|for
control|(
name|current
operator|=
literal|0
init|;
name|current
operator|<
name|nfds
condition|;
name|current
operator|++
control|)
block|{
name|shadow_fd
operator|=
name|get_shadow_fd_by_fd
argument_list|(
name|ufds
index|[
name|current
index|]
operator|.
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|shadow_fd
operator|==
operator|-
literal|1
condition|)
block|{
name|ufds
index|[
name|current
index|]
operator|=
operator|*
name|poll_fd_ptr
expr_stmt|;
block|}
else|else
block|{
name|ufds
index|[
name|current
index|]
operator|=
operator|*
name|poll_fd_ptr
expr_stmt|;
name|poll_fd_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|poll_fd_ptr
operator|->
name|revents
condition|)
block|{
if|if
condition|(
name|ufds
index|[
name|current
index|]
operator|.
name|revents
condition|)
name|ret
operator|--
expr_stmt|;
name|ufds
index|[
name|current
index|]
operator|.
name|revents
operator||=
name|poll_fd_ptr
operator|->
name|revents
expr_stmt|;
block|}
block|}
name|poll_fd_ptr
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|extra
condition|)
name|free
argument_list|(
name|poll_fds
argument_list|)
expr_stmt|;
name|done
label|:
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"POLL:<%s:%d> return<%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|nfds
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* poll */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..epoll_create -- replacement socket call.                                 */
end_comment

begin_comment
comment|/*    Need to make the size twice as large for shadow fds */
end_comment

begin_function
name|int
name|epoll_create
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|int
name|epfd
decl_stmt|;
if|if
condition|(
name|init_status
operator|==
literal|0
condition|)
name|__sdp_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|_socket_funcs
operator|.
name|epoll_create
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error epoll_create: no implementation for epoll_create found\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"EPOLL_CREATE:<%s:%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|epfd
operator|=
name|_socket_funcs
operator|.
name|epoll_create
argument_list|(
name|size
operator|*
literal|2
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"EPOLL_CREATE:<%s:%d> return %d\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|size
argument_list|,
name|epfd
argument_list|)
expr_stmt|;
return|return
name|epfd
return|;
block|}
end_function

begin_comment
comment|/* epoll_create */
end_comment

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..epoll_ctl -- replacement socket call.                                   */
end_comment

begin_comment
comment|/*    Need to add/delete/modify shadow fds as well */
end_comment

begin_function
name|int
name|epoll_ctl
parameter_list|(
name|int
name|epfd
parameter_list|,
name|int
name|op
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|epoll_event
modifier|*
name|event
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|shadow_fd
decl_stmt|,
name|ret2
decl_stmt|;
if|if
condition|(
name|init_status
operator|==
literal|0
condition|)
name|__sdp_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|_socket_funcs
operator|.
name|epoll_ctl
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error epoll_ctl: no implementation for epoll_ctl found\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"EPOLL_CTL:<%s:%d> op<%d:%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|epfd
argument_list|,
name|op
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_socket_funcs
operator|.
name|epoll_ctl
argument_list|(
name|epfd
argument_list|,
name|op
argument_list|,
name|fd
argument_list|,
name|event
argument_list|)
expr_stmt|;
name|shadow_fd
operator|=
name|get_shadow_fd_by_fd
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|shadow_fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|ret2
operator|=
name|_socket_funcs
operator|.
name|epoll_ctl
argument_list|(
name|epfd
argument_list|,
name|op
argument_list|,
name|shadow_fd
argument_list|,
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret2
operator|<
literal|0
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error epoll_ctl<%s:%d:%d>"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|fd
argument_list|,
name|shadow_fd
argument_list|)
expr_stmt|;
return|return
name|ret2
return|;
block|}
block|}
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"EPOLL_CTL:<%s:%d> return<%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|epfd
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* epoll_ctl */
end_comment

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..epoll_wait -- replacement socket call.                                   */
end_comment

begin_comment
comment|/*    We don't care who generated the event because all we get is user-context    values. */
end_comment

begin_function
name|int
name|epoll_wait
parameter_list|(
name|int
name|epfd
parameter_list|,
name|struct
name|epoll_event
modifier|*
name|events
parameter_list|,
name|int
name|maxevents
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|init_status
operator|==
literal|0
condition|)
name|__sdp_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|_socket_funcs
operator|.
name|epoll_wait
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error epoll_wait: no implementation for epoll_wait found\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"EPOLL_WAIT:<%s:%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|epfd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_socket_funcs
operator|.
name|epoll_wait
argument_list|(
name|epfd
argument_list|,
name|events
argument_list|,
name|maxevents
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"EPOLL_WAIT:<%s:%d> return<%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|epfd
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* epoll_wait */
end_comment

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..epoll_pwait -- replacement socket call.                                  */
end_comment

begin_comment
comment|/*    We don't care who generated the event because all we get is user-context    values. */
end_comment

begin_function
name|int
name|epoll_pwait
parameter_list|(
name|int
name|epfd
parameter_list|,
name|struct
name|epoll_event
modifier|*
name|events
parameter_list|,
name|int
name|maxevents
parameter_list|,
name|int
name|timeout
parameter_list|,
specifier|const
name|sigset_t
modifier|*
name|sigmask
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|init_status
operator|==
literal|0
condition|)
name|__sdp_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|_socket_funcs
operator|.
name|epoll_pwait
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Error epoll_pwait: no implementation for epoll_pwait found\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"EPOLL_PWAIT:<%s:%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|epfd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_socket_funcs
operator|.
name|epoll_pwait
argument_list|(
name|epfd
argument_list|,
name|events
argument_list|,
name|maxevents
argument_list|,
name|timeout
argument_list|,
name|sigmask
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|2
argument_list|,
literal|"EPOLL_PWAIT:<%s:%d> return<%d>\n"
argument_list|,
name|program_invocation_short_name
argument_list|,
name|epfd
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* epoll_pwait */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*                                                                       */
end_comment

begin_comment
comment|/* Library load/unload initialization/cleanup                            */
end_comment

begin_comment
comment|/*                                                                       */
end_comment

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..__sdp_init -- intialize the library */
end_comment

begin_function
name|void
name|__sdp_init
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|config_file
decl_stmt|,
modifier|*
name|error_str
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|struct
name|rlimit
name|nofiles_limit
decl_stmt|;
comment|/* HACK: races might apply here: can we assume init is happening 	   only within one thread ? */
if|if
condition|(
name|init_status
operator|!=
literal|0
condition|)
return|return;
name|init_status
operator|=
literal|1
expr_stmt|;
name|dev_null_fd
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_WRONLY
argument_list|)
expr_stmt|;
comment|/* figure out the max number of file descriptors */
if|if
condition|(
name|getrlimit
argument_list|(
name|RLIMIT_NOFILE
argument_list|,
operator|&
name|nofiles_limit
argument_list|)
condition|)
name|max_file_descriptors
operator|=
literal|1024
expr_stmt|;
else|else
name|max_file_descriptors
operator|=
name|nofiles_limit
operator|.
name|rlim_cur
expr_stmt|;
comment|/* allocate and initialize the shadow sdp sockets array */
name|libsdp_fd_attributes
operator|=
operator|(
expr|struct
name|sdp_extra_fd_attributes
operator|*
operator|)
name|calloc
argument_list|(
name|max_file_descriptors
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sdp_extra_fd_attributes
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<
name|max_file_descriptors
condition|;
name|fd
operator|++
control|)
name|init_extra_attribute
argument_list|(
name|fd
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|RTLD_NEXT
comment|/* 	 * open libc for original socket call. 	 * Solaris relies on RTLD next - since the socket calls are 	 * actually in libsocket rather than libc. 	 */
name|__libc_dl_handle
operator|=
name|dlopen
argument_list|(
literal|"/lib64/libc.so.6"
argument_list|,
name|RTLD_LAZY
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|__libc_dl_handle
condition|)
block|{
name|__libc_dl_handle
operator|=
name|dlopen
argument_list|(
literal|"/lib/libc.so.6"
argument_list|,
name|RTLD_LAZY
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|__libc_dl_handle
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|dlerror
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Get the original functions 	 */
name|_socket_funcs
operator|.
name|ioctl
operator|=
name|dlsym
argument_list|(
name|__libc_dl_handle
argument_list|,
literal|"ioctl"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|error_str
operator|=
name|dlerror
argument_list|()
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|error_str
argument_list|)
expr_stmt|;
block|}
name|_socket_funcs
operator|.
name|fcntl
operator|=
name|dlsym
argument_list|(
name|__libc_dl_handle
argument_list|,
literal|"fcntl"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|error_str
operator|=
name|dlerror
argument_list|()
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|error_str
argument_list|)
expr_stmt|;
block|}
name|_socket_funcs
operator|.
name|socket
operator|=
name|dlsym
argument_list|(
name|__libc_dl_handle
argument_list|,
literal|"socket"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|error_str
operator|=
name|dlerror
argument_list|()
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|error_str
argument_list|)
expr_stmt|;
block|}
name|_socket_funcs
operator|.
name|setsockopt
operator|=
name|dlsym
argument_list|(
name|__libc_dl_handle
argument_list|,
literal|"setsockopt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|error_str
operator|=
name|dlerror
argument_list|()
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|error_str
argument_list|)
expr_stmt|;
block|}
name|_socket_funcs
operator|.
name|connect
operator|=
name|dlsym
argument_list|(
name|__libc_dl_handle
argument_list|,
literal|"connect"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|error_str
operator|=
name|dlerror
argument_list|()
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|error_str
argument_list|)
expr_stmt|;
block|}
name|_socket_funcs
operator|.
name|listen
operator|=
name|dlsym
argument_list|(
name|__libc_dl_handle
argument_list|,
literal|"listen"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|error_str
operator|=
name|dlerror
argument_list|()
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|error_str
argument_list|)
expr_stmt|;
block|}
name|_socket_funcs
operator|.
name|bind
operator|=
name|dlsym
argument_list|(
name|__libc_dl_handle
argument_list|,
literal|"bind"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|error_str
operator|=
name|dlerror
argument_list|()
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|error_str
argument_list|)
expr_stmt|;
block|}
name|_socket_funcs
operator|.
name|close
operator|=
name|dlsym
argument_list|(
name|__libc_dl_handle
argument_list|,
literal|"close"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|error_str
operator|=
name|dlerror
argument_list|()
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|error_str
argument_list|)
expr_stmt|;
block|}
name|_socket_funcs
operator|.
name|dup
operator|=
name|dlsym
argument_list|(
name|__libc_dl_handle
argument_list|,
literal|"dup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|error_str
operator|=
name|dlerror
argument_list|()
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|error_str
argument_list|)
expr_stmt|;
block|}
name|_socket_funcs
operator|.
name|dup2
operator|=
name|dlsym
argument_list|(
name|__libc_dl_handle
argument_list|,
literal|"dup2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|error_str
operator|=
name|dlerror
argument_list|()
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|error_str
argument_list|)
expr_stmt|;
block|}
name|_socket_funcs
operator|.
name|getpeername
operator|=
name|dlsym
argument_list|(
name|__libc_dl_handle
argument_list|,
literal|"getpeername"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|error_str
operator|=
name|dlerror
argument_list|()
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|error_str
argument_list|)
expr_stmt|;
block|}
name|_socket_funcs
operator|.
name|getsockname
operator|=
name|dlsym
argument_list|(
name|__libc_dl_handle
argument_list|,
literal|"getsockname"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|error_str
operator|=
name|dlerror
argument_list|()
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|error_str
argument_list|)
expr_stmt|;
block|}
name|_socket_funcs
operator|.
name|accept
operator|=
name|dlsym
argument_list|(
name|__libc_dl_handle
argument_list|,
literal|"accept"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|error_str
operator|=
name|dlerror
argument_list|()
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|error_str
argument_list|)
expr_stmt|;
block|}
name|_socket_funcs
operator|.
name|select
operator|=
name|dlsym
argument_list|(
name|__libc_dl_handle
argument_list|,
literal|"select"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|error_str
operator|=
name|dlerror
argument_list|()
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|error_str
argument_list|)
expr_stmt|;
block|}
name|_socket_funcs
operator|.
name|pselect
operator|=
name|dlsym
argument_list|(
name|__libc_dl_handle
argument_list|,
literal|"pselect"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|error_str
operator|=
name|dlerror
argument_list|()
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|error_str
argument_list|)
expr_stmt|;
block|}
name|_socket_funcs
operator|.
name|poll
operator|=
name|dlsym
argument_list|(
name|__libc_dl_handle
argument_list|,
literal|"poll"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|error_str
operator|=
name|dlerror
argument_list|()
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|error_str
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__linux__
name|_socket_funcs
operator|.
name|epoll_create
operator|=
name|dlsym
argument_list|(
name|__libc_dl_handle
argument_list|,
literal|"epoll_create"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|error_str
operator|=
name|dlerror
argument_list|()
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|error_str
argument_list|)
expr_stmt|;
block|}
name|_socket_funcs
operator|.
name|epoll_ctl
operator|=
name|dlsym
argument_list|(
name|__libc_dl_handle
argument_list|,
literal|"epoll_ctl"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|error_str
operator|=
name|dlerror
argument_list|()
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|error_str
argument_list|)
expr_stmt|;
block|}
name|_socket_funcs
operator|.
name|epoll_wait
operator|=
name|dlsym
argument_list|(
name|__libc_dl_handle
argument_list|,
literal|"epoll_wait"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|error_str
operator|=
name|dlerror
argument_list|()
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|error_str
argument_list|)
expr_stmt|;
block|}
name|_socket_funcs
operator|.
name|epoll_pwait
operator|=
name|dlsym
argument_list|(
name|__libc_dl_handle
argument_list|,
literal|"epoll_pwait"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|error_str
operator|=
name|dlerror
argument_list|()
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|error_str
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SOLARIS_BUILD
name|_socket_xnet_funcs
operator|.
name|socket
operator|=
name|dlsym
argument_list|(
name|__libc_dl_handle
argument_list|,
literal|"__xnet_socket"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|error_str
operator|=
name|dlerror
argument_list|()
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|error_str
argument_list|)
expr_stmt|;
block|}
name|_socket_xnet_funcs
operator|.
name|connect
operator|=
name|dlsym
argument_list|(
name|__libc_dl_handle
argument_list|,
literal|"__xnet_connect"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|error_str
operator|=
name|dlerror
argument_list|()
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|error_str
argument_list|)
expr_stmt|;
block|}
name|_socket_xnet_funcs
operator|.
name|listen
operator|=
name|dlsym
argument_list|(
name|__libc_dl_handle
argument_list|,
literal|"__xnet_listen"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|error_str
operator|=
name|dlerror
argument_list|()
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|error_str
argument_list|)
expr_stmt|;
block|}
name|_socket_xnet_funcs
operator|.
name|bind
operator|=
name|dlsym
argument_list|(
name|__libc_dl_handle
argument_list|,
literal|"__xnet_bind"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|!=
operator|(
name|error_str
operator|=
name|dlerror
argument_list|()
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|error_str
argument_list|)
expr_stmt|;
block|}
comment|/* Determine program name by asking libdl */
name|Dl_argsinfo
name|args_info
decl_stmt|;
if|if
condition|(
name|NULL
operator|!=
name|dlinfo
argument_list|(
name|RTLD_SELF
argument_list|,
name|RTLD_DI_ARGSINFO
argument_list|,
operator|&
name|args_info
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"args_info: %s\n"
argument_list|,
name|dlerror
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|program_invocation_name
operator|=
name|args_info
operator|.
name|dla_argv
index|[
literal|0
index|]
expr_stmt|;
name|program_invocation_short_name
operator|=
name|basename
argument_list|(
name|args_info
operator|.
name|dla_argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|getenv
argument_list|(
literal|"SIMPLE_LIBSDP"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|simple_sdp_library
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|getenv
argument_list|(
literal|"ALWAYS_USE_SDP"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|simple_sdp_library
operator|=
literal|1
expr_stmt|;
block|}
define|#
directive|define
name|LIBSDP_DEFAULT_CONFIG_FILE
value|SYSCONFDIR "/libsdp.conf"
if|if
condition|(
operator|!
name|simple_sdp_library
condition|)
block|{
name|config_file
operator|=
name|getenv
argument_list|(
literal|"LIBSDP_CONFIG_FILE"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|config_file
condition|)
name|config_file
operator|=
name|LIBSDP_DEFAULT_CONFIG_FILE
expr_stmt|;
if|if
condition|(
name|__sdp_parse_config
argument_list|(
name|config_file
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"libsdp Error: failed to parse config file:%s. Using defaults.\n"
argument_list|,
name|config_file
argument_list|)
expr_stmt|;
block|}
block|}
name|__sdp_log
argument_list|(
literal|1
argument_list|,
literal|"Max file descriptors:%d\n"
argument_list|,
name|max_file_descriptors
argument_list|)
expr_stmt|;
name|init_status
operator|=
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* __sdp_init */
end_comment

begin_comment
comment|/* ========================================================================= */
end_comment

begin_comment
comment|/*..__sdp_fini -- when the library is unloaded this is called */
end_comment

begin_function
name|void
name|__sdp_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|use_family_rule
modifier|*
name|rule
decl_stmt|;
for|for
control|(
name|rule
operator|=
name|__sdp_clients_family_rules_head
init|;
name|rule
operator|!=
name|NULL
condition|;
name|rule
operator|=
name|rule
operator|->
name|next
control|)
name|free
argument_list|(
name|rule
operator|->
name|prog_name_expr
argument_list|)
expr_stmt|;
for|for
control|(
name|rule
operator|=
name|__sdp_servers_family_rules_head
init|;
name|rule
operator|!=
name|NULL
condition|;
name|rule
operator|=
name|rule
operator|->
name|next
control|)
name|free
argument_list|(
name|rule
operator|->
name|prog_name_expr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|libsdp_fd_attributes
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|RTLD_NEXT
name|dlclose
argument_list|(
name|__libc_dl_handle
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* _fini */
end_comment

end_unit

