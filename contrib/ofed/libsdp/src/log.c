begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   This software is available to you under a choice of one of two   licenses.  You may choose to be licensed under the terms of the GNU   General Public License (GPL) Version 2, available at<http://www.fsf.org/copyleft/gpl.html>, or the OpenIB.org BSD   license, available in the LICENSE.TXT file accompanying this   software.  These details are also available at<http://openib.org/license.html>.    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   SOFTWARE.    Copyright (c) 2004 Topspin Communications.  All rights reserved.   Copyright (c) 2006 Mellanox Technologies Ltd. All rights reserved.    $Id$ */
end_comment

begin_comment
comment|/*  * system includes  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_comment
comment|/*  * SDP specific includes  */
end_comment

begin_include
include|#
directive|include
file|"libsdp.h"
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|program_invocation_short_name
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
enum|enum
block|{
name|SDP_LOG_FILE
block|,
name|SDP_LOG_SYSLOG
block|, }
name|__sdp_log_type_t
typedef|;
end_typedef

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* library static and global variables                                   */
end_comment

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_decl_stmt
name|int
name|__sdp_min_level
init|=
literal|9
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__sdp_log_type_t
name|__sdp_log_type
init|=
name|SDP_LOG_FILE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|__sdp_log_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|__sdp_log
parameter_list|(
name|int
name|level
parameter_list|,
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|char
name|extra_format
index|[
literal|512
index|]
decl_stmt|;
name|time_t
name|timeval
decl_stmt|;
name|char
name|timestr
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
name|level
operator|<
name|__sdp_min_level
condition|)
block|{
return|return;
block|}
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|__sdp_log_type
condition|)
block|{
case|case
name|SDP_LOG_SYSLOG
case|:
name|sprintf
argument_list|(
name|extra_format
argument_list|,
literal|"%s[%d] libsdp %s "
argument_list|,
name|program_invocation_short_name
argument_list|,
name|getpid
argument_list|(  )
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vsyslog
argument_list|(
name|LOG_USER
operator||
name|LOG_NOTICE
argument_list|,
name|extra_format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|SDP_LOG_FILE
case|:
name|timeval
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOLARIS_BUILD
name|ctime_r
argument_list|(
operator|&
name|timeval
argument_list|,
name|timestr
argument_list|,
sizeof|sizeof
name|timestr
argument_list|)
expr_stmt|;
else|#
directive|else
name|ctime_r
argument_list|(
operator|&
name|timeval
argument_list|,
name|timestr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|timestr
index|[
name|strlen
argument_list|(
name|timestr
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sprintf
argument_list|(
name|extra_format
argument_list|,
literal|"%s %s[%d] libsdp %s "
argument_list|,
name|timestr
argument_list|,
name|program_invocation_short_name
argument_list|,
name|getpid
argument_list|(  )
argument_list|,
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|__sdp_log_file
operator|==
name|NULL
condition|)
block|{
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|extra_format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* might slow everything too much? */
block|( void )fflush( stderr );
endif|#
directive|endif
block|}
else|else
block|{
name|vfprintf
argument_list|(
name|__sdp_log_file
argument_list|,
name|extra_format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* might slow everything too much? */
block|( void )fflush( __sdp_log_file );
endif|#
directive|endif
block|}
break|break;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|__sdp_log_get_level
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|__sdp_min_level
operator|)
return|;
block|}
end_function

begin_function
name|void
name|__sdp_log_set_min_level
parameter_list|(
name|int
name|level
parameter_list|)
block|{
name|__sdp_min_level
operator|=
name|level
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__sdp_log_set_log_type
parameter_list|(
name|__sdp_log_type_t
name|type
parameter_list|)
block|{
if|if
condition|(
name|__sdp_log_file
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|__sdp_log_file
argument_list|)
expr_stmt|;
name|__sdp_log_file
operator|=
name|NULL
expr_stmt|;
block|}
name|__sdp_log_type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_function
name|int
name|__sdp_log_set_log_stderr
parameter_list|(
name|void
parameter_list|)
block|{
name|__sdp_log_set_log_type
argument_list|(
name|SDP_LOG_FILE
argument_list|)
expr_stmt|;
comment|/* NULL means stderr */
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|__sdp_log_set_log_syslog
parameter_list|(
name|void
parameter_list|)
block|{
name|__sdp_log_set_log_type
argument_list|(
name|SDP_LOG_SYSLOG
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|__sdp_log_set_log_file
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|struct
name|stat
name|lstat_res
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
name|tfilename
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Strip off any paths from the filename */
name|p
operator|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/*  		base on the active user ID we either use /var/log for root or 		append the uid to the name 	*/
name|uid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
if|if
condition|(
name|uid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p
condition|)
name|filename
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|tfilename
argument_list|,
sizeof|sizeof
argument_list|(
name|tfilename
argument_list|)
argument_list|,
literal|"/var/log/%s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|tdir
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/*  			for regular user, allow log file to be placed in a user 			requested path. If no path is requested the log file is 			placed in /tmp/ 		*/
if|if
condition|(
name|p
condition|)
name|snprintf
argument_list|(
name|tdir
argument_list|,
sizeof|sizeof
argument_list|(
name|tdir
argument_list|)
argument_list|,
literal|"%s.%d"
argument_list|,
name|filename
argument_list|,
name|uid
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|tdir
argument_list|,
sizeof|sizeof
argument_list|(
name|tdir
argument_list|)
argument_list|,
literal|"/tmp/%s.%d"
argument_list|,
name|filename
argument_list|,
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|tdir
argument_list|,
literal|0700
argument_list|)
condition|)
block|{
name|struct
name|stat
name|stat
decl_stmt|;
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Couldn't create directory '%s' for logging (%m)\n"
argument_list|,
name|tdir
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|lstat
argument_list|(
name|tdir
argument_list|,
operator|&
name|stat
argument_list|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Couldn't lstat directory %s\n"
argument_list|,
name|tdir
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|stat
operator|.
name|st_mode
argument_list|)
operator|||
name|stat
operator|.
name|st_uid
operator|!=
name|uid
operator|||
operator|(
name|stat
operator|.
name|st_mode
operator|&
operator|~
operator|(
name|S_IFMT
operator||
name|S_IRWXU
operator|)
operator|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Cowardly refusing to log into directory:'%s'. "
literal|"Make sure it is not: (1) link, (2) other uid, (3) bad permissions."
literal|"thus is a security issue.\n"
argument_list|,
name|tdir
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|snprintf
argument_list|(
name|tfilename
argument_list|,
sizeof|sizeof
argument_list|(
name|tfilename
argument_list|)
argument_list|,
literal|"%s/log"
argument_list|,
name|tdir
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dir: %s file: %s\n"
argument_list|,
name|tdir
argument_list|,
name|tfilename
argument_list|)
expr_stmt|;
block|}
comment|/* double check the file is not a link */
name|status
operator|=
name|lstat
argument_list|(
name|tfilename
argument_list|,
operator|&
name|lstat_res
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|==
literal|0
operator|)
operator|&&
name|S_ISLNK
argument_list|(
name|lstat_res
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Cowardly refusing to log into:'%s'. "
literal|"It is a link - thus is a security issue.\n"
argument_list|,
name|tfilename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|f
operator|=
name|fopen
argument_list|(
name|tfilename
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|__sdp_log
argument_list|(
literal|9
argument_list|,
literal|"Couldn't open '%s' for logging (%m)\n"
argument_list|,
name|tfilename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|__sdp_log_set_log_type
argument_list|(
name|SDP_LOG_FILE
argument_list|)
expr_stmt|;
name|__sdp_log_file
operator|=
name|f
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

