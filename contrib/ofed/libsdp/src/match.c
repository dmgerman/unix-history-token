begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   This software is available to you under a choice of one of two   licenses.  You may choose to be licensed under the terms of the GNU   General Public License (GPL) Version 2, available at<http://www.fsf.org/copyleft/gpl.html>, or the OpenIB.org BSD   license, available in the LICENSE.TXT file accompanying this   software.  These details are also available at<http://openib.org/license.html>.    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   SOFTWARE.    Copyright (c) 2004 Topspin Communications.  All rights reserved.   Copyright (c) 2005-2006 Mellanox Technologies Ltd.  All rights reserved.    $Id$ */
end_comment

begin_comment
comment|/*  * system includes  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<fnmatch.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_comment
comment|/*  * SDP specific includes  */
end_comment

begin_include
include|#
directive|include
file|"libsdp.h"
end_include

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* library static and global variables                                   */
end_comment

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|program_invocation_name
decl_stmt|,
modifier|*
name|program_invocation_short_name
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|get_rule_str
parameter_list|(
name|struct
name|use_family_rule
modifier|*
name|rule
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
name|addr_buf
index|[
name|MAX_ADDR_STR_LEN
index|]
decl_stmt|;
name|char
name|ports_buf
index|[
literal|16
index|]
decl_stmt|;
name|char
modifier|*
name|target
init|=
name|__sdp_get_family_str
argument_list|(
name|rule
operator|->
name|target_family
argument_list|)
decl_stmt|;
name|char
modifier|*
name|prog
init|=
name|rule
operator|->
name|prog_name_expr
decl_stmt|;
comment|/* TODO: handle IPv6 in rule */
if|if
condition|(
name|rule
operator|->
name|match_by_addr
condition|)
block|{
if|if
condition|(
name|rule
operator|->
name|prefixlen
operator|!=
literal|32
condition|)
name|sprintf
argument_list|(
name|addr_buf
argument_list|,
literal|"%s/%d"
argument_list|,
name|inet_ntoa
argument_list|(
name|rule
operator|->
name|ipv4
argument_list|)
argument_list|,
name|rule
operator|->
name|prefixlen
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|addr_buf
argument_list|,
literal|"%s"
argument_list|,
name|inet_ntoa
argument_list|(
name|rule
operator|->
name|ipv4
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|addr_buf
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rule
operator|->
name|match_by_port
condition|)
if|if
condition|(
name|rule
operator|->
name|eport
operator|>
name|rule
operator|->
name|sport
condition|)
name|sprintf
argument_list|(
name|ports_buf
argument_list|,
literal|"%d"
argument_list|,
name|rule
operator|->
name|sport
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|ports_buf
argument_list|,
literal|"%d-%d"
argument_list|,
name|rule
operator|->
name|sport
argument_list|,
name|rule
operator|->
name|eport
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|ports_buf
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"use %s %s %s:%s"
argument_list|,
name|target
argument_list|,
name|prog
argument_list|,
name|addr_buf
argument_list|,
name|ports_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* return 0 if the addresses match */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|match_ipv4_addr
parameter_list|(
name|struct
name|use_family_rule
modifier|*
name|rule
parameter_list|,
specifier|const
name|struct
name|sockaddr_in
modifier|*
name|sin
parameter_list|)
block|{
return|return
operator|(
name|rule
operator|->
name|ipv4
operator|.
name|s_addr
operator|!=
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|&
name|htonl
argument_list|(
name|SDP_NETMASK
argument_list|(
name|rule
operator|->
name|prefixlen
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|match_ip_addr_and_port
parameter_list|(
name|struct
name|use_family_rule
modifier|*
name|rule
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|addr_in
parameter_list|,
specifier|const
name|socklen_t
name|addrlen
parameter_list|)
block|{
specifier|const
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
specifier|const
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr_in
decl_stmt|;
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|sin6
init|=
operator|(
specifier|const
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr_in
decl_stmt|;
name|struct
name|sockaddr_in
name|tmp_sin
decl_stmt|;
name|unsigned
name|short
name|port
decl_stmt|;
name|int
name|match
init|=
literal|1
decl_stmt|;
name|char
name|addr_buf
index|[
name|MAX_ADDR_STR_LEN
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|addr_str
decl_stmt|;
name|char
name|rule_str
index|[
literal|512
index|]
decl_stmt|;
if|if
condition|(
name|__sdp_log_get_level
argument_list|(  )
operator|<=
literal|3
condition|)
block|{
if|if
condition|(
name|sin6
operator|->
name|sin6_family
operator|==
name|AF_INET6
condition|)
block|{
name|addr_str
operator|=
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|sin6
operator|->
name|sin6_addr
operator|)
argument_list|,
name|addr_buf
argument_list|,
name|MAX_ADDR_STR_LEN
argument_list|)
expr_stmt|;
name|port
operator|=
name|ntohs
argument_list|(
name|sin6
operator|->
name|sin6_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr_str
operator|=
name|inet_ntop
argument_list|(
name|AF_INET
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|sin
operator|->
name|sin_addr
operator|)
argument_list|,
name|addr_buf
argument_list|,
name|MAX_ADDR_STR_LEN
argument_list|)
expr_stmt|;
name|port
operator|=
name|ntohs
argument_list|(
name|sin
operator|->
name|sin_port
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addr_str
operator|==
name|NULL
condition|)
name|addr_str
operator|=
literal|"INVALID_ADDR"
expr_stmt|;
name|get_rule_str
argument_list|(
name|rule
argument_list|,
name|rule_str
argument_list|,
sizeof|sizeof
argument_list|(
name|rule_str
argument_list|)
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|3
argument_list|,
literal|"MATCH: matching %s:%d to %s => \n"
argument_list|,
name|addr_str
argument_list|,
name|port
argument_list|,
name|rule_str
argument_list|)
expr_stmt|;
block|}
comment|/* We currently only support IPv4 and IPv4 embedded in IPv6 */
if|if
condition|(
name|rule
operator|->
name|match_by_port
condition|)
block|{
if|if
condition|(
name|sin6
operator|->
name|sin6_family
operator|==
name|AF_INET6
condition|)
name|port
operator|=
name|ntohs
argument_list|(
name|sin6
operator|->
name|sin6_port
argument_list|)
expr_stmt|;
else|else
name|port
operator|=
name|ntohs
argument_list|(
name|sin
operator|->
name|sin_port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|port
operator|<
name|rule
operator|->
name|sport
operator|)
operator|||
operator|(
name|port
operator|>
name|rule
operator|->
name|eport
operator|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|3
argument_list|,
literal|"NEGATIVE by port range\n"
argument_list|)
expr_stmt|;
name|match
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|match
operator|&&
name|rule
operator|->
name|match_by_addr
condition|)
block|{
if|if
condition|(
name|__sdp_sockaddr_to_sdp
argument_list|(
name|addr_in
argument_list|,
name|addrlen
argument_list|,
operator|&
name|tmp_sin
argument_list|,
name|NULL
argument_list|)
operator|||
name|match_ipv4_addr
argument_list|(
name|rule
argument_list|,
operator|&
name|tmp_sin
argument_list|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|3
argument_list|,
literal|"NEGATIVE by address\n"
argument_list|)
expr_stmt|;
name|match
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|match
condition|)
name|__sdp_log
argument_list|(
literal|3
argument_list|,
literal|"POSITIVE\n"
argument_list|)
expr_stmt|;
return|return
name|match
return|;
block|}
end_function

begin_comment
comment|/* return 1 on match */
end_comment

begin_function
specifier|static
name|int
name|match_program_name
parameter_list|(
name|struct
name|use_family_rule
modifier|*
name|rule
parameter_list|)
block|{
return|return
operator|!
name|fnmatch
argument_list|(
name|rule
operator|->
name|prog_name_expr
argument_list|,
name|program_invocation_short_name
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|use_family_t
name|get_family_by_first_matching_rule
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|sin
parameter_list|,
specifier|const
name|socklen_t
name|addrlen
parameter_list|,
name|struct
name|use_family_rule
modifier|*
name|rules
parameter_list|)
block|{
name|struct
name|use_family_rule
modifier|*
name|rule
decl_stmt|;
for|for
control|(
name|rule
operator|=
name|rules
init|;
name|rule
operator|!=
name|NULL
condition|;
name|rule
operator|=
name|rule
operator|->
name|next
control|)
block|{
comment|/* skip if not our program */
if|if
condition|(
operator|!
name|match_program_name
argument_list|(
name|rule
argument_list|)
condition|)
continue|continue;
comment|/* first rule wins */
if|if
condition|(
name|match_ip_addr_and_port
argument_list|(
name|rule
argument_list|,
name|sin
argument_list|,
name|addrlen
argument_list|)
condition|)
return|return
operator|(
name|rule
operator|->
name|target_family
operator|)
return|;
block|}
return|return
operator|(
name|USE_BOTH
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return the result of the first matching rule found */
end_comment

begin_function
name|use_family_t
name|__sdp_match_listen
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|sin
parameter_list|,
specifier|const
name|socklen_t
name|addrlen
parameter_list|)
block|{
name|use_family_t
name|target_family
decl_stmt|;
comment|/* if we do not have any rules we use sdp */
if|if
condition|(
name|__sdp_config_empty
argument_list|(  )
condition|)
name|target_family
operator|=
name|USE_SDP
expr_stmt|;
else|else
name|target_family
operator|=
name|get_family_by_first_matching_rule
argument_list|(
name|sin
argument_list|,
name|addrlen
argument_list|,
name|__sdp_servers_family_rules_head
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|4
argument_list|,
literal|"MATCH LISTEN: => %s\n"
argument_list|,
name|__sdp_get_family_str
argument_list|(
name|target_family
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|target_family
operator|)
return|;
block|}
end_function

begin_function
name|use_family_t
name|__sdp_match_connect
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|sin
parameter_list|,
specifier|const
name|socklen_t
name|addrlen
parameter_list|)
block|{
name|use_family_t
name|target_family
decl_stmt|;
comment|/* if we do not have any rules we use sdp */
if|if
condition|(
name|__sdp_config_empty
argument_list|(  )
condition|)
name|target_family
operator|=
name|USE_SDP
expr_stmt|;
else|else
name|target_family
operator|=
name|get_family_by_first_matching_rule
argument_list|(
name|sin
argument_list|,
name|addrlen
argument_list|,
name|__sdp_clients_family_rules_head
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|4
argument_list|,
literal|"MATCH CONNECT: => %s\n"
argument_list|,
name|__sdp_get_family_str
argument_list|(
name|target_family
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|target_family
operator|)
return|;
block|}
end_function

begin_comment
comment|/* given a set of rules see if there is a global match for current program */
end_comment

begin_function
specifier|static
name|use_family_t
name|match_by_all_rules_program
parameter_list|(
name|struct
name|use_family_rule
modifier|*
name|rules
parameter_list|)
block|{
name|int
name|any_sdp
init|=
literal|0
decl_stmt|;
name|int
name|any_tcp
init|=
literal|0
decl_stmt|;
name|use_family_t
name|target_family
init|=
name|USE_BOTH
decl_stmt|;
name|struct
name|use_family_rule
modifier|*
name|rule
decl_stmt|;
for|for
control|(
name|rule
operator|=
name|rules
init|;
operator|(
name|rule
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|target_family
operator|==
name|USE_BOTH
operator|)
condition|;
name|rule
operator|=
name|rule
operator|->
name|next
control|)
block|{
comment|/* skip if not our program */
if|if
condition|(
operator|!
name|match_program_name
argument_list|(
name|rule
argument_list|)
condition|)
continue|continue;
comment|/* 		 * to declare a dont care we either have a dont care address and port   		 * or the previous non global rules use the same target family as the 		 * global rule 		 */
if|if
condition|(
name|rule
operator|->
name|match_by_addr
operator|||
name|rule
operator|->
name|match_by_port
condition|)
block|{
comment|/* not a glocal match rule - just track the target family */
if|if
condition|(
name|rule
operator|->
name|target_family
operator|==
name|USE_SDP
condition|)
name|any_sdp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|rule
operator|->
name|target_family
operator|==
name|USE_TCP
condition|)
name|any_tcp
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* a global match so we can declare a match by program */
if|if
condition|(
operator|(
name|rule
operator|->
name|target_family
operator|==
name|USE_SDP
operator|)
operator|&&
operator|(
name|any_tcp
operator|==
literal|0
operator|)
condition|)
name|target_family
operator|=
name|USE_SDP
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rule
operator|->
name|target_family
operator|==
name|USE_TCP
operator|)
operator|&&
operator|(
name|any_sdp
operator|==
literal|0
operator|)
condition|)
name|target_family
operator|=
name|USE_TCP
expr_stmt|;
block|}
block|}
return|return
operator|(
name|target_family
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return tcp or sdp if the port and role are dont cares */
end_comment

begin_function
name|use_family_t
name|__sdp_match_by_program
parameter_list|( 	 )
block|{
name|use_family_t
name|server_target_family
decl_stmt|;
name|use_family_t
name|client_target_family
decl_stmt|;
name|use_family_t
name|target_family
init|=
name|USE_BOTH
decl_stmt|;
if|if
condition|(
name|__sdp_config_empty
argument_list|(  )
condition|)
block|{
name|target_family
operator|=
name|USE_SDP
expr_stmt|;
block|}
else|else
block|{
comment|/* need to try both server and client rules */
name|server_target_family
operator|=
name|match_by_all_rules_program
argument_list|(
name|__sdp_servers_family_rules_head
argument_list|)
expr_stmt|;
name|client_target_family
operator|=
name|match_by_all_rules_program
argument_list|(
name|__sdp_clients_family_rules_head
argument_list|)
expr_stmt|;
comment|/* only if both agree */
if|if
condition|(
name|server_target_family
operator|==
name|client_target_family
condition|)
name|target_family
operator|=
name|server_target_family
expr_stmt|;
block|}
name|__sdp_log
argument_list|(
literal|4
argument_list|,
literal|"MATCH PROGRAM: => %s\n"
argument_list|,
name|__sdp_get_family_str
argument_list|(
name|target_family
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|target_family
operator|)
return|;
block|}
end_function

end_unit

