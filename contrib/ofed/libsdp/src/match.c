begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   This software is available to you under a choice of one of two   licenses.  You may choose to be licensed under the terms of the GNU   General Public License (GPL) Version 2, available at<http://www.fsf.org/copyleft/gpl.html>, or the OpenIB.org BSD   license, available in the LICENSE.TXT file accompanying this   software.  These details are also available at<http://openib.org/license.html>.    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   SOFTWARE.    Copyright (c) 2004 Topspin Communications.  All rights reserved.   Copyright (c) 2005-2006 Mellanox Technologies Ltd.  All rights reserved.    $Id$ */
end_comment

begin_comment
comment|/*  * system includes  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<fnmatch.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_include
include|#
directive|include
file|<linux/types.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|s6_addr32
value|__u6_addr.__u6_addr32
end_define

begin_define
define|#
directive|define
name|__be32
value|uint32_t
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * SDP specific includes  */
end_comment

begin_include
include|#
directive|include
file|"libsdp.h"
end_include

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* library static and global variables                                   */
end_comment

begin_comment
comment|/* --------------------------------------------------------------------- */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|program_invocation_name
decl_stmt|,
modifier|*
name|program_invocation_short_name
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|get_rule_str
parameter_list|(
name|struct
name|use_family_rule
modifier|*
name|rule
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
name|addr_buf
index|[
name|MAX_ADDR_STR_LEN
index|]
decl_stmt|;
name|char
name|ports_buf
index|[
literal|16
index|]
decl_stmt|;
name|char
modifier|*
name|target
init|=
name|__sdp_get_family_str
argument_list|(
name|rule
operator|->
name|target_family
argument_list|)
decl_stmt|;
name|char
modifier|*
name|prog
init|=
name|rule
operator|->
name|prog_name_expr
decl_stmt|;
comment|/* TODO: handle IPv6 in rule */
if|if
condition|(
name|rule
operator|->
name|match_by_addr
condition|)
block|{
name|char
name|tmp
index|[
name|INET6_ADDRSTRLEN
index|]
init|=
literal|"BAD ADDRESS"
decl_stmt|;
if|if
condition|(
name|rule
operator|->
name|ip
operator|.
name|ss_family
operator|==
name|AF_INET
condition|)
name|inet_ntop
argument_list|(
name|AF_INET
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|rule
operator|->
name|ip
operator|)
operator|->
name|sin_addr
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rule
operator|->
name|ip
operator|.
name|ss_family
operator|==
name|AF_INET6
condition|)
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|rule
operator|->
name|ip
operator|)
operator|->
name|sin6_addr
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|addr_buf
argument_list|,
literal|"%s/%d"
argument_list|,
name|tmp
argument_list|,
name|rule
operator|->
name|prefixlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|addr_buf
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rule
operator|->
name|match_by_port
condition|)
if|if
condition|(
name|rule
operator|->
name|eport
operator|>
name|rule
operator|->
name|sport
condition|)
name|sprintf
argument_list|(
name|ports_buf
argument_list|,
literal|"%d"
argument_list|,
name|rule
operator|->
name|sport
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|ports_buf
argument_list|,
literal|"%d-%d"
argument_list|,
name|rule
operator|->
name|sport
argument_list|,
name|rule
operator|->
name|eport
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|ports_buf
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"use %s %s %s:%s"
argument_list|,
name|target
argument_list|,
name|prog
argument_list|,
name|addr_buf
argument_list|,
name|ports_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|__ipv6_prefix_equal
parameter_list|(
specifier|const
name|__be32
modifier|*
name|a1
parameter_list|,
specifier|const
name|__be32
modifier|*
name|a2
parameter_list|,
name|unsigned
name|int
name|prefixlen
parameter_list|)
block|{
name|unsigned
name|pdw
decl_stmt|,
name|pbi
decl_stmt|;
comment|/* check complete u32 in prefix */
name|pdw
operator|=
name|prefixlen
operator|>>
literal|5
expr_stmt|;
if|if
condition|(
name|pdw
operator|&&
name|memcmp
argument_list|(
name|a1
argument_list|,
name|a2
argument_list|,
name|pdw
operator|<<
literal|2
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* check incomplete u32 in prefix */
name|pbi
operator|=
name|prefixlen
operator|&
literal|0x1f
expr_stmt|;
if|if
condition|(
name|pbi
operator|&&
operator|(
operator|(
name|a1
index|[
name|pdw
index|]
operator|^
name|a2
index|[
name|pdw
index|]
operator|)
operator|&
name|htonl
argument_list|(
operator|(
literal|0xffffffff
operator|)
operator|<<
operator|(
literal|32
operator|-
name|pbi
operator|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ipv6_prefix_equal
parameter_list|(
specifier|const
name|struct
name|in6_addr
modifier|*
name|a1
parameter_list|,
specifier|const
name|struct
name|in6_addr
modifier|*
name|a2
parameter_list|,
name|unsigned
name|int
name|prefixlen
parameter_list|)
block|{
return|return
name|__ipv6_prefix_equal
argument_list|(
name|a1
operator|->
name|s6_addr32
argument_list|,
name|a2
operator|->
name|s6_addr32
argument_list|,
name|prefixlen
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* return 0 if the addresses match */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|match_addr
parameter_list|(
name|struct
name|use_family_rule
modifier|*
name|rule
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|addr_in
parameter_list|)
block|{
specifier|const
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
specifier|const
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr_in
decl_stmt|;
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|sin6
init|=
operator|(
specifier|const
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr_in
decl_stmt|;
specifier|const
name|struct
name|sockaddr_in
modifier|*
name|rule_sin
init|=
operator|(
specifier|const
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
operator|&
name|rule
operator|->
name|ip
operator|)
decl_stmt|;
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|rule_sin6
init|=
operator|(
specifier|const
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
operator|&
name|rule
operator|->
name|ip
operator|)
decl_stmt|;
if|if
condition|(
name|rule_sin
operator|->
name|sin_family
operator|==
name|AF_INET
operator|&&
operator|!
name|rule_sin
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|addr_in
operator|->
name|sa_family
operator|!=
name|rule
operator|->
name|ip
operator|.
name|ss_family
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|addr_in
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
return|return
operator|(
name|rule_sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|!=
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|&
name|htonl
argument_list|(
name|SDP_NETMASK
argument_list|(
name|rule
operator|->
name|prefixlen
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
comment|/* IPv6 */
return|return
operator|!
name|ipv6_prefix_equal
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
operator|&
name|rule_sin6
operator|->
name|sin6_addr
argument_list|,
name|rule
operator|->
name|prefixlen
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|match_ip_addr_and_port
parameter_list|(
name|struct
name|use_family_rule
modifier|*
name|rule
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|addr_in
parameter_list|,
specifier|const
name|socklen_t
name|addrlen
parameter_list|)
block|{
specifier|const
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
specifier|const
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr_in
decl_stmt|;
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|sin6
init|=
operator|(
specifier|const
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr_in
decl_stmt|;
name|unsigned
name|short
name|port
decl_stmt|;
name|int
name|match
init|=
literal|1
decl_stmt|;
name|char
name|addr_buf
index|[
name|MAX_ADDR_STR_LEN
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|addr_str
decl_stmt|;
name|char
name|rule_str
index|[
literal|512
index|]
decl_stmt|;
if|if
condition|(
name|__sdp_log_get_level
argument_list|(  )
operator|<=
literal|3
condition|)
block|{
if|if
condition|(
name|sin6
operator|->
name|sin6_family
operator|==
name|AF_INET6
condition|)
block|{
name|addr_str
operator|=
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|sin6
operator|->
name|sin6_addr
operator|)
argument_list|,
name|addr_buf
argument_list|,
name|MAX_ADDR_STR_LEN
argument_list|)
expr_stmt|;
name|port
operator|=
name|ntohs
argument_list|(
name|sin6
operator|->
name|sin6_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr_str
operator|=
name|inet_ntop
argument_list|(
name|AF_INET
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|sin
operator|->
name|sin_addr
operator|)
argument_list|,
name|addr_buf
argument_list|,
name|MAX_ADDR_STR_LEN
argument_list|)
expr_stmt|;
name|port
operator|=
name|ntohs
argument_list|(
name|sin
operator|->
name|sin_port
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|addr_str
operator|==
name|NULL
condition|)
name|addr_str
operator|=
literal|"INVALID_ADDR"
expr_stmt|;
name|get_rule_str
argument_list|(
name|rule
argument_list|,
name|rule_str
argument_list|,
sizeof|sizeof
argument_list|(
name|rule_str
argument_list|)
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|3
argument_list|,
literal|"MATCH: matching %s:%d to %s => \n"
argument_list|,
name|addr_str
argument_list|,
name|port
argument_list|,
name|rule_str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rule
operator|->
name|match_by_port
condition|)
block|{
name|port
operator|=
name|ntohs
argument_list|(
name|sin
operator|->
name|sin_port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|port
operator|<
name|rule
operator|->
name|sport
operator|)
operator|||
operator|(
name|port
operator|>
name|rule
operator|->
name|eport
operator|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|3
argument_list|,
literal|"NEGATIVE by port range\n"
argument_list|)
expr_stmt|;
name|match
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|match
operator|&&
name|rule
operator|->
name|match_by_addr
condition|)
block|{
if|if
condition|(
name|match_addr
argument_list|(
name|rule
argument_list|,
name|addr_in
argument_list|)
condition|)
block|{
name|__sdp_log
argument_list|(
literal|3
argument_list|,
literal|"NEGATIVE by address\n"
argument_list|)
expr_stmt|;
name|match
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|match
condition|)
name|__sdp_log
argument_list|(
literal|3
argument_list|,
literal|"POSITIVE\n"
argument_list|)
expr_stmt|;
return|return
name|match
return|;
block|}
end_function

begin_comment
comment|/* return 1 on match */
end_comment

begin_function
specifier|static
name|int
name|match_program_name
parameter_list|(
name|struct
name|use_family_rule
modifier|*
name|rule
parameter_list|)
block|{
return|return
operator|!
name|fnmatch
argument_list|(
name|rule
operator|->
name|prog_name_expr
argument_list|,
name|program_invocation_short_name
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|use_family_t
name|get_family_by_first_matching_rule
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|sin
parameter_list|,
specifier|const
name|socklen_t
name|addrlen
parameter_list|,
name|struct
name|use_family_rule
modifier|*
name|rules
parameter_list|)
block|{
name|struct
name|use_family_rule
modifier|*
name|rule
decl_stmt|;
for|for
control|(
name|rule
operator|=
name|rules
init|;
name|rule
operator|!=
name|NULL
condition|;
name|rule
operator|=
name|rule
operator|->
name|next
control|)
block|{
comment|/* skip if not our program */
if|if
condition|(
operator|!
name|match_program_name
argument_list|(
name|rule
argument_list|)
condition|)
continue|continue;
comment|/* first rule wins */
if|if
condition|(
name|match_ip_addr_and_port
argument_list|(
name|rule
argument_list|,
name|sin
argument_list|,
name|addrlen
argument_list|)
condition|)
return|return
operator|(
name|rule
operator|->
name|target_family
operator|)
return|;
block|}
return|return
operator|(
name|USE_BOTH
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return the result of the first matching rule found */
end_comment

begin_function
name|use_family_t
name|__sdp_match_listen
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|sin
parameter_list|,
specifier|const
name|socklen_t
name|addrlen
parameter_list|)
block|{
name|use_family_t
name|target_family
decl_stmt|;
comment|/* if we do not have any rules we use sdp */
if|if
condition|(
name|__sdp_config_empty
argument_list|(  )
condition|)
name|target_family
operator|=
name|USE_SDP
expr_stmt|;
else|else
name|target_family
operator|=
name|get_family_by_first_matching_rule
argument_list|(
name|sin
argument_list|,
name|addrlen
argument_list|,
name|__sdp_servers_family_rules_head
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|4
argument_list|,
literal|"MATCH LISTEN: => %s\n"
argument_list|,
name|__sdp_get_family_str
argument_list|(
name|target_family
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|target_family
operator|)
return|;
block|}
end_function

begin_function
name|use_family_t
name|__sdp_match_connect
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|sin
parameter_list|,
specifier|const
name|socklen_t
name|addrlen
parameter_list|)
block|{
name|use_family_t
name|target_family
decl_stmt|;
comment|/* if we do not have any rules we use sdp */
if|if
condition|(
name|__sdp_config_empty
argument_list|(  )
condition|)
name|target_family
operator|=
name|USE_SDP
expr_stmt|;
else|else
name|target_family
operator|=
name|get_family_by_first_matching_rule
argument_list|(
name|sin
argument_list|,
name|addrlen
argument_list|,
name|__sdp_clients_family_rules_head
argument_list|)
expr_stmt|;
name|__sdp_log
argument_list|(
literal|4
argument_list|,
literal|"MATCH CONNECT: => %s\n"
argument_list|,
name|__sdp_get_family_str
argument_list|(
name|target_family
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|target_family
operator|)
return|;
block|}
end_function

begin_comment
comment|/* given a set of rules see if there is a global match for current program */
end_comment

begin_function
specifier|static
name|use_family_t
name|match_by_all_rules_program
parameter_list|(
name|struct
name|use_family_rule
modifier|*
name|rules
parameter_list|)
block|{
name|int
name|any_sdp
init|=
literal|0
decl_stmt|;
name|int
name|any_tcp
init|=
literal|0
decl_stmt|;
name|use_family_t
name|target_family
init|=
name|USE_BOTH
decl_stmt|;
name|struct
name|use_family_rule
modifier|*
name|rule
decl_stmt|;
for|for
control|(
name|rule
operator|=
name|rules
init|;
operator|(
name|rule
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|target_family
operator|==
name|USE_BOTH
operator|)
condition|;
name|rule
operator|=
name|rule
operator|->
name|next
control|)
block|{
comment|/* skip if not our program */
if|if
condition|(
operator|!
name|match_program_name
argument_list|(
name|rule
argument_list|)
condition|)
continue|continue;
comment|/* 		 * to declare a dont care we either have a dont care address and port   		 * or the previous non global rules use the same target family as the 		 * global rule 		 */
if|if
condition|(
name|rule
operator|->
name|match_by_addr
operator|||
name|rule
operator|->
name|match_by_port
condition|)
block|{
comment|/* not a glocal match rule - just track the target family */
if|if
condition|(
name|rule
operator|->
name|target_family
operator|==
name|USE_SDP
condition|)
name|any_sdp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|rule
operator|->
name|target_family
operator|==
name|USE_TCP
condition|)
name|any_tcp
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* a global match so we can declare a match by program */
if|if
condition|(
operator|(
name|rule
operator|->
name|target_family
operator|==
name|USE_SDP
operator|)
operator|&&
operator|(
name|any_tcp
operator|==
literal|0
operator|)
condition|)
name|target_family
operator|=
name|USE_SDP
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|rule
operator|->
name|target_family
operator|==
name|USE_TCP
operator|)
operator|&&
operator|(
name|any_sdp
operator|==
literal|0
operator|)
condition|)
name|target_family
operator|=
name|USE_TCP
expr_stmt|;
block|}
block|}
return|return
operator|(
name|target_family
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return tcp or sdp if the port and role are dont cares */
end_comment

begin_function
name|use_family_t
name|__sdp_match_by_program
parameter_list|( 	 )
block|{
name|use_family_t
name|server_target_family
decl_stmt|;
name|use_family_t
name|client_target_family
decl_stmt|;
name|use_family_t
name|target_family
init|=
name|USE_BOTH
decl_stmt|;
if|if
condition|(
name|__sdp_config_empty
argument_list|(  )
condition|)
block|{
name|target_family
operator|=
name|USE_SDP
expr_stmt|;
block|}
else|else
block|{
comment|/* need to try both server and client rules */
name|server_target_family
operator|=
name|match_by_all_rules_program
argument_list|(
name|__sdp_servers_family_rules_head
argument_list|)
expr_stmt|;
name|client_target_family
operator|=
name|match_by_all_rules_program
argument_list|(
name|__sdp_clients_family_rules_head
argument_list|)
expr_stmt|;
comment|/* only if both agree */
if|if
condition|(
name|server_target_family
operator|==
name|client_target_family
condition|)
name|target_family
operator|=
name|server_target_family
expr_stmt|;
block|}
name|__sdp_log
argument_list|(
literal|4
argument_list|,
literal|"MATCH PROGRAM: => %s\n"
argument_list|,
name|__sdp_get_family_str
argument_list|(
name|target_family
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|target_family
operator|)
return|;
block|}
end_function

end_unit

