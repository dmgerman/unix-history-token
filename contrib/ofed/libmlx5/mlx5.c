begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2012 Mellanox Technologies, Inc.  All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_define
define|#
directive|define
name|_GNU_SOURCE
end_define

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_include
include|#
directive|include
file|"mlx5.h"
end_include

begin_include
include|#
directive|include
file|"mlx5-abi.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PCI_VENDOR_ID_MELLANOX
end_ifndef

begin_define
define|#
directive|define
name|PCI_VENDOR_ID_MELLANOX
value|0x15b3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CPU_OR
end_ifndef

begin_define
define|#
directive|define
name|CPU_OR
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|do {} while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CPU_EQUAL
end_ifndef

begin_define
define|#
directive|define
name|CPU_EQUAL
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|HCA
parameter_list|(
name|v
parameter_list|,
name|d
parameter_list|)
define|\
value|{ .vendor = PCI_VENDOR_ID_##v,			\ 	  .device = d }
end_define

begin_struct
specifier|static
struct|struct
block|{
name|unsigned
name|vendor
decl_stmt|;
name|unsigned
name|device
decl_stmt|;
block|}
name|hca_table
index|[]
init|=
block|{
name|HCA
argument_list|(
name|MELLANOX
argument_list|,
literal|4113
argument_list|)
block|,
comment|/* MT4113 Connect-IB */
name|HCA
argument_list|(
name|MELLANOX
argument_list|,
literal|4114
argument_list|)
block|,
comment|/* Connect-IB Virtual Function */
name|HCA
argument_list|(
name|MELLANOX
argument_list|,
literal|4115
argument_list|)
block|,
comment|/* ConnectX-4 */
name|HCA
argument_list|(
name|MELLANOX
argument_list|,
literal|4116
argument_list|)
block|,
comment|/* ConnectX-4 Virtual Function */
name|HCA
argument_list|(
name|MELLANOX
argument_list|,
literal|4117
argument_list|)
block|,
comment|/* ConnectX-4LX */
name|HCA
argument_list|(
name|MELLANOX
argument_list|,
literal|4118
argument_list|)
block|,
comment|/* ConnectX-4LX Virtual Function */
name|HCA
argument_list|(
name|MELLANOX
argument_list|,
literal|4119
argument_list|)
block|,
comment|/* ConnectX-5, PCIe 3.0 */
name|HCA
argument_list|(
name|MELLANOX
argument_list|,
literal|4120
argument_list|)
block|,
comment|/* ConnectX-5 Virtual Function */
name|HCA
argument_list|(
name|MELLANOX
argument_list|,
literal|4121
argument_list|)
block|,
comment|/* ConnectX-5 Ex */
name|HCA
argument_list|(
name|MELLANOX
argument_list|,
literal|4122
argument_list|)
block|,
comment|/* ConnectX-5 Ex VF */
name|HCA
argument_list|(
name|MELLANOX
argument_list|,
literal|4123
argument_list|)
block|,
comment|/* ConnectX-6 */
name|HCA
argument_list|(
name|MELLANOX
argument_list|,
literal|4124
argument_list|)
block|,
comment|/* ConnectX-6 VF */
name|HCA
argument_list|(
name|MELLANOX
argument_list|,
literal|41682
argument_list|)
block|,
comment|/* BlueField integrated ConnectX-5 network controller */
name|HCA
argument_list|(
name|MELLANOX
argument_list|,
literal|41683
argument_list|)
block|,
comment|/* BlueField integrated ConnectX-5 network controller VF */
block|}
struct|;
end_struct

begin_decl_stmt
name|uint32_t
name|mlx5_debug_mask
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mlx5_freeze_on_error_cqe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ibv_context_ops
name|mlx5_ctx_ops
init|=
block|{
operator|.
name|query_device
operator|=
name|mlx5_query_device
block|,
operator|.
name|query_port
operator|=
name|mlx5_query_port
block|,
operator|.
name|alloc_pd
operator|=
name|mlx5_alloc_pd
block|,
operator|.
name|dealloc_pd
operator|=
name|mlx5_free_pd
block|,
operator|.
name|reg_mr
operator|=
name|mlx5_reg_mr
block|,
operator|.
name|rereg_mr
operator|=
name|mlx5_rereg_mr
block|,
operator|.
name|dereg_mr
operator|=
name|mlx5_dereg_mr
block|,
operator|.
name|alloc_mw
operator|=
name|mlx5_alloc_mw
block|,
operator|.
name|dealloc_mw
operator|=
name|mlx5_dealloc_mw
block|,
operator|.
name|bind_mw
operator|=
name|mlx5_bind_mw
block|,
operator|.
name|create_cq
operator|=
name|mlx5_create_cq
block|,
operator|.
name|poll_cq
operator|=
name|mlx5_poll_cq
block|,
operator|.
name|req_notify_cq
operator|=
name|mlx5_arm_cq
block|,
operator|.
name|cq_event
operator|=
name|mlx5_cq_event
block|,
operator|.
name|resize_cq
operator|=
name|mlx5_resize_cq
block|,
operator|.
name|destroy_cq
operator|=
name|mlx5_destroy_cq
block|,
operator|.
name|create_srq
operator|=
name|mlx5_create_srq
block|,
operator|.
name|modify_srq
operator|=
name|mlx5_modify_srq
block|,
operator|.
name|query_srq
operator|=
name|mlx5_query_srq
block|,
operator|.
name|destroy_srq
operator|=
name|mlx5_destroy_srq
block|,
operator|.
name|post_srq_recv
operator|=
name|mlx5_post_srq_recv
block|,
operator|.
name|create_qp
operator|=
name|mlx5_create_qp
block|,
operator|.
name|query_qp
operator|=
name|mlx5_query_qp
block|,
operator|.
name|modify_qp
operator|=
name|mlx5_modify_qp
block|,
operator|.
name|destroy_qp
operator|=
name|mlx5_destroy_qp
block|,
operator|.
name|post_send
operator|=
name|mlx5_post_send
block|,
operator|.
name|post_recv
operator|=
name|mlx5_post_recv
block|,
operator|.
name|create_ah
operator|=
name|mlx5_create_ah
block|,
operator|.
name|destroy_ah
operator|=
name|mlx5_destroy_ah
block|,
operator|.
name|attach_mcast
operator|=
name|mlx5_attach_mcast
block|,
operator|.
name|detach_mcast
operator|=
name|mlx5_detach_mcast
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|read_number_from_line
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|int
modifier|*
name|value
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
return|return
literal|1
return|;
operator|++
name|ptr
expr_stmt|;
operator|*
name|value
operator|=
name|atoi
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * The function looks for the first free user-index in all the  * user-index tables. If all are used, returns -1, otherwise  * a valid user-index.  * In case the reference count of the table is zero, it means the  * table is not in use and wasn't allocated yet, therefore the  * mlx5_store_uidx allocates the table, and increment the reference  * count on the table.  */
end_comment

begin_function
specifier|static
name|int32_t
name|get_free_uidx
parameter_list|(
name|struct
name|mlx5_context
modifier|*
name|ctx
parameter_list|)
block|{
name|int32_t
name|tind
decl_stmt|;
name|int32_t
name|i
decl_stmt|;
for|for
control|(
name|tind
operator|=
literal|0
init|;
name|tind
operator|<
name|MLX5_UIDX_TABLE_SIZE
condition|;
name|tind
operator|++
control|)
block|{
if|if
condition|(
name|ctx
operator|->
name|uidx_table
index|[
name|tind
index|]
operator|.
name|refcnt
operator|<
name|MLX5_UIDX_TABLE_MASK
condition|)
break|break;
block|}
if|if
condition|(
name|tind
operator|==
name|MLX5_UIDX_TABLE_SIZE
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|uidx_table
index|[
name|tind
index|]
operator|.
name|refcnt
condition|)
return|return
name|tind
operator|<<
name|MLX5_UIDX_TABLE_SHIFT
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MLX5_UIDX_TABLE_MASK
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ctx
operator|->
name|uidx_table
index|[
name|tind
index|]
operator|.
name|table
index|[
name|i
index|]
condition|)
break|break;
block|}
return|return
operator|(
name|tind
operator|<<
name|MLX5_UIDX_TABLE_SHIFT
operator|)
operator||
name|i
return|;
block|}
end_function

begin_function
name|int32_t
name|mlx5_store_uidx
parameter_list|(
name|struct
name|mlx5_context
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|rsc
parameter_list|)
block|{
name|int32_t
name|tind
decl_stmt|;
name|int32_t
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|int32_t
name|uidx
decl_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|ctx
operator|->
name|uidx_table_mutex
argument_list|)
expr_stmt|;
name|uidx
operator|=
name|get_free_uidx
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|uidx
operator|<
literal|0
condition|)
goto|goto
name|out
goto|;
name|tind
operator|=
name|uidx
operator|>>
name|MLX5_UIDX_TABLE_SHIFT
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|uidx_table
index|[
name|tind
index|]
operator|.
name|refcnt
condition|)
block|{
name|ctx
operator|->
name|uidx_table
index|[
name|tind
index|]
operator|.
name|table
operator|=
name|calloc
argument_list|(
name|MLX5_UIDX_TABLE_MASK
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mlx5_resource
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|uidx_table
index|[
name|tind
index|]
operator|.
name|table
condition|)
goto|goto
name|out
goto|;
block|}
operator|++
name|ctx
operator|->
name|uidx_table
index|[
name|tind
index|]
operator|.
name|refcnt
expr_stmt|;
name|ctx
operator|->
name|uidx_table
index|[
name|tind
index|]
operator|.
name|table
index|[
name|uidx
operator|&
name|MLX5_UIDX_TABLE_MASK
index|]
operator|=
name|rsc
expr_stmt|;
name|ret
operator|=
name|uidx
expr_stmt|;
name|out
label|:
name|pthread_mutex_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|uidx_table_mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|mlx5_clear_uidx
parameter_list|(
name|struct
name|mlx5_context
modifier|*
name|ctx
parameter_list|,
name|uint32_t
name|uidx
parameter_list|)
block|{
name|int
name|tind
init|=
name|uidx
operator|>>
name|MLX5_UIDX_TABLE_SHIFT
decl_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|ctx
operator|->
name|uidx_table_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|ctx
operator|->
name|uidx_table
index|[
name|tind
index|]
operator|.
name|refcnt
condition|)
name|free
argument_list|(
name|ctx
operator|->
name|uidx_table
index|[
name|tind
index|]
operator|.
name|table
argument_list|)
expr_stmt|;
else|else
name|ctx
operator|->
name|uidx_table
index|[
name|tind
index|]
operator|.
name|table
index|[
name|uidx
operator|&
name|MLX5_UIDX_TABLE_MASK
index|]
operator|=
name|NULL
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|ctx
operator|->
name|uidx_table_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx5_is_sandy_bridge
parameter_list|(
name|int
modifier|*
name|num_cores
parameter_list|)
block|{
name|char
name|line
index|[
literal|128
index|]
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|int
name|cur_cpu_family
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|cur_cpu_model
init|=
operator|-
literal|1
decl_stmt|;
name|fd
operator|=
name|fopen
argument_list|(
literal|"/proc/cpuinfo"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fd
condition|)
return|return
literal|0
return|;
operator|*
name|num_cores
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
literal|128
argument_list|,
name|fd
argument_list|)
condition|)
block|{
name|int
name|value
decl_stmt|;
comment|/* if this is information on new processor */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"processor"
argument_list|,
literal|9
argument_list|)
condition|)
block|{
operator|++
operator|*
name|num_cores
expr_stmt|;
name|cur_cpu_family
operator|=
operator|-
literal|1
expr_stmt|;
name|cur_cpu_model
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"cpu family"
argument_list|,
literal|10
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|cur_cpu_family
operator|<
literal|0
operator|)
operator|&&
operator|(
operator|!
name|read_number_from_line
argument_list|(
name|line
argument_list|,
operator|&
name|value
argument_list|)
operator|)
condition|)
name|cur_cpu_family
operator|=
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"model"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|cur_cpu_model
operator|<
literal|0
operator|)
operator|&&
operator|(
operator|!
name|read_number_from_line
argument_list|(
name|line
argument_list|,
operator|&
name|value
argument_list|)
operator|)
condition|)
name|cur_cpu_model
operator|=
name|value
expr_stmt|;
block|}
comment|/* if this is a Sandy Bridge CPU */
if|if
condition|(
operator|(
name|cur_cpu_family
operator|==
literal|6
operator|)
operator|&&
operator|(
name|cur_cpu_model
operator|==
literal|0x2A
operator|||
operator|(
name|cur_cpu_model
operator|==
literal|0x2D
operator|)
operator|)
condition|)
name|rc
operator|=
literal|1
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* man cpuset    This format displays each 32-bit word in hexadecimal (using ASCII characters "0" - "9" and "a" - "f"); words   are filled with leading zeros, if required. For masks longer than one word, a comma separator is used between   words. Words are displayed in big-endian order, which has the most significant bit first. The hex digits   within a word are also in big-endian order.    The number of 32-bit words displayed is the minimum number needed to display all bits of the bitmask, based on   the size of the bitmask.    Examples of the Mask Format:       00000001                        # just bit 0 set      40000000,00000000,00000000      # just bit 94 set      000000ff,00000000               # bits 32-39 set      00000000,000E3862               # 1,5,6,11-13,17-19 set    A mask with bits 0, 1, 2, 4, 8, 16, 32, and 64 set displays as:       00000001,00000001,00010117    The first "1" is for bit 64, the second for bit 32, the third for bit 16, the fourth for bit 8, the fifth for   bit 4, and the "7" is for bits 2, 1, and 0. */
end_comment

begin_function
specifier|static
name|void
name|mlx5_local_cpu_set
parameter_list|(
name|struct
name|ibv_device
modifier|*
name|ibdev
parameter_list|,
name|cpuset_t
modifier|*
name|cpu_set
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|env_value
decl_stmt|;
name|uint32_t
name|word
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|env_value
operator|=
name|getenv
argument_list|(
literal|"MLX5_LOCAL_CPUS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env_value
condition|)
name|strncpy
argument_list|(
name|buf
argument_list|,
name|env_value
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|fname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|fname
argument_list|,
name|MAXPATHLEN
argument_list|,
literal|"/sys/class/infiniband/%s"
argument_list|,
name|ibv_get_device_name
argument_list|(
name|ibdev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibv_read_sysfs_file
argument_list|(
name|fname
argument_list|,
literal|"device/local_cpus"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|PFX
literal|"Warning: can not get local cpu set: failed to open %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|p
operator|=
name|strrchr
argument_list|(
name|buf
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|buf
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|word
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|word
condition|;
operator|++
name|k
operator|,
name|word
operator|>>=
literal|1
control|)
if|if
condition|(
name|word
operator|&
literal|1
condition|)
name|CPU_SET
argument_list|(
name|k
operator|+
name|i
argument_list|,
name|cpu_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|buf
condition|)
break|break;
name|p
operator|=
name|strrchr
argument_list|(
name|buf
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|buf
expr_stmt|;
name|i
operator|+=
literal|32
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
name|CPU_SETSIZE
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx5_enable_sandy_bridge_fix
parameter_list|(
name|struct
name|ibv_device
modifier|*
name|ibdev
parameter_list|)
block|{
name|cpuset_t
name|my_cpus
decl_stmt|,
name|dev_local_cpus
decl_stmt|,
name|result_set
decl_stmt|;
name|int
name|stall_enable
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|num_cores
decl_stmt|;
if|if
condition|(
operator|!
name|mlx5_is_sandy_bridge
argument_list|(
operator|&
name|num_cores
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* by default enable stall on sandy bridge arch */
name|stall_enable
operator|=
literal|1
expr_stmt|;
comment|/* 	 * check if app is bound to cpu set that is inside 	 * of device local cpu set. Disable stalling if true 	 */
comment|/* use static cpu set - up to CPU_SETSIZE (1024) cpus/node */
name|CPU_ZERO
argument_list|(
operator|&
name|my_cpus
argument_list|)
expr_stmt|;
name|CPU_ZERO
argument_list|(
operator|&
name|dev_local_cpus
argument_list|)
expr_stmt|;
name|CPU_ZERO
argument_list|(
operator|&
name|result_set
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cpuset_getaffinity
argument_list|(
name|CPU_LEVEL_WHICH
argument_list|,
name|CPU_WHICH_PID
argument_list|,
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|my_cpus
argument_list|)
argument_list|,
operator|&
name|my_cpus
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINVAL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|PFX
literal|"Warning: my cpu set is too small\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|PFX
literal|"Warning: failed to get my cpu set\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* get device local cpu set */
name|mlx5_local_cpu_set
argument_list|(
name|ibdev
argument_list|,
operator|&
name|dev_local_cpus
argument_list|)
expr_stmt|;
comment|/* check if my cpu set is in dev cpu */
name|CPU_OR
argument_list|(
operator|&
name|result_set
argument_list|,
operator|&
name|my_cpus
argument_list|)
expr_stmt|;
name|CPU_OR
argument_list|(
operator|&
name|result_set
argument_list|,
operator|&
name|dev_local_cpus
argument_list|)
expr_stmt|;
name|stall_enable
operator|=
name|CPU_EQUAL
argument_list|(
operator|&
name|result_set
argument_list|,
operator|&
name|dev_local_cpus
argument_list|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|out
label|:
return|return
name|stall_enable
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx5_read_env
parameter_list|(
name|struct
name|ibv_device
modifier|*
name|ibdev
parameter_list|,
name|struct
name|mlx5_context
modifier|*
name|ctx
parameter_list|)
block|{
name|char
modifier|*
name|env_value
decl_stmt|;
name|env_value
operator|=
name|getenv
argument_list|(
literal|"MLX5_STALL_CQ_POLL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env_value
condition|)
comment|/* check if cq stall is enforced by user */
name|ctx
operator|->
name|stall_enable
operator|=
operator|(
name|strcmp
argument_list|(
name|env_value
argument_list|,
literal|"0"
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
else|else
comment|/* autodetect if we need to do cq polling */
name|ctx
operator|->
name|stall_enable
operator|=
name|mlx5_enable_sandy_bridge_fix
argument_list|(
name|ibdev
argument_list|)
expr_stmt|;
name|env_value
operator|=
name|getenv
argument_list|(
literal|"MLX5_STALL_NUM_LOOP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env_value
condition|)
name|mlx5_stall_num_loop
operator|=
name|atoi
argument_list|(
name|env_value
argument_list|)
expr_stmt|;
name|env_value
operator|=
name|getenv
argument_list|(
literal|"MLX5_STALL_CQ_POLL_MIN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env_value
condition|)
name|mlx5_stall_cq_poll_min
operator|=
name|atoi
argument_list|(
name|env_value
argument_list|)
expr_stmt|;
name|env_value
operator|=
name|getenv
argument_list|(
literal|"MLX5_STALL_CQ_POLL_MAX"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env_value
condition|)
name|mlx5_stall_cq_poll_max
operator|=
name|atoi
argument_list|(
name|env_value
argument_list|)
expr_stmt|;
name|env_value
operator|=
name|getenv
argument_list|(
literal|"MLX5_STALL_CQ_INC_STEP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env_value
condition|)
name|mlx5_stall_cq_inc_step
operator|=
name|atoi
argument_list|(
name|env_value
argument_list|)
expr_stmt|;
name|env_value
operator|=
name|getenv
argument_list|(
literal|"MLX5_STALL_CQ_DEC_STEP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env_value
condition|)
name|mlx5_stall_cq_dec_step
operator|=
name|atoi
argument_list|(
name|env_value
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|stall_adaptive_enable
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|stall_cycles
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mlx5_stall_num_loop
operator|<
literal|0
condition|)
block|{
name|ctx
operator|->
name|stall_adaptive_enable
operator|=
literal|1
expr_stmt|;
name|ctx
operator|->
name|stall_cycles
operator|=
name|mlx5_stall_cq_poll_min
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|get_total_uuars
parameter_list|(
name|int
name|page_size
parameter_list|)
block|{
name|int
name|size
init|=
name|MLX5_DEF_TOT_UUARS
decl_stmt|;
name|int
name|uuars_in_page
decl_stmt|;
name|char
modifier|*
name|env
decl_stmt|;
name|env
operator|=
name|getenv
argument_list|(
literal|"MLX5_TOTAL_UUARS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
condition|)
name|size
operator|=
name|atoi
argument_list|(
name|env
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|1
condition|)
return|return
operator|-
name|EINVAL
return|;
name|uuars_in_page
operator|=
name|page_size
operator|/
name|MLX5_ADAPTER_PAGE_SIZE
operator|*
name|MLX5_NUM_NON_FP_BFREGS_PER_UAR
expr_stmt|;
name|size
operator|=
name|max
argument_list|(
name|uuars_in_page
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
name|align
argument_list|(
name|size
argument_list|,
name|MLX5_NUM_NON_FP_BFREGS_PER_UAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|MLX5_MAX_BFREGS
condition|)
return|return
operator|-
name|ENOMEM
return|;
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|open_debug_file
parameter_list|(
name|struct
name|mlx5_context
modifier|*
name|ctx
parameter_list|)
block|{
name|char
modifier|*
name|env
decl_stmt|;
name|env
operator|=
name|getenv
argument_list|(
literal|"MLX5_DEBUG_FILE"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|env
condition|)
block|{
name|ctx
operator|->
name|dbg_fp
operator|=
name|stderr
expr_stmt|;
return|return;
block|}
name|ctx
operator|->
name|dbg_fp
operator|=
name|fopen
argument_list|(
name|env
argument_list|,
literal|"aw+"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|dbg_fp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Failed opening debug file %s, using stderr\n"
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|dbg_fp
operator|=
name|stderr
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|close_debug_file
parameter_list|(
name|struct
name|mlx5_context
modifier|*
name|ctx
parameter_list|)
block|{
if|if
condition|(
name|ctx
operator|->
name|dbg_fp
operator|&&
name|ctx
operator|->
name|dbg_fp
operator|!=
name|stderr
condition|)
name|fclose
argument_list|(
name|ctx
operator|->
name|dbg_fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_debug_mask
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|env
decl_stmt|;
name|env
operator|=
name|getenv
argument_list|(
literal|"MLX5_DEBUG_MASK"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
condition|)
name|mlx5_debug_mask
operator|=
name|strtol
argument_list|(
name|env
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_freeze_on_error
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|env
decl_stmt|;
name|env
operator|=
name|getenv
argument_list|(
literal|"MLX5_FREEZE_ON_ERROR_CQE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
condition|)
name|mlx5_freeze_on_error_cqe
operator|=
name|strtol
argument_list|(
name|env
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_always_bf
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|env
decl_stmt|;
name|env
operator|=
name|getenv
argument_list|(
literal|"MLX5_POST_SEND_PREFER_BF"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|env
condition|)
return|return
literal|1
return|;
return|return
name|strcmp
argument_list|(
name|env
argument_list|,
literal|"0"
argument_list|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_shut_up_bf
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|env
decl_stmt|;
name|env
operator|=
name|getenv
argument_list|(
literal|"MLX5_SHUT_UP_BF"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|env
condition|)
return|return
literal|0
return|;
return|return
name|strcmp
argument_list|(
name|env
argument_list|,
literal|"0"
argument_list|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_num_low_lat_uuars
parameter_list|(
name|int
name|tot_uuars
parameter_list|)
block|{
name|char
modifier|*
name|env
decl_stmt|;
name|int
name|num
init|=
literal|4
decl_stmt|;
name|env
operator|=
name|getenv
argument_list|(
literal|"MLX5_NUM_LOW_LAT_UUARS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
condition|)
name|num
operator|=
name|atoi
argument_list|(
name|env
argument_list|)
expr_stmt|;
if|if
condition|(
name|num
operator|<
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
name|num
operator|=
name|max
argument_list|(
name|num
argument_list|,
name|tot_uuars
operator|-
name|MLX5_MED_BFREGS_TSHOLD
argument_list|)
expr_stmt|;
return|return
name|num
return|;
block|}
end_function

begin_comment
comment|/* The library allocates an array of uuar contexts. The one in index zero does  * not to execersize odd/even policy so it can avoid a lock but it may not use  * blue flame. The upper ones, low_lat_uuars can use blue flame with no lock  * since they are assigned to one QP only. The rest can use blue flame but since  * they are shared they need a lock  */
end_comment

begin_function
specifier|static
name|int
name|need_uuar_lock
parameter_list|(
name|struct
name|mlx5_context
modifier|*
name|ctx
parameter_list|,
name|int
name|uuarn
parameter_list|)
block|{
if|if
condition|(
name|uuarn
operator|==
literal|0
operator|||
name|mlx5_single_threaded
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|uuarn
operator|>=
operator|(
name|ctx
operator|->
name|tot_uuars
operator|-
name|ctx
operator|->
name|low_lat_uuars
operator|)
operator|*
literal|2
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|single_threaded_app
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|env
decl_stmt|;
name|env
operator|=
name|getenv
argument_list|(
literal|"MLX5_SINGLE_THREADED"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
condition|)
return|return
name|strcmp
argument_list|(
name|env
argument_list|,
literal|"1"
argument_list|)
condition|?
literal|0
else|:
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx5_cmd_get_context
parameter_list|(
name|struct
name|mlx5_context
modifier|*
name|context
parameter_list|,
name|struct
name|mlx5_alloc_ucontext
modifier|*
name|req
parameter_list|,
name|size_t
name|req_len
parameter_list|,
name|struct
name|mlx5_alloc_ucontext_resp
modifier|*
name|resp
parameter_list|,
name|size_t
name|resp_len
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ibv_cmd_get_context
argument_list|(
operator|&
name|context
operator|->
name|ibv_ctx
argument_list|,
operator|&
name|req
operator|->
name|ibv_req
argument_list|,
name|req_len
argument_list|,
operator|&
name|resp
operator|->
name|ibv_resp
argument_list|,
name|resp_len
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* The ibv_cmd_get_context fails in older kernels when passing 	 * a request length that the kernel doesn't know. 	 * To avoid breaking compatibility of new libmlx5 and older 	 * kernels, when ibv_cmd_get_context fails with the full 	 * request length, we try once again with the legacy length. 	 * We repeat this process while reducing requested size based 	 * on the feature input size. To avoid this in the future, we 	 * will remove the check in kernel that requires fields unknown 	 * to the kernel to be cleared. This will require that any new 	 * feature that involves extending struct mlx5_alloc_ucontext 	 * will be accompanied by an indication in the form of one or 	 * more fields in struct mlx5_alloc_ucontext_resp. If the 	 * response value can be interpreted as feature not supported 	 * when the returned value is zero, this will suffice to 	 * indicate to the library that the request was ignored by the 	 * kernel, either because it is unaware or because it decided 	 * to do so. If zero is a valid response, we will add a new 	 * field that indicates whether the request was handled. 	 */
if|if
condition|(
operator|!
name|ibv_cmd_get_context
argument_list|(
operator|&
name|context
operator|->
name|ibv_ctx
argument_list|,
operator|&
name|req
operator|->
name|ibv_req
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|mlx5_alloc_ucontext
argument_list|,
name|lib_caps
argument_list|)
argument_list|,
operator|&
name|resp
operator|->
name|ibv_resp
argument_list|,
name|resp_len
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|ibv_cmd_get_context
argument_list|(
operator|&
name|context
operator|->
name|ibv_ctx
argument_list|,
operator|&
name|req
operator|->
name|ibv_req
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|mlx5_alloc_ucontext
argument_list|,
name|cqe_version
argument_list|)
argument_list|,
operator|&
name|resp
operator|->
name|ibv_resp
argument_list|,
name|resp_len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx5_map_internal_clock
parameter_list|(
name|struct
name|mlx5_device
modifier|*
name|mdev
parameter_list|,
name|struct
name|ibv_context
modifier|*
name|ibv_ctx
parameter_list|)
block|{
name|struct
name|mlx5_context
modifier|*
name|context
init|=
name|to_mctx
argument_list|(
name|ibv_ctx
argument_list|)
decl_stmt|;
name|void
modifier|*
name|hca_clock_page
decl_stmt|;
name|off_t
name|offset
init|=
literal|0
decl_stmt|;
name|set_command
argument_list|(
name|MLX5_MMAP_GET_CORE_CLOCK_CMD
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|hca_clock_page
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|mdev
operator|->
name|page_size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_SHARED
argument_list|,
name|ibv_ctx
operator|->
name|cmd_fd
argument_list|,
name|mdev
operator|->
name|page_size
operator|*
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|hca_clock_page
operator|==
name|MAP_FAILED
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|PFX
literal|"Warning: Timestamp available,\n"
literal|"but failed to mmap() hca core clock page.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|context
operator|->
name|hca_core_clock
operator|=
name|hca_clock_page
operator|+
operator|(
name|context
operator|->
name|core_clock
operator|.
name|offset
operator|&
operator|(
name|mdev
operator|->
name|page_size
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx5dv_query_device
parameter_list|(
name|struct
name|ibv_context
modifier|*
name|ctx_in
parameter_list|,
name|struct
name|mlx5dv_context
modifier|*
name|attrs_out
parameter_list|)
block|{
name|struct
name|mlx5_context
modifier|*
name|mctx
init|=
name|to_mctx
argument_list|(
name|ctx_in
argument_list|)
decl_stmt|;
name|uint64_t
name|comp_mask_out
init|=
literal|0
decl_stmt|;
name|attrs_out
operator|->
name|version
operator|=
literal|0
expr_stmt|;
name|attrs_out
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mctx
operator|->
name|cqe_version
operator|==
name|MLX5_CQE_VERSION_V1
condition|)
name|attrs_out
operator|->
name|flags
operator||=
name|MLX5DV_CONTEXT_FLAGS_CQE_V1
expr_stmt|;
if|if
condition|(
name|mctx
operator|->
name|vendor_cap_flags
operator|&
name|MLX5_VENDOR_CAP_FLAGS_MPW
condition|)
name|attrs_out
operator|->
name|flags
operator||=
name|MLX5DV_CONTEXT_FLAGS_MPW
expr_stmt|;
if|if
condition|(
name|attrs_out
operator|->
name|comp_mask
operator|&
name|MLX5DV_CONTEXT_MASK_CQE_COMPRESION
condition|)
block|{
name|attrs_out
operator|->
name|cqe_comp_caps
operator|=
name|mctx
operator|->
name|cqe_comp_caps
expr_stmt|;
name|comp_mask_out
operator||=
name|MLX5DV_CONTEXT_MASK_CQE_COMPRESION
expr_stmt|;
block|}
name|attrs_out
operator|->
name|comp_mask
operator|=
name|comp_mask_out
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx5dv_get_qp
parameter_list|(
name|struct
name|ibv_qp
modifier|*
name|qp_in
parameter_list|,
name|struct
name|mlx5dv_qp
modifier|*
name|qp_out
parameter_list|)
block|{
name|struct
name|mlx5_qp
modifier|*
name|mqp
init|=
name|to_mqp
argument_list|(
name|qp_in
argument_list|)
decl_stmt|;
name|qp_out
operator|->
name|comp_mask
operator|=
literal|0
expr_stmt|;
name|qp_out
operator|->
name|dbrec
operator|=
name|mqp
operator|->
name|db
expr_stmt|;
if|if
condition|(
name|mqp
operator|->
name|sq_buf_size
condition|)
comment|/* IBV_QPT_RAW_PACKET */
name|qp_out
operator|->
name|sq
operator|.
name|buf
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|mqp
operator|->
name|sq_buf
operator|.
name|buf
operator|)
expr_stmt|;
else|else
name|qp_out
operator|->
name|sq
operator|.
name|buf
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|mqp
operator|->
name|buf
operator|.
name|buf
operator|+
name|mqp
operator|->
name|sq
operator|.
name|offset
operator|)
expr_stmt|;
name|qp_out
operator|->
name|sq
operator|.
name|wqe_cnt
operator|=
name|mqp
operator|->
name|sq
operator|.
name|wqe_cnt
expr_stmt|;
name|qp_out
operator|->
name|sq
operator|.
name|stride
operator|=
literal|1
operator|<<
name|mqp
operator|->
name|sq
operator|.
name|wqe_shift
expr_stmt|;
name|qp_out
operator|->
name|rq
operator|.
name|buf
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|mqp
operator|->
name|buf
operator|.
name|buf
operator|+
name|mqp
operator|->
name|rq
operator|.
name|offset
operator|)
expr_stmt|;
name|qp_out
operator|->
name|rq
operator|.
name|wqe_cnt
operator|=
name|mqp
operator|->
name|rq
operator|.
name|wqe_cnt
expr_stmt|;
name|qp_out
operator|->
name|rq
operator|.
name|stride
operator|=
literal|1
operator|<<
name|mqp
operator|->
name|rq
operator|.
name|wqe_shift
expr_stmt|;
name|qp_out
operator|->
name|bf
operator|.
name|reg
operator|=
name|mqp
operator|->
name|bf
operator|->
name|reg
expr_stmt|;
if|if
condition|(
name|mqp
operator|->
name|bf
operator|->
name|uuarn
operator|>
literal|0
condition|)
name|qp_out
operator|->
name|bf
operator|.
name|size
operator|=
name|mqp
operator|->
name|bf
operator|->
name|buf_size
expr_stmt|;
else|else
name|qp_out
operator|->
name|bf
operator|.
name|size
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx5dv_get_cq
parameter_list|(
name|struct
name|ibv_cq
modifier|*
name|cq_in
parameter_list|,
name|struct
name|mlx5dv_cq
modifier|*
name|cq_out
parameter_list|)
block|{
name|struct
name|mlx5_cq
modifier|*
name|mcq
init|=
name|to_mcq
argument_list|(
name|cq_in
argument_list|)
decl_stmt|;
name|struct
name|mlx5_context
modifier|*
name|mctx
init|=
name|to_mctx
argument_list|(
name|cq_in
operator|->
name|context
argument_list|)
decl_stmt|;
name|cq_out
operator|->
name|comp_mask
operator|=
literal|0
expr_stmt|;
name|cq_out
operator|->
name|cqn
operator|=
name|mcq
operator|->
name|cqn
expr_stmt|;
name|cq_out
operator|->
name|cqe_cnt
operator|=
name|mcq
operator|->
name|ibv_cq
operator|.
name|cqe
operator|+
literal|1
expr_stmt|;
name|cq_out
operator|->
name|cqe_size
operator|=
name|mcq
operator|->
name|cqe_sz
expr_stmt|;
name|cq_out
operator|->
name|buf
operator|=
name|mcq
operator|->
name|active_buf
operator|->
name|buf
expr_stmt|;
name|cq_out
operator|->
name|dbrec
operator|=
name|mcq
operator|->
name|dbrec
expr_stmt|;
name|cq_out
operator|->
name|uar
operator|=
name|mctx
operator|->
name|uar
expr_stmt|;
name|mcq
operator|->
name|flags
operator||=
name|MLX5_CQ_FLAGS_DV_OWNED
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx5dv_get_rwq
parameter_list|(
name|struct
name|ibv_wq
modifier|*
name|wq_in
parameter_list|,
name|struct
name|mlx5dv_rwq
modifier|*
name|rwq_out
parameter_list|)
block|{
name|struct
name|mlx5_rwq
modifier|*
name|mrwq
init|=
name|to_mrwq
argument_list|(
name|wq_in
argument_list|)
decl_stmt|;
name|rwq_out
operator|->
name|comp_mask
operator|=
literal|0
expr_stmt|;
name|rwq_out
operator|->
name|buf
operator|=
name|mrwq
operator|->
name|pbuff
expr_stmt|;
name|rwq_out
operator|->
name|dbrec
operator|=
name|mrwq
operator|->
name|recv_db
expr_stmt|;
name|rwq_out
operator|->
name|wqe_cnt
operator|=
name|mrwq
operator|->
name|rq
operator|.
name|wqe_cnt
expr_stmt|;
name|rwq_out
operator|->
name|stride
operator|=
literal|1
operator|<<
name|mrwq
operator|->
name|rq
operator|.
name|wqe_shift
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx5dv_get_srq
parameter_list|(
name|struct
name|ibv_srq
modifier|*
name|srq_in
parameter_list|,
name|struct
name|mlx5dv_srq
modifier|*
name|srq_out
parameter_list|)
block|{
name|struct
name|mlx5_srq
modifier|*
name|msrq
decl_stmt|;
name|msrq
operator|=
name|container_of
argument_list|(
name|srq_in
argument_list|,
expr|struct
name|mlx5_srq
argument_list|,
name|vsrq
operator|.
name|srq
argument_list|)
expr_stmt|;
name|srq_out
operator|->
name|comp_mask
operator|=
literal|0
expr_stmt|;
name|srq_out
operator|->
name|buf
operator|=
name|msrq
operator|->
name|buf
operator|.
name|buf
expr_stmt|;
name|srq_out
operator|->
name|dbrec
operator|=
name|msrq
operator|->
name|db
expr_stmt|;
name|srq_out
operator|->
name|stride
operator|=
literal|1
operator|<<
name|msrq
operator|->
name|wqe_shift
expr_stmt|;
name|srq_out
operator|->
name|head
operator|=
name|msrq
operator|->
name|head
expr_stmt|;
name|srq_out
operator|->
name|tail
operator|=
name|msrq
operator|->
name|tail
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx5dv_init_obj
parameter_list|(
name|struct
name|mlx5dv_obj
modifier|*
name|obj
parameter_list|,
name|uint64_t
name|obj_type
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|obj_type
operator|&
name|MLX5DV_OBJ_QP
condition|)
name|ret
operator|=
name|mlx5dv_get_qp
argument_list|(
name|obj
operator|->
name|qp
operator|.
name|in
argument_list|,
name|obj
operator|->
name|qp
operator|.
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|&&
operator|(
name|obj_type
operator|&
name|MLX5DV_OBJ_CQ
operator|)
condition|)
name|ret
operator|=
name|mlx5dv_get_cq
argument_list|(
name|obj
operator|->
name|cq
operator|.
name|in
argument_list|,
name|obj
operator|->
name|cq
operator|.
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|&&
operator|(
name|obj_type
operator|&
name|MLX5DV_OBJ_SRQ
operator|)
condition|)
name|ret
operator|=
name|mlx5dv_get_srq
argument_list|(
name|obj
operator|->
name|srq
operator|.
name|in
argument_list|,
name|obj
operator|->
name|srq
operator|.
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|&&
operator|(
name|obj_type
operator|&
name|MLX5DV_OBJ_RWQ
operator|)
condition|)
name|ret
operator|=
name|mlx5dv_get_rwq
argument_list|(
name|obj
operator|->
name|rwq
operator|.
name|in
argument_list|,
name|obj
operator|->
name|rwq
operator|.
name|out
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|adjust_uar_info
parameter_list|(
name|struct
name|mlx5_device
modifier|*
name|mdev
parameter_list|,
name|struct
name|mlx5_context
modifier|*
name|context
parameter_list|,
name|struct
name|mlx5_alloc_ucontext_resp
name|resp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|resp
operator|.
name|log_uar_size
operator|&&
operator|!
name|resp
operator|.
name|num_uars_per_page
condition|)
block|{
comment|/* old kernel */
name|context
operator|->
name|uar_size
operator|=
name|mdev
operator|->
name|page_size
expr_stmt|;
name|context
operator|->
name|num_uars_per_page
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|context
operator|->
name|uar_size
operator|=
literal|1
operator|<<
name|resp
operator|.
name|log_uar_size
expr_stmt|;
name|context
operator|->
name|num_uars_per_page
operator|=
name|resp
operator|.
name|num_uars_per_page
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx5_init_context
parameter_list|(
name|struct
name|verbs_device
modifier|*
name|vdev
parameter_list|,
name|struct
name|ibv_context
modifier|*
name|ctx
parameter_list|,
name|int
name|cmd_fd
parameter_list|)
block|{
name|struct
name|mlx5_context
modifier|*
name|context
decl_stmt|;
name|struct
name|mlx5_alloc_ucontext
name|req
decl_stmt|;
name|struct
name|mlx5_alloc_ucontext_resp
name|resp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|page_size
decl_stmt|;
name|int
name|tot_uuars
decl_stmt|;
name|int
name|low_lat_uuars
decl_stmt|;
name|int
name|gross_uuars
decl_stmt|;
name|int
name|j
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|struct
name|mlx5_device
modifier|*
name|mdev
decl_stmt|;
name|struct
name|verbs_context
modifier|*
name|v_ctx
decl_stmt|;
name|struct
name|ibv_port_attr
name|port_attr
decl_stmt|;
name|struct
name|ibv_device_attr_ex
name|device_attr
decl_stmt|;
name|int
name|k
decl_stmt|;
name|int
name|bfi
decl_stmt|;
name|int
name|num_sys_page_map
decl_stmt|;
name|mdev
operator|=
name|to_mdev
argument_list|(
operator|&
name|vdev
operator|->
name|device
argument_list|)
expr_stmt|;
name|v_ctx
operator|=
name|verbs_get_ctx
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|page_size
operator|=
name|mdev
operator|->
name|page_size
expr_stmt|;
name|mlx5_single_threaded
operator|=
name|single_threaded_app
argument_list|()
expr_stmt|;
name|context
operator|=
name|to_mctx
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|context
operator|->
name|ibv_ctx
operator|.
name|cmd_fd
operator|=
name|cmd_fd
expr_stmt|;
name|open_debug_file
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|set_debug_mask
argument_list|()
expr_stmt|;
name|set_freeze_on_error
argument_list|()
expr_stmt|;
if|if
condition|(
name|gethostname
argument_list|(
name|context
operator|->
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|context
operator|->
name|hostname
argument_list|)
argument_list|)
condition|)
name|strcpy
argument_list|(
name|context
operator|->
name|hostname
argument_list|,
literal|"host_unknown"
argument_list|)
expr_stmt|;
name|tot_uuars
operator|=
name|get_total_uuars
argument_list|(
name|page_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|tot_uuars
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
operator|-
name|tot_uuars
expr_stmt|;
goto|goto
name|err_free
goto|;
block|}
name|low_lat_uuars
operator|=
name|get_num_low_lat_uuars
argument_list|(
name|tot_uuars
argument_list|)
expr_stmt|;
if|if
condition|(
name|low_lat_uuars
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
operator|-
name|low_lat_uuars
expr_stmt|;
goto|goto
name|err_free
goto|;
block|}
if|if
condition|(
name|low_lat_uuars
operator|>
name|tot_uuars
operator|-
literal|1
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_free
goto|;
block|}
name|memset
argument_list|(
operator|&
name|req
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|resp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|resp
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|.
name|total_num_uuars
operator|=
name|tot_uuars
expr_stmt|;
name|req
operator|.
name|num_low_latency_uuars
operator|=
name|low_lat_uuars
expr_stmt|;
name|req
operator|.
name|cqe_version
operator|=
name|MLX5_CQE_VERSION_V1
expr_stmt|;
name|req
operator|.
name|lib_caps
operator||=
name|MLX5_LIB_CAP_4K_UAR
expr_stmt|;
if|if
condition|(
name|mlx5_cmd_get_context
argument_list|(
name|context
argument_list|,
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|,
operator|&
name|resp
argument_list|,
sizeof|sizeof
argument_list|(
name|resp
argument_list|)
argument_list|)
condition|)
goto|goto
name|err_free
goto|;
name|context
operator|->
name|max_num_qps
operator|=
name|resp
operator|.
name|qp_tab_size
expr_stmt|;
name|context
operator|->
name|bf_reg_size
operator|=
name|resp
operator|.
name|bf_reg_size
expr_stmt|;
name|context
operator|->
name|tot_uuars
operator|=
name|resp
operator|.
name|tot_uuars
expr_stmt|;
name|context
operator|->
name|low_lat_uuars
operator|=
name|low_lat_uuars
expr_stmt|;
name|context
operator|->
name|cache_line_size
operator|=
name|resp
operator|.
name|cache_line_size
expr_stmt|;
name|context
operator|->
name|max_sq_desc_sz
operator|=
name|resp
operator|.
name|max_sq_desc_sz
expr_stmt|;
name|context
operator|->
name|max_rq_desc_sz
operator|=
name|resp
operator|.
name|max_rq_desc_sz
expr_stmt|;
name|context
operator|->
name|max_send_wqebb
operator|=
name|resp
operator|.
name|max_send_wqebb
expr_stmt|;
name|context
operator|->
name|num_ports
operator|=
name|resp
operator|.
name|num_ports
expr_stmt|;
name|context
operator|->
name|max_recv_wr
operator|=
name|resp
operator|.
name|max_recv_wr
expr_stmt|;
name|context
operator|->
name|max_srq_recv_wr
operator|=
name|resp
operator|.
name|max_srq_recv_wr
expr_stmt|;
name|context
operator|->
name|cqe_version
operator|=
name|resp
operator|.
name|cqe_version
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|cqe_version
condition|)
block|{
if|if
condition|(
name|context
operator|->
name|cqe_version
operator|==
name|MLX5_CQE_VERSION_V1
condition|)
name|mlx5_ctx_ops
operator|.
name|poll_cq
operator|=
name|mlx5_poll_cq_v1
expr_stmt|;
else|else
goto|goto
name|err_free
goto|;
block|}
name|adjust_uar_info
argument_list|(
name|mdev
argument_list|,
name|context
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|gross_uuars
operator|=
name|context
operator|->
name|tot_uuars
operator|/
name|MLX5_NUM_NON_FP_BFREGS_PER_UAR
operator|*
name|NUM_BFREGS_PER_UAR
expr_stmt|;
name|context
operator|->
name|bfs
operator|=
name|calloc
argument_list|(
name|gross_uuars
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|context
operator|->
name|bfs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|context
operator|->
name|bfs
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_free
goto|;
block|}
name|context
operator|->
name|cmds_supp_uhw
operator|=
name|resp
operator|.
name|cmds_supp_uhw
expr_stmt|;
name|context
operator|->
name|vendor_cap_flags
operator|=
literal|0
expr_stmt|;
name|pthread_mutex_init
argument_list|(
operator|&
name|context
operator|->
name|qp_table_mutex
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pthread_mutex_init
argument_list|(
operator|&
name|context
operator|->
name|srq_table_mutex
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pthread_mutex_init
argument_list|(
operator|&
name|context
operator|->
name|uidx_table_mutex
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MLX5_QP_TABLE_SIZE
condition|;
operator|++
name|i
control|)
name|context
operator|->
name|qp_table
index|[
name|i
index|]
operator|.
name|refcnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MLX5_QP_TABLE_SIZE
condition|;
operator|++
name|i
control|)
name|context
operator|->
name|uidx_table
index|[
name|i
index|]
operator|.
name|refcnt
operator|=
literal|0
expr_stmt|;
name|context
operator|->
name|db_list
operator|=
name|NULL
expr_stmt|;
name|pthread_mutex_init
argument_list|(
operator|&
name|context
operator|->
name|db_list_mutex
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|num_sys_page_map
operator|=
name|context
operator|->
name|tot_uuars
operator|/
operator|(
name|context
operator|->
name|num_uars_per_page
operator|*
name|MLX5_NUM_NON_FP_BFREGS_PER_UAR
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_sys_page_map
condition|;
operator|++
name|i
control|)
block|{
name|offset
operator|=
literal|0
expr_stmt|;
name|set_command
argument_list|(
name|MLX5_MMAP_GET_REGULAR_PAGES_CMD
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|set_index
argument_list|(
name|i
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|context
operator|->
name|uar
index|[
name|i
index|]
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|page_size
argument_list|,
name|PROT_WRITE
argument_list|,
name|MAP_SHARED
argument_list|,
name|cmd_fd
argument_list|,
name|page_size
operator|*
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|uar
index|[
name|i
index|]
operator|==
name|MAP_FAILED
condition|)
block|{
name|context
operator|->
name|uar
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
goto|goto
name|err_free_bf
goto|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_sys_page_map
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|context
operator|->
name|num_uars_per_page
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NUM_BFREGS_PER_UAR
condition|;
name|k
operator|++
control|)
block|{
name|bfi
operator|=
operator|(
name|i
operator|*
name|context
operator|->
name|num_uars_per_page
operator|+
name|j
operator|)
operator|*
name|NUM_BFREGS_PER_UAR
operator|+
name|k
expr_stmt|;
name|context
operator|->
name|bfs
index|[
name|bfi
index|]
operator|.
name|reg
operator|=
name|context
operator|->
name|uar
index|[
name|i
index|]
operator|+
name|MLX5_ADAPTER_PAGE_SIZE
operator|*
name|j
operator|+
name|MLX5_BF_OFFSET
operator|+
name|k
operator|*
name|context
operator|->
name|bf_reg_size
expr_stmt|;
name|context
operator|->
name|bfs
index|[
name|bfi
index|]
operator|.
name|need_lock
operator|=
name|need_uuar_lock
argument_list|(
name|context
argument_list|,
name|bfi
argument_list|)
expr_stmt|;
name|mlx5_spinlock_init
argument_list|(
operator|&
name|context
operator|->
name|bfs
index|[
name|bfi
index|]
operator|.
name|lock
argument_list|)
expr_stmt|;
name|context
operator|->
name|bfs
index|[
name|bfi
index|]
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bfi
condition|)
name|context
operator|->
name|bfs
index|[
name|bfi
index|]
operator|.
name|buf_size
operator|=
name|context
operator|->
name|bf_reg_size
operator|/
literal|2
expr_stmt|;
name|context
operator|->
name|bfs
index|[
name|bfi
index|]
operator|.
name|uuarn
operator|=
name|bfi
expr_stmt|;
block|}
block|}
block|}
name|context
operator|->
name|hca_core_clock
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|resp
operator|.
name|response_length
operator|+
sizeof|sizeof
argument_list|(
name|resp
operator|.
name|ibv_resp
argument_list|)
operator|>=
name|offsetof
argument_list|(
expr|struct
name|mlx5_alloc_ucontext_resp
argument_list|,
name|hca_core_clock_offset
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|resp
operator|.
name|hca_core_clock_offset
argument_list|)
operator|&&
name|resp
operator|.
name|comp_mask
operator|&
name|MLX5_IB_ALLOC_UCONTEXT_RESP_MASK_CORE_CLOCK_OFFSET
condition|)
block|{
name|context
operator|->
name|core_clock
operator|.
name|offset
operator|=
name|resp
operator|.
name|hca_core_clock_offset
expr_stmt|;
name|mlx5_map_internal_clock
argument_list|(
name|mdev
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
name|mlx5_spinlock_init
argument_list|(
operator|&
name|context
operator|->
name|lock32
argument_list|)
expr_stmt|;
name|context
operator|->
name|prefer_bf
operator|=
name|get_always_bf
argument_list|()
expr_stmt|;
name|context
operator|->
name|shut_up_bf
operator|=
name|get_shut_up_bf
argument_list|()
expr_stmt|;
name|mlx5_read_env
argument_list|(
operator|&
name|vdev
operator|->
name|device
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|mlx5_spinlock_init
argument_list|(
operator|&
name|context
operator|->
name|hugetlb_lock
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|context
operator|->
name|hugetlb_list
argument_list|)
expr_stmt|;
name|context
operator|->
name|ibv_ctx
operator|.
name|ops
operator|=
name|mlx5_ctx_ops
expr_stmt|;
name|verbs_set_ctx_op
argument_list|(
name|v_ctx
argument_list|,
name|create_qp_ex
argument_list|,
name|mlx5_create_qp_ex
argument_list|)
expr_stmt|;
name|verbs_set_ctx_op
argument_list|(
name|v_ctx
argument_list|,
name|open_xrcd
argument_list|,
name|mlx5_open_xrcd
argument_list|)
expr_stmt|;
name|verbs_set_ctx_op
argument_list|(
name|v_ctx
argument_list|,
name|close_xrcd
argument_list|,
name|mlx5_close_xrcd
argument_list|)
expr_stmt|;
name|verbs_set_ctx_op
argument_list|(
name|v_ctx
argument_list|,
name|create_srq_ex
argument_list|,
name|mlx5_create_srq_ex
argument_list|)
expr_stmt|;
name|verbs_set_ctx_op
argument_list|(
name|v_ctx
argument_list|,
name|get_srq_num
argument_list|,
name|mlx5_get_srq_num
argument_list|)
expr_stmt|;
name|verbs_set_ctx_op
argument_list|(
name|v_ctx
argument_list|,
name|query_device_ex
argument_list|,
name|mlx5_query_device_ex
argument_list|)
expr_stmt|;
name|verbs_set_ctx_op
argument_list|(
name|v_ctx
argument_list|,
name|query_rt_values
argument_list|,
name|mlx5_query_rt_values
argument_list|)
expr_stmt|;
name|verbs_set_ctx_op
argument_list|(
name|v_ctx
argument_list|,
name|ibv_create_flow
argument_list|,
name|ibv_cmd_create_flow
argument_list|)
expr_stmt|;
name|verbs_set_ctx_op
argument_list|(
name|v_ctx
argument_list|,
name|ibv_destroy_flow
argument_list|,
name|ibv_cmd_destroy_flow
argument_list|)
expr_stmt|;
name|verbs_set_ctx_op
argument_list|(
name|v_ctx
argument_list|,
name|create_cq_ex
argument_list|,
name|mlx5_create_cq_ex
argument_list|)
expr_stmt|;
name|verbs_set_ctx_op
argument_list|(
name|v_ctx
argument_list|,
name|create_wq
argument_list|,
name|mlx5_create_wq
argument_list|)
expr_stmt|;
name|verbs_set_ctx_op
argument_list|(
name|v_ctx
argument_list|,
name|modify_wq
argument_list|,
name|mlx5_modify_wq
argument_list|)
expr_stmt|;
name|verbs_set_ctx_op
argument_list|(
name|v_ctx
argument_list|,
name|destroy_wq
argument_list|,
name|mlx5_destroy_wq
argument_list|)
expr_stmt|;
name|verbs_set_ctx_op
argument_list|(
name|v_ctx
argument_list|,
name|create_rwq_ind_table
argument_list|,
name|mlx5_create_rwq_ind_table
argument_list|)
expr_stmt|;
name|verbs_set_ctx_op
argument_list|(
name|v_ctx
argument_list|,
name|destroy_rwq_ind_table
argument_list|,
name|mlx5_destroy_rwq_ind_table
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|device_attr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|device_attr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mlx5_query_device_ex
argument_list|(
name|ctx
argument_list|,
name|NULL
argument_list|,
operator|&
name|device_attr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ibv_device_attr_ex
argument_list|)
argument_list|)
condition|)
block|{
name|context
operator|->
name|cached_device_cap_flags
operator|=
name|device_attr
operator|.
name|orig_attr
operator|.
name|device_cap_flags
expr_stmt|;
name|context
operator|->
name|atomic_cap
operator|=
name|device_attr
operator|.
name|orig_attr
operator|.
name|atomic_cap
expr_stmt|;
name|context
operator|->
name|cached_tso_caps
operator|=
name|device_attr
operator|.
name|tso_caps
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|min
argument_list|(
name|MLX5_MAX_PORTS_NUM
argument_list|,
name|context
operator|->
name|num_ports
argument_list|)
condition|;
operator|++
name|j
control|)
block|{
name|memset
argument_list|(
operator|&
name|port_attr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|port_attr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mlx5_query_port
argument_list|(
name|ctx
argument_list|,
name|j
operator|+
literal|1
argument_list|,
operator|&
name|port_attr
argument_list|)
condition|)
name|context
operator|->
name|cached_link_layer
index|[
name|j
index|]
operator|=
name|port_attr
operator|.
name|link_layer
expr_stmt|;
block|}
return|return
literal|0
return|;
name|err_free_bf
label|:
name|free
argument_list|(
name|context
operator|->
name|bfs
argument_list|)
expr_stmt|;
name|err_free
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MLX5_MAX_UARS
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|context
operator|->
name|uar
index|[
name|i
index|]
condition|)
name|munmap
argument_list|(
name|context
operator|->
name|uar
index|[
name|i
index|]
argument_list|,
name|page_size
argument_list|)
expr_stmt|;
block|}
name|close_debug_file
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|errno
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx5_cleanup_context
parameter_list|(
name|struct
name|verbs_device
modifier|*
name|device
parameter_list|,
name|struct
name|ibv_context
modifier|*
name|ibctx
parameter_list|)
block|{
name|struct
name|mlx5_context
modifier|*
name|context
init|=
name|to_mctx
argument_list|(
name|ibctx
argument_list|)
decl_stmt|;
name|int
name|page_size
init|=
name|to_mdev
argument_list|(
name|ibctx
operator|->
name|device
argument_list|)
operator|->
name|page_size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|free
argument_list|(
name|context
operator|->
name|bfs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MLX5_MAX_UARS
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|context
operator|->
name|uar
index|[
name|i
index|]
condition|)
name|munmap
argument_list|(
name|context
operator|->
name|uar
index|[
name|i
index|]
argument_list|,
name|page_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|context
operator|->
name|hca_core_clock
condition|)
name|munmap
argument_list|(
name|context
operator|->
name|hca_core_clock
operator|-
name|context
operator|->
name|core_clock
operator|.
name|offset
argument_list|,
name|page_size
argument_list|)
expr_stmt|;
name|close_debug_file
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|verbs_device_ops
name|mlx5_dev_ops
init|=
block|{
operator|.
name|init_context
operator|=
name|mlx5_init_context
block|,
operator|.
name|uninit_context
operator|=
name|mlx5_cleanup_context
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|verbs_device
modifier|*
name|mlx5_driver_init
parameter_list|(
specifier|const
name|char
modifier|*
name|uverbs_sys_path
parameter_list|,
name|int
name|abi_version
parameter_list|)
block|{
name|char
name|value
index|[
literal|8
index|]
decl_stmt|;
name|struct
name|mlx5_device
modifier|*
name|dev
decl_stmt|;
name|unsigned
name|vendor
decl_stmt|,
name|device
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ibv_read_sysfs_file
argument_list|(
name|uverbs_sys_path
argument_list|,
literal|"device/vendor"
argument_list|,
name|value
argument_list|,
sizeof|sizeof
name|value
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|sscanf
argument_list|(
name|value
argument_list|,
literal|"%i"
argument_list|,
operator|&
name|vendor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibv_read_sysfs_file
argument_list|(
name|uverbs_sys_path
argument_list|,
literal|"device/device"
argument_list|,
name|value
argument_list|,
sizeof|sizeof
name|value
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|sscanf
argument_list|(
name|value
argument_list|,
literal|"%i"
argument_list|,
operator|&
name|device
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|hca_table
operator|/
sizeof|sizeof
name|hca_table
index|[
literal|0
index|]
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|vendor
operator|==
name|hca_table
index|[
name|i
index|]
operator|.
name|vendor
operator|&&
name|device
operator|==
name|hca_table
index|[
name|i
index|]
operator|.
name|device
condition|)
goto|goto
name|found
goto|;
return|return
name|NULL
return|;
name|found
label|:
if|if
condition|(
name|abi_version
operator|<
name|MLX5_UVERBS_MIN_ABI_VERSION
operator|||
name|abi_version
operator|>
name|MLX5_UVERBS_MAX_ABI_VERSION
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|PFX
literal|"Fatal: ABI version %d of %s is not supported "
literal|"(min supported %d, max supported %d)\n"
argument_list|,
name|abi_version
argument_list|,
name|uverbs_sys_path
argument_list|,
name|MLX5_UVERBS_MIN_ABI_VERSION
argument_list|,
name|MLX5_UVERBS_MAX_ABI_VERSION
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|dev
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|PFX
literal|"Fatal: couldn't allocate device for %s\n"
argument_list|,
name|uverbs_sys_path
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|dev
operator|->
name|page_size
operator|=
name|sysconf
argument_list|(
name|_SC_PAGESIZE
argument_list|)
expr_stmt|;
name|dev
operator|->
name|driver_abi_ver
operator|=
name|abi_version
expr_stmt|;
name|dev
operator|->
name|verbs_dev
operator|.
name|ops
operator|=
operator|&
name|mlx5_dev_ops
expr_stmt|;
name|dev
operator|->
name|verbs_dev
operator|.
name|sz
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|dev
argument_list|)
expr_stmt|;
name|dev
operator|->
name|verbs_dev
operator|.
name|size_of_context
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx5_context
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ibv_context
argument_list|)
expr_stmt|;
return|return
operator|&
name|dev
operator|->
name|verbs_dev
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__attribute__
argument_list|(
argument|(constructor)
argument_list|)
name|void
name|mlx5_register_driver
argument_list|(
argument|void
argument_list|)
block|{
name|verbs_register_driver
argument_list|(
literal|"mlx5"
argument_list|,
name|mlx5_driver_init
argument_list|)
block|; }
end_expr_stmt

end_unit

