begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2017 Mellanox Technologies, Inc.  All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_MLX5DV_H_
end_ifndef

begin_define
define|#
directive|define
name|_MLX5DV_H_
end_define

begin_include
include|#
directive|include
file|<infiniband/types.h>
end_include

begin_comment
comment|/* For the __be64 type */
end_comment

begin_include
include|#
directive|include
file|<infiniband/endian.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__SSE3__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<emmintrin.h>
end_include

begin_include
include|#
directive|include
file|<tmmintrin.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(__SSE3__) */
end_comment

begin_include
include|#
directive|include
file|<infiniband/verbs.h>
end_include

begin_comment
comment|/* Always inline the functions */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|MLX5DV_ALWAYS_INLINE
value|inline __attribute__((always_inline))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MLX5DV_ALWAYS_INLINE
value|inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_enum
enum|enum
block|{
name|MLX5_RCV_DBR
init|=
literal|0
block|,
name|MLX5_SND_DBR
init|=
literal|1
block|, }
enum|;
end_enum

begin_enum
enum|enum
name|mlx5dv_context_comp_mask
block|{
name|MLX5DV_CONTEXT_MASK_CQE_COMPRESION
init|=
literal|1
operator|<<
literal|0
block|,
name|MLX5DV_CONTEXT_MASK_RESERVED
init|=
literal|1
operator|<<
literal|1
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|mlx5dv_cqe_comp_caps
block|{
name|uint32_t
name|max_num
decl_stmt|;
name|uint32_t
name|supported_format
decl_stmt|;
comment|/* enum mlx5dv_cqe_comp_res_format */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Direct verbs device-specific attributes  */
end_comment

begin_struct
struct|struct
name|mlx5dv_context
block|{
name|uint8_t
name|version
decl_stmt|;
name|uint64_t
name|flags
decl_stmt|;
name|uint64_t
name|comp_mask
decl_stmt|;
name|struct
name|mlx5dv_cqe_comp_caps
name|cqe_comp_caps
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|mlx5dv_context_flags
block|{
comment|/* 	 * This flag indicates if CQE version 0 or 1 is needed. 	 */
name|MLX5DV_CONTEXT_FLAGS_CQE_V1
init|=
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
name|MLX5DV_CONTEXT_FLAGS_MPW
init|=
operator|(
literal|1
operator|<<
literal|1
operator|)
block|, }
enum|;
end_enum

begin_enum
enum|enum
name|mlx5dv_cq_init_attr_mask
block|{
name|MLX5DV_CQ_INIT_ATTR_MASK_COMPRESSED_CQE
init|=
literal|1
operator|<<
literal|0
block|,
name|MLX5DV_CQ_INIT_ATTR_MASK_RESERVED
init|=
literal|1
operator|<<
literal|1
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|mlx5dv_cq_init_attr
block|{
name|uint64_t
name|comp_mask
decl_stmt|;
comment|/* Use enum mlx5dv_cq_init_attr_mask */
name|uint8_t
name|cqe_comp_res_format
decl_stmt|;
comment|/* Use enum mlx5dv_cqe_comp_res_format */
block|}
struct|;
end_struct

begin_function_decl
name|struct
name|ibv_cq_ex
modifier|*
name|mlx5dv_create_cq
parameter_list|(
name|struct
name|ibv_context
modifier|*
name|context
parameter_list|,
name|struct
name|ibv_cq_init_attr_ex
modifier|*
name|cq_attr
parameter_list|,
name|struct
name|mlx5dv_cq_init_attr
modifier|*
name|mlx5_cq_attr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Most device capabilities are exported by ibv_query_device(...),  * but there is HW device-specific information which is important  * for data-path, but isn't provided.  *  * Return 0 on success.  */
end_comment

begin_function_decl
name|int
name|mlx5dv_query_device
parameter_list|(
name|struct
name|ibv_context
modifier|*
name|ctx_in
parameter_list|,
name|struct
name|mlx5dv_context
modifier|*
name|attrs_out
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|mlx5dv_qp
block|{
name|uint32_t
modifier|*
name|dbrec
decl_stmt|;
struct|struct
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|uint32_t
name|wqe_cnt
decl_stmt|;
name|uint32_t
name|stride
decl_stmt|;
block|}
name|sq
struct|;
struct|struct
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|uint32_t
name|wqe_cnt
decl_stmt|;
name|uint32_t
name|stride
decl_stmt|;
block|}
name|rq
struct|;
struct|struct
block|{
name|void
modifier|*
name|reg
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
block|}
name|bf
struct|;
name|uint64_t
name|comp_mask
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mlx5dv_cq
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|uint32_t
modifier|*
name|dbrec
decl_stmt|;
name|uint32_t
name|cqe_cnt
decl_stmt|;
name|uint32_t
name|cqe_size
decl_stmt|;
name|void
modifier|*
name|uar
decl_stmt|;
name|uint32_t
name|cqn
decl_stmt|;
name|uint64_t
name|comp_mask
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mlx5dv_srq
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|uint32_t
modifier|*
name|dbrec
decl_stmt|;
name|uint32_t
name|stride
decl_stmt|;
name|uint32_t
name|head
decl_stmt|;
name|uint32_t
name|tail
decl_stmt|;
name|uint64_t
name|comp_mask
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mlx5dv_rwq
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|uint32_t
modifier|*
name|dbrec
decl_stmt|;
name|uint32_t
name|wqe_cnt
decl_stmt|;
name|uint32_t
name|stride
decl_stmt|;
name|uint64_t
name|comp_mask
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mlx5dv_obj
block|{
struct|struct
block|{
name|struct
name|ibv_qp
modifier|*
name|in
decl_stmt|;
name|struct
name|mlx5dv_qp
modifier|*
name|out
decl_stmt|;
block|}
name|qp
struct|;
struct|struct
block|{
name|struct
name|ibv_cq
modifier|*
name|in
decl_stmt|;
name|struct
name|mlx5dv_cq
modifier|*
name|out
decl_stmt|;
block|}
name|cq
struct|;
struct|struct
block|{
name|struct
name|ibv_srq
modifier|*
name|in
decl_stmt|;
name|struct
name|mlx5dv_srq
modifier|*
name|out
decl_stmt|;
block|}
name|srq
struct|;
struct|struct
block|{
name|struct
name|ibv_wq
modifier|*
name|in
decl_stmt|;
name|struct
name|mlx5dv_rwq
modifier|*
name|out
decl_stmt|;
block|}
name|rwq
struct|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|mlx5dv_obj_type
block|{
name|MLX5DV_OBJ_QP
init|=
literal|1
operator|<<
literal|0
block|,
name|MLX5DV_OBJ_CQ
init|=
literal|1
operator|<<
literal|1
block|,
name|MLX5DV_OBJ_SRQ
init|=
literal|1
operator|<<
literal|2
block|,
name|MLX5DV_OBJ_RWQ
init|=
literal|1
operator|<<
literal|3
block|, }
enum|;
end_enum

begin_comment
comment|/*  * This function will initialize mlx5dv_xxx structs based on supplied type.  * The information for initialization is taken from ibv_xx structs supplied  * as part of input.  *  * Request information of CQ marks its owned by DV for all consumer index  * related actions.  *  * The initialization type can be combination of several types together.  *  * Return: 0 in case of success.  */
end_comment

begin_function_decl
name|int
name|mlx5dv_init_obj
parameter_list|(
name|struct
name|mlx5dv_obj
modifier|*
name|obj
parameter_list|,
name|uint64_t
name|obj_type
parameter_list|)
function_decl|;
end_function_decl

begin_enum
enum|enum
block|{
name|MLX5_OPCODE_NOP
init|=
literal|0x00
block|,
name|MLX5_OPCODE_SEND_INVAL
init|=
literal|0x01
block|,
name|MLX5_OPCODE_RDMA_WRITE
init|=
literal|0x08
block|,
name|MLX5_OPCODE_RDMA_WRITE_IMM
init|=
literal|0x09
block|,
name|MLX5_OPCODE_SEND
init|=
literal|0x0a
block|,
name|MLX5_OPCODE_SEND_IMM
init|=
literal|0x0b
block|,
name|MLX5_OPCODE_TSO
init|=
literal|0x0e
block|,
name|MLX5_OPCODE_RDMA_READ
init|=
literal|0x10
block|,
name|MLX5_OPCODE_ATOMIC_CS
init|=
literal|0x11
block|,
name|MLX5_OPCODE_ATOMIC_FA
init|=
literal|0x12
block|,
name|MLX5_OPCODE_ATOMIC_MASKED_CS
init|=
literal|0x14
block|,
name|MLX5_OPCODE_ATOMIC_MASKED_FA
init|=
literal|0x15
block|,
name|MLX5_OPCODE_FMR
init|=
literal|0x19
block|,
name|MLX5_OPCODE_LOCAL_INVAL
init|=
literal|0x1b
block|,
name|MLX5_OPCODE_CONFIG_CMD
init|=
literal|0x1f
block|,
name|MLX5_OPCODE_UMR
init|=
literal|0x25
block|, }
enum|;
end_enum

begin_comment
comment|/*  * CQE related part  */
end_comment

begin_enum
enum|enum
block|{
name|MLX5_INLINE_SCATTER_32
init|=
literal|0x4
block|,
name|MLX5_INLINE_SCATTER_64
init|=
literal|0x8
block|, }
enum|;
end_enum

begin_enum
enum|enum
block|{
name|MLX5_CQE_SYNDROME_LOCAL_LENGTH_ERR
init|=
literal|0x01
block|,
name|MLX5_CQE_SYNDROME_LOCAL_QP_OP_ERR
init|=
literal|0x02
block|,
name|MLX5_CQE_SYNDROME_LOCAL_PROT_ERR
init|=
literal|0x04
block|,
name|MLX5_CQE_SYNDROME_WR_FLUSH_ERR
init|=
literal|0x05
block|,
name|MLX5_CQE_SYNDROME_MW_BIND_ERR
init|=
literal|0x06
block|,
name|MLX5_CQE_SYNDROME_BAD_RESP_ERR
init|=
literal|0x10
block|,
name|MLX5_CQE_SYNDROME_LOCAL_ACCESS_ERR
init|=
literal|0x11
block|,
name|MLX5_CQE_SYNDROME_REMOTE_INVAL_REQ_ERR
init|=
literal|0x12
block|,
name|MLX5_CQE_SYNDROME_REMOTE_ACCESS_ERR
init|=
literal|0x13
block|,
name|MLX5_CQE_SYNDROME_REMOTE_OP_ERR
init|=
literal|0x14
block|,
name|MLX5_CQE_SYNDROME_TRANSPORT_RETRY_EXC_ERR
init|=
literal|0x15
block|,
name|MLX5_CQE_SYNDROME_RNR_RETRY_EXC_ERR
init|=
literal|0x16
block|,
name|MLX5_CQE_SYNDROME_REMOTE_ABORTED_ERR
init|=
literal|0x22
block|, }
enum|;
end_enum

begin_enum
enum|enum
block|{
name|MLX5_CQE_L2_OK
init|=
literal|1
operator|<<
literal|0
block|,
name|MLX5_CQE_L3_OK
init|=
literal|1
operator|<<
literal|1
block|,
name|MLX5_CQE_L4_OK
init|=
literal|1
operator|<<
literal|2
block|, }
enum|;
end_enum

begin_enum
enum|enum
block|{
name|MLX5_CQE_L3_HDR_TYPE_NONE
init|=
literal|0x0
block|,
name|MLX5_CQE_L3_HDR_TYPE_IPV6
init|=
literal|0x1
block|,
name|MLX5_CQE_L3_HDR_TYPE_IPV4
init|=
literal|0x2
block|, }
enum|;
end_enum

begin_enum
enum|enum
block|{
name|MLX5_CQE_OWNER_MASK
init|=
literal|1
block|,
name|MLX5_CQE_REQ
init|=
literal|0
block|,
name|MLX5_CQE_RESP_WR_IMM
init|=
literal|1
block|,
name|MLX5_CQE_RESP_SEND
init|=
literal|2
block|,
name|MLX5_CQE_RESP_SEND_IMM
init|=
literal|3
block|,
name|MLX5_CQE_RESP_SEND_INV
init|=
literal|4
block|,
name|MLX5_CQE_RESIZE_CQ
init|=
literal|5
block|,
name|MLX5_CQE_REQ_ERR
init|=
literal|13
block|,
name|MLX5_CQE_RESP_ERR
init|=
literal|14
block|,
name|MLX5_CQE_INVALID
init|=
literal|15
block|, }
enum|;
end_enum

begin_enum
enum|enum
block|{
name|MLX5_CQ_DOORBELL
init|=
literal|0x20
block|}
enum|;
end_enum

begin_enum
enum|enum
block|{
name|MLX5_CQ_DB_REQ_NOT_SOL
init|=
literal|1
operator|<<
literal|24
block|,
name|MLX5_CQ_DB_REQ_NOT
init|=
literal|0
operator|<<
literal|24
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|mlx5_err_cqe
block|{
name|uint8_t
name|rsvd0
index|[
literal|32
index|]
decl_stmt|;
name|uint32_t
name|srqn
decl_stmt|;
name|uint8_t
name|rsvd1
index|[
literal|18
index|]
decl_stmt|;
name|uint8_t
name|vendor_err_synd
decl_stmt|;
name|uint8_t
name|syndrome
decl_stmt|;
name|uint32_t
name|s_wqe_opcode_qpn
decl_stmt|;
name|uint16_t
name|wqe_counter
decl_stmt|;
name|uint8_t
name|signature
decl_stmt|;
name|uint8_t
name|op_own
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mlx5_cqe64
block|{
name|uint8_t
name|rsvd0
index|[
literal|17
index|]
decl_stmt|;
name|uint8_t
name|ml_path
decl_stmt|;
name|uint8_t
name|rsvd20
index|[
literal|4
index|]
decl_stmt|;
name|uint16_t
name|slid
decl_stmt|;
name|uint32_t
name|flags_rqpn
decl_stmt|;
name|uint8_t
name|hds_ip_ext
decl_stmt|;
name|uint8_t
name|l4_hdr_type_etc
decl_stmt|;
name|uint16_t
name|vlan_info
decl_stmt|;
name|uint32_t
name|srqn_uidx
decl_stmt|;
name|uint32_t
name|imm_inval_pkey
decl_stmt|;
name|uint8_t
name|rsvd40
index|[
literal|4
index|]
decl_stmt|;
name|uint32_t
name|byte_cnt
decl_stmt|;
name|__be64
name|timestamp
decl_stmt|;
name|uint32_t
name|sop_drop_qpn
decl_stmt|;
name|uint16_t
name|wqe_counter
decl_stmt|;
name|uint8_t
name|signature
decl_stmt|;
name|uint8_t
name|op_own
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|mlx5dv_cqe_comp_res_format
block|{
name|MLX5DV_CQE_RES_FORMAT_HASH
init|=
literal|1
operator|<<
literal|0
block|,
name|MLX5DV_CQE_RES_FORMAT_CSUM
init|=
literal|1
operator|<<
literal|1
block|,
name|MLX5DV_CQE_RES_FORMAT_RESERVED
init|=
literal|1
operator|<<
literal|2
block|, }
enum|;
end_enum

begin_function
specifier|static
name|MLX5DV_ALWAYS_INLINE
name|uint8_t
name|mlx5dv_get_cqe_owner
parameter_list|(
name|struct
name|mlx5_cqe64
modifier|*
name|cqe
parameter_list|)
block|{
return|return
name|cqe
operator|->
name|op_own
operator|&
literal|0x1
return|;
block|}
end_function

begin_function
specifier|static
name|MLX5DV_ALWAYS_INLINE
name|void
name|mlx5dv_set_cqe_owner
parameter_list|(
name|struct
name|mlx5_cqe64
modifier|*
name|cqe
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
name|cqe
operator|->
name|op_own
operator|=
operator|(
name|val
operator|&
literal|0x1
operator|)
operator||
operator|(
name|cqe
operator|->
name|op_own
operator|&
operator|~
literal|0x1
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Solicited event */
end_comment

begin_function
specifier|static
name|MLX5DV_ALWAYS_INLINE
name|uint8_t
name|mlx5dv_get_cqe_se
parameter_list|(
name|struct
name|mlx5_cqe64
modifier|*
name|cqe
parameter_list|)
block|{
return|return
operator|(
name|cqe
operator|->
name|op_own
operator|>>
literal|1
operator|)
operator|&
literal|0x1
return|;
block|}
end_function

begin_function
specifier|static
name|MLX5DV_ALWAYS_INLINE
name|uint8_t
name|mlx5dv_get_cqe_format
parameter_list|(
name|struct
name|mlx5_cqe64
modifier|*
name|cqe
parameter_list|)
block|{
return|return
operator|(
name|cqe
operator|->
name|op_own
operator|>>
literal|2
operator|)
operator|&
literal|0x3
return|;
block|}
end_function

begin_function
specifier|static
name|MLX5DV_ALWAYS_INLINE
name|uint8_t
name|mlx5dv_get_cqe_opcode
parameter_list|(
name|struct
name|mlx5_cqe64
modifier|*
name|cqe
parameter_list|)
block|{
return|return
name|cqe
operator|->
name|op_own
operator|>>
literal|4
return|;
block|}
end_function

begin_comment
comment|/*  * WQE related part  */
end_comment

begin_enum
enum|enum
block|{
name|MLX5_INVALID_LKEY
init|=
literal|0x100
block|, }
enum|;
end_enum

begin_enum
enum|enum
block|{
name|MLX5_EXTENDED_UD_AV
init|=
literal|0x80000000
block|, }
enum|;
end_enum

begin_enum
enum|enum
block|{
name|MLX5_WQE_CTRL_CQ_UPDATE
init|=
literal|2
operator|<<
literal|2
block|,
name|MLX5_WQE_CTRL_SOLICITED
init|=
literal|1
operator|<<
literal|1
block|,
name|MLX5_WQE_CTRL_FENCE
init|=
literal|4
operator|<<
literal|5
block|,
name|MLX5_WQE_CTRL_INITIATOR_SMALL_FENCE
init|=
literal|1
operator|<<
literal|5
block|, }
enum|;
end_enum

begin_enum
enum|enum
block|{
name|MLX5_SEND_WQE_BB
init|=
literal|64
block|,
name|MLX5_SEND_WQE_SHIFT
init|=
literal|6
block|, }
enum|;
end_enum

begin_enum
enum|enum
block|{
name|MLX5_INLINE_SEG
init|=
literal|0x80000000
block|, }
enum|;
end_enum

begin_enum
enum|enum
block|{
name|MLX5_ETH_WQE_L3_CSUM
init|=
operator|(
literal|1
operator|<<
literal|6
operator|)
block|,
name|MLX5_ETH_WQE_L4_CSUM
init|=
operator|(
literal|1
operator|<<
literal|7
operator|)
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|mlx5_wqe_srq_next_seg
block|{
name|uint8_t
name|rsvd0
index|[
literal|2
index|]
decl_stmt|;
name|uint16_t
name|next_wqe_index
decl_stmt|;
name|uint8_t
name|signature
decl_stmt|;
name|uint8_t
name|rsvd1
index|[
literal|11
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mlx5_wqe_data_seg
block|{
name|uint32_t
name|byte_count
decl_stmt|;
name|uint32_t
name|lkey
decl_stmt|;
name|uint64_t
name|addr
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mlx5_wqe_ctrl_seg
block|{
name|uint32_t
name|opmod_idx_opcode
decl_stmt|;
name|uint32_t
name|qpn_ds
decl_stmt|;
name|uint8_t
name|signature
decl_stmt|;
name|uint8_t
name|rsvd
index|[
literal|2
index|]
decl_stmt|;
name|uint8_t
name|fm_ce_se
decl_stmt|;
name|uint32_t
name|imm
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mlx5_wqe_av
block|{
union|union
block|{
struct|struct
block|{
name|uint32_t
name|qkey
decl_stmt|;
name|uint32_t
name|reserved
decl_stmt|;
block|}
name|qkey
struct|;
name|uint64_t
name|dc_key
decl_stmt|;
block|}
name|key
union|;
name|uint32_t
name|dqp_dct
decl_stmt|;
name|uint8_t
name|stat_rate_sl
decl_stmt|;
name|uint8_t
name|fl_mlid
decl_stmt|;
name|uint16_t
name|rlid
decl_stmt|;
name|uint8_t
name|reserved0
index|[
literal|4
index|]
decl_stmt|;
name|uint8_t
name|rmac
index|[
literal|6
index|]
decl_stmt|;
name|uint8_t
name|tclass
decl_stmt|;
name|uint8_t
name|hop_limit
decl_stmt|;
name|uint32_t
name|grh_gid_fl
decl_stmt|;
name|uint8_t
name|rgid
index|[
literal|16
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mlx5_wqe_datagram_seg
block|{
name|struct
name|mlx5_wqe_av
name|av
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mlx5_wqe_raddr_seg
block|{
name|uint64_t
name|raddr
decl_stmt|;
name|uint32_t
name|rkey
decl_stmt|;
name|uint32_t
name|reserved
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mlx5_wqe_atomic_seg
block|{
name|uint64_t
name|swap_add
decl_stmt|;
name|uint64_t
name|compare
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mlx5_wqe_inl_data_seg
block|{
name|uint32_t
name|byte_count
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mlx5_wqe_eth_seg
block|{
name|uint32_t
name|rsvd0
decl_stmt|;
name|uint8_t
name|cs_flags
decl_stmt|;
name|uint8_t
name|rsvd1
decl_stmt|;
name|uint16_t
name|mss
decl_stmt|;
name|uint32_t
name|rsvd2
decl_stmt|;
name|uint16_t
name|inline_hdr_sz
decl_stmt|;
name|uint8_t
name|inline_hdr_start
index|[
literal|2
index|]
decl_stmt|;
name|uint8_t
name|inline_hdr
index|[
literal|16
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Control segment - contains some control information for the current WQE.  *  * Output:  *	seg	  - control segment to be filled  * Input:  *	pi	  - WQEBB number of the first block of this WQE.  *		    This number should wrap at 0xffff, regardless of  *		    size of the WQ.  *	opcode	  - Opcode of this WQE. Encodes the type of operation  *		    to be executed on the QP.  *	opmod	  - Opcode modifier.  *	qp_num	  - QP/SQ number this WQE is posted to.  *	fm_ce_se  - FM (fence mode), CE (completion and event mode)  *		    and SE (solicited event).  *	ds	  - WQE size in octowords (16-byte units). DS accounts for all  *		    the segments in the WQE as summarized in WQE construction.  *	signature - WQE signature.  *	imm	  - Immediate data/Invalidation key/UMR mkey.  */
end_comment

begin_function
specifier|static
name|MLX5DV_ALWAYS_INLINE
name|void
name|mlx5dv_set_ctrl_seg
parameter_list|(
name|struct
name|mlx5_wqe_ctrl_seg
modifier|*
name|seg
parameter_list|,
name|uint16_t
name|pi
parameter_list|,
name|uint8_t
name|opcode
parameter_list|,
name|uint8_t
name|opmod
parameter_list|,
name|uint32_t
name|qp_num
parameter_list|,
name|uint8_t
name|fm_ce_se
parameter_list|,
name|uint8_t
name|ds
parameter_list|,
name|uint8_t
name|signature
parameter_list|,
name|uint32_t
name|imm
parameter_list|)
block|{
name|seg
operator|->
name|opmod_idx_opcode
operator|=
name|htobe32
argument_list|(
operator|(
operator|(
name|uint32_t
operator|)
name|opmod
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|uint32_t
operator|)
name|pi
operator|<<
literal|8
operator|)
operator||
name|opcode
argument_list|)
expr_stmt|;
name|seg
operator|->
name|qpn_ds
operator|=
name|htobe32
argument_list|(
operator|(
name|qp_num
operator|<<
literal|8
operator|)
operator||
name|ds
argument_list|)
expr_stmt|;
name|seg
operator|->
name|fm_ce_se
operator|=
name|fm_ce_se
expr_stmt|;
name|seg
operator|->
name|signature
operator|=
name|signature
expr_stmt|;
comment|/* 	 * The caller should prepare "imm" in advance based on WR opcode. 	 * For IBV_WR_SEND_WITH_IMM and IBV_WR_RDMA_WRITE_WITH_IMM, 	 * the "imm" should be assigned as is. 	 * For the IBV_WR_SEND_WITH_INV, it should be htobe32(imm). 	 */
name|seg
operator|->
name|imm
operator|=
name|imm
expr_stmt|;
block|}
end_function

begin_comment
comment|/* x86 optimized version of mlx5dv_set_ctrl_seg()  *  * This is useful when doing calculations on large data sets  * for parallel calculations.  *  * It doesn't suit for serialized algorithms.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__SSE3__
argument_list|)
end_if

begin_function
specifier|static
name|MLX5DV_ALWAYS_INLINE
name|void
name|mlx5dv_x86_set_ctrl_seg
parameter_list|(
name|struct
name|mlx5_wqe_ctrl_seg
modifier|*
name|seg
parameter_list|,
name|uint16_t
name|pi
parameter_list|,
name|uint8_t
name|opcode
parameter_list|,
name|uint8_t
name|opmod
parameter_list|,
name|uint32_t
name|qp_num
parameter_list|,
name|uint8_t
name|fm_ce_se
parameter_list|,
name|uint8_t
name|ds
parameter_list|,
name|uint8_t
name|signature
parameter_list|,
name|uint32_t
name|imm
parameter_list|)
block|{
name|__m128i
name|val
init|=
name|_mm_set_epi32
argument_list|(
name|imm
argument_list|,
name|qp_num
argument_list|,
operator|(
name|ds
operator|<<
literal|16
operator|)
operator||
name|pi
argument_list|,
operator|(
name|signature
operator|<<
literal|24
operator|)
operator||
operator|(
name|opcode
operator|<<
literal|16
operator|)
operator||
operator|(
name|opmod
operator|<<
literal|8
operator|)
operator||
name|fm_ce_se
argument_list|)
decl_stmt|;
name|__m128i
name|mask
init|=
name|_mm_set_epi8
argument_list|(
literal|15
argument_list|,
literal|14
argument_list|,
literal|13
argument_list|,
literal|12
argument_list|,
comment|/* immediate */
literal|0
argument_list|,
comment|/* signal/fence_mode */
literal|0x80
argument_list|,
literal|0x80
argument_list|,
comment|/* reserved */
literal|3
argument_list|,
comment|/* signature */
literal|6
argument_list|,
comment|/* data size */
literal|8
argument_list|,
literal|9
argument_list|,
literal|10
argument_list|,
comment|/* QP num */
literal|2
argument_list|,
comment|/* opcode */
literal|4
argument_list|,
literal|5
argument_list|,
comment|/* sw_pi in BE */
literal|1
comment|/* opmod */
argument_list|)
decl_stmt|;
operator|*
operator|(
name|__m128i
operator|*
operator|)
name|seg
operator|=
name|_mm_shuffle_epi8
argument_list|(
name|val
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(__SSE3__) */
end_comment

begin_comment
comment|/*  * Datagram Segment - contains address information required in order  * to form a datagram message.  *  * Output:  *	seg		- datagram segment to be filled.  * Input:  *	key		- Q_key/access key.  *	dqp_dct		- Destination QP number for UD and DCT for DC.  *	ext		- Address vector extension.  *	stat_rate_sl	- Maximum static rate control, SL/ethernet priority.  *	fl_mlid		- Force loopback and source LID for IB.  *	rlid		- Remote LID  *	rmac		- Remote MAC  *	tclass		- GRH tclass/IPv6 tclass/IPv4 ToS  *	hop_limit	- GRH hop limit/IPv6 hop limit/IPv4 TTL  *	grh_gid_fi	- GRH, source GID address and IPv6 flow label.  *	rgid		- Remote GID/IP address.  */
end_comment

begin_function
specifier|static
name|MLX5DV_ALWAYS_INLINE
name|void
name|mlx5dv_set_dgram_seg
parameter_list|(
name|struct
name|mlx5_wqe_datagram_seg
modifier|*
name|seg
parameter_list|,
name|uint64_t
name|key
parameter_list|,
name|uint32_t
name|dqp_dct
parameter_list|,
name|uint8_t
name|ext
parameter_list|,
name|uint8_t
name|stat_rate_sl
parameter_list|,
name|uint8_t
name|fl_mlid
parameter_list|,
name|uint16_t
name|rlid
parameter_list|,
name|uint8_t
modifier|*
name|rmac
parameter_list|,
name|uint8_t
name|tclass
parameter_list|,
name|uint8_t
name|hop_limit
parameter_list|,
name|uint32_t
name|grh_gid_fi
parameter_list|,
name|uint8_t
modifier|*
name|rgid
parameter_list|)
block|{
comment|/* Always put 64 bits, in q_key, the reserved part will be 0 */
name|seg
operator|->
name|av
operator|.
name|key
operator|.
name|dc_key
operator|=
name|htobe64
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|seg
operator|->
name|av
operator|.
name|dqp_dct
operator|=
name|htobe32
argument_list|(
operator|(
operator|(
name|uint32_t
operator|)
name|ext
operator|<<
literal|31
operator|)
operator||
name|dqp_dct
argument_list|)
expr_stmt|;
name|seg
operator|->
name|av
operator|.
name|stat_rate_sl
operator|=
name|stat_rate_sl
expr_stmt|;
name|seg
operator|->
name|av
operator|.
name|fl_mlid
operator|=
name|fl_mlid
expr_stmt|;
name|seg
operator|->
name|av
operator|.
name|rlid
operator|=
name|htobe16
argument_list|(
name|rlid
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|seg
operator|->
name|av
operator|.
name|rmac
argument_list|,
name|rmac
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|seg
operator|->
name|av
operator|.
name|tclass
operator|=
name|tclass
expr_stmt|;
name|seg
operator|->
name|av
operator|.
name|hop_limit
operator|=
name|hop_limit
expr_stmt|;
name|seg
operator|->
name|av
operator|.
name|grh_gid_fl
operator|=
name|htobe32
argument_list|(
name|grh_gid_fi
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|seg
operator|->
name|av
operator|.
name|rgid
argument_list|,
name|rgid
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Data Segments - contain pointers and a byte count for the scatter/gather list.  * They can optionally contain data, which will save a memory read access for  * gather Work Requests.  */
end_comment

begin_function
specifier|static
name|MLX5DV_ALWAYS_INLINE
name|void
name|mlx5dv_set_data_seg
parameter_list|(
name|struct
name|mlx5_wqe_data_seg
modifier|*
name|seg
parameter_list|,
name|uint32_t
name|length
parameter_list|,
name|uint32_t
name|lkey
parameter_list|,
name|uintptr_t
name|address
parameter_list|)
block|{
name|seg
operator|->
name|byte_count
operator|=
name|htobe32
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|seg
operator|->
name|lkey
operator|=
name|htobe32
argument_list|(
name|lkey
argument_list|)
expr_stmt|;
name|seg
operator|->
name|addr
operator|=
name|htobe64
argument_list|(
name|address
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * x86 optimized version of mlx5dv_set_data_seg()  *  * This is useful when doing calculations on large data sets  * for parallel calculations.  *  * It doesn't suit for serialized algorithms.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__SSE3__
argument_list|)
end_if

begin_function
specifier|static
name|MLX5DV_ALWAYS_INLINE
name|void
name|mlx5dv_x86_set_data_seg
parameter_list|(
name|struct
name|mlx5_wqe_data_seg
modifier|*
name|seg
parameter_list|,
name|uint32_t
name|length
parameter_list|,
name|uint32_t
name|lkey
parameter_list|,
name|uintptr_t
name|address
parameter_list|)
block|{
name|__m128i
name|val
init|=
name|_mm_set_epi32
argument_list|(
operator|(
name|uint32_t
operator|)
name|address
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|address
operator|>>
literal|32
argument_list|)
argument_list|,
name|lkey
argument_list|,
name|length
argument_list|)
decl_stmt|;
name|__m128i
name|mask
init|=
name|_mm_set_epi8
argument_list|(
literal|12
argument_list|,
literal|13
argument_list|,
literal|14
argument_list|,
literal|15
argument_list|,
comment|/* local address low */
literal|8
argument_list|,
literal|9
argument_list|,
literal|10
argument_list|,
literal|11
argument_list|,
comment|/* local address high */
literal|4
argument_list|,
literal|5
argument_list|,
literal|6
argument_list|,
literal|7
argument_list|,
comment|/* l_key */
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|3
comment|/* byte count */
argument_list|)
decl_stmt|;
operator|*
operator|(
name|__m128i
operator|*
operator|)
name|seg
operator|=
name|_mm_shuffle_epi8
argument_list|(
name|val
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(__SSE3__) */
end_comment

begin_comment
comment|/*  * Eth Segment - contains packet headers and information for stateless L2, L3, L4 offloading.  *  * Output:  *	 seg		 - Eth segment to be filled.  * Input:  *	cs_flags	 - l3cs/l3cs_inner/l4cs/l4cs_inner.  *	mss		 - Maximum segment size. For TSO WQEs, the number of bytes  *			   in the TCP payload to be transmitted in each packet. Must  *			   be 0 on non TSO WQEs.  *	inline_hdr_sz	 - Length of the inlined packet headers.  *	inline_hdr_start - Inlined packet header.  */
end_comment

begin_function
specifier|static
name|MLX5DV_ALWAYS_INLINE
name|void
name|mlx5dv_set_eth_seg
parameter_list|(
name|struct
name|mlx5_wqe_eth_seg
modifier|*
name|seg
parameter_list|,
name|uint8_t
name|cs_flags
parameter_list|,
name|uint16_t
name|mss
parameter_list|,
name|uint16_t
name|inline_hdr_sz
parameter_list|,
name|uint8_t
modifier|*
name|inline_hdr_start
parameter_list|)
block|{
name|seg
operator|->
name|cs_flags
operator|=
name|cs_flags
expr_stmt|;
name|seg
operator|->
name|mss
operator|=
name|htobe16
argument_list|(
name|mss
argument_list|)
expr_stmt|;
name|seg
operator|->
name|inline_hdr_sz
operator|=
name|htobe16
argument_list|(
name|inline_hdr_sz
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|seg
operator|->
name|inline_hdr_start
argument_list|,
name|inline_hdr_start
argument_list|,
name|inline_hdr_sz
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _MLX5DV_H_ */
end_comment

end_unit

