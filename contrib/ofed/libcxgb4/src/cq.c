begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2006-2014 Chelsio, Inc. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<infiniband/opcode.h>
end_include

begin_include
include|#
directive|include
file|"libcxgb4.h"
end_include

begin_include
include|#
directive|include
file|"cxgb4-abi.h"
end_include

begin_function
specifier|static
name|void
name|insert_recv_cqe
parameter_list|(
name|struct
name|t4_wq
modifier|*
name|wq
parameter_list|,
name|struct
name|t4_cq
modifier|*
name|cq
parameter_list|)
block|{
name|struct
name|t4_cqe
name|cqe
decl_stmt|;
name|PDBG
argument_list|(
literal|"%s wq %p cq %p sw_cidx %u sw_pidx %u\n"
argument_list|,
name|__func__
argument_list|,
name|wq
argument_list|,
name|cq
argument_list|,
name|cq
operator|->
name|sw_cidx
argument_list|,
name|cq
operator|->
name|sw_pidx
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cqe
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cqe
argument_list|)
argument_list|)
expr_stmt|;
name|cqe
operator|.
name|header
operator|=
name|cpu_to_be32
argument_list|(
name|V_CQE_STATUS
argument_list|(
name|T4_ERR_SWFLUSH
argument_list|)
operator||
name|V_CQE_OPCODE
argument_list|(
name|FW_RI_SEND
argument_list|)
operator||
name|V_CQE_TYPE
argument_list|(
literal|0
argument_list|)
operator||
name|V_CQE_SWCQE
argument_list|(
literal|1
argument_list|)
operator||
name|V_CQE_QPID
argument_list|(
name|wq
operator|->
name|sq
operator|.
name|qid
argument_list|)
argument_list|)
expr_stmt|;
name|cqe
operator|.
name|bits_type_ts
operator|=
name|cpu_to_be64
argument_list|(
name|V_CQE_GENBIT
argument_list|(
operator|(
name|u64
operator|)
name|cq
operator|->
name|gen
argument_list|)
argument_list|)
expr_stmt|;
name|cq
operator|->
name|sw_queue
index|[
name|cq
operator|->
name|sw_pidx
index|]
operator|=
name|cqe
expr_stmt|;
name|t4_swcq_produce
argument_list|(
name|cq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|c4iw_flush_rq
parameter_list|(
name|struct
name|t4_wq
modifier|*
name|wq
parameter_list|,
name|struct
name|t4_cq
modifier|*
name|cq
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|flushed
init|=
literal|0
decl_stmt|;
name|int
name|in_use
init|=
name|wq
operator|->
name|rq
operator|.
name|in_use
operator|-
name|count
decl_stmt|;
name|BUG_ON
argument_list|(
name|in_use
operator|<
literal|0
argument_list|)
expr_stmt|;
name|PDBG
argument_list|(
literal|"%s wq %p cq %p rq.in_use %u skip count %u\n"
argument_list|,
name|__func__
argument_list|,
name|wq
argument_list|,
name|cq
argument_list|,
name|wq
operator|->
name|rq
operator|.
name|in_use
argument_list|,
name|count
argument_list|)
expr_stmt|;
while|while
condition|(
name|in_use
operator|--
condition|)
block|{
name|insert_recv_cqe
argument_list|(
name|wq
argument_list|,
name|cq
argument_list|)
expr_stmt|;
name|flushed
operator|++
expr_stmt|;
block|}
return|return
name|flushed
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_sq_cqe
parameter_list|(
name|struct
name|t4_wq
modifier|*
name|wq
parameter_list|,
name|struct
name|t4_cq
modifier|*
name|cq
parameter_list|,
name|struct
name|t4_swsqe
modifier|*
name|swcqe
parameter_list|)
block|{
name|struct
name|t4_cqe
name|cqe
decl_stmt|;
name|PDBG
argument_list|(
literal|"%s wq %p cq %p sw_cidx %u sw_pidx %u\n"
argument_list|,
name|__func__
argument_list|,
name|wq
argument_list|,
name|cq
argument_list|,
name|cq
operator|->
name|sw_cidx
argument_list|,
name|cq
operator|->
name|sw_pidx
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cqe
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cqe
argument_list|)
argument_list|)
expr_stmt|;
name|cqe
operator|.
name|header
operator|=
name|cpu_to_be32
argument_list|(
name|V_CQE_STATUS
argument_list|(
name|T4_ERR_SWFLUSH
argument_list|)
operator||
name|V_CQE_OPCODE
argument_list|(
name|swcqe
operator|->
name|opcode
argument_list|)
operator||
name|V_CQE_TYPE
argument_list|(
literal|1
argument_list|)
operator||
name|V_CQE_SWCQE
argument_list|(
literal|1
argument_list|)
operator||
name|V_CQE_QPID
argument_list|(
name|wq
operator|->
name|sq
operator|.
name|qid
argument_list|)
argument_list|)
expr_stmt|;
name|CQE_WRID_SQ_IDX
argument_list|(
operator|&
name|cqe
argument_list|)
operator|=
name|swcqe
operator|->
name|idx
expr_stmt|;
name|cqe
operator|.
name|bits_type_ts
operator|=
name|cpu_to_be64
argument_list|(
name|V_CQE_GENBIT
argument_list|(
operator|(
name|u64
operator|)
name|cq
operator|->
name|gen
argument_list|)
argument_list|)
expr_stmt|;
name|cq
operator|->
name|sw_queue
index|[
name|cq
operator|->
name|sw_pidx
index|]
operator|=
name|cqe
expr_stmt|;
name|t4_swcq_produce
argument_list|(
name|cq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|advance_oldest_read
parameter_list|(
name|struct
name|t4_wq
modifier|*
name|wq
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|c4iw_flush_sq
parameter_list|(
name|struct
name|c4iw_qp
modifier|*
name|qhp
parameter_list|)
block|{
name|unsigned
name|short
name|flushed
init|=
literal|0
decl_stmt|;
name|struct
name|t4_wq
modifier|*
name|wq
init|=
operator|&
name|qhp
operator|->
name|wq
decl_stmt|;
name|struct
name|c4iw_cq
modifier|*
name|chp
init|=
name|to_c4iw_cq
argument_list|(
name|qhp
operator|->
name|ibv_qp
operator|.
name|send_cq
argument_list|)
decl_stmt|;
name|struct
name|t4_cq
modifier|*
name|cq
init|=
operator|&
name|chp
operator|->
name|cq
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|struct
name|t4_swsqe
modifier|*
name|swsqe
decl_stmt|;
if|if
condition|(
name|wq
operator|->
name|sq
operator|.
name|flush_cidx
operator|==
operator|-
literal|1
condition|)
name|wq
operator|->
name|sq
operator|.
name|flush_cidx
operator|=
name|wq
operator|->
name|sq
operator|.
name|cidx
expr_stmt|;
name|idx
operator|=
name|wq
operator|->
name|sq
operator|.
name|flush_cidx
expr_stmt|;
name|BUG_ON
argument_list|(
name|idx
operator|>=
name|wq
operator|->
name|sq
operator|.
name|size
argument_list|)
expr_stmt|;
while|while
condition|(
name|idx
operator|!=
name|wq
operator|->
name|sq
operator|.
name|pidx
condition|)
block|{
name|swsqe
operator|=
operator|&
name|wq
operator|->
name|sq
operator|.
name|sw_sq
index|[
name|idx
index|]
expr_stmt|;
name|BUG_ON
argument_list|(
name|swsqe
operator|->
name|flushed
argument_list|)
expr_stmt|;
name|swsqe
operator|->
name|flushed
operator|=
literal|1
expr_stmt|;
name|insert_sq_cqe
argument_list|(
name|wq
argument_list|,
name|cq
argument_list|,
name|swsqe
argument_list|)
expr_stmt|;
if|if
condition|(
name|wq
operator|->
name|sq
operator|.
name|oldest_read
operator|==
name|swsqe
condition|)
block|{
name|BUG_ON
argument_list|(
name|swsqe
operator|->
name|opcode
operator|!=
name|FW_RI_READ_REQ
argument_list|)
expr_stmt|;
name|advance_oldest_read
argument_list|(
name|wq
argument_list|)
expr_stmt|;
block|}
name|flushed
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|idx
operator|==
name|wq
operator|->
name|sq
operator|.
name|size
condition|)
name|idx
operator|=
literal|0
expr_stmt|;
block|}
name|wq
operator|->
name|sq
operator|.
name|flush_cidx
operator|+=
name|flushed
expr_stmt|;
if|if
condition|(
name|wq
operator|->
name|sq
operator|.
name|flush_cidx
operator|>=
name|wq
operator|->
name|sq
operator|.
name|size
condition|)
name|wq
operator|->
name|sq
operator|.
name|flush_cidx
operator|-=
name|wq
operator|->
name|sq
operator|.
name|size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flush_completed_wrs
parameter_list|(
name|struct
name|t4_wq
modifier|*
name|wq
parameter_list|,
name|struct
name|t4_cq
modifier|*
name|cq
parameter_list|)
block|{
name|struct
name|t4_swsqe
modifier|*
name|swsqe
decl_stmt|;
name|unsigned
name|short
name|cidx
decl_stmt|;
if|if
condition|(
name|wq
operator|->
name|sq
operator|.
name|flush_cidx
operator|==
operator|-
literal|1
condition|)
name|wq
operator|->
name|sq
operator|.
name|flush_cidx
operator|=
name|wq
operator|->
name|sq
operator|.
name|cidx
expr_stmt|;
name|cidx
operator|=
name|wq
operator|->
name|sq
operator|.
name|flush_cidx
expr_stmt|;
name|BUG_ON
argument_list|(
name|cidx
operator|>=
name|wq
operator|->
name|sq
operator|.
name|size
argument_list|)
expr_stmt|;
while|while
condition|(
name|cidx
operator|!=
name|wq
operator|->
name|sq
operator|.
name|pidx
condition|)
block|{
name|swsqe
operator|=
operator|&
name|wq
operator|->
name|sq
operator|.
name|sw_sq
index|[
name|cidx
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|swsqe
operator|->
name|signaled
condition|)
block|{
if|if
condition|(
operator|++
name|cidx
operator|==
name|wq
operator|->
name|sq
operator|.
name|size
condition|)
name|cidx
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|swsqe
operator|->
name|complete
condition|)
block|{
name|BUG_ON
argument_list|(
name|swsqe
operator|->
name|flushed
argument_list|)
expr_stmt|;
comment|/* 			 * Insert this completed cqe into the swcq. 			 */
name|PDBG
argument_list|(
literal|"%s moving cqe into swcq sq idx %u cq idx %u\n"
argument_list|,
name|__func__
argument_list|,
name|cidx
argument_list|,
name|cq
operator|->
name|sw_pidx
argument_list|)
expr_stmt|;
name|swsqe
operator|->
name|cqe
operator|.
name|header
operator||=
name|htonl
argument_list|(
name|V_CQE_SWCQE
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|cq
operator|->
name|sw_queue
index|[
name|cq
operator|->
name|sw_pidx
index|]
operator|=
name|swsqe
operator|->
name|cqe
expr_stmt|;
name|t4_swcq_produce
argument_list|(
name|cq
argument_list|)
expr_stmt|;
name|swsqe
operator|->
name|flushed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|cidx
operator|==
name|wq
operator|->
name|sq
operator|.
name|size
condition|)
name|cidx
operator|=
literal|0
expr_stmt|;
name|wq
operator|->
name|sq
operator|.
name|flush_cidx
operator|=
name|cidx
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|create_read_req_cqe
parameter_list|(
name|struct
name|t4_wq
modifier|*
name|wq
parameter_list|,
name|struct
name|t4_cqe
modifier|*
name|hw_cqe
parameter_list|,
name|struct
name|t4_cqe
modifier|*
name|read_cqe
parameter_list|)
block|{
name|read_cqe
operator|->
name|u
operator|.
name|scqe
operator|.
name|cidx
operator|=
name|wq
operator|->
name|sq
operator|.
name|oldest_read
operator|->
name|idx
expr_stmt|;
name|read_cqe
operator|->
name|len
operator|=
name|ntohl
argument_list|(
name|wq
operator|->
name|sq
operator|.
name|oldest_read
operator|->
name|read_len
argument_list|)
expr_stmt|;
name|read_cqe
operator|->
name|header
operator|=
name|htonl
argument_list|(
name|V_CQE_QPID
argument_list|(
name|CQE_QPID
argument_list|(
name|hw_cqe
argument_list|)
argument_list|)
operator||
name|V_CQE_SWCQE
argument_list|(
name|SW_CQE
argument_list|(
name|hw_cqe
argument_list|)
argument_list|)
operator||
name|V_CQE_OPCODE
argument_list|(
name|FW_RI_READ_REQ
argument_list|)
operator||
name|V_CQE_TYPE
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|read_cqe
operator|->
name|bits_type_ts
operator|=
name|hw_cqe
operator|->
name|bits_type_ts
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|advance_oldest_read
parameter_list|(
name|struct
name|t4_wq
modifier|*
name|wq
parameter_list|)
block|{
name|u32
name|rptr
init|=
name|wq
operator|->
name|sq
operator|.
name|oldest_read
operator|-
name|wq
operator|->
name|sq
operator|.
name|sw_sq
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|rptr
operator|==
name|wq
operator|->
name|sq
operator|.
name|size
condition|)
name|rptr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|rptr
operator|!=
name|wq
operator|->
name|sq
operator|.
name|pidx
condition|)
block|{
name|wq
operator|->
name|sq
operator|.
name|oldest_read
operator|=
operator|&
name|wq
operator|->
name|sq
operator|.
name|sw_sq
index|[
name|rptr
index|]
expr_stmt|;
if|if
condition|(
name|wq
operator|->
name|sq
operator|.
name|oldest_read
operator|->
name|opcode
operator|==
name|FW_RI_READ_REQ
condition|)
return|return;
if|if
condition|(
operator|++
name|rptr
operator|==
name|wq
operator|->
name|sq
operator|.
name|size
condition|)
name|rptr
operator|=
literal|0
expr_stmt|;
block|}
name|wq
operator|->
name|sq
operator|.
name|oldest_read
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Move all CQEs from the HWCQ into the SWCQ.  * Deal with out-of-order and/or completions that complete  * prior unsignalled WRs.  */
end_comment

begin_function
name|void
name|c4iw_flush_hw_cq
parameter_list|(
name|struct
name|c4iw_cq
modifier|*
name|chp
parameter_list|)
block|{
name|struct
name|t4_cqe
modifier|*
name|hw_cqe
decl_stmt|,
modifier|*
name|swcqe
decl_stmt|,
name|read_cqe
decl_stmt|;
name|struct
name|c4iw_qp
modifier|*
name|qhp
decl_stmt|;
name|struct
name|t4_swsqe
modifier|*
name|swsqe
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|PDBG
argument_list|(
literal|"%s  cqid 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chp
operator|->
name|cq
operator|.
name|cqid
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_next_hw_cqe
argument_list|(
operator|&
name|chp
operator|->
name|cq
argument_list|,
operator|&
name|hw_cqe
argument_list|)
expr_stmt|;
comment|/* 	 * This logic is similar to poll_cq(), but not quite the same 	 * unfortunately.  Need to move pertinent HW CQEs to the SW CQ but 	 * also do any translation magic that poll_cq() normally does. 	 */
while|while
condition|(
operator|!
name|ret
condition|)
block|{
name|qhp
operator|=
name|get_qhp
argument_list|(
name|chp
operator|->
name|rhp
argument_list|,
name|CQE_QPID
argument_list|(
name|hw_cqe
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * drop CQEs with no associated QP 		 */
if|if
condition|(
name|qhp
operator|==
name|NULL
condition|)
goto|goto
name|next_cqe
goto|;
if|if
condition|(
name|CQE_OPCODE
argument_list|(
name|hw_cqe
argument_list|)
operator|==
name|FW_RI_TERMINATE
condition|)
goto|goto
name|next_cqe
goto|;
if|if
condition|(
name|CQE_OPCODE
argument_list|(
name|hw_cqe
argument_list|)
operator|==
name|FW_RI_READ_RESP
condition|)
block|{
comment|/* 			 * If we have reached here because of async 			 * event or other error, and have egress error 			 * then drop 			 */
if|if
condition|(
name|CQE_TYPE
argument_list|(
name|hw_cqe
argument_list|)
operator|==
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"%s: got egress error in \ 					read-response, dropping!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|next_cqe
goto|;
block|}
comment|/* 			 * drop peer2peer RTR reads. 			 */
if|if
condition|(
name|CQE_WRID_STAG
argument_list|(
name|hw_cqe
argument_list|)
operator|==
literal|1
condition|)
goto|goto
name|next_cqe
goto|;
comment|/* 			 * Eat completions for unsignaled read WRs. 			 */
if|if
condition|(
operator|!
name|qhp
operator|->
name|wq
operator|.
name|sq
operator|.
name|oldest_read
operator|->
name|signaled
condition|)
block|{
name|advance_oldest_read
argument_list|(
operator|&
name|qhp
operator|->
name|wq
argument_list|)
expr_stmt|;
goto|goto
name|next_cqe
goto|;
block|}
comment|/* 			 * Don't write to the HWCQ, create a new read req CQE 			 * in local memory and move it into the swcq. 			 */
name|create_read_req_cqe
argument_list|(
operator|&
name|qhp
operator|->
name|wq
argument_list|,
name|hw_cqe
argument_list|,
operator|&
name|read_cqe
argument_list|)
expr_stmt|;
name|hw_cqe
operator|=
operator|&
name|read_cqe
expr_stmt|;
name|advance_oldest_read
argument_list|(
operator|&
name|qhp
operator|->
name|wq
argument_list|)
expr_stmt|;
block|}
comment|/* if its a SQ completion, then do the magic to move all the 		 * unsignaled and now in-order completions into the swcq. 		 */
if|if
condition|(
name|SQ_TYPE
argument_list|(
name|hw_cqe
argument_list|)
condition|)
block|{
name|int
name|idx
init|=
name|CQE_WRID_SQ_IDX
argument_list|(
name|hw_cqe
argument_list|)
decl_stmt|;
name|BUG_ON
argument_list|(
name|idx
operator|>=
name|qhp
operator|->
name|wq
operator|.
name|sq
operator|.
name|size
argument_list|)
expr_stmt|;
name|swsqe
operator|=
operator|&
name|qhp
operator|->
name|wq
operator|.
name|sq
operator|.
name|sw_sq
index|[
name|idx
index|]
expr_stmt|;
name|swsqe
operator|->
name|cqe
operator|=
operator|*
name|hw_cqe
expr_stmt|;
name|swsqe
operator|->
name|complete
operator|=
literal|1
expr_stmt|;
name|flush_completed_wrs
argument_list|(
operator|&
name|qhp
operator|->
name|wq
argument_list|,
operator|&
name|chp
operator|->
name|cq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|swcqe
operator|=
operator|&
name|chp
operator|->
name|cq
operator|.
name|sw_queue
index|[
name|chp
operator|->
name|cq
operator|.
name|sw_pidx
index|]
expr_stmt|;
operator|*
name|swcqe
operator|=
operator|*
name|hw_cqe
expr_stmt|;
name|swcqe
operator|->
name|header
operator||=
name|cpu_to_be32
argument_list|(
name|V_CQE_SWCQE
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|t4_swcq_produce
argument_list|(
operator|&
name|chp
operator|->
name|cq
argument_list|)
expr_stmt|;
block|}
name|next_cqe
label|:
name|t4_hwcq_consume
argument_list|(
operator|&
name|chp
operator|->
name|cq
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_next_hw_cqe
argument_list|(
operator|&
name|chp
operator|->
name|cq
argument_list|,
operator|&
name|hw_cqe
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|cqe_completes_wr
parameter_list|(
name|struct
name|t4_cqe
modifier|*
name|cqe
parameter_list|,
name|struct
name|t4_wq
modifier|*
name|wq
parameter_list|)
block|{
if|if
condition|(
name|CQE_OPCODE
argument_list|(
name|cqe
argument_list|)
operator|==
name|FW_RI_TERMINATE
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|CQE_OPCODE
argument_list|(
name|cqe
argument_list|)
operator|==
name|FW_RI_RDMA_WRITE
operator|)
operator|&&
name|RQ_TYPE
argument_list|(
name|cqe
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|CQE_OPCODE
argument_list|(
name|cqe
argument_list|)
operator|==
name|FW_RI_READ_RESP
operator|)
operator|&&
name|SQ_TYPE
argument_list|(
name|cqe
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|CQE_SEND_OPCODE
argument_list|(
name|cqe
argument_list|)
operator|&&
name|RQ_TYPE
argument_list|(
name|cqe
argument_list|)
operator|&&
name|t4_rq_empty
argument_list|(
name|wq
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|c4iw_count_rcqes
parameter_list|(
name|struct
name|t4_cq
modifier|*
name|cq
parameter_list|,
name|struct
name|t4_wq
modifier|*
name|wq
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
block|{
name|struct
name|t4_cqe
modifier|*
name|cqe
decl_stmt|;
name|u32
name|ptr
decl_stmt|;
operator|*
name|count
operator|=
literal|0
expr_stmt|;
name|ptr
operator|=
name|cq
operator|->
name|sw_cidx
expr_stmt|;
name|BUG_ON
argument_list|(
name|ptr
operator|>=
name|cq
operator|->
name|size
argument_list|)
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|cq
operator|->
name|sw_pidx
condition|)
block|{
name|cqe
operator|=
operator|&
name|cq
operator|->
name|sw_queue
index|[
name|ptr
index|]
expr_stmt|;
if|if
condition|(
name|RQ_TYPE
argument_list|(
name|cqe
argument_list|)
operator|&&
operator|(
name|CQE_OPCODE
argument_list|(
name|cqe
argument_list|)
operator|!=
name|FW_RI_READ_RESP
operator|)
operator|&&
operator|(
name|CQE_QPID
argument_list|(
name|cqe
argument_list|)
operator|==
name|wq
operator|->
name|sq
operator|.
name|qid
operator|)
operator|&&
name|cqe_completes_wr
argument_list|(
name|cqe
argument_list|,
name|wq
argument_list|)
condition|)
operator|(
operator|*
name|count
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|ptr
operator|==
name|cq
operator|->
name|size
condition|)
name|ptr
operator|=
literal|0
expr_stmt|;
block|}
name|PDBG
argument_list|(
literal|"%s cq %p count %d\n"
argument_list|,
name|__func__
argument_list|,
name|cq
argument_list|,
operator|*
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_cqe
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|u64
modifier|*
name|p
init|=
name|arg
decl_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"cxgb4 err cqe %016lx %016lx %016lx %016lx\n"
argument_list|,
name|be64_to_cpu
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|be64_to_cpu
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|be64_to_cpu
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|be64_to_cpu
argument_list|(
name|p
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * poll_cq  *  * Caller must:  *     check the validity of the first CQE,  *     supply the wq assicated with the qpid.  *  * credit: cq credit to return to sge.  * cqe_flushed: 1 iff the CQE is flushed.  * cqe: copy of the polled CQE.  *  * return value:  *    0		    CQE returned ok.  *    -EAGAIN       CQE skipped, try again.  *    -EOVERFLOW    CQ overflow detected.  */
end_comment

begin_function
specifier|static
name|int
name|poll_cq
parameter_list|(
name|struct
name|t4_wq
modifier|*
name|wq
parameter_list|,
name|struct
name|t4_cq
modifier|*
name|cq
parameter_list|,
name|struct
name|t4_cqe
modifier|*
name|cqe
parameter_list|,
name|u8
modifier|*
name|cqe_flushed
parameter_list|,
name|u64
modifier|*
name|cookie
parameter_list|,
name|u32
modifier|*
name|credit
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|t4_cqe
modifier|*
name|hw_cqe
decl_stmt|,
name|read_cqe
decl_stmt|;
operator|*
name|cqe_flushed
operator|=
literal|0
expr_stmt|;
operator|*
name|credit
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|t4_next_cqe
argument_list|(
name|cq
argument_list|,
operator|&
name|hw_cqe
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|PDBG
argument_list|(
literal|"%s CQE OVF %u qpid 0x%0x genbit %u type %u status 0x%0x"
literal|" opcode 0x%0x len 0x%0x wrid_hi_stag 0x%x wrid_low_msn 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|CQE_OVFBIT
argument_list|(
name|hw_cqe
argument_list|)
argument_list|,
name|CQE_QPID
argument_list|(
name|hw_cqe
argument_list|)
argument_list|,
name|CQE_GENBIT
argument_list|(
name|hw_cqe
argument_list|)
argument_list|,
name|CQE_TYPE
argument_list|(
name|hw_cqe
argument_list|)
argument_list|,
name|CQE_STATUS
argument_list|(
name|hw_cqe
argument_list|)
argument_list|,
name|CQE_OPCODE
argument_list|(
name|hw_cqe
argument_list|)
argument_list|,
name|CQE_LEN
argument_list|(
name|hw_cqe
argument_list|)
argument_list|,
name|CQE_WRID_HI
argument_list|(
name|hw_cqe
argument_list|)
argument_list|,
name|CQE_WRID_LOW
argument_list|(
name|hw_cqe
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * skip cqe's not affiliated with a QP. 	 */
if|if
condition|(
name|wq
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|EAGAIN
expr_stmt|;
goto|goto
name|skip_cqe
goto|;
block|}
comment|/* 	 * Gotta tweak READ completions: 	 *	1) the cqe doesn't contain the sq_wptr from the wr. 	 *	2) opcode not reflected from the wr. 	 *	3) read_len not reflected from the wr. 	 *	4) T4 HW (for now) inserts target read response failures which 	 * 	   need to be skipped. 	 */
if|if
condition|(
name|CQE_OPCODE
argument_list|(
name|hw_cqe
argument_list|)
operator|==
name|FW_RI_READ_RESP
condition|)
block|{
comment|/* 		 * If we have reached here because of async 		 * event or other error, and have egress error 		 * then drop 		 */
if|if
condition|(
name|CQE_TYPE
argument_list|(
name|hw_cqe
argument_list|)
operator|==
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"%s: got egress error in \ 				read-response, dropping!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|CQE_STATUS
argument_list|(
name|hw_cqe
argument_list|)
condition|)
name|t4_set_wq_in_error
argument_list|(
name|wq
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EAGAIN
expr_stmt|;
goto|goto
name|skip_cqe
goto|;
block|}
comment|/* 		 * If this is an unsolicited read response, then the read 		 * was generated by the kernel driver as part of peer-2-peer 		 * connection setup, or a target read response failure. 		 * So skip the completion. 		 */
if|if
condition|(
name|CQE_WRID_STAG
argument_list|(
name|hw_cqe
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|CQE_STATUS
argument_list|(
name|hw_cqe
argument_list|)
condition|)
name|t4_set_wq_in_error
argument_list|(
name|wq
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EAGAIN
expr_stmt|;
goto|goto
name|skip_cqe
goto|;
block|}
comment|/* 		 * Eat completions for unsignaled read WRs. 		 */
if|if
condition|(
operator|!
name|wq
operator|->
name|sq
operator|.
name|oldest_read
operator|->
name|signaled
condition|)
block|{
name|advance_oldest_read
argument_list|(
name|wq
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EAGAIN
expr_stmt|;
goto|goto
name|skip_cqe
goto|;
block|}
comment|/* 		 * Don't write to the HWCQ, so create a new read req CQE 		 * in local memory. 		 */
name|create_read_req_cqe
argument_list|(
name|wq
argument_list|,
name|hw_cqe
argument_list|,
operator|&
name|read_cqe
argument_list|)
expr_stmt|;
name|hw_cqe
operator|=
operator|&
name|read_cqe
expr_stmt|;
name|advance_oldest_read
argument_list|(
name|wq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CQE_STATUS
argument_list|(
name|hw_cqe
argument_list|)
operator|||
name|t4_wq_in_error
argument_list|(
name|wq
argument_list|)
condition|)
block|{
operator|*
name|cqe_flushed
operator|=
operator|(
name|CQE_STATUS
argument_list|(
name|hw_cqe
argument_list|)
operator|==
name|T4_ERR_SWFLUSH
operator|)
expr_stmt|;
name|wq
operator|->
name|error
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|cqe_flushed
operator|&&
name|CQE_STATUS
argument_list|(
name|hw_cqe
argument_list|)
condition|)
name|dump_cqe
argument_list|(
name|hw_cqe
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
operator|(
name|cqe_flushed
operator|==
literal|0
operator|)
operator|&&
operator|!
name|SW_CQE
argument_list|(
name|hw_cqe
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|proc_cqe
goto|;
block|}
if|if
condition|(
name|CQE_OPCODE
argument_list|(
name|hw_cqe
argument_list|)
operator|==
name|FW_RI_TERMINATE
condition|)
block|{
name|ret
operator|=
operator|-
name|EAGAIN
expr_stmt|;
goto|goto
name|skip_cqe
goto|;
block|}
comment|/* 	 * RECV completion. 	 */
if|if
condition|(
name|RQ_TYPE
argument_list|(
name|hw_cqe
argument_list|)
condition|)
block|{
comment|/* 		 * HW only validates 4 bits of MSN.  So we must validate that 		 * the MSN in the SEND is the next expected MSN.  If its not, 		 * then we complete this with T4_ERR_MSN and mark the wq in 		 * error. 		 */
if|if
condition|(
name|t4_rq_empty
argument_list|(
name|wq
argument_list|)
condition|)
block|{
name|t4_set_wq_in_error
argument_list|(
name|wq
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EAGAIN
expr_stmt|;
goto|goto
name|skip_cqe
goto|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|CQE_WRID_MSN
argument_list|(
name|hw_cqe
argument_list|)
operator|!=
operator|(
name|wq
operator|->
name|rq
operator|.
name|msn
operator|)
operator|)
argument_list|)
condition|)
block|{
name|t4_set_wq_in_error
argument_list|(
name|wq
argument_list|)
expr_stmt|;
name|hw_cqe
operator|->
name|header
operator||=
name|htonl
argument_list|(
name|V_CQE_STATUS
argument_list|(
name|T4_ERR_MSN
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|proc_cqe
goto|;
block|}
goto|goto
name|proc_cqe
goto|;
block|}
comment|/* 	 * If we get here its a send completion. 	 * 	 * Handle out of order completion. These get stuffed 	 * in the SW SQ. Then the SW SQ is walked to move any 	 * now in-order completions into the SW CQ.  This handles 	 * 2 cases: 	 *	1) reaping unsignaled WRs when the first subsequent 	 *	   signaled WR is completed. 	 *	2) out of order read completions. 	 */
if|if
condition|(
operator|!
name|SW_CQE
argument_list|(
name|hw_cqe
argument_list|)
operator|&&
operator|(
name|CQE_WRID_SQ_IDX
argument_list|(
name|hw_cqe
argument_list|)
operator|!=
name|wq
operator|->
name|sq
operator|.
name|cidx
operator|)
condition|)
block|{
name|struct
name|t4_swsqe
modifier|*
name|swsqe
decl_stmt|;
name|int
name|idx
init|=
name|CQE_WRID_SQ_IDX
argument_list|(
name|hw_cqe
argument_list|)
decl_stmt|;
name|PDBG
argument_list|(
literal|"%s out of order completion going in sw_sq at idx %u\n"
argument_list|,
name|__func__
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
name|idx
operator|>=
name|wq
operator|->
name|sq
operator|.
name|size
argument_list|)
expr_stmt|;
name|swsqe
operator|=
operator|&
name|wq
operator|->
name|sq
operator|.
name|sw_sq
index|[
name|idx
index|]
expr_stmt|;
name|swsqe
operator|->
name|cqe
operator|=
operator|*
name|hw_cqe
expr_stmt|;
name|swsqe
operator|->
name|complete
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
operator|-
name|EAGAIN
expr_stmt|;
goto|goto
name|flush_wq
goto|;
block|}
name|proc_cqe
label|:
operator|*
name|cqe
operator|=
operator|*
name|hw_cqe
expr_stmt|;
comment|/* 	 * Reap the associated WR(s) that are freed up with this 	 * completion. 	 */
if|if
condition|(
name|SQ_TYPE
argument_list|(
name|hw_cqe
argument_list|)
condition|)
block|{
name|int
name|idx
init|=
name|CQE_WRID_SQ_IDX
argument_list|(
name|hw_cqe
argument_list|)
decl_stmt|;
name|BUG_ON
argument_list|(
name|idx
operator|>=
name|wq
operator|->
name|sq
operator|.
name|size
argument_list|)
expr_stmt|;
comment|/* 		 * Account for any unsignaled completions completed by 		 * this signaled completion.  In this case, cidx points 		 * to the first unsignaled one, and idx points to the 		 * signaled one.  So adjust in_use based on this delta. 		 * if this is not completing any unsigned wrs, then the 		 * delta will be 0. Handle wrapping also! 		 */
if|if
condition|(
name|idx
operator|<
name|wq
operator|->
name|sq
operator|.
name|cidx
condition|)
name|wq
operator|->
name|sq
operator|.
name|in_use
operator|-=
name|wq
operator|->
name|sq
operator|.
name|size
operator|+
name|idx
operator|-
name|wq
operator|->
name|sq
operator|.
name|cidx
expr_stmt|;
else|else
name|wq
operator|->
name|sq
operator|.
name|in_use
operator|-=
name|idx
operator|-
name|wq
operator|->
name|sq
operator|.
name|cidx
expr_stmt|;
name|BUG_ON
argument_list|(
name|wq
operator|->
name|sq
operator|.
name|in_use
operator|<=
literal|0
operator|||
name|wq
operator|->
name|sq
operator|.
name|in_use
operator|>=
name|wq
operator|->
name|sq
operator|.
name|size
argument_list|)
expr_stmt|;
name|wq
operator|->
name|sq
operator|.
name|cidx
operator|=
operator|(
name|u16
operator|)
name|idx
expr_stmt|;
name|PDBG
argument_list|(
literal|"%s completing sq idx %u\n"
argument_list|,
name|__func__
argument_list|,
name|wq
operator|->
name|sq
operator|.
name|cidx
argument_list|)
expr_stmt|;
operator|*
name|cookie
operator|=
name|wq
operator|->
name|sq
operator|.
name|sw_sq
index|[
name|wq
operator|->
name|sq
operator|.
name|cidx
index|]
operator|.
name|wr_id
expr_stmt|;
name|t4_sq_consume
argument_list|(
name|wq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PDBG
argument_list|(
literal|"%s completing rq idx %u\n"
argument_list|,
name|__func__
argument_list|,
name|wq
operator|->
name|rq
operator|.
name|cidx
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
name|wq
operator|->
name|rq
operator|.
name|cidx
operator|>=
name|wq
operator|->
name|rq
operator|.
name|size
argument_list|)
expr_stmt|;
operator|*
name|cookie
operator|=
name|wq
operator|->
name|rq
operator|.
name|sw_rq
index|[
name|wq
operator|->
name|rq
operator|.
name|cidx
index|]
operator|.
name|wr_id
expr_stmt|;
name|BUG_ON
argument_list|(
name|t4_rq_empty
argument_list|(
name|wq
argument_list|)
argument_list|)
expr_stmt|;
name|t4_rq_consume
argument_list|(
name|wq
argument_list|)
expr_stmt|;
goto|goto
name|skip_cqe
goto|;
block|}
name|flush_wq
label|:
comment|/* 	 * Flush any completed cqes that are now in-order. 	 */
name|flush_completed_wrs
argument_list|(
name|wq
argument_list|,
name|cq
argument_list|)
expr_stmt|;
name|skip_cqe
label|:
if|if
condition|(
name|SW_CQE
argument_list|(
name|hw_cqe
argument_list|)
condition|)
block|{
name|PDBG
argument_list|(
literal|"%s cq %p cqid 0x%x skip sw cqe cidx %u\n"
argument_list|,
name|__func__
argument_list|,
name|cq
argument_list|,
name|cq
operator|->
name|cqid
argument_list|,
name|cq
operator|->
name|sw_cidx
argument_list|)
expr_stmt|;
name|t4_swcq_consume
argument_list|(
name|cq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PDBG
argument_list|(
literal|"%s cq %p cqid 0x%x skip hw cqe cidx %u\n"
argument_list|,
name|__func__
argument_list|,
name|cq
argument_list|,
name|cq
operator|->
name|cqid
argument_list|,
name|cq
operator|->
name|cidx
argument_list|)
expr_stmt|;
name|t4_hwcq_consume
argument_list|(
name|cq
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Get one cq entry from c4iw and map it to openib.  *  * Returns:  *	0			cqe returned  *	-ENODATA		EMPTY;  *	-EAGAIN			caller must try again  *	any other -errno	fatal error  */
end_comment

begin_function
specifier|static
name|int
name|c4iw_poll_cq_one
parameter_list|(
name|struct
name|c4iw_cq
modifier|*
name|chp
parameter_list|,
name|struct
name|ibv_wc
modifier|*
name|wc
parameter_list|)
block|{
name|struct
name|c4iw_qp
modifier|*
name|qhp
init|=
name|NULL
decl_stmt|;
name|struct
name|t4_cqe
name|cqe
decl_stmt|,
modifier|*
name|rd_cqe
decl_stmt|;
name|struct
name|t4_wq
modifier|*
name|wq
decl_stmt|;
name|u32
name|credit
init|=
literal|0
decl_stmt|;
name|u8
name|cqe_flushed
decl_stmt|;
name|u64
name|cookie
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|t4_next_cqe
argument_list|(
operator|&
name|chp
operator|->
name|cq
argument_list|,
operator|&
name|rd_cqe
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
ifdef|#
directive|ifdef
name|STALL_DETECTION
if|if
condition|(
name|ret
operator|==
operator|-
name|ENODATA
operator|&&
name|stall_to
operator|&&
operator|!
name|chp
operator|->
name|dumped
condition|)
block|{
name|struct
name|timeval
name|t
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|.
name|tv_sec
operator|-
name|chp
operator|->
name|time
operator|.
name|tv_sec
operator|)
operator|>
name|stall_to
condition|)
block|{
name|dump_state
argument_list|()
expr_stmt|;
name|chp
operator|->
name|dumped
operator|=
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|ret
return|;
block|}
ifdef|#
directive|ifdef
name|STALL_DETECTION
name|gettimeofday
argument_list|(
operator|&
name|chp
operator|->
name|time
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qhp
operator|=
name|get_qhp
argument_list|(
name|chp
operator|->
name|rhp
argument_list|,
name|CQE_QPID
argument_list|(
name|rd_cqe
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qhp
condition|)
name|wq
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|pthread_spin_lock
argument_list|(
operator|&
name|qhp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|wq
operator|=
operator|&
operator|(
name|qhp
operator|->
name|wq
operator|)
expr_stmt|;
block|}
name|ret
operator|=
name|poll_cq
argument_list|(
name|wq
argument_list|,
operator|&
operator|(
name|chp
operator|->
name|cq
operator|)
argument_list|,
operator|&
name|cqe
argument_list|,
operator|&
name|cqe_flushed
argument_list|,
operator|&
name|cookie
argument_list|,
operator|&
name|credit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
name|INC_STAT
argument_list|(
name|cqe
argument_list|)
expr_stmt|;
name|wc
operator|->
name|wr_id
operator|=
name|cookie
expr_stmt|;
name|wc
operator|->
name|qp_num
operator|=
name|qhp
operator|->
name|wq
operator|.
name|sq
operator|.
name|qid
expr_stmt|;
name|wc
operator|->
name|vendor_err
operator|=
name|CQE_STATUS
argument_list|(
operator|&
name|cqe
argument_list|)
expr_stmt|;
name|wc
operator|->
name|wc_flags
operator|=
literal|0
expr_stmt|;
name|PDBG
argument_list|(
literal|"%s qpid 0x%x type %d opcode %d status 0x%x wrid hi 0x%x "
literal|"lo 0x%x cookie 0x%llx\n"
argument_list|,
name|__func__
argument_list|,
name|CQE_QPID
argument_list|(
operator|&
name|cqe
argument_list|)
argument_list|,
name|CQE_TYPE
argument_list|(
operator|&
name|cqe
argument_list|)
argument_list|,
name|CQE_OPCODE
argument_list|(
operator|&
name|cqe
argument_list|)
argument_list|,
name|CQE_STATUS
argument_list|(
operator|&
name|cqe
argument_list|)
argument_list|,
name|CQE_WRID_HI
argument_list|(
operator|&
name|cqe
argument_list|)
argument_list|,
name|CQE_WRID_LOW
argument_list|(
operator|&
name|cqe
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|CQE_TYPE
argument_list|(
operator|&
name|cqe
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|CQE_STATUS
argument_list|(
operator|&
name|cqe
argument_list|)
condition|)
name|wc
operator|->
name|byte_len
operator|=
name|CQE_LEN
argument_list|(
operator|&
name|cqe
argument_list|)
expr_stmt|;
else|else
name|wc
operator|->
name|byte_len
operator|=
literal|0
expr_stmt|;
name|wc
operator|->
name|opcode
operator|=
name|IBV_WC_RECV
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|CQE_OPCODE
argument_list|(
operator|&
name|cqe
argument_list|)
condition|)
block|{
case|case
name|FW_RI_RDMA_WRITE
case|:
name|wc
operator|->
name|opcode
operator|=
name|IBV_WC_RDMA_WRITE
expr_stmt|;
break|break;
case|case
name|FW_RI_READ_REQ
case|:
name|wc
operator|->
name|opcode
operator|=
name|IBV_WC_RDMA_READ
expr_stmt|;
name|wc
operator|->
name|byte_len
operator|=
name|CQE_LEN
argument_list|(
operator|&
name|cqe
argument_list|)
expr_stmt|;
break|break;
case|case
name|FW_RI_SEND
case|:
case|case
name|FW_RI_SEND_WITH_SE
case|:
case|case
name|FW_RI_SEND_WITH_INV
case|:
case|case
name|FW_RI_SEND_WITH_SE_INV
case|:
name|wc
operator|->
name|opcode
operator|=
name|IBV_WC_SEND
expr_stmt|;
break|break;
case|case
name|FW_RI_BIND_MW
case|:
name|wc
operator|->
name|opcode
operator|=
name|IBV_WC_BIND_MW
expr_stmt|;
break|break;
default|default:
name|PDBG
argument_list|(
literal|"Unexpected opcode %d "
literal|"in the CQE received for QPID=0x%0x\n"
argument_list|,
name|CQE_OPCODE
argument_list|(
operator|&
name|cqe
argument_list|)
argument_list|,
name|CQE_QPID
argument_list|(
operator|&
name|cqe
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|cqe_flushed
condition|)
name|wc
operator|->
name|status
operator|=
name|IBV_WC_WR_FLUSH_ERR
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|CQE_STATUS
argument_list|(
operator|&
name|cqe
argument_list|)
condition|)
block|{
case|case
name|T4_ERR_SUCCESS
case|:
name|wc
operator|->
name|status
operator|=
name|IBV_WC_SUCCESS
expr_stmt|;
break|break;
case|case
name|T4_ERR_STAG
case|:
name|wc
operator|->
name|status
operator|=
name|IBV_WC_LOC_ACCESS_ERR
expr_stmt|;
break|break;
case|case
name|T4_ERR_PDID
case|:
name|wc
operator|->
name|status
operator|=
name|IBV_WC_LOC_PROT_ERR
expr_stmt|;
break|break;
case|case
name|T4_ERR_QPID
case|:
case|case
name|T4_ERR_ACCESS
case|:
name|wc
operator|->
name|status
operator|=
name|IBV_WC_LOC_ACCESS_ERR
expr_stmt|;
break|break;
case|case
name|T4_ERR_WRAP
case|:
name|wc
operator|->
name|status
operator|=
name|IBV_WC_GENERAL_ERR
expr_stmt|;
break|break;
case|case
name|T4_ERR_BOUND
case|:
name|wc
operator|->
name|status
operator|=
name|IBV_WC_LOC_LEN_ERR
expr_stmt|;
break|break;
case|case
name|T4_ERR_INVALIDATE_SHARED_MR
case|:
case|case
name|T4_ERR_INVALIDATE_MR_WITH_MW_BOUND
case|:
name|wc
operator|->
name|status
operator|=
name|IBV_WC_MW_BIND_ERR
expr_stmt|;
break|break;
case|case
name|T4_ERR_CRC
case|:
case|case
name|T4_ERR_MARKER
case|:
case|case
name|T4_ERR_PDU_LEN_ERR
case|:
case|case
name|T4_ERR_OUT_OF_RQE
case|:
case|case
name|T4_ERR_DDP_VERSION
case|:
case|case
name|T4_ERR_RDMA_VERSION
case|:
case|case
name|T4_ERR_DDP_QUEUE_NUM
case|:
case|case
name|T4_ERR_MSN
case|:
case|case
name|T4_ERR_TBIT
case|:
case|case
name|T4_ERR_MO
case|:
case|case
name|T4_ERR_MSN_RANGE
case|:
case|case
name|T4_ERR_IRD_OVERFLOW
case|:
case|case
name|T4_ERR_OPCODE
case|:
case|case
name|T4_ERR_INTERNAL_ERR
case|:
name|wc
operator|->
name|status
operator|=
name|IBV_WC_FATAL_ERR
expr_stmt|;
break|break;
case|case
name|T4_ERR_SWFLUSH
case|:
name|wc
operator|->
name|status
operator|=
name|IBV_WC_WR_FLUSH_ERR
expr_stmt|;
break|break;
default|default:
name|PDBG
argument_list|(
literal|"Unexpected cqe_status 0x%x for QPID=0x%0x\n"
argument_list|,
name|CQE_STATUS
argument_list|(
operator|&
name|cqe
argument_list|)
argument_list|,
name|CQE_QPID
argument_list|(
operator|&
name|cqe
argument_list|)
argument_list|)
expr_stmt|;
name|wc
operator|->
name|status
operator|=
name|IBV_WC_FATAL_ERR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wc
operator|->
name|status
operator|&&
name|wc
operator|->
name|status
operator|!=
name|IBV_WC_WR_FLUSH_ERR
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"cxgb4 app err cqid %u qpid %u "
literal|"type %u opcode %u status 0x%x\n"
argument_list|,
name|chp
operator|->
name|cq
operator|.
name|cqid
argument_list|,
name|CQE_QPID
argument_list|(
operator|&
name|cqe
argument_list|)
argument_list|,
name|CQE_TYPE
argument_list|(
operator|&
name|cqe
argument_list|)
argument_list|,
name|CQE_OPCODE
argument_list|(
operator|&
name|cqe
argument_list|)
argument_list|,
name|CQE_STATUS
argument_list|(
operator|&
name|cqe
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|wq
condition|)
name|pthread_spin_unlock
argument_list|(
operator|&
name|qhp
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|c4iw_poll_cq
parameter_list|(
name|struct
name|ibv_cq
modifier|*
name|ibcq
parameter_list|,
name|int
name|num_entries
parameter_list|,
name|struct
name|ibv_wc
modifier|*
name|wc
parameter_list|)
block|{
name|struct
name|c4iw_cq
modifier|*
name|chp
decl_stmt|;
name|int
name|npolled
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|chp
operator|=
name|to_c4iw_cq
argument_list|(
name|ibcq
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4_cq_in_error
argument_list|(
operator|&
name|chp
operator|->
name|cq
argument_list|)
condition|)
block|{
name|t4_reset_cq_in_error
argument_list|(
operator|&
name|chp
operator|->
name|cq
argument_list|)
expr_stmt|;
name|c4iw_flush_qps
argument_list|(
name|chp
operator|->
name|rhp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|num_entries
condition|)
return|return
name|t4_cq_notempty
argument_list|(
operator|&
name|chp
operator|->
name|cq
argument_list|)
return|;
name|pthread_spin_lock
argument_list|(
operator|&
name|chp
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|npolled
operator|=
literal|0
init|;
name|npolled
operator|<
name|num_entries
condition|;
operator|++
name|npolled
control|)
block|{
do|do
block|{
name|err
operator|=
name|c4iw_poll_cq_one
argument_list|(
name|chp
argument_list|,
name|wc
operator|+
name|npolled
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|err
operator|==
operator|-
name|EAGAIN
condition|)
do|;
if|if
condition|(
name|err
condition|)
break|break;
block|}
name|pthread_spin_unlock
argument_list|(
operator|&
name|chp
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|!
name|err
operator|||
name|err
operator|==
operator|-
name|ENODATA
condition|?
name|npolled
else|:
name|err
return|;
block|}
end_function

begin_function
name|int
name|c4iw_arm_cq
parameter_list|(
name|struct
name|ibv_cq
modifier|*
name|ibcq
parameter_list|,
name|int
name|solicited
parameter_list|)
block|{
name|struct
name|c4iw_cq
modifier|*
name|chp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|INC_STAT
argument_list|(
name|arm
argument_list|)
expr_stmt|;
name|chp
operator|=
name|to_c4iw_cq
argument_list|(
name|ibcq
argument_list|)
expr_stmt|;
name|pthread_spin_lock
argument_list|(
operator|&
name|chp
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|t4_arm_cq
argument_list|(
operator|&
name|chp
operator|->
name|cq
argument_list|,
name|solicited
argument_list|)
expr_stmt|;
name|pthread_spin_unlock
argument_list|(
operator|&
name|chp
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

