begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2007 Voltaire Inc.  All rights reserved.  * Copyright (c) 2007 Xsigo Systems Inc.  All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*========================================================*/
end_comment

begin_comment
comment|/*               FABRIC SCANNER SPECIFIC DATA             */
end_comment

begin_comment
comment|/*========================================================*/
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<infiniband/common.h>
end_include

begin_include
include|#
directive|include
file|<infiniband/mad.h>
end_include

begin_include
include|#
directive|include
file|"ibnetdiscover.h"
end_include

begin_include
include|#
directive|include
file|"grouping.h"
end_include

begin_define
define|#
directive|define
name|OUT_BUFFER_SIZE
value|16
end_define

begin_decl_stmt
specifier|extern
name|Node
modifier|*
name|nodesdist
index|[
name|MAXHOPS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last is CA list */
end_comment

begin_decl_stmt
specifier|extern
name|Node
modifier|*
name|mynode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Port
modifier|*
name|myport
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|maxhops_discovered
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|AllChassisList
name|mylist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ChassisTypeStr
index|[
literal|5
index|]
init|=
block|{
literal|""
block|,
literal|"ISR9288"
block|,
literal|"ISR9096"
block|,
literal|"ISR2012"
block|,
literal|"ISR2004"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ChassisSlotStr
index|[
literal|4
index|]
init|=
block|{
literal|""
block|,
literal|"Line"
block|,
literal|"Spine"
block|,
literal|"SRBD"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|get_chassis_type
parameter_list|(
name|unsigned
name|char
name|chassistype
parameter_list|)
block|{
if|if
condition|(
name|chassistype
operator|==
name|UNRESOLVED_CT
operator|||
name|chassistype
operator|>
name|ISR2004_CT
condition|)
return|return
name|NULL
return|;
return|return
name|ChassisTypeStr
index|[
name|chassistype
index|]
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|get_chassis_slot
parameter_list|(
name|unsigned
name|char
name|chassisslot
parameter_list|)
block|{
if|if
condition|(
name|chassisslot
operator|==
name|UNRESOLVED_CS
operator|||
name|chassisslot
operator|>
name|SRBD_CS
condition|)
return|return
name|NULL
return|;
return|return
name|ChassisSlotStr
index|[
name|chassisslot
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ChassisList
modifier|*
name|find_chassisnum
parameter_list|(
name|unsigned
name|char
name|chassisnum
parameter_list|)
block|{
name|ChassisList
modifier|*
name|current
decl_stmt|;
for|for
control|(
name|current
operator|=
name|mylist
operator|.
name|first
init|;
name|current
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
if|if
condition|(
name|current
operator|->
name|chassisnum
operator|==
name|chassisnum
condition|)
return|return
name|current
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|topspin_chassisguid
parameter_list|(
name|uint64_t
name|guid
parameter_list|)
block|{
comment|/* Byte 3 in system image GUID is chassis type, and */
comment|/* Byte 4 is location ID (slot) so just mask off byte 4 */
return|return
name|guid
operator|&
literal|0xffffffff00ffffffULL
return|;
block|}
end_function

begin_function
name|int
name|is_xsigo_guid
parameter_list|(
name|uint64_t
name|guid
parameter_list|)
block|{
if|if
condition|(
operator|(
name|guid
operator|&
literal|0xffffff0000000000ULL
operator|)
operator|==
literal|0x0013970000000000ULL
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_xsigo_leafone
parameter_list|(
name|uint64_t
name|guid
parameter_list|)
block|{
if|if
condition|(
operator|(
name|guid
operator|&
literal|0xffffffffff000000ULL
operator|)
operator|==
literal|0x0013970102000000ULL
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|is_xsigo_hca
parameter_list|(
name|uint64_t
name|guid
parameter_list|)
block|{
comment|/* NodeType 2 is HCA */
if|if
condition|(
operator|(
name|guid
operator|&
literal|0xffffffff00000000ULL
operator|)
operator|==
literal|0x0013970200000000ULL
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|is_xsigo_tca
parameter_list|(
name|uint64_t
name|guid
parameter_list|)
block|{
comment|/* NodeType 3 is TCA */
if|if
condition|(
operator|(
name|guid
operator|&
literal|0xffffffff00000000ULL
operator|)
operator|==
literal|0x0013970300000000ULL
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_xsigo_ca
parameter_list|(
name|uint64_t
name|guid
parameter_list|)
block|{
if|if
condition|(
name|is_xsigo_hca
argument_list|(
name|guid
argument_list|)
operator|||
name|is_xsigo_tca
argument_list|(
name|guid
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_xsigo_switch
parameter_list|(
name|uint64_t
name|guid
parameter_list|)
block|{
if|if
condition|(
operator|(
name|guid
operator|&
literal|0xffffffff00000000ULL
operator|)
operator|==
literal|0x0013970100000000ULL
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|xsigo_chassisguid
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_xsigo_ca
argument_list|(
name|node
operator|->
name|sysimgguid
argument_list|)
condition|)
block|{
comment|/* Byte 3 is NodeType and byte 4 is PortType */
comment|/* If NodeType is 1 (switch), PortType is masked */
if|if
condition|(
name|is_xsigo_switch
argument_list|(
name|node
operator|->
name|sysimgguid
argument_list|)
condition|)
return|return
name|node
operator|->
name|sysimgguid
operator|&
literal|0xffffffff00ffffffULL
return|;
else|else
return|return
name|node
operator|->
name|sysimgguid
return|;
block|}
else|else
block|{
comment|/* Is there a peer port ? */
if|if
condition|(
operator|!
name|node
operator|->
name|ports
operator|->
name|remoteport
condition|)
return|return
name|node
operator|->
name|sysimgguid
return|;
comment|/* If peer port is Leaf 1, use its chassis GUID */
if|if
condition|(
name|is_xsigo_leafone
argument_list|(
name|node
operator|->
name|ports
operator|->
name|remoteport
operator|->
name|node
operator|->
name|sysimgguid
argument_list|)
condition|)
return|return
name|node
operator|->
name|ports
operator|->
name|remoteport
operator|->
name|node
operator|->
name|sysimgguid
operator|&
literal|0xffffffff00ffffffULL
return|;
else|else
return|return
name|node
operator|->
name|sysimgguid
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|get_chassisguid
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|vendid
operator|==
name|TS_VENDOR_ID
operator|||
name|node
operator|->
name|vendid
operator|==
name|SS_VENDOR_ID
condition|)
return|return
name|topspin_chassisguid
argument_list|(
name|node
operator|->
name|sysimgguid
argument_list|)
return|;
elseif|else
if|if
condition|(
name|node
operator|->
name|vendid
operator|==
name|XS_VENDOR_ID
operator|||
name|is_xsigo_guid
argument_list|(
name|node
operator|->
name|sysimgguid
argument_list|)
condition|)
return|return
name|xsigo_chassisguid
argument_list|(
name|node
argument_list|)
return|;
else|else
return|return
name|node
operator|->
name|sysimgguid
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ChassisList
modifier|*
name|find_chassisguid
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|ChassisList
modifier|*
name|current
decl_stmt|;
name|uint64_t
name|chguid
decl_stmt|;
name|chguid
operator|=
name|get_chassisguid
argument_list|(
name|node
argument_list|)
expr_stmt|;
for|for
control|(
name|current
operator|=
name|mylist
operator|.
name|first
init|;
name|current
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
if|if
condition|(
name|current
operator|->
name|chassisguid
operator|==
name|chguid
condition|)
return|return
name|current
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|uint64_t
name|get_chassis_guid
parameter_list|(
name|unsigned
name|char
name|chassisnum
parameter_list|)
block|{
name|ChassisList
modifier|*
name|chassis
decl_stmt|;
name|chassis
operator|=
name|find_chassisnum
argument_list|(
name|chassisnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|chassis
condition|)
return|return
name|chassis
operator|->
name|chassisguid
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_router
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|)
block|{
return|return
operator|(
name|node
operator|->
name|devid
operator|==
name|VTR_DEVID_IB_FC_ROUTER
operator|||
name|node
operator|->
name|devid
operator|==
name|VTR_DEVID_IB_IP_ROUTER
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_spine_9096
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|)
block|{
return|return
operator|(
name|node
operator|->
name|devid
operator|==
name|VTR_DEVID_SFB4
operator|||
name|node
operator|->
name|devid
operator|==
name|VTR_DEVID_SFB4_DDR
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_spine_9288
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|)
block|{
return|return
operator|(
name|node
operator|->
name|devid
operator|==
name|VTR_DEVID_SFB12
operator|||
name|node
operator|->
name|devid
operator|==
name|VTR_DEVID_SFB12_DDR
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_spine_2004
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|)
block|{
return|return
operator|(
name|node
operator|->
name|devid
operator|==
name|VTR_DEVID_SFB2004
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_spine_2012
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|)
block|{
return|return
operator|(
name|node
operator|->
name|devid
operator|==
name|VTR_DEVID_SFB2012
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_spine
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|)
block|{
return|return
operator|(
name|is_spine_9096
argument_list|(
name|node
argument_list|)
operator|||
name|is_spine_9288
argument_list|(
name|node
argument_list|)
operator|||
name|is_spine_2004
argument_list|(
name|node
argument_list|)
operator|||
name|is_spine_2012
argument_list|(
name|node
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_line_24
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|)
block|{
return|return
operator|(
name|node
operator|->
name|devid
operator|==
name|VTR_DEVID_SLB24
operator|||
name|node
operator|->
name|devid
operator|==
name|VTR_DEVID_SLB24_DDR
operator|||
name|node
operator|->
name|devid
operator|==
name|VTR_DEVID_SRB2004
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_line_8
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|)
block|{
return|return
operator|(
name|node
operator|->
name|devid
operator|==
name|VTR_DEVID_SLB8
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_line_2024
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|)
block|{
return|return
operator|(
name|node
operator|->
name|devid
operator|==
name|VTR_DEVID_SLB2024
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_line
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|)
block|{
return|return
operator|(
name|is_line_24
argument_list|(
name|node
argument_list|)
operator|||
name|is_line_8
argument_list|(
name|node
argument_list|)
operator|||
name|is_line_2024
argument_list|(
name|node
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|is_chassis_switch
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|)
block|{
return|return
operator|(
name|is_spine
argument_list|(
name|node
argument_list|)
operator|||
name|is_line
argument_list|(
name|node
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* these structs help find Line (Anafa) slot number while using spine portnum */
end_comment

begin_decl_stmt
name|int
name|line_slot_2_sfb4
index|[
literal|25
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|anafa_line_slot_2_sfb4
index|[
literal|25
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|line_slot_2_sfb12
index|[
literal|25
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|8
block|,
literal|8
block|,
literal|9
block|,
literal|9
block|,
literal|10
block|,
literal|10
block|,
literal|11
block|,
literal|11
block|,
literal|12
block|,
literal|12
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|anafa_line_slot_2_sfb12
index|[
literal|25
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IPR FCR modules connectivity while using sFB4 port as reference */
end_comment

begin_decl_stmt
name|int
name|ipr_slot_2_sfb4_port
index|[
literal|25
index|]
init|=
block|{
literal|0
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these structs help find Spine (Anafa) slot number while using spine portnum */
end_comment

begin_decl_stmt
name|int
name|spine12_slot_2_slb
index|[
literal|25
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|anafa_spine12_slot_2_slb
index|[
literal|25
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|spine4_slot_2_slb
index|[
literal|25
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|anafa_spine4_slot_2_slb
index|[
literal|25
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*	reference                     { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24 }; */
end_comment

begin_function
specifier|static
name|void
name|get_sfb_slot
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|,
name|Port
modifier|*
name|lineport
parameter_list|)
block|{
name|ChassisRecord
modifier|*
name|ch
init|=
name|node
operator|->
name|chrecord
decl_stmt|;
name|ch
operator|->
name|chassisslot
operator|=
name|SPINE_CS
expr_stmt|;
if|if
condition|(
name|is_spine_9096
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|ch
operator|->
name|chassistype
operator|=
name|ISR9096_CT
expr_stmt|;
name|ch
operator|->
name|slotnum
operator|=
name|spine4_slot_2_slb
index|[
name|lineport
operator|->
name|portnum
index|]
expr_stmt|;
name|ch
operator|->
name|anafanum
operator|=
name|anafa_spine4_slot_2_slb
index|[
name|lineport
operator|->
name|portnum
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_spine_9288
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|ch
operator|->
name|chassistype
operator|=
name|ISR9288_CT
expr_stmt|;
name|ch
operator|->
name|slotnum
operator|=
name|spine12_slot_2_slb
index|[
name|lineport
operator|->
name|portnum
index|]
expr_stmt|;
name|ch
operator|->
name|anafanum
operator|=
name|anafa_spine12_slot_2_slb
index|[
name|lineport
operator|->
name|portnum
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_spine_2012
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|ch
operator|->
name|chassistype
operator|=
name|ISR2012_CT
expr_stmt|;
name|ch
operator|->
name|slotnum
operator|=
name|spine12_slot_2_slb
index|[
name|lineport
operator|->
name|portnum
index|]
expr_stmt|;
name|ch
operator|->
name|anafanum
operator|=
name|anafa_spine12_slot_2_slb
index|[
name|lineport
operator|->
name|portnum
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_spine_2004
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|ch
operator|->
name|chassistype
operator|=
name|ISR2004_CT
expr_stmt|;
name|ch
operator|->
name|slotnum
operator|=
name|spine4_slot_2_slb
index|[
name|lineport
operator|->
name|portnum
index|]
expr_stmt|;
name|ch
operator|->
name|anafanum
operator|=
name|anafa_spine4_slot_2_slb
index|[
name|lineport
operator|->
name|portnum
index|]
expr_stmt|;
block|}
else|else
block|{
name|IBPANIC
argument_list|(
literal|"Unexpected node found: guid 0x%016"
name|PRIx64
argument_list|,
name|node
operator|->
name|nodeguid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|get_router_slot
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|,
name|Port
modifier|*
name|spineport
parameter_list|)
block|{
name|ChassisRecord
modifier|*
name|ch
init|=
name|node
operator|->
name|chrecord
decl_stmt|;
name|int
name|guessnum
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|ch
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|node
operator|->
name|chrecord
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|ChassisRecord
argument_list|)
argument_list|)
operator|)
condition|)
name|IBPANIC
argument_list|(
literal|"out of mem"
argument_list|)
expr_stmt|;
name|ch
operator|=
name|node
operator|->
name|chrecord
expr_stmt|;
block|}
name|ch
operator|->
name|chassisslot
operator|=
name|SRBD_CS
expr_stmt|;
if|if
condition|(
name|is_spine_9096
argument_list|(
name|spineport
operator|->
name|node
argument_list|)
condition|)
block|{
name|ch
operator|->
name|chassistype
operator|=
name|ISR9096_CT
expr_stmt|;
name|ch
operator|->
name|slotnum
operator|=
name|line_slot_2_sfb4
index|[
name|spineport
operator|->
name|portnum
index|]
expr_stmt|;
name|ch
operator|->
name|anafanum
operator|=
name|ipr_slot_2_sfb4_port
index|[
name|spineport
operator|->
name|portnum
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_spine_9288
argument_list|(
name|spineport
operator|->
name|node
argument_list|)
condition|)
block|{
name|ch
operator|->
name|chassistype
operator|=
name|ISR9288_CT
expr_stmt|;
name|ch
operator|->
name|slotnum
operator|=
name|line_slot_2_sfb12
index|[
name|spineport
operator|->
name|portnum
index|]
expr_stmt|;
comment|/* this is a smart guess based on nodeguids order on sFB-12 module */
name|guessnum
operator|=
name|spineport
operator|->
name|node
operator|->
name|nodeguid
operator|%
literal|4
expr_stmt|;
comment|/* module 1<--> remote anafa 3 */
comment|/* module 2<--> remote anafa 2 */
comment|/* module 3<--> remote anafa 1 */
name|ch
operator|->
name|anafanum
operator|=
operator|(
name|guessnum
operator|==
literal|3
condition|?
literal|1
else|:
operator|(
name|guessnum
operator|==
literal|1
condition|?
literal|3
else|:
literal|2
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_spine_2012
argument_list|(
name|spineport
operator|->
name|node
argument_list|)
condition|)
block|{
name|ch
operator|->
name|chassistype
operator|=
name|ISR2012_CT
expr_stmt|;
name|ch
operator|->
name|slotnum
operator|=
name|line_slot_2_sfb12
index|[
name|spineport
operator|->
name|portnum
index|]
expr_stmt|;
comment|/* this is a smart guess based on nodeguids order on sFB-12 module */
name|guessnum
operator|=
name|spineport
operator|->
name|node
operator|->
name|nodeguid
operator|%
literal|4
expr_stmt|;
comment|// module 1<--> remote anafa 3
comment|// module 2<--> remote anafa 2
comment|// module 3<--> remote anafa 1
name|ch
operator|->
name|anafanum
operator|=
operator|(
name|guessnum
operator|==
literal|3
condition|?
literal|1
else|:
operator|(
name|guessnum
operator|==
literal|1
condition|?
literal|3
else|:
literal|2
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_spine_2004
argument_list|(
name|spineport
operator|->
name|node
argument_list|)
condition|)
block|{
name|ch
operator|->
name|chassistype
operator|=
name|ISR2004_CT
expr_stmt|;
name|ch
operator|->
name|slotnum
operator|=
name|line_slot_2_sfb4
index|[
name|spineport
operator|->
name|portnum
index|]
expr_stmt|;
name|ch
operator|->
name|anafanum
operator|=
name|ipr_slot_2_sfb4_port
index|[
name|spineport
operator|->
name|portnum
index|]
expr_stmt|;
block|}
else|else
block|{
name|IBPANIC
argument_list|(
literal|"Unexpected node found: guid 0x%016"
name|PRIx64
argument_list|,
name|spineport
operator|->
name|node
operator|->
name|nodeguid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|get_slb_slot
parameter_list|(
name|ChassisRecord
modifier|*
name|ch
parameter_list|,
name|Port
modifier|*
name|spineport
parameter_list|)
block|{
name|ch
operator|->
name|chassisslot
operator|=
name|LINE_CS
expr_stmt|;
if|if
condition|(
name|is_spine_9096
argument_list|(
name|spineport
operator|->
name|node
argument_list|)
condition|)
block|{
name|ch
operator|->
name|chassistype
operator|=
name|ISR9096_CT
expr_stmt|;
name|ch
operator|->
name|slotnum
operator|=
name|line_slot_2_sfb4
index|[
name|spineport
operator|->
name|portnum
index|]
expr_stmt|;
name|ch
operator|->
name|anafanum
operator|=
name|anafa_line_slot_2_sfb4
index|[
name|spineport
operator|->
name|portnum
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_spine_9288
argument_list|(
name|spineport
operator|->
name|node
argument_list|)
condition|)
block|{
name|ch
operator|->
name|chassistype
operator|=
name|ISR9288_CT
expr_stmt|;
name|ch
operator|->
name|slotnum
operator|=
name|line_slot_2_sfb12
index|[
name|spineport
operator|->
name|portnum
index|]
expr_stmt|;
name|ch
operator|->
name|anafanum
operator|=
name|anafa_line_slot_2_sfb12
index|[
name|spineport
operator|->
name|portnum
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_spine_2012
argument_list|(
name|spineport
operator|->
name|node
argument_list|)
condition|)
block|{
name|ch
operator|->
name|chassistype
operator|=
name|ISR2012_CT
expr_stmt|;
name|ch
operator|->
name|slotnum
operator|=
name|line_slot_2_sfb12
index|[
name|spineport
operator|->
name|portnum
index|]
expr_stmt|;
name|ch
operator|->
name|anafanum
operator|=
name|anafa_line_slot_2_sfb12
index|[
name|spineport
operator|->
name|portnum
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_spine_2004
argument_list|(
name|spineport
operator|->
name|node
argument_list|)
condition|)
block|{
name|ch
operator|->
name|chassistype
operator|=
name|ISR2004_CT
expr_stmt|;
name|ch
operator|->
name|slotnum
operator|=
name|line_slot_2_sfb4
index|[
name|spineport
operator|->
name|portnum
index|]
expr_stmt|;
name|ch
operator|->
name|anafanum
operator|=
name|anafa_line_slot_2_sfb4
index|[
name|spineport
operator|->
name|portnum
index|]
expr_stmt|;
block|}
else|else
block|{
name|IBPANIC
argument_list|(
literal|"Unexpected node found: guid 0x%016"
name|PRIx64
argument_list|,
name|spineport
operator|->
name|node
operator|->
name|nodeguid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* 	This function called for every Voltaire node in fabric 	It could be optimized so, but time overhead is very small 	and its only diag.util */
end_comment

begin_function
specifier|static
name|void
name|fill_chassis_record
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|Port
modifier|*
name|port
decl_stmt|;
name|Node
modifier|*
name|remnode
init|=
literal|0
decl_stmt|;
name|ChassisRecord
modifier|*
name|ch
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|chrecord
condition|)
comment|/* somehow this node has already been passed */
return|return;
if|if
condition|(
operator|!
operator|(
name|node
operator|->
name|chrecord
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|ChassisRecord
argument_list|)
argument_list|)
operator|)
condition|)
name|IBPANIC
argument_list|(
literal|"out of mem"
argument_list|)
expr_stmt|;
name|ch
operator|=
name|node
operator|->
name|chrecord
expr_stmt|;
comment|/* node is router only in case of using unique lid */
comment|/* (which is lid of chassis router port) */
comment|/* in such case node->ports is actually a requested port... */
if|if
condition|(
name|is_router
argument_list|(
name|node
argument_list|)
operator|&&
name|is_spine
argument_list|(
name|node
operator|->
name|ports
operator|->
name|remoteport
operator|->
name|node
argument_list|)
condition|)
name|get_router_slot
argument_list|(
name|node
argument_list|,
name|node
operator|->
name|ports
operator|->
name|remoteport
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_spine
argument_list|(
name|node
argument_list|)
condition|)
block|{
for|for
control|(
name|port
operator|=
name|node
operator|->
name|ports
init|;
name|port
condition|;
name|port
operator|=
name|port
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|port
operator|->
name|remoteport
condition|)
continue|continue;
name|remnode
operator|=
name|port
operator|->
name|remoteport
operator|->
name|node
expr_stmt|;
if|if
condition|(
name|remnode
operator|->
name|type
operator|!=
name|SWITCH_NODE
condition|)
block|{
if|if
condition|(
operator|!
name|remnode
operator|->
name|chrecord
condition|)
name|get_router_slot
argument_list|(
name|remnode
argument_list|,
name|port
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|ch
operator|->
name|chassistype
condition|)
comment|/* we assume here that remoteport belongs to line */
name|get_sfb_slot
argument_list|(
name|node
argument_list|,
name|port
operator|->
name|remoteport
argument_list|)
expr_stmt|;
comment|/* we could break here, but need to find if more routers connected */
block|}
block|}
elseif|else
if|if
condition|(
name|is_line
argument_list|(
name|node
argument_list|)
condition|)
block|{
for|for
control|(
name|port
operator|=
name|node
operator|->
name|ports
init|;
name|port
condition|;
name|port
operator|=
name|port
operator|->
name|next
control|)
block|{
if|if
condition|(
name|port
operator|->
name|portnum
operator|>
literal|12
condition|)
continue|continue;
if|if
condition|(
operator|!
name|port
operator|->
name|remoteport
condition|)
continue|continue;
comment|/* we assume here that remoteport belongs to spine */
name|get_slb_slot
argument_list|(
name|ch
argument_list|,
name|port
operator|->
name|remoteport
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|get_line_index
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|int
name|retval
init|=
literal|3
operator|*
operator|(
name|node
operator|->
name|chrecord
operator|->
name|slotnum
operator|-
literal|1
operator|)
operator|+
name|node
operator|->
name|chrecord
operator|->
name|anafanum
decl_stmt|;
if|if
condition|(
name|retval
operator|>
name|LINES_MAX_NUM
operator|||
name|retval
operator|<
literal|1
condition|)
name|IBPANIC
argument_list|(
literal|"Internal error"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_spine_index
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|is_spine_9288
argument_list|(
name|node
argument_list|)
operator|||
name|is_spine_2012
argument_list|(
name|node
argument_list|)
condition|)
name|retval
operator|=
literal|3
operator|*
operator|(
name|node
operator|->
name|chrecord
operator|->
name|slotnum
operator|-
literal|1
operator|)
operator|+
name|node
operator|->
name|chrecord
operator|->
name|anafanum
expr_stmt|;
else|else
name|retval
operator|=
name|node
operator|->
name|chrecord
operator|->
name|slotnum
expr_stmt|;
if|if
condition|(
name|retval
operator|>
name|SPINES_MAX_NUM
operator|||
name|retval
operator|<
literal|1
condition|)
name|IBPANIC
argument_list|(
literal|"Internal error"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_line_router
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|,
name|ChassisList
modifier|*
name|chassislist
parameter_list|)
block|{
name|int
name|i
init|=
name|get_line_index
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|chassislist
operator|->
name|linenode
index|[
name|i
index|]
condition|)
return|return;
comment|/* already filled slot */
name|chassislist
operator|->
name|linenode
index|[
name|i
index|]
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|chrecord
operator|->
name|chassisnum
operator|=
name|chassislist
operator|->
name|chassisnum
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_spine
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|,
name|ChassisList
modifier|*
name|chassislist
parameter_list|)
block|{
name|int
name|i
init|=
name|get_spine_index
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|chassislist
operator|->
name|spinenode
index|[
name|i
index|]
condition|)
return|return;
comment|/* already filled slot */
name|chassislist
operator|->
name|spinenode
index|[
name|i
index|]
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|chrecord
operator|->
name|chassisnum
operator|=
name|chassislist
operator|->
name|chassisnum
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pass_on_lines_catch_spines
parameter_list|(
name|ChassisList
modifier|*
name|chassislist
parameter_list|)
block|{
name|Node
modifier|*
name|node
decl_stmt|,
modifier|*
name|remnode
decl_stmt|;
name|Port
modifier|*
name|port
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|LINES_MAX_NUM
condition|;
name|i
operator|++
control|)
block|{
name|node
operator|=
name|chassislist
operator|->
name|linenode
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|node
operator|&&
name|is_line
argument_list|(
name|node
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* empty slot or router */
for|for
control|(
name|port
operator|=
name|node
operator|->
name|ports
init|;
name|port
condition|;
name|port
operator|=
name|port
operator|->
name|next
control|)
block|{
if|if
condition|(
name|port
operator|->
name|portnum
operator|>
literal|12
condition|)
continue|continue;
if|if
condition|(
operator|!
name|port
operator|->
name|remoteport
condition|)
continue|continue;
name|remnode
operator|=
name|port
operator|->
name|remoteport
operator|->
name|node
expr_stmt|;
if|if
condition|(
operator|!
name|remnode
operator|->
name|chrecord
condition|)
continue|continue;
comment|/* some error - spine not initialized ? FIXME */
name|insert_spine
argument_list|(
name|remnode
argument_list|,
name|chassislist
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pass_on_spines_catch_lines
parameter_list|(
name|ChassisList
modifier|*
name|chassislist
parameter_list|)
block|{
name|Node
modifier|*
name|node
decl_stmt|,
modifier|*
name|remnode
decl_stmt|;
name|Port
modifier|*
name|port
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|SPINES_MAX_NUM
condition|;
name|i
operator|++
control|)
block|{
name|node
operator|=
name|chassislist
operator|->
name|spinenode
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
continue|continue;
comment|/* empty slot */
for|for
control|(
name|port
operator|=
name|node
operator|->
name|ports
init|;
name|port
condition|;
name|port
operator|=
name|port
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|port
operator|->
name|remoteport
condition|)
continue|continue;
name|remnode
operator|=
name|port
operator|->
name|remoteport
operator|->
name|node
expr_stmt|;
if|if
condition|(
operator|!
name|remnode
operator|->
name|chrecord
condition|)
continue|continue;
comment|/* some error - line/router not initialized ? FIXME */
name|insert_line_router
argument_list|(
name|remnode
argument_list|,
name|chassislist
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* 	Stupid interpolation algorithm... 	But nothing to do - have to be compliant with VoltaireSM/NMS */
end_comment

begin_function
specifier|static
name|void
name|pass_on_spines_interpolate_chguid
parameter_list|(
name|ChassisList
modifier|*
name|chassislist
parameter_list|)
block|{
name|Node
modifier|*
name|node
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|SPINES_MAX_NUM
condition|;
name|i
operator|++
control|)
block|{
name|node
operator|=
name|chassislist
operator|->
name|spinenode
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
continue|continue;
comment|/* skip the empty slots */
comment|/* take first guid minus one to be consistent with SM */
name|chassislist
operator|->
name|chassisguid
operator|=
name|node
operator|->
name|nodeguid
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* 	This function fills chassislist structure with all nodes 	in that chassis 	chassislist structure = structure of one standalone chassis */
end_comment

begin_function
specifier|static
name|void
name|build_chassis
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|,
name|ChassisList
modifier|*
name|chassislist
parameter_list|)
block|{
name|Node
modifier|*
name|remnode
init|=
literal|0
decl_stmt|;
name|Port
modifier|*
name|port
init|=
literal|0
decl_stmt|;
comment|/* we get here with node = chassis_spine */
name|chassislist
operator|->
name|chassistype
operator|=
name|node
operator|->
name|chrecord
operator|->
name|chassistype
expr_stmt|;
name|insert_spine
argument_list|(
name|node
argument_list|,
name|chassislist
argument_list|)
expr_stmt|;
comment|/* loop: pass on all ports of node */
for|for
control|(
name|port
operator|=
name|node
operator|->
name|ports
init|;
name|port
condition|;
name|port
operator|=
name|port
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|port
operator|->
name|remoteport
condition|)
continue|continue;
name|remnode
operator|=
name|port
operator|->
name|remoteport
operator|->
name|node
expr_stmt|;
if|if
condition|(
operator|!
name|remnode
operator|->
name|chrecord
condition|)
continue|continue;
comment|/* some error - line or router not initialized ? FIXME */
name|insert_line_router
argument_list|(
name|remnode
argument_list|,
name|chassislist
argument_list|)
expr_stmt|;
block|}
name|pass_on_lines_catch_spines
argument_list|(
name|chassislist
argument_list|)
expr_stmt|;
comment|/* this pass needed for to catch routers, since routers connected only */
comment|/* to spines in slot 1 or 4 and we could miss them first time */
name|pass_on_spines_catch_lines
argument_list|(
name|chassislist
argument_list|)
expr_stmt|;
comment|/* additional 2 passes needed for to overcome a problem of pure "in-chassis" */
comment|/* connectivity - extra pass to ensure that all related chips/modules */
comment|/* inserted into the chassislist */
name|pass_on_lines_catch_spines
argument_list|(
name|chassislist
argument_list|)
expr_stmt|;
name|pass_on_spines_catch_lines
argument_list|(
name|chassislist
argument_list|)
expr_stmt|;
name|pass_on_spines_interpolate_chguid
argument_list|(
name|chassislist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*========================================================*/
end_comment

begin_comment
comment|/*                INTERNAL TO EXTERNAL PORT MAPPING       */
end_comment

begin_comment
comment|/*========================================================*/
end_comment

begin_comment
comment|/* Description : On ISR9288/9096 external ports indexing               is not matching the internal ( anafa ) port               indexes. Use this MAP to translate the data you get from               the OpenIB diagnostics (smpquery, ibroute, ibtracert, etc.)   Module : sLB-24                 anafa 1             anafa 2 ext port | 13 14 15 16 17 18 | 19 20 21 22 23 24 int port | 22 23 24 18 17 16 | 22 23 24 18 17 16 ext port | 1  2  3  4  5  6  | 7  8  9  10 11 12 int port | 19 20 21 15 14 13 | 19 20 21 15 14 13 ------------------------------------------------  Module : sLB-8                 anafa 1             anafa 2 ext port | 13 14 15 16 17 18 | 19 20 21 22 23 24 int port | 24 23 22 18 17 16 | 24 23 22 18 17 16 ext port | 1  2  3  4  5  6  | 7  8  9  10 11 12 int port | 21 20 19 15 14 13 | 21 20 19 15 14 13  ----------->                 anafa 1             anafa 2 ext port | -  -  5  -  -  6  | -  -  7  -  -  8 int port | 24 23 22 18 17 16 | 24 23 22 18 17 16 ext port | -  -  1  -  -  2  | -  -  3  -  -  4 int port | 21 20 19 15 14 13 | 21 20 19 15 14 13 ------------------------------------------------  Module : sLB-2024  ext port | 13 14 15 16 17 18 19 20 21 22 23 24 A1 int port| 13 14 15 16 17 18 19 20 21 22 23 24 ext port | 1 2 3 4 5 6 7 8 9 10 11 12 A2 int port| 13 14 15 16 17 18 19 20 21 22 23 24 ---------------------------------------------------  */
end_comment

begin_decl_stmt
name|int
name|int2ext_map_slb24
index|[
literal|2
index|]
index|[
literal|25
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|6
block|,
literal|5
block|,
literal|4
block|,
literal|18
block|,
literal|17
block|,
literal|16
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|12
block|,
literal|11
block|,
literal|10
block|,
literal|24
block|,
literal|23
block|,
literal|22
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|int2ext_map_slb8
index|[
literal|2
index|]
index|[
literal|25
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|int2ext_map_slb2024
index|[
literal|2
index|]
index|[
literal|25
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*	reference			{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24 }; */
end_comment

begin_comment
comment|/* 	This function relevant only for line modules/chips 	Returns string with external port index */
end_comment

begin_function
name|char
modifier|*
name|portmapstring
parameter_list|(
name|Port
modifier|*
name|port
parameter_list|)
block|{
specifier|static
name|char
name|mapping
index|[
name|OUT_BUFFER_SIZE
index|]
decl_stmt|;
name|ChassisRecord
modifier|*
name|ch
init|=
name|port
operator|->
name|node
operator|->
name|chrecord
decl_stmt|;
name|int
name|portnum
init|=
name|port
operator|->
name|portnum
decl_stmt|;
name|int
name|chipnum
init|=
literal|0
decl_stmt|;
name|int
name|pindex
init|=
literal|0
decl_stmt|;
name|Node
modifier|*
name|node
init|=
name|port
operator|->
name|node
decl_stmt|;
if|if
condition|(
operator|!
name|ch
operator|||
operator|!
name|is_line
argument_list|(
name|node
argument_list|)
operator|||
operator|(
name|portnum
operator|<
literal|13
operator|||
name|portnum
operator|>
literal|24
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|ch
operator|->
name|anafanum
operator|<
literal|1
operator|||
name|ch
operator|->
name|anafanum
operator|>
literal|2
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|mapping
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mapping
argument_list|)
argument_list|)
expr_stmt|;
name|chipnum
operator|=
name|ch
operator|->
name|anafanum
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|is_line_24
argument_list|(
name|node
argument_list|)
condition|)
name|pindex
operator|=
name|int2ext_map_slb24
index|[
name|chipnum
index|]
index|[
name|portnum
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|is_line_2024
argument_list|(
name|node
argument_list|)
condition|)
name|pindex
operator|=
name|int2ext_map_slb2024
index|[
name|chipnum
index|]
index|[
name|portnum
index|]
expr_stmt|;
else|else
name|pindex
operator|=
name|int2ext_map_slb8
index|[
name|chipnum
index|]
index|[
name|portnum
index|]
expr_stmt|;
name|sprintf
argument_list|(
name|mapping
argument_list|,
literal|"[ext %d]"
argument_list|,
name|pindex
argument_list|)
expr_stmt|;
return|return
name|mapping
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_chassislist
parameter_list|()
block|{
if|if
condition|(
operator|!
operator|(
name|mylist
operator|.
name|current
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|ChassisList
argument_list|)
argument_list|)
operator|)
condition|)
name|IBPANIC
argument_list|(
literal|"out of mem"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mylist
operator|.
name|first
operator|==
name|NULL
condition|)
block|{
name|mylist
operator|.
name|first
operator|=
name|mylist
operator|.
name|current
expr_stmt|;
name|mylist
operator|.
name|last
operator|=
name|mylist
operator|.
name|current
expr_stmt|;
block|}
else|else
block|{
name|mylist
operator|.
name|last
operator|->
name|next
operator|=
name|mylist
operator|.
name|current
expr_stmt|;
name|mylist
operator|.
name|current
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|mylist
operator|.
name|last
operator|=
name|mylist
operator|.
name|current
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* 	Main grouping function 	Algorithm: 	1. pass on every Voltaire node 	2. catch spine chip for every Voltaire node 		2.1 build/interpolate chassis around this chip 		2.2 go to 1. 	3. pass on non Voltaire nodes (SystemImageGUID based grouping) 	4. now group non Voltaire nodes by SystemImageGUID */
end_comment

begin_function
name|ChassisList
modifier|*
name|group_nodes
parameter_list|()
block|{
name|Node
modifier|*
name|node
decl_stmt|;
name|int
name|dist
decl_stmt|;
name|int
name|chassisnum
init|=
literal|0
decl_stmt|;
name|struct
name|ChassisList
modifier|*
name|chassis
decl_stmt|;
name|mylist
operator|.
name|first
operator|=
name|NULL
expr_stmt|;
name|mylist
operator|.
name|current
operator|=
name|NULL
expr_stmt|;
name|mylist
operator|.
name|last
operator|=
name|NULL
expr_stmt|;
comment|/* first pass on switches and build for every Voltaire node */
comment|/* an appropriate chassis record (slotnum and position) */
comment|/* according to internal connectivity */
comment|/* not very efficient but clear code so... */
for|for
control|(
name|dist
operator|=
literal|0
init|;
name|dist
operator|<=
name|maxhops_discovered
condition|;
name|dist
operator|++
control|)
block|{
for|for
control|(
name|node
operator|=
name|nodesdist
index|[
name|dist
index|]
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|dnext
control|)
block|{
if|if
condition|(
name|node
operator|->
name|vendid
operator|==
name|VTR_VENDOR_ID
condition|)
name|fill_chassis_record
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* separate every Voltaire chassis from each other and build linked list of them */
comment|/* algorithm: catch spine and find all surrounding nodes */
for|for
control|(
name|dist
operator|=
literal|0
init|;
name|dist
operator|<=
name|maxhops_discovered
condition|;
name|dist
operator|++
control|)
block|{
for|for
control|(
name|node
operator|=
name|nodesdist
index|[
name|dist
index|]
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|dnext
control|)
block|{
if|if
condition|(
name|node
operator|->
name|vendid
operator|!=
name|VTR_VENDOR_ID
condition|)
continue|continue;
if|if
condition|(
operator|!
name|node
operator|->
name|chrecord
operator|||
name|node
operator|->
name|chrecord
operator|->
name|chassisnum
operator|||
operator|!
name|is_spine
argument_list|(
name|node
argument_list|)
condition|)
continue|continue;
name|add_chassislist
argument_list|()
expr_stmt|;
name|mylist
operator|.
name|current
operator|->
name|chassisnum
operator|=
operator|++
name|chassisnum
expr_stmt|;
name|build_chassis
argument_list|(
name|node
argument_list|,
name|mylist
operator|.
name|current
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* now make pass on nodes for chassis which are not Voltaire */
comment|/* grouped by common SystemImageGUID */
for|for
control|(
name|dist
operator|=
literal|0
init|;
name|dist
operator|<=
name|maxhops_discovered
condition|;
name|dist
operator|++
control|)
block|{
for|for
control|(
name|node
operator|=
name|nodesdist
index|[
name|dist
index|]
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|dnext
control|)
block|{
if|if
condition|(
name|node
operator|->
name|vendid
operator|==
name|VTR_VENDOR_ID
condition|)
continue|continue;
if|if
condition|(
name|node
operator|->
name|sysimgguid
condition|)
block|{
name|chassis
operator|=
name|find_chassisguid
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|chassis
condition|)
name|chassis
operator|->
name|nodecount
operator|++
expr_stmt|;
else|else
block|{
comment|/* Possible new chassis */
name|add_chassislist
argument_list|()
expr_stmt|;
name|mylist
operator|.
name|current
operator|->
name|chassisguid
operator|=
name|get_chassisguid
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|mylist
operator|.
name|current
operator|->
name|nodecount
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* now, make another pass to see which nodes are part of chassis */
comment|/* (defined as chassis->nodecount> 1) */
for|for
control|(
name|dist
operator|=
literal|0
init|;
name|dist
operator|<=
name|MAXHOPS
condition|;
control|)
block|{
for|for
control|(
name|node
operator|=
name|nodesdist
index|[
name|dist
index|]
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|dnext
control|)
block|{
if|if
condition|(
name|node
operator|->
name|vendid
operator|==
name|VTR_VENDOR_ID
condition|)
continue|continue;
if|if
condition|(
name|node
operator|->
name|sysimgguid
condition|)
block|{
name|chassis
operator|=
name|find_chassisguid
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|chassis
operator|&&
name|chassis
operator|->
name|nodecount
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|chassis
operator|->
name|chassisnum
condition|)
name|chassis
operator|->
name|chassisnum
operator|=
operator|++
name|chassisnum
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|chrecord
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|node
operator|->
name|chrecord
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|ChassisRecord
argument_list|)
argument_list|)
operator|)
condition|)
name|IBPANIC
argument_list|(
literal|"out of mem"
argument_list|)
expr_stmt|;
name|node
operator|->
name|chrecord
operator|->
name|chassisnum
operator|=
name|chassis
operator|->
name|chassisnum
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|dist
operator|==
name|maxhops_discovered
condition|)
name|dist
operator|=
name|MAXHOPS
expr_stmt|;
comment|/* skip to CAs */
else|else
name|dist
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|mylist
operator|.
name|first
operator|)
return|;
block|}
end_function

end_unit

