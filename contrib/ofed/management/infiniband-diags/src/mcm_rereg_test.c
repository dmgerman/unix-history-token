begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2006 Voltaire, Inc. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<infiniband/umad.h>
end_include

begin_include
include|#
directive|include
file|<infiniband/mad.h>
end_include

begin_define
define|#
directive|define
name|info
parameter_list|(
name|fmt
parameter_list|,
name|arg
modifier|...
parameter_list|)
value|fprintf(stderr, "INFO: " fmt, ##arg )
end_define

begin_define
define|#
directive|define
name|err
parameter_list|(
name|fmt
parameter_list|,
name|arg
modifier|...
parameter_list|)
value|fprintf(stderr, "ERR: " fmt, ##arg )
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|NOISY_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|dbg
parameter_list|(
name|fmt
parameter_list|,
name|arg
modifier|...
parameter_list|)
value|fprintf(stderr, "DBG: " fmt, ##arg )
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|dbg
parameter_list|(
name|fmt
parameter_list|,
name|arg
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TMO
value|100
end_define

begin_comment
comment|/* Multicast Member Record Component Masks */
end_comment

begin_define
define|#
directive|define
name|IB_MCR_COMPMASK_MGID
value|(1ULL<<0)
end_define

begin_define
define|#
directive|define
name|IB_MCR_COMPMASK_PORT_GID
value|(1ULL<<1)
end_define

begin_define
define|#
directive|define
name|IB_MCR_COMPMASK_QKEY
value|(1ULL<<2)
end_define

begin_define
define|#
directive|define
name|IB_MCR_COMPMASK_MLID
value|(1ULL<<3)
end_define

begin_define
define|#
directive|define
name|IB_MCR_COMPMASK_MTU_SEL
value|(1ULL<<4)
end_define

begin_define
define|#
directive|define
name|IB_MCR_COMPMASK_MTU
value|(1ULL<<5)
end_define

begin_define
define|#
directive|define
name|IB_MCR_COMPMASK_TCLASS
value|(1ULL<<6)
end_define

begin_define
define|#
directive|define
name|IB_MCR_COMPMASK_PKEY
value|(1ULL<<7)
end_define

begin_define
define|#
directive|define
name|IB_MCR_COMPMASK_RATE_SEL
value|(1ULL<<8)
end_define

begin_define
define|#
directive|define
name|IB_MCR_COMPMASK_RATE
value|(1ULL<<9)
end_define

begin_define
define|#
directive|define
name|IB_MCR_COMPMASK_LIFE_SEL
value|(1ULL<<10)
end_define

begin_define
define|#
directive|define
name|IB_MCR_COMPMASK_LIFE
value|(1ULL<<11)
end_define

begin_define
define|#
directive|define
name|IB_MCR_COMPMASK_SL
value|(1ULL<<12)
end_define

begin_define
define|#
directive|define
name|IB_MCR_COMPMASK_FLOW
value|(1ULL<<13)
end_define

begin_define
define|#
directive|define
name|IB_MCR_COMPMASK_HOP
value|(1ULL<<14)
end_define

begin_define
define|#
directive|define
name|IB_MCR_COMPMASK_SCOPE
value|(1ULL<<15)
end_define

begin_define
define|#
directive|define
name|IB_MCR_COMPMASK_JOIN_STATE
value|(1ULL<<16)
end_define

begin_define
define|#
directive|define
name|IB_MCR_COMPMASK_PROXY
value|(1ULL<<17)
end_define

begin_decl_stmt
specifier|static
name|ibmad_gid_t
name|mgid_ipoib
init|=
block|{
literal|0xff
block|,
literal|0x12
block|,
literal|0x40
block|,
literal|0x1b
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|uint64_t
name|build_mcm_rec
parameter_list|(
name|uint8_t
modifier|*
name|data
parameter_list|,
name|ibmad_gid_t
name|mgid
parameter_list|,
name|ibmad_gid_t
name|port_gid
parameter_list|)
block|{
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|IB_SA_DATA_SIZE
argument_list|)
expr_stmt|;
name|mad_set_array
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|IB_SA_MCM_MGID_F
argument_list|,
name|mgid
argument_list|)
expr_stmt|;
name|mad_set_array
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|IB_SA_MCM_PORTGID_F
argument_list|,
name|port_gid
argument_list|)
expr_stmt|;
name|mad_set_field
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|IB_SA_MCM_JOIN_STATE_F
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|IB_MCR_COMPMASK_MGID
operator||
name|IB_MCR_COMPMASK_PORT_GID
operator||
name|IB_MCR_COMPMASK_JOIN_STATE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_mcm_rec_umad
parameter_list|(
name|void
modifier|*
name|umad
parameter_list|,
name|ib_portid_t
modifier|*
name|dport
parameter_list|,
name|int
name|method
parameter_list|,
name|uint64_t
name|comp_mask
parameter_list|,
name|uint8_t
modifier|*
name|data
parameter_list|)
block|{
name|ib_rpc_t
name|rpc
decl_stmt|;
name|memset
argument_list|(
operator|&
name|rpc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rpc
argument_list|)
argument_list|)
expr_stmt|;
name|rpc
operator|.
name|mgtclass
operator|=
name|IB_SA_CLASS
expr_stmt|;
name|rpc
operator|.
name|method
operator|=
name|method
expr_stmt|;
name|rpc
operator|.
name|attr
operator|.
name|id
operator|=
name|IB_SA_ATTR_MCRECORD
expr_stmt|;
name|rpc
operator|.
name|attr
operator|.
name|mod
operator|=
literal|0
expr_stmt|;
comment|// ???
name|rpc
operator|.
name|mask
operator|=
name|comp_mask
expr_stmt|;
name|rpc
operator|.
name|datasz
operator|=
name|IB_SA_DATA_SIZE
expr_stmt|;
name|rpc
operator|.
name|dataoffs
operator|=
name|IB_SA_DATA_OFFS
expr_stmt|;
name|mad_build_pkt
argument_list|(
name|umad
argument_list|,
operator|&
name|rpc
argument_list|,
name|dport
argument_list|,
name|NULL
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rereg_send
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|agent
parameter_list|,
name|ib_portid_t
modifier|*
name|dport
parameter_list|,
name|uint8_t
modifier|*
name|umad
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|method
parameter_list|,
name|ibmad_gid_t
name|port_gid
parameter_list|)
block|{
name|uint8_t
name|data
index|[
name|IB_SA_DATA_SIZE
index|]
decl_stmt|;
name|uint64_t
name|comp_mask
decl_stmt|;
name|comp_mask
operator|=
name|build_mcm_rec
argument_list|(
name|data
argument_list|,
name|mgid_ipoib
argument_list|,
name|port_gid
argument_list|)
expr_stmt|;
name|build_mcm_rec_umad
argument_list|(
name|umad
argument_list|,
name|dport
argument_list|,
name|method
argument_list|,
name|comp_mask
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|umad_send
argument_list|(
name|port
argument_list|,
name|agent
argument_list|,
name|umad
argument_list|,
name|len
argument_list|,
name|TMO
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|"umad_send leave failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|dbg
argument_list|(
literal|"umad_send %d: tid = 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|method
argument_list|,
name|mad_get_field64
argument_list|(
name|umad_get_mad
argument_list|(
name|umad
argument_list|)
argument_list|,
literal|0
argument_list|,
name|IB_MAD_TRID_F
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rereg_port_gid
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|agent
parameter_list|,
name|ib_portid_t
modifier|*
name|dport
parameter_list|,
name|uint8_t
modifier|*
name|umad
parameter_list|,
name|int
name|len
parameter_list|,
name|ibmad_gid_t
name|port_gid
parameter_list|)
block|{
name|uint8_t
name|data
index|[
name|IB_SA_DATA_SIZE
index|]
decl_stmt|;
name|uint64_t
name|comp_mask
decl_stmt|;
name|comp_mask
operator|=
name|build_mcm_rec
argument_list|(
name|data
argument_list|,
name|mgid_ipoib
argument_list|,
name|port_gid
argument_list|)
expr_stmt|;
name|build_mcm_rec_umad
argument_list|(
name|umad
argument_list|,
name|dport
argument_list|,
name|IB_MAD_METHOD_DELETE
argument_list|,
name|comp_mask
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|umad_send
argument_list|(
name|port
argument_list|,
name|agent
argument_list|,
name|umad
argument_list|,
name|len
argument_list|,
name|TMO
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|"umad_send leave failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|dbg
argument_list|(
literal|"umad_send leave: tid = 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|mad_get_field64
argument_list|(
name|umad_get_mad
argument_list|(
name|umad
argument_list|)
argument_list|,
literal|0
argument_list|,
name|IB_MAD_TRID_F
argument_list|)
argument_list|)
expr_stmt|;
name|build_mcm_rec_umad
argument_list|(
name|umad
argument_list|,
name|dport
argument_list|,
name|IB_MAD_METHOD_SET
argument_list|,
name|comp_mask
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|umad_send
argument_list|(
name|port
argument_list|,
name|agent
argument_list|,
name|umad
argument_list|,
name|len
argument_list|,
name|TMO
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|"umad_send join failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|dbg
argument_list|(
literal|"umad_send join: tid = 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|mad_get_field64
argument_list|(
name|umad_get_mad
argument_list|(
name|umad
argument_list|)
argument_list|,
literal|0
argument_list|,
name|IB_MAD_TRID_F
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_struct
struct|struct
name|guid_trid
block|{
name|ibmad_gid_t
name|gid
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|uint64_t
name|trid
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|rereg_send_all
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|agent
parameter_list|,
name|ib_portid_t
modifier|*
name|dport
parameter_list|,
name|struct
name|guid_trid
modifier|*
name|list
parameter_list|,
name|unsigned
name|cnt
parameter_list|)
block|{
name|uint8_t
modifier|*
name|umad
decl_stmt|;
name|int
name|len
init|=
name|umad_size
argument_list|()
operator|+
literal|256
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|info
argument_list|(
literal|"rereg_send_all... cnt = %u\n"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|umad
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|umad
condition|)
block|{
name|err
argument_list|(
literal|"cannot alloc mem for umad: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|rereg_port_gid
argument_list|(
name|port
argument_list|,
name|agent
argument_list|,
name|dport
argument_list|,
name|umad
argument_list|,
name|len
argument_list|,
name|list
index|[
name|i
index|]
operator|.
name|gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|"rereg_send_all: rereg_port_gid 0x%016"
name|PRIx64
literal|" failed\n"
argument_list|,
name|list
index|[
name|i
index|]
operator|.
name|guid
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|list
index|[
name|i
index|]
operator|.
name|trid
operator|=
name|mad_get_field64
argument_list|(
name|umad_get_mad
argument_list|(
name|umad
argument_list|)
argument_list|,
literal|0
argument_list|,
name|IB_MAD_TRID_F
argument_list|)
expr_stmt|;
block|}
name|info
argument_list|(
literal|"rereg_send_all: sent %u requests\n"
argument_list|,
name|cnt
operator|*
literal|2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|umad
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int rereg_mcm_rec_send(int port, int agent, ib_portid_t *dport, int cnt) { 	ib_portid_t portid; 	ibmad_gid_t port_gid; 	uint8_t *umad; 	int len, ret = 0;  	ib_resolve_self(&portid, NULL,&port_gid);  	len = umad_size() + 256; 	umad = calloc(1, len); 	if (!umad) { 		err("cannot alloc mem for umad: %s\n", strerror(errno)); 		return -1; 	}  	while(cnt--) { 		if (!rereg_port_gid(port, agent, dport, umad, len, port_gid)) 			ret += 2; 	}  	free(umad);  	return ret; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|rereg_recv
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|agent
parameter_list|,
name|ib_portid_t
modifier|*
name|dport
parameter_list|,
name|uint8_t
modifier|*
name|umad
parameter_list|,
name|int
name|length
parameter_list|,
name|int
name|tmo
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|retry
init|=
literal|0
decl_stmt|;
name|int
name|len
init|=
name|length
decl_stmt|;
while|while
condition|(
operator|(
name|ret
operator|=
name|umad_recv
argument_list|(
name|port
argument_list|,
name|umad
argument_list|,
operator|&
name|len
argument_list|,
name|tmo
argument_list|)
operator|)
operator|<
literal|0
operator|&&
name|errno
operator|==
name|ETIMEDOUT
condition|)
block|{
if|if
condition|(
name|retry
operator|++
operator|>
literal|3
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|"umad_recv %d failed: %s\n"
argument_list|,
name|ret
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|dbg
argument_list|(
literal|"umad_recv (retries %d), tid = 0x%016"
name|PRIx64
literal|": len = %d, status = %d\n"
argument_list|,
name|retry
argument_list|,
name|mad_get_field64
argument_list|(
name|umad_get_mad
argument_list|(
name|umad
argument_list|)
argument_list|,
literal|0
argument_list|,
name|IB_MAD_TRID_F
argument_list|)
argument_list|,
name|len
argument_list|,
name|umad_status
argument_list|(
name|umad
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rereg_recv_all
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|agent
parameter_list|,
name|ib_portid_t
modifier|*
name|dport
parameter_list|,
name|struct
name|guid_trid
modifier|*
name|list
parameter_list|,
name|unsigned
name|cnt
parameter_list|)
block|{
name|uint8_t
modifier|*
name|umad
decl_stmt|,
modifier|*
name|mad
decl_stmt|;
name|int
name|len
init|=
name|umad_size
argument_list|()
operator|+
literal|256
decl_stmt|;
name|uint64_t
name|trid
decl_stmt|;
name|unsigned
name|n
decl_stmt|,
name|method
decl_stmt|,
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
name|info
argument_list|(
literal|"rereg_recv_all...\n"
argument_list|)
expr_stmt|;
name|umad
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|umad
condition|)
block|{
name|err
argument_list|(
literal|"cannot alloc mem for umad: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|rereg_recv
argument_list|(
name|port
argument_list|,
name|agent
argument_list|,
name|dport
argument_list|,
name|umad
argument_list|,
name|len
argument_list|,
name|TMO
argument_list|)
operator|>
literal|0
condition|)
block|{
name|dbg
argument_list|(
literal|"rereg_recv_all: done %d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
name|mad
operator|=
name|umad_get_mad
argument_list|(
name|umad
argument_list|)
expr_stmt|;
name|method
operator|=
name|mad_get_field
argument_list|(
name|mad
argument_list|,
literal|0
argument_list|,
name|IB_MAD_METHOD_F
argument_list|)
expr_stmt|;
name|status
operator|=
name|mad_get_field
argument_list|(
name|mad
argument_list|,
literal|0
argument_list|,
name|IB_MAD_STATUS_F
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|dbg
argument_list|(
literal|"MAD status %x, method %x\n"
argument_list|,
name|status
argument_list|,
name|method
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&&
operator|(
name|method
operator|&
literal|0x7f
operator|)
operator|==
operator|(
name|IB_MAD_METHOD_GET_RESPONSE
operator|&
literal|0x7f
operator|)
condition|)
block|{
name|trid
operator|=
name|mad_get_field64
argument_list|(
name|mad
argument_list|,
literal|0
argument_list|,
name|IB_MAD_TRID_F
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|trid
operator|==
name|list
index|[
name|i
index|]
operator|.
name|trid
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|cnt
condition|)
block|{
name|err
argument_list|(
literal|"cannot find trid 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|trid
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|info
argument_list|(
literal|"guid 0x%016"
name|PRIx64
literal|": method = %x status = %x. Resending\n"
argument_list|,
name|ntohll
argument_list|(
name|list
index|[
name|i
index|]
operator|.
name|guid
argument_list|)
argument_list|,
name|method
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|rereg_port_gid
argument_list|(
name|port
argument_list|,
name|agent
argument_list|,
name|dport
argument_list|,
name|umad
argument_list|,
name|len
argument_list|,
name|list
index|[
name|i
index|]
operator|.
name|gid
argument_list|)
expr_stmt|;
name|list
index|[
name|i
index|]
operator|.
name|trid
operator|=
name|mad_get_field64
argument_list|(
name|umad_get_mad
argument_list|(
name|umad
argument_list|)
argument_list|,
literal|0
argument_list|,
name|IB_MAD_TRID_F
argument_list|)
expr_stmt|;
block|}
block|}
name|info
argument_list|(
literal|"rereg_recv_all: got %u responses\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|umad
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rereg_query_all
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|agent
parameter_list|,
name|ib_portid_t
modifier|*
name|dport
parameter_list|,
name|struct
name|guid_trid
modifier|*
name|list
parameter_list|,
name|unsigned
name|cnt
parameter_list|)
block|{
name|uint8_t
modifier|*
name|umad
decl_stmt|,
modifier|*
name|mad
decl_stmt|;
name|int
name|len
init|=
name|umad_size
argument_list|()
operator|+
literal|256
decl_stmt|;
name|unsigned
name|method
decl_stmt|,
name|status
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|info
argument_list|(
literal|"rereg_query_all...\n"
argument_list|)
expr_stmt|;
name|umad
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|umad
condition|)
block|{
name|err
argument_list|(
literal|"cannot alloc mem for umad: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|rereg_send
argument_list|(
name|port
argument_list|,
name|agent
argument_list|,
name|dport
argument_list|,
name|umad
argument_list|,
name|len
argument_list|,
name|IB_MAD_METHOD_GET
argument_list|,
name|list
index|[
name|i
index|]
operator|.
name|gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|"query_all: rereg_send failed.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ret
operator|=
name|rereg_recv
argument_list|(
name|port
argument_list|,
name|agent
argument_list|,
name|dport
argument_list|,
name|umad
argument_list|,
name|len
argument_list|,
name|TMO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|"query_all: rereg_recv failed.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mad
operator|=
name|umad_get_mad
argument_list|(
name|umad
argument_list|)
expr_stmt|;
name|method
operator|=
name|mad_get_field
argument_list|(
name|mad
argument_list|,
literal|0
argument_list|,
name|IB_MAD_METHOD_F
argument_list|)
expr_stmt|;
name|status
operator|=
name|mad_get_field
argument_list|(
name|mad
argument_list|,
literal|0
argument_list|,
name|IB_MAD_STATUS_F
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|info
argument_list|(
literal|"guid 0x%016"
name|PRIx64
literal|": status %x, method %x\n"
argument_list|,
name|ntohll
argument_list|(
name|list
index|[
name|i
index|]
operator|.
name|guid
argument_list|)
argument_list|,
name|status
argument_list|,
name|method
argument_list|)
expr_stmt|;
block|}
name|info
argument_list|(
literal|"rereg_query_all: %u queried.\n"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|umad
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int rereg_mcm_rec_recv(int port, int agent, int cnt) { 	uint8_t *umad, *mad; 	int len = umad_size() + 256; 	int i;  	umad = calloc(1, len); 	if (!umad) { 		err("cannot alloc mem for umad: %s\n", strerror(errno)); 		return -1; 	}  	for ( i = 0; i< cnt; i++ ) { 		int retry; 		retry = 0; 		while (umad_recv(port, umad,&len, TMO)< 0&& 		       errno == ETIMEDOUT) 			if (retry++> 3) { 				err("umad_recv %d failed: %s\n", 				    i, strerror(errno)); 				free(umad); 				return -1; 			} 		dbg("umad_recv %d (retries %d), tid = 0x%016" PRIx64 ": len = %d, status = %d\n", 		    i, retry, 		    mad_get_field64(umad_get_mad(umad), 0, IB_MAD_TRID_F), 		    len, umad_status(umad)); 		mad = umad_get_mad(umad); 	}  	free(umad); 	return 0; }
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAX_CLIENTS
value|50
end_define

begin_function
specifier|static
name|int
name|rereg_and_test_port
parameter_list|(
name|char
modifier|*
name|guid_file
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|agent
parameter_list|,
name|ib_portid_t
modifier|*
name|dport
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|char
name|line
index|[
literal|256
index|]
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|ibmad_gid_t
name|port_gid
decl_stmt|;
name|uint64_t
name|prefix
init|=
name|htonll
argument_list|(
literal|0xfe80000000000000llu
argument_list|)
decl_stmt|;
name|uint64_t
name|guid
init|=
name|htonll
argument_list|(
literal|0x0002c90200223825llu
argument_list|)
decl_stmt|;
name|struct
name|guid_trid
modifier|*
name|list
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|list
operator|=
name|calloc
argument_list|(
name|MAX_CLIENTS
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
block|{
name|err
argument_list|(
literal|"cannot alloc mem for guid/trid list: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|f
operator|=
name|fopen
argument_list|(
name|guid_file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|err
argument_list|(
literal|"cannot open %s: %s\n"
argument_list|,
name|guid_file
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|guid
operator|=
name|strtoull
argument_list|(
name|line
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|guid
operator|=
name|htonll
argument_list|(
name|guid
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|port_gid
index|[
literal|0
index|]
argument_list|,
operator|&
name|prefix
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|port_gid
index|[
literal|8
index|]
argument_list|,
operator|&
name|guid
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|list
index|[
name|i
index|]
operator|.
name|guid
operator|=
name|guid
expr_stmt|;
name|memcpy
argument_list|(
name|list
index|[
name|i
index|]
operator|.
name|gid
argument_list|,
name|port_gid
argument_list|,
sizeof|sizeof
argument_list|(
name|list
index|[
name|i
index|]
operator|.
name|gid
argument_list|)
argument_list|)
expr_stmt|;
name|list
index|[
name|i
index|]
operator|.
name|trid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|>=
name|MAX_CLIENTS
condition|)
break|break;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|rereg_send_all
argument_list|(
name|port
argument_list|,
name|agent
argument_list|,
name|dport
argument_list|,
name|list
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rereg_recv_all
argument_list|(
name|port
argument_list|,
name|agent
argument_list|,
name|dport
argument_list|,
name|list
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rereg_query_all
argument_list|(
name|port
argument_list|,
name|agent
argument_list|,
name|dport
argument_list|,
name|list
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|guid_file
init|=
literal|"port_guids.list"
decl_stmt|;
name|int
name|mgmt_classes
index|[
literal|2
index|]
init|=
block|{
name|IB_SMI_CLASS
block|,
name|IB_SMI_DIRECT_CLASS
block|}
decl_stmt|;
name|ib_portid_t
name|dport_id
decl_stmt|;
name|int
name|port
decl_stmt|,
name|agent
decl_stmt|;
name|uint8_t
modifier|*
name|umad
decl_stmt|,
modifier|*
name|mad
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|guid_file
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|madrpc_init
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|mgmt_classes
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
name|ib_resolve_smlid
argument_list|(
operator|&
name|dport_id
argument_list|,
name|TMO
argument_list|)
expr_stmt|;
else|#
directive|else
name|memset
argument_list|(
operator|&
name|dport_id
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dport_id
argument_list|)
argument_list|)
expr_stmt|;
name|dport_id
operator|.
name|lid
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|dport_id
operator|.
name|qp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|dport_id
operator|.
name|qkey
condition|)
name|dport_id
operator|.
name|qkey
operator|=
name|IB_DEFAULT_QP1_QKEY
expr_stmt|;
name|len
operator|=
name|umad_size
argument_list|()
operator|+
literal|256
expr_stmt|;
name|umad
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|umad
condition|)
block|{
name|err
argument_list|(
literal|"cannot alloc mem for umad: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|#
directive|if
literal|1
name|port
operator|=
name|madrpc_portid
argument_list|()
expr_stmt|;
else|#
directive|else
name|ret
operator|=
name|umad_init
argument_list|()
expr_stmt|;
name|port
operator|=
name|umad_open_port
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|"umad_open_port failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|port
return|;
block|}
endif|#
directive|endif
name|agent
operator|=
name|umad_register
argument_list|(
name|port
argument_list|,
name|IB_SA_CLASS
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|int cnt; 	cnt = rereg_mcm_rec_send(port, agent,&dport_id, cnt);  	rereg_recv_all(port, agent,&dport_id);
else|#
directive|else
name|rereg_and_test_port
argument_list|(
name|guid_file
argument_list|,
name|port
argument_list|,
name|agent
argument_list|,
operator|&
name|dport_id
argument_list|,
name|TMO
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mad
operator|=
name|umad_get_mad
argument_list|(
name|umad
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|umad
argument_list|)
expr_stmt|;
name|umad_unregister
argument_list|(
name|port
argument_list|,
name|agent
argument_list|)
expr_stmt|;
name|umad_close_port
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|umad_done
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

