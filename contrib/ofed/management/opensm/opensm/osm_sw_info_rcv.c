begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2008 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2005 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_si_rcv_t.  * This object represents the SwitchInfo Receiver object.  * This object is part of the opensm family of objects.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qmap.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_passivelock.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_switch.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_subnet.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_comment
comment|/**********************************************************************  The plock must be held before calling this function. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_si_rcv_get_port_info
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_switch_t
modifier|*
specifier|const
name|p_sw
parameter_list|)
block|{
name|osm_madw_context_t
name|context
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|uint8_t
name|num_ports
decl_stmt|;
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
name|p_node
operator|=
name|p_sw
operator|->
name|p_node
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|osm_node_get_type
argument_list|(
name|p_node
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
argument_list|)
expr_stmt|;
comment|/* 	   Request PortInfo attribute for each port on the switch. 	 */
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|port_guid
operator|=
name|osm_physp_get_port_guid
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|set_method
operator|=
name|FALSE
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|light_sweep
operator|=
name|FALSE
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|active_transition
operator|=
name|FALSE
expr_stmt|;
name|num_ports
operator|=
name|osm_node_get_num_physp
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
for|for
control|(
name|port_num
operator|=
literal|0
init|;
name|port_num
operator|<
name|num_ports
condition|;
name|port_num
operator|++
control|)
block|{
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
argument_list|,
name|IB_MAD_ATTR_PORT_INFO
argument_list|,
name|cl_hton32
argument_list|(
name|port_num
argument_list|)
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
comment|/* continue the loop despite the error */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3602: "
literal|"Failure initiating PortInfo request (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/**********************************************************************  The plock must be held before calling this function. **********************************************************************/
end_comment

begin_comment
unit|static void __osm_si_rcv_get_fwd_tbl(IN osm_sm_t * sm, IN osm_switch_t * const p_sw) { 	osm_madw_context_t context; 	osm_dr_path_t *p_dr_path; 	osm_physp_t *p_physp; 	osm_node_t *p_node; 	uint32_t block_id_ho; 	uint32_t max_block_id_ho; 	ib_api_status_t status = IB_SUCCESS;  	OSM_LOG_ENTER(sm->p_log);  	CL_ASSERT(p_sw);  	p_node = p_sw->p_node;  	CL_ASSERT(osm_node_get_type(p_node) == IB_NODE_TYPE_SWITCH);  	context.lft_context.node_guid = osm_node_get_node_guid(p_node); 	context.lft_context.set_method = FALSE;  	max_block_id_ho = osm_switch_get_max_block_id_in_use(p_sw);  	p_physp = osm_node_get_physp_ptr(p_node, 0); 	p_dr_path = osm_physp_get_dr_path_ptr(p_physp);  	for (block_id_ho = 0; block_id_ho<= max_block_id_ho; block_id_ho++) { 		OSM_LOG(sm->p_log, OSM_LOG_DEBUG, 			"Retrieving FT block %u\n", block_id_ho);  		status = osm_req_get(sm, p_dr_path, IB_MAD_ATTR_LIN_FWD_TBL, 				     cl_hton32(block_id_ho), 				     CL_DISP_MSGID_NONE,&context); 		if (status != IB_SUCCESS)
comment|/* continue the loop despite the error */
end_comment

begin_comment
unit|OSM_LOG(sm->p_log, OSM_LOG_ERROR, "ERR 3603: " 				"Failure initiating PortInfo request (%s)\n", 				ib_get_err_str(status)); 	}  	OSM_LOG_EXIT(sm->p_log); }
comment|/**********************************************************************  The plock must be held before calling this function. **********************************************************************/
end_comment

begin_comment
unit|static void __osm_si_rcv_get_mcast_fwd_tbl(IN osm_sm_t * sm, IN osm_switch_t * const p_sw) { 	osm_madw_context_t context; 	osm_dr_path_t *p_dr_path; 	osm_physp_t *p_physp; 	osm_node_t *p_node; 	osm_mcast_tbl_t *p_tbl; 	uint32_t block_id_ho; 	uint32_t max_block_id_ho; 	uint32_t position; 	uint32_t max_position; 	uint32_t attr_mod_ho; 	ib_api_status_t status = IB_SUCCESS;  	OSM_LOG_ENTER(sm->p_log);  	CL_ASSERT(p_sw);  	p_node = p_sw->p_node;  	CL_ASSERT(osm_node_get_type(p_node) == IB_NODE_TYPE_SWITCH);  	if (osm_switch_get_mcast_fwd_tbl_size(p_sw) == 0) { 		OSM_LOG(sm->p_log, OSM_LOG_DEBUG, 			"Multicast not supported by switch 0x%016" PRIx64 "\n", 			cl_ntoh64(osm_node_get_node_guid(p_node))); 		goto Exit; 	}  	context.mft_context.node_guid = osm_node_get_node_guid(p_node); 	context.mft_context.set_method = FALSE;  	p_tbl = osm_switch_get_mcast_tbl_ptr(p_sw); 	max_block_id_ho = osm_mcast_tbl_get_max_block(p_tbl);  	if (max_block_id_ho> IB_MCAST_MAX_BLOCK_ID) { 		OSM_LOG(sm->p_log, OSM_LOG_ERROR, "ERR 3609: " 			"Out-of-range mcast block size = %u on switch 0x%016" 			PRIx64 "\n", max_block_id_ho, 			cl_ntoh64(osm_node_get_node_guid(p_node))); 		goto Exit; 	}  	max_position = osm_mcast_tbl_get_max_position(p_tbl);  	CL_ASSERT(max_position<= IB_MCAST_POSITION_MAX);  	OSM_LOG(sm->p_log, OSM_LOG_DEBUG, 		"Max MFT block = %u, Max position = %u\n", max_block_id_ho, 		max_position);  	p_physp = osm_node_get_physp_ptr(p_node, 0); 	p_dr_path = osm_physp_get_dr_path_ptr(p_physp);  	for (block_id_ho = 0; block_id_ho<= max_block_id_ho; block_id_ho++) { 		OSM_LOG(sm->p_log, OSM_LOG_DEBUG, 			"Retrieving MFT block %u\n", block_id_ho);  		for (position = 0; position<= max_position; position++) { 			OSM_LOG(sm->p_log, OSM_LOG_DEBUG, 				"Retrieving MFT position %u\n", position);  			attr_mod_ho = 			    block_id_ho | position<< IB_MCAST_POSITION_SHIFT; 			status = 			    osm_req_get(sm, p_dr_path, 					IB_MAD_ATTR_MCAST_FWD_TBL, 					cl_hton32(attr_mod_ho), 					CL_DISP_MSGID_NONE,&context); 			if (status != IB_SUCCESS)
comment|/* continue the loop despite the error */
end_comment

begin_endif
unit|OSM_LOG(sm->p_log, OSM_LOG_ERROR, "ERR 3607: " 					"Failure initiating PortInfo request (%s)\n", 					ib_get_err_str(status)); 		} 	}  Exit: 	OSM_LOG_EXIT(sm->p_log); }
endif|#
directive|endif
end_endif

begin_comment
comment|/**********************************************************************    Lock must be held on entry to this function. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_si_rcv_process_new
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
specifier|const
name|p_node
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|)
block|{
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_check
decl_stmt|;
name|ib_switch_info_t
modifier|*
name|p_si
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|cl_qmap_t
modifier|*
name|p_sw_guid_tbl
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_sw_guid_tbl
operator|=
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_si
operator|=
operator|(
name|ib_switch_info_t
operator|*
operator|)
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
name|osm_dump_switch_info
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|p_si
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
expr_stmt|;
comment|/* 	   Allocate a new switch object for this switch, 	   and place it in the switch table. 	 */
name|p_sw
operator|=
name|osm_switch_new
argument_list|(
name|p_node
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3608: "
literal|"Unable to allocate new switch object\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* set subnet max mlid to the minimum MulticastFDBCap of all switches */
if|if
condition|(
name|p_sw
operator|->
name|mcast_tbl
operator|.
name|max_mlid_ho
operator|<
name|sm
operator|->
name|p_subn
operator|->
name|max_mcast_lid_ho
condition|)
block|{
name|sm
operator|->
name|p_subn
operator|->
name|max_mcast_lid_ho
operator|=
name|p_sw
operator|->
name|mcast_tbl
operator|.
name|max_mlid_ho
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Subnet max multicast lid is 0x%X\n"
argument_list|,
name|sm
operator|->
name|p_subn
operator|->
name|max_mcast_lid_ho
argument_list|)
expr_stmt|;
block|}
comment|/* set subnet max unicast lid to the minimum LinearFDBCap of all switches */
if|if
condition|(
name|cl_ntoh16
argument_list|(
name|p_si
operator|->
name|lin_cap
argument_list|)
operator|<
name|sm
operator|->
name|p_subn
operator|->
name|max_ucast_lid_ho
condition|)
block|{
name|sm
operator|->
name|p_subn
operator|->
name|max_ucast_lid_ho
operator|=
name|cl_ntoh16
argument_list|(
name|p_si
operator|->
name|lin_cap
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Subnet max unicast lid is 0x%X\n"
argument_list|,
name|sm
operator|->
name|p_subn
operator|->
name|max_ucast_lid_ho
argument_list|)
expr_stmt|;
block|}
name|p_check
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_insert
argument_list|(
name|p_sw_guid_tbl
argument_list|,
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|,
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_check
operator|!=
name|p_sw
condition|)
block|{
comment|/* 		   This shouldn't happen since we hold the lock! 		 */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3605: "
literal|"Unable to add new switch object to database\n"
argument_list|)
expr_stmt|;
name|osm_switch_delete
argument_list|(
operator|&
name|p_sw
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_node
operator|->
name|sw
operator|=
name|p_sw
expr_stmt|;
comment|/* 	   Update the switch info according to the 	   info we just received. 	 */
name|osm_switch_set_switch_info
argument_list|(
name|p_sw
argument_list|,
name|p_si
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|discovery_count
operator|++
expr_stmt|;
comment|/* 	   Get the PortInfo attribute for every port. 	 */
name|__osm_si_rcv_get_port_info
argument_list|(
name|sm
argument_list|,
name|p_sw
argument_list|)
expr_stmt|;
comment|/* 	   Don't bother retrieving the current unicast and multicast tables 	   from the switches.  The current version of SM does 	   not support silent take-over of an existing multicast 	   configuration.  	   Gathering the multicast tables can also generate large amounts 	   of extra subnet-init traffic.  	   The code to retrieve the tables was fully debugged. 	 */
if|#
directive|if
literal|0
block|__osm_si_rcv_get_fwd_tbl(sm, p_sw); 	if (!sm->p_subn->opt.disable_multicast) 		__osm_si_rcv_get_mcast_fwd_tbl(sm, p_sw);
endif|#
directive|endif
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************    Lock must be held on entry to this function.    Return 1 if the caller is expected to send a change_detected event.    this can not be done internally as the event needs the lock... **********************************************************************/
end_comment

begin_function
specifier|static
name|boolean_t
name|__osm_si_rcv_process_existing
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
specifier|const
name|p_node
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|)
block|{
name|osm_switch_t
modifier|*
name|p_sw
init|=
name|p_node
operator|->
name|sw
decl_stmt|;
name|ib_switch_info_t
modifier|*
name|p_si
decl_stmt|;
name|osm_si_context_t
modifier|*
name|p_si_context
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|boolean_t
name|is_change_detected
init|=
name|FALSE
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_si
operator|=
operator|(
name|ib_switch_info_t
operator|*
operator|)
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
name|p_si_context
operator|=
name|osm_madw_get_si_context_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_si_context
operator|->
name|set_method
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Received logical SetResp()\n"
argument_list|)
expr_stmt|;
name|osm_switch_set_switch_info
argument_list|(
name|p_sw
argument_list|,
name|p_si
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Received logical GetResp()\n"
argument_list|)
expr_stmt|;
name|osm_switch_set_switch_info
argument_list|(
name|p_sw
argument_list|,
name|p_si
argument_list|)
expr_stmt|;
comment|/* 		   Check the port state change bit.  If true, then this switch 		   has seen a port state transition, so continue probing. 		 */
if|if
condition|(
name|p_si_context
operator|->
name|light_sweep
operator|==
name|TRUE
condition|)
block|{
comment|/* This is a light sweep */
comment|/* If the mad was returned with an error - 			   signal a change to the state manager. */
if|if
condition|(
name|ib_smp_get_status
argument_list|(
name|p_smp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"GetResp() received with error in light sweep. "
literal|"Commencing heavy sweep\n"
argument_list|)
expr_stmt|;
name|is_change_detected
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 				   If something changed, then just signal the 				   state manager.  Don't attempt to probe 				   further during a light sweep. 				 */
if|if
condition|(
name|ib_switch_info_get_state_change
argument_list|(
name|p_si
argument_list|)
condition|)
block|{
name|osm_dump_switch_info
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|p_si
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
expr_stmt|;
name|is_change_detected
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 			   This is a heavy sweep.  Get information regardless 			   of the state change bit. 			 */
name|p_sw
operator|->
name|discovery_count
operator|++
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"discovery_count is:%u\n"
argument_list|,
name|p_sw
operator|->
name|discovery_count
argument_list|)
expr_stmt|;
comment|/* If this is the first discovery - then get the port_info */
if|if
condition|(
name|p_sw
operator|->
name|discovery_count
operator|==
literal|1
condition|)
name|__osm_si_rcv_get_port_info
argument_list|(
name|sm
argument_list|,
name|p_sw
argument_list|)
expr_stmt|;
else|else
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Not discovering again through switch:0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|osm_node_get_node_guid
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|is_change_detected
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|void
name|osm_si_rcv_process
parameter_list|(
name|IN
name|void
modifier|*
name|context
parameter_list|,
name|IN
name|void
modifier|*
name|data
parameter_list|)
block|{
name|osm_sm_t
modifier|*
name|sm
init|=
name|context
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_madw
init|=
name|data
decl_stmt|;
name|ib_switch_info_t
modifier|*
name|p_si
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|ib_net64_t
name|node_guid
decl_stmt|;
name|osm_si_context_t
modifier|*
name|p_context
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_si
operator|=
operator|(
name|ib_switch_info_t
operator|*
operator|)
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
comment|/* 	   Acquire the switch object and add the switch info. 	 */
name|p_context
operator|=
name|osm_madw_get_si_context_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|node_guid
operator|=
name|p_context
operator|->
name|node_guid
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Switch GUID 0x%016"
name|PRIx64
literal|", TID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|node_guid
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_smp
operator|->
name|trans_id
argument_list|)
argument_list|)
expr_stmt|;
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|p_node
operator|=
name|osm_get_node_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|node_guid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_node
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3606: "
literal|"SwitchInfo received for nonexistent node "
literal|"with GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|node_guid
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 		   Hack for bad value in Mellanox switch 		 */
if|if
condition|(
name|cl_ntoh16
argument_list|(
name|p_si
operator|->
name|lin_top
argument_list|)
operator|>
name|IB_LID_UCAST_END_HO
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3610: "
literal|"\n\t\t\t\tBad LinearFDBTop value = 0x%X "
literal|"on switch 0x%"
name|PRIx64
literal|"\n\t\t\t\tForcing internal correction to 0x%X\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_si
operator|->
name|lin_top
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p_si
operator|->
name|lin_top
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		   Acquire the switch object for this switch. 		 */
if|if
condition|(
operator|!
name|p_node
operator|->
name|sw
condition|)
block|{
name|__osm_si_rcv_process_new
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
comment|/* 			   A new switch was found during the sweep so we need 			   to ignore the current LFT settings. 			 */
name|sm
operator|->
name|p_subn
operator|->
name|ignore_existing_lfts
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* we might get back a request for signaling change was detected */
if|if
condition|(
name|__osm_si_rcv_process_existing
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_madw
argument_list|)
condition|)
block|{
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|force_heavy_sweep
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
block|}
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

