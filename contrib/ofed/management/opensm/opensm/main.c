begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2008 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2008 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Command line interface for opensm.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<vendor/osm_vendor_api.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_version.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_console.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_console_io.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_perfmgr.h>
end_include

begin_decl_stmt
specifier|volatile
name|unsigned
name|int
name|osm_exit_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|unsigned
name|int
name|osm_hup_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|unsigned
name|int
name|osm_usr1_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|GUID_ARRAY_SIZE
value|64
end_define

begin_define
define|#
directive|define
name|INVALID_GUID
value|(0xFFFFFFFFFFFFFFFFULL)
end_define

begin_function
specifier|static
name|void
name|mark_exit_flag
parameter_list|(
name|int
name|signum
parameter_list|)
block|{
if|if
condition|(
operator|!
name|osm_exit_flag
condition|)
name|printf
argument_list|(
literal|"OpenSM: Got signal %d - exiting...\n"
argument_list|,
name|signum
argument_list|)
expr_stmt|;
name|osm_exit_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mark_hup_flag
parameter_list|(
name|int
name|signum
parameter_list|)
block|{
name|osm_hup_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mark_usr1_flag
parameter_list|(
name|int
name|signum
parameter_list|)
block|{
name|osm_usr1_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|sigset_t
name|saved_sigset
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|block_signals
parameter_list|()
block|{
name|sigset_t
name|set
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|HAVE_OLD_LINUX_THREADS
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGUSR1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pthread_sigmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|set
argument_list|,
operator|&
name|saved_sigset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup_signals
parameter_list|()
block|{
name|struct
name|sigaction
name|act
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|mark_exit_flag
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGTERM
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|mark_hup_flag
expr_stmt|;
name|sigaction
argument_list|(
name|SIGHUP
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGCONT
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|HAVE_OLD_LINUX_THREADS
name|act
operator|.
name|sa_handler
operator|=
name|mark_usr1_flag
expr_stmt|;
name|sigaction
argument_list|(
name|SIGUSR1
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pthread_sigmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|saved_sigset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|show_usage
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\n------- OpenSM - Usage and options ----------------------\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Usage:   opensm [options]\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Options:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--version\n          Prints OpenSM version and exits.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--config, -F<file-name>\n"
literal|"          The name of the OpenSM config file. When not specified\n"
literal|"          "
name|OSM_DEFAULT_CONFIG_FILE
literal|" will be used (if exists).\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--create-config, -c<file-name>\n"
literal|"          OpenSM will dump its configuration to the specified file and exit.\n"
literal|"          This is a way to generate OpenSM configuration file template.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--guid, -g<GUID in hex>\n"
literal|"          This option specifies the local port GUID value\n"
literal|"          with which OpenSM should bind.  OpenSM may be\n"
literal|"          bound to 1 port at a time.\n"
literal|"          If GUID given is 0, OpenSM displays a list\n"
literal|"          of possible port GUIDs and waits for user input.\n"
literal|"          Without -g, OpenSM tries to use the default port.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--lmc, -l<LMC>\n"
literal|"          This option specifies the subnet's LMC value.\n"
literal|"          The number of LIDs assigned to each port is 2^LMC.\n"
literal|"          The LMC value must be in the range 0-7.\n"
literal|"          LMC values> 0 allow multiple paths between ports.\n"
literal|"          LMC values> 0 should only be used if the subnet\n"
literal|"          topology actually provides multiple paths between\n"
literal|"          ports, i.e. multiple interconnects between switches.\n"
literal|"          Without -l, OpenSM defaults to LMC = 0, which allows\n"
literal|"          one path between any two ports.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--priority, -p<PRIORITY>\n"
literal|"          This option specifies the SM's PRIORITY.\n"
literal|"          This will effect the handover cases, where master\n"
literal|"          is chosen by priority and GUID.  Range goes\n"
literal|"          from 0 (lowest priority) to 15 (highest).\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--smkey, -k<SM_Key>\n"
literal|"          This option specifies the SM's SM_Key (64 bits).\n"
literal|"          This will effect SM authentication.\n"
literal|"          Note that OpenSM version 3.2.1 and below used the\n"
literal|"          default value '1' in a host byte order, it is fixed\n"
literal|"          now but you may need this option to interoperate\n"
literal|"          with old OpenSM running on a little endian machine.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--reassign_lids, -r\n"
literal|"          This option causes OpenSM to reassign LIDs to all\n"
literal|"          end nodes. Specifying -r on a running subnet\n"
literal|"          may disrupt subnet traffic.\n"
literal|"          Without -r, OpenSM attempts to preserve existing\n"
literal|"          LID assignments resolving multiple use of same LID.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--routing_engine, -R<engine name>\n"
literal|"          This option chooses routing engine(s) to use instead of default\n"
literal|"          Min Hop algorithm.  Multiple routing engines can be specified\n"
literal|"          separated by commas so that specific ordering of routing\n"
literal|"          algorithms will be tried if earlier routing engines fail.\n"
literal|"          Supported engines: updn, file, ftree, lash, dor\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--connect_roots, -z\n"
literal|"          This option enforces a routing engine (currently\n"
literal|"          up/down only) to make connectivity between root switches\n"
literal|"          and in this way be IBA compliant. In many cases,\n"
literal|"          this can violate \"pure\" deadlock free algorithm, so\n"
literal|"          use it carefully.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--ucast_cache, -A\n"
literal|"          This option enables unicast routing cache to prevent\n"
literal|"          routing recalculation (which is a heavy task in a\n"
literal|"          large cluster) when there was no topology change\n"
literal|"          detected during the heavy sweep, or when the topology\n"
literal|"          change does not require new routing calculation,\n"
literal|"          e.g. in case of host reboot.\n"
literal|"          This option becomes very handy when the cluster size\n"
literal|"          is thousands of nodes.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--lid_matrix_file, -M<file name>\n"
literal|"          This option specifies the name of the lid matrix dump file\n"
literal|"          from where switch lid matrices (min hops tables will be\n"
literal|"          loaded.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--lfts_file, -U<file name>\n"
literal|"          This option specifies the name of the LFTs file\n"
literal|"          from where switch forwarding tables will be loaded.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--sadb_file, -S<file name>\n"
literal|"          This option specifies the name of the SA DB dump file\n"
literal|"          from where SA database will be loaded.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--root_guid_file, -a<path to file>\n"
literal|"          Set the root nodes for the Up/Down or Fat-Tree routing\n"
literal|"          algorithm to the guids provided in the given file (one\n"
literal|"          to a line)\n"
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--cn_guid_file, -u<path to file>\n"
literal|"          Set the compute nodes for the Fat-Tree routing algorithm\n"
literal|"          to the guids provided in the given file (one to a line)\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--ids_guid_file, -m<path to file>\n"
literal|"          Name of the map file with set of the IDs which will be used\n"
literal|"          by Up/Down routing algorithm instead of node GUIDs\n"
literal|"          (format:<guid><id> per line)\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--guid_routing_order_file, -X<path to file>\n"
literal|"          Set the order port guids will be routed for the MinHop\n"
literal|"          and Up/Down routing algorithms to the guids provided in the\n"
literal|"          given file (one to a line)\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--once, -o\n"
literal|"          This option causes OpenSM to configure the subnet\n"
literal|"          once, then exit.  Ports remain in the ACTIVE state.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--sweep, -s<interval>\n"
literal|"          This option specifies the number of seconds between\n"
literal|"          subnet sweeps.  Specifying -s 0 disables sweeping.\n"
literal|"          Without -s, OpenSM defaults to a sweep interval of\n"
literal|"          10 seconds.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--timeout, -t<milliseconds>\n"
literal|"          This option specifies the time in milliseconds\n"
literal|"          used for transaction timeouts.\n"
literal|"          Specifying -t 0 disables timeouts.\n"
literal|"          Without -t, OpenSM defaults to a timeout value of\n"
literal|"          200 milliseconds.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--maxsmps, -n<number>\n"
literal|"          This option specifies the number of VL15 SMP MADs\n"
literal|"          allowed on the wire at any one time.\n"
literal|"          Specifying --maxsmps 0 allows unlimited outstanding\n"
literal|"          SMPs.\n"
literal|"          Without --maxsmps, OpenSM defaults to a maximum of\n"
literal|"          4 outstanding SMPs.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--console, -q [off|local"
ifdef|#
directive|ifdef
name|ENABLE_OSM_CONSOLE_SOCKET
literal|"|socket|loopback"
endif|#
directive|endif
literal|"]\n          This option activates the OpenSM console (default off).\n\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_OSM_CONSOLE_SOCKET
name|printf
argument_list|(
literal|"--console-port, -C<port>\n"
literal|"          Specify an alternate telnet port for the console (default %d).\n\n"
argument_list|,
name|OSM_DEFAULT_CONSOLE_PORT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"--ignore-guids, -i<equalize-ignore-guids-file>\n"
literal|"          This option provides the means to define a set of ports\n"
literal|"          (by guid) that will be ignored by the link load\n"
literal|"          equalization algorithm.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--honor_guid2lid, -x\n"
literal|"          This option forces OpenSM to honor the guid2lid file,\n"
literal|"          when it comes out of Standby state, if such file exists\n"
literal|"          under OSM_CACHE_DIR, and is valid. By default, this is FALSE.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--log_file, -f<log-file-name>\n"
literal|"          This option defines the log to be the given file.\n"
literal|"          By default, the log goes to /var/log/opensm.log.\n"
literal|"          For the log to go to standard output use -f stdout.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--log_limit, -L<size in MB>\n"
literal|"          This option defines maximal log file size in MB. When\n"
literal|"          specified the log file will be truncated upon reaching\n"
literal|"          this limit.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--erase_log_file, -e\n"
literal|"          This option will cause deletion of the log file\n"
literal|"          (if it previously exists). By default, the log file\n"
literal|"          is accumulative.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--Pconfig, -P<partition-config-file>\n"
literal|"          This option defines the optional partition configuration file.\n"
literal|"          The default name is \'"
name|OSM_DEFAULT_PARTITION_CONFIG_FILE
literal|"\'.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--no_part_enforce, -N\n"
literal|"          This option disables partition enforcement on switch external ports.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--qos, -Q\n"
literal|"          This option enables QoS setup.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--qos_policy_file, -Y<QoS-policy-file>\n"
literal|"          This option defines the optional QoS policy file.\n"
literal|"          The default name is \'"
name|OSM_DEFAULT_QOS_POLICY_FILE
literal|"\'.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--stay_on_fatal, -y\n"
literal|"          This option will cause SM not to exit on fatal initialization\n"
literal|"          issues: if SM discovers duplicated guids or 12x link with\n"
literal|"          lane reversal badly configured.\n"
literal|"          By default, the SM will exit on these errors.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--daemon, -B\n"
literal|"          Run in daemon mode - OpenSM will run in the background.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--inactive, -I\n"
literal|"           Start SM in inactive rather than normal init SM state.\n\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_OSM_PERF_MGR
name|printf
argument_list|(
literal|"--perfmgr\n"
literal|"           Start with PerfMgr enabled.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--perfmgr_sweep_time_s<sec.>\n"
literal|"           PerfMgr sweep interval in seconds.\n\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"--prefix_routes_file<path to file>\n"
literal|"          This option specifies the prefix routes file.\n"
literal|"          Prefix routes control how the SA responds to path record\n"
literal|"          queries for off-subnet DGIDs.  Default file is:\n"
literal|"              "
name|OSM_DEFAULT_PREFIX_ROUTES_FILE
literal|"\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--consolidate_ipv6_snm_req\n"
literal|"          Consolidate IPv6 Solicited Node Multicast group joins\n"
literal|"          into 1 IB multicast group.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--verbose, -v\n"
literal|"          This option increases the log verbosity level.\n"
literal|"          The -v option may be specified multiple times\n"
literal|"          to further increase the verbosity level.\n"
literal|"          See the -D option for more information about\n"
literal|"          log verbosity.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--V, -V\n"
literal|"          This option sets the maximum verbosity level and\n"
literal|"          forces log flushing.\n"
literal|"          The -V is equivalent to '-D 0xFF -d 2'.\n"
literal|"          See the -D option for more information about\n"
literal|"          log verbosity.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--D, -D<flags>\n"
literal|"          This option sets the log verbosity level.\n"
literal|"          A flags field must follow the -D option.\n"
literal|"          A bit set/clear in the flags enables/disables a\n"
literal|"          specific log level as follows:\n"
literal|"          BIT    LOG LEVEL ENABLED\n"
literal|"          ----   -----------------\n"
literal|"          0x01 - ERROR (error messages)\n"
literal|"          0x02 - INFO (basic messages, low volume)\n"
literal|"          0x04 - VERBOSE (interesting stuff, moderate volume)\n"
literal|"          0x08 - DEBUG (diagnostic, high volume)\n"
literal|"          0x10 - FUNCS (function entry/exit, very high volume)\n"
literal|"          0x20 - FRAMES (dumps all SMP and GMP frames)\n"
literal|"          0x40 - ROUTING (dump FDB routing information)\n"
literal|"          0x80 - currently unused.\n"
literal|"          Without -D, OpenSM defaults to ERROR + INFO (0x3).\n"
literal|"          Specifying -D 0 disables all messages.\n"
literal|"          Specifying -D 0xFF enables all messages (see -V).\n"
literal|"          High verbosity levels may require increasing\n"
literal|"          the transaction timeout with the -t option.\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--debug, -d<number>\n"
literal|"          This option specifies a debug option.\n"
literal|"          These options are not normally needed.\n"
literal|"          The number following -d selects the debug\n"
literal|"          option to enable as follows:\n"
literal|"          OPT   Description\n"
literal|"          ---    -----------------\n"
literal|"          -d0  - Ignore other SM nodes\n"
literal|"          -d1  - Force single threaded dispatching\n"
literal|"          -d2  - Force log flushing after each log message\n"
literal|"          -d3  - Disable multicast support\n"
literal|"          -d10 - Put OpenSM in testability mode\n"
literal|"          Without -d, no debug options are enabled\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--help, -h, -?\n"
literal|"          Display this usage info then exit.\n\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_net64_t
name|get_port_guid
parameter_list|(
name|IN
name|osm_opensm_t
modifier|*
name|p_osm
parameter_list|,
name|uint64_t
name|port_guid
parameter_list|)
block|{
name|ib_port_attr_t
name|attr_array
index|[
name|GUID_ARRAY_SIZE
index|]
decl_stmt|;
name|uint32_t
name|num_ports
init|=
name|GUID_ARRAY_SIZE
decl_stmt|;
name|char
name|junk
index|[
literal|128
index|]
decl_stmt|;
name|uint32_t
name|i
decl_stmt|,
name|choice
init|=
literal|0
decl_stmt|;
name|boolean_t
name|done_flag
init|=
name|FALSE
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
comment|/* 	   Call the transport layer for a list of local port 	   GUID values. 	 */
name|status
operator|=
name|osm_vendor_get_all_port_attr
argument_list|(
name|p_osm
operator|->
name|p_vendor
argument_list|,
name|attr_array
argument_list|,
operator|&
name|num_ports
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"\nError from osm_vendor_get_all_port_attr (%x)\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* if num_ports is 0 - return 0 */
if|if
condition|(
name|num_ports
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\nNo local ports detected!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* If num_ports is 1, then there is only one possible port to use. 	 * Use it. */
if|if
condition|(
name|num_ports
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Using default GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_hton64
argument_list|(
name|attr_array
index|[
literal|0
index|]
operator|.
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|attr_array
index|[
literal|0
index|]
operator|.
name|port_guid
operator|)
return|;
block|}
comment|/* If port_guid is 0 - use the first connected port */
if|if
condition|(
name|port_guid
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ports
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|attr_array
index|[
name|i
index|]
operator|.
name|link_state
operator|>
name|IB_LINK_DOWN
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|num_ports
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"Using default GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_hton64
argument_list|(
name|attr_array
index|[
name|i
index|]
operator|.
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|attr_array
index|[
name|i
index|]
operator|.
name|port_guid
operator|)
return|;
block|}
if|if
condition|(
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|daemon
condition|)
return|return
literal|0
return|;
comment|/* More than one possible port - list all ports and let the user 	 * to choose. */
while|while
condition|(
name|done_flag
operator|==
name|FALSE
condition|)
block|{
name|printf
argument_list|(
literal|"\nChoose a local port number with which to bind:\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ports
condition|;
name|i
operator|++
control|)
comment|/* Print the index + 1 since by convention, port 			 * numbers start with 1 on host channel adapters. */
name|printf
argument_list|(
literal|"\t%u: GUID 0x%"
name|PRIx64
literal|", lid %u, state %s\n"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|cl_ntoh64
argument_list|(
name|attr_array
index|[
name|i
index|]
operator|.
name|port_guid
argument_list|)
argument_list|,
name|attr_array
index|[
name|i
index|]
operator|.
name|lid
argument_list|,
name|ib_get_port_state_str
argument_list|(
name|attr_array
index|[
name|i
index|]
operator|.
name|link_state
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nEnter choice (1-%u): "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|scanf
argument_list|(
literal|"%u"
argument_list|,
operator|&
name|choice
argument_list|)
condition|)
block|{
if|if
condition|(
name|choice
operator|>
name|num_ports
operator|||
name|choice
operator|<
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\nError: Lame choice!\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|choice
operator|--
expr_stmt|;
name|done_flag
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* get rid of the junk in the selection line */
name|scanf
argument_list|(
literal|"%s"
argument_list|,
name|junk
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nError: Lame choice!\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"Choice guid=0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|attr_array
index|[
name|choice
index|]
operator|.
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|attr_array
index|[
name|choice
index|]
operator|.
name|port_guid
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|daemonize
parameter_list|(
name|osm_opensm_t
modifier|*
name|osm
parameter_list|)
block|{
name|pid_t
name|pid
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_WRONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"open"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|setsid
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|fd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|int
name|osm_manager_loop
parameter_list|(
name|osm_subn_opt_t
modifier|*
name|p_opt
parameter_list|,
name|osm_opensm_t
modifier|*
name|p_osm
parameter_list|)
block|{
name|int
name|console_init_flag
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|is_console_enabled
argument_list|(
name|p_opt
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|osm_console_init
argument_list|(
name|p_opt
argument_list|,
operator|&
name|p_osm
operator|->
name|console
argument_list|,
operator|&
name|p_osm
operator|->
name|log
argument_list|)
condition|)
name|console_init_flag
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	   Sit here forever - dwell or do console i/o& cmds 	 */
while|while
condition|(
operator|!
name|osm_exit_flag
condition|)
block|{
if|if
condition|(
name|console_init_flag
condition|)
name|osm_console
argument_list|(
name|p_osm
argument_list|)
expr_stmt|;
else|else
name|cl_thread_suspend
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_usr1_flag
condition|)
block|{
name|osm_usr1_flag
operator|=
literal|0
expr_stmt|;
name|osm_log_reopen_file
argument_list|(
operator|&
operator|(
name|p_osm
operator|->
name|log
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|osm_hup_flag
condition|)
block|{
name|osm_hup_flag
operator|=
literal|0
expr_stmt|;
comment|/* a HUP signal should only start a new heavy sweep */
name|p_osm
operator|->
name|subn
operator|.
name|force_heavy_sweep
operator|=
name|TRUE
expr_stmt|;
name|osm_opensm_sweep
argument_list|(
name|p_osm
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|is_console_enabled
argument_list|(
name|p_opt
argument_list|)
condition|)
name|osm_console_exit
argument_list|(
operator|&
name|p_osm
operator|->
name|console
argument_list|,
operator|&
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|osm_opensm_t
name|osm
decl_stmt|;
name|osm_subn_opt_t
name|opt
decl_stmt|;
name|ib_net64_t
name|sm_key
init|=
literal|0
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|,
name|dbg_lvl
decl_stmt|;
name|boolean_t
name|run_once_flag
init|=
name|FALSE
decl_stmt|;
name|int32_t
name|vendor_debug
init|=
literal|0
decl_stmt|;
name|uint32_t
name|next_option
decl_stmt|;
name|char
modifier|*
name|conf_template
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|unsigned
name|config_file_done
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|short_option
init|=
literal|"F:c:i:f:ed:D:g:l:L:s:t:a:u:m:X:R:zM:U:S:P:Y:ANBIQvVhoryxp:n:q:k:C:"
decl_stmt|;
comment|/* 	   In the array below, the 2nd parameter specifies the number 	   of arguments as follows: 	   0: no arguments 	   1: argument 	   2: optional 	 */
specifier|const
name|struct
name|option
name|long_option
index|[]
init|=
block|{
block|{
literal|"version"
block|,
literal|0
block|,
name|NULL
block|,
literal|12
block|}
block|,
block|{
literal|"config"
block|,
literal|1
block|,
name|NULL
block|,
literal|'F'
block|}
block|,
block|{
literal|"create-config"
block|,
literal|1
block|,
name|NULL
block|,
literal|'c'
block|}
block|,
block|{
literal|"debug"
block|,
literal|1
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
block|{
literal|"guid"
block|,
literal|1
block|,
name|NULL
block|,
literal|'g'
block|}
block|,
block|{
literal|"ignore_guids"
block|,
literal|1
block|,
name|NULL
block|,
literal|'i'
block|}
block|,
block|{
literal|"lmc"
block|,
literal|1
block|,
name|NULL
block|,
literal|'l'
block|}
block|,
block|{
literal|"sweep"
block|,
literal|1
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"timeout"
block|,
literal|1
block|,
name|NULL
block|,
literal|'t'
block|}
block|,
block|{
literal|"verbose"
block|,
literal|0
block|,
name|NULL
block|,
literal|'v'
block|}
block|,
block|{
literal|"D"
block|,
literal|1
block|,
name|NULL
block|,
literal|'D'
block|}
block|,
block|{
literal|"log_file"
block|,
literal|1
block|,
name|NULL
block|,
literal|'f'
block|}
block|,
block|{
literal|"log_limit"
block|,
literal|1
block|,
name|NULL
block|,
literal|'L'
block|}
block|,
block|{
literal|"erase_log_file"
block|,
literal|0
block|,
name|NULL
block|,
literal|'e'
block|}
block|,
block|{
literal|"Pconfig"
block|,
literal|1
block|,
name|NULL
block|,
literal|'P'
block|}
block|,
block|{
literal|"no_part_enforce"
block|,
literal|0
block|,
name|NULL
block|,
literal|'N'
block|}
block|,
block|{
literal|"qos"
block|,
literal|0
block|,
name|NULL
block|,
literal|'Q'
block|}
block|,
block|{
literal|"qos_policy_file"
block|,
literal|1
block|,
name|NULL
block|,
literal|'Y'
block|}
block|,
block|{
literal|"maxsmps"
block|,
literal|1
block|,
name|NULL
block|,
literal|'n'
block|}
block|,
block|{
literal|"console"
block|,
literal|1
block|,
name|NULL
block|,
literal|'q'
block|}
block|,
block|{
literal|"V"
block|,
literal|0
block|,
name|NULL
block|,
literal|'V'
block|}
block|,
block|{
literal|"help"
block|,
literal|0
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"once"
block|,
literal|0
block|,
name|NULL
block|,
literal|'o'
block|}
block|,
block|{
literal|"reassign_lids"
block|,
literal|0
block|,
name|NULL
block|,
literal|'r'
block|}
block|,
block|{
literal|"priority"
block|,
literal|1
block|,
name|NULL
block|,
literal|'p'
block|}
block|,
block|{
literal|"smkey"
block|,
literal|1
block|,
name|NULL
block|,
literal|'k'
block|}
block|,
block|{
literal|"routing_engine"
block|,
literal|1
block|,
name|NULL
block|,
literal|'R'
block|}
block|,
block|{
literal|"ucast_cache"
block|,
literal|0
block|,
name|NULL
block|,
literal|'A'
block|}
block|,
block|{
literal|"connect_roots"
block|,
literal|0
block|,
name|NULL
block|,
literal|'z'
block|}
block|,
block|{
literal|"lid_matrix_file"
block|,
literal|1
block|,
name|NULL
block|,
literal|'M'
block|}
block|,
block|{
literal|"lfts_file"
block|,
literal|1
block|,
name|NULL
block|,
literal|'U'
block|}
block|,
block|{
literal|"sadb_file"
block|,
literal|1
block|,
name|NULL
block|,
literal|'S'
block|}
block|,
block|{
literal|"root_guid_file"
block|,
literal|1
block|,
name|NULL
block|,
literal|'a'
block|}
block|,
block|{
literal|"cn_guid_file"
block|,
literal|1
block|,
name|NULL
block|,
literal|'u'
block|}
block|,
block|{
literal|"ids_guid_file"
block|,
literal|1
block|,
name|NULL
block|,
literal|'m'
block|}
block|,
block|{
literal|"guid_routing_order_file"
block|,
literal|1
block|,
name|NULL
block|,
literal|'X'
block|}
block|,
block|{
literal|"stay_on_fatal"
block|,
literal|0
block|,
name|NULL
block|,
literal|'y'
block|}
block|,
block|{
literal|"honor_guid2lid"
block|,
literal|0
block|,
name|NULL
block|,
literal|'x'
block|}
block|,
ifdef|#
directive|ifdef
name|ENABLE_OSM_CONSOLE_SOCKET
block|{
literal|"console-port"
block|,
literal|1
block|,
name|NULL
block|,
literal|'C'
block|}
block|,
endif|#
directive|endif
block|{
literal|"daemon"
block|,
literal|0
block|,
name|NULL
block|,
literal|'B'
block|}
block|,
block|{
literal|"inactive"
block|,
literal|0
block|,
name|NULL
block|,
literal|'I'
block|}
block|,
ifdef|#
directive|ifdef
name|ENABLE_OSM_PERF_MGR
block|{
literal|"perfmgr"
block|,
literal|0
block|,
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"perfmgr_sweep_time_s"
block|,
literal|1
block|,
name|NULL
block|,
literal|2
block|}
block|,
endif|#
directive|endif
block|{
literal|"prefix_routes_file"
block|,
literal|1
block|,
name|NULL
block|,
literal|3
block|}
block|,
block|{
literal|"consolidate_ipv6_snm_req"
block|,
literal|0
block|,
name|NULL
block|,
literal|4
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
comment|/* Required at the end of the array */
block|}
decl_stmt|;
comment|/* Make sure that the opensm and complib were compiled using 	   same modes (debug/free) */
if|if
condition|(
name|osm_is_debug
argument_list|()
operator|!=
name|cl_is_debug
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: OpenSM and Complib were compiled using different modes\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: OpenSM debug:%d Complib debug:%d \n"
argument_list|,
name|osm_is_debug
argument_list|()
argument_list|,
name|cl_is_debug
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|_DEBUG_
argument_list|)
operator|&&
name|defined
argument_list|(
name|OSM_VENDOR_INTF_OPENIB
argument_list|)
name|enable_stack_dump
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"-------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|OSM_VERSION
argument_list|)
expr_stmt|;
name|osm_subn_set_default_opt
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_subn_parse_conf_file
argument_list|(
name|OSM_DEFAULT_CONFIG_FILE
argument_list|,
operator|&
name|opt
argument_list|)
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"\nosm_subn_parse_conf_file failed!\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Command Line Arguments:\n"
argument_list|)
expr_stmt|;
do|do
block|{
name|next_option
operator|=
name|getopt_long_only
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|short_option
argument_list|,
name|long_option
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|next_option
condition|)
block|{
case|case
literal|12
case|:
comment|/* --version - already printed above */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
if|if
condition|(
name|config_file_done
condition|)
break|break;
name|printf
argument_list|(
literal|"Reloading config from `%s`:\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_subn_parse_conf_file
argument_list|(
name|optarg
argument_list|,
operator|&
name|opt
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"cannot parse config file.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Rescaning command line:\n"
argument_list|)
expr_stmt|;
name|config_file_done
operator|=
literal|1
expr_stmt|;
name|optind
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|conf_template
operator|=
name|optarg
expr_stmt|;
name|printf
argument_list|(
literal|" Creating config file template \'%s\'.\n"
argument_list|,
name|conf_template
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* 			   Run once option. 			 */
name|run_once_flag
operator|=
name|TRUE
expr_stmt|;
name|printf
argument_list|(
literal|" Run Once\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* 			   Reassign LIDs subnet option. 			 */
name|opt
operator|.
name|reassign_lids
operator|=
name|TRUE
expr_stmt|;
name|printf
argument_list|(
literal|" Reassign LIDs\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* 			   Specifies ignore guids file. 			 */
name|opt
operator|.
name|port_prof_ignore_file
operator|=
name|optarg
expr_stmt|;
name|printf
argument_list|(
literal|" Ignore Guids File = %s\n"
argument_list|,
name|opt
operator|.
name|port_prof_ignore_file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* 			   Specifies port guid with which to bind. 			 */
name|opt
operator|.
name|guid
operator|=
name|cl_hton64
argument_list|(
name|strtoull
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opt
operator|.
name|guid
condition|)
comment|/* If guid is 0 - need to display the 				 * guid list */
name|opt
operator|.
name|guid
operator|=
name|INVALID_GUID
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" Guid<0x%"
name|PRIx64
literal|">\n"
argument_list|,
name|cl_hton64
argument_list|(
name|opt
operator|.
name|guid
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|val
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check that the number is not too large */
if|if
condition|(
operator|(
call|(
name|uint32_t
call|)
argument_list|(
name|val
operator|*
literal|1000000
argument_list|)
operator|)
operator|/
literal|1000000
operator|!=
name|val
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: sweep interval given is too large. Ignoring it.\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|opt
operator|.
name|sweep_interval
operator|=
name|val
expr_stmt|;
name|printf
argument_list|(
literal|" sweep interval = %d\n"
argument_list|,
name|opt
operator|.
name|sweep_interval
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
name|opt
operator|.
name|transaction_timeout
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Transaction timeout = %d\n"
argument_list|,
name|opt
operator|.
name|transaction_timeout
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|opt
operator|.
name|max_wire_smps
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|.
name|max_wire_smps
operator|<=
literal|0
condition|)
name|opt
operator|.
name|max_wire_smps
operator|=
literal|0x7FFFFFFF
expr_stmt|;
name|printf
argument_list|(
literal|" Max wire smp's = %d\n"
argument_list|,
name|opt
operator|.
name|max_wire_smps
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* 			 * OpenSM interactive console 			 */
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
name|OSM_DISABLE_CONSOLE
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|optarg
argument_list|,
name|OSM_LOCAL_CONSOLE
argument_list|)
operator|==
literal|0
ifdef|#
directive|ifdef
name|ENABLE_OSM_CONSOLE_SOCKET
operator|||
name|strcmp
argument_list|(
name|optarg
argument_list|,
name|OSM_REMOTE_CONSOLE
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|optarg
argument_list|,
name|OSM_LOOPBACK_CONSOLE
argument_list|)
operator|==
literal|0
endif|#
directive|endif
condition|)
name|opt
operator|.
name|console
operator|=
name|optarg
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"-console %s option not understood\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|ENABLE_OSM_CONSOLE_SOCKET
case|case
literal|'C'
case|:
name|opt
operator|.
name|console_port
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'d'
case|:
name|dbg_lvl
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" d level = 0x%x\n"
argument_list|,
name|dbg_lvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbg_lvl
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" Debug mode: Ignore Other SMs\n"
argument_list|)
expr_stmt|;
name|opt
operator|.
name|ignore_other_sm
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dbg_lvl
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|" Debug mode: Forcing Single Thread\n"
argument_list|)
expr_stmt|;
name|opt
operator|.
name|single_thread
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dbg_lvl
operator|==
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|" Debug mode: Force Log Flush\n"
argument_list|)
expr_stmt|;
name|opt
operator|.
name|force_log_flush
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dbg_lvl
operator|==
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|" Debug mode: Disable multicast support\n"
argument_list|)
expr_stmt|;
name|opt
operator|.
name|disable_multicast
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* 			 * NOTE: Debug level 4 used to be used for memory 			 * tracking but this is now deprecated 			 */
elseif|else
if|if
condition|(
name|dbg_lvl
operator|==
literal|5
condition|)
name|vendor_debug
operator|++
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" OpenSM: Unknown debug option %d"
literal|" ignored\n"
argument_list|,
name|dbg_lvl
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|temp
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>
literal|7
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: LMC must be 7 or less.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|opt
operator|.
name|lmc
operator|=
operator|(
name|uint8_t
operator|)
name|temp
expr_stmt|;
name|printf
argument_list|(
literal|" LMC = %d\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|opt
operator|.
name|log_flags
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" verbose option -D = 0x%x\n"
argument_list|,
name|opt
operator|.
name|log_flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|opt
operator|.
name|log_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|opt
operator|.
name|log_max_size
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|*
operator|(
literal|1024
operator|*
literal|1024
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|" Log file max size is %lu bytes\n"
argument_list|,
name|opt
operator|.
name|log_max_size
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|opt
operator|.
name|accum_log_file
operator|=
name|FALSE
expr_stmt|;
name|printf
argument_list|(
literal|" Creating new log file\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|opt
operator|.
name|partition_config_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|opt
operator|.
name|no_partition_enforcement
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|opt
operator|.
name|qos
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
name|opt
operator|.
name|qos_policy_file
operator|=
name|optarg
expr_stmt|;
name|printf
argument_list|(
literal|" QoS policy file \'%s\'\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|opt
operator|.
name|exit_on_fatal
operator|=
name|FALSE
expr_stmt|;
name|printf
argument_list|(
literal|" Staying on fatal initialization errors\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|opt
operator|.
name|log_flags
operator|=
operator|(
name|opt
operator|.
name|log_flags
operator|<<
literal|1
operator|)
operator||
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|" Verbose option -v (log flags = 0x%X)\n"
argument_list|,
name|opt
operator|.
name|log_flags
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|opt
operator|.
name|log_flags
operator|=
literal|0xFF
expr_stmt|;
name|opt
operator|.
name|force_log_flush
operator|=
name|TRUE
expr_stmt|;
name|printf
argument_list|(
literal|" Big V selected\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|temp
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|>
name|temp
operator|||
literal|15
operator|<
name|temp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: priority must be between 0 and 15\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|opt
operator|.
name|sm_priority
operator|=
operator|(
name|uint8_t
operator|)
name|temp
expr_stmt|;
name|printf
argument_list|(
literal|" Priority = %d\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|sm_key
operator|=
name|cl_hton64
argument_list|(
name|strtoull
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" SM Key<0x%"
name|PRIx64
literal|">\n"
argument_list|,
name|cl_hton64
argument_list|(
name|sm_key
argument_list|)
argument_list|)
expr_stmt|;
name|opt
operator|.
name|sm_key
operator|=
name|sm_key
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|opt
operator|.
name|routing_engine_names
operator|=
name|optarg
expr_stmt|;
name|printf
argument_list|(
literal|" Activate \'%s\' routing engine(s)\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|opt
operator|.
name|connect_roots
operator|=
name|TRUE
expr_stmt|;
name|printf
argument_list|(
literal|" Connect roots option is on\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|opt
operator|.
name|use_ucast_cache
operator|=
name|TRUE
expr_stmt|;
name|printf
argument_list|(
literal|" Unicast routing cache option is on\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|opt
operator|.
name|lid_matrix_dump_file
operator|=
name|optarg
expr_stmt|;
name|printf
argument_list|(
literal|" Lid matrix dump file is \'%s\'\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|opt
operator|.
name|lfts_file
operator|=
name|optarg
expr_stmt|;
name|printf
argument_list|(
literal|" LFTs file is \'%s\'\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|opt
operator|.
name|sa_db_file
operator|=
name|optarg
expr_stmt|;
name|printf
argument_list|(
literal|" SA DB file is \'%s\'\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* 			   Specifies root guids file 			 */
name|opt
operator|.
name|root_guid_file
operator|=
name|optarg
expr_stmt|;
name|printf
argument_list|(
literal|" Root Guid File: %s\n"
argument_list|,
name|opt
operator|.
name|root_guid_file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* 			   Specifies compute node guids file 			 */
name|opt
operator|.
name|cn_guid_file
operator|=
name|optarg
expr_stmt|;
name|printf
argument_list|(
literal|" Compute Node Guid File: %s\n"
argument_list|,
name|opt
operator|.
name|cn_guid_file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Specifies ids guid file */
name|opt
operator|.
name|ids_guid_file
operator|=
name|optarg
expr_stmt|;
name|printf
argument_list|(
literal|" IDs Guid File: %s\n"
argument_list|,
name|opt
operator|.
name|ids_guid_file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* Specifies guid routing order file */
name|opt
operator|.
name|guid_routing_order_file
operator|=
name|optarg
expr_stmt|;
name|printf
argument_list|(
literal|" GUID Routing Order File: %s\n"
argument_list|,
name|opt
operator|.
name|guid_routing_order_file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|opt
operator|.
name|honor_guid2lid_file
operator|=
name|TRUE
expr_stmt|;
name|printf
argument_list|(
literal|" Honor guid2lid file, if possible\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|opt
operator|.
name|daemon
operator|=
name|TRUE
expr_stmt|;
name|printf
argument_list|(
literal|" Daemon mode\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|opt
operator|.
name|sm_inactive
operator|=
name|TRUE
expr_stmt|;
name|printf
argument_list|(
literal|" SM started in inactive state\n"
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|ENABLE_OSM_PERF_MGR
case|case
literal|1
case|:
name|opt
operator|.
name|perfmgr
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|opt
operator|.
name|perfmgr_sweep_time_s
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* ENABLE_OSM_PERF_MGR */
case|case
literal|3
case|:
name|opt
operator|.
name|prefix_routes_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|opt
operator|.
name|consolidate_ipv6_snm_req
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
case|case
literal|'?'
case|:
case|case
literal|':'
case|:
name|show_usage
argument_list|()
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
break|break;
comment|/* done with option */
default|default:
comment|/* something wrong */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
name|next_option
operator|!=
operator|-
literal|1
condition|)
do|;
if|if
condition|(
name|opt
operator|.
name|log_file
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|" Log File: %s\n"
argument_list|,
name|opt
operator|.
name|log_file
argument_list|)
expr_stmt|;
comment|/* Done with options description */
name|printf
argument_list|(
literal|"-------------------------------------------------\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf_template
condition|)
block|{
name|status
operator|=
name|osm_subn_write_conf_file
argument_list|(
name|conf_template
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|printf
argument_list|(
literal|"\nosm_subn_write_conf_file failed!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
name|osm_subn_verify_config
argument_list|(
operator|&
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|vendor_debug
condition|)
name|osm_vendor_set_debug
argument_list|(
name|osm
operator|.
name|p_vendor
argument_list|,
name|vendor_debug
argument_list|)
expr_stmt|;
name|block_signals
argument_list|()
expr_stmt|;
if|if
condition|(
name|opt
operator|.
name|daemon
condition|)
name|daemonize
argument_list|(
operator|&
name|osm
argument_list|)
expr_stmt|;
name|complib_init
argument_list|()
expr_stmt|;
name|status
operator|=
name|osm_opensm_init
argument_list|(
operator|&
name|osm
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
specifier|const
name|char
modifier|*
name|err_str
init|=
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
decl_stmt|;
if|if
condition|(
name|err_str
operator|==
name|NULL
condition|)
name|err_str
operator|=
literal|"Unknown Error Type"
expr_stmt|;
name|printf
argument_list|(
literal|"\nError from osm_opensm_init: %s.\n"
argument_list|,
name|err_str
argument_list|)
expr_stmt|;
comment|/* We will just exit, and not go to Exit, since we don't 		   want the destroy to be called. */
name|complib_exit
argument_list|()
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
comment|/* 	   If the user didn't specify a GUID on the command line, 	   then get a port GUID value with which to bind. 	 */
if|if
condition|(
name|opt
operator|.
name|guid
operator|==
literal|0
operator|||
name|cl_hton64
argument_list|(
name|opt
operator|.
name|guid
argument_list|)
operator|==
name|CL_HTON64
argument_list|(
name|INVALID_GUID
argument_list|)
condition|)
name|opt
operator|.
name|guid
operator|=
name|get_port_guid
argument_list|(
operator|&
name|osm
argument_list|,
name|opt
operator|.
name|guid
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_opensm_bind
argument_list|(
operator|&
name|osm
argument_list|,
name|opt
operator|.
name|guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|"\nError from osm_opensm_bind (0x%X)\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Perhaps another instance of OpenSM is already running\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|setup_signals
argument_list|()
expr_stmt|;
name|osm_opensm_sweep
argument_list|(
operator|&
name|osm
argument_list|)
expr_stmt|;
if|if
condition|(
name|run_once_flag
operator|==
name|TRUE
condition|)
block|{
while|while
condition|(
operator|!
name|osm_exit_flag
condition|)
block|{
name|status
operator|=
name|osm_opensm_wait_for_subnet_up
argument_list|(
operator|&
name|osm
argument_list|,
name|osm
operator|.
name|subn
operator|.
name|opt
operator|.
name|sweep_interval
operator|*
literal|1000000
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
name|osm_exit_flag
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 *         Sit here until signaled to exit 		 */
name|osm_manager_loop
argument_list|(
operator|&
name|opt
argument_list|,
operator|&
name|osm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|osm
operator|.
name|mad_pool
operator|.
name|mads_out
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"There are still %u MADs out. Forcing the exit of the OpenSM application...\n"
argument_list|,
name|osm
operator|.
name|mad_pool
operator|.
name|mads_out
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_LIBPTHREAD
name|pthread_cond_signal
argument_list|(
operator|&
name|osm
operator|.
name|stats
operator|.
name|cond
argument_list|)
expr_stmt|;
else|#
directive|else
name|cl_event_signal
argument_list|(
operator|&
name|osm
operator|.
name|stats
operator|.
name|event
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|Exit
label|:
name|osm_opensm_destroy
argument_list|(
operator|&
name|osm
argument_list|)
expr_stmt|;
name|complib_exit
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

