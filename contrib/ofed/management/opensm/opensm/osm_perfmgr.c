begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2007 The Regents of the University of California.  * Copyright (c) 2007-2008 Voltaire, Inc. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_perfmgr_t.  * This object implements an IBA performance manager.  *  * Author:  *    Ira Weiny, LLNL  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_OSM_PERF_MGR
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<poll.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<float.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_thread.h>
end_include

begin_include
include|#
directive|include
file|<vendor/osm_vendor_api.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_perfmgr.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_node.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_define
define|#
directive|define
name|OSM_PERFMGR_INITIAL_TID_VALUE
value|0xcafe
end_define

begin_if
if|#
directive|if
name|ENABLE_OSM_PERF_MGR_PROFILE
end_if

begin_struct
struct|struct
block|{
name|double
name|fastest_us
decl_stmt|;
name|double
name|slowest_us
decl_stmt|;
name|double
name|avg_us
decl_stmt|;
name|uint64_t
name|num
decl_stmt|;
block|}
name|perfmgr_mad_stats
init|=
block|{
name|fastest_us
operator|:
name|DBL_MAX
block|,
name|slowest_us
operator|:
name|DBL_MIN
block|,
name|avg_us
operator|:
literal|0
block|,
name|num
operator|:
literal|0
block|}
struct|;
end_struct

begin_comment
comment|/* diff must be something which can fit in a susecond_t */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|update_mad_stats
parameter_list|(
name|struct
name|timeval
modifier|*
name|diff
parameter_list|)
block|{
name|double
name|new
init|=
operator|(
name|diff
operator|->
name|tv_sec
operator|*
literal|1000000
operator|)
operator|+
name|diff
operator|->
name|tv_usec
decl_stmt|;
if|if
condition|(
name|new
operator|<
name|perfmgr_mad_stats
operator|.
name|fastest_us
condition|)
name|perfmgr_mad_stats
operator|.
name|fastest_us
operator|=
name|new
expr_stmt|;
if|if
condition|(
name|new
operator|>
name|perfmgr_mad_stats
operator|.
name|slowest_us
condition|)
name|perfmgr_mad_stats
operator|.
name|slowest_us
operator|=
name|new
expr_stmt|;
name|perfmgr_mad_stats
operator|.
name|avg_us
operator|=
operator|(
operator|(
name|perfmgr_mad_stats
operator|.
name|avg_us
operator|*
name|perfmgr_mad_stats
operator|.
name|num
operator|)
operator|+
name|new
operator|)
operator|/
operator|(
name|perfmgr_mad_stats
operator|.
name|num
operator|+
literal|1
operator|)
expr_stmt|;
name|perfmgr_mad_stats
operator|.
name|num
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|perfmgr_clear_mad_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|perfmgr_mad_stats
operator|.
name|fastest_us
operator|=
name|DBL_MAX
expr_stmt|;
name|perfmgr_mad_stats
operator|.
name|slowest_us
operator|=
name|DBL_MIN
expr_stmt|;
name|perfmgr_mad_stats
operator|.
name|avg_us
operator|=
literal|0
expr_stmt|;
name|perfmgr_mad_stats
operator|.
name|num
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* after and diff can be the same struct */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|diff_time
parameter_list|(
name|struct
name|timeval
modifier|*
name|before
parameter_list|,
name|struct
name|timeval
modifier|*
name|after
parameter_list|,
name|struct
name|timeval
modifier|*
name|diff
parameter_list|)
block|{
name|struct
name|timeval
name|tmp
init|=
operator|*
name|after
decl_stmt|;
if|if
condition|(
name|tmp
operator|.
name|tv_usec
operator|<
name|before
operator|->
name|tv_usec
condition|)
block|{
name|tmp
operator|.
name|tv_sec
operator|--
expr_stmt|;
name|tmp
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
name|diff
operator|->
name|tv_sec
operator|=
name|tmp
operator|.
name|tv_sec
operator|-
name|before
operator|->
name|tv_sec
expr_stmt|;
name|diff
operator|->
name|tv_usec
operator|=
name|tmp
operator|.
name|tv_usec
operator|-
name|before
operator|->
name|tv_usec
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|int
name|wait_for_pending_transactions
parameter_list|(
name|osm_stats_t
modifier|*
name|stats
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**********************************************************************  * Internal helper functions.  **********************************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|__init_monitored_nodes
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|)
block|{
name|cl_qmap_init
argument_list|(
operator|&
name|pm
operator|->
name|monitored_map
argument_list|)
expr_stmt|;
name|pm
operator|->
name|remove_list
operator|=
name|NULL
expr_stmt|;
name|cl_event_construct
argument_list|(
operator|&
name|pm
operator|->
name|sig_query
argument_list|)
expr_stmt|;
name|cl_event_init
argument_list|(
operator|&
name|pm
operator|->
name|sig_query
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|__mark_for_removal
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|,
name|__monitored_node_t
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|pm
operator|->
name|remove_list
condition|)
block|{
name|node
operator|->
name|next
operator|=
name|pm
operator|->
name|remove_list
expr_stmt|;
name|pm
operator|->
name|remove_list
operator|=
name|node
expr_stmt|;
block|}
else|else
block|{
name|node
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|pm
operator|->
name|remove_list
operator|=
name|node
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|__remove_marked_nodes
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|)
block|{
while|while
condition|(
name|pm
operator|->
name|remove_list
condition|)
block|{
name|__monitored_node_t
modifier|*
name|next
init|=
name|pm
operator|->
name|remove_list
operator|->
name|next
decl_stmt|;
name|cl_qmap_remove_item
argument_list|(
operator|&
operator|(
name|pm
operator|->
name|monitored_map
operator|)
argument_list|,
operator|(
name|cl_map_item_t
operator|*
operator|)
operator|(
name|pm
operator|->
name|remove_list
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|remove_list
operator|->
name|name
condition|)
name|free
argument_list|(
name|pm
operator|->
name|remove_list
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pm
operator|->
name|remove_list
argument_list|)
expr_stmt|;
name|pm
operator|->
name|remove_list
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|__decrement_outstanding_queries
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|)
block|{
name|cl_atomic_dec
argument_list|(
operator|&
operator|(
name|pm
operator|->
name|outstanding_queries
operator|)
argument_list|)
expr_stmt|;
name|cl_event_signal
argument_list|(
operator|&
operator|(
name|pm
operator|->
name|sig_query
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Receive the MAD from the vendor layer and post it for processing by  * the dispatcher.  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|osm_perfmgr_mad_recv_callback
parameter_list|(
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|,
name|void
modifier|*
name|bind_context
parameter_list|,
name|osm_madw_t
modifier|*
name|p_req_madw
parameter_list|)
block|{
name|osm_perfmgr_t
modifier|*
name|pm
init|=
operator|(
name|osm_perfmgr_t
operator|*
operator|)
name|bind_context
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
name|osm_madw_copy_context
argument_list|(
name|p_madw
argument_list|,
name|p_req_madw
argument_list|)
expr_stmt|;
name|osm_mad_pool_put
argument_list|(
name|pm
operator|->
name|mad_pool
argument_list|,
name|p_req_madw
argument_list|)
expr_stmt|;
name|__decrement_outstanding_queries
argument_list|(
name|pm
argument_list|)
expr_stmt|;
comment|/* post this message for later processing. */
if|if
condition|(
name|cl_disp_post
argument_list|(
name|pm
operator|->
name|pc_disp_h
argument_list|,
name|OSM_MSG_MAD_PORT_COUNTERS
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p_madw
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|!=
name|CL_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4C01: "
literal|"PerfMgr Dispatcher post failed\n"
argument_list|)
expr_stmt|;
name|osm_mad_pool_put
argument_list|(
name|pm
operator|->
name|mad_pool
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Process MAD send errors.  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|osm_perfmgr_mad_send_err_callback
parameter_list|(
name|void
modifier|*
name|bind_context
parameter_list|,
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|)
block|{
name|osm_perfmgr_t
modifier|*
name|pm
init|=
operator|(
name|osm_perfmgr_t
operator|*
operator|)
name|bind_context
decl_stmt|;
name|osm_madw_context_t
modifier|*
name|context
init|=
operator|&
operator|(
name|p_madw
operator|->
name|context
operator|)
decl_stmt|;
name|uint64_t
name|node_guid
init|=
name|context
operator|->
name|perfmgr_context
operator|.
name|node_guid
decl_stmt|;
name|uint8_t
name|port
init|=
name|context
operator|->
name|perfmgr_context
operator|.
name|port
decl_stmt|;
name|cl_map_item_t
modifier|*
name|p_node
decl_stmt|;
name|__monitored_node_t
modifier|*
name|p_mon_node
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
comment|/* go ahead and get the monitored node struct to have the printable 	 * name if needed in messages 	 */
if|if
condition|(
operator|(
name|p_node
operator|=
name|cl_qmap_get
argument_list|(
operator|&
operator|(
name|pm
operator|->
name|monitored_map
operator|)
argument_list|,
name|node_guid
argument_list|)
operator|)
operator|==
name|cl_qmap_end
argument_list|(
operator|&
operator|(
name|pm
operator|->
name|monitored_map
operator|)
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4C15: GUID 0x%016"
name|PRIx64
literal|" not found in monitored map\n"
argument_list|,
name|node_guid
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_mon_node
operator|=
operator|(
name|__monitored_node_t
operator|*
operator|)
name|p_node
expr_stmt|;
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4C02: %s (0x%"
name|PRIx64
literal|") port %u\n"
argument_list|,
name|p_mon_node
operator|->
name|name
argument_list|,
name|p_mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|subn
operator|->
name|opt
operator|.
name|perfmgr_redir
operator|&&
name|p_madw
operator|->
name|status
operator|==
name|IB_TIMEOUT
condition|)
block|{
comment|/* First, find the node in the monitored map */
name|cl_plock_acquire
argument_list|(
name|pm
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* Now, validate port number */
if|if
condition|(
name|port
operator|>
name|p_mon_node
operator|->
name|redir_tbl_size
condition|)
block|{
name|cl_plock_release
argument_list|(
name|pm
operator|->
name|lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4C16: "
literal|"Invalid port num %u for %s (GUID 0x%016"
name|PRIx64
literal|") num ports %u\n"
argument_list|,
name|port
argument_list|,
name|p_mon_node
operator|->
name|name
argument_list|,
name|p_mon_node
operator|->
name|guid
argument_list|,
name|p_mon_node
operator|->
name|redir_tbl_size
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Clear redirection info */
name|p_mon_node
operator|->
name|redir_port
index|[
name|port
index|]
operator|.
name|redir_lid
operator|=
literal|0
expr_stmt|;
name|p_mon_node
operator|->
name|redir_port
index|[
name|port
index|]
operator|.
name|redir_qp
operator|=
literal|0
expr_stmt|;
name|cl_plock_release
argument_list|(
name|pm
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|osm_mad_pool_put
argument_list|(
name|pm
operator|->
name|mad_pool
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
name|__decrement_outstanding_queries
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Bind the PerfMgr to the vendor layer for MAD sends/receives  **********************************************************************/
end_comment

begin_function
name|ib_api_status_t
name|osm_perfmgr_bind
parameter_list|(
name|osm_perfmgr_t
modifier|*
specifier|const
name|pm
parameter_list|,
specifier|const
name|ib_net64_t
name|port_guid
parameter_list|)
block|{
name|osm_bind_info_t
name|bind_info
decl_stmt|;
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|bind_handle
operator|!=
name|OSM_BIND_INVALID_HANDLE
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4C03: Multiple binds not allowed\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|bind_info
operator|.
name|port_guid
operator|=
name|port_guid
expr_stmt|;
name|bind_info
operator|.
name|mad_class
operator|=
name|IB_MCLASS_PERF
expr_stmt|;
name|bind_info
operator|.
name|class_version
operator|=
literal|1
expr_stmt|;
name|bind_info
operator|.
name|is_responder
operator|=
name|FALSE
expr_stmt|;
name|bind_info
operator|.
name|is_report_processor
operator|=
name|FALSE
expr_stmt|;
name|bind_info
operator|.
name|is_trap_processor
operator|=
name|FALSE
expr_stmt|;
name|bind_info
operator|.
name|recv_q_size
operator|=
name|OSM_PM_DEFAULT_QP1_RCV_SIZE
expr_stmt|;
name|bind_info
operator|.
name|send_q_size
operator|=
name|OSM_PM_DEFAULT_QP1_SEND_SIZE
expr_stmt|;
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Binding to port GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
name|pm
operator|->
name|bind_handle
operator|=
name|osm_vendor_bind
argument_list|(
name|pm
operator|->
name|vendor
argument_list|,
operator|&
name|bind_info
argument_list|,
name|pm
operator|->
name|mad_pool
argument_list|,
name|osm_perfmgr_mad_recv_callback
argument_list|,
name|osm_perfmgr_mad_send_err_callback
argument_list|,
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|bind_handle
operator|==
name|OSM_BIND_INVALID_HANDLE
condition|)
block|{
name|status
operator|=
name|IB_ERROR
expr_stmt|;
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4C04: Vendor specific bind failed (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Unbind the PerfMgr from the vendor layer for MAD sends/receives  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|osm_perfmgr_mad_unbind
parameter_list|(
name|osm_perfmgr_t
modifier|*
specifier|const
name|pm
parameter_list|)
block|{
name|OSM_LOG_ENTER
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|bind_handle
operator|==
name|OSM_BIND_INVALID_HANDLE
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4C05: No previous bind\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|osm_vendor_unbind
argument_list|(
name|pm
operator|->
name|bind_handle
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Given a monitored node and a port, return the qp  **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_net32_t
name|get_qp
parameter_list|(
name|__monitored_node_t
modifier|*
name|mon_node
parameter_list|,
name|uint8_t
name|port
parameter_list|)
block|{
name|ib_net32_t
name|qp
init|=
name|cl_ntoh32
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|mon_node
operator|&&
name|mon_node
operator|->
name|redir_tbl_size
operator|&&
name|port
operator|<
name|mon_node
operator|->
name|redir_tbl_size
operator|&&
name|mon_node
operator|->
name|redir_port
index|[
name|port
index|]
operator|.
name|redir_lid
operator|&&
name|mon_node
operator|->
name|redir_port
index|[
name|port
index|]
operator|.
name|redir_qp
condition|)
name|qp
operator|=
name|mon_node
operator|->
name|redir_port
index|[
name|port
index|]
operator|.
name|redir_qp
expr_stmt|;
return|return
name|qp
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Given a node, a port, and an optional monitored node,  * return the appropriate lid to query that port  **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_net16_t
name|get_lid
parameter_list|(
name|osm_node_t
modifier|*
name|p_node
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|__monitored_node_t
modifier|*
name|mon_node
parameter_list|)
block|{
if|if
condition|(
name|mon_node
operator|&&
name|mon_node
operator|->
name|redir_tbl_size
operator|&&
name|port
operator|<
name|mon_node
operator|->
name|redir_tbl_size
operator|&&
name|mon_node
operator|->
name|redir_port
index|[
name|port
index|]
operator|.
name|redir_lid
condition|)
return|return
name|mon_node
operator|->
name|redir_port
index|[
name|port
index|]
operator|.
name|redir_lid
return|;
switch|switch
condition|(
name|p_node
operator|->
name|node_info
operator|.
name|node_type
condition|)
block|{
case|case
name|IB_NODE_TYPE_CA
case|:
case|case
name|IB_NODE_TYPE_ROUTER
case|:
return|return
name|osm_node_get_base_lid
argument_list|(
name|p_node
argument_list|,
name|port
argument_list|)
return|;
case|case
name|IB_NODE_TYPE_SWITCH
case|:
return|return
name|osm_node_get_base_lid
argument_list|(
name|p_node
argument_list|,
literal|0
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/**********************************************************************  * Form and send the Port Counters MAD for a single port.  **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|osm_perfmgr_send_pc_mad
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|perfmgr
parameter_list|,
name|ib_net16_t
name|dest_lid
parameter_list|,
name|ib_net32_t
name|dest_qp
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|uint8_t
name|mad_method
parameter_list|,
name|osm_madw_context_t
modifier|*
specifier|const
name|p_context
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|ib_port_counters_t
modifier|*
name|port_counter
init|=
name|NULL
decl_stmt|;
name|ib_perfmgt_mad_t
modifier|*
name|pm_mad
init|=
name|NULL
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_madw
init|=
name|NULL
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|perfmgr
operator|->
name|log
argument_list|)
expr_stmt|;
name|p_madw
operator|=
name|osm_mad_pool_get
argument_list|(
name|perfmgr
operator|->
name|mad_pool
argument_list|,
name|perfmgr
operator|->
name|bind_handle
argument_list|,
name|MAD_BLOCK_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_madw
operator|==
name|NULL
condition|)
return|return
operator|(
name|IB_INSUFFICIENT_MEMORY
operator|)
return|;
name|pm_mad
operator|=
name|osm_madw_get_perfmgt_mad_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
comment|/* build the mad */
name|pm_mad
operator|->
name|header
operator|.
name|base_ver
operator|=
literal|1
expr_stmt|;
name|pm_mad
operator|->
name|header
operator|.
name|mgmt_class
operator|=
name|IB_MCLASS_PERF
expr_stmt|;
name|pm_mad
operator|->
name|header
operator|.
name|class_ver
operator|=
literal|1
expr_stmt|;
name|pm_mad
operator|->
name|header
operator|.
name|method
operator|=
name|mad_method
expr_stmt|;
name|pm_mad
operator|->
name|header
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|pm_mad
operator|->
name|header
operator|.
name|class_spec
operator|=
literal|0
expr_stmt|;
name|pm_mad
operator|->
name|header
operator|.
name|trans_id
operator|=
name|cl_hton64
argument_list|(
operator|(
name|uint64_t
operator|)
name|cl_atomic_inc
argument_list|(
operator|&
operator|(
name|perfmgr
operator|->
name|trans_id
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|pm_mad
operator|->
name|header
operator|.
name|attr_id
operator|=
name|IB_MAD_ATTR_PORT_CNTRS
expr_stmt|;
name|pm_mad
operator|->
name|header
operator|.
name|resv
operator|=
literal|0
expr_stmt|;
name|pm_mad
operator|->
name|header
operator|.
name|attr_mod
operator|=
literal|0
expr_stmt|;
name|port_counter
operator|=
operator|(
name|ib_port_counters_t
operator|*
operator|)
operator|&
operator|(
name|pm_mad
operator|->
name|data
operator|)
expr_stmt|;
name|memset
argument_list|(
name|port_counter
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|port_counter
argument_list|)
argument_list|)
expr_stmt|;
name|port_counter
operator|->
name|port_select
operator|=
name|port
expr_stmt|;
name|port_counter
operator|->
name|counter_select
operator|=
literal|0xFFFF
expr_stmt|;
name|p_madw
operator|->
name|mad_addr
operator|.
name|dest_lid
operator|=
name|dest_lid
expr_stmt|;
name|p_madw
operator|->
name|mad_addr
operator|.
name|addr_type
operator|.
name|gsi
operator|.
name|remote_qp
operator|=
name|dest_qp
expr_stmt|;
name|p_madw
operator|->
name|mad_addr
operator|.
name|addr_type
operator|.
name|gsi
operator|.
name|remote_qkey
operator|=
name|cl_hton32
argument_list|(
name|IB_QP1_WELL_KNOWN_Q_KEY
argument_list|)
expr_stmt|;
comment|/* FIXME what about other partitions */
name|p_madw
operator|->
name|mad_addr
operator|.
name|addr_type
operator|.
name|gsi
operator|.
name|pkey_ix
operator|=
literal|0
expr_stmt|;
name|p_madw
operator|->
name|mad_addr
operator|.
name|addr_type
operator|.
name|gsi
operator|.
name|service_level
operator|=
literal|0
expr_stmt|;
name|p_madw
operator|->
name|mad_addr
operator|.
name|addr_type
operator|.
name|gsi
operator|.
name|global_route
operator|=
name|FALSE
expr_stmt|;
name|p_madw
operator|->
name|resp_expected
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|p_context
condition|)
name|p_madw
operator|->
name|context
operator|=
operator|*
name|p_context
expr_stmt|;
name|status
operator|=
name|osm_vendor_send
argument_list|(
name|perfmgr
operator|->
name|bind_handle
argument_list|,
name|p_madw
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IB_SUCCESS
condition|)
block|{
comment|/* pause this thread if we have too many outstanding requests */
name|cl_atomic_inc
argument_list|(
operator|&
operator|(
name|perfmgr
operator|->
name|outstanding_queries
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|perfmgr
operator|->
name|outstanding_queries
operator|>
name|perfmgr
operator|->
name|max_outstanding_queries
condition|)
block|{
name|perfmgr
operator|->
name|sweep_state
operator|=
name|PERFMGR_SWEEP_SUSPENDED
expr_stmt|;
name|cl_event_wait_on
argument_list|(
operator|&
name|perfmgr
operator|->
name|sig_query
argument_list|,
name|EVENT_NO_TIMEOUT
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|perfmgr
operator|->
name|sweep_state
operator|=
name|PERFMGR_SWEEP_ACTIVE
expr_stmt|;
block|}
block|}
name|OSM_LOG_EXIT
argument_list|(
name|perfmgr
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * sweep the node_guid_tbl and collect the node guids to be tracked  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__collect_guids
parameter_list|(
name|cl_map_item_t
modifier|*
specifier|const
name|p_map_item
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|osm_node_t
modifier|*
name|node
init|=
operator|(
name|osm_node_t
operator|*
operator|)
name|p_map_item
decl_stmt|;
name|uint64_t
name|node_guid
init|=
name|cl_ntoh64
argument_list|(
name|node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|)
decl_stmt|;
name|osm_perfmgr_t
modifier|*
name|pm
init|=
operator|(
name|osm_perfmgr_t
operator|*
operator|)
name|context
decl_stmt|;
name|__monitored_node_t
modifier|*
name|mon_node
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl_qmap_get
argument_list|(
operator|&
operator|(
name|pm
operator|->
name|monitored_map
operator|)
argument_list|,
name|node_guid
argument_list|)
operator|==
name|cl_qmap_end
argument_list|(
operator|&
operator|(
name|pm
operator|->
name|monitored_map
operator|)
argument_list|)
condition|)
block|{
comment|/* if not already in our map add it */
name|size
operator|=
name|node
operator|->
name|node_info
operator|.
name|num_ports
expr_stmt|;
name|mon_node
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mon_node
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|redir_t
argument_list|)
operator|*
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mon_node
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"PerfMgr: ERR 4C06: "
literal|"malloc failed: not handling node %s"
literal|"(GUID 0x%"
name|PRIx64
literal|")\n"
argument_list|,
name|node
operator|->
name|print_desc
argument_list|,
name|node_guid
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|memset
argument_list|(
name|mon_node
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mon_node
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|redir_t
argument_list|)
operator|*
name|size
argument_list|)
expr_stmt|;
name|mon_node
operator|->
name|guid
operator|=
name|node_guid
expr_stmt|;
name|mon_node
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
name|mon_node
operator|->
name|redir_tbl_size
operator|=
name|size
operator|+
literal|1
expr_stmt|;
name|cl_qmap_insert
argument_list|(
operator|&
operator|(
name|pm
operator|->
name|monitored_map
operator|)
argument_list|,
name|node_guid
argument_list|,
operator|(
name|cl_map_item_t
operator|*
operator|)
name|mon_node
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * query the Port Counters of all the nodes in the subnet.  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_perfmgr_query_counters
parameter_list|(
name|cl_map_item_t
modifier|*
specifier|const
name|p_map_item
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|uint8_t
name|port
init|=
literal|0
decl_stmt|,
name|startport
init|=
literal|1
decl_stmt|;
name|osm_perfmgr_t
modifier|*
name|pm
init|=
operator|(
name|osm_perfmgr_t
operator|*
operator|)
name|context
decl_stmt|;
name|osm_node_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|__monitored_node_t
modifier|*
name|mon_node
init|=
operator|(
name|__monitored_node_t
operator|*
operator|)
name|p_map_item
decl_stmt|;
name|osm_madw_context_t
name|mad_context
decl_stmt|;
name|uint8_t
name|num_ports
init|=
literal|0
decl_stmt|;
name|uint64_t
name|node_guid
init|=
literal|0
decl_stmt|;
name|ib_net32_t
name|remote_qp
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
name|cl_plock_acquire
argument_list|(
name|pm
operator|->
name|lock
argument_list|)
expr_stmt|;
name|node
operator|=
name|osm_get_node_by_guid
argument_list|(
name|pm
operator|->
name|subn
argument_list|,
name|cl_hton64
argument_list|(
name|mon_node
operator|->
name|guid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4C07: Node \"%s\" (guid 0x%"
name|PRIx64
literal|") no longer exists so removing from PerfMgr monitoring\n"
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|)
expr_stmt|;
name|__mark_for_removal
argument_list|(
name|pm
argument_list|,
name|mon_node
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|num_ports
operator|=
name|osm_node_get_num_physp
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node_guid
operator|=
name|cl_ntoh64
argument_list|(
name|node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|)
expr_stmt|;
comment|/* make sure we have a database object ready to store this information */
if|if
condition|(
name|perfmgr_db_create_entry
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|node_guid
argument_list|,
name|num_ports
argument_list|,
name|node
operator|->
name|print_desc
argument_list|)
operator|!=
name|PERFMGR_EVENT_DB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4C08: DB create entry failed for 0x%"
name|PRIx64
literal|" (%s) : %s\n"
argument_list|,
name|node_guid
argument_list|,
name|node
operator|->
name|print_desc
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* if switch, check for enhanced port 0 */
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|node
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
operator|&&
name|node
operator|->
name|sw
operator|&&
name|ib_switch_info_is_enhanced_port0
argument_list|(
operator|&
name|node
operator|->
name|sw
operator|->
name|switch_info
argument_list|)
condition|)
name|startport
operator|=
literal|0
expr_stmt|;
comment|/* issue the query for each port */
for|for
control|(
name|port
operator|=
name|startport
init|;
name|port
operator|<
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
name|ib_net16_t
name|lid
decl_stmt|;
if|if
condition|(
operator|!
name|osm_node_get_physp_ptr
argument_list|(
name|node
argument_list|,
name|port
argument_list|)
condition|)
continue|continue;
name|lid
operator|=
name|get_lid
argument_list|(
name|node
argument_list|,
name|port
argument_list|,
name|mon_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|lid
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"WARN: node 0x%"
name|PRIx64
literal|" port %d (%s): port out of range, skipping\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|)
argument_list|,
name|port
argument_list|,
name|node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|remote_qp
operator|=
name|get_qp
argument_list|(
name|mon_node
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|mad_context
operator|.
name|perfmgr_context
operator|.
name|node_guid
operator|=
name|node_guid
expr_stmt|;
name|mad_context
operator|.
name|perfmgr_context
operator|.
name|port
operator|=
name|port
expr_stmt|;
name|mad_context
operator|.
name|perfmgr_context
operator|.
name|mad_method
operator|=
name|IB_MAD_METHOD_GET
expr_stmt|;
if|#
directive|if
name|ENABLE_OSM_PERF_MGR_PROFILE
name|gettimeofday
argument_list|(
operator|&
operator|(
name|mad_context
operator|.
name|perfmgr_context
operator|.
name|query_start
operator|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Getting stats for node 0x%"
name|PRIx64
literal|" port %d (lid %u) (%s)\n"
argument_list|,
name|node_guid
argument_list|,
name|port
argument_list|,
name|cl_ntoh16
argument_list|(
name|lid
argument_list|)
argument_list|,
name|node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_perfmgr_send_pc_mad
argument_list|(
name|pm
argument_list|,
name|lid
argument_list|,
name|remote_qp
argument_list|,
name|port
argument_list|,
name|IB_MAD_METHOD_GET
argument_list|,
operator|&
name|mad_context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4C09: "
literal|"Failed to issue port counter query for node 0x%"
name|PRIx64
literal|" port %d (%s)\n"
argument_list|,
name|node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|,
name|port
argument_list|,
name|node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|cl_plock_release
argument_list|(
name|pm
operator|->
name|lock
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Discovery stuff.  * Basically this code should not be here, but merged with main OpenSM  **********************************************************************/
end_comment

begin_function_decl
specifier|extern
name|void
name|osm_drop_mgr_process
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|sweep_hop_1
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|osm_bind_handle_t
name|h_bind
decl_stmt|;
name|osm_madw_context_t
name|context
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|osm_dr_path_t
modifier|*
name|p_dr_path
decl_stmt|;
name|osm_dr_path_t
name|hop_1_path
decl_stmt|;
name|ib_net64_t
name|port_guid
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|uint8_t
name|path_array
index|[
name|IB_SUBNET_PATH_HOPS_MAX
index|]
decl_stmt|;
name|uint8_t
name|num_ports
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_ext_physp
decl_stmt|;
name|port_guid
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|sm_port_guid
expr_stmt|;
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4C81: No SM port object\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|p_node
operator|=
name|p_port
operator|->
name|p_node
expr_stmt|;
name|port_num
operator|=
name|ib_node_info_get_local_port_num
argument_list|(
operator|&
name|p_node
operator|->
name|node_info
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Probing hop 1 on local port %u\n"
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|p_dr_path
operator|=
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|h_bind
operator|=
name|osm_dr_path_get_bind_handle
argument_list|(
name|p_dr_path
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|h_bind
operator|!=
name|OSM_BIND_INVALID_HANDLE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|path_array
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|path_array
argument_list|)
argument_list|)
expr_stmt|;
comment|/* the hop_1 operations depend on the type of our node. 	 * Currently - legal nodes that can host SM are SW and CA */
switch|switch
condition|(
name|osm_node_get_type
argument_list|(
name|p_node
argument_list|)
condition|)
block|{
case|case
name|IB_NODE_TYPE_CA
case|:
case|case
name|IB_NODE_TYPE_ROUTER
case|:
name|memset
argument_list|(
operator|&
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|ni_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|context
operator|.
name|ni_context
operator|.
name|port_num
operator|=
name|port_num
expr_stmt|;
name|path_array
index|[
literal|1
index|]
operator|=
name|port_num
expr_stmt|;
name|osm_dr_path_init
argument_list|(
operator|&
name|hop_1_path
argument_list|,
name|h_bind
argument_list|,
literal|1
argument_list|,
name|path_array
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
operator|&
name|hop_1_path
argument_list|,
name|IB_MAD_ATTR_NODE_INFO
argument_list|,
literal|0
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4C82: "
literal|"Request for NodeInfo failed\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_NODE_TYPE_SWITCH
case|:
comment|/* Need to go over all the ports of the switch, and send a node_info 		 * from them. This doesn't include the port 0 of the switch, which 		 * hosts the SM. 		 * Note: We'll send another switchInfo on port 0, since if no ports 		 * are connected, we still want to get some response, and have the 		 * subnet come up. 		 */
name|num_ports
operator|=
name|osm_node_get_num_physp
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
for|for
control|(
name|port_num
operator|=
literal|0
init|;
name|port_num
operator|<
name|num_ports
condition|;
name|port_num
operator|++
control|)
block|{
comment|/* go through the port only if the port is not DOWN */
name|p_ext_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ext_physp
operator|||
name|ib_port_info_get_port_state
argument_list|(
operator|&
name|p_ext_physp
operator|->
name|port_info
argument_list|)
operator|<=
name|IB_LINK_DOWN
condition|)
continue|continue;
name|memset
argument_list|(
operator|&
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|ni_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|context
operator|.
name|ni_context
operator|.
name|port_num
operator|=
name|port_num
expr_stmt|;
name|path_array
index|[
literal|1
index|]
operator|=
name|port_num
expr_stmt|;
name|osm_dr_path_init
argument_list|(
operator|&
name|hop_1_path
argument_list|,
name|h_bind
argument_list|,
literal|1
argument_list|,
name|path_array
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
operator|&
name|hop_1_path
argument_list|,
name|IB_MAD_ATTR_NODE_INFO
argument_list|,
literal|0
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4C82: "
literal|"Request for NodeInfo failed\n"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4C83: Unknown node type %d\n"
argument_list|,
name|osm_node_get_type
argument_list|(
name|p_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|is_sm_port_down
parameter_list|(
name|osm_sm_t
modifier|*
specifier|const
name|sm
parameter_list|)
block|{
name|ib_net64_t
name|port_guid
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|port_guid
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|sm_port_guid
expr_stmt|;
if|if
condition|(
name|port_guid
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|CL_PLOCK_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
block|{
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4C85: "
literal|"SM port with GUID:%016"
name|PRIx64
literal|" is unknown\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
return|return
name|osm_physp_get_port_state
argument_list|(
name|p_port
operator|->
name|p_physp
argument_list|)
operator|==
name|IB_LINK_DOWN
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sweep_hop_0
parameter_list|(
name|osm_sm_t
modifier|*
specifier|const
name|sm
parameter_list|)
block|{
name|ib_api_status_t
name|status
decl_stmt|;
name|osm_dr_path_t
name|dr_path
decl_stmt|;
name|osm_bind_handle_t
name|h_bind
decl_stmt|;
name|uint8_t
name|path_array
index|[
name|IB_SUBNET_PATH_HOPS_MAX
index|]
decl_stmt|;
name|memset
argument_list|(
name|path_array
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|path_array
argument_list|)
argument_list|)
expr_stmt|;
name|h_bind
operator|=
name|osm_sm_mad_ctrl_get_bind_handle
argument_list|(
operator|&
name|sm
operator|->
name|mad_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|h_bind
operator|==
name|OSM_BIND_INVALID_HANDLE
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"No bound ports.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|osm_dr_path_init
argument_list|(
operator|&
name|dr_path
argument_list|,
name|h_bind
argument_list|,
literal|0
argument_list|,
name|path_array
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
operator|&
name|dr_path
argument_list|,
name|IB_MAD_ATTR_NODE_INFO
argument_list|,
literal|0
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4C86: Request for NodeInfo failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|reset_node_count
parameter_list|(
name|cl_map_item_t
modifier|*
specifier|const
name|p_map_item
parameter_list|,
name|void
modifier|*
name|cxt
parameter_list|)
block|{
name|osm_node_t
modifier|*
name|p_node
init|=
operator|(
name|osm_node_t
operator|*
operator|)
name|p_map_item
decl_stmt|;
name|p_node
operator|->
name|discovery_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|reset_port_count
parameter_list|(
name|cl_map_item_t
modifier|*
specifier|const
name|p_map_item
parameter_list|,
name|void
modifier|*
name|cxt
parameter_list|)
block|{
name|osm_port_t
modifier|*
name|p_port
init|=
operator|(
name|osm_port_t
operator|*
operator|)
name|p_map_item
decl_stmt|;
name|p_port
operator|->
name|discovery_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|reset_switch_count
parameter_list|(
name|cl_map_item_t
modifier|*
specifier|const
name|p_map_item
parameter_list|,
name|void
modifier|*
name|cxt
parameter_list|)
block|{
name|osm_switch_t
modifier|*
name|p_sw
init|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|p_map_item
decl_stmt|;
name|p_sw
operator|->
name|discovery_count
operator|=
literal|0
expr_stmt|;
name|p_sw
operator|->
name|need_update
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|perfmgr_discovery
parameter_list|(
name|osm_opensm_t
modifier|*
name|osm
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|CL_PLOCK_ACQUIRE
argument_list|(
operator|&
name|osm
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cl_qmap_apply_func
argument_list|(
operator|&
name|osm
operator|->
name|subn
operator|.
name|node_guid_tbl
argument_list|,
name|reset_node_count
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cl_qmap_apply_func
argument_list|(
operator|&
name|osm
operator|->
name|subn
operator|.
name|port_guid_tbl
argument_list|,
name|reset_port_count
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cl_qmap_apply_func
argument_list|(
operator|&
name|osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|,
name|reset_switch_count
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
operator|&
name|osm
operator|->
name|lock
argument_list|)
expr_stmt|;
name|osm
operator|->
name|subn
operator|.
name|in_sweep_hop_0
operator|=
name|TRUE
expr_stmt|;
name|ret
operator|=
name|sweep_hop_0
argument_list|(
operator|&
name|osm
operator|->
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|_exit
goto|;
if|if
condition|(
name|wait_for_pending_transactions
argument_list|(
operator|&
name|osm
operator|->
name|stats
argument_list|)
condition|)
goto|goto
name|_exit
goto|;
if|if
condition|(
name|is_sm_port_down
argument_list|(
operator|&
name|osm
operator|->
name|sm
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"SM port is down\n"
argument_list|)
expr_stmt|;
goto|goto
name|_drop
goto|;
block|}
name|osm
operator|->
name|subn
operator|.
name|in_sweep_hop_0
operator|=
name|FALSE
expr_stmt|;
name|ret
operator|=
name|sweep_hop_1
argument_list|(
operator|&
name|osm
operator|->
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|_exit
goto|;
if|if
condition|(
name|wait_for_pending_transactions
argument_list|(
operator|&
name|osm
operator|->
name|stats
argument_list|)
condition|)
goto|goto
name|_exit
goto|;
name|_drop
label|:
name|osm_drop_mgr_process
argument_list|(
operator|&
name|osm
operator|->
name|sm
argument_list|)
expr_stmt|;
name|_exit
label|:
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Main PerfMgr processor - query the performance counters.  **********************************************************************/
end_comment

begin_function
name|void
name|osm_perfmgr_process
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|)
block|{
if|#
directive|if
name|ENABLE_OSM_PERF_MGR_PROFILE
name|struct
name|timeval
name|before
decl_stmt|,
name|after
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pm
operator|->
name|state
operator|!=
name|PERFMGR_STATE_ENABLED
condition|)
return|return;
if|if
condition|(
name|pm
operator|->
name|subn
operator|->
name|sm_state
operator|==
name|IB_SMINFO_STATE_STANDBY
operator|||
name|pm
operator|->
name|subn
operator|->
name|sm_state
operator|==
name|IB_SMINFO_STATE_NOTACTIVE
condition|)
name|perfmgr_discovery
argument_list|(
name|pm
operator|->
name|subn
operator|->
name|p_osm
argument_list|)
expr_stmt|;
if|#
directive|if
name|ENABLE_OSM_PERF_MGR_PROFILE
name|gettimeofday
argument_list|(
operator|&
name|before
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pm
operator|->
name|sweep_state
operator|=
name|PERFMGR_SWEEP_ACTIVE
expr_stmt|;
comment|/* With the global lock held collect the node guids */
comment|/* FIXME we should be able to track SA notices 	 * and not have to sweep the node_guid_tbl each pass 	 */
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Gathering PerfMgr stats\n"
argument_list|)
expr_stmt|;
name|cl_plock_acquire
argument_list|(
name|pm
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cl_qmap_apply_func
argument_list|(
operator|&
operator|(
name|pm
operator|->
name|subn
operator|->
name|node_guid_tbl
operator|)
argument_list|,
name|__collect_guids
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pm
argument_list|)
expr_stmt|;
name|cl_plock_release
argument_list|(
name|pm
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* then for each node query their counters */
name|cl_qmap_apply_func
argument_list|(
operator|&
operator|(
name|pm
operator|->
name|monitored_map
operator|)
argument_list|,
name|__osm_perfmgr_query_counters
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pm
argument_list|)
expr_stmt|;
comment|/* Clean out any nodes found to be removed during the 	 * sweep 	 */
name|__remove_marked_nodes
argument_list|(
name|pm
argument_list|)
expr_stmt|;
if|#
directive|if
name|ENABLE_OSM_PERF_MGR_PROFILE
comment|/* spin on outstanding queries */
while|while
condition|(
name|pm
operator|->
name|outstanding_queries
operator|>
literal|0
condition|)
name|cl_event_wait_on
argument_list|(
operator|&
name|pm
operator|->
name|sig_sweep
argument_list|,
literal|1000
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|after
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|diff_time
argument_list|(
operator|&
name|before
argument_list|,
operator|&
name|after
argument_list|,
operator|&
name|after
argument_list|)
expr_stmt|;
name|osm_log
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"PerfMgr total sweep time : %ld.%06ld s\n"
literal|"        fastest mad      : %g us\n"
literal|"        slowest mad      : %g us\n"
literal|"        average mad      : %g us\n"
argument_list|,
name|after
operator|.
name|tv_sec
argument_list|,
name|after
operator|.
name|tv_usec
argument_list|,
name|perfmgr_mad_stats
operator|.
name|fastest_us
argument_list|,
name|perfmgr_mad_stats
operator|.
name|slowest_us
argument_list|,
name|perfmgr_mad_stats
operator|.
name|avg_us
argument_list|)
expr_stmt|;
name|perfmgr_clear_mad_stats
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|pm
operator|->
name|sweep_state
operator|=
name|PERFMGR_SWEEP_SLEEP
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * PerfMgr timer - loop continuously and signal SM to run PerfMgr  * processor.  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|perfmgr_sweep
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|osm_perfmgr_t
modifier|*
name|pm
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|pm
operator|->
name|state
operator|==
name|PERFMGR_STATE_ENABLED
condition|)
name|osm_sm_signal
argument_list|(
name|pm
operator|->
name|sm
argument_list|,
name|OSM_SIGNAL_PERFMGR_SWEEP
argument_list|)
expr_stmt|;
name|cl_timer_start
argument_list|(
operator|&
name|pm
operator|->
name|sweep_timer
argument_list|,
name|pm
operator|->
name|sweep_time_s
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|void
name|osm_perfmgr_shutdown
parameter_list|(
name|osm_perfmgr_t
modifier|*
specifier|const
name|pm
parameter_list|)
block|{
name|OSM_LOG_ENTER
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
name|cl_timer_stop
argument_list|(
operator|&
name|pm
operator|->
name|sweep_timer
argument_list|)
expr_stmt|;
name|osm_perfmgr_mad_unbind
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|void
name|osm_perfmgr_destroy
parameter_list|(
name|osm_perfmgr_t
modifier|*
specifier|const
name|pm
parameter_list|)
block|{
name|OSM_LOG_ENTER
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
name|perfmgr_db_destroy
argument_list|(
name|pm
operator|->
name|db
argument_list|)
expr_stmt|;
name|cl_timer_destroy
argument_list|(
operator|&
name|pm
operator|->
name|sweep_timer
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Detect if someone else on the network could have cleared the counters  * without us knowing.  This is easy to detect because the counters never wrap  * but are "sticky"  *  * The one time this will not work is if the port is getting errors fast enough  * to have the reading overtake the previous reading.  In this case counters  * will be missed.  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|osm_perfmgr_check_oob_clear
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|,
name|__monitored_node_t
modifier|*
name|mon_node
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|perfmgr_db_err_reading_t
modifier|*
name|cr
parameter_list|,
name|perfmgr_db_data_cnt_reading_t
modifier|*
name|dc
parameter_list|)
block|{
name|perfmgr_db_err_reading_t
name|prev_err
decl_stmt|;
name|perfmgr_db_data_cnt_reading_t
name|prev_dc
decl_stmt|;
if|if
condition|(
name|perfmgr_db_get_prev_err
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|,
operator|&
name|prev_err
argument_list|)
operator|!=
name|PERFMGR_EVENT_DB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Failed to find previous "
literal|"error reading for %s (guid 0x%"
name|PRIx64
literal|") port %u\n"
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cr
operator|->
name|symbol_err_cnt
operator|<
name|prev_err
operator|.
name|symbol_err_cnt
operator|||
name|cr
operator|->
name|link_err_recover
operator|<
name|prev_err
operator|.
name|link_err_recover
operator|||
name|cr
operator|->
name|link_downed
operator|<
name|prev_err
operator|.
name|link_downed
operator|||
name|cr
operator|->
name|rcv_err
operator|<
name|prev_err
operator|.
name|rcv_err
operator|||
name|cr
operator|->
name|rcv_rem_phys_err
operator|<
name|prev_err
operator|.
name|rcv_rem_phys_err
operator|||
name|cr
operator|->
name|rcv_switch_relay_err
operator|<
name|prev_err
operator|.
name|rcv_switch_relay_err
operator|||
name|cr
operator|->
name|xmit_discards
operator|<
name|prev_err
operator|.
name|xmit_discards
operator|||
name|cr
operator|->
name|xmit_constraint_err
operator|<
name|prev_err
operator|.
name|xmit_constraint_err
operator|||
name|cr
operator|->
name|rcv_constraint_err
operator|<
name|prev_err
operator|.
name|rcv_constraint_err
operator|||
name|cr
operator|->
name|link_integrity
operator|<
name|prev_err
operator|.
name|link_integrity
operator|||
name|cr
operator|->
name|buffer_overrun
operator|<
name|prev_err
operator|.
name|buffer_overrun
operator|||
name|cr
operator|->
name|vl15_dropped
operator|<
name|prev_err
operator|.
name|vl15_dropped
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"PerfMgr: ERR 4C0A: "
literal|"Detected an out of band error clear "
literal|"on %s (0x%"
name|PRIx64
literal|") port %u\n"
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|perfmgr_db_clear_prev_err
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME handle extended counters */
if|if
condition|(
name|perfmgr_db_get_prev_dc
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|,
operator|&
name|prev_dc
argument_list|)
operator|!=
name|PERFMGR_EVENT_DB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Failed to find previous data count "
literal|"reading for %s (0x%"
name|PRIx64
literal|") port %u\n"
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dc
operator|->
name|xmit_data
operator|<
name|prev_dc
operator|.
name|xmit_data
operator|||
name|dc
operator|->
name|rcv_data
operator|<
name|prev_dc
operator|.
name|rcv_data
operator|||
name|dc
operator|->
name|xmit_pkts
operator|<
name|prev_dc
operator|.
name|xmit_pkts
operator|||
name|dc
operator|->
name|rcv_pkts
operator|<
name|prev_dc
operator|.
name|rcv_pkts
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"PerfMgr: ERR 4C0B: Detected an out of band data counter "
literal|"clear on node %s (0x%"
name|PRIx64
literal|") port %u\n"
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|perfmgr_db_clear_prev_dc
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**********************************************************************  * Return 1 if the value is "close" to overflowing  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|counter_overflow_4
parameter_list|(
name|uint8_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|val
operator|>=
literal|10
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|counter_overflow_8
parameter_list|(
name|uint8_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|val
operator|>=
operator|(
name|UINT8_MAX
operator|-
operator|(
name|UINT8_MAX
operator|/
literal|4
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|counter_overflow_16
parameter_list|(
name|ib_net16_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|cl_ntoh16
argument_list|(
name|val
argument_list|)
operator|>=
operator|(
name|UINT16_MAX
operator|-
operator|(
name|UINT16_MAX
operator|/
literal|4
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|counter_overflow_32
parameter_list|(
name|ib_net32_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|cl_ntoh32
argument_list|(
name|val
argument_list|)
operator|>=
operator|(
name|UINT32_MAX
operator|-
operator|(
name|UINT32_MAX
operator|/
literal|4
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Check if the port counters have overflowed and if so issue a clear  * MAD to the port.  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|osm_perfmgr_check_overflow
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|,
name|__monitored_node_t
modifier|*
name|mon_node
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|ib_port_counters_t
modifier|*
name|pc
parameter_list|)
block|{
name|osm_madw_context_t
name|mad_context
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|ib_net32_t
name|remote_qp
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|counter_overflow_16
argument_list|(
name|pc
operator|->
name|symbol_err_cnt
argument_list|)
operator|||
name|counter_overflow_8
argument_list|(
name|pc
operator|->
name|link_err_recover
argument_list|)
operator|||
name|counter_overflow_8
argument_list|(
name|pc
operator|->
name|link_downed
argument_list|)
operator|||
name|counter_overflow_16
argument_list|(
name|pc
operator|->
name|rcv_err
argument_list|)
operator|||
name|counter_overflow_16
argument_list|(
name|pc
operator|->
name|rcv_rem_phys_err
argument_list|)
operator|||
name|counter_overflow_16
argument_list|(
name|pc
operator|->
name|rcv_switch_relay_err
argument_list|)
operator|||
name|counter_overflow_16
argument_list|(
name|pc
operator|->
name|xmit_discards
argument_list|)
operator|||
name|counter_overflow_8
argument_list|(
name|pc
operator|->
name|xmit_constraint_err
argument_list|)
operator|||
name|counter_overflow_8
argument_list|(
name|pc
operator|->
name|rcv_constraint_err
argument_list|)
operator|||
name|counter_overflow_4
argument_list|(
name|PC_LINK_INT
argument_list|(
name|pc
operator|->
name|link_int_buffer_overrun
argument_list|)
argument_list|)
operator|||
name|counter_overflow_4
argument_list|(
name|PC_BUF_OVERRUN
argument_list|(
name|pc
operator|->
name|link_int_buffer_overrun
argument_list|)
argument_list|)
operator|||
name|counter_overflow_16
argument_list|(
name|pc
operator|->
name|vl15_dropped
argument_list|)
operator|||
name|counter_overflow_32
argument_list|(
name|pc
operator|->
name|xmit_data
argument_list|)
operator|||
name|counter_overflow_32
argument_list|(
name|pc
operator|->
name|rcv_data
argument_list|)
operator|||
name|counter_overflow_32
argument_list|(
name|pc
operator|->
name|xmit_pkts
argument_list|)
operator|||
name|counter_overflow_32
argument_list|(
name|pc
operator|->
name|rcv_pkts
argument_list|)
condition|)
block|{
name|osm_node_t
modifier|*
name|p_node
init|=
name|NULL
decl_stmt|;
name|ib_net16_t
name|lid
init|=
literal|0
decl_stmt|;
name|osm_log
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"PerfMgr: Counter overflow: %s (0x%"
name|PRIx64
literal|") port %d; clearing counters\n"
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|cl_plock_acquire
argument_list|(
name|pm
operator|->
name|lock
argument_list|)
expr_stmt|;
name|p_node
operator|=
name|osm_get_node_by_guid
argument_list|(
name|pm
operator|->
name|subn
argument_list|,
name|cl_hton64
argument_list|(
name|mon_node
operator|->
name|guid
argument_list|)
argument_list|)
expr_stmt|;
name|lid
operator|=
name|get_lid
argument_list|(
name|p_node
argument_list|,
name|port
argument_list|,
name|mon_node
argument_list|)
expr_stmt|;
name|cl_plock_release
argument_list|(
name|pm
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|lid
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"PerfMgr: ERR 4C0C: "
literal|"Failed to clear counters for %s (0x%"
name|PRIx64
literal|") port %d; failed to get lid\n"
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|remote_qp
operator|=
name|get_qp
argument_list|(
name|NULL
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|mad_context
operator|.
name|perfmgr_context
operator|.
name|node_guid
operator|=
name|mon_node
operator|->
name|guid
expr_stmt|;
name|mad_context
operator|.
name|perfmgr_context
operator|.
name|port
operator|=
name|port
expr_stmt|;
name|mad_context
operator|.
name|perfmgr_context
operator|.
name|mad_method
operator|=
name|IB_MAD_METHOD_SET
expr_stmt|;
comment|/* clear port counters */
name|status
operator|=
name|osm_perfmgr_send_pc_mad
argument_list|(
name|pm
argument_list|,
name|lid
argument_list|,
name|remote_qp
argument_list|,
name|port
argument_list|,
name|IB_MAD_METHOD_SET
argument_list|,
operator|&
name|mad_context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"PerfMgr: ERR 4C11: "
literal|"Failed to send clear counters MAD for %s (0x%"
name|PRIx64
literal|") port %d\n"
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|perfmgr_db_clear_prev_dc
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Check values for logging of errors  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|osm_perfmgr_log_events
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|,
name|__monitored_node_t
modifier|*
name|mon_node
parameter_list|,
name|uint8_t
name|port
parameter_list|,
name|perfmgr_db_err_reading_t
modifier|*
name|reading
parameter_list|)
block|{
name|perfmgr_db_err_reading_t
name|prev_read
decl_stmt|;
name|time_t
name|time_diff
init|=
literal|0
decl_stmt|;
name|perfmgr_db_err_t
name|err
init|=
name|perfmgr_db_get_prev_err
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|,
operator|&
name|prev_read
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
name|PERFMGR_EVENT_DB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Failed to find previous "
literal|"reading for %s (0x%"
name|PRIx64
literal|") port %u\n"
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return;
block|}
name|time_diff
operator|=
operator|(
name|reading
operator|->
name|time
operator|-
name|prev_read
operator|.
name|time
operator|)
expr_stmt|;
comment|/* FIXME these events should be defineable by the user in a config 	 * file somewhere. */
if|if
condition|(
name|reading
operator|->
name|symbol_err_cnt
operator|>
name|prev_read
operator|.
name|symbol_err_cnt
condition|)
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4C0D: "
literal|"Found %"
name|PRIu64
literal|" Symbol errors in %lu sec on %s (0x%"
name|PRIx64
literal|") port %u\n"
argument_list|,
operator|(
name|reading
operator|->
name|symbol_err_cnt
operator|-
name|prev_read
operator|.
name|symbol_err_cnt
operator|)
argument_list|,
name|time_diff
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|reading
operator|->
name|rcv_err
operator|>
name|prev_read
operator|.
name|rcv_err
condition|)
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4C0E: "
literal|"Found %"
name|PRIu64
literal|" Receive errors in %lu sec on %s (0x%"
name|PRIx64
literal|") port %u\n"
argument_list|,
operator|(
name|reading
operator|->
name|rcv_err
operator|-
name|prev_read
operator|.
name|rcv_err
operator|)
argument_list|,
name|time_diff
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|reading
operator|->
name|xmit_discards
operator|>
name|prev_read
operator|.
name|xmit_discards
condition|)
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4C0F: "
literal|"Found %"
name|PRIu64
literal|" Xmit Discards in %lu sec on %s (0x%"
name|PRIx64
literal|") port %u\n"
argument_list|,
operator|(
name|reading
operator|->
name|xmit_discards
operator|-
name|prev_read
operator|.
name|xmit_discards
operator|)
argument_list|,
name|time_diff
argument_list|,
name|mon_node
operator|->
name|name
argument_list|,
name|mon_node
operator|->
name|guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * The dispatcher uses a thread pool which will call this function when  * we have a thread available to process our mad received from the wire.  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|osm_pc_rcv_process
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|osm_perfmgr_t
modifier|*
specifier|const
name|pm
init|=
operator|(
name|osm_perfmgr_t
operator|*
operator|)
name|context
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_madw
init|=
operator|(
name|osm_madw_t
operator|*
operator|)
name|data
decl_stmt|;
name|osm_madw_context_t
modifier|*
name|mad_context
init|=
operator|&
operator|(
name|p_madw
operator|->
name|context
operator|)
decl_stmt|;
name|ib_port_counters_t
modifier|*
name|wire_read
init|=
operator|(
name|ib_port_counters_t
operator|*
operator|)
operator|&
operator|(
name|osm_madw_get_perfmgt_mad_ptr
argument_list|(
name|p_madw
argument_list|)
operator|->
name|data
operator|)
decl_stmt|;
name|ib_mad_t
modifier|*
name|p_mad
init|=
name|osm_madw_get_mad_ptr
argument_list|(
name|p_madw
argument_list|)
decl_stmt|;
name|uint64_t
name|node_guid
init|=
name|mad_context
operator|->
name|perfmgr_context
operator|.
name|node_guid
decl_stmt|;
name|uint8_t
name|port
init|=
name|mad_context
operator|->
name|perfmgr_context
operator|.
name|port
decl_stmt|;
name|perfmgr_db_err_reading_t
name|err_reading
decl_stmt|;
name|perfmgr_db_data_cnt_reading_t
name|data_reading
decl_stmt|;
name|cl_map_item_t
modifier|*
name|p_node
decl_stmt|;
name|__monitored_node_t
modifier|*
name|p_mon_node
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
comment|/* go ahead and get the monitored node struct to have the printable 	 * name if needed in messages 	 */
if|if
condition|(
operator|(
name|p_node
operator|=
name|cl_qmap_get
argument_list|(
operator|&
operator|(
name|pm
operator|->
name|monitored_map
operator|)
argument_list|,
name|node_guid
argument_list|)
operator|)
operator|==
name|cl_qmap_end
argument_list|(
operator|&
operator|(
name|pm
operator|->
name|monitored_map
operator|)
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4C12: GUID 0x%016"
name|PRIx64
literal|" not found in monitored map\n"
argument_list|,
name|node_guid
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_mon_node
operator|=
operator|(
name|__monitored_node_t
operator|*
operator|)
name|p_node
expr_stmt|;
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Processing received MAD status 0x%x context 0x%"
name|PRIx64
literal|" port %u\n"
argument_list|,
name|p_mad
operator|->
name|status
argument_list|,
name|node_guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/* Response could also be redirection (IBM eHCA PMA does this) */
if|if
condition|(
name|p_mad
operator|->
name|attr_id
operator|==
name|IB_MAD_ATTR_CLASS_PORT_INFO
condition|)
block|{
name|char
name|gid_str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|ib_class_port_info_t
modifier|*
name|cpi
init|=
operator|(
name|ib_class_port_info_t
operator|*
operator|)
operator|&
operator|(
name|osm_madw_get_perfmgt_mad_ptr
argument_list|(
name|p_madw
argument_list|)
operator|->
name|data
operator|)
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Redirection to LID %u GID %s QP 0x%x received\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|cpi
operator|->
name|redir_lid
argument_list|)
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|cpi
operator|->
name|redir_gid
operator|.
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
name|gid_str
argument_list|)
argument_list|,
name|cl_ntoh32
argument_list|(
name|cpi
operator|->
name|redir_qp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* LID or GID redirection ? */
comment|/* For GID redirection, need to get PathRecord from SA */
if|if
condition|(
name|cpi
operator|->
name|redir_lid
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"GID redirection not currently implemented!\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|!
name|pm
operator|->
name|subn
operator|->
name|opt
operator|.
name|perfmgr_redir
condition|)
block|{
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4C16: "
literal|"redirection requested but disabled\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* LID redirection support (easier than GID redirection) */
name|cl_plock_acquire
argument_list|(
name|pm
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* Now, validate port number */
if|if
condition|(
name|port
operator|>
name|p_mon_node
operator|->
name|redir_tbl_size
condition|)
block|{
name|cl_plock_release
argument_list|(
name|pm
operator|->
name|lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4C13: "
literal|"Invalid port num %d for GUID 0x%016"
name|PRIx64
literal|" num ports %d\n"
argument_list|,
name|port
argument_list|,
name|node_guid
argument_list|,
name|p_mon_node
operator|->
name|redir_tbl_size
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_mon_node
operator|->
name|redir_port
index|[
name|port
index|]
operator|.
name|redir_lid
operator|=
name|cpi
operator|->
name|redir_lid
expr_stmt|;
name|p_mon_node
operator|->
name|redir_port
index|[
name|port
index|]
operator|.
name|redir_qp
operator|=
name|cpi
operator|->
name|redir_qp
expr_stmt|;
name|cl_plock_release
argument_list|(
name|pm
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* Finally, reissue the query to the redirected location */
name|status
operator|=
name|osm_perfmgr_send_pc_mad
argument_list|(
name|pm
argument_list|,
name|cpi
operator|->
name|redir_lid
argument_list|,
name|cpi
operator|->
name|redir_qp
argument_list|,
name|port
argument_list|,
name|mad_context
operator|->
name|perfmgr_context
operator|.
name|mad_method
argument_list|,
name|mad_context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 4C14: "
literal|"Failed to send redirected MAD with method 0x%x for node 0x%"
name|PRIx64
literal|" port %d\n"
argument_list|,
name|mad_context
operator|->
name|perfmgr_context
operator|.
name|mad_method
argument_list|,
name|node_guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|CL_ASSERT
argument_list|(
name|p_mad
operator|->
name|attr_id
operator|==
name|IB_MAD_ATTR_PORT_CNTRS
argument_list|)
expr_stmt|;
name|perfmgr_db_fill_err_read
argument_list|(
name|wire_read
argument_list|,
operator|&
name|err_reading
argument_list|)
expr_stmt|;
comment|/* FIXME separate query for extended counters if they are supported 	 * on the port. 	 */
name|perfmgr_db_fill_data_cnt_read_pc
argument_list|(
name|wire_read
argument_list|,
operator|&
name|data_reading
argument_list|)
expr_stmt|;
comment|/* detect an out of band clear on the port */
if|if
condition|(
name|mad_context
operator|->
name|perfmgr_context
operator|.
name|mad_method
operator|!=
name|IB_MAD_METHOD_SET
condition|)
name|osm_perfmgr_check_oob_clear
argument_list|(
name|pm
argument_list|,
name|p_mon_node
argument_list|,
name|port
argument_list|,
operator|&
name|err_reading
argument_list|,
operator|&
name|data_reading
argument_list|)
expr_stmt|;
comment|/* log any critical events from this reading */
name|osm_perfmgr_log_events
argument_list|(
name|pm
argument_list|,
name|p_mon_node
argument_list|,
name|port
argument_list|,
operator|&
name|err_reading
argument_list|)
expr_stmt|;
if|if
condition|(
name|mad_context
operator|->
name|perfmgr_context
operator|.
name|mad_method
operator|==
name|IB_MAD_METHOD_GET
condition|)
block|{
name|perfmgr_db_add_err_reading
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|node_guid
argument_list|,
name|port
argument_list|,
operator|&
name|err_reading
argument_list|)
expr_stmt|;
name|perfmgr_db_add_dc_reading
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|node_guid
argument_list|,
name|port
argument_list|,
operator|&
name|data_reading
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|perfmgr_db_clear_prev_err
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|node_guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|perfmgr_db_clear_prev_dc
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|node_guid
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
name|osm_perfmgr_check_overflow
argument_list|(
name|pm
argument_list|,
name|p_mon_node
argument_list|,
name|port
argument_list|,
name|wire_read
argument_list|)
expr_stmt|;
if|#
directive|if
name|ENABLE_OSM_PERF_MGR_PROFILE
do|do
block|{
name|struct
name|timeval
name|proc_time
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|proc_time
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|diff_time
argument_list|(
operator|&
operator|(
name|p_madw
operator|->
name|context
operator|.
name|perfmgr_context
operator|.
name|query_start
operator|)
argument_list|,
operator|&
name|proc_time
argument_list|,
operator|&
name|proc_time
argument_list|)
expr_stmt|;
name|update_mad_stats
argument_list|(
operator|&
name|proc_time
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
endif|#
directive|endif
name|Exit
label|:
name|osm_mad_pool_put
argument_list|(
name|pm
operator|->
name|mad_pool
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Initialize the PerfMgr object  **********************************************************************/
end_comment

begin_function
name|ib_api_status_t
name|osm_perfmgr_init
parameter_list|(
name|osm_perfmgr_t
modifier|*
specifier|const
name|pm
parameter_list|,
name|osm_opensm_t
modifier|*
name|osm
parameter_list|,
specifier|const
name|osm_subn_opt_t
modifier|*
specifier|const
name|p_opt
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Initializing PerfMgr\n"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|pm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pm
argument_list|)
argument_list|)
expr_stmt|;
name|cl_event_construct
argument_list|(
operator|&
name|pm
operator|->
name|sig_sweep
argument_list|)
expr_stmt|;
name|cl_event_init
argument_list|(
operator|&
name|pm
operator|->
name|sig_sweep
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pm
operator|->
name|subn
operator|=
operator|&
name|osm
operator|->
name|subn
expr_stmt|;
name|pm
operator|->
name|sm
operator|=
operator|&
name|osm
operator|->
name|sm
expr_stmt|;
name|pm
operator|->
name|log
operator|=
operator|&
name|osm
operator|->
name|log
expr_stmt|;
name|pm
operator|->
name|mad_pool
operator|=
operator|&
name|osm
operator|->
name|mad_pool
expr_stmt|;
name|pm
operator|->
name|vendor
operator|=
name|osm
operator|->
name|p_vendor
expr_stmt|;
name|pm
operator|->
name|trans_id
operator|=
name|OSM_PERFMGR_INITIAL_TID_VALUE
expr_stmt|;
name|pm
operator|->
name|lock
operator|=
operator|&
name|osm
operator|->
name|lock
expr_stmt|;
name|pm
operator|->
name|state
operator|=
name|p_opt
operator|->
name|perfmgr
condition|?
name|PERFMGR_STATE_ENABLED
else|:
name|PERFMGR_STATE_DISABLE
expr_stmt|;
name|pm
operator|->
name|sweep_time_s
operator|=
name|p_opt
operator|->
name|perfmgr_sweep_time_s
expr_stmt|;
name|pm
operator|->
name|max_outstanding_queries
operator|=
name|p_opt
operator|->
name|perfmgr_max_outstanding_queries
expr_stmt|;
name|pm
operator|->
name|osm
operator|=
name|osm
expr_stmt|;
name|status
operator|=
name|cl_timer_init
argument_list|(
operator|&
name|pm
operator|->
name|sweep_timer
argument_list|,
name|perfmgr_sweep
argument_list|,
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
name|pm
operator|->
name|db
operator|=
name|perfmgr_db_construct
argument_list|(
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pm
operator|->
name|db
condition|)
block|{
name|pm
operator|->
name|state
operator|=
name|PERFMGR_STATE_NO_DB
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|pm
operator|->
name|pc_disp_h
operator|=
name|cl_disp_register
argument_list|(
operator|&
name|osm
operator|->
name|disp
argument_list|,
name|OSM_MSG_MAD_PORT_COUNTERS
argument_list|,
name|osm_pc_rcv_process
argument_list|,
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|pc_disp_h
operator|==
name|CL_DISP_INVALID_HANDLE
condition|)
goto|goto
name|Exit
goto|;
name|__init_monitored_nodes
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|cl_timer_start
argument_list|(
operator|&
name|pm
operator|->
name|sweep_timer
argument_list|,
name|pm
operator|->
name|sweep_time_s
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|pm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * Clear the counters from the db  **********************************************************************/
end_comment

begin_function
name|void
name|osm_perfmgr_clear_counters
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|)
block|{
comment|/** 	 * FIXME todo issue clear on the fabric? 	 */
name|perfmgr_db_clear_counters
argument_list|(
name|pm
operator|->
name|db
argument_list|)
expr_stmt|;
name|osm_log
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"PerfMgr counters cleared\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************  * Have the DB dump its information to the file specified  *******************************************************************/
end_comment

begin_function
name|void
name|osm_perfmgr_dump_counters
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|,
name|perfmgr_db_dump_t
name|dump_type
parameter_list|)
block|{
name|char
name|path
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|file_name
decl_stmt|;
if|if
condition|(
name|pm
operator|->
name|subn
operator|->
name|opt
operator|.
name|event_db_dump_file
condition|)
name|file_name
operator|=
name|pm
operator|->
name|subn
operator|->
name|opt
operator|.
name|event_db_dump_file
expr_stmt|;
else|else
block|{
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|pm
operator|->
name|subn
operator|->
name|opt
operator|.
name|dump_files_dir
argument_list|,
name|OSM_PERFMGR_DEFAULT_DUMP_FILE
argument_list|)
expr_stmt|;
name|file_name
operator|=
name|path
expr_stmt|;
block|}
if|if
condition|(
name|perfmgr_db_dump
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|file_name
argument_list|,
name|dump_type
argument_list|)
operator|!=
literal|0
condition|)
name|OSM_LOG
argument_list|(
name|pm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"Failed to dump file %s : %s"
argument_list|,
name|file_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************  * Have the DB print its information to the fp specified  *******************************************************************/
end_comment

begin_function
name|void
name|osm_perfmgr_print_counters
parameter_list|(
name|osm_perfmgr_t
modifier|*
name|pm
parameter_list|,
name|char
modifier|*
name|nodename
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|uint64_t
name|guid
init|=
name|strtoull
argument_list|(
name|nodename
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|guid
operator|==
literal|0
operator|&&
name|errno
operator|==
name|EINVAL
condition|)
block|{
name|perfmgr_db_print_by_name
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|nodename
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|perfmgr_db_print_by_guid
argument_list|(
name|pm
operator|->
name|db
argument_list|,
name|guid
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENABLE_OSM_PERF_MGR */
end_comment

end_unit

