begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2008 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2006 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  * Copyright (c) 2008 Xsigo Systems Inc.  All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_mcast_mgr_t.  * This file implements the Multicast Manager object.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_sm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_multicast.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_node.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_switch.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_msgdef.h>
end_include

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
name|osm_mcast_work_obj
block|{
name|cl_list_item_t
name|list_item
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
block|}
name|osm_mcast_work_obj_t
typedef|;
end_typedef

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|osm_mcast_work_obj_t
modifier|*
name|__osm_mcast_work_obj_new
parameter_list|(
name|IN
specifier|const
name|osm_port_t
modifier|*
specifier|const
name|p_port
parameter_list|)
block|{
comment|/* 	   TO DO - get these objects from a lockpool. 	 */
name|osm_mcast_work_obj_t
modifier|*
name|p_obj
decl_stmt|;
comment|/* 	   clean allocated memory to avoid assertion when trying to insert to 	   qlist. 	   see cl_qlist_insert_tail(): CL_ASSERT(p_list_item->p_list != p_list) 	 */
name|p_obj
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p_obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_obj
condition|)
block|{
name|memset
argument_list|(
name|p_obj
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_obj
argument_list|)
argument_list|)
expr_stmt|;
name|p_obj
operator|->
name|p_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|p_port
expr_stmt|;
block|}
return|return
operator|(
name|p_obj
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_mcast_work_obj_delete
parameter_list|(
name|IN
name|osm_mcast_work_obj_t
modifier|*
name|p_wobj
parameter_list|)
block|{
name|free
argument_list|(
name|p_wobj
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Recursively remove nodes from the tree  *********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_mcast_mgr_purge_tree_node
parameter_list|(
name|IN
name|osm_mtree_node_t
modifier|*
name|p_mtn
parameter_list|)
block|{
name|uint8_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_mtn
operator|->
name|max_children
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p_mtn
operator|->
name|child_array
index|[
name|i
index|]
operator|&&
operator|(
name|p_mtn
operator|->
name|child_array
index|[
name|i
index|]
operator|!=
name|OSM_MTREE_LEAF
operator|)
condition|)
name|__osm_mcast_mgr_purge_tree_node
argument_list|(
name|p_mtn
operator|->
name|child_array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|p_mtn
operator|->
name|child_array
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|p_mtn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_mcast_mgr_purge_tree
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_mgrp_t
modifier|*
specifier|const
name|p_mgrp
parameter_list|)
block|{
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_mgrp
operator|->
name|p_root
condition|)
name|__osm_mcast_mgr_purge_tree_node
argument_list|(
name|p_mgrp
operator|->
name|p_root
argument_list|)
expr_stmt|;
name|p_mgrp
operator|->
name|p_root
operator|=
name|NULL
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|float
name|osm_mcast_mgr_compute_avg_hops
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
specifier|const
name|osm_mgrp_t
modifier|*
specifier|const
name|p_mgrp
parameter_list|,
specifier|const
name|osm_switch_t
modifier|*
specifier|const
name|p_sw
parameter_list|)
block|{
name|float
name|avg_hops
init|=
literal|0
decl_stmt|;
name|uint32_t
name|hops
init|=
literal|0
decl_stmt|;
name|uint32_t
name|num_ports
init|=
literal|0
decl_stmt|;
specifier|const
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
specifier|const
name|osm_mcm_port_t
modifier|*
name|p_mcm_port
decl_stmt|;
specifier|const
name|cl_qmap_t
modifier|*
name|p_mcm_tbl
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_mcm_tbl
operator|=
operator|&
name|p_mgrp
operator|->
name|mcm_port_tbl
expr_stmt|;
comment|/* 	   For each member of the multicast group, compute the 	   number of hops to its base LID. 	 */
for|for
control|(
name|p_mcm_port
operator|=
operator|(
name|osm_mcm_port_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_mcm_tbl
argument_list|)
init|;
name|p_mcm_port
operator|!=
operator|(
name|osm_mcm_port_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_mcm_tbl
argument_list|)
condition|;
name|p_mcm_port
operator|=
operator|(
name|osm_mcm_port_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_mcm_port
operator|->
name|map_item
argument_list|)
control|)
block|{
comment|/* 		   Acquire the port object for this port guid, then create 		   the new worker object to build the list. 		 */
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|ib_gid_get_guid
argument_list|(
operator|&
name|p_mcm_port
operator|->
name|port_gid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A18: "
literal|"No port object for port 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|ib_gid_get_guid
argument_list|(
operator|&
name|p_mcm_port
operator|->
name|port_gid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|hops
operator|+=
name|osm_switch_get_port_least_hops
argument_list|(
name|p_sw
argument_list|,
name|p_port
argument_list|)
expr_stmt|;
name|num_ports
operator|++
expr_stmt|;
block|}
comment|/* 	   We should be here if there aren't any ports in the group. 	 */
name|CL_ASSERT
argument_list|(
name|num_ports
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_ports
operator|!=
literal|0
condition|)
name|avg_hops
operator|=
call|(
name|float
call|)
argument_list|(
name|hops
operator|/
name|num_ports
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|avg_hops
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Calculate the maximal "min hops" from the given switch to any  of the group HCAs  **********************************************************************/
end_comment

begin_function
specifier|static
name|float
name|osm_mcast_mgr_compute_max_hops
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
specifier|const
name|osm_mgrp_t
modifier|*
specifier|const
name|p_mgrp
parameter_list|,
specifier|const
name|osm_switch_t
modifier|*
specifier|const
name|p_sw
parameter_list|)
block|{
name|uint32_t
name|max_hops
init|=
literal|0
decl_stmt|;
name|uint32_t
name|hops
init|=
literal|0
decl_stmt|;
specifier|const
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
specifier|const
name|osm_mcm_port_t
modifier|*
name|p_mcm_port
decl_stmt|;
specifier|const
name|cl_qmap_t
modifier|*
name|p_mcm_tbl
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_mcm_tbl
operator|=
operator|&
name|p_mgrp
operator|->
name|mcm_port_tbl
expr_stmt|;
comment|/* 	   For each member of the multicast group, compute the 	   number of hops to its base LID. 	 */
for|for
control|(
name|p_mcm_port
operator|=
operator|(
name|osm_mcm_port_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_mcm_tbl
argument_list|)
init|;
name|p_mcm_port
operator|!=
operator|(
name|osm_mcm_port_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_mcm_tbl
argument_list|)
condition|;
name|p_mcm_port
operator|=
operator|(
name|osm_mcm_port_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_mcm_port
operator|->
name|map_item
argument_list|)
control|)
block|{
comment|/* 		   Acquire the port object for this port guid, then create 		   the new worker object to build the list. 		 */
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|ib_gid_get_guid
argument_list|(
operator|&
name|p_mcm_port
operator|->
name|port_gid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A1A: "
literal|"No port object for port 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|ib_gid_get_guid
argument_list|(
operator|&
name|p_mcm_port
operator|->
name|port_gid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|hops
operator|=
name|osm_switch_get_port_least_hops
argument_list|(
name|p_sw
argument_list|,
name|p_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|hops
operator|>
name|max_hops
condition|)
name|max_hops
operator|=
name|hops
expr_stmt|;
block|}
if|if
condition|(
name|max_hops
operator|==
literal|0
condition|)
block|{
comment|/* 		   We should be here if there aren't any ports in the group. 		 */
name|max_hops
operator|=
literal|10001
expr_stmt|;
comment|/* see later - we use it to realize no hops */
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
call|(
name|float
call|)
argument_list|(
name|max_hops
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************    This function attempts to locate the optimal switch for the    center of the spanning tree.  The current algorithm chooses    a switch with the lowest average hop count to the members    of the multicast group. **********************************************************************/
end_comment

begin_function
specifier|static
name|osm_switch_t
modifier|*
name|__osm_mcast_mgr_find_optimal_switch
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
specifier|const
name|osm_mgrp_t
modifier|*
specifier|const
name|p_mgrp
parameter_list|)
block|{
name|cl_qmap_t
modifier|*
name|p_sw_tbl
decl_stmt|;
specifier|const
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|;
specifier|const
name|osm_switch_t
modifier|*
name|p_best_sw
init|=
name|NULL
decl_stmt|;
name|float
name|hops
init|=
literal|0
decl_stmt|;
name|float
name|best_hops
init|=
literal|10000
decl_stmt|;
comment|/* any big # will do */
ifdef|#
directive|ifdef
name|OSM_VENDOR_INTF_ANAFA
name|boolean_t
name|use_avg_hops
init|=
name|TRUE
decl_stmt|;
comment|/* anafa2 - bug hca on switch */
comment|/* use max hops for root */
else|#
directive|else
name|boolean_t
name|use_avg_hops
init|=
name|FALSE
decl_stmt|;
comment|/* use max hops for root */
endif|#
directive|endif
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_sw_tbl
operator|=
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
expr_stmt|;
name|CL_ASSERT
argument_list|(
operator|!
name|osm_mgrp_is_empty
argument_list|(
name|p_mgrp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_sw_tbl
argument_list|)
init|;
name|p_sw
operator|!=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_sw_tbl
argument_list|)
condition|;
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|osm_switch_supports_mcast
argument_list|(
name|p_sw
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|use_avg_hops
condition|)
name|hops
operator|=
name|osm_mcast_mgr_compute_avg_hops
argument_list|(
name|sm
argument_list|,
name|p_mgrp
argument_list|,
name|p_sw
argument_list|)
expr_stmt|;
else|else
name|hops
operator|=
name|osm_mcast_mgr_compute_max_hops
argument_list|(
name|sm
argument_list|,
name|p_mgrp
argument_list|,
name|p_sw
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Switch 0x%016"
name|PRIx64
literal|", hops = %f\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|hops
argument_list|)
expr_stmt|;
if|if
condition|(
name|hops
operator|<
name|best_hops
condition|)
block|{
name|p_best_sw
operator|=
name|p_sw
expr_stmt|;
name|best_hops
operator|=
name|hops
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p_best_sw
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Best switch is 0x%"
name|PRIx64
literal|", hops = %f\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_best_sw
operator|->
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|best_hops
argument_list|)
expr_stmt|;
else|else
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"No multicast capable switches detected\n"
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|osm_switch_t
operator|*
operator|)
name|p_best_sw
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************    This function returns the existing or optimal root swtich for the tree. **********************************************************************/
end_comment

begin_function
specifier|static
name|osm_switch_t
modifier|*
name|__osm_mcast_mgr_find_root_switch
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
specifier|const
name|osm_mgrp_t
modifier|*
specifier|const
name|p_mgrp
parameter_list|)
block|{
specifier|const
name|osm_switch_t
modifier|*
name|p_sw
init|=
name|NULL
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	   We always look for the best multicast tree root switch. 	   Otherwise since we always start with a a single join 	   the root will be always on the first switch attached to it. 	   - Very bad ... 	 */
name|p_sw
operator|=
name|__osm_mcast_mgr_find_optimal_switch
argument_list|(
name|sm
argument_list|,
name|p_mgrp
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|osm_switch_t
operator|*
operator|)
name|p_sw
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|osm_signal_t
name|__osm_mcast_mgr_set_tbl
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_switch_t
modifier|*
specifier|const
name|p_sw
parameter_list|)
block|{
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|osm_dr_path_t
modifier|*
name|p_path
decl_stmt|;
name|osm_madw_context_t
name|mad_context
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|uint32_t
name|block_id_ho
init|=
literal|0
decl_stmt|;
name|int16_t
name|block_num
init|=
literal|0
decl_stmt|;
name|uint32_t
name|position
init|=
literal|0
decl_stmt|;
name|uint32_t
name|max_position
decl_stmt|;
name|osm_mcast_tbl_t
modifier|*
name|p_tbl
decl_stmt|;
name|ib_net16_t
name|block
index|[
name|IB_MCAST_BLOCK_SIZE
index|]
decl_stmt|;
name|osm_signal_t
name|signal
init|=
name|OSM_SIGNAL_DONE
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
name|p_node
operator|=
name|p_sw
operator|->
name|p_node
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|p_path
operator|=
name|osm_physp_get_dr_path_ptr
argument_list|(
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	   Send multicast forwarding table blocks to the switch 	   as long as the switch indicates it has blocks needing 	   configuration. 	 */
name|mad_context
operator|.
name|mft_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|mad_context
operator|.
name|mft_context
operator|.
name|set_method
operator|=
name|TRUE
expr_stmt|;
name|p_tbl
operator|=
name|osm_switch_get_mcast_tbl_ptr
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
name|max_position
operator|=
name|p_tbl
operator|->
name|max_position
expr_stmt|;
while|while
condition|(
name|osm_mcast_tbl_get_block
argument_list|(
name|p_tbl
argument_list|,
name|block_num
argument_list|,
operator|(
name|uint8_t
operator|)
name|position
argument_list|,
name|block
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Writing MFT block 0x%X\n"
argument_list|,
name|block_id_ho
argument_list|)
expr_stmt|;
name|block_id_ho
operator|=
name|block_num
operator|+
operator|(
name|position
operator|<<
literal|28
operator|)
expr_stmt|;
name|status
operator|=
name|osm_req_set
argument_list|(
name|sm
argument_list|,
name|p_path
argument_list|,
operator|(
name|void
operator|*
operator|)
name|block
argument_list|,
sizeof|sizeof
argument_list|(
name|block
argument_list|)
argument_list|,
name|IB_MAD_ATTR_MCAST_FWD_TBL
argument_list|,
name|cl_hton32
argument_list|(
name|block_id_ho
argument_list|)
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|mad_context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A02: "
literal|"Sending multicast fwd. tbl. block failed (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|signal
operator|=
name|OSM_SIGNAL_DONE_PENDING
expr_stmt|;
if|if
condition|(
operator|++
name|position
operator|>
name|max_position
condition|)
block|{
name|position
operator|=
literal|0
expr_stmt|;
name|block_num
operator|++
expr_stmt|;
block|}
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|signal
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************   This is part of the recursive function to compute the paths in the   spanning tree that eminate from this switch.  On input, the p_list   contains the group members that must be routed from this switch. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_mcast_mgr_subdivide
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|osm_mgrp_t
modifier|*
specifier|const
name|p_mgrp
parameter_list|,
name|osm_switch_t
modifier|*
specifier|const
name|p_sw
parameter_list|,
name|cl_qlist_t
modifier|*
specifier|const
name|p_list
parameter_list|,
name|cl_qlist_t
modifier|*
specifier|const
name|list_array
parameter_list|,
name|uint8_t
specifier|const
name|array_size
parameter_list|)
block|{
name|uint8_t
name|port_num
decl_stmt|;
name|uint16_t
name|mlid_ho
decl_stmt|;
name|boolean_t
name|ignore_existing
decl_stmt|;
name|osm_mcast_work_obj_t
modifier|*
name|p_wobj
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|mlid_ho
operator|=
name|cl_ntoh16
argument_list|(
name|osm_mgrp_get_mlid
argument_list|(
name|p_mgrp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	   For Multicast Groups, we want not to count on previous 	   configurations - since we can easily generate a storm 	   by loops. 	 */
name|ignore_existing
operator|=
name|TRUE
expr_stmt|;
comment|/* 	   Subdivide the set of ports into non-overlapping subsets 	   that will be routed to other switches. 	 */
while|while
condition|(
operator|(
name|p_wobj
operator|=
operator|(
name|osm_mcast_work_obj_t
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
name|p_list
argument_list|)
operator|)
operator|!=
operator|(
name|osm_mcast_work_obj_t
operator|*
operator|)
name|cl_qlist_end
argument_list|(
name|p_list
argument_list|)
condition|)
block|{
name|port_num
operator|=
name|osm_switch_recommend_mcast_path
argument_list|(
name|p_sw
argument_list|,
name|p_wobj
operator|->
name|p_port
argument_list|,
name|mlid_ho
argument_list|,
name|ignore_existing
argument_list|)
expr_stmt|;
if|if
condition|(
name|port_num
operator|==
name|OSM_NO_PATH
condition|)
block|{
comment|/* 			   This typically occurs if the switch does not support 			   multicast and the multicast tree must branch at this 			   switch. 			 */
name|uint64_t
name|node_guid_ho
init|=
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|)
argument_list|)
decl_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A03: "
literal|"Error routing MLID 0x%X through switch 0x%"
name|PRIx64
literal|"\n"
literal|"\t\t\t\tNo multicast paths from this switch for port "
literal|"with LID %u\n"
argument_list|,
name|mlid_ho
argument_list|,
name|node_guid_ho
argument_list|,
name|cl_ntoh16
argument_list|(
name|osm_port_get_base_lid
argument_list|(
name|p_wobj
operator|->
name|p_port
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|__osm_mcast_work_obj_delete
argument_list|(
name|p_wobj
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|port_num
operator|>
name|array_size
condition|)
block|{
name|uint64_t
name|node_guid_ho
init|=
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|)
argument_list|)
decl_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A04: "
literal|"Error routing MLID 0x%X through switch 0x%"
name|PRIx64
literal|"\n"
literal|"\t\t\t\tNo multicast paths from this switch to port "
literal|"with LID %u\n"
argument_list|,
name|mlid_ho
argument_list|,
name|node_guid_ho
argument_list|,
name|cl_ntoh16
argument_list|(
name|osm_port_get_base_lid
argument_list|(
name|p_wobj
operator|->
name|p_port
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|__osm_mcast_work_obj_delete
argument_list|(
name|p_wobj
argument_list|)
expr_stmt|;
comment|/* This is means OpenSM has a bug. */
name|CL_ASSERT
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|cl_qlist_insert_tail
argument_list|(
operator|&
name|list_array
index|[
name|port_num
index|]
argument_list|,
operator|&
name|p_wobj
operator|->
name|list_item
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_mcast_mgr_purge_list
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|cl_qlist_t
modifier|*
specifier|const
name|p_list
parameter_list|)
block|{
name|osm_mcast_work_obj_t
modifier|*
name|p_wobj
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p_wobj
operator|=
operator|(
name|osm_mcast_work_obj_t
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
name|p_list
argument_list|)
operator|)
operator|!=
operator|(
name|osm_mcast_work_obj_t
operator|*
operator|)
name|cl_qlist_end
argument_list|(
name|p_list
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A06: "
literal|"Unable to route for port 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|osm_port_get_guid
argument_list|(
name|p_wobj
operator|->
name|p_port
argument_list|)
argument_list|)
expr_stmt|;
name|__osm_mcast_work_obj_delete
argument_list|(
name|p_wobj
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************   This is the recursive function to compute the paths in the spanning   tree that emanate from this switch.  On input, the p_list contains   the group members that must be routed from this switch.    The function returns the newly created mtree node element. **********************************************************************/
end_comment

begin_function
specifier|static
name|osm_mtree_node_t
modifier|*
name|__osm_mcast_mgr_branch
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|osm_mgrp_t
modifier|*
specifier|const
name|p_mgrp
parameter_list|,
name|osm_switch_t
modifier|*
specifier|const
name|p_sw
parameter_list|,
name|cl_qlist_t
modifier|*
specifier|const
name|p_list
parameter_list|,
name|uint8_t
name|depth
parameter_list|,
name|uint8_t
specifier|const
name|upstream_port
parameter_list|,
name|uint8_t
modifier|*
specifier|const
name|p_max_depth
parameter_list|)
block|{
name|uint8_t
name|max_children
decl_stmt|;
name|osm_mtree_node_t
modifier|*
name|p_mtn
init|=
name|NULL
decl_stmt|;
name|cl_qlist_t
modifier|*
name|list_array
init|=
name|NULL
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|ib_net64_t
name|node_guid
decl_stmt|;
name|uint64_t
name|node_guid_ho
decl_stmt|;
name|osm_mcast_work_obj_t
modifier|*
name|p_wobj
decl_stmt|;
name|cl_qlist_t
modifier|*
name|p_port_list
decl_stmt|;
name|size_t
name|count
decl_stmt|;
name|uint16_t
name|mlid_ho
decl_stmt|;
name|osm_mcast_tbl_t
modifier|*
name|p_tbl
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_list
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_max_depth
argument_list|)
expr_stmt|;
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|)
expr_stmt|;
name|node_guid_ho
operator|=
name|cl_ntoh64
argument_list|(
name|node_guid
argument_list|)
expr_stmt|;
name|mlid_ho
operator|=
name|cl_ntoh16
argument_list|(
name|osm_mgrp_get_mlid
argument_list|(
name|p_mgrp
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Routing MLID 0x%X through switch 0x%"
name|PRIx64
literal|", %u nodes at depth %u\n"
argument_list|,
name|mlid_ho
argument_list|,
name|node_guid_ho
argument_list|,
name|cl_qlist_count
argument_list|(
name|p_list
argument_list|)
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|cl_qlist_count
argument_list|(
name|p_list
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|depth
operator|++
expr_stmt|;
if|if
condition|(
name|depth
operator|>=
literal|64
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"Maximal hops number is reached for MLID 0x%x."
literal|" Break processing."
argument_list|,
name|mlid_ho
argument_list|)
expr_stmt|;
name|__osm_mcast_mgr_purge_list
argument_list|(
name|sm
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|depth
operator|>
operator|*
name|p_max_depth
condition|)
block|{
name|CL_ASSERT
argument_list|(
name|depth
operator|==
operator|*
name|p_max_depth
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|p_max_depth
operator|=
name|depth
expr_stmt|;
block|}
if|if
condition|(
name|osm_switch_supports_mcast
argument_list|(
name|p_sw
argument_list|)
operator|==
name|FALSE
condition|)
block|{
comment|/* 		   This switch doesn't do multicast.  Clean-up. 		 */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A14: "
literal|"Switch 0x%"
name|PRIx64
literal|" does not support multicast\n"
argument_list|,
name|node_guid_ho
argument_list|)
expr_stmt|;
comment|/* 		   Deallocate all the work objects on this branch of the tree. 		 */
name|__osm_mcast_mgr_purge_list
argument_list|(
name|sm
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_mtn
operator|=
name|osm_mtree_node_new
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_mtn
operator|==
name|NULL
condition|)
block|{
comment|/* 		   We are unable to continue routing down this 		   leg of the tree.  Clean-up. 		 */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A15: "
literal|"Insufficient memory to build multicast tree\n"
argument_list|)
expr_stmt|;
comment|/* 		   Deallocate all the work objects on this branch of the tree. 		 */
name|__osm_mcast_mgr_purge_list
argument_list|(
name|sm
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|max_children
operator|=
name|osm_mtree_node_get_max_children
argument_list|(
name|p_mtn
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|max_children
operator|>
literal|1
argument_list|)
expr_stmt|;
comment|/* 	   Prepare an empty list for each port in the switch. 	   TO DO - this list array could probably be moved 	   inside the switch element to save on malloc thrashing. 	 */
name|list_array
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cl_qlist_t
argument_list|)
operator|*
name|max_children
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_array
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A16: "
literal|"Unable to allocate list array\n"
argument_list|)
expr_stmt|;
name|__osm_mcast_mgr_purge_list
argument_list|(
name|sm
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|memset
argument_list|(
name|list_array
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cl_qlist_t
argument_list|)
operator|*
name|max_children
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_children
condition|;
name|i
operator|++
control|)
name|cl_qlist_init
argument_list|(
operator|&
name|list_array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|__osm_mcast_mgr_subdivide
argument_list|(
name|sm
argument_list|,
name|p_mgrp
argument_list|,
name|p_sw
argument_list|,
name|p_list
argument_list|,
name|list_array
argument_list|,
name|max_children
argument_list|)
expr_stmt|;
name|p_tbl
operator|=
name|osm_switch_get_mcast_tbl_ptr
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
comment|/* 	   Add the upstream port to the forwarding table unless 	   we're at the root of the spanning tree. 	 */
if|if
condition|(
name|depth
operator|>
literal|1
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Adding upstream port %u\n"
argument_list|,
name|upstream_port
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|upstream_port
argument_list|)
expr_stmt|;
name|osm_mcast_tbl_set
argument_list|(
name|p_tbl
argument_list|,
name|mlid_ho
argument_list|,
name|upstream_port
argument_list|)
expr_stmt|;
block|}
comment|/* 	   For each port that was allocated some routes, 	   recurse into this function to continue building the tree 	   if the node on the other end of that port is another switch. 	   Otherwise, the node is an endpoint, and we've found a leaf 	   of the tree.  Mark leaves with our special pointer value. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_children
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
specifier|const
name|osm_physp_t
modifier|*
name|p_remote_physp
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
specifier|const
name|osm_node_t
modifier|*
name|p_remote_node
decl_stmt|;
name|p_port_list
operator|=
operator|&
name|list_array
index|[
name|i
index|]
expr_stmt|;
name|count
operator|=
name|cl_qlist_count
argument_list|(
name|p_port_list
argument_list|)
expr_stmt|;
comment|/* 		   There should be no children routed through the upstream port! 		 */
name|CL_ASSERT
argument_list|(
operator|(
name|upstream_port
operator|==
literal|0
operator|)
operator|||
operator|(
name|i
operator|!=
name|upstream_port
operator|)
operator|||
operator|(
operator|(
name|i
operator|==
name|upstream_port
operator|)
operator|&&
operator|(
name|count
operator|==
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
continue|continue;
comment|/* No routes down this port. */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Routing %zu destinations via switch port %u\n"
argument_list|,
name|count
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 		   This port routes frames for this mcast group.  Therefore, 		   set the appropriate bit in the multicast forwarding 		   table for this switch. 		 */
name|osm_mcast_tbl_set
argument_list|(
name|p_tbl
argument_list|,
name|mlid_ho
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* This means we are adding the switch to the MC group. 			   We do not need to continue looking at the remote port, just 			   needed to add the port to the table */
name|CL_ASSERT
argument_list|(
name|count
operator|==
literal|1
argument_list|)
expr_stmt|;
name|p_wobj
operator|=
operator|(
name|osm_mcast_work_obj_t
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
name|p_port_list
argument_list|)
expr_stmt|;
name|__osm_mcast_work_obj_delete
argument_list|(
name|p_wobj
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|p_node
operator|=
name|p_sw
operator|->
name|p_node
expr_stmt|;
name|p_remote_node
operator|=
name|osm_node_get_remote_node
argument_list|(
name|p_node
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_remote_node
condition|)
continue|continue;
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|p_remote_node
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
condition|)
block|{
comment|/* 			   Acquire a pointer to the remote switch then recurse. 			 */
name|CL_ASSERT
argument_list|(
name|p_remote_node
operator|->
name|sw
argument_list|)
expr_stmt|;
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|p_remote_physp
operator|=
name|osm_physp_get_remote
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_remote_physp
argument_list|)
expr_stmt|;
name|p_mtn
operator|->
name|child_array
index|[
name|i
index|]
operator|=
name|__osm_mcast_mgr_branch
argument_list|(
name|sm
argument_list|,
name|p_mgrp
argument_list|,
name|p_remote_node
operator|->
name|sw
argument_list|,
name|p_port_list
argument_list|,
name|depth
argument_list|,
name|osm_physp_get_port_num
argument_list|(
name|p_remote_physp
argument_list|)
argument_list|,
name|p_max_depth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			   The neighbor node is not a switch, so this 			   must be a leaf. 			 */
name|CL_ASSERT
argument_list|(
name|count
operator|==
literal|1
argument_list|)
expr_stmt|;
name|p_mtn
operator|->
name|child_array
index|[
name|i
index|]
operator|=
name|OSM_MTREE_LEAF
expr_stmt|;
name|p_wobj
operator|=
operator|(
name|osm_mcast_work_obj_t
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
name|p_port_list
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|cl_is_qlist_empty
argument_list|(
name|p_port_list
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Found leaf for port 0x%016"
name|PRIx64
literal|" on switch port %u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_port_get_guid
argument_list|(
name|p_wobj
operator|->
name|p_port
argument_list|)
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|__osm_mcast_work_obj_delete
argument_list|(
name|p_wobj
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|list_array
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|p_mtn
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|__osm_mcast_mgr_build_spanning_tree
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|osm_mgrp_t
modifier|*
specifier|const
name|p_mgrp
parameter_list|)
block|{
specifier|const
name|cl_qmap_t
modifier|*
name|p_mcm_tbl
decl_stmt|;
specifier|const
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
specifier|const
name|osm_mcm_port_t
modifier|*
name|p_mcm_port
decl_stmt|;
name|uint32_t
name|num_ports
decl_stmt|;
name|cl_qlist_t
name|port_list
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|osm_mcast_work_obj_t
modifier|*
name|p_wobj
decl_stmt|;
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|uint8_t
name|max_depth
init|=
literal|0
decl_stmt|;
name|uint32_t
name|count
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|cl_qlist_init
argument_list|(
operator|&
name|port_list
argument_list|)
expr_stmt|;
comment|/* 	   TO DO - for now, just blow away the old tree. 	   In the future we'll need to construct the tree based 	   on multicast forwarding table information if the user wants to 	   preserve existing multicast routes. 	 */
name|__osm_mcast_mgr_purge_tree
argument_list|(
name|sm
argument_list|,
name|p_mgrp
argument_list|)
expr_stmt|;
name|p_mcm_tbl
operator|=
operator|&
name|p_mgrp
operator|->
name|mcm_port_tbl
expr_stmt|;
name|num_ports
operator|=
name|cl_qmap_count
argument_list|(
name|p_mcm_tbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_ports
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"MLID 0x%X has no members - nothing to do\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|osm_mgrp_get_mlid
argument_list|(
name|p_mgrp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	   This function builds the single spanning tree recursively. 	   At each stage, the ports to be reached are divided into 	   non-overlapping subsets of member ports that can be reached through 	   a given switch port.  Construction then moves down each 	   branch, and the process starts again with each branch computing 	   for its own subset of the member ports.  	   The maximum recursion depth is at worst the maximum hop count in the 	   subnet, which is spec limited to 64. 	 */
comment|/* 	   Locate the switch around which to create the spanning 	   tree for this multicast group. 	 */
name|p_sw
operator|=
name|__osm_mcast_mgr_find_root_switch
argument_list|(
name|sm
argument_list|,
name|p_mgrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A08: "
literal|"Unable to locate a suitable switch for group 0x%X\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|osm_mgrp_get_mlid
argument_list|(
name|p_mgrp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	   Build the first "subset" containing all member ports. 	 */
for|for
control|(
name|p_mcm_port
operator|=
operator|(
name|osm_mcm_port_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_mcm_tbl
argument_list|)
init|;
name|p_mcm_port
operator|!=
operator|(
name|osm_mcm_port_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_mcm_tbl
argument_list|)
condition|;
name|p_mcm_port
operator|=
operator|(
name|osm_mcm_port_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_mcm_port
operator|->
name|map_item
argument_list|)
control|)
block|{
comment|/* 		   Acquire the port object for this port guid, then create 		   the new worker object to build the list. 		 */
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|ib_gid_get_guid
argument_list|(
operator|&
name|p_mcm_port
operator|->
name|port_gid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A09: "
literal|"No port object for port 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|ib_gid_get_guid
argument_list|(
operator|&
name|p_mcm_port
operator|->
name|port_gid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|p_wobj
operator|=
name|__osm_mcast_work_obj_new
argument_list|(
name|p_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_wobj
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A10: "
literal|"Insufficient memory to route port 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_port_get_guid
argument_list|(
name|p_port
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|cl_qlist_insert_tail
argument_list|(
operator|&
name|port_list
argument_list|,
operator|&
name|p_wobj
operator|->
name|list_item
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
name|cl_qlist_count
argument_list|(
operator|&
name|port_list
argument_list|)
expr_stmt|;
name|p_mgrp
operator|->
name|p_root
operator|=
name|__osm_mcast_mgr_branch
argument_list|(
name|sm
argument_list|,
name|p_mgrp
argument_list|,
name|p_sw
argument_list|,
operator|&
name|port_list
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|max_depth
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Configured MLID 0x%X for %u ports, max tree depth = %u\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|osm_mgrp_get_mlid
argument_list|(
name|p_mgrp
argument_list|)
argument_list|)
argument_list|,
name|count
argument_list|,
name|max_depth
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* unused */
end_comment

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_comment
unit|void osm_mcast_mgr_set_table(osm_sm_t * sm, 			IN const osm_mgrp_t * const p_mgrp, 			IN const osm_mtree_node_t * const p_mtn) { 	uint8_t i; 	uint8_t max_children; 	osm_mtree_node_t *p_child_mtn; 	uint16_t mlid_ho; 	osm_mcast_tbl_t *p_tbl; 	osm_switch_t *p_sw;  	OSM_LOG_ENTER(sm->p_log);  	mlid_ho = cl_ntoh16(osm_mgrp_get_mlid(p_mgrp)); 	p_sw = osm_mtree_node_get_switch_ptr(p_mtn);  	CL_ASSERT(p_sw);  	OSM_LOG(sm->p_log, OSM_LOG_VERBOSE, 		"Configuring MLID 0x%X on switch 0x%" PRIx64 "\n", 		mlid_ho, osm_node_get_node_guid(p_sw->p_node));
comment|/* 	   For every child of this tree node, set the corresponding 	   bit in the switch's mcast table. 	 */
end_comment

begin_endif
unit|p_tbl = osm_switch_get_mcast_tbl_ptr(p_sw); 	max_children = osm_mtree_node_get_max_children(p_mtn);  	CL_ASSERT(max_children<= osm_switch_get_num_ports(p_sw));  	osm_mcast_tbl_clear_mlid(p_tbl, mlid_ho);  	for (i = 0; i< max_children; i++) { 		p_child_mtn = osm_mtree_node_get_child(p_mtn, i); 		if (p_child_mtn == NULL) 			continue;  		osm_mcast_tbl_set(p_tbl, mlid_ho, i); 	}  	OSM_LOG_EXIT(sm->p_log); }
endif|#
directive|endif
end_endif

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_mcast_mgr_clear
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_mgrp_t
modifier|*
specifier|const
name|p_mgrp
parameter_list|)
block|{
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|cl_qmap_t
modifier|*
name|p_sw_tbl
decl_stmt|;
name|osm_mcast_tbl_t
modifier|*
name|p_mcast_tbl
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	   Walk the switches and clear the routing entries for 	   this MLID. 	 */
name|p_sw_tbl
operator|=
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
expr_stmt|;
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_sw_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_sw
operator|!=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_sw_tbl
argument_list|)
condition|)
block|{
name|p_mcast_tbl
operator|=
name|osm_switch_get_mcast_tbl_ptr
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
name|osm_mcast_tbl_clear_mlid
argument_list|(
name|p_mcast_tbl
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_mgrp
operator|->
name|mlid
argument_list|)
argument_list|)
expr_stmt|;
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* TO DO - make this real -- at least update spanning tree */
end_comment

begin_comment
comment|/**********************************************************************    Lock must be held on entry. **********************************************************************/
end_comment

begin_comment
unit|ib_api_status_t osm_mcast_mgr_process_single(osm_sm_t * sm, 			     IN ib_net16_t const mlid, 			     IN ib_net64_t const port_guid, 			     IN uint8_t const join_state) { 	uint8_t port_num; 	uint16_t mlid_ho; 	ib_net64_t sw_guid; 	osm_port_t *p_port; 	osm_physp_t *p_physp; 	osm_physp_t *p_remote_physp; 	osm_node_t *p_remote_node; 	osm_mcast_tbl_t *p_mcast_tbl; 	ib_api_status_t status = IB_SUCCESS;  	OSM_LOG_ENTER(sm->p_log);  	CL_ASSERT(mlid); 	CL_ASSERT(port_guid);  	mlid_ho = cl_ntoh16(mlid);  	OSM_LOG(sm->p_log, OSM_LOG_DEBUG, 		"Attempting to add port 0x%" PRIx64 " to MLID 0x%X, " 		"\n\t\t\t\tjoin state = 0x%X\n", 		cl_ntoh64(port_guid), mlid_ho, join_state);
comment|/* 	   Acquire the Port object. 	 */
end_comment

begin_comment
unit|p_port = osm_get_port_by_guid(sm->p_subn, port_guid); 	if (!p_port) { 		OSM_LOG(sm->p_log, OSM_LOG_ERROR, "ERR 0A01: " 			"Unable to acquire port object for 0x%" PRIx64 "\n", 			cl_ntoh64(port_guid)); 		status = IB_ERROR; 		goto Exit; 	}  	p_physp = p_port->p_physp; 	if (p_physp == NULL) { 		OSM_LOG(sm->p_log, OSM_LOG_ERROR, "ERR 0A05: " 			"Unable to acquire phsyical port object for 0x%" PRIx64 			"\n", cl_ntoh64(port_guid)); 		status = IB_ERROR; 		goto Exit; 	}  	p_remote_physp = osm_physp_get_remote(p_physp); 	if (p_remote_physp == NULL) { 		OSM_LOG(sm->p_log, OSM_LOG_ERROR, "ERR 0A11: " 			"Unable to acquire remote phsyical port object " 			"for 0x%" PRIx64 "\n", cl_ntoh64(port_guid)); 		status = IB_ERROR; 		goto Exit; 	}  	p_remote_node = osm_physp_get_node_ptr(p_remote_physp);  	CL_ASSERT(p_remote_node);  	sw_guid = osm_node_get_node_guid(p_remote_node);  	if (osm_node_get_type(p_remote_node) != IB_NODE_TYPE_SWITCH) { 		OSM_LOG(sm->p_log, OSM_LOG_ERROR, "ERR 0A22: " 			"Remote node not a switch node 0x%" PRIx64 "\n", 			cl_ntoh64(sw_guid)); 		status = IB_ERROR; 		goto Exit; 	}  	if (!p_remote_node->sw) { 		OSM_LOG(sm->p_log, OSM_LOG_ERROR, "ERR 0A12: " 			"No switch object 0x%" PRIx64 "\n", cl_ntoh64(sw_guid)); 		status = IB_ERROR; 		goto Exit; 	}  	if (osm_switch_is_in_mcast_tree(p_remote_node->sw, mlid_ho)) {
comment|/* 		   We're in luck. The switch attached to this port 		   is already in the multicast group, so we can just 		   add the specified port as a new leaf of the tree. 		 */
end_comment

begin_comment
unit|if (join_state& (IB_JOIN_STATE_FULL | IB_JOIN_STATE_NON)) {
comment|/* 			   This node wants to receive multicast frames. 			   Get the switch port number to which the new member port 			   is attached, then configure this single mcast table. 			 */
end_comment

begin_endif
unit|port_num = osm_physp_get_port_num(p_remote_physp); 			CL_ASSERT(port_num);  			p_mcast_tbl = 			    osm_switch_get_mcast_tbl_ptr(p_remote_node->sw); 			osm_mcast_tbl_set(p_mcast_tbl, mlid_ho, port_num); 		} else { 			if (join_state& IB_JOIN_STATE_SEND_ONLY) 				OSM_LOG(sm->p_log, OSM_LOG_DEBUG, 					"Success.  Nothing to do for send" 					"only member\n"); 			else { 				OSM_LOG(sm->p_log, OSM_LOG_ERROR, "ERR 0A13: " 					"Unknown join state 0x%X\n", 					join_state); 				status = IB_ERROR; 				goto Exit; 			} 		} 	} else 		OSM_LOG(sm->p_log, OSM_LOG_DEBUG, "Unable to add port\n");  Exit: 	OSM_LOG_EXIT(sm->p_log); 	return (status); }
endif|#
directive|endif
end_endif

begin_comment
comment|/**********************************************************************    lock must already be held on entry **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|osm_mcast_mgr_process_tree
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_mgrp_t
modifier|*
specifier|const
name|p_mgrp
parameter_list|,
name|IN
name|osm_mcast_req_type_t
name|req_type
parameter_list|,
name|ib_net64_t
name|port_guid
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|ib_net16_t
name|mlid
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|mlid
operator|=
name|osm_mgrp_get_mlid
argument_list|(
name|p_mgrp
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Processing multicast group 0x%X\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|mlid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	   If there are no switches in the subnet, then we have nothing to do. 	 */
if|if
condition|(
name|cl_qmap_count
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"No switches in subnet. Nothing to do\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	   Clear the multicast tables to start clean, then build 	   the spanning tree which sets the mcast table bits for each 	   port in the group. 	 */
name|__osm_mcast_mgr_clear
argument_list|(
name|sm
argument_list|,
name|p_mgrp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_mgrp
operator|->
name|full_members
condition|)
goto|goto
name|Exit
goto|;
name|status
operator|=
name|__osm_mcast_mgr_build_spanning_tree
argument_list|(
name|sm
argument_list|,
name|p_mgrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A17: "
literal|"Unable to create spanning tree (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Process the entire group.  NOTE : The lock should be held externally!  **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|mcast_mgr_process_mgrp
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_mgrp_t
modifier|*
specifier|const
name|p_mgrp
parameter_list|,
name|IN
name|osm_mcast_req_type_t
name|req_type
parameter_list|,
name|IN
name|ib_net64_t
name|port_guid
parameter_list|)
block|{
name|ib_api_status_t
name|status
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_mcast_mgr_process_tree
argument_list|(
name|sm
argument_list|,
name|p_mgrp
argument_list|,
name|req_type
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0A19: "
literal|"Unable to create spanning tree (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_mgrp
operator|->
name|last_tree_id
operator|=
name|p_mgrp
operator|->
name|last_change_id
expr_stmt|;
comment|/* remove MCGRP if it is marked for deletion */
if|if
condition|(
name|p_mgrp
operator|->
name|to_be_deleted
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Destroying mgrp with lid:0x%x\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_mgrp
operator|->
name|mlid
argument_list|)
argument_list|)
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|mgroups
index|[
name|cl_ntoh16
argument_list|(
name|p_mgrp
operator|->
name|mlid
argument_list|)
operator|-
name|IB_LID_MCAST_START_HO
index|]
operator|=
name|NULL
expr_stmt|;
name|osm_mgrp_delete
argument_list|(
name|p_mgrp
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|osm_signal_t
name|osm_mcast_mgr_process
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|osm_signal_t
name|signal
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|cl_qmap_t
modifier|*
name|p_sw_tbl
decl_stmt|;
name|cl_qlist_t
modifier|*
name|p_list
init|=
operator|&
name|sm
operator|->
name|mgrp_list
decl_stmt|;
name|osm_mgrp_t
modifier|*
name|p_mgrp
decl_stmt|;
name|boolean_t
name|pending_transactions
init|=
name|FALSE
decl_stmt|;
name|int
name|i
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_sw_tbl
operator|=
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
expr_stmt|;
comment|/* 	   While holding the lock, iterate over all the established 	   multicast groups, servicing each in turn.  	   Then, download the multicast tables to the switches. 	 */
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|sm
operator|->
name|p_subn
operator|->
name|max_mcast_lid_ho
operator|-
name|IB_LID_MCAST_START_HO
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		   We reached here due to some change that caused a heavy sweep 		   of the subnet. Not due to a specific multicast request. 		   So the request type is subnet_change and the port guid is 0. 		 */
name|p_mgrp
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|mgroups
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p_mgrp
condition|)
name|mcast_mgr_process_mgrp
argument_list|(
name|sm
argument_list|,
name|p_mgrp
argument_list|,
name|OSM_MCAST_REQ_TYPE_SUBNET_CHANGE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	   Walk the switches and download the tables for each. 	 */
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_sw_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_sw
operator|!=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_sw_tbl
argument_list|)
condition|)
block|{
name|signal
operator|=
name|__osm_mcast_mgr_set_tbl
argument_list|(
name|sm
argument_list|,
name|p_sw
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
operator|==
name|OSM_SIGNAL_DONE_PENDING
condition|)
name|pending_transactions
operator|=
name|TRUE
expr_stmt|;
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|cl_is_qlist_empty
argument_list|(
name|p_list
argument_list|)
condition|)
block|{
name|cl_list_item_t
modifier|*
name|p
init|=
name|cl_qlist_remove_head
argument_list|(
name|p_list
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_transactions
operator|==
name|TRUE
condition|)
return|return
operator|(
name|OSM_SIGNAL_DONE_PENDING
operator|)
return|;
else|else
return|return
operator|(
name|OSM_SIGNAL_DONE
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************   This is the function that is invoked during idle time to handle the   process request for mcast groups where join/leave/delete was required.  **********************************************************************/
end_comment

begin_function
name|osm_signal_t
name|osm_mcast_mgr_process_mgroups
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|)
block|{
name|cl_qlist_t
modifier|*
name|p_list
init|=
operator|&
name|sm
operator|->
name|mgrp_list
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|cl_qmap_t
modifier|*
name|p_sw_tbl
decl_stmt|;
name|osm_mgrp_t
modifier|*
name|p_mgrp
decl_stmt|;
name|ib_net16_t
name|mlid
decl_stmt|;
name|osm_signal_t
name|ret
decl_stmt|,
name|signal
init|=
name|OSM_SIGNAL_DONE
decl_stmt|;
name|osm_mcast_mgr_ctxt_t
modifier|*
name|ctx
decl_stmt|;
name|osm_mcast_req_type_t
name|req_type
decl_stmt|;
name|ib_net64_t
name|port_guid
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* we need a lock to make sure the p_mgrp is not change other ways */
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|cl_is_qlist_empty
argument_list|(
name|p_list
argument_list|)
condition|)
block|{
name|ctx
operator|=
operator|(
name|osm_mcast_mgr_ctxt_t
operator|*
operator|)
name|cl_qlist_remove_head
argument_list|(
name|p_list
argument_list|)
expr_stmt|;
name|req_type
operator|=
name|ctx
operator|->
name|req_type
expr_stmt|;
name|port_guid
operator|=
name|ctx
operator|->
name|port_guid
expr_stmt|;
comment|/* nice copy no warning on size diff */
name|memcpy
argument_list|(
operator|&
name|mlid
argument_list|,
operator|&
name|ctx
operator|->
name|mlid
argument_list|,
sizeof|sizeof
argument_list|(
name|mlid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* we can destroy the context now */
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
comment|/* since we delayed the execution we prefer to pass the 		   mlid as the mgrp identifier and then find it or abort */
name|p_mgrp
operator|=
name|osm_get_mgrp_by_mlid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|mlid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_mgrp
condition|)
continue|continue;
comment|/* if there was no change from the last time 		 * we processed the group we can skip doing anything 		 */
if|if
condition|(
name|p_mgrp
operator|->
name|last_change_id
operator|==
name|p_mgrp
operator|->
name|last_tree_id
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Skip processing mgrp with lid:0x%X change id:%u\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|mlid
argument_list|)
argument_list|,
name|p_mgrp
operator|->
name|last_change_id
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Processing mgrp with lid:0x%X change id:%u\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|mlid
argument_list|)
argument_list|,
name|p_mgrp
operator|->
name|last_change_id
argument_list|)
expr_stmt|;
name|mcast_mgr_process_mgrp
argument_list|(
name|sm
argument_list|,
name|p_mgrp
argument_list|,
name|req_type
argument_list|,
name|port_guid
argument_list|)
expr_stmt|;
block|}
comment|/* 	   Walk the switches and download the tables for each. 	 */
name|p_sw_tbl
operator|=
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
expr_stmt|;
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_sw_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_sw
operator|!=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_sw_tbl
argument_list|)
condition|)
block|{
name|ret
operator|=
name|__osm_mcast_mgr_set_tbl
argument_list|(
name|sm
argument_list|,
name|p_sw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|OSM_SIGNAL_DONE_PENDING
condition|)
name|signal
operator|=
name|ret
expr_stmt|;
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
name|osm_dump_mcast_routes
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|p_osm
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|signal
return|;
block|}
end_function

end_unit

