begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2008 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2006 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_trap_rcv_t.  * This object represents the Trap Receiver object.  * This object is part of the opensm family of objects.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qmap.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_madw.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_node.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_subnet.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_inform.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_function_decl
specifier|extern
name|void
name|osm_req_get_node_desc
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|osm_physp_t
modifier|*
name|p_physp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**********************************************************************  *  * TRAP HANDLING:  *  * Assuming traps can be caused by bad hardware we should provide  * a mechanism for filtering their propagation into the actual logic  * of OpenSM such that it is not overloaded by them.  *  * We will provide a trap filtering mechanism with "Aging" capability.  * This mechanism will track incoming traps, clasify them by their  * source and content and provide back their age.  *  * A timer running in the background will toggle a timer counter  * that should be referenced by the aging algorithm.  * To provide an efficient handling of aging. We also track all traps  * in a sorted list by their aging.  *  * The generic Aging Tracker mechanism is implemented in the  * cl_aging_tracker object.  *  **********************************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
name|osm_trap_agingracker_context
block|{
name|osm_log_t
modifier|*
name|p_log
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
block|}
name|osm_trap_aging_tracker_context_t
typedef|;
end_typedef

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|osm_physp_t
modifier|*
name|get_physp_by_lid_and_num
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|uint16_t
name|lid
parameter_list|,
name|IN
name|uint8_t
name|num
parameter_list|)
block|{
name|cl_ptr_vector_t
modifier|*
name|p_vec
init|=
operator|&
operator|(
name|sm
operator|->
name|p_subn
operator|->
name|port_lid_tbl
operator|)
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
if|if
condition|(
name|lid
operator|>
name|cl_ptr_vector_get_size
argument_list|(
name|p_vec
argument_list|)
condition|)
return|return
name|NULL
return|;
name|p_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_ptr_vector_get
argument_list|(
name|p_vec
argument_list|,
name|lid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|osm_node_get_num_physp
argument_list|(
name|p_port
operator|->
name|p_node
argument_list|)
operator|<
name|num
condition|)
return|return
name|NULL
return|;
return|return
name|osm_node_get_physp_ptr
argument_list|(
name|p_port
operator|->
name|p_node
argument_list|,
name|num
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|uint64_t
name|osm_trap_rcv_aging_tracker_callback
parameter_list|(
name|IN
name|uint64_t
name|key
parameter_list|,
name|IN
name|uint32_t
name|num_regs
parameter_list|,
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
name|osm_sm_t
modifier|*
name|sm
init|=
name|context
decl_stmt|;
name|uint16_t
name|lid
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_exit_flag
condition|)
comment|/* We got an exit flag - do nothing */
return|return
literal|0
return|;
name|lid
operator|=
name|cl_ntoh16
argument_list|(
call|(
name|uint16_t
call|)
argument_list|(
operator|(
name|key
operator|&
literal|0x0000FFFF00000000ULL
operator|)
operator|>>
literal|32
argument_list|)
argument_list|)
expr_stmt|;
name|port_num
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|key
operator|&
literal|0x00FF000000000000ULL
operator|)
operator|>>
literal|48
argument_list|)
expr_stmt|;
name|p_physp
operator|=
name|get_physp_by_lid_and_num
argument_list|(
name|sm
argument_list|,
name|lid
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Cannot find port num:%u with lid:%u\n"
argument_list|,
name|port_num
argument_list|,
name|lid
argument_list|)
expr_stmt|;
comment|/* make sure the physp is still valid */
comment|/* If the health port was false - set it to true */
elseif|else
if|if
condition|(
operator|!
name|osm_physp_is_healthy
argument_list|(
name|p_physp
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Clearing health bit of port num:%u with lid:%u\n"
argument_list|,
name|port_num
argument_list|,
name|lid
argument_list|)
expr_stmt|;
comment|/* Clear its health bit */
name|osm_physp_set_health
argument_list|(
name|p_physp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* We want to remove the event from the tracker - so 	   need to return zero. */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * CRC calculation for notice identification  **********************************************************************/
end_comment

begin_define
define|#
directive|define
name|CRC32_POLYNOMIAL
value|0xEDB88320L
end_define

begin_comment
comment|/* calculate the crc for a given buffer */
end_comment

begin_function
specifier|static
name|uint32_t
name|__osm_trap_calc_crc32
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|uint32_t
name|count
parameter_list|)
block|{
name|uint32_t
name|temp1
decl_stmt|,
name|temp2
decl_stmt|;
name|uint32_t
name|crc
init|=
operator|-
literal|1L
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buffer
decl_stmt|;
comment|/* pre - calculated table for faster crc calculation */
specifier|static
name|uint32_t
name|crc_table
index|[
literal|256
index|]
decl_stmt|;
specifier|static
name|boolean_t
name|first
init|=
name|TRUE
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* if we need to initialize the lookup table */
if|if
condition|(
name|first
condition|)
block|{
comment|/* calc the CRC table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|255
condition|;
name|i
operator|++
control|)
block|{
name|crc
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|8
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|crc
operator|&
literal|1
condition|)
name|crc
operator|=
operator|(
name|crc
operator|>>
literal|1
operator|)
operator|^
name|CRC32_POLYNOMIAL
expr_stmt|;
else|else
name|crc
operator|>>=
literal|1
expr_stmt|;
name|crc_table
index|[
name|i
index|]
operator|=
name|crc
expr_stmt|;
block|}
name|first
operator|=
name|FALSE
expr_stmt|;
block|}
name|crc
operator|=
operator|-
literal|1L
expr_stmt|;
comment|/* do the calculation */
while|while
condition|(
name|count
operator|--
operator|!=
literal|0
condition|)
block|{
name|temp1
operator|=
operator|(
name|crc
operator|>>
literal|8
operator|)
operator|&
literal|0x00FFFFFFL
expr_stmt|;
name|temp2
operator|=
name|crc_table
index|[
operator|(
operator|(
name|int
operator|)
name|crc
operator|^
operator|*
name|p
operator|++
operator|)
operator|&
literal|0xFF
index|]
expr_stmt|;
name|crc
operator|=
name|temp1
operator|^
name|temp2
expr_stmt|;
block|}
return|return
name|crc
return|;
block|}
end_function

begin_comment
comment|/********************************************************************  ********************************************************************/
end_comment

begin_comment
comment|/* The key is created in the following manner:    port_num  lid   crc    \______/ \___/ \___/      16b     16b   32b */
end_comment

begin_function
specifier|static
name|void
name|__osm_trap_get_key
parameter_list|(
name|IN
name|uint16_t
name|lid
parameter_list|,
name|IN
name|uint8_t
name|port_num
parameter_list|,
name|IN
name|ib_mad_notice_attr_t
modifier|*
name|p_ntci
parameter_list|,
name|OUT
name|uint64_t
modifier|*
name|trap_key
parameter_list|)
block|{
name|uint32_t
name|crc
init|=
literal|0
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|trap_key
argument_list|)
expr_stmt|;
name|crc
operator|=
name|__osm_trap_calc_crc32
argument_list|(
name|p_ntci
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_mad_notice_attr_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|trap_key
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|port_num
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|lid
operator|<<
literal|32
operator|)
operator||
name|crc
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|__print_num_received
parameter_list|(
name|IN
name|uint32_t
name|num_received
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
comment|/* Series is 10, 20, 50, 100, 200, 500, ... */
name|i
operator|=
name|num_received
expr_stmt|;
while|while
condition|(
name|i
operator|>=
literal|10
condition|)
block|{
if|if
condition|(
name|i
operator|%
literal|10
condition|)
break|break;
name|i
operator|=
name|i
operator|/
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|1
operator|||
name|i
operator|==
literal|2
operator|||
name|i
operator|==
literal|5
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|disable_port
parameter_list|(
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|osm_physp_t
modifier|*
name|p
parameter_list|)
block|{
name|uint8_t
name|payload
index|[
name|IB_SMP_DATA_SIZE
index|]
decl_stmt|;
name|osm_madw_context_t
name|context
decl_stmt|;
name|ib_port_info_t
modifier|*
name|pi
init|=
operator|(
name|ib_port_info_t
operator|*
operator|)
name|payload
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* select the nearest port to master opensm */
if|if
condition|(
name|p
operator|->
name|p_remote_physp
operator|&&
name|p
operator|->
name|dr_path
operator|.
name|hop_count
operator|>
name|p
operator|->
name|p_remote_physp
operator|->
name|dr_path
operator|.
name|hop_count
condition|)
name|p
operator|=
name|p
operator|->
name|p_remote_physp
expr_stmt|;
comment|/* If trap 131, might want to disable peer port if available */
comment|/* but peer port has been observed not to respond to SM requests */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3810: "
literal|"Disabling physical port 0x%016"
name|PRIx64
literal|" num:%u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
name|p
operator|->
name|port_num
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|payload
argument_list|,
operator|&
name|p
operator|->
name|port_info
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_port_info_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set port to disabled/down */
name|ib_port_info_set_port_state
argument_list|(
name|pi
argument_list|,
name|IB_LINK_DOWN
argument_list|)
expr_stmt|;
name|ib_port_info_set_port_phys_state
argument_list|(
name|IB_PORT_PHYS_STATE_DISABLED
argument_list|,
name|pi
argument_list|)
expr_stmt|;
comment|/* Issue set of PortInfo */
name|context
operator|.
name|pi_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p
operator|->
name|p_node
argument_list|)
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|port_guid
operator|=
name|osm_physp_get_port_guid
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|set_method
operator|=
name|TRUE
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|light_sweep
operator|=
name|FALSE
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|active_transition
operator|=
name|FALSE
expr_stmt|;
name|ret
operator|=
name|osm_req_set
argument_list|(
name|sm
argument_list|,
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p
argument_list|)
argument_list|,
name|payload
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|,
name|IB_MAD_ATTR_PORT_INFO
argument_list|,
name|cl_hton32
argument_list|(
name|osm_physp_get_port_num
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3811: "
literal|"Request to set PortInfo failed\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_trap_rcv_process_request
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|)
block|{
name|uint8_t
name|payload
index|[
sizeof|sizeof
argument_list|(
name|ib_mad_notice_attr_t
argument_list|)
index|]
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|ib_mad_notice_attr_t
modifier|*
name|p_ntci
init|=
operator|(
name|ib_mad_notice_attr_t
operator|*
operator|)
name|payload
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|osm_madw_t
name|tmp_madw
decl_stmt|;
comment|/* we need a copy to last after repress */
name|uint64_t
name|trap_key
decl_stmt|;
name|uint32_t
name|num_received
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|cl_ptr_vector_t
modifier|*
name|p_tbl
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|ib_net16_t
name|source_lid
init|=
literal|0
decl_stmt|;
name|boolean_t
name|is_gsi
init|=
name|TRUE
decl_stmt|;
name|uint8_t
name|port_num
init|=
literal|0
decl_stmt|;
name|boolean_t
name|physp_change_trap
init|=
name|FALSE
decl_stmt|;
name|uint64_t
name|event_wheel_timeout
init|=
name|OSM_DEFAULT_TRAP_SUPRESSION_TIMEOUT
decl_stmt|;
name|boolean_t
name|run_heavy_sweep
init|=
name|FALSE
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_exit_flag
condition|)
comment|/* 		   We got an exit flag - do nothing 		   Otherwise we start a sweep on the trap 144 caused by 		   cleaning up SM Cap bit... 		 */
goto|goto
name|Exit
goto|;
comment|/* update the is_gsi flag according to the mgmt_class field */
if|if
condition|(
name|p_madw
operator|->
name|p_mad
operator|->
name|mgmt_class
operator|==
name|IB_MCLASS_SUBN_LID
operator|||
name|p_madw
operator|->
name|p_mad
operator|->
name|mgmt_class
operator|==
name|IB_MCLASS_SUBN_DIR
condition|)
name|is_gsi
operator|=
name|FALSE
expr_stmt|;
comment|/* No real need to grab the lock for this function. */
name|memset
argument_list|(
name|payload
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|payload
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|tmp_madw
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp_madw
argument_list|)
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_smp
operator|->
name|method
operator|!=
name|IB_MAD_METHOD_TRAP
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3801: "
literal|"Unsupported method 0x%X\n"
argument_list|,
name|p_smp
operator|->
name|method
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	 * The NOTICE Attribute is part of the SMP CLASS attributes 	 * As such the actual attribute data resides inside the SMP 	 * payload. 	 */
name|memcpy
argument_list|(
name|payload
argument_list|,
operator|&
operator|(
name|p_smp
operator|->
name|data
operator|)
argument_list|,
name|IB_SMP_DATA_SIZE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|tmp_madw
argument_list|,
name|p_madw
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp_madw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_gsi
operator|==
name|FALSE
condition|)
block|{
comment|/* We are in smi flow */
comment|/* 		 * When we received a TRAP with dlid = 0 - it means it 		 * came from our own node. So we need to fix it. 		 */
if|if
condition|(
name|p_madw
operator|->
name|mad_addr
operator|.
name|addr_type
operator|.
name|smi
operator|.
name|source_lid
operator|==
literal|0
condition|)
block|{
comment|/* Check if the sm_base_lid is 0. If yes - this means 			   that the local lid wasn't configured yet. Don't send 			   a response to the trap. */
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_base_lid
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Received SLID=0 Trap with local LID=0. Ignoring MAD\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Received SLID=0 Trap. Using local LID:%u instead\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_base_lid
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_madw
operator|.
name|mad_addr
operator|.
name|addr_type
operator|.
name|smi
operator|.
name|source_lid
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|sm_base_lid
expr_stmt|;
block|}
name|source_lid
operator|=
name|tmp_madw
operator|.
name|mad_addr
operator|.
name|addr_type
operator|.
name|smi
operator|.
name|source_lid
expr_stmt|;
comment|/* Print some info about the incoming Trap */
if|if
condition|(
name|ib_notice_is_generic
argument_list|(
name|p_ntci
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
operator|==
name|CL_HTON16
argument_list|(
literal|129
argument_list|)
operator|)
operator|||
operator|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
operator|==
name|CL_HTON16
argument_list|(
literal|130
argument_list|)
operator|)
operator|||
operator|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
operator|==
name|CL_HTON16
argument_list|(
literal|131
argument_list|)
operator|)
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"Received Generic Notice type:%u "
literal|"num:%u (%s) Producer:%u (%s) "
literal|"from LID:%u Port %d TID:0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|ib_notice_get_type
argument_list|(
name|p_ntci
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
argument_list|)
argument_list|,
name|ib_get_trap_str
argument_list|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
argument_list|)
argument_list|,
name|cl_ntoh32
argument_list|(
name|ib_notice_get_prod_type
argument_list|(
name|p_ntci
argument_list|)
argument_list|)
argument_list|,
name|ib_get_producer_type_str
argument_list|(
name|ib_notice_get_prod_type
argument_list|(
name|p_ntci
argument_list|)
argument_list|)
argument_list|,
name|cl_hton16
argument_list|(
name|source_lid
argument_list|)
argument_list|,
name|p_ntci
operator|->
name|data_details
operator|.
name|ntc_129_131
operator|.
name|port_num
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_smp
operator|->
name|trans_id
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"Received Generic Notice type:%u "
literal|"num:%u (%s) Producer:%u (%s) "
literal|"from LID:%u TID:0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|ib_notice_get_type
argument_list|(
name|p_ntci
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
argument_list|)
argument_list|,
name|ib_get_trap_str
argument_list|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
argument_list|)
argument_list|,
name|cl_ntoh32
argument_list|(
name|ib_notice_get_prod_type
argument_list|(
name|p_ntci
argument_list|)
argument_list|)
argument_list|,
name|ib_get_producer_type_str
argument_list|(
name|ib_notice_get_prod_type
argument_list|(
name|p_ntci
argument_list|)
argument_list|)
argument_list|,
name|cl_hton16
argument_list|(
name|source_lid
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_smp
operator|->
name|trans_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"Received Vendor Notice type:%u vend:0x%06X "
literal|"dev:%u from LID:%u TID:0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|ib_notice_get_type
argument_list|(
name|p_ntci
argument_list|)
argument_list|,
name|cl_ntoh32
argument_list|(
name|ib_notice_get_vend_id
argument_list|(
name|p_ntci
argument_list|)
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|vend
operator|.
name|dev_id
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|source_lid
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_smp
operator|->
name|trans_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|osm_dump_notice
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|p_ntci
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|)
expr_stmt|;
name|p_physp
operator|=
name|osm_get_physp_by_mad_addr
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|sm
operator|->
name|p_subn
argument_list|,
operator|&
name|tmp_madw
operator|.
name|mad_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_physp
condition|)
name|p_smp
operator|->
name|m_key
operator|=
name|p_physp
operator|->
name|port_info
operator|.
name|m_key
expr_stmt|;
else|else
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3809: "
literal|"Failed to find source physical port for trap\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_resp_send
argument_list|(
name|sm
argument_list|,
operator|&
name|tmp_madw
argument_list|,
literal|0
argument_list|,
name|payload
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3802: "
literal|"Error sending response (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	 * We would like to filter out recurring Traps so we track them by 	 * their source lid and content. If the same trap was already 	 * received within the aging time window more than 10 times, 	 * we simply ignore it. This is done only if we are in smi mode 	 */
if|if
condition|(
name|is_gsi
operator|==
name|FALSE
condition|)
block|{
if|if
condition|(
name|ib_notice_is_generic
argument_list|(
name|p_ntci
argument_list|)
operator|&&
operator|(
operator|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
operator|==
name|CL_HTON16
argument_list|(
literal|129
argument_list|)
operator|)
operator|||
operator|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
operator|==
name|CL_HTON16
argument_list|(
literal|130
argument_list|)
operator|)
operator|||
operator|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
operator|==
name|CL_HTON16
argument_list|(
literal|131
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* If this is a trap 129, 130, or 131 - then this is a 			 * trap signaling a change on a physical port. 			 * Mark the physp_change_trap flag as TRUE. 			 */
name|physp_change_trap
operator|=
name|TRUE
expr_stmt|;
comment|/* The source_lid should be based on the source_lid from the trap */
name|source_lid
operator|=
name|p_ntci
operator|->
name|data_details
operator|.
name|ntc_129_131
operator|.
name|lid
expr_stmt|;
block|}
comment|/* If physp_change_trap is TRUE - the key will include the port number. 		   If not - the port_number in the key will be zero. */
if|if
condition|(
name|physp_change_trap
operator|==
name|TRUE
condition|)
block|{
name|port_num
operator|=
name|p_ntci
operator|->
name|data_details
operator|.
name|ntc_129_131
operator|.
name|port_num
expr_stmt|;
name|__osm_trap_get_key
argument_list|(
name|source_lid
argument_list|,
name|port_num
argument_list|,
name|p_ntci
argument_list|,
operator|&
name|trap_key
argument_list|)
expr_stmt|;
block|}
else|else
name|__osm_trap_get_key
argument_list|(
name|source_lid
argument_list|,
literal|0
argument_list|,
name|p_ntci
argument_list|,
operator|&
name|trap_key
argument_list|)
expr_stmt|;
comment|/* try to find it in the aging tracker */
name|num_received
operator|=
name|cl_event_wheel_num_regs
argument_list|(
operator|&
name|sm
operator|->
name|trap_aging_tracker
argument_list|,
name|trap_key
argument_list|)
expr_stmt|;
comment|/* Now we know how many times it provided this trap */
if|if
condition|(
name|num_received
operator|>
literal|10
condition|)
block|{
if|if
condition|(
name|__print_num_received
argument_list|(
name|num_received
argument_list|)
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3804: "
literal|"Received trap %u times consecutively\n"
argument_list|,
name|num_received
argument_list|)
expr_stmt|;
comment|/* 			 * If the trap provides info about a bad port 			 * we mark it as unhealthy. 			 */
if|if
condition|(
name|physp_change_trap
operator|==
name|TRUE
condition|)
block|{
comment|/* get the port */
name|p_physp
operator|=
name|get_physp_by_lid_and_num
argument_list|(
name|sm
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_ntci
operator|->
name|data_details
operator|.
name|ntc_129_131
operator|.
name|lid
argument_list|)
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3805: "
literal|"Failed to find physical port by lid:%u num:%u\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_ntci
operator|->
name|data_details
operator|.
name|ntc_129_131
operator|.
name|lid
argument_list|)
argument_list|,
name|p_ntci
operator|->
name|data_details
operator|.
name|ntc_129_131
operator|.
name|port_num
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* When babbling port policy option is enabled and 					   Threshold for disabling a "babbling" port is exceeded */
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|babbling_port_policy
operator|&&
name|num_received
operator|>=
literal|250
operator|&&
name|disable_port
argument_list|(
name|sm
argument_list|,
name|p_physp
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|Exit
goto|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Marking unhealthy physical port by lid:%u num:%u\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_ntci
operator|->
name|data_details
operator|.
name|ntc_129_131
operator|.
name|lid
argument_list|)
argument_list|,
name|p_ntci
operator|->
name|data_details
operator|.
name|ntc_129_131
operator|.
name|port_num
argument_list|)
expr_stmt|;
comment|/* check if the current state of the p_physp is healthy. If 					   it is - then this is a first change of state. Run a heavy sweep. 					   if it is not - no need to mark it again - just restart the timer. */
if|if
condition|(
name|osm_physp_is_healthy
argument_list|(
name|p_physp
argument_list|)
condition|)
block|{
name|osm_physp_set_health
argument_list|(
name|p_physp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Make sure we sweep again - force a heavy sweep. */
comment|/* The sweep should be done only after the re-registration, or 						   else we'll be losing track of the timer. */
name|run_heavy_sweep
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If we are marking the port as unhealthy - we want to 					   keep this for a longer period of time than the 					   OSM_DEFAULT_TRAP_SUPRESSION_TIMEOUT. Use the 					   OSM_DEFAULT_UNHEALTHY_TIMEOUT */
name|event_wheel_timeout
operator|=
name|OSM_DEFAULT_UNHEALTHY_TIMEOUT
expr_stmt|;
block|}
block|}
block|}
comment|/* restart the aging anyway */
comment|/* If physp_change_trap is TRUE - then use a callback to unset the 		   healthy bit. If not - no need to use a callback. */
if|if
condition|(
name|physp_change_trap
operator|==
name|TRUE
condition|)
name|cl_event_wheel_reg
argument_list|(
operator|&
name|sm
operator|->
name|trap_aging_tracker
argument_list|,
name|trap_key
argument_list|,
name|cl_get_time_stamp
argument_list|()
operator|+
name|event_wheel_timeout
argument_list|,
name|osm_trap_rcv_aging_tracker_callback
argument_list|,
comment|/* no callback */
name|sm
comment|/* no context */
argument_list|)
expr_stmt|;
else|else
name|cl_event_wheel_reg
argument_list|(
operator|&
name|sm
operator|->
name|trap_aging_tracker
argument_list|,
name|trap_key
argument_list|,
name|cl_get_time_stamp
argument_list|()
operator|+
name|event_wheel_timeout
argument_list|,
name|NULL
argument_list|,
comment|/* no callback */
name|NULL
comment|/* no context */
argument_list|)
expr_stmt|;
comment|/* If was already registered do nothing more */
if|if
condition|(
name|num_received
operator|>
literal|10
operator|&&
name|run_heavy_sweep
operator|==
name|FALSE
condition|)
block|{
if|if
condition|(
name|__print_num_received
argument_list|(
name|num_received
argument_list|)
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Continuously received this trap %u times. Ignoring\n"
argument_list|,
name|num_received
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/* Check for node description update. IB Spec v1.2.1 pg 823 */
if|if
condition|(
operator|(
name|p_ntci
operator|->
name|data_details
operator|.
name|ntc_144
operator|.
name|local_changes
operator|&
name|TRAP_144_MASK_OTHER_LOCAL_CHANGES
operator|)
operator|&&
operator|(
name|p_ntci
operator|->
name|data_details
operator|.
name|ntc_144
operator|.
name|change_flgs
operator|&
name|TRAP_144_MASK_NODE_DESCRIPTION_CHANGE
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"Trap 144 Node description update\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_physp
condition|)
block|{
name|CL_PLOCK_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|osm_req_get_node_desc
argument_list|(
name|sm
argument_list|,
name|p_physp
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3812: No physical port found for "
literal|"trap 144: \"node description update\"\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* do a sweep if we received a trap */
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|sweep_on_trap
condition|)
block|{
comment|/* if this is trap number 128 or run_heavy_sweep is TRUE - update the 		   force_single_heavy_sweep flag of the subnet. 		   Sweep also on traps 144/145 - these traps signal a change of a certain 		   port capability/system image guid. 		   TODO: In the future we can change this to just getting PortInfo on 		   this port instead of sweeping the entire subnet. */
if|if
condition|(
name|ib_notice_is_generic
argument_list|(
name|p_ntci
argument_list|)
operator|&&
operator|(
operator|(
name|cl_ntoh16
argument_list|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
argument_list|)
operator|==
literal|128
operator|)
operator|||
operator|(
name|cl_ntoh16
argument_list|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
argument_list|)
operator|==
literal|144
operator|)
operator|||
operator|(
name|cl_ntoh16
argument_list|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
argument_list|)
operator|==
literal|145
operator|)
operator|||
name|run_heavy_sweep
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Forcing heavy sweep. Received trap:%u\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_ntci
operator|->
name|g_or_v
operator|.
name|generic
operator|.
name|trap_num
argument_list|)
argument_list|)
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|force_heavy_sweep
operator|=
name|TRUE
expr_stmt|;
block|}
name|osm_sm_signal
argument_list|(
name|sm
argument_list|,
name|OSM_SIGNAL_SWEEP
argument_list|)
expr_stmt|;
block|}
comment|/* If we reached here due to trap 129/130/131 - do not need to do 	   the notice report. Just goto exit. We know this is the case 	   if physp_change_trap is TRUE. */
if|if
condition|(
name|physp_change_trap
operator|==
name|TRUE
condition|)
goto|goto
name|Exit
goto|;
comment|/* Add a call to osm_report_notice */
comment|/* We are going to report the notice - so need to fix the IssuerGID 	   accordingly. See IBA 1.2 p.739 or IBA 1.1 p.653 for details. */
if|if
condition|(
name|is_gsi
condition|)
block|{
if|if
condition|(
operator|!
name|tmp_madw
operator|.
name|mad_addr
operator|.
name|addr_type
operator|.
name|gsi
operator|.
name|global_route
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3806: "
literal|"Received gsi trap with global_route FALSE. "
literal|"Cannot update issuer_gid!\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|memcpy
argument_list|(
operator|&
operator|(
name|p_ntci
operator|->
name|issuer_gid
operator|)
argument_list|,
operator|&
operator|(
name|tmp_madw
operator|.
name|mad_addr
operator|.
name|addr_type
operator|.
name|gsi
operator|.
name|grh_info
operator|.
name|src_gid
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_gid_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Need to use the IssuerLID */
name|p_tbl
operator|=
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|port_lid_tbl
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|cl_ptr_vector_get_size
argument_list|(
name|p_tbl
argument_list|)
operator|<
literal|0x10000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uint16_t
operator|)
name|cl_ptr_vector_get_size
argument_list|(
name|p_tbl
argument_list|)
operator|<=
name|cl_ntoh16
argument_list|(
name|source_lid
argument_list|)
condition|)
block|{
comment|/*  the source lid is out of range */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"source lid is out of range:%u\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|source_lid
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_port
operator|=
name|cl_ptr_vector_get
argument_list|(
name|p_tbl
argument_list|,
name|cl_ntoh16
argument_list|(
name|source_lid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_port
operator|==
literal|0
condition|)
block|{
comment|/* We have the lid - but no corresponding port */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Cannot find port corresponding to lid:%u\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|source_lid
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_ntci
operator|->
name|issuer_gid
operator|.
name|unicast
operator|.
name|prefix
operator|=
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|subnet_prefix
expr_stmt|;
name|p_ntci
operator|->
name|issuer_gid
operator|.
name|unicast
operator|.
name|interface_id
operator|=
name|p_port
operator|->
name|guid
expr_stmt|;
block|}
comment|/* we need a lock here as the InformInfo DB must be stable */
name|CL_PLOCK_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_report_notice
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|sm
operator|->
name|p_subn
argument_list|,
name|p_ntci
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3803: "
literal|"Error sending trap reports (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/**********************************************************************  CURRENTLY WE ARE NOT CREATING TRAPS - SO THIS CALL IS AN ERROR **********************************************************************/
end_comment

begin_comment
unit|static void __osm_trap_rcv_process_sm(IN osm_sm_t * sm, 			  IN const osm_remote_sm_t * const p_sm) {
comment|/* const ib_sm_info_t*        p_smi; */
end_comment

begin_endif
unit|OSM_LOG_ENTER(sm->p_log);  	OSM_LOG(sm->p_log, OSM_LOG_ERROR, "ERR 3807: " 		"This function is not supported yet\n");  	OSM_LOG_EXIT(sm->p_log); }
endif|#
directive|endif
end_endif

begin_comment
comment|/**********************************************************************  CURRENTLY WE ARE NOT CREATING TRAPS - SO THIS CALL IN AN ERROR **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_trap_rcv_process_response
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|)
block|{
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3808: "
literal|"This function is not supported yet\n"
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|void
name|osm_trap_rcv_process
parameter_list|(
name|IN
name|void
modifier|*
name|context
parameter_list|,
name|IN
name|void
modifier|*
name|data
parameter_list|)
block|{
name|osm_sm_t
modifier|*
name|sm
init|=
name|context
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_madw
init|=
name|data
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
comment|/* 	   Determine if this is a request for our own Trap 	   or if this is a response to our request for another 	   SM's Trap. 	 */
if|if
condition|(
name|ib_smp_is_response
argument_list|(
name|p_smp
argument_list|)
condition|)
name|__osm_trap_rcv_process_response
argument_list|(
name|sm
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
else|else
name|__osm_trap_rcv_process_request
argument_list|(
name|sm
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

