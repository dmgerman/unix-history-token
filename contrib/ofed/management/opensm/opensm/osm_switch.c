begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2008 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2008 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_switch_t.  * This object represents an Infiniband switch.  * This object is part of the opensm family of objects.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_math.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_switch.h>
end_include

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|cl_status_t
name|osm_switch_set_hops
parameter_list|(
name|IN
name|osm_switch_t
modifier|*
specifier|const
name|p_sw
parameter_list|,
name|IN
specifier|const
name|uint16_t
name|lid_ho
parameter_list|,
name|IN
specifier|const
name|uint8_t
name|port_num
parameter_list|,
name|IN
specifier|const
name|uint8_t
name|num_hops
parameter_list|)
block|{
if|if
condition|(
name|lid_ho
operator|>
name|p_sw
operator|->
name|max_lid_ho
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|p_sw
operator|->
name|hops
index|[
name|lid_ho
index|]
condition|)
block|{
name|p_sw
operator|->
name|hops
index|[
name|lid_ho
index|]
operator|=
name|malloc
argument_list|(
name|p_sw
operator|->
name|num_ports
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_sw
operator|->
name|hops
index|[
name|lid_ho
index|]
condition|)
return|return
operator|-
literal|1
return|;
name|memset
argument_list|(
name|p_sw
operator|->
name|hops
index|[
name|lid_ho
index|]
argument_list|,
name|OSM_NO_PATH
argument_list|,
name|p_sw
operator|->
name|num_ports
argument_list|)
expr_stmt|;
block|}
name|p_sw
operator|->
name|hops
index|[
name|lid_ho
index|]
index|[
name|port_num
index|]
operator|=
name|num_hops
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|hops
index|[
name|lid_ho
index|]
index|[
literal|0
index|]
operator|>
name|num_hops
condition|)
name|p_sw
operator|->
name|hops
index|[
name|lid_ho
index|]
index|[
literal|0
index|]
operator|=
name|num_hops
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|osm_switch_init
parameter_list|(
name|IN
name|osm_switch_t
modifier|*
specifier|const
name|p_sw
parameter_list|,
name|IN
name|osm_node_t
modifier|*
specifier|const
name|p_node
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|ib_switch_info_t
modifier|*
name|p_si
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|uint8_t
name|num_ports
decl_stmt|;
name|uint32_t
name|port_num
decl_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_si
operator|=
operator|(
name|ib_switch_info_t
operator|*
operator|)
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
name|num_ports
operator|=
name|osm_node_get_num_physp
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_smp
operator|->
name|attr_id
operator|==
name|IB_MAD_ATTR_SWITCH_INFO
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|p_node
operator|=
name|p_node
expr_stmt|;
name|p_sw
operator|->
name|switch_info
operator|=
operator|*
name|p_si
expr_stmt|;
name|p_sw
operator|->
name|num_ports
operator|=
name|num_ports
expr_stmt|;
name|p_sw
operator|->
name|need_update
operator|=
literal|2
expr_stmt|;
comment|/* Initiate the linear forwarding table */
if|if
condition|(
operator|!
name|p_si
operator|->
name|lin_cap
condition|)
block|{
comment|/* This switch does not support linear forwarding tables */
name|status
operator|=
name|IB_UNSUPPORTED
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_sw
operator|->
name|lft
operator|=
name|malloc
argument_list|(
name|IB_LID_UCAST_END_HO
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_sw
operator|->
name|lft
condition|)
block|{
name|status
operator|=
name|IB_INSUFFICIENT_MEMORY
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Initialize the table to OSM_NO_PATH, which is "invalid port" */
name|memset
argument_list|(
name|p_sw
operator|->
name|lft
argument_list|,
name|OSM_NO_PATH
argument_list|,
name|IB_LID_UCAST_END_HO
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|p_prof
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p_sw
operator|->
name|p_prof
argument_list|)
operator|*
name|num_ports
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|p_prof
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|IB_INSUFFICIENT_MEMORY
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|memset
argument_list|(
name|p_sw
operator|->
name|p_prof
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_sw
operator|->
name|p_prof
argument_list|)
operator|*
name|num_ports
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_mcast_tbl_init
argument_list|(
operator|&
name|p_sw
operator|->
name|mcast_tbl
argument_list|,
name|osm_node_get_num_physp
argument_list|(
name|p_node
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_si
operator|->
name|mcast_cap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
for|for
control|(
name|port_num
operator|=
literal|0
init|;
name|port_num
operator|<
name|num_ports
condition|;
name|port_num
operator|++
control|)
name|osm_port_prof_construct
argument_list|(
operator|&
name|p_sw
operator|->
name|p_prof
index|[
name|port_num
index|]
argument_list|)
expr_stmt|;
name|Exit
label|:
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|void
name|osm_switch_delete
parameter_list|(
name|IN
name|OUT
name|osm_switch_t
modifier|*
modifier|*
specifier|const
name|pp_sw
parameter_list|)
block|{
name|osm_switch_t
modifier|*
name|p_sw
init|=
operator|*
name|pp_sw
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|osm_mcast_tbl_destroy
argument_list|(
operator|&
name|p_sw
operator|->
name|mcast_tbl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_sw
operator|->
name|p_prof
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|lft
condition|)
name|free
argument_list|(
name|p_sw
operator|->
name|lft
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|new_lft
condition|)
name|free
argument_list|(
name|p_sw
operator|->
name|new_lft
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|hops
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|num_hops
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p_sw
operator|->
name|hops
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|p_sw
operator|->
name|hops
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_sw
operator|->
name|hops
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|*
name|pp_sw
argument_list|)
expr_stmt|;
operator|*
name|pp_sw
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|osm_switch_t
modifier|*
name|osm_switch_new
parameter_list|(
name|IN
name|osm_node_t
modifier|*
specifier|const
name|p_node
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|)
block|{
name|ib_api_status_t
name|status
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_sw
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|p_sw
operator|=
operator|(
name|osm_switch_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p_sw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
condition|)
block|{
name|memset
argument_list|(
name|p_sw
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_sw
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_switch_init
argument_list|(
name|p_sw
argument_list|,
name|p_node
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|osm_switch_delete
argument_list|(
operator|&
name|p_sw
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p_sw
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|boolean_t
name|osm_switch_get_lft_block
parameter_list|(
name|IN
specifier|const
name|osm_switch_t
modifier|*
specifier|const
name|p_sw
parameter_list|,
name|IN
specifier|const
name|uint16_t
name|block_id
parameter_list|,
name|OUT
name|uint8_t
modifier|*
specifier|const
name|p_block
parameter_list|)
block|{
name|uint16_t
name|base_lid_ho
init|=
name|block_id
operator|*
name|IB_SMP_DATA_SIZE
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_lid_ho
operator|>
name|p_sw
operator|->
name|max_lid_ho
condition|)
return|return
name|FALSE
return|;
name|CL_ASSERT
argument_list|(
name|base_lid_ho
operator|+
name|IB_SMP_DATA_SIZE
operator|<=
name|IB_LID_UCAST_END_HO
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p_block
argument_list|,
operator|&
operator|(
name|p_sw
operator|->
name|lft
index|[
name|base_lid_ho
index|]
operator|)
argument_list|,
name|IB_SMP_DATA_SIZE
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|struct
name|osm_remote_node
modifier|*
name|osm_switch_find_guid_common
parameter_list|(
name|IN
specifier|const
name|osm_switch_t
modifier|*
specifier|const
name|p_sw
parameter_list|,
name|IN
name|struct
name|osm_remote_guids_count
modifier|*
name|r
parameter_list|,
name|IN
name|uint8_t
name|port_num
parameter_list|,
name|IN
name|int
name|find_sys_guid
parameter_list|,
name|IN
name|int
name|find_node_guid
parameter_list|)
block|{
name|struct
name|osm_remote_node
modifier|*
name|p_remote_guid
init|=
name|NULL
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_rem_physp
decl_stmt|;
name|osm_node_t
modifier|*
name|p_rem_node
decl_stmt|;
name|uint64_t
name|sys_guid
decl_stmt|;
name|uint64_t
name|node_guid
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|p_rem_physp
operator|=
name|osm_physp_get_remote
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|p_rem_node
operator|=
name|osm_physp_get_node_ptr
argument_list|(
name|p_rem_physp
argument_list|)
expr_stmt|;
name|sys_guid
operator|=
name|p_rem_node
operator|->
name|node_info
operator|.
name|sys_guid
expr_stmt|;
name|node_guid
operator|=
name|p_rem_node
operator|->
name|node_info
operator|.
name|node_guid
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r
operator|->
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|!
name|find_sys_guid
operator|||
name|r
operator|->
name|guids
index|[
name|i
index|]
operator|.
name|node
operator|->
name|node_info
operator|.
name|sys_guid
operator|==
name|sys_guid
operator|)
operator|&&
operator|(
operator|!
name|find_node_guid
operator|||
name|r
operator|->
name|guids
index|[
name|i
index|]
operator|.
name|node
operator|->
name|node_info
operator|.
name|node_guid
operator|==
name|node_guid
operator|)
condition|)
block|{
name|p_remote_guid
operator|=
operator|&
name|r
operator|->
name|guids
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
return|return
name|p_remote_guid
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|osm_remote_node
modifier|*
name|osm_switch_find_sys_guid_count
parameter_list|(
name|IN
specifier|const
name|osm_switch_t
modifier|*
specifier|const
name|p_sw
parameter_list|,
name|IN
name|struct
name|osm_remote_guids_count
modifier|*
name|r
parameter_list|,
name|IN
name|uint8_t
name|port_num
parameter_list|)
block|{
return|return
name|osm_switch_find_guid_common
argument_list|(
name|p_sw
argument_list|,
name|r
argument_list|,
name|port_num
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|osm_remote_node
modifier|*
name|osm_switch_find_node_guid_count
parameter_list|(
name|IN
specifier|const
name|osm_switch_t
modifier|*
specifier|const
name|p_sw
parameter_list|,
name|IN
name|struct
name|osm_remote_guids_count
modifier|*
name|r
parameter_list|,
name|IN
name|uint8_t
name|port_num
parameter_list|)
block|{
return|return
name|osm_switch_find_guid_common
argument_list|(
name|p_sw
argument_list|,
name|r
argument_list|,
name|port_num
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|uint8_t
name|osm_switch_recommend_path
parameter_list|(
name|IN
specifier|const
name|osm_switch_t
modifier|*
specifier|const
name|p_sw
parameter_list|,
name|IN
name|osm_port_t
modifier|*
name|p_port
parameter_list|,
name|IN
specifier|const
name|uint16_t
name|lid_ho
parameter_list|,
name|IN
name|unsigned
name|start_from
parameter_list|,
name|IN
specifier|const
name|boolean_t
name|ignore_existing
parameter_list|,
name|IN
specifier|const
name|boolean_t
name|dor
parameter_list|)
block|{
comment|/* 	   We support an enhanced LMC aware routing mode: 	   In the case of LMC> 0, we can track the remote side 	   system and node for all of the lids of the target 	   and try and avoid routing again through the same 	   system / node.  	   If this procedure is provided with the tracking array 	   and counter we can conduct this algorithm. 	 */
name|boolean_t
name|routing_for_lmc
init|=
operator|(
name|p_port
operator|->
name|priv
operator|!=
name|NULL
operator|)
decl_stmt|;
name|uint16_t
name|base_lid
decl_stmt|;
name|uint8_t
name|hops
decl_stmt|;
name|uint8_t
name|least_hops
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|uint8_t
name|num_ports
decl_stmt|;
name|uint32_t
name|least_paths
init|=
literal|0xFFFFFFFF
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
comment|/* 	   The follwing will track the least paths if the 	   route should go through a new system/node 	 */
name|uint32_t
name|least_paths_other_sys
init|=
literal|0xFFFFFFFF
decl_stmt|;
name|uint32_t
name|least_paths_other_nodes
init|=
literal|0xFFFFFFFF
decl_stmt|;
name|uint32_t
name|least_forwarded_to
init|=
literal|0xFFFFFFFF
decl_stmt|;
name|uint32_t
name|check_count
decl_stmt|;
name|uint8_t
name|best_port
init|=
literal|0
decl_stmt|;
comment|/* 	   These vars track the best port if it connects to 	   not used system/node. 	 */
name|uint8_t
name|best_port_other_sys
init|=
literal|0
decl_stmt|;
name|uint8_t
name|best_port_other_node
init|=
literal|0
decl_stmt|;
name|boolean_t
name|port_found
init|=
name|FALSE
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_rem_physp
decl_stmt|;
name|osm_node_t
modifier|*
name|p_rem_node
decl_stmt|;
name|osm_node_t
modifier|*
name|p_rem_node_first
init|=
name|NULL
decl_stmt|;
name|struct
name|osm_remote_node
modifier|*
name|p_remote_guid
init|=
name|NULL
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|lid_ho
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_port
operator|->
name|p_node
operator|->
name|sw
condition|)
block|{
if|if
condition|(
name|p_port
operator|->
name|p_node
operator|->
name|sw
operator|==
name|p_sw
condition|)
return|return
literal|0
return|;
name|base_lid
operator|=
name|osm_port_get_base_lid
argument_list|(
name|p_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p_physp
operator|=
name|p_port
operator|->
name|p_physp
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
operator|||
operator|!
name|p_physp
operator|->
name|p_remote_physp
operator|||
operator|!
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
condition|)
return|return
name|OSM_NO_PATH
return|;
if|if
condition|(
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
operator|==
name|p_sw
condition|)
return|return
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|port_num
return|;
name|base_lid
operator|=
name|osm_node_get_base_lid
argument_list|(
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|base_lid
operator|=
name|cl_ntoh16
argument_list|(
name|base_lid
argument_list|)
expr_stmt|;
name|num_ports
operator|=
name|p_sw
operator|->
name|num_ports
expr_stmt|;
name|least_hops
operator|=
name|osm_switch_get_least_hops
argument_list|(
name|p_sw
argument_list|,
name|base_lid
argument_list|)
expr_stmt|;
if|if
condition|(
name|least_hops
operator|==
name|OSM_NO_PATH
condition|)
return|return
operator|(
name|OSM_NO_PATH
operator|)
return|;
comment|/* 	   First, inquire with the forwarding table for an existing 	   route.  If one is found, honor it unless: 	   1. the ignore existing flag is set. 	   2. the physical port is not a valid one or not healthy 	   3. the physical port has a remote port (the link is up) 	   4. the port has min-hops to the target (avoid loops) 	 */
if|if
condition|(
operator|!
name|ignore_existing
condition|)
block|{
name|port_num
operator|=
name|osm_switch_get_port_by_lid
argument_list|(
name|p_sw
argument_list|,
name|lid_ho
argument_list|)
expr_stmt|;
if|if
condition|(
name|port_num
operator|!=
name|OSM_NO_PATH
condition|)
block|{
name|CL_ASSERT
argument_list|(
name|port_num
operator|<
name|num_ports
argument_list|)
expr_stmt|;
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
comment|/* 			   Don't be too trusting of the current forwarding table! 			   Verify that the port number is legal and that the 			   LID is reachable through this port. 			 */
if|if
condition|(
name|p_physp
operator|&&
name|osm_physp_is_healthy
argument_list|(
name|p_physp
argument_list|)
operator|&&
name|osm_physp_get_remote
argument_list|(
name|p_physp
argument_list|)
condition|)
block|{
name|hops
operator|=
name|osm_switch_get_hop_count
argument_list|(
name|p_sw
argument_list|,
name|base_lid
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
comment|/* 				   If we aren't using pre-defined user routes 				   function, then we need to make sure that the 				   current path is the minimum one. In case of 				   having such a user function - this check will 				   not be done, and the old routing will be used. 				   Note: This means that it is the user's job to 				   clean all data in the forwarding tables that 				   he wants to be overridden by the minimum 				   hop function. 				 */
if|if
condition|(
name|hops
operator|==
name|least_hops
condition|)
return|return
operator|(
name|port_num
operator|)
return|;
block|}
block|}
block|}
comment|/* 	   This algorithm selects a port based on a static load balanced 	   selection across equal hop-count ports. 	   There is lots of room for improved sophistication here, 	   possibly guided by user configuration info. 	 */
comment|/* 	   OpenSM routing is "local" - not considering a full lid to lid 	   path. As such we can not guarantee a path will not loop if we 	   do not always follow least hops. 	   So we must abort if not least hops. 	 */
comment|/* port number starts with one and num_ports is 1 + num phys ports */
for|for
control|(
name|i
operator|=
name|start_from
init|;
name|i
operator|<
name|start_from
operator|+
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|port_num
operator|=
name|i
operator|%
name|num_ports
expr_stmt|;
if|if
condition|(
operator|!
name|port_num
operator|||
name|osm_switch_get_hop_count
argument_list|(
name|p_sw
argument_list|,
name|base_lid
argument_list|,
name|port_num
argument_list|)
operator|!=
name|least_hops
condition|)
continue|continue;
comment|/* let us make sure it is not down or unhealthy */
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_sw
operator|->
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp
operator|||
operator|!
name|osm_physp_is_healthy
argument_list|(
name|p_physp
argument_list|)
operator|||
comment|/* 		       we require all - non sma ports to be linked 		       to be routed through 		     */
operator|!
name|osm_physp_get_remote
argument_list|(
name|p_physp
argument_list|)
condition|)
continue|continue;
comment|/* 		   We located a least-hop port, possibly one of many. 		   For this port, check the running total count of 		   the number of paths through this port.  Select 		   the port routing the least number of paths. 		 */
name|check_count
operator|=
name|osm_port_prof_path_count_get
argument_list|(
operator|&
name|p_sw
operator|->
name|p_prof
index|[
name|port_num
index|]
argument_list|)
expr_stmt|;
comment|/* 		   Advanced LMC routing requires tracking of the 		   best port by the node connected to the other side of 		   it. 		 */
if|if
condition|(
name|routing_for_lmc
condition|)
block|{
comment|/* Is the sys guid already used ? */
name|p_remote_guid
operator|=
name|osm_switch_find_sys_guid_count
argument_list|(
name|p_sw
argument_list|,
name|p_port
operator|->
name|priv
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
comment|/* If not update the least hops for this case */
if|if
condition|(
operator|!
name|p_remote_guid
condition|)
block|{
if|if
condition|(
name|check_count
operator|<
name|least_paths_other_sys
condition|)
block|{
name|least_paths_other_sys
operator|=
name|check_count
expr_stmt|;
name|best_port_other_sys
operator|=
name|port_num
expr_stmt|;
name|least_forwarded_to
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* same sys found - try node */
comment|/* Else is the node guid already used ? */
name|p_remote_guid
operator|=
name|osm_switch_find_node_guid_count
argument_list|(
name|p_sw
argument_list|,
name|p_port
operator|->
name|priv
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
comment|/* If not update the least hops for this case */
if|if
condition|(
operator|!
name|p_remote_guid
operator|&&
name|check_count
operator|<
name|least_paths_other_nodes
condition|)
block|{
name|least_paths_other_nodes
operator|=
name|check_count
expr_stmt|;
name|best_port_other_node
operator|=
name|port_num
expr_stmt|;
name|least_forwarded_to
operator|=
literal|0
expr_stmt|;
block|}
comment|/* else prior sys and node guid already used */
block|}
comment|/* same sys found */
block|}
comment|/* routing for LMC mode */
comment|/* 		   the count is min but also lower then the max subscribed 		 */
if|if
condition|(
name|check_count
operator|<
name|least_paths
condition|)
block|{
if|if
condition|(
name|dor
condition|)
block|{
comment|/* Get the Remote Node */
name|p_rem_physp
operator|=
name|osm_physp_get_remote
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|p_rem_node
operator|=
name|osm_physp_get_node_ptr
argument_list|(
name|p_rem_physp
argument_list|)
expr_stmt|;
comment|/* use the first dimension, but spread 				 * traffic out among the group of ports 				 * representing that dimension */
if|if
condition|(
name|port_found
condition|)
block|{
if|if
condition|(
name|p_rem_node
operator|!=
name|p_rem_node_first
condition|)
continue|continue;
block|}
else|else
name|p_rem_node_first
operator|=
name|p_rem_node
expr_stmt|;
block|}
name|port_found
operator|=
name|TRUE
expr_stmt|;
name|best_port
operator|=
name|port_num
expr_stmt|;
name|least_paths
operator|=
name|check_count
expr_stmt|;
if|if
condition|(
name|routing_for_lmc
operator|&&
name|p_remote_guid
operator|&&
name|p_remote_guid
operator|->
name|forwarded_to
operator|<
name|least_forwarded_to
condition|)
name|least_forwarded_to
operator|=
name|p_remote_guid
operator|->
name|forwarded_to
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|routing_for_lmc
operator|&&
name|p_remote_guid
operator|&&
name|check_count
operator|==
name|least_paths
operator|&&
name|p_remote_guid
operator|->
name|forwarded_to
operator|<
name|least_forwarded_to
condition|)
block|{
name|least_forwarded_to
operator|=
name|p_remote_guid
operator|->
name|forwarded_to
expr_stmt|;
name|best_port
operator|=
name|port_num
expr_stmt|;
block|}
block|}
if|if
condition|(
name|port_found
operator|==
name|FALSE
condition|)
return|return
operator|(
name|OSM_NO_PATH
operator|)
return|;
comment|/* 	   if we are in enhanced routing mode and the best port is not 	   the local port 0 	 */
if|if
condition|(
name|routing_for_lmc
operator|&&
name|best_port
condition|)
block|{
comment|/* Select the least hop port of the non used sys first */
if|if
condition|(
name|best_port_other_sys
condition|)
name|best_port
operator|=
name|best_port_other_sys
expr_stmt|;
elseif|else
if|if
condition|(
name|best_port_other_node
condition|)
name|best_port
operator|=
name|best_port_other_node
expr_stmt|;
block|}
return|return
operator|(
name|best_port
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|void
name|osm_switch_clear_hops
parameter_list|(
name|IN
name|osm_switch_t
modifier|*
name|p_sw
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|num_hops
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p_sw
operator|->
name|hops
index|[
name|i
index|]
condition|)
name|memset
argument_list|(
name|p_sw
operator|->
name|hops
index|[
name|i
index|]
argument_list|,
name|OSM_NO_PATH
argument_list|,
name|p_sw
operator|->
name|num_ports
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|int
name|osm_switch_prepare_path_rebuild
parameter_list|(
name|IN
name|osm_switch_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|uint16_t
name|max_lids
parameter_list|)
block|{
name|uint8_t
modifier|*
modifier|*
name|hops
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
name|osm_port_prof_construct
argument_list|(
operator|&
name|p_sw
operator|->
name|p_prof
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|osm_switch_clear_hops
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_sw
operator|->
name|new_lft
operator|&&
operator|!
operator|(
name|p_sw
operator|->
name|new_lft
operator|=
name|malloc
argument_list|(
name|IB_LID_UCAST_END_HO
operator|+
literal|1
argument_list|)
operator|)
condition|)
return|return
name|IB_INSUFFICIENT_MEMORY
return|;
name|memset
argument_list|(
name|p_sw
operator|->
name|new_lft
argument_list|,
name|OSM_NO_PATH
argument_list|,
name|IB_LID_UCAST_END_HO
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_sw
operator|->
name|hops
condition|)
block|{
name|hops
operator|=
name|malloc
argument_list|(
operator|(
name|max_lids
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|hops
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hops
condition|)
return|return
operator|-
literal|1
return|;
name|memset
argument_list|(
name|hops
argument_list|,
literal|0
argument_list|,
operator|(
name|max_lids
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|hops
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|hops
operator|=
name|hops
expr_stmt|;
name|p_sw
operator|->
name|num_hops
operator|=
name|max_lids
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|max_lids
operator|+
literal|1
operator|>
name|p_sw
operator|->
name|num_hops
condition|)
block|{
name|uint8_t
modifier|*
modifier|*
name|old_hops
decl_stmt|;
name|hops
operator|=
name|malloc
argument_list|(
operator|(
name|max_lids
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|hops
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hops
condition|)
return|return
operator|-
literal|1
return|;
name|memcpy
argument_list|(
name|hops
argument_list|,
name|p_sw
operator|->
name|hops
argument_list|,
name|p_sw
operator|->
name|num_hops
operator|*
sizeof|sizeof
argument_list|(
name|hops
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|hops
operator|+
name|p_sw
operator|->
name|num_hops
argument_list|,
literal|0
argument_list|,
operator|(
name|max_lids
operator|+
literal|1
operator|-
name|p_sw
operator|->
name|num_hops
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|hops
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|old_hops
operator|=
name|p_sw
operator|->
name|hops
expr_stmt|;
name|p_sw
operator|->
name|hops
operator|=
name|hops
expr_stmt|;
name|p_sw
operator|->
name|num_hops
operator|=
name|max_lids
operator|+
literal|1
expr_stmt|;
name|free
argument_list|(
name|old_hops
argument_list|)
expr_stmt|;
block|}
name|p_sw
operator|->
name|max_lid_ho
operator|=
name|max_lids
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|uint8_t
name|osm_switch_get_port_least_hops
parameter_list|(
name|IN
specifier|const
name|osm_switch_t
modifier|*
specifier|const
name|p_sw
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
name|p_port
parameter_list|)
block|{
name|uint16_t
name|lid
decl_stmt|;
if|if
condition|(
name|p_port
operator|->
name|p_node
operator|->
name|sw
condition|)
block|{
if|if
condition|(
name|p_port
operator|->
name|p_node
operator|->
name|sw
operator|==
name|p_sw
condition|)
return|return
literal|0
return|;
name|lid
operator|=
name|osm_node_get_base_lid
argument_list|(
name|p_port
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|osm_switch_get_least_hops
argument_list|(
name|p_sw
argument_list|,
name|cl_ntoh16
argument_list|(
name|lid
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|osm_physp_t
modifier|*
name|p
init|=
name|p_port
operator|->
name|p_physp
decl_stmt|;
name|uint8_t
name|hops
decl_stmt|;
if|if
condition|(
operator|!
name|p
operator|||
operator|!
name|p
operator|->
name|p_remote_physp
operator|||
operator|!
name|p
operator|->
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
condition|)
return|return
name|OSM_NO_PATH
return|;
if|if
condition|(
name|p
operator|->
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
operator|==
name|p_sw
condition|)
return|return
literal|1
return|;
name|lid
operator|=
name|osm_node_get_base_lid
argument_list|(
name|p
operator|->
name|p_remote_physp
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hops
operator|=
name|osm_switch_get_least_hops
argument_list|(
name|p_sw
argument_list|,
name|cl_ntoh16
argument_list|(
name|lid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|hops
operator|!=
name|OSM_NO_PATH
condition|?
name|hops
operator|+
literal|1
else|:
name|OSM_NO_PATH
return|;
block|}
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|uint8_t
name|osm_switch_recommend_mcast_path
parameter_list|(
name|IN
name|osm_switch_t
modifier|*
specifier|const
name|p_sw
parameter_list|,
name|IN
name|osm_port_t
modifier|*
name|p_port
parameter_list|,
name|IN
name|uint16_t
specifier|const
name|mlid_ho
parameter_list|,
name|IN
name|boolean_t
specifier|const
name|ignore_existing
parameter_list|)
block|{
name|uint16_t
name|base_lid
decl_stmt|;
name|uint8_t
name|hops
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|uint8_t
name|num_ports
decl_stmt|;
name|uint8_t
name|least_hops
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|mlid_ho
operator|>=
name|IB_LID_MCAST_START_HO
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_port
operator|->
name|p_node
operator|->
name|sw
condition|)
block|{
if|if
condition|(
name|p_port
operator|->
name|p_node
operator|->
name|sw
operator|==
name|p_sw
condition|)
return|return
literal|0
return|;
name|base_lid
operator|=
name|osm_port_get_base_lid
argument_list|(
name|p_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|osm_physp_t
modifier|*
name|p_physp
init|=
name|p_port
operator|->
name|p_physp
decl_stmt|;
if|if
condition|(
operator|!
name|p_physp
operator|||
operator|!
name|p_physp
operator|->
name|p_remote_physp
operator|||
operator|!
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
condition|)
return|return
name|OSM_NO_PATH
return|;
if|if
condition|(
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|p_node
operator|->
name|sw
operator|==
name|p_sw
condition|)
return|return
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|port_num
return|;
name|base_lid
operator|=
name|osm_node_get_base_lid
argument_list|(
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|base_lid
operator|=
name|cl_ntoh16
argument_list|(
name|base_lid
argument_list|)
expr_stmt|;
name|num_ports
operator|=
name|p_sw
operator|->
name|num_ports
expr_stmt|;
comment|/* 	   If the user wants us to ignore existing multicast routes, 	   then simply return the shortest hop count path to the 	   target port.  	   Otherwise, return the first port that has a path to the target, 	   picking from the ports that are already in the multicast group. 	 */
if|if
condition|(
operator|!
name|ignore_existing
condition|)
block|{
for|for
control|(
name|port_num
operator|=
literal|1
init|;
name|port_num
operator|<
name|num_ports
condition|;
name|port_num
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|osm_mcast_tbl_is_port
argument_list|(
operator|&
name|p_sw
operator|->
name|mcast_tbl
argument_list|,
name|mlid_ho
argument_list|,
name|port_num
argument_list|)
condition|)
continue|continue;
comment|/* 			   Don't be too trusting of the current forwarding table! 			   Verify that the LID is reachable through this port. 			 */
name|hops
operator|=
name|osm_switch_get_hop_count
argument_list|(
name|p_sw
argument_list|,
name|base_lid
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|hops
operator|!=
name|OSM_NO_PATH
condition|)
return|return
operator|(
name|port_num
operator|)
return|;
block|}
block|}
comment|/* 	   Either no existing mcast paths reach this port or we are 	   ignoring existing paths.  	   Determine the best multicast path to the target.  Note that this 	   algorithm is slightly different from the one used for unicast route 	   recommendation.  In this case (multicast), we must NOT 	   perform any sort of load balancing.  We MUST take the FIRST 	   port found that has<= the lowest hop count path.  This prevents 	   more than one multicast path to the same remote switch which 	   prevents a multicast loop.  Multicast loops are bad since the same 	   multicast packet will go around and around, inevitably creating 	   a black hole that will destroy the Earth in a firey conflagration. 	 */
name|least_hops
operator|=
name|osm_switch_get_least_hops
argument_list|(
name|p_sw
argument_list|,
name|base_lid
argument_list|)
expr_stmt|;
for|for
control|(
name|port_num
operator|=
literal|1
init|;
name|port_num
operator|<
name|num_ports
condition|;
name|port_num
operator|++
control|)
if|if
condition|(
name|osm_switch_get_hop_count
argument_list|(
name|p_sw
argument_list|,
name|base_lid
argument_list|,
name|port_num
argument_list|)
operator|==
name|least_hops
condition|)
break|break;
name|CL_ASSERT
argument_list|(
name|port_num
operator|<
name|num_ports
argument_list|)
expr_stmt|;
return|return
operator|(
name|port_num
operator|)
return|;
block|}
end_function

end_unit

