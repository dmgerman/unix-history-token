begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2008 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2008 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_ni_rcv_t.  * This object represents the NodeInfo Receiver object.  * This object is part of the opensm family of objects.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qmap.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_passivelock.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_madw.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_node.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_subnet.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_router.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_mad_pool.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_msgdef.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_ucast_mgr.h>
end_include

begin_function
specifier|static
name|void
name|report_duplicated_guid
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|osm_physp_t
modifier|*
name|p_physp
parameter_list|,
name|osm_node_t
modifier|*
name|p_neighbor_node
parameter_list|,
specifier|const
name|uint8_t
name|port_num
parameter_list|)
block|{
name|osm_physp_t
modifier|*
name|p_old
decl_stmt|,
modifier|*
name|p_new
decl_stmt|;
name|osm_dr_path_t
name|path
decl_stmt|;
name|p_old
operator|=
name|p_physp
operator|->
name|p_remote_physp
expr_stmt|;
name|p_new
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_neighbor_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D01: "
literal|"Found duplicated node.\n"
literal|"Node 0x%"
name|PRIx64
literal|" port %u is reachable from remote node "
literal|"0x%"
name|PRIx64
literal|" port %u and remote node 0x%"
name|PRIx64
literal|" port %u.\n"
literal|"Paths are:\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_physp
operator|->
name|p_node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|)
argument_list|,
name|p_physp
operator|->
name|port_num
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_old
operator|->
name|p_node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|)
argument_list|,
name|p_old
operator|->
name|port_num
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_new
operator|->
name|p_node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|)
argument_list|,
name|p_new
operator|->
name|port_num
argument_list|)
expr_stmt|;
name|osm_dump_dr_path
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
argument_list|,
name|OSM_LOG_ERROR
argument_list|)
expr_stmt|;
name|path
operator|=
operator|*
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_new
argument_list|)
expr_stmt|;
name|osm_dr_path_extend
argument_list|(
operator|&
name|path
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|osm_dump_dr_path
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
operator|&
name|path
argument_list|,
name|OSM_LOG_ERROR
argument_list|)
expr_stmt|;
name|osm_log
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
literal|"FATAL: duplicated guids or 12x lane reversal\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|requery_dup_node_info
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|osm_physp_t
modifier|*
name|p_physp
parameter_list|,
name|unsigned
name|count
parameter_list|)
block|{
name|osm_madw_context_t
name|context
decl_stmt|;
name|osm_dr_path_t
name|path
decl_stmt|;
name|cl_status_t
name|status
decl_stmt|;
name|path
operator|=
operator|*
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
operator|->
name|p_remote_physp
argument_list|)
expr_stmt|;
name|osm_dr_path_extend
argument_list|(
operator|&
name|path
argument_list|,
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|port_num
argument_list|)
expr_stmt|;
name|context
operator|.
name|ni_context
operator|.
name|node_guid
operator|=
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|p_node
operator|->
name|node_info
operator|.
name|port_guid
expr_stmt|;
name|context
operator|.
name|ni_context
operator|.
name|port_num
operator|=
name|p_physp
operator|->
name|p_remote_physp
operator|->
name|port_num
expr_stmt|;
name|context
operator|.
name|ni_context
operator|.
name|dup_node_guid
operator|=
name|p_physp
operator|->
name|p_node
operator|->
name|node_info
operator|.
name|node_guid
expr_stmt|;
name|context
operator|.
name|ni_context
operator|.
name|dup_port_num
operator|=
name|p_physp
operator|->
name|port_num
expr_stmt|;
name|context
operator|.
name|ni_context
operator|.
name|dup_count
operator|=
name|count
expr_stmt|;
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
operator|&
name|path
argument_list|,
name|IB_MAD_ATTR_NODE_INFO
argument_list|,
literal|0
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D02: "
literal|"Failure initiating NodeInfo request (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  The plock must be held before calling this function. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ni_rcv_set_links
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|osm_node_t
modifier|*
name|p_node
parameter_list|,
specifier|const
name|uint8_t
name|port_num
parameter_list|,
specifier|const
name|osm_ni_context_t
modifier|*
specifier|const
name|p_ni_context
parameter_list|)
block|{
name|osm_node_t
modifier|*
name|p_neighbor_node
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	   A special case exists in which the node we're trying to 	   link is our own node.  In this case, the guid value in 	   the ni_context will be zero. 	 */
if|if
condition|(
name|p_ni_context
operator|->
name|node_guid
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Nothing to link for our own node 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|_exit
goto|;
block|}
name|p_neighbor_node
operator|=
name|osm_get_node_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|p_ni_context
operator|->
name|node_guid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_neighbor_node
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D10: "
literal|"Unexpected removal of neighbor node "
literal|"0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni_context
operator|->
name|node_guid
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|_exit
goto|;
block|}
comment|/* 	   We have seen this neighbor node before, but we might 	   not have seen this port on the neighbor node before. 	   We should not set links to an uninitialized port on the 	   neighbor, so check validity up front.  If it's not 	   valid, do nothing, since we'll see this link again 	   when we probe the neighbor. 	 */
if|if
condition|(
operator|!
name|osm_node_link_has_valid_ports
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|,
name|p_neighbor_node
argument_list|,
name|p_ni_context
operator|->
name|port_num
argument_list|)
condition|)
goto|goto
name|_exit
goto|;
if|if
condition|(
name|osm_node_link_exists
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|,
name|p_neighbor_node
argument_list|,
name|p_ni_context
operator|->
name|port_num
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Link already exists\n"
argument_list|)
expr_stmt|;
goto|goto
name|_exit
goto|;
block|}
if|if
condition|(
name|osm_node_has_any_link
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
operator|&&
name|sm
operator|->
name|p_subn
operator|->
name|force_heavy_sweep
operator|==
name|FALSE
operator|&&
operator|(
operator|!
name|p_ni_context
operator|->
name|dup_count
operator|||
operator|(
name|p_ni_context
operator|->
name|dup_node_guid
operator|==
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
operator|&&
name|p_ni_context
operator|->
name|dup_port_num
operator|==
name|port_num
operator|)
operator|)
condition|)
block|{
comment|/* 		   Uh oh... 		   This could be reconnected ports, but also duplicated GUID 		   (2 nodes have the same guid) or a 12x link with lane reversal 		   that is not configured correctly. 		   We will try to recover by querying NodeInfo again. 		   In order to catch even fast port moving to new location(s) and 		   back we will count up to 5. 		   Some crazy reconnections (newly created switch loop right before 		   targeted CA) will not be catched this way. So in worst case - 		   report GUID duplication and request new discovery. 		   When switch node is targeted NodeInfo querying will be done in 		   opposite order, this is much stronger check, unfortunately it is 		   impossible with CAs. 		 */
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ni_context
operator|->
name|dup_count
operator|>
literal|5
condition|)
block|{
name|report_duplicated_guid
argument_list|(
name|sm
argument_list|,
name|p_physp
argument_list|,
name|p_neighbor_node
argument_list|,
name|p_ni_context
operator|->
name|port_num
argument_list|)
expr_stmt|;
name|sm
operator|->
name|p_subn
operator|->
name|force_heavy_sweep
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_node
operator|->
name|sw
condition|)
name|requery_dup_node_info
argument_list|(
name|sm
argument_list|,
name|p_physp
operator|->
name|p_remote_physp
argument_list|,
name|p_ni_context
operator|->
name|dup_count
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|requery_dup_node_info
argument_list|(
name|sm
argument_list|,
name|p_physp
argument_list|,
name|p_ni_context
operator|->
name|dup_count
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	   When there are only two nodes with exact same guids (connected back 	   to back) - the previous check for duplicated guid will not catch 	   them. But the link will be from the port to itself... 	   Enhanced Port 0 is an exception to this 	 */
if|if
condition|(
operator|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
operator|==
name|p_ni_context
operator|->
name|node_guid
operator|)
operator|&&
operator|(
name|port_num
operator|==
name|p_ni_context
operator|->
name|port_num
operator|)
operator|&&
name|port_num
operator|!=
literal|0
operator|&&
name|cl_qmap_count
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|sw_guid_tbl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Duplicate GUID found by link from a port to itself:"
literal|"node 0x%"
name|PRIx64
literal|", port number %u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|osm_dump_dr_path
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|exit_on_fatal
operator|==
name|TRUE
condition|)
block|{
name|osm_log
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
literal|"Errors on subnet. Duplicate GUID found "
literal|"by link from a port to itself. "
literal|"See verbose opensm.log for more details\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Creating new link between:\n\t\t\t\tnode 0x%"
name|PRIx64
literal|", port number %u and\n\t\t\t\tnode 0x%"
name|PRIx64
literal|", port number %u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|port_num
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni_context
operator|->
name|node_guid
argument_list|)
argument_list|,
name|p_ni_context
operator|->
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|ucast_mgr
operator|.
name|cache_valid
condition|)
name|osm_ucast_cache_check_new_link
argument_list|(
operator|&
name|sm
operator|->
name|ucast_mgr
argument_list|,
name|p_node
argument_list|,
name|port_num
argument_list|,
name|p_neighbor_node
argument_list|,
name|p_ni_context
operator|->
name|port_num
argument_list|)
expr_stmt|;
name|osm_node_link
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|,
name|p_neighbor_node
argument_list|,
name|p_ni_context
operator|->
name|port_num
argument_list|)
expr_stmt|;
name|_exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  The plock must be held before calling this function. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ni_rcv_process_new_node
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
specifier|const
name|p_node
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|osm_madw_context_t
name|context
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|ib_node_info_t
modifier|*
name|p_ni
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_ni
operator|=
operator|(
name|ib_node_info_t
operator|*
operator|)
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
name|port_num
operator|=
name|ib_node_info_get_local_port_num
argument_list|(
name|p_ni
argument_list|)
expr_stmt|;
comment|/* 	   Request PortInfo& NodeDescription attributes for the port 	   that responded to the NodeInfo attribute. 	   Because this is a channel adapter or router, we are 	   not allowed to request PortInfo for the other ports. 	   Set the context union properly, so the recipient 	   knows which node& port are relevant. 	 */
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|node_guid
operator|=
name|p_ni
operator|->
name|node_guid
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|port_guid
operator|=
name|p_ni
operator|->
name|port_guid
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|set_method
operator|=
name|FALSE
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|light_sweep
operator|=
name|FALSE
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|active_transition
operator|=
name|FALSE
expr_stmt|;
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
argument_list|,
name|IB_MAD_ATTR_PORT_INFO
argument_list|,
name|cl_hton32
argument_list|(
name|port_num
argument_list|)
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D02: "
literal|"Failure initiating PortInfo request (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  The plock must be held before calling this function. **********************************************************************/
end_comment

begin_function
name|void
name|osm_req_get_node_desc
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|osm_physp_t
modifier|*
name|p_physp
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|osm_madw_context_t
name|context
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|context
operator|.
name|nd_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|osm_physp_get_node_ptr
argument_list|(
name|p_physp
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
argument_list|,
name|IB_MAD_ATTR_NODE_DESC
argument_list|,
literal|0
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D03: "
literal|"Failure initiating NodeDescription request (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  The plock must be held before calling this function. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ni_rcv_get_node_desc
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
specifier|const
name|p_node
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|)
block|{
name|ib_node_info_t
modifier|*
name|p_ni
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
init|=
name|NULL
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_ni
operator|=
operator|(
name|ib_node_info_t
operator|*
operator|)
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
name|port_num
operator|=
name|ib_node_info_get_local_port_num
argument_list|(
name|p_ni
argument_list|)
expr_stmt|;
comment|/* 	   Request PortInfo& NodeDescription attributes for the port 	   that responded to the NodeInfo attribute. 	   Because this is a channel adapter or router, we are 	   not allowed to request PortInfo for the other ports. 	   Set the context union properly, so the recipient 	   knows which node& port are relevant. 	 */
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|osm_req_get_node_desc
argument_list|(
name|sm
argument_list|,
name|p_physp
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  The plock must be held before calling this function. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ni_rcv_process_new_ca_or_router
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
specifier|const
name|p_node
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|)
block|{
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|__osm_ni_rcv_process_new_node
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
comment|/* 	   A node guid of 0 is the corner case that indicates 	   we discovered our own node.  Initialize the subnet 	   object with the SM's own port guid. 	 */
if|if
condition|(
name|osm_madw_get_ni_context_ptr
argument_list|(
name|p_madw
argument_list|)
operator|->
name|node_guid
operator|==
literal|0
condition|)
name|sm
operator|->
name|p_subn
operator|->
name|sm_port_guid
operator|=
name|p_node
operator|->
name|node_info
operator|.
name|port_guid
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  The plock must be held before calling this function. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ni_rcv_process_existing_ca_or_router
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
specifier|const
name|p_node
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|)
block|{
name|ib_node_info_t
modifier|*
name|p_ni
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port_check
decl_stmt|;
name|osm_madw_context_t
name|context
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|osm_dr_path_t
modifier|*
name|p_dr_path
decl_stmt|;
name|osm_bind_handle_t
name|h_bind
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_ni
operator|=
operator|(
name|ib_node_info_t
operator|*
operator|)
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
name|port_num
operator|=
name|ib_node_info_get_local_port_num
argument_list|(
name|p_ni
argument_list|)
expr_stmt|;
name|h_bind
operator|=
name|osm_madw_get_bind_handle
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
comment|/* 	   Determine if we have encountered this node through a 	   previously undiscovered port.  If so, build the new 	   port object. 	 */
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|p_ni
operator|->
name|port_guid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Creating new port object with GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni
operator|->
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
name|osm_node_init_physp
argument_list|(
name|p_node
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
name|p_port
operator|=
name|osm_port_new
argument_list|(
name|p_ni
argument_list|,
name|p_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_port
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D04: "
literal|"Unable to create new port object\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 		   Add the new port object to the database. 		 */
name|p_port_check
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_insert
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|port_guid_tbl
argument_list|,
name|p_ni
operator|->
name|port_guid
argument_list|,
operator|&
name|p_port
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_port_check
operator|!=
name|p_port
condition|)
block|{
comment|/* 			   We should never be here! 			   Somehow, this port GUID already exists in the table. 			 */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D12: "
literal|"Port 0x%"
name|PRIx64
literal|" already in the database!\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni
operator|->
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
name|osm_port_delete
argument_list|(
operator|&
name|p_port
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* If we are a master, then this means the port is new on the subnet. 		   Mark it as new - need to send trap 64 on these ports. 		   The condition that we are master is true, since if we are in discovering 		   state (meaning we woke up from standby or we are just initializing), 		   then these ports may be new to us, but are not new on the subnet. 		   If we are master, then the subnet as we know it is the updated one, 		   and any new ports we encounter should cause trap 64. C14-72.1.1 */
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
operator|==
name|IB_SMINFO_STATE_MASTER
condition|)
name|p_port
operator|->
name|is_new
operator|=
literal|1
expr_stmt|;
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
comment|/* 		   Update the DR Path to the port, 		   in case the old one is no longer available. 		 */
name|p_dr_path
operator|=
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|osm_dr_path_init
argument_list|(
name|p_dr_path
argument_list|,
name|h_bind
argument_list|,
name|p_smp
operator|->
name|hop_count
argument_list|,
name|p_smp
operator|->
name|initial_path
argument_list|)
expr_stmt|;
block|}
name|context
operator|.
name|pi_context
operator|.
name|node_guid
operator|=
name|p_ni
operator|->
name|node_guid
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|port_guid
operator|=
name|p_ni
operator|->
name|port_guid
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|set_method
operator|=
name|FALSE
expr_stmt|;
name|context
operator|.
name|pi_context
operator|.
name|light_sweep
operator|=
name|FALSE
expr_stmt|;
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_physp
argument_list|)
argument_list|,
name|IB_MAD_ATTR_PORT_INFO
argument_list|,
name|cl_hton32
argument_list|(
name|port_num
argument_list|)
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D13: "
literal|"Failure initiating PortInfo request (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ni_rcv_process_switch
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
specifier|const
name|p_node
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|osm_madw_context_t
name|context
decl_stmt|;
name|osm_dr_path_t
modifier|*
name|path
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
comment|/* update DR path of already initialized switch port 0 */
name|path
operator|=
name|osm_physp_get_dr_path_ptr
argument_list|(
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|osm_dr_path_init
argument_list|(
name|path
argument_list|,
name|osm_madw_get_bind_handle
argument_list|(
name|p_madw
argument_list|)
argument_list|,
name|p_smp
operator|->
name|hop_count
argument_list|,
name|p_smp
operator|->
name|initial_path
argument_list|)
expr_stmt|;
name|context
operator|.
name|si_context
operator|.
name|node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
expr_stmt|;
name|context
operator|.
name|si_context
operator|.
name|set_method
operator|=
name|FALSE
expr_stmt|;
name|context
operator|.
name|si_context
operator|.
name|light_sweep
operator|=
name|FALSE
expr_stmt|;
comment|/* Request a SwitchInfo attribute */
name|status
operator|=
name|osm_req_get
argument_list|(
name|sm
argument_list|,
name|path
argument_list|,
name|IB_MAD_ATTR_SWITCH_INFO
argument_list|,
literal|0
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
comment|/* continue despite error */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D06: "
literal|"Failure initiating SwitchInfo request (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  The plock must be held before calling this function. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ni_rcv_process_existing_switch
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
specifier|const
name|p_node
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|)
block|{
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	   If this switch has already been probed during this sweep, 	   then don't bother reprobing it. 	   There is one exception - if the node has been visited, but 	   for some reason we don't have the switch object (this can happen 	   if the SwitchInfo mad didn't reach the SM) then we want 	   to retry to probe the switch. 	 */
if|if
condition|(
name|p_node
operator|->
name|discovery_count
operator|==
literal|1
condition|)
name|__osm_ni_rcv_process_switch
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|p_node
operator|->
name|sw
operator|||
name|p_node
operator|->
name|sw
operator|->
name|discovery_count
operator|==
literal|0
condition|)
block|{
comment|/* we don't have the SwitchInfo - retry to get it */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Retry to get SwitchInfo on node GUID:0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|__osm_ni_rcv_process_switch
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  The plock must be held before calling this function. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ni_rcv_process_new_switch
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
specifier|const
name|p_node
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|)
block|{
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|__osm_ni_rcv_process_switch
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
comment|/* 	   A node guid of 0 is the corner case that indicates 	   we discovered our own node.  Initialize the subnet 	   object with the SM's own port guid. 	 */
if|if
condition|(
name|osm_madw_get_ni_context_ptr
argument_list|(
name|p_madw
argument_list|)
operator|->
name|node_guid
operator|==
literal|0
condition|)
name|sm
operator|->
name|p_subn
operator|->
name|sm_port_guid
operator|=
name|p_node
operator|->
name|node_info
operator|.
name|port_guid
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  The plock must NOT be held before calling this function. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ni_rcv_process_new
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|)
block|{
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node_check
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port_check
decl_stmt|;
name|osm_router_t
modifier|*
name|p_rtr
init|=
name|NULL
decl_stmt|;
name|osm_router_t
modifier|*
name|p_rtr_check
decl_stmt|;
name|cl_qmap_t
modifier|*
name|p_rtr_guid_tbl
decl_stmt|;
name|ib_node_info_t
modifier|*
name|p_ni
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|osm_ni_context_t
modifier|*
name|p_ni_context
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_ni
operator|=
operator|(
name|ib_node_info_t
operator|*
operator|)
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
name|p_ni_context
operator|=
name|osm_madw_get_ni_context_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|port_num
operator|=
name|ib_node_info_get_local_port_num
argument_list|(
name|p_ni
argument_list|)
expr_stmt|;
name|osm_dump_smp_dr_path
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|p_smp
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Discovered new %s node,"
literal|"\n\t\t\t\tGUID 0x%"
name|PRIx64
literal|", TID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|ib_get_node_type_str
argument_list|(
name|p_ni
operator|->
name|node_type
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni
operator|->
name|node_guid
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_smp
operator|->
name|trans_id
argument_list|)
argument_list|)
expr_stmt|;
name|p_node
operator|=
name|osm_node_new
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_node
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D07: "
literal|"Unable to create new node object\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	   Create a new port object to represent this node's physical 	   ports in the port table. 	 */
name|p_port
operator|=
name|osm_port_new
argument_list|(
name|p_ni
argument_list|,
name|p_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_port
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D14: "
literal|"Unable to create new port object\n"
argument_list|)
expr_stmt|;
name|osm_node_delete
argument_list|(
operator|&
name|p_node
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	   Add the new port object to the database. 	 */
name|p_port_check
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_insert
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|port_guid_tbl
argument_list|,
name|p_ni
operator|->
name|port_guid
argument_list|,
operator|&
name|p_port
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_port_check
operator|!=
name|p_port
condition|)
block|{
comment|/* 		   We should never be here! 		   Somehow, this port GUID already exists in the table. 		 */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D15: "
literal|"Duplicate Port GUID 0x%"
name|PRIx64
literal|"! Found by the two directed routes:\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni
operator|->
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
name|osm_dump_dr_path
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_port
operator|->
name|p_physp
argument_list|)
argument_list|,
name|OSM_LOG_ERROR
argument_list|)
expr_stmt|;
name|osm_dump_dr_path
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|osm_physp_get_dr_path_ptr
argument_list|(
name|p_port_check
operator|->
name|p_physp
argument_list|)
argument_list|,
name|OSM_LOG_ERROR
argument_list|)
expr_stmt|;
name|osm_port_delete
argument_list|(
operator|&
name|p_port
argument_list|)
expr_stmt|;
name|osm_node_delete
argument_list|(
operator|&
name|p_node
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* If we are a master, then this means the port is new on the subnet. 	   Mark it as new - need to send trap 64 on these ports. 	   The condition that we are master is true, since if we are in discovering 	   state (meaning we woke up from standby or we are just initializing), 	   then these ports may be new to us, but are not new on the subnet. 	   If we are master, then the subnet as we know it is the updated one, 	   and any new ports we encounter should cause trap 64. C14-72.1.1 */
if|if
condition|(
name|sm
operator|->
name|p_subn
operator|->
name|sm_state
operator|==
name|IB_SMINFO_STATE_MASTER
condition|)
name|p_port
operator|->
name|is_new
operator|=
literal|1
expr_stmt|;
comment|/* If there were RouterInfo or other router attribute, 	   this would be elsewhere */
if|if
condition|(
name|p_ni
operator|->
name|node_type
operator|==
name|IB_NODE_TYPE_ROUTER
condition|)
block|{
if|if
condition|(
operator|(
name|p_rtr
operator|=
name|osm_router_new
argument_list|(
name|p_port
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D1A: "
literal|"Unable to create new router object\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|p_rtr_guid_tbl
operator|=
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|rtr_guid_tbl
expr_stmt|;
name|p_rtr_check
operator|=
operator|(
name|osm_router_t
operator|*
operator|)
name|cl_qmap_insert
argument_list|(
name|p_rtr_guid_tbl
argument_list|,
name|p_ni
operator|->
name|port_guid
argument_list|,
operator|&
name|p_rtr
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_rtr_check
operator|!=
name|p_rtr
condition|)
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D1B: "
literal|"Unable to add port GUID:0x%016"
name|PRIx64
literal|" to router table\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni
operator|->
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|p_node_check
operator|=
operator|(
name|osm_node_t
operator|*
operator|)
name|cl_qmap_insert
argument_list|(
operator|&
name|sm
operator|->
name|p_subn
operator|->
name|node_guid_tbl
argument_list|,
name|p_ni
operator|->
name|node_guid
argument_list|,
operator|&
name|p_node
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_node_check
operator|!=
name|p_node
condition|)
block|{
comment|/* 		   This node must have been inserted by another thread. 		   This is unexpected, but is not an error. 		   We can simply clean-up, since the other thread will 		   see this processing through to completion. 		 */
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Discovery race detected at node 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni
operator|->
name|node_guid
argument_list|)
argument_list|)
expr_stmt|;
name|osm_node_delete
argument_list|(
operator|&
name|p_node
argument_list|)
expr_stmt|;
name|p_node
operator|=
name|p_node_check
expr_stmt|;
name|__osm_ni_rcv_set_links
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|port_num
argument_list|,
name|p_ni_context
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
else|else
name|__osm_ni_rcv_set_links
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|port_num
argument_list|,
name|p_ni_context
argument_list|)
expr_stmt|;
name|p_node
operator|->
name|discovery_count
operator|++
expr_stmt|;
name|__osm_ni_rcv_get_node_desc
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_ni
operator|->
name|node_type
condition|)
block|{
case|case
name|IB_NODE_TYPE_CA
case|:
case|case
name|IB_NODE_TYPE_ROUTER
case|:
name|__osm_ni_rcv_process_new_ca_or_router
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_NODE_TYPE_SWITCH
case|:
name|__osm_ni_rcv_process_new_switch
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
break|break;
default|default:
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D16: "
literal|"Unknown node type %u with GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|p_ni
operator|->
name|node_type
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni
operator|->
name|node_guid
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  The plock must be held before calling this function. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ni_rcv_process_existing
parameter_list|(
name|IN
name|osm_sm_t
modifier|*
name|sm
parameter_list|,
name|IN
name|osm_node_t
modifier|*
specifier|const
name|p_node
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|)
block|{
name|ib_node_info_t
modifier|*
name|p_ni
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|osm_ni_context_t
modifier|*
name|p_ni_context
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_ni
operator|=
operator|(
name|ib_node_info_t
operator|*
operator|)
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
name|p_ni_context
operator|=
name|osm_madw_get_ni_context_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|port_num
operator|=
name|ib_node_info_get_local_port_num
argument_list|(
name|p_ni
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Rediscovered %s node 0x%"
name|PRIx64
literal|" TID 0x%"
name|PRIx64
literal|", discovered %u times already\n"
argument_list|,
name|ib_get_node_type_str
argument_list|(
name|p_ni
operator|->
name|node_type
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni
operator|->
name|node_guid
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_smp
operator|->
name|trans_id
argument_list|)
argument_list|,
name|p_node
operator|->
name|discovery_count
argument_list|)
expr_stmt|;
comment|/* 	   If we haven't already encountered this existing node 	   on this particular sweep, then process further. 	 */
name|p_node
operator|->
name|discovery_count
operator|++
expr_stmt|;
switch|switch
condition|(
name|p_ni
operator|->
name|node_type
condition|)
block|{
case|case
name|IB_NODE_TYPE_CA
case|:
case|case
name|IB_NODE_TYPE_ROUTER
case|:
name|__osm_ni_rcv_process_existing_ca_or_router
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_NODE_TYPE_SWITCH
case|:
name|__osm_ni_rcv_process_existing_switch
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
break|break;
default|default:
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D09: "
literal|"Unknown node type %u with GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|p_ni
operator|->
name|node_type
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_ni
operator|->
name|node_guid
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|__osm_ni_rcv_set_links
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|port_num
argument_list|,
name|p_ni_context
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|void
name|osm_ni_rcv_process
parameter_list|(
name|IN
name|void
modifier|*
name|context
parameter_list|,
name|IN
name|void
modifier|*
name|data
parameter_list|)
block|{
name|osm_sm_t
modifier|*
name|sm
init|=
name|context
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_madw
init|=
name|data
decl_stmt|;
name|ib_node_info_t
modifier|*
name|p_ni
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_ni
operator|=
operator|(
name|ib_node_info_t
operator|*
operator|)
name|ib_smp_get_payload_ptr
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_smp
operator|->
name|attr_id
operator|==
name|IB_MAD_ATTR_NODE_INFO
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ni
operator|->
name|node_guid
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D16: "
literal|"Got Zero Node GUID! Found on the directed route:\n"
argument_list|)
expr_stmt|;
name|osm_dump_smp_dr_path
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|p_smp
argument_list|,
name|OSM_LOG_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|p_ni
operator|->
name|port_guid
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 0D17: "
literal|"Got Zero Port GUID! Found on the directed route:\n"
argument_list|)
expr_stmt|;
name|osm_dump_smp_dr_path
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|p_smp
argument_list|,
name|OSM_LOG_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	   Determine if this node has already been discovered, 	   and process accordingly. 	   During processing of this node, hold the shared lock. 	 */
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|p_node
operator|=
name|osm_get_node_by_guid
argument_list|(
name|sm
operator|->
name|p_subn
argument_list|,
name|p_ni
operator|->
name|node_guid
argument_list|)
expr_stmt|;
name|osm_dump_node_info
argument_list|(
name|sm
operator|->
name|p_log
argument_list|,
name|p_ni
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_node
condition|)
name|__osm_ni_rcv_process_new
argument_list|(
name|sm
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
else|else
name|__osm_ni_rcv_process_existing
argument_list|(
name|sm
argument_list|,
name|p_node
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sm
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sm
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

