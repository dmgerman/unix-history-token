begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2008 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2005 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  * Copyright (c) 2008 Xsigo Systems Inc.  All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_mcmr_recv_t.  * This object represents the MCMemberRecord Receiver object.  * This object is part of the opensm family of objects.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qmap.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_passivelock.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qlist.h>
end_include

begin_include
include|#
directive|include
file|<vendor/osm_vendor_api.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_madw.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_subnet.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_mad_pool.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_msgdef.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_pkey.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_inform.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_sa.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_define
define|#
directive|define
name|JOIN_MC_COMP_MASK
value|(IB_MCR_COMPMASK_MGID | \ 				IB_MCR_COMPMASK_PORT_GID | \ 				IB_MCR_COMPMASK_JOIN_STATE)
end_define

begin_define
define|#
directive|define
name|REQUIRED_MC_CREATE_COMP_MASK
value|(IB_MCR_COMPMASK_MGID | \ 					IB_MCR_COMPMASK_PORT_GID | \ 					IB_MCR_COMPMASK_JOIN_STATE | \ 					IB_MCR_COMPMASK_QKEY | \ 					IB_MCR_COMPMASK_TCLASS | \ 					IB_MCR_COMPMASK_PKEY | \ 					IB_MCR_COMPMASK_FLOW | \ 					IB_MCR_COMPMASK_SL)
end_define

begin_typedef
typedef|typedef
struct|struct
name|osm_mcmr_item
block|{
name|cl_list_item_t
name|list_item
decl_stmt|;
name|ib_member_rec_t
name|rec
decl_stmt|;
block|}
name|osm_mcmr_item_t
typedef|;
end_typedef

begin_comment
comment|/*********************************************************************  Copy certain fields between two mcmember records  used during the process of join request to copy data from the mgrp  to the port record. **********************************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|__copy_from_create_mc_rec
parameter_list|(
name|IN
name|ib_member_rec_t
modifier|*
specifier|const
name|dest
parameter_list|,
name|IN
specifier|const
name|ib_member_rec_t
modifier|*
specifier|const
name|src
parameter_list|)
block|{
name|dest
operator|->
name|qkey
operator|=
name|src
operator|->
name|qkey
expr_stmt|;
name|dest
operator|->
name|mlid
operator|=
name|src
operator|->
name|mlid
expr_stmt|;
name|dest
operator|->
name|tclass
operator|=
name|src
operator|->
name|tclass
expr_stmt|;
name|dest
operator|->
name|pkey
operator|=
name|src
operator|->
name|pkey
expr_stmt|;
name|dest
operator|->
name|sl_flow_hop
operator|=
name|src
operator|->
name|sl_flow_hop
expr_stmt|;
name|dest
operator|->
name|mtu
operator|=
name|src
operator|->
name|mtu
expr_stmt|;
name|dest
operator|->
name|rate
operator|=
name|src
operator|->
name|rate
expr_stmt|;
name|dest
operator|->
name|pkt_life
operator|=
name|src
operator|->
name|pkt_life
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  Return mlid to the pool of free mlids.  But this implementation is not a pool - it simply scans through  the MGRP database for unused mlids... *********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__free_mlid
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
name|uint16_t
name|mlid
parameter_list|)
block|{
name|UNUSED_PARAM
argument_list|(
name|sa
argument_list|)
expr_stmt|;
name|UNUSED_PARAM
argument_list|(
name|mlid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  Get a new unused mlid by scanning all the used ones in the subnet. **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_net16_t
name|__get_new_mlid
parameter_list|(
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|ib_net16_t
name|requested_mlid
parameter_list|)
block|{
name|osm_subn_t
modifier|*
name|p_subn
init|=
name|sa
operator|->
name|p_subn
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|max
decl_stmt|;
if|if
condition|(
name|requested_mlid
operator|&&
name|cl_ntoh16
argument_list|(
name|requested_mlid
argument_list|)
operator|>=
name|IB_LID_MCAST_START_HO
operator|&&
name|cl_ntoh16
argument_list|(
name|requested_mlid
argument_list|)
operator|<=
name|p_subn
operator|->
name|max_mcast_lid_ho
operator|&&
operator|!
name|osm_get_mgrp_by_mlid
argument_list|(
name|p_subn
argument_list|,
name|requested_mlid
argument_list|)
condition|)
return|return
name|requested_mlid
return|;
name|max
operator|=
name|p_subn
operator|->
name|max_mcast_lid_ho
operator|-
name|IB_LID_MCAST_START_HO
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|osm_mgrp_t
modifier|*
name|p_mgrp
init|=
name|sa
operator|->
name|p_subn
operator|->
name|mgroups
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|p_mgrp
operator|||
name|p_mgrp
operator|->
name|to_be_deleted
condition|)
return|return
name|cl_hton16
argument_list|(
name|i
operator|+
name|IB_LID_MCAST_START_HO
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  This procedure is only invoked to cleanup an INTERMEDIATE mgrp.  If there is only one port on the mgrp it means that the current  request was the only member and the group is not really needed. So  we silently drop it. Since it was an intermediate group no need to  re-route it. **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__cleanup_mgrp
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|osm_mgrp_t
modifier|*
name|mgrp
parameter_list|)
block|{
comment|/* Remove MGRP only if osm_mcm_port_t count is 0 and 	   not a well known group */
if|if
condition|(
name|cl_is_qmap_empty
argument_list|(
operator|&
name|mgrp
operator|->
name|mcm_port_tbl
argument_list|)
operator|&&
operator|!
name|mgrp
operator|->
name|well_known
condition|)
block|{
name|sa
operator|->
name|p_subn
operator|->
name|mgroups
index|[
name|cl_ntoh16
argument_list|(
name|mgrp
operator|->
name|mlid
argument_list|)
operator|-
name|IB_LID_MCAST_START_HO
index|]
operator|=
name|NULL
expr_stmt|;
name|osm_mgrp_delete
argument_list|(
name|mgrp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************************************  Add a port to the group. Calculating its PROXY_JOIN by the Port and  requester gids. **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|__add_new_mgrp_port
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
name|osm_mgrp_t
modifier|*
name|p_mgrp
parameter_list|,
name|IN
name|ib_member_rec_t
modifier|*
name|p_recvd_mcmember_rec
parameter_list|,
name|IN
name|osm_mad_addr_t
modifier|*
name|p_mad_addr
parameter_list|,
name|OUT
name|osm_mcm_port_t
modifier|*
modifier|*
name|pp_mcmr_port
parameter_list|)
block|{
name|boolean_t
name|proxy_join
decl_stmt|;
name|ib_gid_t
name|requester_gid
decl_stmt|;
name|ib_api_status_t
name|res
decl_stmt|;
comment|/* set the proxy_join if the requester gid is not identical to the 	   joined gid */
name|res
operator|=
name|osm_get_gid_by_mad_addr
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|sa
operator|->
name|p_subn
argument_list|,
name|p_mad_addr
argument_list|,
operator|&
name|requester_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B29: "
literal|"Could not find GID for requester\n"
argument_list|)
expr_stmt|;
return|return
name|IB_INVALID_PARAMETER
return|;
block|}
if|if
condition|(
operator|!
name|memcmp
argument_list|(
operator|&
name|p_recvd_mcmember_rec
operator|->
name|port_gid
argument_list|,
operator|&
name|requester_gid
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_gid_t
argument_list|)
argument_list|)
condition|)
block|{
name|proxy_join
operator|=
name|FALSE
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Create new port with proxy_join FALSE\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The port is not the one specified in PortGID. 		   The check that the requester is in the same partition as 		   the PortGID is done before - just need to update 		   the proxy_join. */
name|proxy_join
operator|=
name|TRUE
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Create new port with proxy_join TRUE\n"
argument_list|)
expr_stmt|;
block|}
operator|*
name|pp_mcmr_port
operator|=
name|osm_mgrp_add_port
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|sa
operator|->
name|p_log
argument_list|,
name|p_mgrp
argument_list|,
operator|&
name|p_recvd_mcmember_rec
operator|->
name|port_gid
argument_list|,
name|p_recvd_mcmember_rec
operator|->
name|scope_state
argument_list|,
name|proxy_join
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pp_mcmr_port
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B06: "
literal|"osm_mgrp_add_port failed\n"
argument_list|)
expr_stmt|;
return|return
name|IB_INSUFFICIENT_MEMORY
return|;
block|}
return|return
name|IB_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|boolean_t
name|__check_join_comp_mask
parameter_list|(
name|ib_net64_t
name|comp_mask
parameter_list|)
block|{
return|return
operator|(
operator|(
name|comp_mask
operator|&
name|JOIN_MC_COMP_MASK
operator|)
operator|==
name|JOIN_MC_COMP_MASK
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|boolean_t
name|__check_create_comp_mask
parameter_list|(
name|ib_net64_t
name|comp_mask
parameter_list|,
name|ib_member_rec_t
modifier|*
name|p_recvd_mcmember_rec
parameter_list|)
block|{
return|return
operator|(
operator|(
name|comp_mask
operator|&
name|REQUIRED_MC_CREATE_COMP_MASK
operator|)
operator|==
name|REQUIRED_MC_CREATE_COMP_MASK
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Generate the response MAD **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_mcmr_rcv_respond
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|,
name|IN
name|ib_member_rec_t
modifier|*
name|p_mcmember_rec
parameter_list|)
block|{
name|cl_qlist_t
name|rec_list
decl_stmt|;
name|osm_mcmr_item_t
modifier|*
name|item
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|item
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B16: "
literal|"rec_item alloc failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|item
operator|->
name|rec
operator|=
operator|*
name|p_mcmember_rec
expr_stmt|;
comment|/* Fill in the mtu, rate, and packet lifetime selectors */
name|item
operator|->
name|rec
operator|.
name|mtu
operator|&=
literal|0x3f
expr_stmt|;
name|item
operator|->
name|rec
operator|.
name|mtu
operator||=
literal|2
operator|<<
literal|6
expr_stmt|;
comment|/* exactly */
name|item
operator|->
name|rec
operator|.
name|rate
operator|&=
literal|0x3f
expr_stmt|;
name|item
operator|->
name|rec
operator|.
name|rate
operator||=
literal|2
operator|<<
literal|6
expr_stmt|;
comment|/* exactly */
name|item
operator|->
name|rec
operator|.
name|pkt_life
operator|&=
literal|0x3f
expr_stmt|;
name|item
operator|->
name|rec
operator|.
name|pkt_life
operator||=
literal|2
operator|<<
literal|6
expr_stmt|;
comment|/* exactly */
name|cl_qlist_init
argument_list|(
operator|&
name|rec_list
argument_list|)
expr_stmt|;
name|cl_qlist_insert_tail
argument_list|(
operator|&
name|rec_list
argument_list|,
operator|&
name|item
operator|->
name|list_item
argument_list|)
expr_stmt|;
name|osm_sa_respond
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_member_rec_t
argument_list|)
argument_list|,
operator|&
name|rec_list
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  In joining an existing group, or when querying the mc groups,  we make sure the following components provided match: MTU and RATE  HACK: Currently we ignore the PKT_LIFETIME field. **********************************************************************/
end_comment

begin_function
specifier|static
name|boolean_t
name|__validate_more_comp_fields
parameter_list|(
name|osm_log_t
modifier|*
name|p_log
parameter_list|,
specifier|const
name|osm_mgrp_t
modifier|*
name|p_mgrp
parameter_list|,
specifier|const
name|ib_member_rec_t
modifier|*
name|p_recvd_mcmember_rec
parameter_list|,
name|ib_net64_t
name|comp_mask
parameter_list|)
block|{
name|uint8_t
name|mtu_sel
decl_stmt|;
name|uint8_t
name|mtu_required
decl_stmt|;
name|uint8_t
name|mtu_mgrp
decl_stmt|;
name|uint8_t
name|rate_sel
decl_stmt|;
name|uint8_t
name|rate_required
decl_stmt|;
name|uint8_t
name|rate_mgrp
decl_stmt|;
if|if
condition|(
name|comp_mask
operator|&
name|IB_MCR_COMPMASK_MTU_SEL
condition|)
block|{
name|mtu_sel
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_recvd_mcmember_rec
operator|->
name|mtu
operator|>>
literal|6
argument_list|)
expr_stmt|;
comment|/* Clearing last 2 bits */
name|mtu_required
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_recvd_mcmember_rec
operator|->
name|mtu
operator|&
literal|0x3F
argument_list|)
expr_stmt|;
name|mtu_mgrp
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|mtu
operator|&
literal|0x3F
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mtu_sel
condition|)
block|{
case|case
literal|0
case|:
comment|/* Greater than MTU specified */
if|if
condition|(
name|mtu_mgrp
operator|<=
name|mtu_required
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Requested mcast group has MTU %x, "
literal|"which is not greater than %x\n"
argument_list|,
name|mtu_mgrp
argument_list|,
name|mtu_required
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
case|case
literal|1
case|:
comment|/* Less than MTU specified */
if|if
condition|(
name|mtu_mgrp
operator|>=
name|mtu_required
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Requested mcast group has MTU %x, "
literal|"which is not less than %x\n"
argument_list|,
name|mtu_mgrp
argument_list|,
name|mtu_required
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* Exactly MTU specified */
if|if
condition|(
name|mtu_mgrp
operator|!=
name|mtu_required
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Requested mcast group has MTU %x, "
literal|"which is not equal to %x\n"
argument_list|,
name|mtu_mgrp
argument_list|,
name|mtu_required
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
comment|/* what about rate ? */
if|if
condition|(
name|comp_mask
operator|&
name|IB_MCR_COMPMASK_RATE_SEL
condition|)
block|{
name|rate_sel
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_recvd_mcmember_rec
operator|->
name|rate
operator|>>
literal|6
argument_list|)
expr_stmt|;
comment|/* Clearing last 2 bits */
name|rate_required
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_recvd_mcmember_rec
operator|->
name|rate
operator|&
literal|0x3F
argument_list|)
expr_stmt|;
name|rate_mgrp
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|rate
operator|&
literal|0x3F
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rate_sel
condition|)
block|{
case|case
literal|0
case|:
comment|/* Greater than RATE specified */
if|if
condition|(
name|rate_mgrp
operator|<=
name|rate_required
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Requested mcast group has RATE %x, "
literal|"which is not greater than %x\n"
argument_list|,
name|rate_mgrp
argument_list|,
name|rate_required
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
case|case
literal|1
case|:
comment|/* Less than RATE specified */
if|if
condition|(
name|rate_mgrp
operator|>=
name|rate_required
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Requested mcast group has RATE %x, "
literal|"which is not less than %x\n"
argument_list|,
name|rate_mgrp
argument_list|,
name|rate_required
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* Exactly RATE specified */
if|if
condition|(
name|rate_mgrp
operator|!=
name|rate_required
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Requested mcast group has RATE %x, "
literal|"which is not equal to %x\n"
argument_list|,
name|rate_mgrp
argument_list|,
name|rate_required
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  In joining an existing group, we make sure the following components  are physically realizable: MTU and RATE **********************************************************************/
end_comment

begin_function
specifier|static
name|boolean_t
name|__validate_port_caps
parameter_list|(
name|osm_log_t
modifier|*
specifier|const
name|p_log
parameter_list|,
specifier|const
name|osm_mgrp_t
modifier|*
name|p_mgrp
parameter_list|,
specifier|const
name|osm_physp_t
modifier|*
name|p_physp
parameter_list|)
block|{
name|uint8_t
name|mtu_required
decl_stmt|;
name|uint8_t
name|mtu_mgrp
decl_stmt|;
name|uint8_t
name|rate_required
decl_stmt|;
name|uint8_t
name|rate_mgrp
decl_stmt|;
name|mtu_required
operator|=
name|ib_port_info_get_mtu_cap
argument_list|(
operator|&
name|p_physp
operator|->
name|port_info
argument_list|)
expr_stmt|;
name|mtu_mgrp
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|mtu
operator|&
literal|0x3F
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtu_required
operator|<
name|mtu_mgrp
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Port's MTU %x is less than %x\n"
argument_list|,
name|mtu_required
argument_list|,
name|mtu_mgrp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|rate_required
operator|=
name|ib_port_info_compute_rate
argument_list|(
operator|&
name|p_physp
operator|->
name|port_info
argument_list|)
expr_stmt|;
name|rate_mgrp
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|rate
operator|&
literal|0x3F
argument_list|)
expr_stmt|;
if|if
condition|(
name|rate_required
operator|<
name|rate_mgrp
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Port's RATE %x is less than %x\n"
argument_list|,
name|rate_required
argument_list|,
name|rate_mgrp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * o15-0.2.1: If SA supports UD multicast, then if SA receives a SubnAdmSet()  * or SubnAdmDelete() method that would modify an existing  * MCMemberRecord, SA shall not modify that MCMemberRecord and shall  * return an error status of ERR_REQ_INVALID in response in the  * following cases:  * 1. Saved MCMemberRecord.ProxyJoin is not set and the request is  * issued by a requester with a GID other than the Port-GID.  * 2. Saved MCMemberRecord.ProxyJoin is set and the requester is not  * part of the partition for that MCMemberRecord.  **********************************************************************/
end_comment

begin_function
specifier|static
name|boolean_t
name|__validate_modify
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
name|osm_mgrp_t
modifier|*
name|p_mgrp
parameter_list|,
name|IN
name|osm_mad_addr_t
modifier|*
name|p_mad_addr
parameter_list|,
name|IN
name|ib_member_rec_t
modifier|*
name|p_recvd_mcmember_rec
parameter_list|,
name|OUT
name|osm_mcm_port_t
modifier|*
modifier|*
name|pp_mcm_port
parameter_list|)
block|{
name|ib_net64_t
name|portguid
decl_stmt|;
name|ib_gid_t
name|request_gid
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_request_physp
decl_stmt|;
name|ib_api_status_t
name|res
decl_stmt|;
name|portguid
operator|=
name|p_recvd_mcmember_rec
operator|->
name|port_gid
operator|.
name|unicast
operator|.
name|interface_id
expr_stmt|;
operator|*
name|pp_mcm_port
operator|=
name|NULL
expr_stmt|;
comment|/* o15-0.2.1: If this is a new port being added - nothing to check */
if|if
condition|(
operator|!
name|osm_mgrp_is_port_present
argument_list|(
name|p_mgrp
argument_list|,
name|portguid
argument_list|,
name|pp_mcm_port
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"This is a new port in the MC group\n"
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
comment|/* We validate the request according the the proxy_join. 	   Check if the proxy_join is set or not */
if|if
condition|(
operator|(
operator|*
name|pp_mcm_port
operator|)
operator|->
name|proxy_join
operator|==
name|FALSE
condition|)
block|{
comment|/* The proxy_join is not set. Modifying can by done only 		   if the requester GID == PortGID */
name|res
operator|=
name|osm_get_gid_by_mad_addr
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|sa
operator|->
name|p_subn
argument_list|,
name|p_mad_addr
argument_list|,
operator|&
name|request_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Could not find port for requested address\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
operator|&
operator|(
operator|(
operator|*
name|pp_mcm_port
operator|)
operator|->
name|port_gid
operator|)
argument_list|,
operator|&
name|request_gid
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_gid_t
argument_list|)
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"No ProxyJoin but different ports: stored:"
literal|"0x%016"
name|PRIx64
literal|" request:0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
operator|(
operator|*
name|pp_mcm_port
operator|)
operator|->
name|port_gid
operator|.
name|unicast
operator|.
name|interface_id
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_mad_addr
operator|->
name|addr_type
operator|.
name|gsi
operator|.
name|grh_info
operator|.
name|src_gid
operator|.
name|unicast
operator|.
name|interface_id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
else|else
block|{
comment|/* The proxy_join is set. Modification allowed only if the 		   requester is part of the partition for this MCMemberRecord */
name|p_request_physp
operator|=
name|osm_get_physp_by_mad_addr
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|sa
operator|->
name|p_subn
argument_list|,
name|p_mad_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_request_physp
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|osm_physp_has_pkey
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|pkey
argument_list|,
name|p_request_physp
argument_list|)
condition|)
block|{
comment|/* the request port is not part of the partition for this mgrp */
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"ProxyJoin but port not in partition. stored:"
literal|"0x%016"
name|PRIx64
literal|" request:0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
operator|(
operator|*
name|pp_mcm_port
operator|)
operator|->
name|port_gid
operator|.
name|unicast
operator|.
name|interface_id
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_mad_addr
operator|->
name|addr_type
operator|.
name|gsi
operator|.
name|grh_info
operator|.
name|src_gid
operator|.
name|unicast
operator|.
name|interface_id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_comment
comment|/*  * Check legality of the requested MGID DELETE  * o15-0.1.14 = VALID DELETE:  * To be a valid delete MAD needs to:  * 1 the MADs PortGID and MGID components match the PortGID and  *   MGID of a stored MCMemberRecord;  * 2 the MADs JoinState component contains at least one bit set to 1  *   in the same position as that stored MCMemberRecords JoinState  *   has a bit set to 1,  *   i.e., the logical AND of the two JoinState components  *   is not all zeros;  * 3 the MADs JoinState component does not have some bits set  *   which are not set in the stored MCMemberRecords JoinState component;  * 4 either the stored MCMemberRecord:ProxyJoin is reset (0), and the  *   MADs source is the stored PortGID;  *   OR  *   the stored MCMemberRecord:ProxyJoin is set (1), (see o15-  *   0.1.2:); and the MADs source is a member of the partition indicated  *   by the stored MCMemberRecord:P_Key.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|__validate_delete
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
name|osm_mgrp_t
modifier|*
name|p_mgrp
parameter_list|,
name|IN
name|osm_mad_addr_t
modifier|*
name|p_mad_addr
parameter_list|,
name|IN
name|ib_member_rec_t
modifier|*
name|p_recvd_mcmember_rec
parameter_list|,
name|OUT
name|osm_mcm_port_t
modifier|*
modifier|*
name|pp_mcm_port
parameter_list|)
block|{
name|ib_net64_t
name|portguid
decl_stmt|;
name|portguid
operator|=
name|p_recvd_mcmember_rec
operator|->
name|port_gid
operator|.
name|unicast
operator|.
name|interface_id
expr_stmt|;
operator|*
name|pp_mcm_port
operator|=
name|NULL
expr_stmt|;
comment|/* 1 */
if|if
condition|(
operator|!
name|osm_mgrp_is_port_present
argument_list|(
name|p_mgrp
argument_list|,
name|portguid
argument_list|,
name|pp_mcm_port
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Failed to find the port in the MC group\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* 2 */
if|if
condition|(
operator|!
operator|(
name|p_recvd_mcmember_rec
operator|->
name|scope_state
operator|&
literal|0x0F
operator|&
operator|(
operator|*
name|pp_mcm_port
operator|)
operator|->
name|scope_state
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Could not find any matching bits in the stored "
literal|"and requested JoinStates\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* 3 */
if|if
condition|(
operator|(
operator|(
name|p_recvd_mcmember_rec
operator|->
name|scope_state
operator|&
literal|0x0F
operator|)
operator||
operator|(
literal|0x0F
operator|&
operator|(
operator|*
name|pp_mcm_port
operator|)
operator|->
name|scope_state
operator|)
operator|)
operator|!=
operator|(
literal|0x0F
operator|&
operator|(
operator|*
name|pp_mcm_port
operator|)
operator|->
name|scope_state
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Some bits in the request JoinState (0x%X) are not "
literal|"set in the stored port (0x%X)\n"
argument_list|,
operator|(
name|p_recvd_mcmember_rec
operator|->
name|scope_state
operator|&
literal|0x0F
operator|)
argument_list|,
operator|(
literal|0x0F
operator|&
operator|(
operator|*
name|pp_mcm_port
operator|)
operator|->
name|scope_state
operator|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* 4 */
comment|/* Validate according the the proxy_join (o15-0.1.2) */
if|if
condition|(
name|__validate_modify
argument_list|(
name|sa
argument_list|,
name|p_mgrp
argument_list|,
name|p_mad_addr
argument_list|,
name|p_recvd_mcmember_rec
argument_list|,
name|pp_mcm_port
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"proxy_join validation failure\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_comment
comment|/*  * Check legality of the requested MGID (note this does not hold for SA  * created MGIDs)  *  * Implementing o15-0.1.5:  * A multicast GID is considered to be invalid if:  * 1. It does not comply with the rules as specified in 4.1.1 "GID Usage and  *    Properties" on page 145:  *  * 14) The multicast GID format is (bytes are comma sep):  *     0xff,<Fl><Sc>,<Si>,<Si>,<P>,<P>,<P>,<P>,<P>,<P>,<P>,<P>,<Id>,<Id>,<Id>,<Id>  *     Fl  4bit = Flags (b)  *     Sc  4bit = Scope (c)  *     Si 16bit = Signature (2)  *     P  64bit = GID Prefix (should be a subnet unique ID - normally Subnet Prefix)  *     Id 32bit = Unique ID in the Subnet (might be MLID or Pkey ?)  *  *  a) 8-bits of 11111111 at the start of the GID identifies this as being a  *     multicast GID.  *  b) Flags is a set of four 1-bit flags: 000T with three flags reserved  *     and defined as zero (0). The T flag is defined as follows:  *     i) T = 0 indicates this is a permanently assigned (i.e. wellknown)  *        multicast GID. See RFC 2373 and RFC 2375 as reference  *        for these permanently assigned GIDs.  *     ii) T = 1 indicates this is a non-permanently assigned (i.e. transient)  *        multicast GID.  *  c) Scope is a 4-bit multicast scope value used to limit the scope of  *     the multicast group. The following table defines scope value and  *     interpretation.  *  *     Multicast Address Scope Values:  *     0x2 Link-local  *     0x5 Site-local  *     0x8 Organization-local  *     0xE Global  *  * 2. It contains the SA-specific signature of 0xA01B and has the link-local  *    scope bits set. (EZ: the idea here is that SA created MGIDs are the  *    only source for this signature with link-local scope)  */
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|__validate_requested_mgid
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|ib_member_rec_t
modifier|*
name|p_mcm_rec
parameter_list|)
block|{
name|uint16_t
name|signature
decl_stmt|;
name|boolean_t
name|valid
init|=
name|TRUE
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 14-a: mcast GID must start with 0xFF */
if|if
condition|(
name|p_mcm_rec
operator|->
name|mgid
operator|.
name|multicast
operator|.
name|header
index|[
literal|0
index|]
operator|!=
literal|0xFF
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B01: "
literal|"Wrong MGID Prefix 0x%02X must be 0xFF\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_mcm_rec
operator|->
name|mgid
operator|.
name|multicast
operator|.
name|header
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|valid
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* the MGID signature can mark IPoIB or SA assigned MGIDs */
name|memcpy
argument_list|(
operator|&
name|signature
argument_list|,
operator|&
operator|(
name|p_mcm_rec
operator|->
name|mgid
operator|.
name|multicast
operator|.
name|raw_group_id
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|signature
argument_list|)
argument_list|)
expr_stmt|;
name|signature
operator|=
name|cl_ntoh16
argument_list|(
name|signature
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"MGID Signed as 0x%04X\n"
argument_list|,
name|signature
argument_list|)
expr_stmt|;
comment|/* 	 * We skip any checks for MGIDs that follow IPoIB 	 * GID structure as defined by the IETF ipoib-link-multicast. 	 * 	 * For IPv4 over IB, the signature will be "0x401B". 	 * 	 * |   8    |  4 |  4 |     16 bits     | 16 bits | 48 bits  | 32 bits | 	 * +--------+----+----+-----------------+---------+----------+---------+ 	 * |11111111|0001|scop|<IPoIB signature>|< P_Key>|00.......0|<all 1's>| 	 * +--------+----+----+-----------------+---------+----------+---------+ 	 * 	 * For IPv6 over IB, the signature will be "0x601B". 	 * 	 * |   8    |  4 |  4 |     16 bits     | 16 bits |       80 bits      | 	 * +--------+----+----+-----------------+---------+--------------------+ 	 * |11111111|0001|scop|<IPoIB signature>|< P_Key>|000.............0001| 	 * +--------+----+----+-----------------+---------+--------------------+ 	 * 	 */
if|if
condition|(
name|signature
operator|==
literal|0x401B
operator|||
name|signature
operator|==
literal|0x601B
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Skipping MGID Validation for IPoIB Signed (0x%04X) MGIDs\n"
argument_list|,
name|signature
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 14-b: the 3 upper bits in the "flags" should be zero: */
if|if
condition|(
name|p_mcm_rec
operator|->
name|mgid
operator|.
name|multicast
operator|.
name|header
index|[
literal|1
index|]
operator|&
literal|0xE0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B28: "
literal|"MGID uses Reserved Flags: flags=0x%X\n"
argument_list|,
operator|(
name|p_mcm_rec
operator|->
name|mgid
operator|.
name|multicast
operator|.
name|header
index|[
literal|1
index|]
operator|&
literal|0xE0
operator|)
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|valid
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 2 - now what if the link local format 0xA01B is used - 	   the scope should not be link local */
if|if
condition|(
name|signature
operator|==
literal|0xA01B
operator|&&
operator|(
name|p_mcm_rec
operator|->
name|mgid
operator|.
name|multicast
operator|.
name|header
index|[
literal|1
index|]
operator|&
literal|0x0F
operator|)
operator|==
name|IB_MC_SCOPE_LINK_LOCAL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B24: "
literal|"MGID uses 0xA01B signature but with link-local scope\n"
argument_list|)
expr_stmt|;
name|valid
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	 * For SA assigned MGIDs (signature 0xA01B): 	 * There is no real way to make sure the Unique MGID Prefix is really unique. 	 * If we could enforce using the Subnet Prefix for that purpose it would 	 * have been nice. But the spec does not require it. 	 */
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|valid
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Check if the requested new MC group parameters are realizable.  Also set the default MTU and Rate if not provided by the user. **********************************************************************/
end_comment

begin_function
specifier|static
name|boolean_t
name|__mgrp_request_is_realizable
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
name|ib_net64_t
name|comp_mask
parameter_list|,
name|IN
name|ib_member_rec_t
modifier|*
name|p_mcm_rec
parameter_list|,
name|IN
specifier|const
name|osm_physp_t
modifier|*
specifier|const
name|p_physp
parameter_list|)
block|{
name|uint8_t
name|mtu_sel
init|=
literal|2
decl_stmt|;
comment|/* exactly */
name|uint8_t
name|mtu_required
decl_stmt|,
name|mtu
decl_stmt|,
name|port_mtu
decl_stmt|;
name|uint8_t
name|rate_sel
init|=
literal|2
decl_stmt|;
comment|/* exactly */
name|uint8_t
name|rate_required
decl_stmt|,
name|rate
decl_stmt|,
name|port_rate
decl_stmt|;
name|osm_log_t
modifier|*
name|p_log
init|=
name|sa
operator|->
name|p_log
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	 * End of o15-0.2.3 specifies: 	 * .... 	 * The entity may also supply the other components such as HopLimit, 	 * MTU, etc. during group creation time. If these components are not 	 * provided during group creation time, SA will provide them for the 	 * group. The values chosen are vendor-dependent and beyond the scope 	 * of the specification. 	 * 	 * so we might also need to assign RATE/MTU if they are not comp 	 * masked in. 	 */
name|port_mtu
operator|=
name|p_physp
condition|?
name|ib_port_info_get_mtu_cap
argument_list|(
operator|&
name|p_physp
operator|->
name|port_info
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|comp_mask
operator|&
name|IB_MCR_COMPMASK_MTU
operator|)
operator|||
operator|!
operator|(
name|comp_mask
operator|&
name|IB_MCR_COMPMASK_MTU_SEL
operator|)
operator|||
operator|(
name|mtu_sel
operator|=
operator|(
name|p_mcm_rec
operator|->
name|mtu
operator|>>
literal|6
operator|)
operator|)
operator|==
literal|3
condition|)
name|mtu
operator|=
name|port_mtu
condition|?
name|port_mtu
else|:
name|sa
operator|->
name|p_subn
operator|->
name|min_ca_mtu
expr_stmt|;
else|else
block|{
name|mtu_required
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_mcm_rec
operator|->
name|mtu
operator|&
literal|0x3F
argument_list|)
expr_stmt|;
name|mtu
operator|=
name|mtu_required
expr_stmt|;
switch|switch
condition|(
name|mtu_sel
condition|)
block|{
case|case
literal|0
case|:
comment|/* Greater than MTU specified */
if|if
condition|(
name|port_mtu
operator|&&
name|mtu_required
operator|>=
name|port_mtu
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Requested MTU %x>= the port\'s mtu:%x\n"
argument_list|,
name|mtu_required
argument_list|,
name|port_mtu
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* we provide the largest MTU possible if we can */
if|if
condition|(
name|port_mtu
condition|)
name|mtu
operator|=
name|port_mtu
expr_stmt|;
elseif|else
if|if
condition|(
name|mtu_required
operator|<
name|sa
operator|->
name|p_subn
operator|->
name|min_ca_mtu
condition|)
name|mtu
operator|=
name|sa
operator|->
name|p_subn
operator|->
name|min_ca_mtu
expr_stmt|;
else|else
name|mtu
operator|++
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Less than MTU specified */
comment|/* use the smaller of the two: 			   a. one lower then the required 			   b. the mtu of the requesting port (if exists) */
if|if
condition|(
name|port_mtu
operator|&&
name|mtu_required
operator|>
name|port_mtu
condition|)
name|mtu
operator|=
name|port_mtu
expr_stmt|;
else|else
name|mtu
operator|--
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Exactly MTU specified */
default|default:
break|break;
block|}
comment|/* make sure it still be in the range */
if|if
condition|(
name|mtu
operator|<
name|IB_MIN_MTU
operator|||
name|mtu
operator|>
name|IB_MAX_MTU
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Calculated MTU %x is out of range\n"
argument_list|,
name|mtu
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|p_mcm_rec
operator|->
name|mtu
operator|=
operator|(
name|mtu_sel
operator|<<
literal|6
operator|)
operator||
name|mtu
expr_stmt|;
name|port_rate
operator|=
name|p_physp
condition|?
name|ib_port_info_compute_rate
argument_list|(
operator|&
name|p_physp
operator|->
name|port_info
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|comp_mask
operator|&
name|IB_MCR_COMPMASK_RATE
operator|)
operator|||
operator|!
operator|(
name|comp_mask
operator|&
name|IB_MCR_COMPMASK_RATE_SEL
operator|)
operator|||
operator|(
name|rate_sel
operator|=
operator|(
name|p_mcm_rec
operator|->
name|rate
operator|>>
literal|6
operator|)
operator|)
operator|==
literal|3
condition|)
name|rate
operator|=
name|port_rate
condition|?
name|port_rate
else|:
name|sa
operator|->
name|p_subn
operator|->
name|min_ca_rate
expr_stmt|;
else|else
block|{
name|rate_required
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_mcm_rec
operator|->
name|rate
operator|&
literal|0x3F
argument_list|)
expr_stmt|;
name|rate
operator|=
name|rate_required
expr_stmt|;
switch|switch
condition|(
name|rate_sel
condition|)
block|{
case|case
literal|0
case|:
comment|/* Greater than RATE specified */
if|if
condition|(
name|port_rate
operator|&&
name|rate_required
operator|>=
name|port_rate
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Requested RATE %x>= the port\'s rate:%x\n"
argument_list|,
name|rate_required
argument_list|,
name|port_rate
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* we provide the largest RATE possible if we can */
if|if
condition|(
name|port_rate
condition|)
name|rate
operator|=
name|port_rate
expr_stmt|;
elseif|else
if|if
condition|(
name|rate_required
operator|<
name|sa
operator|->
name|p_subn
operator|->
name|min_ca_rate
condition|)
name|rate
operator|=
name|sa
operator|->
name|p_subn
operator|->
name|min_ca_rate
expr_stmt|;
else|else
name|rate
operator|++
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Less than RATE specified */
comment|/* use the smaller of the two: 			   a. one lower then the required 			   b. the rate of the requesting port (if exists) */
if|if
condition|(
name|port_rate
operator|&&
name|rate_required
operator|>
name|port_rate
condition|)
name|rate
operator|=
name|port_rate
expr_stmt|;
else|else
name|rate
operator|--
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Exactly RATE specified */
default|default:
break|break;
block|}
comment|/* make sure it still is in the range */
if|if
condition|(
name|rate
operator|<
name|IB_MIN_RATE
operator|||
name|rate
operator|>
name|IB_MAX_RATE
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Calculated RATE %x is out of range\n"
argument_list|,
name|rate
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|p_mcm_rec
operator|->
name|rate
operator|=
operator|(
name|rate_sel
operator|<<
literal|6
operator|)
operator||
name|rate
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Call this function to create a new mgrp. **********************************************************************/
end_comment

begin_function
name|ib_api_status_t
name|osm_mcmr_rcv_create_new_mgrp
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
name|ib_net64_t
name|comp_mask
parameter_list|,
name|IN
specifier|const
name|ib_member_rec_t
modifier|*
specifier|const
name|p_recvd_mcmember_rec
parameter_list|,
name|IN
specifier|const
name|osm_physp_t
modifier|*
specifier|const
name|p_physp
parameter_list|,
name|OUT
name|osm_mgrp_t
modifier|*
modifier|*
name|pp_mgrp
parameter_list|)
block|{
name|ib_net16_t
name|mlid
decl_stmt|;
name|unsigned
name|zero_mgid
decl_stmt|,
name|i
decl_stmt|;
name|uint8_t
name|scope
decl_stmt|;
name|ib_gid_t
modifier|*
name|p_mgid
decl_stmt|;
name|osm_mgrp_t
modifier|*
name|p_prev_mgrp
decl_stmt|;
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|ib_member_rec_t
name|mcm_rec
init|=
operator|*
name|p_recvd_mcmember_rec
decl_stmt|;
comment|/* copy for modifications */
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* but what if the given MGID was not 0 ? */
name|zero_mgid
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|p_recvd_mcmember_rec
operator|->
name|mgid
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|p_recvd_mcmember_rec
operator|->
name|mgid
operator|.
name|raw
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|zero_mgid
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 	   we allocate a new mlid number before we might use it 	   for MGID ... 	 */
name|mlid
operator|=
name|__get_new_mlid
argument_list|(
name|sa
argument_list|,
name|mcm_rec
operator|.
name|mlid
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlid
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B19: "
literal|"__get_new_mlid failed request mlid 0x%04x\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|mcm_rec
operator|.
name|mlid
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_SA_MAD_STATUS_NO_RESOURCES
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Obtained new mlid 0x%X\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|mlid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* we need to create the new MGID if it was not defined */
if|if
condition|(
name|zero_mgid
condition|)
block|{
comment|/* create a new MGID */
name|char
name|gid_str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
comment|/* use the given scope state only if requested! */
if|if
condition|(
name|comp_mask
operator|&
name|IB_MCR_COMPMASK_SCOPE
condition|)
name|ib_member_get_scope_state
argument_list|(
name|p_recvd_mcmember_rec
operator|->
name|scope_state
argument_list|,
operator|&
name|scope
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
comment|/* to guarantee no collision with other subnets use local scope! */
name|scope
operator|=
name|IB_MC_SCOPE_LINK_LOCAL
expr_stmt|;
name|p_mgid
operator|=
operator|&
operator|(
name|mcm_rec
operator|.
name|mgid
operator|)
expr_stmt|;
name|p_mgid
operator|->
name|raw
index|[
literal|0
index|]
operator|=
literal|0xFF
expr_stmt|;
name|p_mgid
operator|->
name|raw
index|[
literal|1
index|]
operator|=
literal|0x10
operator||
name|scope
expr_stmt|;
name|p_mgid
operator|->
name|raw
index|[
literal|2
index|]
operator|=
literal|0xA0
expr_stmt|;
name|p_mgid
operator|->
name|raw
index|[
literal|3
index|]
operator|=
literal|0x1B
expr_stmt|;
comment|/* HACK: use the SA port gid to make it globally unique */
name|memcpy
argument_list|(
operator|(
operator|&
name|p_mgid
operator|->
name|raw
index|[
literal|4
index|]
operator|)
argument_list|,
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|subnet_prefix
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* HACK: how do we get a unique number - use the mlid twice */
name|memcpy
argument_list|(
operator|&
name|p_mgid
operator|->
name|raw
index|[
literal|10
index|]
argument_list|,
operator|&
name|mlid
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_mgid
operator|->
name|raw
index|[
literal|12
index|]
argument_list|,
operator|&
name|mlid
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Allocated new MGID:%s\n"
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|p_mgid
operator|->
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
name|gid_str
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|__validate_requested_mgid
argument_list|(
name|sa
argument_list|,
operator|&
name|mcm_rec
argument_list|)
condition|)
block|{
comment|/* a specific MGID was requested so validate the resulting MGID */
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B22: "
literal|"Invalid requested MGID\n"
argument_list|)
expr_stmt|;
name|__free_mlid
argument_list|(
name|sa
argument_list|,
name|mlid
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_SA_MAD_STATUS_REQ_INVALID
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* check the requested parameters are realizable */
if|if
condition|(
name|__mgrp_request_is_realizable
argument_list|(
name|sa
argument_list|,
name|comp_mask
argument_list|,
operator|&
name|mcm_rec
argument_list|,
name|p_physp
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B26: "
literal|"Requested MGRP parameters are not realizable\n"
argument_list|)
expr_stmt|;
name|__free_mlid
argument_list|(
name|sa
argument_list|,
name|mlid
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_SA_MAD_STATUS_REQ_INVALID
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* create a new MC Group */
operator|*
name|pp_mgrp
operator|=
name|osm_mgrp_new
argument_list|(
name|mlid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pp_mgrp
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B08: "
literal|"osm_mgrp_new failed\n"
argument_list|)
expr_stmt|;
name|__free_mlid
argument_list|(
name|sa
argument_list|,
name|mlid
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_SA_MAD_STATUS_NO_RESOURCES
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Initialize the mgrp */
operator|(
operator|*
name|pp_mgrp
operator|)
operator|->
name|mcmember_rec
operator|=
name|mcm_rec
expr_stmt|;
operator|(
operator|*
name|pp_mgrp
operator|)
operator|->
name|mcmember_rec
operator|.
name|mlid
operator|=
name|mlid
expr_stmt|;
comment|/* the mcmember_record should have mtu_sel, rate_sel, and pkt_lifetime_sel = 2 */
operator|(
operator|*
name|pp_mgrp
operator|)
operator|->
name|mcmember_rec
operator|.
name|mtu
operator|&=
literal|0x3f
expr_stmt|;
operator|(
operator|*
name|pp_mgrp
operator|)
operator|->
name|mcmember_rec
operator|.
name|mtu
operator||=
literal|2
operator|<<
literal|6
expr_stmt|;
comment|/* exactly */
operator|(
operator|*
name|pp_mgrp
operator|)
operator|->
name|mcmember_rec
operator|.
name|rate
operator|&=
literal|0x3f
expr_stmt|;
operator|(
operator|*
name|pp_mgrp
operator|)
operator|->
name|mcmember_rec
operator|.
name|rate
operator||=
literal|2
operator|<<
literal|6
expr_stmt|;
comment|/* exactly */
operator|(
operator|*
name|pp_mgrp
operator|)
operator|->
name|mcmember_rec
operator|.
name|pkt_life
operator|&=
literal|0x3f
expr_stmt|;
operator|(
operator|*
name|pp_mgrp
operator|)
operator|->
name|mcmember_rec
operator|.
name|pkt_life
operator||=
literal|2
operator|<<
literal|6
expr_stmt|;
comment|/* exactly */
comment|/* Insert the new group in the data base */
comment|/* since we might have an old group by that mlid 	   one whose deletion was delayed for an idle time 	   we need to deallocate it first */
name|p_prev_mgrp
operator|=
name|osm_get_mgrp_by_mlid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|mlid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_prev_mgrp
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Found previous group for mlid:0x%04x - "
literal|"Destroying it first\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|mlid
argument_list|)
argument_list|)
expr_stmt|;
name|sa
operator|->
name|p_subn
operator|->
name|mgroups
index|[
name|cl_ntoh16
argument_list|(
name|mlid
argument_list|)
operator|-
name|IB_LID_MCAST_START_HO
index|]
operator|=
name|NULL
expr_stmt|;
name|osm_mgrp_delete
argument_list|(
name|p_prev_mgrp
argument_list|)
expr_stmt|;
block|}
name|sa
operator|->
name|p_subn
operator|->
name|mgroups
index|[
name|cl_ntoh16
argument_list|(
name|mlid
argument_list|)
operator|-
name|IB_LID_MCAST_START_HO
index|]
operator|=
operator|*
name|pp_mgrp
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  *********************************************************************/
end_comment

begin_function
specifier|static
name|unsigned
name|match_mgrp_by_mgid
parameter_list|(
name|IN
name|osm_mgrp_t
modifier|*
specifier|const
name|p_mgrp
parameter_list|,
name|ib_gid_t
modifier|*
name|mgid
parameter_list|)
block|{
comment|/* ignore groups marked for deletion */
if|if
condition|(
name|p_mgrp
operator|->
name|to_be_deleted
operator|||
name|memcmp
argument_list|(
operator|&
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|mgid
argument_list|,
name|mgid
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_gid_t
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_define
define|#
directive|define
name|PREFIX_MASK
value|CL_HTON64(0xff10ffff0000ffffULL)
end_define

begin_define
define|#
directive|define
name|PREFIX_SIGNATURE
value|CL_HTON64(0xff10601b00000000ULL)
end_define

begin_define
define|#
directive|define
name|INT_ID_MASK
value|CL_HTON64(0xfffffff1ff000000ULL)
end_define

begin_define
define|#
directive|define
name|INT_ID_SIGNATURE
value|CL_HTON64(0x00000001ff000000ULL)
end_define

begin_comment
comment|/* Special Case IPv6 Solicited Node Multicast (SNM) addresses */
end_comment

begin_comment
comment|/* 0xff1Z601bXXXX0000 : 0x00000001ffYYYYYY */
end_comment

begin_comment
comment|/* Where Z is the scope, XXXX is the P_Key, and  * YYYYYY is the last 24 bits of the port guid */
end_comment

begin_function
specifier|static
name|unsigned
name|match_and_update_ipv6_snm_mgid
parameter_list|(
name|ib_gid_t
modifier|*
name|mgid
parameter_list|)
block|{
if|if
condition|(
operator|(
name|mgid
operator|->
name|unicast
operator|.
name|prefix
operator|&
name|PREFIX_MASK
operator|)
operator|==
name|PREFIX_SIGNATURE
operator|&&
operator|(
name|mgid
operator|->
name|unicast
operator|.
name|interface_id
operator|&
name|INT_ID_MASK
operator|)
operator|==
name|INT_ID_SIGNATURE
condition|)
block|{
name|mgid
operator|->
name|unicast
operator|.
name|prefix
operator|&=
name|PREFIX_MASK
expr_stmt|;
name|mgid
operator|->
name|unicast
operator|.
name|interface_id
operator|&=
name|INT_ID_MASK
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|osm_mgrp_t
modifier|*
name|osm_get_mgrp_by_mgid
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
name|ib_gid_t
modifier|*
name|p_mgid
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|consolidate_ipv6_snm_req
operator|&&
name|match_and_update_ipv6_snm_mgid
argument_list|(
name|p_mgid
argument_list|)
condition|)
block|{
name|char
name|gid_str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Special Case Solicited Node Mcast Join for MGID %s\n"
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|p_mgid
operator|->
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
name|gid_str
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|sa
operator|->
name|p_subn
operator|->
name|max_mcast_lid_ho
operator|-
name|IB_LID_MCAST_START_HO
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sa
operator|->
name|p_subn
operator|->
name|mgroups
index|[
name|i
index|]
operator|&&
name|match_mgrp_by_mgid
argument_list|(
name|sa
operator|->
name|p_subn
operator|->
name|mgroups
index|[
name|i
index|]
argument_list|,
name|p_mgid
argument_list|)
condition|)
return|return
name|sa
operator|->
name|p_subn
operator|->
name|mgroups
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Call this function to find or create a new mgrp. **********************************************************************/
end_comment

begin_function
name|ib_api_status_t
name|osm_mcmr_rcv_find_or_create_new_mgrp
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
name|ib_net64_t
name|comp_mask
parameter_list|,
name|IN
name|ib_member_rec_t
modifier|*
specifier|const
name|p_recvd_mcmember_rec
parameter_list|,
name|OUT
name|osm_mgrp_t
modifier|*
modifier|*
name|pp_mgrp
parameter_list|)
block|{
name|osm_mgrp_t
modifier|*
name|mgrp
decl_stmt|;
if|if
condition|(
operator|(
name|mgrp
operator|=
name|osm_get_mgrp_by_mgid
argument_list|(
name|sa
argument_list|,
operator|&
name|p_recvd_mcmember_rec
operator|->
name|mgid
argument_list|)
operator|)
condition|)
block|{
operator|*
name|pp_mgrp
operator|=
name|mgrp
expr_stmt|;
return|return
name|IB_SUCCESS
return|;
block|}
return|return
name|osm_mcmr_rcv_create_new_mgrp
argument_list|(
name|sa
argument_list|,
name|comp_mask
argument_list|,
name|p_recvd_mcmember_rec
argument_list|,
name|NULL
argument_list|,
name|pp_mgrp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************* Process a request for leaving the group **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_mcmr_rcv_leave_mgrp
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|)
block|{
name|osm_mgrp_t
modifier|*
name|p_mgrp
decl_stmt|;
name|ib_sa_mad_t
modifier|*
name|p_sa_mad
decl_stmt|;
name|ib_member_rec_t
modifier|*
name|p_recvd_mcmember_rec
decl_stmt|;
name|ib_member_rec_t
name|mcmember_rec
decl_stmt|;
name|ib_net16_t
name|mlid
decl_stmt|;
name|ib_net64_t
name|portguid
decl_stmt|;
name|osm_mcm_port_t
modifier|*
name|p_mcm_port
decl_stmt|;
name|int
name|removed
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_sa_mad
operator|=
name|osm_madw_get_sa_mad_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_recvd_mcmember_rec
operator|=
operator|(
name|ib_member_rec_t
operator|*
operator|)
name|ib_sa_mad_get_payload_ptr
argument_list|(
name|p_sa_mad
argument_list|)
expr_stmt|;
name|mcmember_rec
operator|=
operator|*
name|p_recvd_mcmember_rec
expr_stmt|;
if|if
condition|(
name|osm_log_is_active
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Dump of record\n"
argument_list|)
expr_stmt|;
name|osm_dump_mc_record
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
operator|&
name|mcmember_rec
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
expr_stmt|;
block|}
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|p_mgrp
operator|=
name|osm_get_mgrp_by_mgid
argument_list|(
name|sa
argument_list|,
operator|&
name|p_recvd_mcmember_rec
operator|->
name|mgid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_mgrp
condition|)
block|{
name|char
name|gid_str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Failed since multicast group %s not present\n"
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|p_recvd_mcmember_rec
operator|->
name|mgid
operator|.
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
name|gid_str
argument_list|)
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|mlid
operator|=
name|p_mgrp
operator|->
name|mlid
expr_stmt|;
name|portguid
operator|=
name|p_recvd_mcmember_rec
operator|->
name|port_gid
operator|.
name|unicast
operator|.
name|interface_id
expr_stmt|;
comment|/* check validity of the delete request o15-0.1.14 */
if|if
condition|(
operator|!
name|__validate_delete
argument_list|(
name|sa
argument_list|,
name|p_mgrp
argument_list|,
name|osm_madw_get_mad_addr_ptr
argument_list|(
name|p_madw
argument_list|)
argument_list|,
name|p_recvd_mcmember_rec
argument_list|,
operator|&
name|p_mcm_port
argument_list|)
condition|)
block|{
name|char
name|gid_str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|char
name|gid_str2
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B25: "
literal|"Received an invalid delete request for "
literal|"MGID: %s for PortGID: %s\n"
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|p_recvd_mcmember_rec
operator|->
name|mgid
operator|.
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
name|gid_str
argument_list|)
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|p_recvd_mcmember_rec
operator|->
name|port_gid
operator|.
name|raw
argument_list|,
name|gid_str2
argument_list|,
sizeof|sizeof
name|gid_str2
argument_list|)
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* store state - we'll need it if the port is removed */
name|mcmember_rec
operator|.
name|scope_state
operator|=
name|p_mcm_port
operator|->
name|scope_state
expr_stmt|;
comment|/* remove port or update join state */
name|removed
operator|=
name|osm_mgrp_remove_port
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|sa
operator|->
name|p_log
argument_list|,
name|p_mgrp
argument_list|,
name|p_mcm_port
argument_list|,
name|p_recvd_mcmember_rec
operator|->
name|scope_state
operator|&
literal|0x0F
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|removed
condition|)
name|mcmember_rec
operator|.
name|scope_state
operator|=
name|p_mcm_port
operator|->
name|scope_state
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
comment|/* we can leave if port was deleted from MCG */
if|if
condition|(
name|removed
operator|&&
name|osm_sm_mcgrp_leave
argument_list|(
name|sa
operator|->
name|sm
argument_list|,
name|mlid
argument_list|,
name|portguid
argument_list|)
condition|)
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B09: "
literal|"osm_sm_mcgrp_leave failed\n"
argument_list|)
expr_stmt|;
comment|/* Send an SA response */
name|__osm_mcmr_rcv_respond
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
operator|&
name|mcmember_rec
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Handle a join (or create) request **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_mcmr_rcv_join_mgrp
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|)
block|{
name|osm_mgrp_t
modifier|*
name|p_mgrp
init|=
name|NULL
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|ib_sa_mad_t
modifier|*
name|p_sa_mad
decl_stmt|;
name|ib_member_rec_t
modifier|*
name|p_recvd_mcmember_rec
decl_stmt|;
name|ib_member_rec_t
name|mcmember_rec
decl_stmt|;
name|ib_net16_t
name|mlid
decl_stmt|;
name|osm_mcm_port_t
modifier|*
name|p_mcmr_port
decl_stmt|;
name|ib_net64_t
name|portguid
decl_stmt|;
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_request_physp
decl_stmt|;
name|uint8_t
name|is_new_group
decl_stmt|;
comment|/* TRUE = there is a need to create a group */
name|osm_mcast_req_type_t
name|req_type
decl_stmt|;
name|uint8_t
name|join_state
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_sa_mad
operator|=
name|osm_madw_get_sa_mad_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_recvd_mcmember_rec
operator|=
name|ib_sa_mad_get_payload_ptr
argument_list|(
name|p_sa_mad
argument_list|)
expr_stmt|;
name|portguid
operator|=
name|p_recvd_mcmember_rec
operator|->
name|port_gid
operator|.
name|unicast
operator|.
name|interface_id
expr_stmt|;
name|mcmember_rec
operator|=
operator|*
name|p_recvd_mcmember_rec
expr_stmt|;
if|if
condition|(
name|osm_log_is_active
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Dump of incoming record\n"
argument_list|)
expr_stmt|;
name|osm_dump_mc_record
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
operator|&
name|mcmember_rec
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
expr_stmt|;
block|}
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
comment|/* make sure the requested port guid is known to the SM */
name|p_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|portguid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
block|{
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Unknown port GUID 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|portguid
argument_list|)
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_physp
operator|=
name|p_port
operator|->
name|p_physp
expr_stmt|;
comment|/* Check that the p_physp and the requester physp are in the same 	   partition. */
name|p_request_physp
operator|=
name|osm_get_physp_by_mad_addr
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|sa
operator|->
name|p_subn
argument_list|,
name|osm_madw_get_mad_addr_ptr
argument_list|(
name|p_madw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_request_physp
operator|==
name|NULL
condition|)
block|{
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|!
name|osm_physp_share_pkey
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_physp
argument_list|,
name|p_request_physp
argument_list|)
condition|)
block|{
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Port and requester don't share pkey\n"
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|ib_member_get_scope_state
argument_list|(
name|p_recvd_mcmember_rec
operator|->
name|scope_state
argument_list|,
name|NULL
argument_list|,
operator|&
name|join_state
argument_list|)
expr_stmt|;
comment|/* do we need to create a new group? */
name|p_mgrp
operator|=
name|osm_get_mgrp_by_mgid
argument_list|(
name|sa
argument_list|,
operator|&
name|p_recvd_mcmember_rec
operator|->
name|mgid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_mgrp
operator|||
name|p_mgrp
operator|->
name|to_be_deleted
condition|)
block|{
comment|/* check for JoinState.FullMember = 1 o15.0.1.9 */
if|if
condition|(
operator|(
name|join_state
operator|&
literal|0x01
operator|)
operator|!=
literal|0x01
condition|)
block|{
name|char
name|gid_str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B10: "
literal|"Provided Join State != FullMember - "
literal|"required for create, "
literal|"MGID: %s from port 0x%016"
name|PRIx64
literal|" (%s)\n"
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|p_recvd_mcmember_rec
operator|->
name|mgid
operator|.
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
name|gid_str
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|portguid
argument_list|)
argument_list|,
name|p_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* check the comp_mask */
if|if
condition|(
operator|!
name|__check_create_comp_mask
argument_list|(
name|p_sa_mad
operator|->
name|comp_mask
argument_list|,
name|p_recvd_mcmember_rec
argument_list|)
condition|)
block|{
name|char
name|gid_str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B11: "
literal|"method = %s, scope_state = 0x%x, "
literal|"component mask = 0x%016"
name|PRIx64
literal|", "
literal|"expected comp mask = 0x%016"
name|PRIx64
literal|", "
literal|"MGID: %s from port 0x%016"
name|PRIx64
literal|" (%s)\n"
argument_list|,
name|ib_get_sa_method_str
argument_list|(
name|p_sa_mad
operator|->
name|method
argument_list|)
argument_list|,
name|p_recvd_mcmember_rec
operator|->
name|scope_state
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_sa_mad
operator|->
name|comp_mask
argument_list|)
argument_list|,
name|CL_NTOH64
argument_list|(
name|REQUIRED_MC_CREATE_COMP_MASK
argument_list|)
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|p_recvd_mcmember_rec
operator|->
name|mgid
operator|.
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
name|gid_str
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|portguid
argument_list|)
argument_list|,
name|p_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_INSUF_COMPS
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|status
operator|=
name|osm_mcmr_rcv_create_new_mgrp
argument_list|(
name|sa
argument_list|,
name|p_sa_mad
operator|->
name|comp_mask
argument_list|,
name|p_recvd_mcmember_rec
argument_list|,
name|p_physp
argument_list|,
operator|&
name|p_mgrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|status
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* copy the MGID to the result */
name|mcmember_rec
operator|.
name|mgid
operator|=
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|mgid
expr_stmt|;
name|is_new_group
operator|=
literal|1
expr_stmt|;
name|req_type
operator|=
name|OSM_MCAST_REQ_TYPE_CREATE
expr_stmt|;
block|}
else|else
block|{
comment|/* no need for a new group */
name|is_new_group
operator|=
literal|0
expr_stmt|;
name|req_type
operator|=
name|OSM_MCAST_REQ_TYPE_JOIN
expr_stmt|;
block|}
name|CL_ASSERT
argument_list|(
name|p_mgrp
argument_list|)
expr_stmt|;
name|mlid
operator|=
name|p_mgrp
operator|->
name|mlid
expr_stmt|;
comment|/* 	 * o15-0.2.4: If SA supports UD multicast, then SA shall cause an 	 * endport to join an existing multicast group if: 	 * 1. It receives a SubnAdmSet() method for a MCMemberRecord, and 	 *    - WE KNOW THAT ALREADY 	 * 2. The MGID is specified and matches an existing multicast 	 *    group, and 	 *    - WE KNOW THAT ALREADY 	 * 3. The MCMemberRecord:JoinState is not all 0s, and 	 * 4. PortGID is specified and 	 *    - WE KNOW THAT ALREADY (as it matched a real one) 	 * 5. All other components match that existing group, either by 	 *    being wildcarded or by having values identical to those specified 	 *    by the component mask and in use by the group with the exception 	 *    of components such as ProxyJoin and Reserved, which are ignored 	 *    by SA. 	 * 	 * We need to check #3 and #5 here: 	 */
if|if
condition|(
operator|!
name|__validate_more_comp_fields
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_mgrp
argument_list|,
name|p_recvd_mcmember_rec
argument_list|,
name|p_sa_mad
operator|->
name|comp_mask
argument_list|)
operator|||
operator|!
name|__validate_port_caps
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_mgrp
argument_list|,
name|p_physp
argument_list|)
operator|||
operator|!
operator|(
name|join_state
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* since we might have created the new group we need to cleanup */
name|__cleanup_mgrp
argument_list|(
name|sa
argument_list|,
name|p_mgrp
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B12: "
literal|"__validate_more_comp_fields, __validate_port_caps, "
literal|"or JoinState = 0 failed from port 0x%016"
name|PRIx64
literal|" (%s), "
literal|"sending IB_SA_MAD_STATUS_REQ_INVALID\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|portguid
argument_list|)
argument_list|,
name|p_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	 * o15-0.2.1 requires validation of the requesting port 	 * in the case of modification: 	 */
if|if
condition|(
operator|!
name|is_new_group
operator|&&
operator|!
name|__validate_modify
argument_list|(
name|sa
argument_list|,
name|p_mgrp
argument_list|,
name|osm_madw_get_mad_addr_ptr
argument_list|(
name|p_madw
argument_list|)
argument_list|,
name|p_recvd_mcmember_rec
argument_list|,
operator|&
name|p_mcmr_port
argument_list|)
condition|)
block|{
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B13: "
literal|"__validate_modify failed from port 0x%016"
name|PRIx64
literal|" (%s), sending IB_SA_MAD_STATUS_REQ_INVALID\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|portguid
argument_list|)
argument_list|,
name|p_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* create or update existing port (join-state will be updated) */
name|status
operator|=
name|__add_new_mgrp_port
argument_list|(
name|sa
argument_list|,
name|p_mgrp
argument_list|,
name|p_recvd_mcmember_rec
argument_list|,
name|osm_madw_get_mad_addr_ptr
argument_list|(
name|p_madw
argument_list|)
argument_list|,
operator|&
name|p_mcmr_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
comment|/* we fail to add the port so we might need to delete the group */
name|__cleanup_mgrp
argument_list|(
name|sa
argument_list|,
name|p_mgrp
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|status
operator|==
name|IB_INVALID_PARAMETER
condition|?
name|IB_SA_MAD_STATUS_REQ_INVALID
else|:
name|IB_SA_MAD_STATUS_NO_RESOURCES
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* o15.0.1.11: copy the join state */
name|mcmember_rec
operator|.
name|scope_state
operator|=
name|p_mcmr_port
operator|->
name|scope_state
expr_stmt|;
comment|/* copy qkey mlid tclass pkey sl_flow_hop mtu rate pkt_life sl_flow_hop */
name|__copy_from_create_mc_rec
argument_list|(
operator|&
name|mcmember_rec
argument_list|,
operator|&
name|p_mgrp
operator|->
name|mcmember_rec
argument_list|)
expr_stmt|;
comment|/* Release the lock as we don't need it. */
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
comment|/* do the actual routing (actually schedule the update) */
name|status
operator|=
name|osm_sm_mcgrp_join
argument_list|(
name|sa
operator|->
name|sm
argument_list|,
name|mlid
argument_list|,
name|p_recvd_mcmember_rec
operator|->
name|port_gid
operator|.
name|unicast
operator|.
name|interface_id
argument_list|,
name|req_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B14: "
literal|"osm_sm_mcgrp_join failed from port 0x%016"
name|PRIx64
literal|" (%s), "
literal|"sending IB_SA_MAD_STATUS_NO_RESOURCES\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|portguid
argument_list|)
argument_list|,
name|p_port
operator|->
name|p_node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
name|CL_PLOCK_EXCL_ACQUIRE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
comment|/* the request for routing failed so we need to remove the port */
name|osm_mgrp_delete_port
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|sa
operator|->
name|p_log
argument_list|,
name|p_mgrp
argument_list|,
name|p_recvd_mcmember_rec
operator|->
name|port_gid
operator|.
name|unicast
operator|.
name|interface_id
argument_list|)
expr_stmt|;
name|__cleanup_mgrp
argument_list|(
name|sa
argument_list|,
name|p_mgrp
argument_list|)
expr_stmt|;
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_NO_RESOURCES
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* failed to route */
if|if
condition|(
name|osm_log_is_active
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
name|osm_dump_mc_record
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
operator|&
name|mcmember_rec
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
expr_stmt|;
name|__osm_mcmr_rcv_respond
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
operator|&
name|mcmember_rec
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Add a patched multicast group to the results list **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|__osm_mcmr_rcv_new_mcmr
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|ib_member_rec_t
modifier|*
name|p_rcvd_rec
parameter_list|,
name|IN
name|cl_qlist_t
modifier|*
specifier|const
name|p_list
parameter_list|)
block|{
name|osm_mcmr_item_t
modifier|*
name|p_rec_item
decl_stmt|;
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_rec_item
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p_rec_item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_rec_item
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B15: "
literal|"rec_item alloc failed\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_INSUFFICIENT_RESOURCES
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|memset
argument_list|(
name|p_rec_item
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_rec_item
argument_list|)
argument_list|)
expr_stmt|;
comment|/* HACK: Untrusted requesters should result with 0 Join 	   State, Port Guid, and Proxy */
name|p_rec_item
operator|->
name|rec
operator|=
operator|*
name|p_rcvd_rec
expr_stmt|;
name|cl_qlist_insert_tail
argument_list|(
name|p_list
argument_list|,
operator|&
name|p_rec_item
operator|->
name|list_item
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Match the given mgrp to the requested mcmr **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|mcmr_by_comp_mask
parameter_list|(
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
specifier|const
name|ib_member_rec_t
modifier|*
name|p_rcvd_rec
parameter_list|,
name|ib_net64_t
name|comp_mask
parameter_list|,
name|osm_mgrp_t
modifier|*
name|p_mgrp
parameter_list|,
specifier|const
name|osm_physp_t
modifier|*
name|p_req_physp
parameter_list|,
name|boolean_t
name|trusted_req
parameter_list|,
name|cl_qlist_t
modifier|*
name|list
parameter_list|)
block|{
comment|/* since we might change scope_state */
name|ib_member_rec_t
name|match_rec
decl_stmt|;
name|osm_mcm_port_t
modifier|*
name|p_mcm_port
decl_stmt|;
name|ib_net64_t
name|portguid
init|=
name|p_rcvd_rec
operator|->
name|port_gid
operator|.
name|unicast
operator|.
name|interface_id
decl_stmt|;
comment|/* will be used for group or port info */
name|uint8_t
name|scope_state
decl_stmt|;
name|uint8_t
name|scope_state_mask
init|=
literal|0
decl_stmt|;
name|cl_map_item_t
modifier|*
name|p_item
decl_stmt|;
name|ib_gid_t
name|port_gid
decl_stmt|;
name|boolean_t
name|proxy_join
init|=
name|FALSE
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Checking mlid:0x%X\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_mgrp
operator|->
name|mlid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* the group might be marked for deletion */
if|if
condition|(
name|p_mgrp
operator|->
name|to_be_deleted
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Group mlid:0x%X is marked to be deleted\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_mgrp
operator|->
name|mlid
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* first try to eliminate the group by MGID, MLID, or P_Key */
if|if
condition|(
operator|(
name|IB_MCR_COMPMASK_MGID
operator|&
name|comp_mask
operator|)
operator|&&
name|memcmp
argument_list|(
operator|&
name|p_rcvd_rec
operator|->
name|mgid
argument_list|,
operator|&
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|mgid
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_gid_t
argument_list|)
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
operator|(
name|IB_MCR_COMPMASK_MLID
operator|&
name|comp_mask
operator|)
operator|&&
name|memcmp
argument_list|(
operator|&
name|p_rcvd_rec
operator|->
name|mlid
argument_list|,
operator|&
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|mlid
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* if the requester physical port doesn't have the pkey that is defined 	   for the group - exit. */
if|if
condition|(
operator|!
name|osm_physp_has_pkey
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|pkey
argument_list|,
name|p_req_physp
argument_list|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* now do the rest of the match */
if|if
condition|(
operator|(
name|IB_MCR_COMPMASK_QKEY
operator|&
name|comp_mask
operator|)
operator|&&
name|p_rcvd_rec
operator|->
name|qkey
operator|!=
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|qkey
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
operator|(
name|IB_MCR_COMPMASK_PKEY
operator|&
name|comp_mask
operator|)
operator|&&
name|p_rcvd_rec
operator|->
name|pkey
operator|!=
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|pkey
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
operator|(
name|IB_MCR_COMPMASK_TCLASS
operator|&
name|comp_mask
operator|)
operator|&&
name|p_rcvd_rec
operator|->
name|tclass
operator|!=
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|tclass
condition|)
goto|goto
name|Exit
goto|;
comment|/* check SL, Flow, and Hop limit */
block|{
name|uint8_t
name|mgrp_sl
decl_stmt|,
name|query_sl
decl_stmt|;
name|uint32_t
name|mgrp_flow
decl_stmt|,
name|query_flow
decl_stmt|;
name|uint8_t
name|mgrp_hop
decl_stmt|,
name|query_hop
decl_stmt|;
name|ib_member_get_sl_flow_hop
argument_list|(
name|p_rcvd_rec
operator|->
name|sl_flow_hop
argument_list|,
operator|&
name|query_sl
argument_list|,
operator|&
name|query_flow
argument_list|,
operator|&
name|query_hop
argument_list|)
expr_stmt|;
name|ib_member_get_sl_flow_hop
argument_list|(
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|sl_flow_hop
argument_list|,
operator|&
name|mgrp_sl
argument_list|,
operator|&
name|mgrp_flow
argument_list|,
operator|&
name|mgrp_hop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|IB_MCR_COMPMASK_SL
operator|&
name|comp_mask
operator|)
operator|&&
name|query_sl
operator|!=
name|mgrp_sl
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
operator|(
name|IB_MCR_COMPMASK_FLOW
operator|&
name|comp_mask
operator|)
operator|&&
name|query_flow
operator|!=
name|mgrp_flow
condition|)
goto|goto
name|Exit
goto|;
if|if
condition|(
operator|(
name|IB_MCR_COMPMASK_HOP
operator|&
name|comp_mask
operator|)
operator|&&
name|query_hop
operator|!=
name|mgrp_hop
condition|)
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|(
name|IB_MCR_COMPMASK_PROXY
operator|&
name|comp_mask
operator|)
operator|&&
name|p_rcvd_rec
operator|->
name|proxy_join
operator|!=
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|proxy_join
condition|)
goto|goto
name|Exit
goto|;
comment|/* need to validate mtu, rate, and pkt_lifetime fields */
if|if
condition|(
name|__validate_more_comp_fields
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_mgrp
argument_list|,
name|p_rcvd_rec
argument_list|,
name|comp_mask
argument_list|)
operator|==
name|FALSE
condition|)
goto|goto
name|Exit
goto|;
comment|/* Port specific fields */
comment|/* so did we get the PortGUID mask */
if|if
condition|(
name|IB_MCR_COMPMASK_PORT_GID
operator|&
name|comp_mask
condition|)
block|{
comment|/* try to find this port */
if|if
condition|(
name|osm_mgrp_is_port_present
argument_list|(
name|p_mgrp
argument_list|,
name|portguid
argument_list|,
operator|&
name|p_mcm_port
argument_list|)
condition|)
block|{
name|scope_state
operator|=
name|p_mcm_port
operator|->
name|scope_state
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|port_gid
argument_list|,
operator|&
operator|(
name|p_mcm_port
operator|->
name|port_gid
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_gid_t
argument_list|)
argument_list|)
expr_stmt|;
name|proxy_join
operator|=
name|p_mcm_port
operator|->
name|proxy_join
expr_stmt|;
block|}
else|else
block|{
comment|/* port not in group */
goto|goto
name|Exit
goto|;
block|}
block|}
else|else
block|{
comment|/* point to the group information */
name|scope_state
operator|=
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|scope_state
expr_stmt|;
block|}
if|if
condition|(
name|IB_MCR_COMPMASK_SCOPE
operator|&
name|comp_mask
condition|)
name|scope_state_mask
operator|=
literal|0xF0
expr_stmt|;
if|if
condition|(
name|IB_MCR_COMPMASK_JOIN_STATE
operator|&
name|comp_mask
condition|)
name|scope_state_mask
operator|=
name|scope_state_mask
operator||
literal|0x0F
expr_stmt|;
comment|/* Many MC records returned */
if|if
condition|(
name|trusted_req
operator|==
name|TRUE
operator|&&
operator|!
operator|(
name|IB_MCR_COMPMASK_PORT_GID
operator|&
name|comp_mask
operator|)
condition|)
block|{
name|char
name|gid_str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Trusted req is TRUE and no specific port defined\n"
argument_list|)
expr_stmt|;
comment|/* return all the ports that match in this MC group */
name|p_item
operator|=
name|cl_qmap_head
argument_list|(
operator|&
operator|(
name|p_mgrp
operator|->
name|mcm_port_tbl
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_item
operator|!=
name|cl_qmap_end
argument_list|(
operator|&
operator|(
name|p_mgrp
operator|->
name|mcm_port_tbl
operator|)
argument_list|)
condition|)
block|{
name|p_mcm_port
operator|=
operator|(
name|osm_mcm_port_t
operator|*
operator|)
name|p_item
expr_stmt|;
if|if
condition|(
operator|(
name|scope_state_mask
operator|&
name|p_rcvd_rec
operator|->
name|scope_state
operator|)
operator|==
operator|(
name|scope_state_mask
operator|&
name|p_mcm_port
operator|->
name|scope_state
operator|)
condition|)
block|{
comment|/* add to the list */
name|match_rec
operator|=
name|p_mgrp
operator|->
name|mcmember_rec
expr_stmt|;
name|match_rec
operator|.
name|scope_state
operator|=
name|p_mcm_port
operator|->
name|scope_state
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
name|match_rec
operator|.
name|port_gid
operator|)
argument_list|,
operator|&
operator|(
name|p_mcm_port
operator|->
name|port_gid
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_gid_t
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Record of port_gid: %s"
literal|" in multicast_lid: 0x%X is returned\n"
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|match_rec
operator|.
name|port_gid
operator|.
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
name|gid_str
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_mgrp
operator|->
name|mlid
argument_list|)
argument_list|)
expr_stmt|;
name|match_rec
operator|.
name|proxy_join
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_mcm_port
operator|->
name|proxy_join
argument_list|)
expr_stmt|;
name|__osm_mcmr_rcv_new_mcmr
argument_list|(
name|sa
argument_list|,
operator|&
name|match_rec
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|p_item
operator|=
name|cl_qmap_next
argument_list|(
name|p_item
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* One MC record returned */
else|else
block|{
if|if
condition|(
operator|(
name|scope_state_mask
operator|&
name|p_rcvd_rec
operator|->
name|scope_state
operator|)
operator|!=
operator|(
name|scope_state_mask
operator|&
name|scope_state
operator|)
condition|)
goto|goto
name|Exit
goto|;
comment|/* add to the list */
name|match_rec
operator|=
name|p_mgrp
operator|->
name|mcmember_rec
expr_stmt|;
name|match_rec
operator|.
name|scope_state
operator|=
name|scope_state
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
name|match_rec
operator|.
name|port_gid
operator|)
argument_list|,
operator|&
name|port_gid
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_gid_t
argument_list|)
argument_list|)
expr_stmt|;
name|match_rec
operator|.
name|proxy_join
operator|=
operator|(
name|uint8_t
operator|)
name|proxy_join
expr_stmt|;
name|__osm_mcmr_rcv_new_mcmr
argument_list|(
name|sa
argument_list|,
operator|&
name|match_rec
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  Handle a query request **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_mcmr_query_mgrp
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|)
block|{
specifier|const
name|ib_sa_mad_t
modifier|*
name|p_rcvd_mad
decl_stmt|;
specifier|const
name|ib_member_rec_t
modifier|*
name|p_rcvd_rec
decl_stmt|;
name|cl_qlist_t
name|rec_list
decl_stmt|;
name|ib_net64_t
name|comp_mask
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_req_physp
decl_stmt|;
name|boolean_t
name|trusted_req
decl_stmt|;
name|osm_mgrp_t
modifier|*
name|p_mgrp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_rcvd_mad
operator|=
name|osm_madw_get_sa_mad_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_rcvd_rec
operator|=
operator|(
name|ib_member_rec_t
operator|*
operator|)
name|ib_sa_mad_get_payload_ptr
argument_list|(
name|p_rcvd_mad
argument_list|)
expr_stmt|;
name|comp_mask
operator|=
name|p_rcvd_mad
operator|->
name|comp_mask
expr_stmt|;
comment|/* 	   if sm_key is not zero and does not match we never get here 	   see main SA receiver 	 */
name|trusted_req
operator|=
operator|(
name|p_rcvd_mad
operator|->
name|sm_key
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* update the requester physical port. */
name|p_req_physp
operator|=
name|osm_get_physp_by_mad_addr
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|sa
operator|->
name|p_subn
argument_list|,
name|osm_madw_get_mad_addr_ptr
argument_list|(
name|p_madw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_req_physp
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B04: "
literal|"Cannot find requester physical port\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|cl_qlist_init
argument_list|(
operator|&
name|rec_list
argument_list|)
expr_stmt|;
name|CL_PLOCK_ACQUIRE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
comment|/* simply go over all MCGs and match */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|sa
operator|->
name|p_subn
operator|->
name|max_mcast_lid_ho
operator|-
name|IB_LID_MCAST_START_HO
condition|;
name|i
operator|++
control|)
block|{
name|p_mgrp
operator|=
name|sa
operator|->
name|p_subn
operator|->
name|mgroups
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p_mgrp
condition|)
name|mcmr_by_comp_mask
argument_list|(
name|sa
argument_list|,
name|p_rcvd_rec
argument_list|,
name|comp_mask
argument_list|,
name|p_mgrp
argument_list|,
name|p_req_physp
argument_list|,
name|trusted_req
argument_list|,
operator|&
name|rec_list
argument_list|)
expr_stmt|;
block|}
name|CL_PLOCK_RELEASE
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
comment|/* 	   p923 - The PortGID, JoinState and ProxyJoin shall be zero, 	   except in the case of a trusted request. 	   Note: In the mad controller we check that the SM_Key received on 	   the mad is valid. Meaning - is either zero or equal to the local 	   sm_key. 	 */
if|if
condition|(
operator|!
name|p_rcvd_mad
operator|->
name|sm_key
condition|)
block|{
name|osm_mcmr_item_t
modifier|*
name|item
decl_stmt|;
for|for
control|(
name|item
operator|=
operator|(
name|osm_mcmr_item_t
operator|*
operator|)
name|cl_qlist_head
argument_list|(
operator|&
name|rec_list
argument_list|)
init|;
name|item
operator|!=
operator|(
name|osm_mcmr_item_t
operator|*
operator|)
name|cl_qlist_end
argument_list|(
operator|&
name|rec_list
argument_list|)
condition|;
name|item
operator|=
operator|(
name|osm_mcmr_item_t
operator|*
operator|)
name|cl_qlist_next
argument_list|(
operator|&
name|item
operator|->
name|list_item
argument_list|)
control|)
block|{
name|memset
argument_list|(
operator|&
name|item
operator|->
name|rec
operator|.
name|port_gid
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_gid_t
argument_list|)
argument_list|)
expr_stmt|;
name|ib_member_set_join_state
argument_list|(
operator|&
name|item
operator|->
name|rec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|item
operator|->
name|rec
operator|.
name|proxy_join
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|osm_sa_respond
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_member_rec_t
argument_list|)
argument_list|,
operator|&
name|rec_list
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|void
name|osm_mcmr_rcv_process
parameter_list|(
name|IN
name|void
modifier|*
name|context
parameter_list|,
name|IN
name|void
modifier|*
name|data
parameter_list|)
block|{
name|osm_sa_t
modifier|*
name|sa
init|=
name|context
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_madw
init|=
name|data
decl_stmt|;
name|ib_sa_mad_t
modifier|*
name|p_sa_mad
decl_stmt|;
name|ib_member_rec_t
modifier|*
name|p_recvd_mcmember_rec
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|sa
argument_list|)
expr_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_sa_mad
operator|=
name|osm_madw_get_sa_mad_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_recvd_mcmember_rec
operator|=
operator|(
name|ib_member_rec_t
operator|*
operator|)
name|ib_sa_mad_get_payload_ptr
argument_list|(
name|p_sa_mad
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_sa_mad
operator|->
name|attr_id
operator|==
name|IB_MAD_ATTR_MCMEMBER_RECORD
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p_sa_mad
operator|->
name|method
condition|)
block|{
case|case
name|IB_MAD_METHOD_SET
case|:
if|if
condition|(
operator|!
name|__check_join_comp_mask
argument_list|(
name|p_sa_mad
operator|->
name|comp_mask
argument_list|)
condition|)
block|{
name|char
name|gid_str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|char
name|gid_str2
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B18: "
literal|"component mask = 0x%016"
name|PRIx64
literal|", "
literal|"expected comp mask = 0x%016"
name|PRIx64
literal|", "
literal|"MGID: %s for PortGID: %s\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_sa_mad
operator|->
name|comp_mask
argument_list|)
argument_list|,
name|CL_NTOH64
argument_list|(
name|JOIN_MC_COMP_MASK
argument_list|)
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|p_recvd_mcmember_rec
operator|->
name|mgid
operator|.
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
name|gid_str
argument_list|)
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|p_recvd_mcmember_rec
operator|->
name|port_gid
operator|.
name|raw
argument_list|,
name|gid_str2
argument_list|,
sizeof|sizeof
name|gid_str2
argument_list|)
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 		 * Join or Create Multicast Group 		 */
name|__osm_mcmr_rcv_join_mgrp
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_MAD_METHOD_DELETE
case|:
if|if
condition|(
operator|!
name|__check_join_comp_mask
argument_list|(
name|p_sa_mad
operator|->
name|comp_mask
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B20: "
literal|"component mask = 0x%016"
name|PRIx64
literal|", "
literal|"expected comp mask = 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_sa_mad
operator|->
name|comp_mask
argument_list|)
argument_list|,
name|CL_NTOH64
argument_list|(
name|JOIN_MC_COMP_MASK
argument_list|)
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_SA_MAD_STATUS_REQ_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 		 * Leave Multicast Group 		 */
name|__osm_mcmr_rcv_leave_mgrp
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_MAD_METHOD_GET
case|:
case|case
name|IB_MAD_METHOD_GETTABLE
case|:
comment|/* 		 * Querying a Multicast Group 		 */
name|__osm_mcmr_query_mgrp
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
break|break;
default|default:
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1B21: "
literal|"Unsupported Method (%s)\n"
argument_list|,
name|ib_get_sa_method_str
argument_list|(
name|p_sa_mad
operator|->
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_MAD_STATUS_UNSUP_METHOD_ATTR
argument_list|)
expr_stmt|;
break|break;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

