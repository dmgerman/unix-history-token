begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2008 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2006 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of opensm pkey manipulation functions.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_pkey.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_port.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_node.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_switch.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|void
name|osm_pkey_tbl_construct
parameter_list|(
name|IN
name|osm_pkey_tbl_t
modifier|*
name|p_pkey_tbl
parameter_list|)
block|{
name|cl_ptr_vector_construct
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|blocks
argument_list|)
expr_stmt|;
name|cl_ptr_vector_construct
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|new_blocks
argument_list|)
expr_stmt|;
name|cl_map_construct
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|keys
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|void
name|osm_pkey_tbl_destroy
parameter_list|(
name|IN
name|osm_pkey_tbl_t
modifier|*
name|p_pkey_tbl
parameter_list|)
block|{
name|ib_pkey_table_t
modifier|*
name|p_block
decl_stmt|;
name|uint16_t
name|num_blocks
decl_stmt|,
name|i
decl_stmt|;
name|num_blocks
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|blocks
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|p_block
operator|=
name|cl_ptr_vector_get
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|blocks
argument_list|,
name|i
argument_list|)
operator|)
condition|)
name|free
argument_list|(
name|p_block
argument_list|)
expr_stmt|;
name|cl_ptr_vector_destroy
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|blocks
argument_list|)
expr_stmt|;
name|num_blocks
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|new_blocks
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|p_block
operator|=
name|cl_ptr_vector_get
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|new_blocks
argument_list|,
name|i
argument_list|)
operator|)
condition|)
name|free
argument_list|(
name|p_block
argument_list|)
expr_stmt|;
name|cl_ptr_vector_destroy
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|new_blocks
argument_list|)
expr_stmt|;
name|cl_map_remove_all
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|keys
argument_list|)
expr_stmt|;
name|cl_map_destroy
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|keys
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|ib_api_status_t
name|osm_pkey_tbl_init
parameter_list|(
name|IN
name|osm_pkey_tbl_t
modifier|*
name|p_pkey_tbl
parameter_list|)
block|{
name|cl_ptr_vector_init
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|blocks
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cl_ptr_vector_init
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|new_blocks
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cl_map_init
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|keys
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cl_qlist_init
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|pending
argument_list|)
expr_stmt|;
name|p_pkey_tbl
operator|->
name|used_blocks
operator|=
literal|0
expr_stmt|;
name|p_pkey_tbl
operator|->
name|max_blocks
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|IB_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|void
name|osm_pkey_tbl_init_new_blocks
parameter_list|(
name|IN
specifier|const
name|osm_pkey_tbl_t
modifier|*
name|p_pkey_tbl
parameter_list|)
block|{
name|ib_pkey_table_t
modifier|*
name|p_block
decl_stmt|;
name|size_t
name|b
decl_stmt|,
name|num_blocks
init|=
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|new_blocks
argument_list|)
decl_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|num_blocks
condition|;
name|b
operator|++
control|)
if|if
condition|(
operator|(
name|p_block
operator|=
name|cl_ptr_vector_get
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|new_blocks
argument_list|,
name|b
argument_list|)
operator|)
condition|)
name|memset
argument_list|(
name|p_block
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_block
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|void
name|osm_pkey_tbl_cleanup_pending
parameter_list|(
name|IN
name|osm_pkey_tbl_t
modifier|*
name|p_pkey_tbl
parameter_list|)
block|{
name|cl_list_item_t
modifier|*
name|p_item
decl_stmt|;
name|p_item
operator|=
name|cl_qlist_remove_head
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|pending
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_item
operator|!=
name|cl_qlist_end
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|pending
argument_list|)
condition|)
block|{
name|free
argument_list|(
operator|(
name|osm_pending_pkey_t
operator|*
operator|)
name|p_item
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|ib_api_status_t
name|osm_pkey_tbl_set
parameter_list|(
name|IN
name|osm_pkey_tbl_t
modifier|*
name|p_pkey_tbl
parameter_list|,
name|IN
name|uint16_t
name|block
parameter_list|,
name|IN
name|ib_pkey_table_t
modifier|*
name|p_tbl
parameter_list|)
block|{
name|uint16_t
name|b
decl_stmt|,
name|i
decl_stmt|;
name|ib_pkey_table_t
modifier|*
name|p_pkey_block
decl_stmt|;
name|uint16_t
modifier|*
name|p_prev_pkey
decl_stmt|;
name|ib_net16_t
name|pkey
decl_stmt|;
comment|/* make sure the block is allocated */
if|if
condition|(
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|blocks
argument_list|)
operator|>
name|block
condition|)
name|p_pkey_block
operator|=
operator|(
name|ib_pkey_table_t
operator|*
operator|)
name|cl_ptr_vector_get
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
else|else
name|p_pkey_block
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|p_pkey_block
condition|)
block|{
name|p_pkey_block
operator|=
operator|(
name|ib_pkey_table_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ib_pkey_table_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_pkey_block
condition|)
return|return
operator|(
name|IB_ERROR
operator|)
return|;
name|memset
argument_list|(
name|p_pkey_block
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_pkey_table_t
argument_list|)
argument_list|)
expr_stmt|;
name|cl_ptr_vector_set
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|blocks
argument_list|,
name|block
argument_list|,
name|p_pkey_block
argument_list|)
expr_stmt|;
block|}
comment|/* sets the block values */
name|memcpy
argument_list|(
name|p_pkey_block
argument_list|,
name|p_tbl
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_pkey_table_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	   NOTE: as the spec does not require uniqueness of PKeys in 	   tables there is no other way but to refresh the entire keys map.  	   Moreover, if the same key exists but with full membership it should 	   have precedence on the key with limited membership ! 	 */
name|cl_map_remove_all
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|keys
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|blocks
argument_list|)
condition|;
name|b
operator|++
control|)
block|{
name|p_pkey_block
operator|=
name|cl_ptr_vector_get
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|blocks
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_pkey_block
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IB_NUM_PKEY_ELEMENTS_IN_BLOCK
condition|;
name|i
operator|++
control|)
block|{
name|pkey
operator|=
name|p_pkey_block
operator|->
name|pkey_entry
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ib_pkey_is_invalid
argument_list|(
name|pkey
argument_list|)
condition|)
continue|continue;
comment|/* 			   ignore the PKey Full Member bit in the key but store 			   the pointer to the table element as the map value 			 */
name|p_prev_pkey
operator|=
name|cl_map_get
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|keys
argument_list|,
name|ib_pkey_get_base
argument_list|(
name|pkey
argument_list|)
argument_list|)
expr_stmt|;
comment|/* we only insert if no previous or it is not full member */
if|if
condition|(
operator|(
name|p_prev_pkey
operator|==
name|NULL
operator|)
operator|||
operator|(
name|cl_ntoh16
argument_list|(
operator|*
name|p_prev_pkey
argument_list|)
operator|<
name|cl_ntoh16
argument_list|(
name|pkey
argument_list|)
operator|)
condition|)
name|cl_map_insert
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|keys
argument_list|,
name|ib_pkey_get_base
argument_list|(
name|pkey
argument_list|)
argument_list|,
operator|&
operator|(
name|p_pkey_block
operator|->
name|pkey_entry
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|IB_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_comment
comment|/*   Store the given pkey in the "new" blocks array.   Also, make sure the regular block exists. */
end_comment

begin_function
name|ib_api_status_t
name|osm_pkey_tbl_set_new_entry
parameter_list|(
name|IN
name|osm_pkey_tbl_t
modifier|*
name|p_pkey_tbl
parameter_list|,
name|IN
name|uint16_t
name|block_idx
parameter_list|,
name|IN
name|uint8_t
name|pkey_idx
parameter_list|,
name|IN
name|uint16_t
name|pkey
parameter_list|)
block|{
name|ib_pkey_table_t
modifier|*
name|p_block
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|p_block
operator|=
name|osm_pkey_tbl_new_block_get
argument_list|(
name|p_pkey_tbl
argument_list|,
name|block_idx
argument_list|)
operator|)
condition|)
block|{
name|p_block
operator|=
operator|(
name|ib_pkey_table_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ib_pkey_table_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_block
condition|)
return|return
operator|(
name|IB_ERROR
operator|)
return|;
name|memset
argument_list|(
name|p_block
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_pkey_table_t
argument_list|)
argument_list|)
expr_stmt|;
name|cl_ptr_vector_set
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|new_blocks
argument_list|,
name|block_idx
argument_list|,
name|p_block
argument_list|)
expr_stmt|;
block|}
name|p_block
operator|->
name|pkey_entry
index|[
name|pkey_idx
index|]
operator|=
name|pkey
expr_stmt|;
if|if
condition|(
name|p_pkey_tbl
operator|->
name|used_blocks
operator|<=
name|block_idx
condition|)
name|p_pkey_tbl
operator|->
name|used_blocks
operator|=
name|block_idx
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|IB_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|boolean_t
name|osm_pkey_find_next_free_entry
parameter_list|(
name|IN
name|osm_pkey_tbl_t
modifier|*
name|p_pkey_tbl
parameter_list|,
name|OUT
name|uint16_t
modifier|*
name|p_block_idx
parameter_list|,
name|OUT
name|uint8_t
modifier|*
name|p_pkey_idx
parameter_list|)
block|{
name|ib_pkey_table_t
modifier|*
name|p_new_block
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_block_idx
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_pkey_idx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p_block_idx
operator|<
name|p_pkey_tbl
operator|->
name|max_blocks
condition|)
block|{
if|if
condition|(
operator|*
name|p_pkey_idx
operator|>
name|IB_NUM_PKEY_ELEMENTS_IN_BLOCK
operator|-
literal|1
condition|)
block|{
operator|*
name|p_pkey_idx
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|p_block_idx
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p_block_idx
operator|>=
name|p_pkey_tbl
operator|->
name|max_blocks
condition|)
return|return
name|FALSE
return|;
block|}
name|p_new_block
operator|=
name|osm_pkey_tbl_new_block_get
argument_list|(
name|p_pkey_tbl
argument_list|,
operator|*
name|p_block_idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_new_block
operator|||
name|ib_pkey_is_invalid
argument_list|(
name|p_new_block
operator|->
name|pkey_entry
index|[
operator|*
name|p_pkey_idx
index|]
argument_list|)
condition|)
return|return
name|TRUE
return|;
else|else
operator|(
operator|*
name|p_pkey_idx
operator|)
operator|++
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|ib_api_status_t
name|osm_pkey_tbl_get_block_and_idx
parameter_list|(
name|IN
name|osm_pkey_tbl_t
modifier|*
name|p_pkey_tbl
parameter_list|,
name|IN
name|uint16_t
modifier|*
name|p_pkey
parameter_list|,
name|OUT
name|uint16_t
modifier|*
name|p_block_idx
parameter_list|,
name|OUT
name|uint8_t
modifier|*
name|p_pkey_idx
parameter_list|)
block|{
name|uint16_t
name|num_of_blocks
decl_stmt|;
name|uint16_t
name|block_index
decl_stmt|;
name|ib_pkey_table_t
modifier|*
name|block
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|p_block_idx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_pkey_idx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|num_of_blocks
operator|=
operator|(
name|uint16_t
operator|)
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_pkey_tbl
operator|->
name|blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|block_index
operator|=
literal|0
init|;
name|block_index
operator|<
name|num_of_blocks
condition|;
name|block_index
operator|++
control|)
block|{
name|block
operator|=
name|osm_pkey_tbl_block_get
argument_list|(
name|p_pkey_tbl
argument_list|,
name|block_index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|block
operator|->
name|pkey_entry
operator|<=
name|p_pkey
operator|)
operator|&&
operator|(
name|p_pkey
operator|<
name|block
operator|->
name|pkey_entry
operator|+
name|IB_NUM_PKEY_ELEMENTS_IN_BLOCK
operator|)
condition|)
block|{
operator|*
name|p_block_idx
operator|=
name|block_index
expr_stmt|;
operator|*
name|p_pkey_idx
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_pkey
operator|-
name|block
operator|->
name|pkey_entry
argument_list|)
expr_stmt|;
return|return
operator|(
name|IB_SUCCESS
operator|)
return|;
block|}
block|}
return|return
operator|(
name|IB_NOT_FOUND
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|boolean_t
name|__osm_match_pkey
parameter_list|(
name|IN
specifier|const
name|ib_net16_t
modifier|*
name|pkey1
parameter_list|,
name|IN
specifier|const
name|ib_net16_t
modifier|*
name|pkey2
parameter_list|)
block|{
comment|/* if both pkeys are not full member - this is not a match */
if|if
condition|(
operator|!
operator|(
name|ib_pkey_is_full_member
argument_list|(
operator|*
name|pkey1
argument_list|)
operator|||
name|ib_pkey_is_full_member
argument_list|(
operator|*
name|pkey2
argument_list|)
operator|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* compare if the bases are the same. if they are - then 	   this is a match */
if|if
condition|(
name|ib_pkey_get_base
argument_list|(
operator|*
name|pkey1
argument_list|)
operator|!=
name|ib_pkey_get_base
argument_list|(
operator|*
name|pkey2
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|boolean_t
name|osm_physp_share_this_pkey
parameter_list|(
name|IN
specifier|const
name|osm_physp_t
modifier|*
specifier|const
name|p_physp1
parameter_list|,
name|IN
specifier|const
name|osm_physp_t
modifier|*
specifier|const
name|p_physp2
parameter_list|,
name|IN
specifier|const
name|ib_net16_t
name|pkey
parameter_list|)
block|{
name|ib_net16_t
modifier|*
name|pkey1
decl_stmt|,
modifier|*
name|pkey2
decl_stmt|;
name|pkey1
operator|=
name|cl_map_get
argument_list|(
operator|&
operator|(
name|osm_physp_get_pkey_tbl
argument_list|(
name|p_physp1
argument_list|)
operator|)
operator|->
name|keys
argument_list|,
name|ib_pkey_get_base
argument_list|(
name|pkey
argument_list|)
argument_list|)
expr_stmt|;
name|pkey2
operator|=
name|cl_map_get
argument_list|(
operator|&
operator|(
name|osm_physp_get_pkey_tbl
argument_list|(
name|p_physp2
argument_list|)
operator|)
operator|->
name|keys
argument_list|,
name|ib_pkey_get_base
argument_list|(
name|pkey
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|pkey1
operator|&&
name|pkey2
operator|&&
name|__osm_match_pkey
argument_list|(
name|pkey1
argument_list|,
name|pkey2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|ib_net16_t
name|osm_physp_find_common_pkey
parameter_list|(
name|IN
specifier|const
name|osm_physp_t
modifier|*
specifier|const
name|p_physp1
parameter_list|,
name|IN
specifier|const
name|osm_physp_t
modifier|*
specifier|const
name|p_physp2
parameter_list|)
block|{
name|ib_net16_t
modifier|*
name|pkey1
decl_stmt|,
modifier|*
name|pkey2
decl_stmt|;
name|uint64_t
name|pkey1_base
decl_stmt|,
name|pkey2_base
decl_stmt|;
specifier|const
name|osm_pkey_tbl_t
modifier|*
name|pkey_tbl1
decl_stmt|,
modifier|*
name|pkey_tbl2
decl_stmt|;
name|cl_map_iterator_t
name|map_iter1
decl_stmt|,
name|map_iter2
decl_stmt|;
name|pkey_tbl1
operator|=
name|osm_physp_get_pkey_tbl
argument_list|(
name|p_physp1
argument_list|)
expr_stmt|;
name|pkey_tbl2
operator|=
name|osm_physp_get_pkey_tbl
argument_list|(
name|p_physp2
argument_list|)
expr_stmt|;
name|map_iter1
operator|=
name|cl_map_head
argument_list|(
operator|&
name|pkey_tbl1
operator|->
name|keys
argument_list|)
expr_stmt|;
name|map_iter2
operator|=
name|cl_map_head
argument_list|(
operator|&
name|pkey_tbl2
operator|->
name|keys
argument_list|)
expr_stmt|;
comment|/* we rely on the fact the map are sorted by pkey */
while|while
condition|(
operator|(
name|map_iter1
operator|!=
name|cl_map_end
argument_list|(
operator|&
name|pkey_tbl1
operator|->
name|keys
argument_list|)
operator|)
operator|&&
operator|(
name|map_iter2
operator|!=
name|cl_map_end
argument_list|(
operator|&
name|pkey_tbl2
operator|->
name|keys
argument_list|)
operator|)
condition|)
block|{
name|pkey1
operator|=
operator|(
name|ib_net16_t
operator|*
operator|)
name|cl_map_obj
argument_list|(
name|map_iter1
argument_list|)
expr_stmt|;
name|pkey2
operator|=
operator|(
name|ib_net16_t
operator|*
operator|)
name|cl_map_obj
argument_list|(
name|map_iter2
argument_list|)
expr_stmt|;
if|if
condition|(
name|__osm_match_pkey
argument_list|(
name|pkey1
argument_list|,
name|pkey2
argument_list|)
condition|)
return|return
operator|*
name|pkey1
return|;
comment|/* advance the lower value if they are not equal */
name|pkey1_base
operator|=
name|cl_map_key
argument_list|(
name|map_iter1
argument_list|)
expr_stmt|;
name|pkey2_base
operator|=
name|cl_map_key
argument_list|(
name|map_iter2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkey2_base
operator|==
name|pkey1_base
condition|)
block|{
name|map_iter1
operator|=
name|cl_map_next
argument_list|(
name|map_iter1
argument_list|)
expr_stmt|;
name|map_iter2
operator|=
name|cl_map_next
argument_list|(
name|map_iter2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pkey2_base
operator|<
name|pkey1_base
condition|)
name|map_iter2
operator|=
name|cl_map_next
argument_list|(
name|map_iter2
argument_list|)
expr_stmt|;
else|else
name|map_iter1
operator|=
name|cl_map_next
argument_list|(
name|map_iter1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|boolean_t
name|osm_physp_share_pkey
parameter_list|(
name|IN
name|osm_log_t
modifier|*
name|p_log
parameter_list|,
name|IN
specifier|const
name|osm_physp_t
modifier|*
specifier|const
name|p_physp_1
parameter_list|,
name|IN
specifier|const
name|osm_physp_t
modifier|*
specifier|const
name|p_physp_2
parameter_list|)
block|{
specifier|const
name|osm_pkey_tbl_t
modifier|*
name|pkey_tbl1
decl_stmt|,
modifier|*
name|pkey_tbl2
decl_stmt|;
if|if
condition|(
name|p_physp_1
operator|==
name|p_physp_2
condition|)
return|return
name|TRUE
return|;
name|pkey_tbl1
operator|=
name|osm_physp_get_pkey_tbl
argument_list|(
name|p_physp_1
argument_list|)
expr_stmt|;
name|pkey_tbl2
operator|=
name|osm_physp_get_pkey_tbl
argument_list|(
name|p_physp_2
argument_list|)
expr_stmt|;
comment|/* 	   The spec: 10.9.2 does not require each phys port to have PKey Table. 	   So actually if it does not, we need to use the default port instead.  	   HACK: meanwhile we will ignore the check 	 */
if|if
condition|(
name|cl_is_map_empty
argument_list|(
operator|&
name|pkey_tbl1
operator|->
name|keys
argument_list|)
operator|||
name|cl_is_map_empty
argument_list|(
operator|&
name|pkey_tbl2
operator|->
name|keys
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
operator|!
name|ib_pkey_is_invalid
argument_list|(
name|osm_physp_find_common_pkey
argument_list|(
name|p_physp_1
argument_list|,
name|p_physp_2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|boolean_t
name|osm_port_share_pkey
parameter_list|(
name|IN
name|osm_log_t
modifier|*
name|p_log
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
specifier|const
name|p_port_1
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
specifier|const
name|p_port_2
parameter_list|)
block|{
name|osm_physp_t
modifier|*
name|p_physp1
decl_stmt|,
modifier|*
name|p_physp2
decl_stmt|;
name|boolean_t
name|ret
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_port_1
operator|||
operator|!
name|p_port_2
condition|)
block|{
name|ret
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_physp1
operator|=
name|p_port_1
operator|->
name|p_physp
expr_stmt|;
name|p_physp2
operator|=
name|p_port_2
operator|->
name|p_physp
expr_stmt|;
if|if
condition|(
operator|!
name|p_physp1
operator|||
operator|!
name|p_physp2
condition|)
block|{
name|ret
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|ret
operator|=
name|osm_physp_share_pkey
argument_list|(
name|p_log
argument_list|,
name|p_physp1
argument_list|,
name|p_physp2
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|boolean_t
name|osm_physp_has_pkey
parameter_list|(
name|IN
name|osm_log_t
modifier|*
name|p_log
parameter_list|,
name|IN
specifier|const
name|ib_net16_t
name|pkey
parameter_list|,
name|IN
specifier|const
name|osm_physp_t
modifier|*
specifier|const
name|p_physp
parameter_list|)
block|{
name|ib_net16_t
modifier|*
name|p_pkey
decl_stmt|,
name|pkey_base
decl_stmt|;
specifier|const
name|osm_pkey_tbl_t
modifier|*
name|pkey_tbl
decl_stmt|;
name|boolean_t
name|res
init|=
name|FALSE
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Search for PKey: 0x%04x\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|pkey
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if the pkey given is an invalid pkey - return TRUE. */
if|if
condition|(
name|ib_pkey_is_invalid
argument_list|(
name|pkey
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Given invalid PKey - we treat it loosely and allow it\n"
argument_list|)
expr_stmt|;
name|res
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|pkey_base
operator|=
name|ib_pkey_get_base
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
name|pkey_tbl
operator|=
name|osm_physp_get_pkey_tbl
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|p_pkey
operator|=
name|cl_map_get
argument_list|(
operator|&
name|pkey_tbl
operator|->
name|keys
argument_list|,
name|pkey_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_pkey
condition|)
block|{
name|res
operator|=
name|TRUE
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"PKey 0x%04x was found\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|pkey
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"PKey 0x%04x was not found\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|pkey
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

end_unit

