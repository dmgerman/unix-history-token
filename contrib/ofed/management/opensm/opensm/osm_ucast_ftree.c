begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2008 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2007 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of OpenSM FatTree routing  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qmap.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_switch.h>
end_include

begin_comment
comment|/*  * FatTree rank is bounded between 2 and 8:  *  - Tree of rank 1 has only trivial routing paths,  *    so no need to use FatTree routing.  *  - Why maximum rank is 8:  *    Each node (switch) is assigned a unique tuple.  *    Switches are stored in two cl_qmaps - one is  *    ordered by guid, and the other by a key that is  *    generated from tuple. Since cl_qmap supports only  *    a 64-bit key, the maximal tuple lenght is 8 bytes.  *    which means that maximal tree rank is 8.  * Note that the above also implies that each switch  * can have at max 255 up/down ports.  */
end_comment

begin_define
define|#
directive|define
name|FAT_TREE_MIN_RANK
value|2
end_define

begin_define
define|#
directive|define
name|FAT_TREE_MAX_RANK
value|8
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|FTREE_DIRECTION_DOWN
init|=
operator|-
literal|1
block|,
name|FTREE_DIRECTION_SAME
block|,
name|FTREE_DIRECTION_UP
block|}
name|ftree_direction_t
typedef|;
end_typedef

begin_comment
comment|/***************************************************  **  **  Forward references  **  ***************************************************/
end_comment

begin_struct_decl
struct_decl|struct
name|ftree_sw_t_
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|ftree_hca_t_
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|ftree_port_t_
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|ftree_port_group_t_
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|ftree_fabric_t_
struct_decl|;
end_struct_decl

begin_comment
comment|/***************************************************  **  **  ftree_tuple_t definition  **  ***************************************************/
end_comment

begin_define
define|#
directive|define
name|FTREE_TUPLE_BUFF_LEN
value|1024
end_define

begin_define
define|#
directive|define
name|FTREE_TUPLE_LEN
value|8
end_define

begin_typedef
typedef|typedef
name|uint8_t
name|ftree_tuple_t
index|[
name|FTREE_TUPLE_LEN
index|]
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint64_t
name|ftree_tuple_key_t
typedef|;
end_typedef

begin_struct
struct|struct
name|guid_list_item
block|{
name|cl_list_item_t
name|list
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/***************************************************  **  **  ftree_sw_table_element_t definition  **  ***************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|cl_map_item_t
name|map_item
decl_stmt|;
name|struct
name|ftree_sw_t_
modifier|*
name|p_sw
decl_stmt|;
block|}
name|ftree_sw_tbl_element_t
typedef|;
end_typedef

begin_comment
comment|/***************************************************  **  **  ftree_port_t definition  **  ***************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ftree_port_t_
block|{
name|cl_map_item_t
name|map_item
decl_stmt|;
name|uint8_t
name|port_num
decl_stmt|;
comment|/* port number on the current node */
name|uint8_t
name|remote_port_num
decl_stmt|;
comment|/* port number on the remote node */
name|uint32_t
name|counter_up
decl_stmt|;
comment|/* number of allocated routs upwards */
name|uint32_t
name|counter_down
decl_stmt|;
comment|/* number of allocated routs downwards */
block|}
name|ftree_port_t
typedef|;
end_typedef

begin_comment
comment|/***************************************************  **  **  ftree_port_group_t definition  **  ***************************************************/
end_comment

begin_typedef
typedef|typedef
union|union
name|ftree_hca_or_sw_
block|{
name|struct
name|ftree_hca_t_
modifier|*
name|p_hca
decl_stmt|;
name|struct
name|ftree_sw_t_
modifier|*
name|p_sw
decl_stmt|;
block|}
name|ftree_hca_or_sw
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|ftree_port_group_t_
block|{
name|cl_map_item_t
name|map_item
decl_stmt|;
name|ib_net16_t
name|base_lid
decl_stmt|;
comment|/* base lid of the current node */
name|ib_net16_t
name|remote_base_lid
decl_stmt|;
comment|/* base lid of the remote node */
name|ib_net64_t
name|port_guid
decl_stmt|;
comment|/* port guid of this port */
name|ib_net64_t
name|node_guid
decl_stmt|;
comment|/* this node's guid */
name|uint8_t
name|node_type
decl_stmt|;
comment|/* this node's type */
name|ib_net64_t
name|remote_port_guid
decl_stmt|;
comment|/* port guid of the remote port */
name|ib_net64_t
name|remote_node_guid
decl_stmt|;
comment|/* node guid of the remote node */
name|uint8_t
name|remote_node_type
decl_stmt|;
comment|/* IB_NODE_TYPE_{CA,SWITCH,ROUTER,...} */
name|ftree_hca_or_sw
name|hca_or_sw
decl_stmt|;
comment|/* pointer to this hca/switch */
name|ftree_hca_or_sw
name|remote_hca_or_sw
decl_stmt|;
comment|/* pointer to remote hca/switch */
name|cl_ptr_vector_t
name|ports
decl_stmt|;
comment|/* vector of ports to the same lid */
name|boolean_t
name|is_cn
decl_stmt|;
comment|/* whether this port is a compute node */
name|uint32_t
name|counter_down
decl_stmt|;
comment|/* number of allocated routs downwards */
block|}
name|ftree_port_group_t
typedef|;
end_typedef

begin_comment
comment|/***************************************************  **  **  ftree_sw_t definition  **  ***************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ftree_sw_t_
block|{
name|cl_map_item_t
name|map_item
decl_stmt|;
name|osm_switch_t
modifier|*
name|p_osm_sw
decl_stmt|;
name|uint32_t
name|rank
decl_stmt|;
name|ftree_tuple_t
name|tuple
decl_stmt|;
name|ib_net16_t
name|base_lid
decl_stmt|;
name|ftree_port_group_t
modifier|*
modifier|*
name|down_port_groups
decl_stmt|;
name|uint8_t
name|down_port_groups_num
decl_stmt|;
name|ftree_port_group_t
modifier|*
modifier|*
name|up_port_groups
decl_stmt|;
name|uint8_t
name|up_port_groups_num
decl_stmt|;
name|boolean_t
name|is_leaf
decl_stmt|;
name|int
name|down_port_groups_idx
decl_stmt|;
block|}
name|ftree_sw_t
typedef|;
end_typedef

begin_comment
comment|/***************************************************  **  **  ftree_hca_t definition  **  ***************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ftree_hca_t_
block|{
name|cl_map_item_t
name|map_item
decl_stmt|;
name|osm_node_t
modifier|*
name|p_osm_node
decl_stmt|;
name|ftree_port_group_t
modifier|*
modifier|*
name|up_port_groups
decl_stmt|;
name|uint16_t
name|up_port_groups_num
decl_stmt|;
name|unsigned
name|cn_num
decl_stmt|;
block|}
name|ftree_hca_t
typedef|;
end_typedef

begin_comment
comment|/***************************************************  **  **  ftree_fabric_t definition  **  ***************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ftree_fabric_t_
block|{
name|osm_opensm_t
modifier|*
name|p_osm
decl_stmt|;
name|cl_qmap_t
name|hca_tbl
decl_stmt|;
name|cl_qmap_t
name|sw_tbl
decl_stmt|;
name|cl_qmap_t
name|sw_by_tuple_tbl
decl_stmt|;
name|cl_qlist_t
name|root_guid_list
decl_stmt|;
name|cl_qmap_t
name|cn_guid_tbl
decl_stmt|;
name|unsigned
name|cn_num
decl_stmt|;
name|uint8_t
name|leaf_switch_rank
decl_stmt|;
name|uint8_t
name|max_switch_rank
decl_stmt|;
name|ftree_sw_t
modifier|*
modifier|*
name|leaf_switches
decl_stmt|;
name|uint32_t
name|leaf_switches_num
decl_stmt|;
name|uint16_t
name|max_cn_per_leaf
decl_stmt|;
name|uint16_t
name|lft_max_lid_ho
decl_stmt|;
name|boolean_t
name|fabric_built
decl_stmt|;
block|}
name|ftree_fabric_t
typedef|;
end_typedef

begin_comment
comment|/***************************************************  **  ** comparators  **  ***************************************************/
end_comment

begin_function
specifier|static
name|int
name|OSM_CDECL
name|__osm_ftree_compare_switches_by_index
parameter_list|(
name|IN
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
name|IN
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
modifier|*
name|pp_sw1
init|=
operator|(
name|ftree_sw_t
operator|*
operator|*
operator|)
name|p1
decl_stmt|;
name|ftree_sw_t
modifier|*
modifier|*
name|pp_sw2
init|=
operator|(
name|ftree_sw_t
operator|*
operator|*
operator|)
name|p2
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FTREE_TUPLE_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|pp_sw1
operator|)
operator|->
name|tuple
index|[
name|i
index|]
operator|>
operator|(
operator|*
name|pp_sw2
operator|)
operator|->
name|tuple
index|[
name|i
index|]
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
operator|*
name|pp_sw1
operator|)
operator|->
name|tuple
index|[
name|i
index|]
operator|<
operator|(
operator|*
name|pp_sw2
operator|)
operator|->
name|tuple
index|[
name|i
index|]
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|int
name|OSM_CDECL
name|__osm_ftree_compare_port_groups_by_remote_switch_index
parameter_list|(
name|IN
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
name|IN
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
name|ftree_port_group_t
modifier|*
modifier|*
name|pp_g1
init|=
operator|(
name|ftree_port_group_t
operator|*
operator|*
operator|)
name|p1
decl_stmt|;
name|ftree_port_group_t
modifier|*
modifier|*
name|pp_g2
init|=
operator|(
name|ftree_port_group_t
operator|*
operator|*
operator|)
name|p2
decl_stmt|;
return|return
name|__osm_ftree_compare_switches_by_index
argument_list|(
operator|&
operator|(
operator|(
operator|*
name|pp_g1
operator|)
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
operator|)
argument_list|,
operator|&
operator|(
operator|(
operator|*
name|pp_g2
operator|)
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************  **  ** ftree_tuple_t functions  **  ***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_tuple_init
parameter_list|(
name|IN
name|ftree_tuple_t
name|tuple
parameter_list|)
block|{
name|memset
argument_list|(
name|tuple
argument_list|,
literal|0xFF
argument_list|,
name|FTREE_TUPLE_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|boolean_t
name|__osm_ftree_tuple_assigned
parameter_list|(
name|IN
name|ftree_tuple_t
name|tuple
parameter_list|)
block|{
return|return
operator|(
name|tuple
index|[
literal|0
index|]
operator|!=
literal|0xFF
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_define
define|#
directive|define
name|FTREE_TUPLE_BUFFERS_NUM
value|6
end_define

begin_function
specifier|static
name|char
modifier|*
name|__osm_ftree_tuple_to_str
parameter_list|(
name|IN
name|ftree_tuple_t
name|tuple
parameter_list|)
block|{
specifier|static
name|char
name|buffer
index|[
name|FTREE_TUPLE_BUFFERS_NUM
index|]
index|[
name|FTREE_TUPLE_BUFF_LEN
index|]
decl_stmt|;
specifier|static
name|uint8_t
name|ind
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|ret_buffer
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|__osm_ftree_tuple_assigned
argument_list|(
name|tuple
argument_list|)
condition|)
return|return
literal|"INDEX.NOT.ASSIGNED"
return|;
name|buffer
index|[
name|ind
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|FTREE_TUPLE_LEN
operator|)
operator|&&
operator|(
name|tuple
index|[
name|i
index|]
operator|!=
literal|0xFF
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|buffer
index|[
name|ind
index|]
argument_list|)
operator|+
literal|10
operator|)
operator|>
name|FTREE_TUPLE_BUFF_LEN
condition|)
return|return
literal|"INDEX.TOO.LONG"
return|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|strcat
argument_list|(
name|buffer
index|[
name|ind
index|]
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
operator|&
name|buffer
index|[
name|ind
index|]
index|[
name|strlen
argument_list|(
name|buffer
index|[
name|ind
index|]
argument_list|)
index|]
argument_list|,
literal|"%u"
argument_list|,
name|tuple
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|ret_buffer
operator|=
name|buffer
index|[
name|ind
index|]
expr_stmt|;
name|ind
operator|=
operator|(
name|ind
operator|+
literal|1
operator|)
operator|%
name|FTREE_TUPLE_BUFFERS_NUM
expr_stmt|;
return|return
name|ret_buffer
return|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_tuple_to_str() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|ftree_tuple_key_t
name|__osm_ftree_tuple_to_key
parameter_list|(
name|IN
name|ftree_tuple_t
name|tuple
parameter_list|)
block|{
name|ftree_tuple_key_t
name|key
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|key
argument_list|,
name|tuple
argument_list|,
name|FTREE_TUPLE_LEN
argument_list|)
expr_stmt|;
return|return
name|key
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|__osm_ftree_tuple_from_key
parameter_list|(
name|IN
name|ftree_tuple_t
name|tuple
parameter_list|,
name|IN
name|ftree_tuple_key_t
name|key
parameter_list|)
block|{
name|memcpy
argument_list|(
name|tuple
argument_list|,
operator|&
name|key
argument_list|,
name|FTREE_TUPLE_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  **  ** ftree_sw_tbl_element_t functions  **  ***************************************************/
end_comment

begin_function
specifier|static
name|ftree_sw_tbl_element_t
modifier|*
name|__osm_ftree_sw_tbl_element_create
parameter_list|(
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|)
block|{
name|ftree_sw_tbl_element_t
modifier|*
name|p_element
init|=
operator|(
name|ftree_sw_tbl_element_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ftree_sw_tbl_element_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p_element
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|p_element
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ftree_sw_tbl_element_t
argument_list|)
argument_list|)
expr_stmt|;
name|p_element
operator|->
name|p_sw
operator|=
name|p_sw
expr_stmt|;
return|return
name|p_element
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_sw_tbl_element_destroy
parameter_list|(
name|IN
name|ftree_sw_tbl_element_t
modifier|*
name|p_element
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p_element
condition|)
return|return;
name|free
argument_list|(
name|p_element
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  **  ** ftree_port_t functions  **  ***************************************************/
end_comment

begin_function
specifier|static
name|ftree_port_t
modifier|*
name|__osm_ftree_port_create
parameter_list|(
name|IN
name|uint8_t
name|port_num
parameter_list|,
name|IN
name|uint8_t
name|remote_port_num
parameter_list|)
block|{
name|ftree_port_t
modifier|*
name|p_port
init|=
operator|(
name|ftree_port_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ftree_port_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p_port
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|p_port
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ftree_port_t
argument_list|)
argument_list|)
expr_stmt|;
name|p_port
operator|->
name|port_num
operator|=
name|port_num
expr_stmt|;
name|p_port
operator|->
name|remote_port_num
operator|=
name|remote_port_num
expr_stmt|;
return|return
name|p_port
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_port_destroy
parameter_list|(
name|IN
name|ftree_port_t
modifier|*
name|p_port
parameter_list|)
block|{
if|if
condition|(
name|p_port
condition|)
name|free
argument_list|(
name|p_port
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  **  ** ftree_port_group_t functions  **  ***************************************************/
end_comment

begin_function
specifier|static
name|ftree_port_group_t
modifier|*
name|__osm_ftree_port_group_create
parameter_list|(
name|IN
name|ib_net16_t
name|base_lid
parameter_list|,
name|IN
name|ib_net16_t
name|remote_base_lid
parameter_list|,
name|IN
name|ib_net64_t
name|port_guid
parameter_list|,
name|IN
name|ib_net64_t
name|node_guid
parameter_list|,
name|IN
name|uint8_t
name|node_type
parameter_list|,
name|IN
name|void
modifier|*
name|p_hca_or_sw
parameter_list|,
name|IN
name|ib_net64_t
name|remote_port_guid
parameter_list|,
name|IN
name|ib_net64_t
name|remote_node_guid
parameter_list|,
name|IN
name|uint8_t
name|remote_node_type
parameter_list|,
name|IN
name|void
modifier|*
name|p_remote_hca_or_sw
parameter_list|,
name|IN
name|boolean_t
name|is_cn
parameter_list|)
block|{
name|ftree_port_group_t
modifier|*
name|p_group
init|=
operator|(
name|ftree_port_group_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ftree_port_group_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|p_group
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|p_group
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ftree_port_group_t
argument_list|)
argument_list|)
expr_stmt|;
name|p_group
operator|->
name|base_lid
operator|=
name|base_lid
expr_stmt|;
name|p_group
operator|->
name|remote_base_lid
operator|=
name|remote_base_lid
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_group
operator|->
name|port_guid
argument_list|,
operator|&
name|port_guid
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_net64_t
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_group
operator|->
name|node_guid
argument_list|,
operator|&
name|node_guid
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_net64_t
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_group
operator|->
name|remote_port_guid
argument_list|,
operator|&
name|remote_port_guid
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_net64_t
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|p_group
operator|->
name|remote_node_guid
argument_list|,
operator|&
name|remote_node_guid
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_net64_t
argument_list|)
argument_list|)
expr_stmt|;
name|p_group
operator|->
name|node_type
operator|=
name|node_type
expr_stmt|;
switch|switch
condition|(
name|node_type
condition|)
block|{
case|case
name|IB_NODE_TYPE_CA
case|:
name|p_group
operator|->
name|hca_or_sw
operator|.
name|p_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|p_hca_or_sw
expr_stmt|;
break|break;
case|case
name|IB_NODE_TYPE_SWITCH
case|:
name|p_group
operator|->
name|hca_or_sw
operator|.
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|p_hca_or_sw
expr_stmt|;
break|break;
default|default:
comment|/* we shouldn't get here - port is created only in hca or switch */
name|CL_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|p_group
operator|->
name|remote_node_type
operator|=
name|remote_node_type
expr_stmt|;
switch|switch
condition|(
name|remote_node_type
condition|)
block|{
case|case
name|IB_NODE_TYPE_CA
case|:
name|p_group
operator|->
name|remote_hca_or_sw
operator|.
name|p_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|p_remote_hca_or_sw
expr_stmt|;
break|break;
case|case
name|IB_NODE_TYPE_SWITCH
case|:
name|p_group
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|p_remote_hca_or_sw
expr_stmt|;
break|break;
default|default:
comment|/* we shouldn't get here - port is created only in hca or switch */
name|CL_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|cl_ptr_vector_init
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|,
literal|0
argument_list|,
comment|/* min size */
literal|8
argument_list|)
expr_stmt|;
comment|/* grow size */
name|p_group
operator|->
name|is_cn
operator|=
name|is_cn
expr_stmt|;
return|return
name|p_group
return|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_port_group_create() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_port_group_destroy
parameter_list|(
name|IN
name|ftree_port_group_t
modifier|*
name|p_group
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
name|ftree_port_t
modifier|*
name|p_port
decl_stmt|;
if|if
condition|(
operator|!
name|p_group
condition|)
return|return;
comment|/* remove all the elements of p_group->ports vector */
name|size
operator|=
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|cl_ptr_vector_at
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|,
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_port
argument_list|)
expr_stmt|;
name|__osm_ftree_port_destroy
argument_list|(
name|p_port
argument_list|)
expr_stmt|;
block|}
name|cl_ptr_vector_destroy
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_group
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_port_group_destroy() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_port_group_dump
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_port_group_t
modifier|*
name|p_group
parameter_list|,
name|IN
name|ftree_direction_t
name|direction
parameter_list|)
block|{
name|ftree_port_t
modifier|*
name|p_port
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|char
name|buff
index|[
literal|10
operator|*
literal|1024
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|p_group
condition|)
return|return;
if|if
condition|(
operator|!
name|osm_log_is_active
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
return|return;
name|size
operator|=
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|)
expr_stmt|;
name|buff
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|cl_ptr_vector_at
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|,
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_port
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|strcat
argument_list|(
name|buff
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buff
operator|+
name|strlen
argument_list|(
name|buff
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
name|p_port
operator|->
name|port_num
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"    Port Group of size %u, port(s): %s, direction: %s\n"
literal|"                  Local<--> Remote GUID (LID):"
literal|"0x%016"
name|PRIx64
literal|" (0x%04x)<--> 0x%016"
name|PRIx64
literal|" (0x%04x)\n"
argument_list|,
name|size
argument_list|,
name|buff
argument_list|,
operator|(
name|direction
operator|==
name|FTREE_DIRECTION_DOWN
operator|)
condition|?
literal|"DOWN"
else|:
literal|"UP"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_group
operator|->
name|port_guid
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_group
operator|->
name|base_lid
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_group
operator|->
name|remote_port_guid
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_group
operator|->
name|remote_base_lid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_port_group_dump() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_port_group_add_port
parameter_list|(
name|IN
name|ftree_port_group_t
modifier|*
name|p_group
parameter_list|,
name|IN
name|uint8_t
name|port_num
parameter_list|,
name|IN
name|uint8_t
name|remote_port_num
parameter_list|)
block|{
name|uint16_t
name|i
decl_stmt|;
name|ftree_port_t
modifier|*
name|p_port
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|cl_ptr_vector_at
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|,
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_port
operator|->
name|port_num
operator|==
name|port_num
condition|)
return|return;
block|}
name|p_port
operator|=
name|__osm_ftree_port_create
argument_list|(
name|port_num
argument_list|,
name|remote_port_num
argument_list|)
expr_stmt|;
name|cl_ptr_vector_insert
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|,
name|p_port
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  **  ** ftree_sw_t functions  **  ***************************************************/
end_comment

begin_function
specifier|static
name|ftree_sw_t
modifier|*
name|__osm_ftree_sw_create
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|osm_switch_t
modifier|*
name|p_osm_sw
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|uint8_t
name|ports_num
decl_stmt|;
comment|/* make sure that the switch has ports */
if|if
condition|(
name|p_osm_sw
operator|->
name|num_ports
operator|==
literal|1
condition|)
return|return
name|NULL
return|;
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ftree_sw_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|p_sw
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ftree_sw_t
argument_list|)
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|p_osm_sw
operator|=
name|p_osm_sw
expr_stmt|;
name|p_sw
operator|->
name|rank
operator|=
literal|0xFFFFFFFF
expr_stmt|;
name|__osm_ftree_tuple_init
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|base_lid
operator|=
name|osm_node_get_base_lid
argument_list|(
name|p_sw
operator|->
name|p_osm_sw
operator|->
name|p_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ports_num
operator|=
name|osm_node_get_num_physp
argument_list|(
name|p_sw
operator|->
name|p_osm_sw
operator|->
name|p_node
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|down_port_groups
operator|=
operator|(
name|ftree_port_group_t
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|ports_num
operator|*
sizeof|sizeof
argument_list|(
name|ftree_port_group_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|up_port_groups
operator|=
operator|(
name|ftree_port_group_t
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|ports_num
operator|*
sizeof|sizeof
argument_list|(
name|ftree_port_group_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_sw
operator|->
name|down_port_groups
operator|||
operator|!
name|p_sw
operator|->
name|up_port_groups
condition|)
return|return
name|NULL
return|;
name|p_sw
operator|->
name|down_port_groups_num
operator|=
literal|0
expr_stmt|;
name|p_sw
operator|->
name|up_port_groups_num
operator|=
literal|0
expr_stmt|;
comment|/* initialize lft buffer */
name|memset
argument_list|(
name|p_osm_sw
operator|->
name|new_lft
argument_list|,
name|OSM_NO_PATH
argument_list|,
name|IB_LID_UCAST_END_HO
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|down_port_groups_idx
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|p_sw
return|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_sw_create() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_sw_destroy
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|)
block|{
name|uint8_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|p_sw
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|down_port_groups_num
condition|;
name|i
operator|++
control|)
name|__osm_ftree_port_group_destroy
argument_list|(
name|p_sw
operator|->
name|down_port_groups
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|up_port_groups_num
condition|;
name|i
operator|++
control|)
name|__osm_ftree_port_group_destroy
argument_list|(
name|p_sw
operator|->
name|up_port_groups
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|down_port_groups
condition|)
name|free
argument_list|(
name|p_sw
operator|->
name|down_port_groups
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|up_port_groups
condition|)
name|free
argument_list|(
name|p_sw
operator|->
name|up_port_groups
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_sw_destroy() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|uint64_t
name|__osm_ftree_sw_get_guid_no
parameter_list|(
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p_sw
condition|)
return|return
literal|0
return|;
return|return
name|osm_node_get_node_guid
argument_list|(
name|p_sw
operator|->
name|p_osm_sw
operator|->
name|p_node
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|uint64_t
name|__osm_ftree_sw_get_guid_ho
parameter_list|(
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|)
block|{
return|return
name|cl_ntoh64
argument_list|(
name|__osm_ftree_sw_get_guid_no
argument_list|(
name|p_sw
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_sw_dump
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|p_sw
condition|)
return|return;
if|if
condition|(
operator|!
name|osm_log_is_active
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
return|return;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Switch index: %s, GUID: 0x%016"
name|PRIx64
literal|", Ports: %u DOWN, %u UP\n"
argument_list|,
name|__osm_ftree_tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|__osm_ftree_sw_get_guid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|,
name|p_sw
operator|->
name|down_port_groups_num
argument_list|,
name|p_sw
operator|->
name|up_port_groups_num
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|down_port_groups_num
condition|;
name|i
operator|++
control|)
name|__osm_ftree_port_group_dump
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
operator|->
name|down_port_groups
index|[
name|i
index|]
argument_list|,
name|FTREE_DIRECTION_DOWN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|up_port_groups_num
condition|;
name|i
operator|++
control|)
name|__osm_ftree_port_group_dump
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
operator|->
name|up_port_groups
index|[
name|i
index|]
argument_list|,
name|FTREE_DIRECTION_UP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_sw_dump() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|boolean_t
name|__osm_ftree_sw_ranked
parameter_list|(
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|)
block|{
return|return
operator|(
name|p_sw
operator|->
name|rank
operator|!=
literal|0xFFFFFFFF
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|ftree_port_group_t
modifier|*
name|__osm_ftree_sw_get_port_group_by_remote_lid
parameter_list|(
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|ib_net16_t
name|remote_base_lid
parameter_list|,
name|IN
name|ftree_direction_t
name|direction
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
name|ftree_port_group_t
modifier|*
modifier|*
name|port_groups
decl_stmt|;
if|if
condition|(
name|direction
operator|==
name|FTREE_DIRECTION_UP
condition|)
block|{
name|port_groups
operator|=
name|p_sw
operator|->
name|up_port_groups
expr_stmt|;
name|size
operator|=
name|p_sw
operator|->
name|up_port_groups_num
expr_stmt|;
block|}
else|else
block|{
name|port_groups
operator|=
name|p_sw
operator|->
name|down_port_groups
expr_stmt|;
name|size
operator|=
name|p_sw
operator|->
name|down_port_groups_num
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|remote_base_lid
operator|==
name|port_groups
index|[
name|i
index|]
operator|->
name|remote_base_lid
condition|)
return|return
name|port_groups
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_sw_get_port_group_by_remote_lid() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_sw_add_port
parameter_list|(
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|uint8_t
name|port_num
parameter_list|,
name|IN
name|uint8_t
name|remote_port_num
parameter_list|,
name|IN
name|ib_net16_t
name|base_lid
parameter_list|,
name|IN
name|ib_net16_t
name|remote_base_lid
parameter_list|,
name|IN
name|ib_net64_t
name|port_guid
parameter_list|,
name|IN
name|ib_net64_t
name|remote_port_guid
parameter_list|,
name|IN
name|ib_net64_t
name|remote_node_guid
parameter_list|,
name|IN
name|uint8_t
name|remote_node_type
parameter_list|,
name|IN
name|void
modifier|*
name|p_remote_hca_or_sw
parameter_list|,
name|IN
name|ftree_direction_t
name|direction
parameter_list|)
block|{
name|ftree_port_group_t
modifier|*
name|p_group
init|=
name|__osm_ftree_sw_get_port_group_by_remote_lid
argument_list|(
name|p_sw
argument_list|,
name|remote_base_lid
argument_list|,
name|direction
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p_group
condition|)
block|{
name|p_group
operator|=
name|__osm_ftree_port_group_create
argument_list|(
name|base_lid
argument_list|,
name|remote_base_lid
argument_list|,
name|port_guid
argument_list|,
name|__osm_ftree_sw_get_guid_no
argument_list|(
name|p_sw
argument_list|)
argument_list|,
name|IB_NODE_TYPE_SWITCH
argument_list|,
name|p_sw
argument_list|,
name|remote_port_guid
argument_list|,
name|remote_node_guid
argument_list|,
name|remote_node_type
argument_list|,
name|p_remote_hca_or_sw
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_group
argument_list|)
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|FTREE_DIRECTION_UP
condition|)
name|p_sw
operator|->
name|up_port_groups
index|[
name|p_sw
operator|->
name|up_port_groups_num
operator|++
index|]
operator|=
name|p_group
expr_stmt|;
else|else
name|p_sw
operator|->
name|down_port_groups
index|[
name|p_sw
operator|->
name|down_port_groups_num
operator|++
index|]
operator|=
name|p_group
expr_stmt|;
block|}
name|__osm_ftree_port_group_add_port
argument_list|(
name|p_group
argument_list|,
name|port_num
argument_list|,
name|remote_port_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_sw_add_port() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|cl_status_t
name|__osm_ftree_sw_set_hops
parameter_list|(
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|uint16_t
name|lid_ho
parameter_list|,
name|IN
name|uint8_t
name|port_num
parameter_list|,
name|IN
name|uint8_t
name|hops
parameter_list|)
block|{
comment|/* set local min hop table(LID) */
return|return
name|osm_switch_set_hops
argument_list|(
name|p_sw
operator|->
name|p_osm_sw
argument_list|,
name|lid_ho
argument_list|,
name|port_num
argument_list|,
name|hops
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************  **  ** ftree_hca_t functions  **  ***************************************************/
end_comment

begin_function
specifier|static
name|ftree_hca_t
modifier|*
name|__osm_ftree_hca_create
parameter_list|(
name|IN
name|osm_node_t
modifier|*
name|p_osm_node
parameter_list|)
block|{
name|ftree_hca_t
modifier|*
name|p_hca
init|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ftree_hca_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|p_hca
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|p_hca
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ftree_hca_t
argument_list|)
argument_list|)
expr_stmt|;
name|p_hca
operator|->
name|p_osm_node
operator|=
name|p_osm_node
expr_stmt|;
name|p_hca
operator|->
name|up_port_groups
operator|=
operator|(
name|ftree_port_group_t
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|osm_node_get_num_physp
argument_list|(
name|p_hca
operator|->
name|p_osm_node
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|ftree_port_group_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_hca
operator|->
name|up_port_groups
condition|)
return|return
name|NULL
return|;
name|p_hca
operator|->
name|up_port_groups_num
operator|=
literal|0
expr_stmt|;
return|return
name|p_hca
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_hca_destroy
parameter_list|(
name|IN
name|ftree_hca_t
modifier|*
name|p_hca
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|p_hca
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_hca
operator|->
name|up_port_groups_num
condition|;
name|i
operator|++
control|)
name|__osm_ftree_port_group_destroy
argument_list|(
name|p_hca
operator|->
name|up_port_groups
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_hca
operator|->
name|up_port_groups
condition|)
name|free
argument_list|(
name|p_hca
operator|->
name|up_port_groups
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_hca
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|uint64_t
name|__osm_ftree_hca_get_guid_no
parameter_list|(
name|IN
name|ftree_hca_t
modifier|*
name|p_hca
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p_hca
condition|)
return|return
literal|0
return|;
return|return
name|osm_node_get_node_guid
argument_list|(
name|p_hca
operator|->
name|p_osm_node
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|uint64_t
name|__osm_ftree_hca_get_guid_ho
parameter_list|(
name|IN
name|ftree_hca_t
modifier|*
name|p_hca
parameter_list|)
block|{
return|return
name|cl_ntoh64
argument_list|(
name|__osm_ftree_hca_get_guid_no
argument_list|(
name|p_hca
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_hca_dump
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_hca_t
modifier|*
name|p_hca
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|p_hca
condition|)
return|return;
if|if
condition|(
operator|!
name|osm_log_is_active
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
return|return;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"CA GUID: 0x%016"
name|PRIx64
literal|", Ports: %u UP\n"
argument_list|,
name|__osm_ftree_hca_get_guid_ho
argument_list|(
name|p_hca
argument_list|)
argument_list|,
name|p_hca
operator|->
name|up_port_groups_num
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_hca
operator|->
name|up_port_groups_num
condition|;
name|i
operator|++
control|)
name|__osm_ftree_port_group_dump
argument_list|(
name|p_ftree
argument_list|,
name|p_hca
operator|->
name|up_port_groups
index|[
name|i
index|]
argument_list|,
name|FTREE_DIRECTION_UP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|ftree_port_group_t
modifier|*
name|__osm_ftree_hca_get_port_group_by_remote_lid
parameter_list|(
name|IN
name|ftree_hca_t
modifier|*
name|p_hca
parameter_list|,
name|IN
name|ib_net16_t
name|remote_base_lid
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_hca
operator|->
name|up_port_groups_num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|remote_base_lid
operator|==
name|p_hca
operator|->
name|up_port_groups
index|[
name|i
index|]
operator|->
name|remote_base_lid
condition|)
return|return
name|p_hca
operator|->
name|up_port_groups
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_hca_add_port
parameter_list|(
name|IN
name|ftree_hca_t
modifier|*
name|p_hca
parameter_list|,
name|IN
name|uint8_t
name|port_num
parameter_list|,
name|IN
name|uint8_t
name|remote_port_num
parameter_list|,
name|IN
name|ib_net16_t
name|base_lid
parameter_list|,
name|IN
name|ib_net16_t
name|remote_base_lid
parameter_list|,
name|IN
name|ib_net64_t
name|port_guid
parameter_list|,
name|IN
name|ib_net64_t
name|remote_port_guid
parameter_list|,
name|IN
name|ib_net64_t
name|remote_node_guid
parameter_list|,
name|IN
name|uint8_t
name|remote_node_type
parameter_list|,
name|IN
name|void
modifier|*
name|p_remote_hca_or_sw
parameter_list|,
name|IN
name|boolean_t
name|is_cn
parameter_list|)
block|{
name|ftree_port_group_t
modifier|*
name|p_group
decl_stmt|;
comment|/* this function is supposed to be called only for adding ports 	   in hca's that lead to switches */
name|CL_ASSERT
argument_list|(
name|remote_node_type
operator|==
name|IB_NODE_TYPE_SWITCH
argument_list|)
expr_stmt|;
name|p_group
operator|=
name|__osm_ftree_hca_get_port_group_by_remote_lid
argument_list|(
name|p_hca
argument_list|,
name|remote_base_lid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_group
condition|)
block|{
name|p_group
operator|=
name|__osm_ftree_port_group_create
argument_list|(
name|base_lid
argument_list|,
name|remote_base_lid
argument_list|,
name|port_guid
argument_list|,
name|__osm_ftree_hca_get_guid_no
argument_list|(
name|p_hca
argument_list|)
argument_list|,
name|IB_NODE_TYPE_CA
argument_list|,
name|p_hca
argument_list|,
name|remote_port_guid
argument_list|,
name|remote_node_guid
argument_list|,
name|remote_node_type
argument_list|,
name|p_remote_hca_or_sw
argument_list|,
name|is_cn
argument_list|)
expr_stmt|;
name|p_hca
operator|->
name|up_port_groups
index|[
name|p_hca
operator|->
name|up_port_groups_num
operator|++
index|]
operator|=
name|p_group
expr_stmt|;
block|}
name|__osm_ftree_port_group_add_port
argument_list|(
name|p_group
argument_list|,
name|port_num
argument_list|,
name|remote_port_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_hca_add_port() */
end_comment

begin_comment
comment|/***************************************************  **  ** ftree_fabric_t functions  **  ***************************************************/
end_comment

begin_function
specifier|static
name|ftree_fabric_t
modifier|*
name|__osm_ftree_fabric_create
parameter_list|()
block|{
name|ftree_fabric_t
modifier|*
name|p_ftree
init|=
operator|(
name|ftree_fabric_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ftree_fabric_t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|p_ftree
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|p_ftree
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ftree_fabric_t
argument_list|)
argument_list|)
expr_stmt|;
name|cl_qmap_init
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
expr_stmt|;
name|cl_qmap_init
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
expr_stmt|;
name|cl_qmap_init
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_by_tuple_tbl
argument_list|)
expr_stmt|;
name|cl_qmap_init
argument_list|(
operator|&
name|p_ftree
operator|->
name|cn_guid_tbl
argument_list|)
expr_stmt|;
name|cl_qlist_init
argument_list|(
operator|&
name|p_ftree
operator|->
name|root_guid_list
argument_list|)
expr_stmt|;
return|return
name|p_ftree
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_fabric_clear
parameter_list|(
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|ftree_hca_t
modifier|*
name|p_hca
decl_stmt|;
name|ftree_hca_t
modifier|*
name|p_next_hca
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_next_sw
decl_stmt|;
name|ftree_sw_tbl_element_t
modifier|*
name|p_element
decl_stmt|;
name|ftree_sw_tbl_element_t
modifier|*
name|p_next_element
decl_stmt|;
name|name_map_item_t
modifier|*
name|p_guid_element
decl_stmt|,
modifier|*
name|p_next_guid_element
decl_stmt|;
if|if
condition|(
operator|!
name|p_ftree
condition|)
return|return;
comment|/* remove all the elements of hca_tbl */
name|p_next_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_hca
operator|!=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
condition|)
block|{
name|p_hca
operator|=
name|p_next_hca
expr_stmt|;
name|p_next_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_hca
operator|->
name|map_item
argument_list|)
expr_stmt|;
name|__osm_ftree_hca_destroy
argument_list|(
name|p_hca
argument_list|)
expr_stmt|;
block|}
name|cl_qmap_remove_all
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
expr_stmt|;
comment|/* remove all the elements of sw_tbl */
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_sw
operator|!=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
condition|)
block|{
name|p_sw
operator|=
name|p_next_sw
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
name|__osm_ftree_sw_destroy
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
argument_list|)
expr_stmt|;
block|}
name|cl_qmap_remove_all
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
expr_stmt|;
comment|/* remove all the elements of sw_by_tuple_tbl */
name|p_next_element
operator|=
operator|(
name|ftree_sw_tbl_element_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_by_tuple_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_element
operator|!=
operator|(
name|ftree_sw_tbl_element_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_by_tuple_tbl
argument_list|)
condition|)
block|{
name|p_element
operator|=
name|p_next_element
expr_stmt|;
name|p_next_element
operator|=
operator|(
name|ftree_sw_tbl_element_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_element
operator|->
name|map_item
argument_list|)
expr_stmt|;
name|__osm_ftree_sw_tbl_element_destroy
argument_list|(
name|p_element
argument_list|)
expr_stmt|;
block|}
name|cl_qmap_remove_all
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_by_tuple_tbl
argument_list|)
expr_stmt|;
comment|/* remove all the elements of cn_guid_tbl */
name|p_next_guid_element
operator|=
operator|(
name|name_map_item_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|cn_guid_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_guid_element
operator|!=
operator|(
name|name_map_item_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|cn_guid_tbl
argument_list|)
condition|)
block|{
name|p_guid_element
operator|=
name|p_next_guid_element
expr_stmt|;
name|p_next_guid_element
operator|=
operator|(
name|name_map_item_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_guid_element
operator|->
name|item
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_guid_element
argument_list|)
expr_stmt|;
block|}
name|cl_qmap_remove_all
argument_list|(
operator|&
name|p_ftree
operator|->
name|cn_guid_tbl
argument_list|)
expr_stmt|;
comment|/* remove all the elements of root_guid_list */
while|while
condition|(
operator|!
name|cl_is_qlist_empty
argument_list|(
operator|&
name|p_ftree
operator|->
name|root_guid_list
argument_list|)
condition|)
name|free
argument_list|(
name|cl_qlist_remove_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|root_guid_list
argument_list|)
argument_list|)
expr_stmt|;
comment|/* free the leaf switches array */
if|if
condition|(
operator|(
name|p_ftree
operator|->
name|leaf_switches_num
operator|>
literal|0
operator|)
operator|&&
operator|(
name|p_ftree
operator|->
name|leaf_switches
operator|)
condition|)
name|free
argument_list|(
name|p_ftree
operator|->
name|leaf_switches
argument_list|)
expr_stmt|;
name|p_ftree
operator|->
name|leaf_switches_num
operator|=
literal|0
expr_stmt|;
name|p_ftree
operator|->
name|cn_num
operator|=
literal|0
expr_stmt|;
name|p_ftree
operator|->
name|leaf_switch_rank
operator|=
literal|0
expr_stmt|;
name|p_ftree
operator|->
name|max_switch_rank
operator|=
literal|0
expr_stmt|;
name|p_ftree
operator|->
name|max_cn_per_leaf
operator|=
literal|0
expr_stmt|;
name|p_ftree
operator|->
name|lft_max_lid_ho
operator|=
literal|0
expr_stmt|;
name|p_ftree
operator|->
name|leaf_switches
operator|=
name|NULL
expr_stmt|;
name|p_ftree
operator|->
name|fabric_built
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_fabric_destroy() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_fabric_destroy
parameter_list|(
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p_ftree
condition|)
return|return;
name|__osm_ftree_fabric_clear
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|uint8_t
name|__osm_ftree_fabric_get_rank
parameter_list|(
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
return|return
name|p_ftree
operator|->
name|leaf_switch_rank
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_fabric_add_hca
parameter_list|(
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|osm_node_t
modifier|*
name|p_osm_node
parameter_list|)
block|{
name|ftree_hca_t
modifier|*
name|p_hca
init|=
name|__osm_ftree_hca_create
argument_list|(
name|p_osm_node
argument_list|)
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|osm_node_get_type
argument_list|(
name|p_osm_node
argument_list|)
operator|==
name|IB_NODE_TYPE_CA
argument_list|)
expr_stmt|;
name|cl_qmap_insert
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|,
name|p_osm_node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|,
operator|&
name|p_hca
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_fabric_add_sw
parameter_list|(
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|osm_switch_t
modifier|*
name|p_osm_sw
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
init|=
name|__osm_ftree_sw_create
argument_list|(
name|p_ftree
argument_list|,
name|p_osm_sw
argument_list|)
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|osm_node_get_type
argument_list|(
name|p_osm_sw
operator|->
name|p_node
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
argument_list|)
expr_stmt|;
name|cl_qmap_insert
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|,
name|p_osm_sw
operator|->
name|p_node
operator|->
name|node_info
operator|.
name|node_guid
argument_list|,
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
comment|/* track the max lid (in host order) that exists in the fabric */
if|if
condition|(
name|cl_ntoh16
argument_list|(
name|p_sw
operator|->
name|base_lid
argument_list|)
operator|>
name|p_ftree
operator|->
name|lft_max_lid_ho
condition|)
name|p_ftree
operator|->
name|lft_max_lid_ho
operator|=
name|cl_ntoh16
argument_list|(
name|p_sw
operator|->
name|base_lid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_fabric_add_sw_by_tuple
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|)
block|{
name|CL_ASSERT
argument_list|(
name|__osm_ftree_tuple_assigned
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|)
expr_stmt|;
name|cl_qmap_insert
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_by_tuple_tbl
argument_list|,
name|__osm_ftree_tuple_to_key
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
operator|&
name|__osm_ftree_sw_tbl_element_create
argument_list|(
name|p_sw
argument_list|)
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|ftree_sw_t
modifier|*
name|__osm_ftree_fabric_get_sw_by_tuple
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_tuple_t
name|tuple
parameter_list|)
block|{
name|ftree_sw_tbl_element_t
modifier|*
name|p_element
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|__osm_ftree_tuple_assigned
argument_list|(
name|tuple
argument_list|)
argument_list|)
expr_stmt|;
name|__osm_ftree_tuple_to_key
argument_list|(
name|tuple
argument_list|)
expr_stmt|;
name|p_element
operator|=
operator|(
name|ftree_sw_tbl_element_t
operator|*
operator|)
name|cl_qmap_get
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_by_tuple_tbl
argument_list|,
name|__osm_ftree_tuple_to_key
argument_list|(
name|tuple
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_element
operator|==
operator|(
name|ftree_sw_tbl_element_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_by_tuple_tbl
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|p_element
operator|->
name|p_sw
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|ftree_sw_t
modifier|*
name|__osm_ftree_fabric_get_sw_by_guid
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|uint64_t
name|guid
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_get
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|,
name|guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|==
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|p_sw
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|ftree_hca_t
modifier|*
name|__osm_ftree_fabric_get_hca_by_guid
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|uint64_t
name|guid
parameter_list|)
block|{
name|ftree_hca_t
modifier|*
name|p_hca
decl_stmt|;
name|p_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_get
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|,
name|guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_hca
operator|==
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|p_hca
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_fabric_dump
parameter_list|(
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|ftree_hca_t
modifier|*
name|p_hca
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
if|if
condition|(
operator|!
name|osm_log_is_active
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
return|return;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"\n"
literal|"                       |-------------------------------|\n"
literal|"                       |-  Full fabric topology dump  -|\n"
literal|"                       |-------------------------------|\n\n"
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"-- CAs:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|p_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
init|;
name|p_hca
operator|!=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
condition|;
name|p_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_hca
operator|->
name|map_item
argument_list|)
control|)
block|{
name|__osm_ftree_hca_dump
argument_list|(
name|p_ftree
argument_list|,
name|p_hca
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_ftree
operator|->
name|max_switch_rank
condition|;
name|i
operator|++
control|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"-- Rank %u switches\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
init|;
name|p_sw
operator|!=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
condition|;
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
control|)
block|{
if|if
condition|(
name|p_sw
operator|->
name|rank
operator|==
name|i
condition|)
name|__osm_ftree_sw_dump
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
argument_list|)
expr_stmt|;
block|}
block|}
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"\n"
literal|"                       |---------------------------------------|\n"
literal|"                       |- Full fabric topology dump completed -|\n"
literal|"                       |---------------------------------------|\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_fabric_dump() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_fabric_dump_general_info
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"General fabric topology info\n"
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"============================\n"
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"  - FatTree rank (roots to leaf switches): %u\n"
argument_list|,
name|p_ftree
operator|->
name|leaf_switch_rank
operator|+
literal|1
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"  - FatTree max switch rank: %u\n"
argument_list|,
name|p_ftree
operator|->
name|max_switch_rank
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"  - Fabric has %u CAs (%u of them CNs), %u switches\n"
argument_list|,
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
argument_list|,
name|p_ftree
operator|->
name|cn_num
argument_list|,
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
operator|>=
name|p_ftree
operator|->
name|cn_num
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|p_ftree
operator|->
name|max_switch_rank
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
init|;
name|p_sw
operator|!=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
condition|;
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
control|)
block|{
if|if
condition|(
name|p_sw
operator|->
name|rank
operator|==
name|i
condition|)
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"  - Fabric has %u switches at rank %u (roots)\n"
argument_list|,
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|p_ftree
operator|->
name|leaf_switch_rank
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"  - Fabric has %u switches at rank %u (%u of them leafs)\n"
argument_list|,
name|j
argument_list|,
name|i
argument_list|,
name|p_ftree
operator|->
name|leaf_switches_num
argument_list|)
expr_stmt|;
else|else
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"  - Fabric has %u switches at rank %u\n"
argument_list|,
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|osm_log_is_active
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"  - Root switches:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
init|;
name|p_sw
operator|!=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
condition|;
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
control|)
block|{
if|if
condition|(
name|p_sw
operator|->
name|rank
operator|==
literal|0
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"      GUID: 0x%016"
name|PRIx64
literal|", LID: %u, Index %s\n"
argument_list|,
name|__osm_ftree_sw_get_guid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_sw
operator|->
name|base_lid
argument_list|)
argument_list|,
name|__osm_ftree_tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"  - Leaf switches (sorted by index):\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_ftree
operator|->
name|leaf_switches_num
condition|;
name|i
operator|++
control|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"      GUID: 0x%016"
name|PRIx64
literal|", LID: %u, Index %s\n"
argument_list|,
name|__osm_ftree_sw_get_guid_ho
argument_list|(
name|p_ftree
operator|->
name|leaf_switches
index|[
name|i
index|]
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_ftree
operator|->
name|leaf_switches
index|[
name|i
index|]
operator|->
name|base_lid
argument_list|)
argument_list|,
name|__osm_ftree_tuple_to_str
argument_list|(
name|p_ftree
operator|->
name|leaf_switches
index|[
name|i
index|]
operator|->
name|tuple
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* __osm_ftree_fabric_dump_general_info() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_fabric_dump_hca_ordering
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|ftree_hca_t
modifier|*
name|p_hca
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_port_group_t
modifier|*
name|p_group_on_sw
decl_stmt|;
name|ftree_port_group_t
modifier|*
name|p_group_on_hca
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|j
decl_stmt|;
name|unsigned
name|printed_hcas_on_leaf
decl_stmt|;
name|char
name|path
index|[
literal|1024
index|]
decl_stmt|;
name|FILE
modifier|*
name|p_hca_ordering_file
decl_stmt|;
name|char
modifier|*
name|filename
init|=
literal|"opensm-ftree-ca-order.dump"
decl_stmt|;
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|dump_files_dir
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|p_hca_ordering_file
operator|=
name|fopen
argument_list|(
name|path
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_hca_ordering_file
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB01: "
literal|"cannot open file \'%s\': %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* for each leaf switch (in indexing order) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_ftree
operator|->
name|leaf_switches_num
condition|;
name|i
operator|++
control|)
block|{
name|p_sw
operator|=
name|p_ftree
operator|->
name|leaf_switches
index|[
name|i
index|]
expr_stmt|;
name|printed_hcas_on_leaf
operator|=
literal|0
expr_stmt|;
comment|/* for each real CA (CNs and not) connected to this switch */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p_sw
operator|->
name|down_port_groups_num
condition|;
name|j
operator|++
control|)
block|{
name|p_group_on_sw
operator|=
name|p_sw
operator|->
name|down_port_groups
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|p_group_on_sw
operator|->
name|remote_node_type
operator|!=
name|IB_NODE_TYPE_CA
condition|)
continue|continue;
name|p_hca
operator|=
name|p_group_on_sw
operator|->
name|remote_hca_or_sw
operator|.
name|p_hca
expr_stmt|;
name|p_group_on_hca
operator|=
name|__osm_ftree_hca_get_port_group_by_remote_lid
argument_list|(
name|p_hca
argument_list|,
name|p_group_on_sw
operator|->
name|base_lid
argument_list|)
expr_stmt|;
comment|/* treat non-compute nodes as dummies */
if|if
condition|(
operator|!
name|p_group_on_hca
operator|->
name|is_cn
condition|)
continue|continue;
name|fprintf
argument_list|(
name|p_hca_ordering_file
argument_list|,
literal|"0x%04x\t%s\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_group_on_hca
operator|->
name|base_lid
argument_list|)
argument_list|,
name|p_hca
operator|->
name|p_osm_node
operator|->
name|print_desc
argument_list|)
expr_stmt|;
name|printed_hcas_on_leaf
operator|++
expr_stmt|;
block|}
comment|/* now print missing HCAs */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|p_ftree
operator|->
name|max_cn_per_leaf
operator|-
name|printed_hcas_on_leaf
operator|)
condition|;
name|j
operator|++
control|)
name|fprintf
argument_list|(
name|p_hca_ordering_file
argument_list|,
literal|"0xFFFF\tDUMMY\n"
argument_list|)
expr_stmt|;
block|}
comment|/* done going through all the leaf switches */
name|fclose
argument_list|(
name|p_hca_ordering_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_fabric_dump_hca_ordering() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_fabric_assign_tuple
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|ftree_tuple_t
name|new_tuple
parameter_list|)
block|{
name|memcpy
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|,
name|new_tuple
argument_list|,
name|FTREE_TUPLE_LEN
argument_list|)
expr_stmt|;
name|__osm_ftree_fabric_add_sw_by_tuple
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_fabric_assign_first_tuple
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|)
block|{
name|uint8_t
name|i
decl_stmt|;
name|ftree_tuple_t
name|new_tuple
decl_stmt|;
name|__osm_ftree_tuple_init
argument_list|(
name|new_tuple
argument_list|)
expr_stmt|;
name|new_tuple
index|[
literal|0
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|p_sw
operator|->
name|rank
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|p_sw
operator|->
name|rank
condition|;
name|i
operator|++
control|)
name|new_tuple
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|__osm_ftree_fabric_assign_tuple
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
argument_list|,
name|new_tuple
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_fabric_get_new_tuple
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|OUT
name|ftree_tuple_t
name|new_tuple
parameter_list|,
name|IN
name|ftree_tuple_t
name|from_tuple
parameter_list|,
name|IN
name|ftree_direction_t
name|direction
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_tuple_t
name|temp_tuple
decl_stmt|;
name|uint8_t
name|var_index
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|__osm_ftree_tuple_init
argument_list|(
name|new_tuple
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|temp_tuple
argument_list|,
name|from_tuple
argument_list|,
name|FTREE_TUPLE_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|FTREE_DIRECTION_DOWN
condition|)
block|{
name|temp_tuple
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|var_index
operator|=
name|from_tuple
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|temp_tuple
index|[
literal|0
index|]
operator|--
expr_stmt|;
name|var_index
operator|=
name|from_tuple
index|[
literal|0
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0xFF
condition|;
name|i
operator|++
control|)
block|{
name|temp_tuple
index|[
name|var_index
index|]
operator|=
name|i
expr_stmt|;
name|p_sw
operator|=
name|__osm_ftree_fabric_get_sw_by_tuple
argument_list|(
name|p_ftree
argument_list|,
name|temp_tuple
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|==
name|NULL
condition|)
comment|/* found free tuple */
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0xFF
condition|)
block|{
comment|/* new tuple not found - there are more than 255 ports in one direction */
return|return;
block|}
name|memcpy
argument_list|(
name|new_tuple
argument_list|,
name|temp_tuple
argument_list|,
name|FTREE_TUPLE_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_fabric_get_new_tuple() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|boolean_t
name|__osm_ftree_fabric_roots_provided
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
return|return
operator|(
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|root_guid_file
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|boolean_t
name|__osm_ftree_fabric_cns_provided
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
return|return
operator|(
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|cn_guid_file
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|int
name|__osm_ftree_fabric_mark_leaf_switches
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_hca_t
modifier|*
name|p_hca
decl_stmt|;
name|ftree_hca_t
modifier|*
name|p_next_hca
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Marking leaf switches in fabric\n"
argument_list|)
expr_stmt|;
comment|/* Scan all the CAs, if they have CNs - find CN port and mark switch 	   that is connected to this port as leaf switch. 	   Also, ensure that this marked leaf has rank of p_ftree->leaf_switch_rank. */
name|p_next_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_hca
operator|!=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
condition|)
block|{
name|p_hca
operator|=
name|p_next_hca
expr_stmt|;
name|p_next_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_hca
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_hca
operator|->
name|cn_num
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_hca
operator|->
name|up_port_groups_num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|p_hca
operator|->
name|up_port_groups
index|[
name|i
index|]
operator|->
name|is_cn
condition|)
continue|continue;
comment|/* In CAs, port group alway has one port, and since this 			   port group is CN, we know that this port is compute node */
name|CL_ASSERT
argument_list|(
name|p_hca
operator|->
name|up_port_groups
index|[
name|i
index|]
operator|->
name|remote_node_type
operator|==
name|IB_NODE_TYPE_SWITCH
argument_list|)
expr_stmt|;
name|p_sw
operator|=
name|p_hca
operator|->
name|up_port_groups
index|[
name|i
index|]
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
expr_stmt|;
comment|/* check if this switch was already processed */
if|if
condition|(
name|p_sw
operator|->
name|is_leaf
condition|)
continue|continue;
name|p_sw
operator|->
name|is_leaf
operator|=
name|TRUE
expr_stmt|;
comment|/* ensure that this leaf switch is at the correct tree level */
if|if
condition|(
name|p_sw
operator|->
name|rank
operator|!=
name|p_ftree
operator|->
name|leaf_switch_rank
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB26: CN port 0x%"
name|PRIx64
literal|" is connected to switch 0x%"
name|PRIx64
literal|" with rank %u, "
literal|"while FatTree leaf rank is %u\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_hca
operator|->
name|up_port_groups
index|[
name|i
index|]
operator|->
name|port_guid
argument_list|)
argument_list|,
name|__osm_ftree_sw_get_guid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|,
name|p_sw
operator|->
name|rank
argument_list|,
name|p_ftree
operator|->
name|leaf_switch_rank
argument_list|)
expr_stmt|;
name|res
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_fabric_mark_leaf_switches() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_fabric_make_indexing
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_remote_sw
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_sw
init|=
name|NULL
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_next_sw
decl_stmt|;
name|ftree_tuple_t
name|new_tuple
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|cl_list_t
name|bfs_list
decl_stmt|;
name|ftree_sw_tbl_element_t
modifier|*
name|p_sw_tbl_element
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Starting FatTree indexing\n"
argument_list|)
expr_stmt|;
comment|/* using the first leaf switch as a starting point for indexing algorithm. */
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_sw
operator|!=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
condition|)
block|{
name|p_sw
operator|=
name|p_next_sw
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|is_leaf
condition|)
break|break;
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
name|CL_ASSERT
argument_list|(
name|p_next_sw
operator|!=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Assign the first tuple to the switch that is used as BFS starting point. 	   The tuple will be as follows: [rank].0.0.0... 	   This fuction also adds the switch it into the switch_by_tuple table. */
name|__osm_ftree_fabric_assign_first_tuple
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Indexing starting point:\n"
literal|"                                            - Switch rank  : %u\n"
literal|"                                            - Switch index : %s\n"
literal|"                                            - Node LID     : %u\n"
literal|"                                            - Node GUID    : 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|p_sw
operator|->
name|rank
argument_list|,
name|__osm_ftree_tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_sw
operator|->
name|base_lid
argument_list|)
argument_list|,
name|__osm_ftree_sw_get_guid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Now run BFS and assign indexes to all switches 	 * Pseudo code of the algorithm is as follows: 	 * 	 *  * Add first switch to BFS queue 	 *  * While (BFS queue not empty) 	 *      - Pop the switch from the head of the queue 	 *      - Scan all the downward and upward ports 	 *      - For each port 	 *          + Get the remote switch 	 *          + Assign index to the remote switch 	 *          + Add remote switch to the BFS queue 	 */
name|cl_list_init
argument_list|(
operator|&
name|bfs_list
argument_list|,
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
argument_list|)
expr_stmt|;
name|cl_list_insert_tail
argument_list|(
operator|&
name|bfs_list
argument_list|,
operator|&
name|__osm_ftree_sw_tbl_element_create
argument_list|(
name|p_sw
argument_list|)
operator|->
name|map_item
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|cl_is_list_empty
argument_list|(
operator|&
name|bfs_list
argument_list|)
condition|)
block|{
name|p_sw_tbl_element
operator|=
operator|(
name|ftree_sw_tbl_element_t
operator|*
operator|)
name|cl_list_remove_head
argument_list|(
operator|&
name|bfs_list
argument_list|)
expr_stmt|;
name|p_sw
operator|=
name|p_sw_tbl_element
operator|->
name|p_sw
expr_stmt|;
name|__osm_ftree_sw_tbl_element_destroy
argument_list|(
name|p_sw_tbl_element
argument_list|)
expr_stmt|;
comment|/* Discover all the nodes from ports that are pointing down */
if|if
condition|(
name|p_sw
operator|->
name|rank
operator|>=
name|p_ftree
operator|->
name|leaf_switch_rank
condition|)
block|{
comment|/* whether downward ports are pointing to CAs or switches, 			   we don't assign indexes to switches that are located 			   lower than leaf switches */
block|}
else|else
block|{
comment|/* This is not the leaf switch */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|down_port_groups_num
condition|;
name|i
operator|++
control|)
block|{
comment|/* Work with port groups that are pointing to switches only. 				   No need to assign indexing to HCAs */
if|if
condition|(
name|p_sw
operator|->
name|down_port_groups
index|[
name|i
index|]
operator|->
name|remote_node_type
operator|!=
name|IB_NODE_TYPE_SWITCH
condition|)
continue|continue;
name|p_remote_sw
operator|=
name|p_sw
operator|->
name|down_port_groups
index|[
name|i
index|]
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
expr_stmt|;
if|if
condition|(
name|__osm_ftree_tuple_assigned
argument_list|(
name|p_remote_sw
operator|->
name|tuple
argument_list|)
condition|)
block|{
comment|/* this switch has been already indexed */
continue|continue;
block|}
comment|/* allocate new tuple */
name|__osm_ftree_fabric_get_new_tuple
argument_list|(
name|p_ftree
argument_list|,
name|new_tuple
argument_list|,
name|p_sw
operator|->
name|tuple
argument_list|,
name|FTREE_DIRECTION_DOWN
argument_list|)
expr_stmt|;
comment|/* Assign the new tuple to the remote switch. 				   This fuction also adds the switch into the switch_by_tuple table. */
name|__osm_ftree_fabric_assign_tuple
argument_list|(
name|p_ftree
argument_list|,
name|p_remote_sw
argument_list|,
name|new_tuple
argument_list|)
expr_stmt|;
comment|/* add the newly discovered switch to the BFS queue */
name|cl_list_insert_tail
argument_list|(
operator|&
name|bfs_list
argument_list|,
operator|&
name|__osm_ftree_sw_tbl_element_create
argument_list|(
name|p_remote_sw
argument_list|)
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
comment|/* Done assigning indexes to all the remote switches 			   that are pointed by the downgoing ports. 			   Now sort port groups according to remote index. */
name|qsort
argument_list|(
name|p_sw
operator|->
name|down_port_groups
argument_list|,
comment|/* array */
name|p_sw
operator|->
name|down_port_groups_num
argument_list|,
comment|/* number of elements */
sizeof|sizeof
argument_list|(
name|ftree_port_group_t
operator|*
argument_list|)
argument_list|,
comment|/* size of each element */
name|__osm_ftree_compare_port_groups_by_remote_switch_index
argument_list|)
expr_stmt|;
comment|/* comparator */
block|}
comment|/* Done indexing switches from ports that go down. 		   Now do the same with ports that are pointing up. */
if|if
condition|(
name|p_sw
operator|->
name|rank
operator|!=
literal|0
condition|)
block|{
comment|/* This is not the root switch, which means that all the ports 			   that are pointing up are taking us to another switches. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|up_port_groups_num
condition|;
name|i
operator|++
control|)
block|{
name|p_remote_sw
operator|=
name|p_sw
operator|->
name|up_port_groups
index|[
name|i
index|]
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
expr_stmt|;
if|if
condition|(
name|__osm_ftree_tuple_assigned
argument_list|(
name|p_remote_sw
operator|->
name|tuple
argument_list|)
condition|)
continue|continue;
comment|/* allocate new tuple */
name|__osm_ftree_fabric_get_new_tuple
argument_list|(
name|p_ftree
argument_list|,
name|new_tuple
argument_list|,
name|p_sw
operator|->
name|tuple
argument_list|,
name|FTREE_DIRECTION_UP
argument_list|)
expr_stmt|;
comment|/* Assign the new tuple to the remote switch. 				   This fuction also adds the switch to the 				   switch_by_tuple table. */
name|__osm_ftree_fabric_assign_tuple
argument_list|(
name|p_ftree
argument_list|,
name|p_remote_sw
argument_list|,
name|new_tuple
argument_list|)
expr_stmt|;
comment|/* add the newly discovered switch to the BFS queue */
name|cl_list_insert_tail
argument_list|(
operator|&
name|bfs_list
argument_list|,
operator|&
name|__osm_ftree_sw_tbl_element_create
argument_list|(
name|p_remote_sw
argument_list|)
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
comment|/* Done assigning indexes to all the remote switches 			   that are pointed by the upgoing ports. 			   Now sort port groups according to remote index. */
name|qsort
argument_list|(
name|p_sw
operator|->
name|up_port_groups
argument_list|,
comment|/* array */
name|p_sw
operator|->
name|up_port_groups_num
argument_list|,
comment|/* number of elements */
sizeof|sizeof
argument_list|(
name|ftree_port_group_t
operator|*
argument_list|)
argument_list|,
comment|/* size of each element */
name|__osm_ftree_compare_port_groups_by_remote_switch_index
argument_list|)
expr_stmt|;
comment|/* comparator */
block|}
comment|/* Done assigning indexes to all the switches that are directly connected 		   to the current switch - go to the next switch in the BFS queue */
block|}
name|cl_list_destroy
argument_list|(
operator|&
name|bfs_list
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_fabric_make_indexing() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|int
name|__osm_ftree_fabric_create_leaf_switch_array
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_next_sw
decl_stmt|;
name|ftree_sw_t
modifier|*
modifier|*
name|all_switches_at_leaf_level
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|unsigned
name|all_leaf_idx
init|=
literal|0
decl_stmt|;
name|unsigned
name|first_leaf_idx
decl_stmt|;
name|unsigned
name|last_leaf_idx
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
comment|/* create array of ALL the switches that have leaf rank */
name|all_switches_at_leaf_level
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|ftree_sw_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|all_switches_at_leaf_level
condition|)
block|{
name|osm_log
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
literal|"Fat-tree routing: Memory allocation failed\n"
argument_list|)
expr_stmt|;
name|res
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|memset
argument_list|(
name|all_switches_at_leaf_level
argument_list|,
literal|0
argument_list|,
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|ftree_sw_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_sw
operator|!=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
condition|)
block|{
name|p_sw
operator|=
name|p_next_sw
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_sw
operator|->
name|rank
operator|==
name|p_ftree
operator|->
name|leaf_switch_rank
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Adding switch 0x%"
name|PRIx64
literal|" to full leaf switch array\n"
argument_list|,
name|__osm_ftree_sw_get_guid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|)
expr_stmt|;
name|all_switches_at_leaf_level
index|[
name|all_leaf_idx
operator|++
index|]
operator|=
name|p_sw
expr_stmt|;
block|}
block|}
comment|/* quick-sort array of leaf switches by index */
name|qsort
argument_list|(
name|all_switches_at_leaf_level
argument_list|,
comment|/* array */
name|all_leaf_idx
argument_list|,
comment|/* number of elements */
sizeof|sizeof
argument_list|(
name|ftree_sw_t
operator|*
argument_list|)
argument_list|,
comment|/* size of each element */
name|__osm_ftree_compare_switches_by_index
argument_list|)
expr_stmt|;
comment|/* comparator */
comment|/* check the first and the last REAL leaf (the one 	   that has CNs) in the array of all the leafs */
name|first_leaf_idx
operator|=
name|all_leaf_idx
expr_stmt|;
name|last_leaf_idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|all_leaf_idx
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|all_switches_at_leaf_level
index|[
name|i
index|]
operator|->
name|is_leaf
condition|)
block|{
if|if
condition|(
name|i
operator|<
name|first_leaf_idx
condition|)
name|first_leaf_idx
operator|=
name|i
expr_stmt|;
name|last_leaf_idx
operator|=
name|i
expr_stmt|;
block|}
block|}
name|CL_ASSERT
argument_list|(
name|first_leaf_idx
operator|<
name|last_leaf_idx
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Full leaf array info: first_leaf_idx = %u, last_leaf_idx = %u\n"
argument_list|,
name|first_leaf_idx
argument_list|,
name|last_leaf_idx
argument_list|)
expr_stmt|;
comment|/* Create array of REAL leaf switches, sorted by index. 	   This array may contain switches at the same rank w/o CNs, 	   in case this is the order of indexing. */
name|p_ftree
operator|->
name|leaf_switches_num
operator|=
name|last_leaf_idx
operator|-
name|first_leaf_idx
operator|+
literal|1
expr_stmt|;
name|p_ftree
operator|->
name|leaf_switches
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|p_ftree
operator|->
name|leaf_switches_num
operator|*
sizeof|sizeof
argument_list|(
name|ftree_sw_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ftree
operator|->
name|leaf_switches
condition|)
block|{
name|osm_log
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
literal|"Fat-tree routing: Memory allocation failed\n"
argument_list|)
expr_stmt|;
name|res
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|memcpy
argument_list|(
name|p_ftree
operator|->
name|leaf_switches
argument_list|,
operator|&
operator|(
name|all_switches_at_leaf_level
index|[
name|first_leaf_idx
index|]
operator|)
argument_list|,
name|p_ftree
operator|->
name|leaf_switches_num
operator|*
sizeof|sizeof
argument_list|(
name|ftree_sw_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|all_switches_at_leaf_level
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Created array of %u leaf switches\n"
argument_list|,
name|p_ftree
operator|->
name|leaf_switches_num
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_fabric_create_leaf_switch_array() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_fabric_set_max_cn_per_leaf
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|unsigned
name|j
decl_stmt|;
name|unsigned
name|cns_on_this_leaf
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_port_group_t
modifier|*
name|p_group
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_ftree
operator|->
name|leaf_switches_num
condition|;
name|i
operator|++
control|)
block|{
name|p_sw
operator|=
name|p_ftree
operator|->
name|leaf_switches
index|[
name|i
index|]
expr_stmt|;
name|cns_on_this_leaf
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p_sw
operator|->
name|down_port_groups_num
condition|;
name|j
operator|++
control|)
block|{
name|p_group
operator|=
name|p_sw
operator|->
name|down_port_groups
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|p_group
operator|->
name|remote_node_type
operator|!=
name|IB_NODE_TYPE_CA
condition|)
continue|continue;
name|cns_on_this_leaf
operator|+=
name|p_group
operator|->
name|remote_hca_or_sw
operator|.
name|p_hca
operator|->
name|cn_num
expr_stmt|;
block|}
if|if
condition|(
name|cns_on_this_leaf
operator|>
name|p_ftree
operator|->
name|max_cn_per_leaf
condition|)
name|p_ftree
operator|->
name|max_cn_per_leaf
operator|=
name|cns_on_this_leaf
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* __osm_ftree_fabric_set_max_cn_per_leaf() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|boolean_t
name|__osm_ftree_fabric_validate_topology
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|ftree_port_group_t
modifier|*
name|p_group
decl_stmt|;
name|ftree_port_group_t
modifier|*
name|p_ref_group
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_next_sw
decl_stmt|;
name|ftree_sw_t
modifier|*
modifier|*
name|reference_sw_arr
decl_stmt|;
name|uint16_t
name|tree_rank
init|=
name|__osm_ftree_fabric_get_rank
argument_list|(
name|p_ftree
argument_list|)
decl_stmt|;
name|boolean_t
name|res
init|=
name|TRUE
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Validating fabric topology\n"
argument_list|)
expr_stmt|;
name|reference_sw_arr
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|tree_rank
operator|*
sizeof|sizeof
argument_list|(
name|ftree_sw_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reference_sw_arr
operator|==
name|NULL
condition|)
block|{
name|osm_log
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
literal|"Fat-tree routing: Memory allocation failed\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|memset
argument_list|(
name|reference_sw_arr
argument_list|,
literal|0
argument_list|,
name|tree_rank
operator|*
sizeof|sizeof
argument_list|(
name|ftree_sw_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|res
operator|&&
name|p_next_sw
operator|!=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
condition|)
block|{
name|p_sw
operator|=
name|p_next_sw
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
condition|)
block|{
comment|/* This is the first switch in the current level that 			   we're checking - use it as a reference */
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|=
name|p_sw
expr_stmt|;
block|}
else|else
block|{
comment|/* compare this switch properties to the reference switch */
if|if
condition|(
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|up_port_groups_num
operator|!=
name|p_sw
operator|->
name|up_port_groups_num
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB09: Different number of upward port groups on switches:\n"
literal|"       GUID 0x%016"
name|PRIx64
literal|", LID %u, Index %s - %u groups\n"
literal|"       GUID 0x%016"
name|PRIx64
literal|", LID %u, Index %s - %u groups\n"
argument_list|,
name|__osm_ftree_sw_get_guid_ho
argument_list|(
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|base_lid
argument_list|)
argument_list|,
name|__osm_ftree_tuple_to_str
argument_list|(
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|tuple
argument_list|)
argument_list|,
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|up_port_groups_num
argument_list|,
name|__osm_ftree_sw_get_guid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_sw
operator|->
name|base_lid
argument_list|)
argument_list|,
name|__osm_ftree_tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|p_sw
operator|->
name|up_port_groups_num
argument_list|)
expr_stmt|;
name|res
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p_sw
operator|->
name|rank
operator|!=
operator|(
name|tree_rank
operator|-
literal|1
operator|)
operator|&&
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|down_port_groups_num
operator|!=
name|p_sw
operator|->
name|down_port_groups_num
condition|)
block|{
comment|/* we're allowing some hca's to be missing */
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB0A: Different number of downward port groups on switches:\n"
literal|"       GUID 0x%016"
name|PRIx64
literal|", LID %u, Index %s - %u port groups\n"
literal|"       GUID 0x%016"
name|PRIx64
literal|", LID %u, Index %s - %u port groups\n"
argument_list|,
name|__osm_ftree_sw_get_guid_ho
argument_list|(
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|base_lid
argument_list|)
argument_list|,
name|__osm_ftree_tuple_to_str
argument_list|(
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|tuple
argument_list|)
argument_list|,
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|down_port_groups_num
argument_list|,
name|__osm_ftree_sw_get_guid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_sw
operator|->
name|base_lid
argument_list|)
argument_list|,
name|__osm_ftree_tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|p_sw
operator|->
name|down_port_groups_num
argument_list|)
expr_stmt|;
name|res
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|up_port_groups_num
operator|!=
literal|0
condition|)
block|{
name|p_ref_group
operator|=
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|up_port_groups
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|up_port_groups_num
condition|;
name|i
operator|++
control|)
block|{
name|p_group
operator|=
name|p_sw
operator|->
name|up_port_groups
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_ref_group
operator|->
name|ports
argument_list|)
operator|!=
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB0B: Different number of ports in an upward port group on switches:\n"
literal|"       GUID 0x%016"
name|PRIx64
literal|", LID %u, Index %s - %u ports\n"
literal|"       GUID 0x%016"
name|PRIx64
literal|", LID %u, Index %s - %u ports\n"
argument_list|,
name|__osm_ftree_sw_get_guid_ho
argument_list|(
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|base_lid
argument_list|)
argument_list|,
name|__osm_ftree_tuple_to_str
argument_list|(
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|tuple
argument_list|)
argument_list|,
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_ref_group
operator|->
name|ports
argument_list|)
argument_list|,
name|__osm_ftree_sw_get_guid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_sw
operator|->
name|base_lid
argument_list|)
argument_list|,
name|__osm_ftree_tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|down_port_groups_num
operator|!=
literal|0
operator|&&
name|p_sw
operator|->
name|rank
operator|!=
operator|(
name|tree_rank
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* we're allowing some hca's to be missing */
name|p_ref_group
operator|=
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|down_port_groups
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|down_port_groups_num
condition|;
name|i
operator|++
control|)
block|{
name|p_group
operator|=
name|p_sw
operator|->
name|down_port_groups
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_ref_group
operator|->
name|ports
argument_list|)
operator|!=
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB0C: Different number of ports in an downward port group on switches:\n"
literal|"       GUID 0x%016"
name|PRIx64
literal|", LID %u, Index %s - %u ports\n"
literal|"       GUID 0x%016"
name|PRIx64
literal|", LID %u, Index %s - %u ports\n"
argument_list|,
name|__osm_ftree_sw_get_guid_ho
argument_list|(
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|base_lid
argument_list|)
argument_list|,
name|__osm_ftree_tuple_to_str
argument_list|(
name|reference_sw_arr
index|[
name|p_sw
operator|->
name|rank
index|]
operator|->
name|tuple
argument_list|)
argument_list|,
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_ref_group
operator|->
name|ports
argument_list|)
argument_list|,
name|__osm_ftree_sw_get_guid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_sw
operator|->
name|base_lid
argument_list|)
argument_list|,
name|__osm_ftree_tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* end of else */
block|}
comment|/* end of while */
if|if
condition|(
name|res
operator|==
name|TRUE
condition|)
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Fabric topology has been identified as FatTree\n"
argument_list|)
expr_stmt|;
else|else
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB0D: Fabric topology hasn't been identified as FatTree\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reference_sw_arr
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_fabric_validate_topology() */
end_comment

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_set_sw_fwd_table
parameter_list|(
name|IN
name|cl_map_item_t
modifier|*
specifier|const
name|p_map_item
parameter_list|,
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
init|=
operator|(
name|ftree_sw_t
operator|*
specifier|const
operator|)
name|p_map_item
decl_stmt|;
name|ftree_fabric_t
modifier|*
name|p_ftree
init|=
operator|(
name|ftree_fabric_t
operator|*
operator|)
name|context
decl_stmt|;
name|p_sw
operator|->
name|p_osm_sw
operator|->
name|max_lid_ho
operator|=
name|p_ftree
operator|->
name|lft_max_lid_ho
expr_stmt|;
name|osm_ucast_mgr_set_fwd_table
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|sm
operator|.
name|ucast_mgr
argument_list|,
name|p_sw
operator|->
name|p_osm_sw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_comment
comment|/*  * Function: assign-up-going-port-by-descending-down  * Given   : a switch and a LID  * Pseudo code:  *    foreach down-going-port-group (in indexing order)  *        skip this group if the LFT(LID) port is part of this group  *        find the least loaded port of the group (scan in indexing order)  *        r-port is the remote port connected to it  *        assign the remote switch node LFT(LID) to r-port  *        increase r-port usage counter  *        assign-up-going-port-by-descending-down to r-port node (recursion)  */
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_fabric_route_upgoing_by_going_down
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|ftree_sw_t
modifier|*
name|p_prev_sw
parameter_list|,
name|IN
name|ib_net16_t
name|target_lid
parameter_list|,
name|IN
name|uint8_t
name|target_rank
parameter_list|,
name|IN
name|boolean_t
name|is_real_lid
parameter_list|,
name|IN
name|boolean_t
name|is_main_path
parameter_list|,
name|IN
name|uint8_t
name|highest_rank_in_route
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_remote_sw
decl_stmt|;
name|uint16_t
name|ports_num
decl_stmt|;
name|ftree_port_group_t
modifier|*
name|p_group
decl_stmt|;
name|ftree_port_t
modifier|*
name|p_port
decl_stmt|;
name|ftree_port_t
modifier|*
name|p_min_port
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|uint16_t
name|j
decl_stmt|;
name|uint16_t
name|k
decl_stmt|;
comment|/* we shouldn't enter here if both real_lid and main_path are false */
name|CL_ASSERT
argument_list|(
name|is_real_lid
operator|||
name|is_main_path
argument_list|)
expr_stmt|;
comment|/* if there is no down-going ports */
if|if
condition|(
name|p_sw
operator|->
name|down_port_groups_num
operator|==
literal|0
condition|)
return|return;
comment|/* promote the index that indicates which group should we 	   start with when going through all the downgoing groups */
name|p_sw
operator|->
name|down_port_groups_idx
operator|=
operator|(
name|p_sw
operator|->
name|down_port_groups_idx
operator|+
literal|1
operator|)
operator|%
name|p_sw
operator|->
name|down_port_groups_num
expr_stmt|;
comment|/* foreach down-going port group (in indexing order) */
name|i
operator|=
name|p_sw
operator|->
name|down_port_groups_idx
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|p_sw
operator|->
name|down_port_groups_num
condition|;
name|k
operator|++
control|)
block|{
name|p_group
operator|=
name|p_sw
operator|->
name|down_port_groups
index|[
name|i
index|]
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|p_sw
operator|->
name|down_port_groups_num
expr_stmt|;
comment|/* Skip this port group unless it points to a switch */
if|if
condition|(
name|p_group
operator|->
name|remote_node_type
operator|!=
name|IB_NODE_TYPE_SWITCH
condition|)
continue|continue;
if|if
condition|(
name|p_prev_sw
operator|&&
operator|(
name|p_group
operator|->
name|remote_base_lid
operator|==
name|p_prev_sw
operator|->
name|base_lid
operator|)
condition|)
block|{
comment|/* This port group has a port that was used when we entered this switch, 			   which means that the current group points to the switch where we were 			   at the previous step of the algorithm (before going up). 			   Skipping this group. */
continue|continue;
block|}
comment|/* find the least loaded port of the group (in indexing order) */
name|p_min_port
operator|=
name|NULL
expr_stmt|;
name|ports_num
operator|=
operator|(
name|uint16_t
operator|)
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|)
expr_stmt|;
comment|/* ToDo: no need to select a least loaded port for non-main path. 		   Think about optimization. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ports_num
condition|;
name|j
operator|++
control|)
block|{
name|cl_ptr_vector_at
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|,
name|j
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_min_port
condition|)
block|{
comment|/* first port that we're checking - set as port with the lowest load */
name|p_min_port
operator|=
name|p_port
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_port
operator|->
name|counter_up
operator|<
name|p_min_port
operator|->
name|counter_up
condition|)
block|{
comment|/* this port is less loaded - use it as min */
name|p_min_port
operator|=
name|p_port
expr_stmt|;
block|}
block|}
comment|/* At this point we have selected a port in this group with the 		   lowest load of upgoing routes. 		   Set on the remote switch how to get to the target_lid - 		   set LFT(target_lid) on the remote switch to the remote port */
name|p_remote_sw
operator|=
name|p_group
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
expr_stmt|;
if|if
condition|(
name|osm_switch_get_least_hops
argument_list|(
name|p_remote_sw
operator|->
name|p_osm_sw
argument_list|,
name|cl_ntoh16
argument_list|(
name|target_lid
argument_list|)
argument_list|)
operator|!=
name|OSM_NO_PATH
condition|)
block|{
comment|/* Loop in the fabric - we already routed the remote switch 			   on our way UP, and now we see it again on our way DOWN */
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Loop of lenght %d in the fabric:\n                             "
literal|"Switch %s (LID %u) closes loop through switch %s (LID %u)\n"
argument_list|,
operator|(
name|p_remote_sw
operator|->
name|rank
operator|-
name|highest_rank_in_route
operator|)
operator|*
literal|2
argument_list|,
name|__osm_ftree_tuple_to_str
argument_list|(
name|p_remote_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_group
operator|->
name|base_lid
argument_list|)
argument_list|,
name|__osm_ftree_tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_group
operator|->
name|remote_base_lid
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Four possible cases: 		 * 		 *  1. is_real_lid == TRUE&& is_main_path == TRUE: 		 *      - going DOWN(TRUE,TRUE) through ALL the groups 		 *         + promoting port counter 		 *         + setting path in remote switch fwd tbl 		 *         + setting hops in remote switch on all the ports of each group 		 * 		 *  2. is_real_lid == TRUE&& is_main_path == FALSE: 		 *      - going DOWN(TRUE,FALSE) through ALL the groups but only if 		 *        the remote (lower) switch hasn't been already configured 		 *        for this target LID 		 *         + NOT promoting port counter 		 *         + setting path in remote switch fwd tbl if it hasn't been set yet 		 *         + setting hops in remote switch on all the ports of each group 		 *           if it hasn't been set yet 		 * 		 *  3. is_real_lid == FALSE&& is_main_path == TRUE: 		 *      - going DOWN(FALSE,TRUE) through ALL the groups 		 *         + promoting port counter 		 *         + NOT setting path in remote switch fwd tbl 		 *         + NOT setting hops in remote switch 		 * 		 *  4. is_real_lid == FALSE&& is_main_path == FALSE: 		 *      - illegal state - we shouldn't get here 		 */
comment|/* second case: skip the port group if the remote (lower) 		   switch has been already configured for this target LID */
if|if
condition|(
name|is_real_lid
operator|&&
operator|!
name|is_main_path
operator|&&
name|p_remote_sw
operator|->
name|p_osm_sw
operator|->
name|new_lft
index|[
name|cl_ntoh16
argument_list|(
name|target_lid
argument_list|)
index|]
operator|!=
name|OSM_NO_PATH
condition|)
continue|continue;
comment|/* setting fwd tbl port only if this is real LID */
if|if
condition|(
name|is_real_lid
condition|)
block|{
name|p_remote_sw
operator|->
name|p_osm_sw
operator|->
name|new_lft
index|[
name|cl_ntoh16
argument_list|(
name|target_lid
argument_list|)
index|]
operator|=
name|p_min_port
operator|->
name|remote_port_num
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Switch %s: set path to CA LID %u through port %u\n"
argument_list|,
name|__osm_ftree_tuple_to_str
argument_list|(
name|p_remote_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|target_lid
argument_list|)
argument_list|,
name|p_min_port
operator|->
name|remote_port_num
argument_list|)
expr_stmt|;
comment|/* On the remote switch that is pointed by the p_group, 			   set hops for ALL the ports in the remote group. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ports_num
condition|;
name|j
operator|++
control|)
block|{
name|cl_ptr_vector_at
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|,
name|j
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_port
argument_list|)
expr_stmt|;
name|__osm_ftree_sw_set_hops
argument_list|(
name|p_remote_sw
argument_list|,
name|cl_ntoh16
argument_list|(
name|target_lid
argument_list|)
argument_list|,
name|p_port
operator|->
name|remote_port_num
argument_list|,
operator|(
operator|(
name|target_rank
operator|-
name|highest_rank_in_route
operator|)
operator|+
operator|(
name|p_remote_sw
operator|->
name|rank
operator|-
name|highest_rank_in_route
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The number of upgoing routes is tracked in the 		   p_port->counter_up counter of the port that belongs to 		   the upper side of the link (on switch with lower rank). 		   Counter is promoted only if we're routing LID on the main 		   path (whether it's a real LID or a dummy one). */
if|if
condition|(
name|is_main_path
condition|)
name|p_min_port
operator|->
name|counter_up
operator|++
expr_stmt|;
comment|/* Recursion step: 		   Assign upgoing ports by stepping down, starting on REMOTE switch */
name|__osm_ftree_fabric_route_upgoing_by_going_down
argument_list|(
name|p_ftree
argument_list|,
name|p_remote_sw
argument_list|,
comment|/* remote switch - used as a route-upgoing alg. start point */
name|NULL
argument_list|,
comment|/* prev. position - NULL to mark that we went down and not up */
name|target_lid
argument_list|,
comment|/* LID that we're routing to */
name|target_rank
argument_list|,
comment|/* rank of the LID that we're routing to */
name|is_real_lid
argument_list|,
comment|/* whether the target LID is real or dummy */
name|is_main_path
argument_list|,
comment|/* whether this is path to HCA that should by tracked by counters */
name|highest_rank_in_route
argument_list|)
expr_stmt|;
comment|/* highest visited point in the tree before going down */
block|}
comment|/* done scanning all the down-going port groups */
block|}
end_function

begin_comment
comment|/* __osm_ftree_fabric_route_upgoing_by_going_down() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_comment
comment|/*  * Function: assign-down-going-port-by-ascending-up  * Given   : a switch and a LID  * Pseudo code:  *    find the least loaded port of all the upgoing groups (scan in indexing order)  *    assign the LFT(LID) of remote switch to that port  *    track that port usage  *    assign-up-going-port-by-descending-down on CURRENT switch  *    assign-down-going-port-by-ascending-up on REMOTE switch (recursion)  */
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_fabric_route_downgoing_by_going_up
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|ftree_sw_t
modifier|*
name|p_prev_sw
parameter_list|,
name|IN
name|ib_net16_t
name|target_lid
parameter_list|,
name|IN
name|uint8_t
name|target_rank
parameter_list|,
name|IN
name|boolean_t
name|is_real_lid
parameter_list|,
name|IN
name|boolean_t
name|is_main_path
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_remote_sw
decl_stmt|;
name|uint16_t
name|ports_num
decl_stmt|;
name|ftree_port_group_t
modifier|*
name|p_group
decl_stmt|;
name|ftree_port_t
modifier|*
name|p_port
decl_stmt|;
name|ftree_port_group_t
modifier|*
name|p_min_group
decl_stmt|;
name|ftree_port_t
modifier|*
name|p_min_port
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
name|uint16_t
name|j
decl_stmt|;
comment|/* we shouldn't enter here if both real_lid and main_path are false */
name|CL_ASSERT
argument_list|(
name|is_real_lid
operator|||
name|is_main_path
argument_list|)
expr_stmt|;
comment|/* Assign upgoing ports by stepping down, starting on THIS switch */
name|__osm_ftree_fabric_route_upgoing_by_going_down
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
argument_list|,
comment|/* local switch - used as a route-upgoing alg. start point */
name|p_prev_sw
argument_list|,
comment|/* switch that we went up from (NULL means that we went down) */
name|target_lid
argument_list|,
comment|/* LID that we're routing to */
name|target_rank
argument_list|,
comment|/* rank of the LID that we're routing to */
name|is_real_lid
argument_list|,
comment|/* whether this target LID is real or dummy */
name|is_main_path
argument_list|,
comment|/* whether this path to HCA should by tracked by counters */
name|p_sw
operator|->
name|rank
argument_list|)
expr_stmt|;
comment|/* the highest visited point in the tree before going down */
comment|/* recursion stop condition - if it's a root switch, */
if|if
condition|(
name|p_sw
operator|->
name|rank
operator|==
literal|0
condition|)
return|return;
comment|/* Find the least loaded upgoing port group */
name|p_min_group
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|up_port_groups_num
condition|;
name|i
operator|++
control|)
block|{
name|p_group
operator|=
name|p_sw
operator|->
name|up_port_groups
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|p_min_group
condition|)
block|{
comment|/* first group that we're checking - use 			   it as a group with the lowest load */
name|p_min_group
operator|=
name|p_group
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_group
operator|->
name|counter_down
operator|<
name|p_min_group
operator|->
name|counter_down
condition|)
block|{
comment|/* this group is less loaded - use it as min */
name|p_min_group
operator|=
name|p_group
expr_stmt|;
block|}
block|}
comment|/* Find the least loaded upgoing port in the selected group */
name|p_min_port
operator|=
name|NULL
expr_stmt|;
name|ports_num
operator|=
operator|(
name|uint16_t
operator|)
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_min_group
operator|->
name|ports
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ports_num
condition|;
name|j
operator|++
control|)
block|{
name|cl_ptr_vector_at
argument_list|(
operator|&
name|p_min_group
operator|->
name|ports
argument_list|,
name|j
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_min_port
condition|)
block|{
comment|/* first port that we're checking - use 			   it as a port with the lowest load */
name|p_min_port
operator|=
name|p_port
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_port
operator|->
name|counter_down
operator|<
name|p_min_port
operator|->
name|counter_down
condition|)
block|{
comment|/* this port is less loaded - use it as min */
name|p_min_port
operator|=
name|p_port
expr_stmt|;
block|}
block|}
comment|/* At this point we have selected a group and port with the 	   lowest load of downgoing routes. 	   Set on the remote switch how to get to the target_lid - 	   set LFT(target_lid) on the remote switch to the remote port */
name|p_remote_sw
operator|=
name|p_min_group
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
expr_stmt|;
comment|/* Four possible cases: 	 * 	 *  1. is_real_lid == TRUE&& is_main_path == TRUE: 	 *      - going UP(TRUE,TRUE) on selected min_group and min_port 	 *         + promoting port counter 	 *         + setting path in remote switch fwd tbl 	 *         + setting hops in remote switch on all the ports of selected group 	 *      - going UP(TRUE,FALSE) on rest of the groups, each time on port 0 	 *         + NOT promoting port counter 	 *         + setting path in remote switch fwd tbl if it hasn't been set yet 	 *         + setting hops in remote switch on all the ports of each group 	 *           if it hasn't been set yet 	 * 	 *  2. is_real_lid == TRUE&& is_main_path == FALSE: 	 *      - going UP(TRUE,FALSE) on ALL the groups, each time on port 0, 	 *        but only if the remote (upper) switch hasn't been already 	 *        configured for this target LID 	 *         + NOT promoting port counter 	 *         + setting path in remote switch fwd tbl if it hasn't been set yet 	 *         + setting hops in remote switch on all the ports of each group 	 *           if it hasn't been set yet 	 * 	 *  3. is_real_lid == FALSE&& is_main_path == TRUE: 	 *      - going UP(FALSE,TRUE) ONLY on selected min_group and min_port 	 *         + promoting port counter 	 *         + NOT setting path in remote switch fwd tbl 	 *         + NOT setting hops in remote switch 	 * 	 *  4. is_real_lid == FALSE&& is_main_path == FALSE: 	 *      - illegal state - we shouldn't get here 	 */
comment|/* covering first half of case 1, and case 3 */
if|if
condition|(
name|is_main_path
condition|)
block|{
if|if
condition|(
name|p_sw
operator|->
name|is_leaf
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|" - Routing MAIN path for %s CA LID %u: %s --> %s\n"
argument_list|,
operator|(
name|is_real_lid
operator|)
condition|?
literal|"real"
else|:
literal|"DUMMY"
argument_list|,
name|cl_ntoh16
argument_list|(
name|target_lid
argument_list|)
argument_list|,
name|__osm_ftree_tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|__osm_ftree_tuple_to_str
argument_list|(
name|p_remote_sw
operator|->
name|tuple
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The number of downgoing routes is tracked in the 		   p_group->counter_down p_port->counter_down counters of the 		   group and port that belong to the lower side of the link 		   (on switch with higher rank) */
name|p_min_group
operator|->
name|counter_down
operator|++
expr_stmt|;
name|p_min_port
operator|->
name|counter_down
operator|++
expr_stmt|;
if|if
condition|(
name|is_real_lid
condition|)
block|{
name|p_remote_sw
operator|->
name|p_osm_sw
operator|->
name|new_lft
index|[
name|cl_ntoh16
argument_list|(
name|target_lid
argument_list|)
index|]
operator|=
name|p_min_port
operator|->
name|remote_port_num
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Switch %s: set path to CA LID %u through port %u\n"
argument_list|,
name|__osm_ftree_tuple_to_str
argument_list|(
name|p_remote_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|target_lid
argument_list|)
argument_list|,
name|p_min_port
operator|->
name|remote_port_num
argument_list|)
expr_stmt|;
comment|/* On the remote switch that is pointed by the min_group, 			   set hops for ALL the ports in the remote group. */
name|ports_num
operator|=
operator|(
name|uint16_t
operator|)
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_min_group
operator|->
name|ports
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ports_num
condition|;
name|j
operator|++
control|)
block|{
name|cl_ptr_vector_at
argument_list|(
operator|&
name|p_min_group
operator|->
name|ports
argument_list|,
name|j
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_port
argument_list|)
expr_stmt|;
name|__osm_ftree_sw_set_hops
argument_list|(
name|p_remote_sw
argument_list|,
name|cl_ntoh16
argument_list|(
name|target_lid
argument_list|)
argument_list|,
name|p_port
operator|->
name|remote_port_num
argument_list|,
name|target_rank
operator|-
name|p_remote_sw
operator|->
name|rank
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Recursion step: 		   Assign downgoing ports by stepping up, starting on REMOTE switch. */
name|__osm_ftree_fabric_route_downgoing_by_going_up
argument_list|(
name|p_ftree
argument_list|,
name|p_remote_sw
argument_list|,
comment|/* remote switch - used as a route-downgoing alg. next step point */
name|p_sw
argument_list|,
comment|/* this switch - prev. position switch for the function */
name|target_lid
argument_list|,
comment|/* LID that we're routing to */
name|target_rank
argument_list|,
comment|/* rank of the LID that we're routing to */
name|is_real_lid
argument_list|,
comment|/* whether this target LID is real or dummy */
name|is_main_path
argument_list|)
expr_stmt|;
comment|/* whether this is path to HCA that should by tracked by counters */
block|}
comment|/* we're done for the third case */
if|if
condition|(
operator|!
name|is_real_lid
condition|)
return|return;
comment|/* What's left to do at this point: 	 * 	 *  1. is_real_lid == TRUE&& is_main_path == TRUE: 	 *      - going UP(TRUE,FALSE) on rest of the groups, each time on port 0, 	 *        but only if the remote (upper) switch hasn't been already 	 *        configured for this target LID 	 *         + NOT promoting port counter 	 *         + setting path in remote switch fwd tbl if it hasn't been set yet 	 *         + setting hops in remote switch on all the ports of each group 	 *           if it hasn't been set yet 	 * 	 *  2. is_real_lid == TRUE&& is_main_path == FALSE: 	 *      - going UP(TRUE,FALSE) on ALL the groups, each time on port 0, 	 *        but only if the remote (upper) switch hasn't been already 	 *        configured for this target LID 	 *         + NOT promoting port counter 	 *         + setting path in remote switch fwd tbl if it hasn't been set yet 	 *         + setting hops in remote switch on all the ports of each group 	 *           if it hasn't been set yet 	 * 	 *  These two rules can be rephrased this way: 	 *   - foreach UP port group 	 *      + if remote switch has been set with the target LID 	 *         - skip this port group 	 *      + else 	 *         - select port 0 	 *         - do NOT promote port counter 	 *         - set path in remote switch fwd tbl 	 *         - set hops in remote switch on all the ports of this group 	 *         - go UP(TRUE,FALSE) to the remote switch 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_sw
operator|->
name|up_port_groups_num
condition|;
name|i
operator|++
control|)
block|{
name|p_group
operator|=
name|p_sw
operator|->
name|up_port_groups
index|[
name|i
index|]
expr_stmt|;
name|p_remote_sw
operator|=
name|p_group
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
expr_stmt|;
comment|/* skip if target lid has been already set on remote switch fwd tbl */
if|if
condition|(
name|p_remote_sw
operator|->
name|p_osm_sw
operator|->
name|new_lft
index|[
name|cl_ntoh16
argument_list|(
name|target_lid
argument_list|)
index|]
operator|!=
name|OSM_NO_PATH
condition|)
continue|continue;
if|if
condition|(
name|p_sw
operator|->
name|is_leaf
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|" - Routing SECONDARY path for LID %u: %s --> %s\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|target_lid
argument_list|)
argument_list|,
name|__osm_ftree_tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|__osm_ftree_tuple_to_str
argument_list|(
name|p_remote_sw
operator|->
name|tuple
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Routing REAL lids on SECONDARY path means routing 		   switch-to-switch or switch-to-CA paths. 		   We can safely assume that switch will initiate very 		   few traffic, so there's no point waisting runtime on 		   trying to balance these routes - always pick port 0. */
name|cl_ptr_vector_at
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_port
argument_list|)
expr_stmt|;
name|p_remote_sw
operator|->
name|p_osm_sw
operator|->
name|new_lft
index|[
name|cl_ntoh16
argument_list|(
name|target_lid
argument_list|)
index|]
operator|=
name|p_port
operator|->
name|remote_port_num
expr_stmt|;
comment|/* On the remote switch that is pointed by the p_group, 		   set hops for ALL the ports in the remote group. */
name|ports_num
operator|=
operator|(
name|uint16_t
operator|)
name|cl_ptr_vector_get_size
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ports_num
condition|;
name|j
operator|++
control|)
block|{
name|cl_ptr_vector_at
argument_list|(
operator|&
name|p_group
operator|->
name|ports
argument_list|,
name|j
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_port
argument_list|)
expr_stmt|;
name|__osm_ftree_sw_set_hops
argument_list|(
name|p_remote_sw
argument_list|,
name|cl_ntoh16
argument_list|(
name|target_lid
argument_list|)
argument_list|,
name|p_port
operator|->
name|remote_port_num
argument_list|,
name|target_rank
operator|-
name|p_remote_sw
operator|->
name|rank
argument_list|)
expr_stmt|;
block|}
comment|/* Recursion step: 		   Assign downgoing ports by stepping up, starting on REMOTE switch. */
name|__osm_ftree_fabric_route_downgoing_by_going_up
argument_list|(
name|p_ftree
argument_list|,
name|p_remote_sw
argument_list|,
comment|/* remote switch - used as a route-downgoing alg. next step point */
name|p_sw
argument_list|,
comment|/* this switch - prev. position switch for the function */
name|target_lid
argument_list|,
comment|/* LID that we're routing to */
name|target_rank
argument_list|,
comment|/* rank of the LID that we're routing to */
name|TRUE
argument_list|,
comment|/* whether the target LID is real or dummy */
name|FALSE
argument_list|)
expr_stmt|;
comment|/* whether this is path to HCA that should by tracked by counters */
block|}
block|}
end_function

begin_comment
comment|/* ftree_fabric_route_downgoing_by_going_up() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_comment
comment|/*  * Pseudo code:  *    foreach leaf switch (in indexing order)  *       for each compute node (in indexing order)  *          obtain the LID of the compute node  *          set local LFT(LID) of the port connecting to compute node  *          call assign-down-going-port-by-ascending-up(TRUE,TRUE) on CURRENT switch  *       for each MISSING compute node  *          call assign-down-going-port-by-ascending-up(FALSE,TRUE) on CURRENT switch  */
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_fabric_route_to_cns
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_hca_t
modifier|*
name|p_hca
decl_stmt|;
name|ftree_port_group_t
modifier|*
name|p_leaf_port_group
decl_stmt|;
name|ftree_port_group_t
modifier|*
name|p_hca_port_group
decl_stmt|;
name|ftree_port_t
modifier|*
name|p_port
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|j
decl_stmt|;
name|ib_net16_t
name|hca_lid
decl_stmt|;
name|unsigned
name|routed_targets_on_leaf
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
comment|/* for each leaf switch (in indexing order) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_ftree
operator|->
name|leaf_switches_num
condition|;
name|i
operator|++
control|)
block|{
name|p_sw
operator|=
name|p_ftree
operator|->
name|leaf_switches
index|[
name|i
index|]
expr_stmt|;
name|routed_targets_on_leaf
operator|=
literal|0
expr_stmt|;
comment|/* for each HCA connected to this switch */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p_sw
operator|->
name|down_port_groups_num
condition|;
name|j
operator|++
control|)
block|{
name|p_leaf_port_group
operator|=
name|p_sw
operator|->
name|down_port_groups
index|[
name|j
index|]
expr_stmt|;
comment|/* work with this port group only if the remote node is CA */
if|if
condition|(
name|p_leaf_port_group
operator|->
name|remote_node_type
operator|!=
name|IB_NODE_TYPE_CA
condition|)
continue|continue;
name|p_hca
operator|=
name|p_leaf_port_group
operator|->
name|remote_hca_or_sw
operator|.
name|p_hca
expr_stmt|;
comment|/* work with this port group only if remote HCA has CNs */
if|if
condition|(
operator|!
name|p_hca
operator|->
name|cn_num
condition|)
continue|continue;
name|p_hca_port_group
operator|=
name|__osm_ftree_hca_get_port_group_by_remote_lid
argument_list|(
name|p_hca
argument_list|,
name|p_leaf_port_group
operator|->
name|base_lid
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_hca_port_group
argument_list|)
expr_stmt|;
comment|/* work with this port group only if remote port is CN */
if|if
condition|(
operator|!
name|p_hca_port_group
operator|->
name|is_cn
condition|)
continue|continue;
comment|/* obtain the LID of HCA port */
name|hca_lid
operator|=
name|p_leaf_port_group
operator|->
name|remote_base_lid
expr_stmt|;
comment|/* set local LFT(LID) to the port that is connected to HCA */
name|cl_ptr_vector_at
argument_list|(
operator|&
name|p_leaf_port_group
operator|->
name|ports
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_port
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|p_osm_sw
operator|->
name|new_lft
index|[
name|cl_ntoh16
argument_list|(
name|hca_lid
argument_list|)
index|]
operator|=
name|p_port
operator|->
name|port_num
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Switch %s: set path to CN LID %u through port %u\n"
argument_list|,
name|__osm_ftree_tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|hca_lid
argument_list|)
argument_list|,
name|p_port
operator|->
name|port_num
argument_list|)
expr_stmt|;
comment|/* set local min hop table(LID) to route to the CA */
name|__osm_ftree_sw_set_hops
argument_list|(
name|p_sw
argument_list|,
name|cl_ntoh16
argument_list|(
name|hca_lid
argument_list|)
argument_list|,
name|p_port
operator|->
name|port_num
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Assign downgoing ports by stepping up. 			   Since we're routing here only CNs, we're routing it as REAL 			   LID and updating fat-tree balancing counters. */
name|__osm_ftree_fabric_route_downgoing_by_going_up
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
argument_list|,
comment|/* local switch - used as a route-downgoing alg. start point */
name|NULL
argument_list|,
comment|/* prev. position switch */
name|hca_lid
argument_list|,
comment|/* LID that we're routing to */
name|p_sw
operator|->
name|rank
operator|+
literal|1
argument_list|,
comment|/* rank of the LID that we're routing to */
name|TRUE
argument_list|,
comment|/* whether this HCA LID is real or dummy */
name|TRUE
argument_list|)
expr_stmt|;
comment|/* whether this path to HCA should by tracked by counters */
comment|/* count how many real targets have been routed from this leaf switch */
name|routed_targets_on_leaf
operator|++
expr_stmt|;
block|}
comment|/* We're done with the real targets (all CNs) of this leaf switch. 		   Now route the dummy HCAs that are missing or that are non-CNs. 		   When routing to dummy HCAs we don't fill lid matrices. */
if|if
condition|(
name|p_ftree
operator|->
name|max_cn_per_leaf
operator|>
name|routed_targets_on_leaf
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Routing %u dummy CAs\n"
argument_list|,
name|p_ftree
operator|->
name|max_cn_per_leaf
operator|-
name|p_sw
operator|->
name|down_port_groups_num
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
operator|(
name|int
operator|)
name|j
operator|)
operator|<
operator|(
name|p_ftree
operator|->
name|max_cn_per_leaf
operator|-
name|routed_targets_on_leaf
operator|)
condition|;
name|j
operator|++
control|)
block|{
comment|/* assign downgoing ports by stepping up */
name|__osm_ftree_fabric_route_downgoing_by_going_up
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
argument_list|,
comment|/* local switch - used as a route-downgoing alg. start point */
name|NULL
argument_list|,
comment|/* prev. position switch */
literal|0
argument_list|,
comment|/* LID that we're routing to - ignored for dummy HCA */
literal|0
argument_list|,
comment|/* rank of the LID that we're routing to - ignored for dummy HCA */
name|FALSE
argument_list|,
comment|/* whether this HCA LID is real or dummy */
name|TRUE
argument_list|)
expr_stmt|;
comment|/* whether this path to HCA should by tracked by counters */
block|}
block|}
block|}
comment|/* done going through all the leaf switches */
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_fabric_route_to_cns() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_comment
comment|/*  * Pseudo code:  *    foreach HCA non-CN port in fabric  *       obtain the LID of the HCA port  *       get switch that is connected to this HCA port  *       set switch LFT(LID) to the port connecting to compute node  *       call assign-down-going-port-by-ascending-up(TRUE,FALSE) on CURRENT switch  *  * Routing to these HCAs is routing a REAL hca lid on SECONDARY path.  * However, we do want to allow load-leveling of the traffic to the non-CNs,  * because such nodes may include IO nodes with heavy usage  *   - we should set fwd tables  *   - we should update port counters  * Routing to non-CNs is done after routing to CNs, so updated port  * counters will not affect CN-to-CN routing.  */
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_fabric_route_to_non_cns
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_hca_t
modifier|*
name|p_hca
decl_stmt|;
name|ftree_hca_t
modifier|*
name|p_next_hca
decl_stmt|;
name|ftree_port_t
modifier|*
name|p_hca_port
decl_stmt|;
name|ftree_port_group_t
modifier|*
name|p_hca_port_group
decl_stmt|;
name|ib_net16_t
name|hca_lid
decl_stmt|;
name|unsigned
name|port_num_on_switch
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|p_next_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_hca
operator|!=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
condition|)
block|{
name|p_hca
operator|=
name|p_next_hca
expr_stmt|;
name|p_next_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_hca
operator|->
name|map_item
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_hca
operator|->
name|up_port_groups_num
condition|;
name|i
operator|++
control|)
block|{
name|p_hca_port_group
operator|=
name|p_hca
operator|->
name|up_port_groups
index|[
name|i
index|]
expr_stmt|;
comment|/* skip this port if it's CN, in which case it has been already routed */
if|if
condition|(
name|p_hca_port_group
operator|->
name|is_cn
condition|)
continue|continue;
comment|/* skip this port if it is not connected to switch */
if|if
condition|(
name|p_hca_port_group
operator|->
name|remote_node_type
operator|!=
name|IB_NODE_TYPE_SWITCH
condition|)
continue|continue;
name|p_sw
operator|=
name|p_hca_port_group
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
expr_stmt|;
name|hca_lid
operator|=
name|p_hca_port_group
operator|->
name|base_lid
expr_stmt|;
comment|/* set switches  LFT(LID) to the port that is connected to HCA */
name|cl_ptr_vector_at
argument_list|(
operator|&
name|p_hca_port_group
operator|->
name|ports
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|p_hca_port
argument_list|)
expr_stmt|;
name|port_num_on_switch
operator|=
name|p_hca_port
operator|->
name|remote_port_num
expr_stmt|;
name|p_sw
operator|->
name|p_osm_sw
operator|->
name|new_lft
index|[
name|cl_ntoh16
argument_list|(
name|hca_lid
argument_list|)
index|]
operator|=
name|port_num_on_switch
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Switch %s: set path to non-CN HCA LID %u through port %u\n"
argument_list|,
name|__osm_ftree_tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|hca_lid
argument_list|)
argument_list|,
name|port_num_on_switch
argument_list|)
expr_stmt|;
comment|/* set local min hop table(LID) to route to the CA */
name|__osm_ftree_sw_set_hops
argument_list|(
name|p_sw
argument_list|,
name|cl_ntoh16
argument_list|(
name|hca_lid
argument_list|)
argument_list|,
name|port_num_on_switch
argument_list|,
comment|/* port num */
literal|1
argument_list|)
expr_stmt|;
comment|/* hops */
comment|/* Assign downgoing ports by stepping up. 			   We're routing REAL targets. They are not CNs and not included 			   in the leafs array, but we treat them as MAIN path to allow load 			   leveling, which means that the counters will be updated. */
name|__osm_ftree_fabric_route_downgoing_by_going_up
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
argument_list|,
comment|/* local switch - used as a route-downgoing alg. start point */
name|NULL
argument_list|,
comment|/* prev. position switch */
name|hca_lid
argument_list|,
comment|/* LID that we're routing to */
name|p_sw
operator|->
name|rank
operator|+
literal|1
argument_list|,
comment|/* rank of the LID that we're routing to */
name|TRUE
argument_list|,
comment|/* whether this HCA LID is real or dummy */
name|TRUE
argument_list|)
expr_stmt|;
comment|/* whether this path to HCA should by tracked by counters */
block|}
comment|/* done with all the port groups of this HCA - go to next HCA */
block|}
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_fabric_route_to_non_cns() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_comment
comment|/*  * Pseudo code:  *    foreach switch in fabric  *       obtain its LID  *       set local LFT(LID) to port 0  *       call assign-down-going-port-by-ascending-up(TRUE,FALSE) on CURRENT switch  *  * Routing to switch is similar to routing a REAL hca lid on SECONDARY path:  *   - we should set fwd tables  *   - we should NOT update port counters  */
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_fabric_route_to_switches
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_next_sw
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_sw
operator|!=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
condition|)
block|{
name|p_sw
operator|=
name|p_next_sw
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
comment|/* set local LFT(LID) to 0 (route to itself) */
name|p_sw
operator|->
name|p_osm_sw
operator|->
name|new_lft
index|[
name|cl_ntoh16
argument_list|(
name|p_sw
operator|->
name|base_lid
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Switch %s (LID %u): routing switch-to-switch paths\n"
argument_list|,
name|__osm_ftree_tuple_to_str
argument_list|(
name|p_sw
operator|->
name|tuple
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_sw
operator|->
name|base_lid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set min hop table of the switch to itself */
name|__osm_ftree_sw_set_hops
argument_list|(
name|p_sw
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_sw
operator|->
name|base_lid
argument_list|)
argument_list|,
literal|0
argument_list|,
comment|/* port_num */
literal|0
argument_list|)
expr_stmt|;
comment|/* hops     */
name|__osm_ftree_fabric_route_downgoing_by_going_up
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
argument_list|,
comment|/* local switch - used as a route-downgoing alg. start point */
name|NULL
argument_list|,
comment|/* prev. position switch */
name|p_sw
operator|->
name|base_lid
argument_list|,
comment|/* LID that we're routing to */
name|p_sw
operator|->
name|rank
argument_list|,
comment|/* rank of the LID that we're routing to */
name|TRUE
argument_list|,
comment|/* whether the target LID is a real or dummy */
name|FALSE
argument_list|)
expr_stmt|;
comment|/* whether this path should by tracked by counters */
block|}
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_fabric_route_to_switches() */
end_comment

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|int
name|__osm_ftree_fabric_populate_nodes
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|osm_node_t
modifier|*
name|p_osm_node
decl_stmt|;
name|osm_node_t
modifier|*
name|p_next_osm_node
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|p_next_osm_node
operator|=
operator|(
name|osm_node_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|node_guid_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_osm_node
operator|!=
operator|(
name|osm_node_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|node_guid_tbl
argument_list|)
condition|)
block|{
name|p_osm_node
operator|=
name|p_next_osm_node
expr_stmt|;
name|p_next_osm_node
operator|=
operator|(
name|osm_node_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_osm_node
operator|->
name|map_item
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|osm_node_get_type
argument_list|(
name|p_osm_node
argument_list|)
condition|)
block|{
case|case
name|IB_NODE_TYPE_CA
case|:
name|__osm_ftree_fabric_add_hca
argument_list|(
name|p_ftree
argument_list|,
name|p_osm_node
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_NODE_TYPE_ROUTER
case|:
break|break;
case|case
name|IB_NODE_TYPE_SWITCH
case|:
name|__osm_ftree_fabric_add_sw
argument_list|(
name|p_ftree
argument_list|,
name|p_osm_node
operator|->
name|sw
argument_list|)
expr_stmt|;
break|break;
default|default:
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB0E: "
literal|"Node GUID 0x%016"
name|PRIx64
literal|" - Unknown node type: %s\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_osm_node
argument_list|)
argument_list|)
argument_list|,
name|ib_get_node_type_str
argument_list|(
name|osm_node_get_type
argument_list|(
name|p_osm_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_fabric_populate_nodes() */
end_comment

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|boolean_t
name|__osm_ftree_sw_update_rank
parameter_list|(
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|,
name|IN
name|uint32_t
name|new_rank
parameter_list|)
block|{
if|if
condition|(
name|__osm_ftree_sw_ranked
argument_list|(
name|p_sw
argument_list|)
operator|&&
name|p_sw
operator|->
name|rank
operator|<=
name|new_rank
condition|)
return|return
name|FALSE
return|;
name|p_sw
operator|->
name|rank
operator|=
name|new_rank
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_rank_switches_from_leafs
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|cl_list_t
modifier|*
name|p_ranking_bfs_list
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_remote_sw
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
name|osm_node_t
modifier|*
name|p_remote_node
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_osm_port
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|unsigned
name|max_rank
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|cl_is_list_empty
argument_list|(
name|p_ranking_bfs_list
argument_list|)
condition|)
block|{
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_list_remove_head
argument_list|(
name|p_ranking_bfs_list
argument_list|)
expr_stmt|;
name|p_node
operator|=
name|p_sw
operator|->
name|p_osm_sw
operator|->
name|p_node
expr_stmt|;
comment|/* note: skipping port 0 on switches */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|osm_node_get_num_physp
argument_list|(
name|p_node
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|p_osm_port
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_osm_port
operator|||
operator|!
name|osm_link_is_healthy
argument_list|(
name|p_osm_port
argument_list|)
condition|)
continue|continue;
name|p_remote_node
operator|=
name|osm_node_get_remote_node
argument_list|(
name|p_node
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_remote_node
condition|)
continue|continue;
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|p_remote_node
argument_list|)
operator|!=
name|IB_NODE_TYPE_SWITCH
condition|)
continue|continue;
name|p_remote_sw
operator|=
name|__osm_ftree_fabric_get_sw_by_guid
argument_list|(
name|p_ftree
argument_list|,
name|osm_node_get_node_guid
argument_list|(
name|p_remote_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_remote_sw
condition|)
block|{
comment|/* remote node is not a switch */
continue|continue;
block|}
comment|/* if needed, rank the remote switch and add it to the BFS list */
if|if
condition|(
name|__osm_ftree_sw_update_rank
argument_list|(
name|p_remote_sw
argument_list|,
name|p_sw
operator|->
name|rank
operator|+
literal|1
argument_list|)
condition|)
block|{
name|max_rank
operator|=
name|p_remote_sw
operator|->
name|rank
expr_stmt|;
name|cl_list_insert_tail
argument_list|(
name|p_ranking_bfs_list
argument_list|,
name|p_remote_sw
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* set FatTree maximal switch rank */
name|p_ftree
operator|->
name|max_switch_rank
operator|=
name|max_rank
expr_stmt|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_rank_switches_from_leafs() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|int
name|__osm_ftree_rank_leaf_switches
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_hca_t
modifier|*
name|p_hca
parameter_list|,
name|IN
name|cl_list_t
modifier|*
name|p_ranking_bfs_list
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|osm_node_t
modifier|*
name|p_osm_node
init|=
name|p_hca
operator|->
name|p_osm_node
decl_stmt|;
name|osm_node_t
modifier|*
name|p_remote_osm_node
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_osm_port
decl_stmt|;
specifier|static
name|uint8_t
name|i
init|=
literal|0
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|osm_node_get_num_physp
argument_list|(
name|p_osm_node
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|p_osm_port
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_osm_node
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_osm_port
operator|||
operator|!
name|osm_link_is_healthy
argument_list|(
name|p_osm_port
argument_list|)
condition|)
continue|continue;
name|p_remote_osm_node
operator|=
name|osm_node_get_remote_node
argument_list|(
name|p_osm_node
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_remote_osm_node
condition|)
continue|continue;
switch|switch
condition|(
name|osm_node_get_type
argument_list|(
name|p_remote_osm_node
argument_list|)
condition|)
block|{
case|case
name|IB_NODE_TYPE_CA
case|:
comment|/* HCA connected directly to another HCA - not FatTree */
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB0F: "
literal|"CA conected directly to another CA: "
literal|"0x%016"
name|PRIx64
literal|"<---> 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|__osm_ftree_hca_get_guid_ho
argument_list|(
name|p_hca
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_remote_osm_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
case|case
name|IB_NODE_TYPE_ROUTER
case|:
comment|/* leaving this port - proceeding to the next one */
continue|continue;
case|case
name|IB_NODE_TYPE_SWITCH
case|:
comment|/* continue with this port */
break|break;
default|default:
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB10: Node GUID 0x%016"
name|PRIx64
literal|" - Unknown node type: %s\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_remote_osm_node
argument_list|)
argument_list|)
argument_list|,
name|ib_get_node_type_str
argument_list|(
name|osm_node_get_type
argument_list|(
name|p_remote_osm_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* remote node is switch */
name|p_sw
operator|=
name|__osm_ftree_fabric_get_sw_by_guid
argument_list|(
name|p_ftree
argument_list|,
name|osm_node_get_node_guid
argument_list|(
name|p_osm_port
operator|->
name|p_remote_physp
operator|->
name|p_node
argument_list|)
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_sw
argument_list|)
expr_stmt|;
comment|/* if needed, rank the remote switch and add it to the BFS list */
if|if
condition|(
operator|!
name|__osm_ftree_sw_update_rank
argument_list|(
name|p_sw
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Marking rank of switch that is directly connected to CA:\n"
literal|"                                            - CA guid    : 0x%016"
name|PRIx64
literal|"\n"
literal|"                                            - Switch guid: 0x%016"
name|PRIx64
literal|"\n"
literal|"                                            - Switch LID : %u\n"
argument_list|,
name|__osm_ftree_hca_get_guid_ho
argument_list|(
name|p_hca
argument_list|)
argument_list|,
name|__osm_ftree_sw_get_guid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_sw
operator|->
name|base_lid
argument_list|)
argument_list|)
expr_stmt|;
name|cl_list_insert_tail
argument_list|(
name|p_ranking_bfs_list
argument_list|,
name|p_sw
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_rank_leaf_switches() */
end_comment

begin_comment
comment|/***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_sw_reverse_rank
parameter_list|(
name|IN
name|cl_map_item_t
modifier|*
specifier|const
name|p_map_item
parameter_list|,
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
name|ftree_fabric_t
modifier|*
name|p_ftree
init|=
operator|(
name|ftree_fabric_t
operator|*
operator|)
name|context
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_sw
init|=
operator|(
name|ftree_sw_t
operator|*
specifier|const
operator|)
name|p_map_item
decl_stmt|;
name|p_sw
operator|->
name|rank
operator|=
name|p_ftree
operator|->
name|max_switch_rank
operator|-
name|p_sw
operator|->
name|rank
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|int
name|__osm_ftree_fabric_construct_hca_ports
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_hca_t
modifier|*
name|p_hca
parameter_list|)
block|{
name|ftree_sw_t
modifier|*
name|p_remote_sw
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
init|=
name|p_hca
operator|->
name|p_osm_node
decl_stmt|;
name|osm_node_t
modifier|*
name|p_remote_node
decl_stmt|;
name|uint8_t
name|remote_node_type
decl_stmt|;
name|ib_net64_t
name|remote_node_guid
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_remote_osm_port
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|uint8_t
name|remote_port_num
decl_stmt|;
name|boolean_t
name|is_cn
init|=
name|FALSE
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|osm_node_get_num_physp
argument_list|(
name|p_node
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|osm_physp_t
modifier|*
name|p_osm_port
init|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p_osm_port
operator|||
operator|!
name|osm_link_is_healthy
argument_list|(
name|p_osm_port
argument_list|)
condition|)
continue|continue;
name|p_remote_osm_port
operator|=
name|osm_physp_get_remote
argument_list|(
name|p_osm_port
argument_list|)
expr_stmt|;
name|p_remote_node
operator|=
name|osm_node_get_remote_node
argument_list|(
name|p_node
argument_list|,
name|i
argument_list|,
operator|&
name|remote_port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_remote_osm_port
condition|)
continue|continue;
name|remote_node_type
operator|=
name|osm_node_get_type
argument_list|(
name|p_remote_node
argument_list|)
expr_stmt|;
name|remote_node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_remote_node
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|remote_node_type
condition|)
block|{
case|case
name|IB_NODE_TYPE_ROUTER
case|:
comment|/* leaving this port - proceeding to the next one */
continue|continue;
case|case
name|IB_NODE_TYPE_CA
case|:
comment|/* HCA connected directly to another HCA - not FatTree */
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB11: "
literal|"CA conected directly to another CA: "
literal|"0x%016"
name|PRIx64
literal|"<---> 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|remote_node_guid
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
case|case
name|IB_NODE_TYPE_SWITCH
case|:
comment|/* continue with this port */
break|break;
default|default:
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB12: Node GUID 0x%016"
name|PRIx64
literal|" - Unknown node type: %s\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|remote_node_guid
argument_list|)
argument_list|,
name|ib_get_node_type_str
argument_list|(
name|remote_node_type
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* remote node is switch */
name|p_remote_sw
operator|=
name|__osm_ftree_fabric_get_sw_by_guid
argument_list|(
name|p_ftree
argument_list|,
name|remote_node_guid
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_remote_sw
argument_list|)
expr_stmt|;
comment|/* If CN file is not supplied, then all the CAs considered as Compute Nodes. 		   Otherwise all the CAs are not CNs, and only guids that are present in the 		   CN file will be marked as compute nodes. */
if|if
condition|(
operator|!
name|__osm_ftree_fabric_cns_provided
argument_list|(
name|p_ftree
argument_list|)
condition|)
block|{
name|is_cn
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|name_map_item_t
modifier|*
name|p_elem
init|=
operator|(
name|name_map_item_t
operator|*
operator|)
name|cl_qmap_get
argument_list|(
operator|&
name|p_ftree
operator|->
name|cn_guid_tbl
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_osm_port
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|p_elem
operator|!=
operator|(
name|name_map_item_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|cn_guid_tbl
argument_list|)
condition|)
name|is_cn
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|is_cn
condition|)
block|{
name|p_ftree
operator|->
name|cn_num
operator|++
expr_stmt|;
name|p_hca
operator|->
name|cn_num
operator|++
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Marking CN port GUID 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_osm_port
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Marking non-CN port GUID 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_osm_port
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|__osm_ftree_hca_add_port
argument_list|(
name|p_hca
argument_list|,
comment|/* local ftree_hca object */
name|i
argument_list|,
comment|/* local port number */
name|remote_port_num
argument_list|,
comment|/* remote port number */
name|osm_node_get_base_lid
argument_list|(
name|p_node
argument_list|,
name|i
argument_list|)
argument_list|,
comment|/* local lid */
name|osm_node_get_base_lid
argument_list|(
name|p_remote_node
argument_list|,
literal|0
argument_list|)
argument_list|,
comment|/* remote lid */
name|osm_physp_get_port_guid
argument_list|(
name|p_osm_port
argument_list|)
argument_list|,
comment|/* local port guid */
name|osm_physp_get_port_guid
argument_list|(
name|p_remote_osm_port
argument_list|)
argument_list|,
comment|/* remote port guid */
name|remote_node_guid
argument_list|,
comment|/* remote node guid */
name|remote_node_type
argument_list|,
comment|/* remote node type */
operator|(
name|void
operator|*
operator|)
name|p_remote_sw
argument_list|,
comment|/* remote ftree_hca/sw object */
name|is_cn
argument_list|)
expr_stmt|;
comment|/* whether this port is compute node */
block|}
name|Exit
label|:
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_fabric_construct_hca_ports() */
end_comment

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|boolean_t
name|__osm_invalid_link_rank_diff
parameter_list|(
specifier|const
name|uint32_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|val
operator|!=
literal|1U
operator|&&
name|val
operator|!=
operator|-
literal|1U
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__osm_ftree_fabric_construct_sw_ports
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|,
name|IN
name|ftree_sw_t
modifier|*
name|p_sw
parameter_list|)
block|{
name|ftree_hca_t
modifier|*
name|p_remote_hca
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_remote_sw
decl_stmt|;
name|osm_node_t
modifier|*
name|p_node
init|=
name|p_sw
operator|->
name|p_osm_sw
operator|->
name|p_node
decl_stmt|;
name|osm_node_t
modifier|*
name|p_remote_node
decl_stmt|;
name|ib_net16_t
name|remote_base_lid
decl_stmt|;
name|uint8_t
name|remote_node_type
decl_stmt|;
name|ib_net64_t
name|remote_node_guid
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_remote_osm_port
decl_stmt|;
name|ftree_direction_t
name|direction
decl_stmt|;
name|void
modifier|*
name|p_remote_hca_or_sw
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|uint8_t
name|remote_port_num
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
name|CL_ASSERT
argument_list|(
name|osm_node_get_type
argument_list|(
name|p_node
argument_list|)
operator|==
name|IB_NODE_TYPE_SWITCH
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|osm_node_get_num_physp
argument_list|(
name|p_node
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|osm_physp_t
modifier|*
name|p_osm_port
init|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_node
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p_osm_port
operator|||
operator|!
name|osm_link_is_healthy
argument_list|(
name|p_osm_port
argument_list|)
condition|)
continue|continue;
name|p_remote_osm_port
operator|=
name|osm_physp_get_remote
argument_list|(
name|p_osm_port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_remote_osm_port
condition|)
continue|continue;
name|p_remote_node
operator|=
name|osm_node_get_remote_node
argument_list|(
name|p_node
argument_list|,
name|i
argument_list|,
operator|&
name|remote_port_num
argument_list|)
expr_stmt|;
comment|/* ignore any loopback connection on switch */
if|if
condition|(
name|p_node
operator|==
name|p_remote_node
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Ignoring loopback on switch GUID 0x%016"
name|PRIx64
literal|", LID %u, rank %u\n"
argument_list|,
name|__osm_ftree_sw_get_guid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_sw
operator|->
name|base_lid
argument_list|)
argument_list|,
name|p_sw
operator|->
name|rank
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|remote_node_type
operator|=
name|osm_node_get_type
argument_list|(
name|p_remote_node
argument_list|)
expr_stmt|;
name|remote_node_guid
operator|=
name|osm_node_get_node_guid
argument_list|(
name|p_remote_node
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|remote_node_type
condition|)
block|{
case|case
name|IB_NODE_TYPE_ROUTER
case|:
comment|/* leaving this port - proceeding to the next one */
continue|continue;
case|case
name|IB_NODE_TYPE_CA
case|:
comment|/* switch connected to hca */
name|p_remote_hca
operator|=
name|__osm_ftree_fabric_get_hca_by_guid
argument_list|(
name|p_ftree
argument_list|,
name|remote_node_guid
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_remote_hca
argument_list|)
expr_stmt|;
name|p_remote_hca_or_sw
operator|=
operator|(
name|void
operator|*
operator|)
name|p_remote_hca
expr_stmt|;
name|direction
operator|=
name|FTREE_DIRECTION_DOWN
expr_stmt|;
name|remote_base_lid
operator|=
name|osm_physp_get_base_lid
argument_list|(
name|p_remote_osm_port
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_NODE_TYPE_SWITCH
case|:
comment|/* switch connected to another switch */
name|p_remote_sw
operator|=
name|__osm_ftree_fabric_get_sw_by_guid
argument_list|(
name|p_ftree
argument_list|,
name|remote_node_guid
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_remote_sw
argument_list|)
expr_stmt|;
name|p_remote_hca_or_sw
operator|=
operator|(
name|void
operator|*
operator|)
name|p_remote_sw
expr_stmt|;
if|if
condition|(
name|__osm_invalid_link_rank_diff
argument_list|(
name|p_sw
operator|->
name|rank
operator|-
name|p_remote_sw
operator|->
name|rank
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB16: "
literal|"Illegal link between switches with ranks %u and %u:\n"
literal|"       GUID 0x%016"
name|PRIx64
literal|", LID %u, rank %u\n"
literal|"       GUID 0x%016"
name|PRIx64
literal|", LID %u, rank %u\n"
argument_list|,
name|p_sw
operator|->
name|rank
argument_list|,
name|p_remote_sw
operator|->
name|rank
argument_list|,
name|__osm_ftree_sw_get_guid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_sw
operator|->
name|base_lid
argument_list|)
argument_list|,
name|p_sw
operator|->
name|rank
argument_list|,
name|__osm_ftree_sw_get_guid_ho
argument_list|(
name|p_remote_sw
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_remote_sw
operator|->
name|base_lid
argument_list|)
argument_list|,
name|p_remote_sw
operator|->
name|rank
argument_list|)
expr_stmt|;
name|res
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|p_sw
operator|->
name|rank
operator|>
name|p_remote_sw
operator|->
name|rank
condition|)
name|direction
operator|=
name|FTREE_DIRECTION_UP
expr_stmt|;
else|else
name|direction
operator|=
name|FTREE_DIRECTION_DOWN
expr_stmt|;
comment|/* switch LID is only in port 0 port_info structure */
name|remote_base_lid
operator|=
name|osm_node_get_base_lid
argument_list|(
name|p_remote_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB13: Node GUID 0x%016"
name|PRIx64
literal|" - Unknown node type: %s\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|remote_node_guid
argument_list|)
argument_list|,
name|ib_get_node_type_str
argument_list|(
name|remote_node_type
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|__osm_ftree_sw_add_port
argument_list|(
name|p_sw
argument_list|,
comment|/* local ftree_sw object */
name|i
argument_list|,
comment|/* local port number */
name|remote_port_num
argument_list|,
comment|/* remote port number */
name|p_sw
operator|->
name|base_lid
argument_list|,
comment|/* local lid */
name|remote_base_lid
argument_list|,
comment|/* remote lid */
name|osm_physp_get_port_guid
argument_list|(
name|p_osm_port
argument_list|)
argument_list|,
comment|/* local port guid */
name|osm_physp_get_port_guid
argument_list|(
name|p_remote_osm_port
argument_list|)
argument_list|,
comment|/* remote port guid */
name|remote_node_guid
argument_list|,
comment|/* remote node guid */
name|remote_node_type
argument_list|,
comment|/* remote node type */
name|p_remote_hca_or_sw
argument_list|,
comment|/* remote ftree_hca/sw object */
name|direction
argument_list|)
expr_stmt|;
comment|/* port direction (up or down) */
comment|/* Track the max lid (in host order) that exists in the fabric */
if|if
condition|(
name|cl_ntoh16
argument_list|(
name|remote_base_lid
argument_list|)
operator|>
name|p_ftree
operator|->
name|lft_max_lid_ho
condition|)
name|p_ftree
operator|->
name|lft_max_lid_ho
operator|=
name|cl_ntoh16
argument_list|(
name|remote_base_lid
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_fabric_construct_sw_ports() */
end_comment

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|int
name|__osm_ftree_fabric_rank_from_roots
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|osm_node_t
modifier|*
name|p_osm_node
decl_stmt|;
name|osm_node_t
modifier|*
name|p_remote_osm_node
decl_stmt|;
name|osm_physp_t
modifier|*
name|p_osm_physp
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_remote_sw
decl_stmt|;
name|cl_list_t
name|ranking_bfs_list
decl_stmt|;
name|struct
name|guid_list_item
modifier|*
name|item
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
name|unsigned
name|num_roots
decl_stmt|;
name|unsigned
name|max_rank
init|=
literal|0
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|cl_list_init
argument_list|(
operator|&
name|ranking_bfs_list
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Rank all the roots and add them to list */
for|for
control|(
name|item
operator|=
operator|(
name|void
operator|*
operator|)
name|cl_qlist_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|root_guid_list
argument_list|)
init|;
name|item
operator|!=
operator|(
name|void
operator|*
operator|)
name|cl_qlist_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|root_guid_list
argument_list|)
condition|;
name|item
operator|=
operator|(
name|void
operator|*
operator|)
name|cl_qlist_next
argument_list|(
operator|&
name|item
operator|->
name|list
argument_list|)
control|)
block|{
name|p_sw
operator|=
name|__osm_ftree_fabric_get_sw_by_guid
argument_list|(
name|p_ftree
argument_list|,
name|cl_hton64
argument_list|(
name|item
operator|->
name|guid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_sw
condition|)
block|{
comment|/* the specified root guid wasn't found in the fabric */
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB24: "
literal|"Root switch GUID 0x%"
name|PRIx64
literal|" not found\n"
argument_list|,
name|item
operator|->
name|guid
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Ranking root switch with GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|item
operator|->
name|guid
argument_list|)
expr_stmt|;
name|p_sw
operator|->
name|rank
operator|=
literal|0
expr_stmt|;
name|cl_list_insert_tail
argument_list|(
operator|&
name|ranking_bfs_list
argument_list|,
name|p_sw
argument_list|)
expr_stmt|;
block|}
name|num_roots
operator|=
name|cl_list_count
argument_list|(
operator|&
name|ranking_bfs_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num_roots
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB25: "
literal|"No valid roots supplied\n"
argument_list|)
expr_stmt|;
name|res
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Ranked %u valid root switches\n"
argument_list|,
name|num_roots
argument_list|)
expr_stmt|;
comment|/* Now the list has all the roots. 	   BFS the subnet and update rank on all the switches. */
while|while
condition|(
operator|!
name|cl_is_list_empty
argument_list|(
operator|&
name|ranking_bfs_list
argument_list|)
condition|)
block|{
name|p_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_list_remove_head
argument_list|(
operator|&
name|ranking_bfs_list
argument_list|)
expr_stmt|;
name|p_osm_node
operator|=
name|p_sw
operator|->
name|p_osm_sw
operator|->
name|p_node
expr_stmt|;
comment|/* note: skipping port 0 on switches */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|osm_node_get_num_physp
argument_list|(
name|p_osm_node
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|p_osm_physp
operator|=
name|osm_node_get_physp_ptr
argument_list|(
name|p_osm_node
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_osm_physp
operator|||
operator|!
name|osm_link_is_healthy
argument_list|(
name|p_osm_physp
argument_list|)
condition|)
continue|continue;
name|p_remote_osm_node
operator|=
name|osm_node_get_remote_node
argument_list|(
name|p_osm_node
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_remote_osm_node
condition|)
continue|continue;
if|if
condition|(
name|osm_node_get_type
argument_list|(
name|p_remote_osm_node
argument_list|)
operator|!=
name|IB_NODE_TYPE_SWITCH
condition|)
continue|continue;
name|p_remote_sw
operator|=
name|__osm_ftree_fabric_get_sw_by_guid
argument_list|(
name|p_ftree
argument_list|,
name|osm_node_get_node_guid
argument_list|(
name|p_remote_osm_node
argument_list|)
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_remote_sw
argument_list|)
expr_stmt|;
comment|/* if needed, rank the remote switch and add it to the BFS list */
if|if
condition|(
name|__osm_ftree_sw_update_rank
argument_list|(
name|p_remote_sw
argument_list|,
name|p_sw
operator|->
name|rank
operator|+
literal|1
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Ranking switch 0x%"
name|PRIx64
literal|" with rank %u\n"
argument_list|,
name|__osm_ftree_sw_get_guid_ho
argument_list|(
name|p_remote_sw
argument_list|)
argument_list|,
name|p_remote_sw
operator|->
name|rank
argument_list|)
expr_stmt|;
name|max_rank
operator|=
name|p_remote_sw
operator|->
name|rank
expr_stmt|;
name|cl_list_insert_tail
argument_list|(
operator|&
name|ranking_bfs_list
argument_list|,
name|p_remote_sw
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* done with ports of this switch - go to the next switch in the list */
block|}
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Subnet ranking completed. Max Node Rank = %u\n"
argument_list|,
name|max_rank
argument_list|)
expr_stmt|;
comment|/* set FatTree maximal switch rank */
name|p_ftree
operator|->
name|max_switch_rank
operator|=
name|max_rank
expr_stmt|;
name|Exit
label|:
name|cl_list_destroy
argument_list|(
operator|&
name|ranking_bfs_list
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_fabric_rank_from_roots() */
end_comment

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|int
name|__osm_ftree_fabric_rank_from_hcas
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|ftree_hca_t
modifier|*
name|p_hca
decl_stmt|;
name|ftree_hca_t
modifier|*
name|p_next_hca
decl_stmt|;
name|cl_list_t
name|ranking_bfs_list
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|cl_list_init
argument_list|(
operator|&
name|ranking_bfs_list
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Mark REVERSED rank of all the switches in the subnet. 	   Start from switches that are connected to hca's, and 	   scan all the switches in the subnet. */
name|p_next_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_hca
operator|!=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
condition|)
block|{
name|p_hca
operator|=
name|p_next_hca
expr_stmt|;
name|p_next_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_hca
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|__osm_ftree_rank_leaf_switches
argument_list|(
name|p_ftree
argument_list|,
name|p_hca
argument_list|,
operator|&
name|ranking_bfs_list
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|res
operator|=
operator|-
literal|1
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB14: "
literal|"Subnet ranking failed - subnet is not FatTree"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/* Now rank rest of the switches in the fabric, while the 	   list already contains all the ranked leaf switches */
name|__osm_ftree_rank_switches_from_leafs
argument_list|(
name|p_ftree
argument_list|,
operator|&
name|ranking_bfs_list
argument_list|)
expr_stmt|;
comment|/* fix ranking of the switches by reversing the ranking direction */
name|cl_qmap_apply_func
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|,
name|__osm_ftree_sw_reverse_rank
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p_ftree
argument_list|)
expr_stmt|;
name|Exit
label|:
name|cl_list_destroy
argument_list|(
operator|&
name|ranking_bfs_list
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_fabric_rank_from_hcas() */
end_comment

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|int
name|__osm_ftree_fabric_rank
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|int
name|res
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|__osm_ftree_fabric_roots_provided
argument_list|(
name|p_ftree
argument_list|)
condition|)
name|res
operator|=
name|__osm_ftree_fabric_rank_from_roots
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|__osm_ftree_fabric_rank_from_hcas
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
goto|goto
name|Exit
goto|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"FatTree max switch rank is %u\n"
argument_list|,
name|p_ftree
operator|->
name|max_switch_rank
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_fabric_rank() */
end_comment

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_fabric_set_leaf_rank
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_hca_t
modifier|*
name|p_hca
init|=
name|NULL
decl_stmt|;
name|ftree_hca_t
modifier|*
name|p_next_hca
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|__osm_ftree_fabric_roots_provided
argument_list|(
name|p_ftree
argument_list|)
condition|)
block|{
comment|/* If root file is not provided, the fabric has to be pure fat-tree 		   in terms of ranking. Thus, leaf switches rank is the max rank. */
name|p_ftree
operator|->
name|leaf_switch_rank
operator|=
name|p_ftree
operator|->
name|max_switch_rank
expr_stmt|;
block|}
else|else
block|{
comment|/* Find the first CN and set the leaf_switch_rank to the rank 		   of the switch that is connected to this CN. Later we will 		   ensure that all the leaf switches have the same rank. */
name|p_next_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_hca
operator|!=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
condition|)
block|{
name|p_hca
operator|=
name|p_next_hca
expr_stmt|;
if|if
condition|(
name|p_hca
operator|->
name|cn_num
condition|)
break|break;
name|p_next_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_hca
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
comment|/* we know that there are CNs in the fabric, so just to be sure... */
name|CL_ASSERT
argument_list|(
name|p_next_hca
operator|!=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Selected CN port GUID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|__osm_ftree_hca_get_guid_ho
argument_list|(
name|p_hca
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|p_hca
operator|->
name|up_port_groups_num
operator|)
operator|&&
operator|(
operator|!
name|p_hca
operator|->
name|up_port_groups
index|[
name|i
index|]
operator|->
name|is_cn
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|CL_ASSERT
argument_list|(
name|i
operator|<
name|p_hca
operator|->
name|up_port_groups_num
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_hca
operator|->
name|up_port_groups
index|[
name|i
index|]
operator|->
name|remote_node_type
operator|==
name|IB_NODE_TYPE_SWITCH
argument_list|)
expr_stmt|;
name|p_sw
operator|=
name|p_hca
operator|->
name|up_port_groups
index|[
name|i
index|]
operator|->
name|remote_hca_or_sw
operator|.
name|p_sw
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Selected leaf switch GUID 0x%"
name|PRIx64
literal|", rank %u\n"
argument_list|,
name|__osm_ftree_sw_get_guid_ho
argument_list|(
name|p_sw
argument_list|)
argument_list|,
name|p_sw
operator|->
name|rank
argument_list|)
expr_stmt|;
name|p_ftree
operator|->
name|leaf_switch_rank
operator|=
name|p_sw
operator|->
name|rank
expr_stmt|;
block|}
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_INFO
argument_list|,
literal|"FatTree leaf switch rank is %u\n"
argument_list|,
name|p_ftree
operator|->
name|leaf_switch_rank
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_fabric_set_leaf_rank() */
end_comment

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|int
name|__osm_ftree_fabric_populate_ports
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|ftree_hca_t
modifier|*
name|p_hca
decl_stmt|;
name|ftree_hca_t
modifier|*
name|p_next_hca
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_sw
decl_stmt|;
name|ftree_sw_t
modifier|*
name|p_next_sw
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|p_next_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_hca
operator|!=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
condition|)
block|{
name|p_hca
operator|=
name|p_next_hca
expr_stmt|;
name|p_next_hca
operator|=
operator|(
name|ftree_hca_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_hca
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|__osm_ftree_fabric_construct_hca_ports
argument_list|(
name|p_ftree
argument_list|,
name|p_hca
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|res
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_next_sw
operator|!=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|)
condition|)
block|{
name|p_sw
operator|=
name|p_next_sw
expr_stmt|;
name|p_next_sw
operator|=
operator|(
name|ftree_sw_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_sw
operator|->
name|map_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|__osm_ftree_fabric_construct_sw_ports
argument_list|(
name|p_ftree
argument_list|,
name|p_sw
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|res
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_fabric_populate_ports() */
end_comment

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|int
name|add_guid_item_to_list
parameter_list|(
name|void
modifier|*
name|cxt
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
name|cl_qlist_t
modifier|*
name|list
init|=
name|cxt
decl_stmt|;
name|struct
name|guid_list_item
modifier|*
name|item
decl_stmt|;
name|item
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
return|return
operator|-
literal|1
return|;
name|item
operator|->
name|guid
operator|=
name|guid
expr_stmt|;
name|cl_qlist_insert_tail
argument_list|(
name|list
argument_list|,
operator|&
name|item
operator|->
name|list
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_guid_item_to_map
parameter_list|(
name|void
modifier|*
name|cxt
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|char
modifier|*
name|p
parameter_list|)
block|{
name|cl_qmap_t
modifier|*
name|map
init|=
name|cxt
decl_stmt|;
name|name_map_item_t
modifier|*
name|item
decl_stmt|;
name|item
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|item
condition|)
return|return
operator|-
literal|1
return|;
name|item
operator|->
name|guid
operator|=
name|guid
expr_stmt|;
name|cl_qmap_insert
argument_list|(
name|map
argument_list|,
name|guid
argument_list|,
operator|&
name|item
operator|->
name|item
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__osm_ftree_fabric_read_guid_files
parameter_list|(
name|IN
name|ftree_fabric_t
modifier|*
name|p_ftree
parameter_list|)
block|{
name|int
name|status
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|__osm_ftree_fabric_roots_provided
argument_list|(
name|p_ftree
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Fetching root nodes from file %s\n"
argument_list|,
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|root_guid_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_node_map
argument_list|(
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|root_guid_file
argument_list|,
name|add_guid_item_to_list
argument_list|,
operator|&
name|p_ftree
operator|->
name|root_guid_list
argument_list|)
condition|)
block|{
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|!
name|cl_qlist_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|root_guid_list
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB22: "
literal|"Root guids file has no valid guids\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
if|if
condition|(
name|__osm_ftree_fabric_cns_provided
argument_list|(
name|p_ftree
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Fetching compute nodes from file %s\n"
argument_list|,
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|cn_guid_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_node_map
argument_list|(
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|cn_guid_file
argument_list|,
name|add_guid_item_to_map
argument_list|,
operator|&
name|p_ftree
operator|->
name|cn_guid_tbl
argument_list|)
condition|)
block|{
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|!
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|cn_guid_tbl
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR AB23: "
literal|"Compute node guids file has no valid guids\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*__osm_ftree_fabric_read_guid_files() */
end_comment

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|int
name|__osm_ftree_construct_fabric
parameter_list|(
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
name|ftree_fabric_t
modifier|*
name|p_ftree
init|=
name|context
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
name|__osm_ftree_fabric_clear
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|opt
operator|.
name|lmc
operator|>
literal|0
condition|)
block|{
name|osm_log
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
literal|"LMC> 0 is not supported by fat-tree routing.\n"
literal|"Falling back to default routing\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
operator|<
literal|2
condition|)
block|{
name|osm_log
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
literal|"Fabric has %u switches - topology is not fat-tree.\n"
literal|"Falling back to default routing\n"
argument_list|,
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
operator|(
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|node_guid_tbl
argument_list|)
operator|-
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
operator|)
operator|<
literal|2
condition|)
block|{
name|osm_log
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
literal|"Fabric has %u nodes (%u switches) - topology is not fat-tree.\n"
literal|"Falling back to default routing\n"
argument_list|,
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|node_guid_tbl
argument_list|)
argument_list|,
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|subn
operator|.
name|sw_guid_tbl
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"\n"
literal|"                       |----------------------------------------|\n"
literal|"                       |- Starting FatTree fabric construction -|\n"
literal|"                       |----------------------------------------|\n\n"
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Populating FatTree Switch and CA tables\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|__osm_ftree_fabric_populate_nodes
argument_list|(
name|p_ftree
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|osm_log
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
literal|"Fabric topology is not fat-tree - "
literal|"falling back to default routing\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Reading guid files provided by user\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|__osm_ftree_fabric_read_guid_files
argument_list|(
name|p_ftree
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|osm_log
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
literal|"Failed reading guid files - "
literal|"falling back to default routing\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
operator|<
literal|2
condition|)
block|{
name|osm_log
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
literal|"Fabric has %u CAa - topology is not fat-tree.\n"
literal|"Falling back to default routing\n"
argument_list|,
name|cl_qmap_count
argument_list|(
operator|&
name|p_ftree
operator|->
name|hca_tbl
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Rank all the switches in the fabric. 	   After that we will know only fabric max switch rank. 	   We will be able to check leaf switches rank and the 	   whole tree rank after filling ports and marking CNs. */
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Ranking FatTree\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|__osm_ftree_fabric_rank
argument_list|(
name|p_ftree
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|osm_log
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
literal|"Failed ranking the tree\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* For each hca and switch, construct array of ports. 	   This is done after the whole FatTree data structure is ready, 	   because we want the ports to have pointers to ftree_{sw,hca}_t 	   objects, and we need the switches to be already ranked because 	   that's how the port direction is determined. */
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Populating CA& switch ports\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|__osm_ftree_fabric_populate_ports
argument_list|(
name|p_ftree
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|osm_log
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
literal|"Fabric topology is not a fat-tree\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
elseif|else
if|if
condition|(
name|p_ftree
operator|->
name|cn_num
operator|==
literal|0
condition|)
block|{
name|osm_log
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
literal|"Fabric has no valid compute nodes\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Now that the CA ports have been created and CNs were marked, 	   we can complete the fabric ranking - set leaf switches rank. */
name|__osm_ftree_fabric_set_leaf_rank
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
if|if
condition|(
name|__osm_ftree_fabric_get_rank
argument_list|(
name|p_ftree
argument_list|)
operator|>
name|FAT_TREE_MAX_RANK
operator|||
name|__osm_ftree_fabric_get_rank
argument_list|(
name|p_ftree
argument_list|)
operator|<
name|FAT_TREE_MIN_RANK
condition|)
block|{
name|osm_log
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
literal|"Fabric rank is %u (should be between %u and %u)\n"
argument_list|,
name|__osm_ftree_fabric_get_rank
argument_list|(
name|p_ftree
argument_list|)
argument_list|,
name|FAT_TREE_MIN_RANK
argument_list|,
name|FAT_TREE_MAX_RANK
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Mark all the switches in the fabric with rank equal to 	   p_ftree->leaf_switch_rank and that are also connected to CNs. 	   As a by-product, this function also runs basic topology 	   validation - it checks that all the CNs are at the same rank. */
if|if
condition|(
name|__osm_ftree_fabric_mark_leaf_switches
argument_list|(
name|p_ftree
argument_list|)
condition|)
block|{
name|osm_log
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
literal|"Fabric topology is not a fat-tree\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* Assign index to all the switches in the fabric. 	   This function also sorts leaf switch array by the switch index, 	   sorts all the port arrays of the indexed switches by remote 	   switch index, and creates switch-by-tuple table (sw_by_tuple_tbl) */
name|__osm_ftree_fabric_make_indexing
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
comment|/* Create leaf switch array sorted by index. 	   This array contains switches with rank equal to p_ftree->leaf_switch_rank 	   and that are also connected to CNs (REAL leafs), and it may contain 	   switches at the same leaf rank w/o CNs, if this is the order of indexing. 	   In any case, the first and the last switches in the array are REAL leafs. */
if|if
condition|(
name|__osm_ftree_fabric_create_leaf_switch_array
argument_list|(
name|p_ftree
argument_list|)
condition|)
block|{
name|osm_log
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
literal|"Fabric topology is not a fat-tree\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* calculate and set ftree.max_cn_per_leaf field */
name|__osm_ftree_fabric_set_max_cn_per_leaf
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
comment|/* print general info about fabric topology */
name|__osm_ftree_fabric_dump_general_info
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
comment|/* dump full tree topology */
if|if
condition|(
name|osm_log_is_active
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
name|__osm_ftree_fabric_dump
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
comment|/* the fabric is required to be PURE fat-tree only if the root 	   guid file hasn't been provided by user */
if|if
condition|(
operator|!
name|__osm_ftree_fabric_roots_provided
argument_list|(
name|p_ftree
argument_list|)
operator|&&
operator|!
name|__osm_ftree_fabric_validate_topology
argument_list|(
name|p_ftree
argument_list|)
condition|)
block|{
name|osm_log
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_SYS
argument_list|,
literal|"Fabric topology is not a fat-tree\n"
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Max LID in switch LFTs: %u\n"
argument_list|,
name|p_ftree
operator|->
name|lft_max_lid_ho
argument_list|)
expr_stmt|;
name|Exit
label|:
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Clearing FatTree Fabric data structures\n"
argument_list|)
expr_stmt|;
name|__osm_ftree_fabric_clear
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
block|}
else|else
name|p_ftree
operator|->
name|fabric_built
operator|=
name|TRUE
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"\n"
literal|"                       |--------------------------------------------------|\n"
literal|"                       |- Done constructing FatTree fabric (status = %d) -|\n"
literal|"                       |--------------------------------------------------|\n\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* __osm_ftree_construct_fabric() */
end_comment

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|int
name|__osm_ftree_do_routing
parameter_list|(
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
name|ftree_fabric_t
modifier|*
name|p_ftree
init|=
name|context
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_ftree
operator|->
name|fabric_built
condition|)
block|{
name|status
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Starting FatTree routing\n"
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Filling switch forwarding tables for Compute Nodes\n"
argument_list|)
expr_stmt|;
name|__osm_ftree_fabric_route_to_cns
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Filling switch forwarding tables for non-CN targets\n"
argument_list|)
expr_stmt|;
name|__osm_ftree_fabric_route_to_non_cns
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Filling switch forwarding tables for switch-to-switch paths\n"
argument_list|)
expr_stmt|;
name|__osm_ftree_fabric_route_to_switches
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
comment|/* for each switch, set its fwd table */
name|cl_qmap_apply_func
argument_list|(
operator|&
name|p_ftree
operator|->
name|sw_tbl
argument_list|,
name|__osm_ftree_set_sw_fwd_table
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p_ftree
argument_list|)
expr_stmt|;
comment|/* write out hca ordering file */
name|__osm_ftree_fabric_dump_hca_ordering
argument_list|(
name|p_ftree
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"FatTree routing is done\n"
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
operator|&
name|p_ftree
operator|->
name|p_osm
operator|->
name|log
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_ftree_delete
parameter_list|(
name|IN
name|void
modifier|*
name|context
parameter_list|)
block|{
if|if
condition|(
operator|!
name|context
condition|)
return|return;
name|__osm_ftree_fabric_destroy
argument_list|(
operator|(
name|ftree_fabric_t
operator|*
operator|)
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  ***************************************************/
end_comment

begin_function
name|int
name|osm_ucast_ftree_setup
parameter_list|(
name|struct
name|osm_routing_engine
modifier|*
name|r
parameter_list|,
name|osm_opensm_t
modifier|*
name|p_osm
parameter_list|)
block|{
name|ftree_fabric_t
modifier|*
name|p_ftree
init|=
name|__osm_ftree_fabric_create
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|p_ftree
condition|)
return|return
operator|-
literal|1
return|;
name|p_ftree
operator|->
name|p_osm
operator|=
name|p_osm
expr_stmt|;
name|r
operator|->
name|context
operator|=
operator|(
name|void
operator|*
operator|)
name|p_ftree
expr_stmt|;
name|r
operator|->
name|build_lid_matrices
operator|=
name|__osm_ftree_construct_fabric
expr_stmt|;
name|r
operator|->
name|ucast_build_fwd_tables
operator|=
name|__osm_ftree_do_routing
expr_stmt|;
name|r
operator|->
name|delete
operator|=
name|__osm_ftree_delete
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

