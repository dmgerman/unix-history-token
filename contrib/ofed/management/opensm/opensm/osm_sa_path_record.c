begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2008 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2006 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  * Copyright (c) 2008 Xsigo Systems Inc.  All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_pr_rcv_t.  * This object represents the PathRecord Receiver object.  * This object is part of the opensm family of objects.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qmap.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_passivelock.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_qlist.h>
end_include

begin_include
include|#
directive|include
file|<vendor/osm_vendor_api.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_base.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_port.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_node.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_switch.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_pkey.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_multicast.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_partition.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_qos_policy.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_sa.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_router.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_prefix_route.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_function_decl
specifier|extern
name|uint8_t
name|osm_get_lash_sl
parameter_list|(
name|osm_opensm_t
modifier|*
name|p_osm
parameter_list|,
specifier|const
name|osm_port_t
modifier|*
name|p_src_port
parameter_list|,
specifier|const
name|osm_port_t
modifier|*
name|p_dst_port
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
struct|struct
name|osm_pr_item
block|{
name|cl_list_item_t
name|list_item
decl_stmt|;
name|ib_path_rec_t
name|path_rec
decl_stmt|;
block|}
name|osm_pr_item_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|osm_path_parms
block|{
name|ib_net16_t
name|pkey
decl_stmt|;
name|uint8_t
name|mtu
decl_stmt|;
name|uint8_t
name|rate
decl_stmt|;
name|uint8_t
name|sl
decl_stmt|;
name|uint8_t
name|pkt_life
decl_stmt|;
name|boolean_t
name|reversible
decl_stmt|;
block|}
name|osm_path_parms_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|ib_gid_t
name|zero_gid
init|=
block|{
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
specifier|inline
name|boolean_t
name|__osm_sa_path_rec_is_tavor_port
parameter_list|(
name|IN
specifier|const
name|osm_port_t
modifier|*
specifier|const
name|p_port
parameter_list|)
block|{
name|osm_node_t
specifier|const
modifier|*
name|p_node
decl_stmt|;
name|ib_net32_t
name|vend_id
decl_stmt|;
name|p_node
operator|=
name|p_port
operator|->
name|p_node
expr_stmt|;
name|vend_id
operator|=
name|ib_node_info_get_vendor_id
argument_list|(
operator|&
name|p_node
operator|->
name|node_info
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|p_node
operator|->
name|node_info
operator|.
name|device_id
operator|==
name|CL_HTON16
argument_list|(
literal|23108
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|vend_id
operator|==
name|CL_HTON32
argument_list|(
name|OSM_VENDOR_ID_MELLANOX
argument_list|)
operator|)
operator|||
operator|(
name|vend_id
operator|==
name|CL_HTON32
argument_list|(
name|OSM_VENDOR_ID_TOPSPIN
argument_list|)
operator|)
operator|||
operator|(
name|vend_id
operator|==
name|CL_HTON32
argument_list|(
name|OSM_VENDOR_ID_SILVERSTORM
argument_list|)
operator|)
operator|||
operator|(
name|vend_id
operator|==
name|CL_HTON32
argument_list|(
name|OSM_VENDOR_ID_VOLTAIRE
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|boolean_t
name|__osm_sa_path_rec_apply_tavor_mtu_limit
parameter_list|(
name|IN
specifier|const
name|ib_path_rec_t
modifier|*
specifier|const
name|p_pr
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
specifier|const
name|p_src_port
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
specifier|const
name|p_dest_port
parameter_list|,
name|IN
specifier|const
name|ib_net64_t
name|comp_mask
parameter_list|)
block|{
name|uint8_t
name|required_mtu
decl_stmt|;
comment|/* only if at least one of the ports is a Tavor device */
if|if
condition|(
operator|!
name|__osm_sa_path_rec_is_tavor_port
argument_list|(
name|p_src_port
argument_list|)
operator|&&
operator|!
name|__osm_sa_path_rec_is_tavor_port
argument_list|(
name|p_dest_port
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* 	   we can apply the patch if either: 	   1. No MTU required 	   2. Required MTU< 	   3. Required MTU = 1K or 512 or 256 	   4. Required MTU> 256 or 512 	 */
name|required_mtu
operator|=
name|ib_path_rec_mtu
argument_list|(
name|p_pr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_MTUSELEC
operator|)
operator|&&
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_MTU
operator|)
condition|)
block|{
switch|switch
condition|(
name|ib_path_rec_mtu_sel
argument_list|(
name|p_pr
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* must be greater than */
case|case
literal|2
case|:
comment|/* exact match */
if|if
condition|(
name|IB_MTU_LEN_1024
operator|<
name|required_mtu
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
break|break;
case|case
literal|1
case|:
comment|/* must be less than */
comment|/* can't be disqualified by this one */
break|break;
case|case
literal|3
case|:
comment|/* largest available */
comment|/* the ULP intentionally requested */
comment|/* the largest MTU possible */
return|return
operator|(
name|FALSE
operator|)
return|;
break|break;
default|default:
comment|/* if we're here, there's a bug in ib_path_rec_mtu_sel() */
name|CL_ASSERT
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|__osm_pr_rcv_get_path_parms
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|ib_path_rec_t
modifier|*
specifier|const
name|p_pr
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
specifier|const
name|p_src_port
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
specifier|const
name|p_dest_port
parameter_list|,
name|IN
specifier|const
name|uint16_t
name|dest_lid_ho
parameter_list|,
name|IN
specifier|const
name|ib_net64_t
name|comp_mask
parameter_list|,
name|OUT
name|osm_path_parms_t
modifier|*
specifier|const
name|p_parms
parameter_list|)
block|{
specifier|const
name|osm_node_t
modifier|*
name|p_node
decl_stmt|;
specifier|const
name|osm_physp_t
modifier|*
name|p_physp
decl_stmt|;
specifier|const
name|osm_physp_t
modifier|*
name|p_src_physp
decl_stmt|;
specifier|const
name|osm_physp_t
modifier|*
name|p_dest_physp
decl_stmt|;
specifier|const
name|osm_prtn_t
modifier|*
name|p_prtn
init|=
name|NULL
decl_stmt|;
name|osm_opensm_t
modifier|*
name|p_osm
decl_stmt|;
specifier|const
name|ib_port_info_t
modifier|*
name|p_pi
decl_stmt|;
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|ib_net16_t
name|pkey
decl_stmt|;
name|uint8_t
name|mtu
decl_stmt|;
name|uint8_t
name|rate
decl_stmt|;
name|uint8_t
name|pkt_life
decl_stmt|;
name|uint8_t
name|required_mtu
decl_stmt|;
name|uint8_t
name|required_rate
decl_stmt|;
name|uint8_t
name|required_pkt_life
decl_stmt|;
name|uint8_t
name|sl
decl_stmt|;
name|uint8_t
name|in_port_num
decl_stmt|;
name|ib_net16_t
name|dest_lid
decl_stmt|;
name|uint8_t
name|i
decl_stmt|;
name|ib_slvl_table_t
modifier|*
name|p_slvl_tbl
init|=
name|NULL
decl_stmt|;
name|osm_qos_level_t
modifier|*
name|p_qos_level
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|valid_sl_mask
init|=
literal|0xffff
decl_stmt|;
name|int
name|is_lash
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|dest_lid
operator|=
name|cl_hton16
argument_list|(
name|dest_lid_ho
argument_list|)
expr_stmt|;
name|p_dest_physp
operator|=
name|p_dest_port
operator|->
name|p_physp
expr_stmt|;
name|p_physp
operator|=
name|p_src_port
operator|->
name|p_physp
expr_stmt|;
name|p_src_physp
operator|=
name|p_physp
expr_stmt|;
name|p_pi
operator|=
operator|&
name|p_physp
operator|->
name|port_info
expr_stmt|;
name|p_osm
operator|=
name|sa
operator|->
name|p_subn
operator|->
name|p_osm
expr_stmt|;
name|mtu
operator|=
name|ib_port_info_get_mtu_cap
argument_list|(
name|p_pi
argument_list|)
expr_stmt|;
name|rate
operator|=
name|ib_port_info_compute_rate
argument_list|(
name|p_pi
argument_list|)
expr_stmt|;
comment|/* 	   Mellanox Tavor device performance is better using 1K MTU. 	   If required MTU and MTU selector are such that 1K is OK 	   and at least one end of the path is Tavor we override the 	   port MTU with 1K. 	 */
if|if
condition|(
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|enable_quirks
operator|&&
name|__osm_sa_path_rec_apply_tavor_mtu_limit
argument_list|(
name|p_pr
argument_list|,
name|p_src_port
argument_list|,
name|p_dest_port
argument_list|,
name|comp_mask
argument_list|)
condition|)
if|if
condition|(
name|mtu
operator|>
name|IB_MTU_LEN_1024
condition|)
block|{
name|mtu
operator|=
name|IB_MTU_LEN_1024
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Optimized Path MTU to 1K for Mellanox Tavor device\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	   Walk the subnet object from source to destination, 	   tracking the most restrictive rate and mtu values along the way...  	   If source port node is a switch, then p_physp should 	   point to the port that routes the destination lid 	 */
name|p_node
operator|=
name|osm_physp_get_node_ptr
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_node
operator|->
name|sw
condition|)
block|{
comment|/* 		 * Source node is a switch. 		 * Make sure that p_physp points to the out port of the 		 * switch that routes to the destination lid (dest_lid_ho) 		 */
name|p_physp
operator|=
name|osm_switch_get_route_by_lid
argument_list|(
name|p_node
operator|->
name|sw
argument_list|,
name|dest_lid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_physp
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F02: "
literal|"Cannot find routing to LID %u from switch for GUID 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|dest_lid_ho
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
if|if
condition|(
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|qos
condition|)
block|{
comment|/* 		 * Whether this node is switch or CA, the IN port for 		 * the sl2vl table is 0, because this is a source node. 		 */
name|p_slvl_tbl
operator|=
name|osm_physp_get_slvl_tbl
argument_list|(
name|p_physp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* update valid SLs that still exist on this route */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IB_MAX_NUM_VLS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|valid_sl_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|&&
name|ib_slvl_table_get
argument_list|(
name|p_slvl_tbl
argument_list|,
name|i
argument_list|)
operator|==
name|IB_DROP_VL
condition|)
name|valid_sl_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|valid_sl_mask
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"All the SLs lead to VL15 on this path\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/* 	 * Same as above 	 */
name|p_node
operator|=
name|osm_physp_get_node_ptr
argument_list|(
name|p_dest_physp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_node
operator|->
name|sw
condition|)
block|{
comment|/* 		 * if destination is switch, we want p_dest_physp to point to port 0 		 */
name|p_dest_physp
operator|=
name|osm_switch_get_route_by_lid
argument_list|(
name|p_node
operator|->
name|sw
argument_list|,
name|dest_lid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_dest_physp
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F03: "
literal|"Cannot find routing to LID %u from switch for GUID 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|dest_lid_ho
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
comment|/* 	 * Now go through the path step by step 	 */
while|while
condition|(
name|p_physp
operator|!=
name|p_dest_physp
condition|)
block|{
name|p_node
operator|=
name|osm_physp_get_node_ptr
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
name|p_physp
operator|=
name|osm_physp_get_remote
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_physp
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F05: "
literal|"Cannot find remote phys port when routing to LID %u from node GUID 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|dest_lid_ho
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|in_port_num
operator|=
name|osm_physp_get_port_num
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
comment|/* 		   This is point to point case (no switch in between) 		 */
if|if
condition|(
name|p_physp
operator|==
name|p_dest_physp
condition|)
break|break;
name|p_node
operator|=
name|osm_physp_get_node_ptr
argument_list|(
name|p_physp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_node
operator|->
name|sw
condition|)
block|{
comment|/* 			   There is some sort of problem in the subnet object! 			   If this isn't a switch, we should have reached 			   the destination by now! 			 */
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F06: "
literal|"Internal error, bad path\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 		   Check parameters for the ingress port in this switch. 		 */
name|p_pi
operator|=
operator|&
name|p_physp
operator|->
name|port_info
expr_stmt|;
if|if
condition|(
name|mtu
operator|>
name|ib_port_info_get_mtu_cap
argument_list|(
name|p_pi
argument_list|)
condition|)
name|mtu
operator|=
name|ib_port_info_get_mtu_cap
argument_list|(
name|p_pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|rate
operator|>
name|ib_port_info_compute_rate
argument_list|(
name|p_pi
argument_list|)
condition|)
name|rate
operator|=
name|ib_port_info_compute_rate
argument_list|(
name|p_pi
argument_list|)
expr_stmt|;
comment|/* 		   Continue with the egress port on this switch. 		 */
name|p_physp
operator|=
name|osm_switch_get_route_by_lid
argument_list|(
name|p_node
operator|->
name|sw
argument_list|,
name|dest_lid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_physp
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F07: "
literal|"Dead end on path to LID %u from switch for GUID 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|dest_lid_ho
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_node_get_node_guid
argument_list|(
name|p_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_pi
operator|=
operator|&
name|p_physp
operator|->
name|port_info
expr_stmt|;
if|if
condition|(
name|mtu
operator|>
name|ib_port_info_get_mtu_cap
argument_list|(
name|p_pi
argument_list|)
condition|)
name|mtu
operator|=
name|ib_port_info_get_mtu_cap
argument_list|(
name|p_pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|rate
operator|>
name|ib_port_info_compute_rate
argument_list|(
name|p_pi
argument_list|)
condition|)
name|rate
operator|=
name|ib_port_info_compute_rate
argument_list|(
name|p_pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|qos
condition|)
block|{
comment|/* 			 * Check SL2VL table of the switch and update valid SLs 			 */
name|p_slvl_tbl
operator|=
name|osm_physp_get_slvl_tbl
argument_list|(
name|p_physp
argument_list|,
name|in_port_num
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IB_MAX_NUM_VLS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|valid_sl_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|&&
name|ib_slvl_table_get
argument_list|(
name|p_slvl_tbl
argument_list|,
name|i
argument_list|)
operator|==
name|IB_DROP_VL
condition|)
name|valid_sl_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|valid_sl_mask
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"All the SLs "
literal|"lead to VL15 on this path\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
block|}
comment|/* 	   p_physp now points to the destination 	 */
name|p_pi
operator|=
operator|&
name|p_physp
operator|->
name|port_info
expr_stmt|;
if|if
condition|(
name|mtu
operator|>
name|ib_port_info_get_mtu_cap
argument_list|(
name|p_pi
argument_list|)
condition|)
name|mtu
operator|=
name|ib_port_info_get_mtu_cap
argument_list|(
name|p_pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|rate
operator|>
name|ib_port_info_compute_rate
argument_list|(
name|p_pi
argument_list|)
condition|)
name|rate
operator|=
name|ib_port_info_compute_rate
argument_list|(
name|p_pi
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Path min MTU = %u, min rate = %u\n"
argument_list|,
name|mtu
argument_list|,
name|rate
argument_list|)
expr_stmt|;
comment|/* 	 * Get QoS Level object according to the path request 	 * and adjust path parameters according to QoS settings 	 */
if|if
condition|(
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|qos
operator|&&
name|sa
operator|->
name|p_subn
operator|->
name|p_qos_policy
operator|&&
operator|(
name|p_qos_level
operator|=
name|osm_qos_policy_get_qos_level_by_pr
argument_list|(
name|sa
operator|->
name|p_subn
operator|->
name|p_qos_policy
argument_list|,
name|p_pr
argument_list|,
name|p_src_physp
argument_list|,
name|p_dest_physp
argument_list|,
name|comp_mask
argument_list|)
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"PathRecord request matches QoS Level '%s' (%s)\n"
argument_list|,
name|p_qos_level
operator|->
name|name
argument_list|,
name|p_qos_level
operator|->
name|use
condition|?
name|p_qos_level
operator|->
name|use
else|:
literal|"no description"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_qos_level
operator|->
name|mtu_limit_set
operator|&&
operator|(
name|mtu
operator|>
name|p_qos_level
operator|->
name|mtu_limit
operator|)
condition|)
name|mtu
operator|=
name|p_qos_level
operator|->
name|mtu_limit
expr_stmt|;
if|if
condition|(
name|p_qos_level
operator|->
name|rate_limit_set
operator|&&
operator|(
name|rate
operator|>
name|p_qos_level
operator|->
name|rate_limit
operator|)
condition|)
name|rate
operator|=
name|p_qos_level
operator|->
name|rate_limit
expr_stmt|;
if|if
condition|(
name|p_qos_level
operator|->
name|sl_set
condition|)
block|{
name|sl
operator|=
name|p_qos_level
operator|->
name|sl
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|valid_sl_mask
operator|&
operator|(
literal|1
operator|<<
name|sl
operator|)
operator|)
condition|)
block|{
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
block|}
comment|/* 	 * Set packet lifetime. 	 * According to spec definition IBA 1.2 Table 205 	 * PacketLifeTime description, for loopback paths, 	 * packetLifeTime shall be zero. 	 */
if|if
condition|(
name|p_src_port
operator|==
name|p_dest_port
condition|)
name|pkt_life
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|p_qos_level
operator|&&
name|p_qos_level
operator|->
name|pkt_life_set
condition|)
name|pkt_life
operator|=
name|p_qos_level
operator|->
name|pkt_life
expr_stmt|;
else|else
name|pkt_life
operator|=
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|subnet_timeout
expr_stmt|;
comment|/* 	   Determine if these values meet the user criteria 	   and adjust appropriately 	 */
comment|/* we silently ignore cases where only the MTU selector is defined */
if|if
condition|(
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_MTUSELEC
operator|)
operator|&&
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_MTU
operator|)
condition|)
block|{
name|required_mtu
operator|=
name|ib_path_rec_mtu
argument_list|(
name|p_pr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ib_path_rec_mtu_sel
argument_list|(
name|p_pr
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* must be greater than */
if|if
condition|(
name|mtu
operator|<=
name|required_mtu
condition|)
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* must be less than */
if|if
condition|(
name|mtu
operator|>=
name|required_mtu
condition|)
block|{
comment|/* adjust to use the highest mtu 				   lower then the required one */
if|if
condition|(
name|required_mtu
operator|>
literal|1
condition|)
name|mtu
operator|=
name|required_mtu
operator|-
literal|1
expr_stmt|;
else|else
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* exact match */
if|if
condition|(
name|mtu
operator|<
name|required_mtu
condition|)
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
else|else
name|mtu
operator|=
name|required_mtu
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* largest available */
comment|/* can't be disqualified by this one */
break|break;
default|default:
comment|/* if we're here, there's a bug in ib_path_rec_mtu_sel() */
name|CL_ASSERT
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
comment|/* we silently ignore cases where only the Rate selector is defined */
if|if
condition|(
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_RATESELEC
operator|)
operator|&&
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_RATE
operator|)
condition|)
block|{
name|required_rate
operator|=
name|ib_path_rec_rate
argument_list|(
name|p_pr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ib_path_rec_rate_sel
argument_list|(
name|p_pr
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* must be greater than */
if|if
condition|(
name|rate
operator|<=
name|required_rate
condition|)
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* must be less than */
if|if
condition|(
name|rate
operator|>=
name|required_rate
condition|)
block|{
comment|/* adjust the rate to use the highest rate 				   lower then the required one */
if|if
condition|(
name|required_rate
operator|>
literal|2
condition|)
name|rate
operator|=
name|required_rate
operator|-
literal|1
expr_stmt|;
else|else
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* exact match */
if|if
condition|(
name|rate
operator|<
name|required_rate
condition|)
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
else|else
name|rate
operator|=
name|required_rate
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* largest available */
comment|/* can't be disqualified by this one */
break|break;
default|default:
comment|/* if we're here, there's a bug in ib_path_rec_mtu_sel() */
name|CL_ASSERT
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
comment|/* we silently ignore cases where only the PktLife selector is defined */
if|if
condition|(
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_PKTLIFETIMESELEC
operator|)
operator|&&
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_PKTLIFETIME
operator|)
condition|)
block|{
name|required_pkt_life
operator|=
name|ib_path_rec_pkt_life
argument_list|(
name|p_pr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ib_path_rec_pkt_life_sel
argument_list|(
name|p_pr
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* must be greater than */
if|if
condition|(
name|pkt_life
operator|<=
name|required_pkt_life
condition|)
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* must be less than */
if|if
condition|(
name|pkt_life
operator|>=
name|required_pkt_life
condition|)
block|{
comment|/* adjust the lifetime to use the highest possible 				   lower then the required one */
if|if
condition|(
name|required_pkt_life
operator|>
literal|1
condition|)
name|pkt_life
operator|=
name|required_pkt_life
operator|-
literal|1
expr_stmt|;
else|else
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* exact match */
if|if
condition|(
name|pkt_life
operator|<
name|required_pkt_life
condition|)
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
else|else
name|pkt_life
operator|=
name|required_pkt_life
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* smallest available */
comment|/* can't be disqualified by this one */
break|break;
default|default:
comment|/* if we're here, there's a bug in ib_path_rec_pkt_life_sel() */
name|CL_ASSERT
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
goto|goto
name|Exit
goto|;
comment|/* 	 * set Pkey for this path record request 	 */
if|if
condition|(
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_RAWTRAFFIC
operator|)
operator|&&
operator|(
name|cl_ntoh32
argument_list|(
name|p_pr
operator|->
name|hop_flow_raw
argument_list|)
operator|&
operator|(
literal|1
operator|<<
literal|31
operator|)
operator|)
condition|)
name|pkey
operator|=
name|osm_physp_find_common_pkey
argument_list|(
name|p_src_physp
argument_list|,
name|p_dest_physp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_PKEY
condition|)
block|{
comment|/* 		 * PR request has a specific pkey: 		 * Check that source and destination share this pkey. 		 * If QoS level has pkeys, check that this pkey exists 		 * in the QoS level pkeys. 		 * PR returned pkey is the requested pkey. 		 */
name|pkey
operator|=
name|p_pr
operator|->
name|pkey
expr_stmt|;
if|if
condition|(
operator|!
name|osm_physp_share_this_pkey
argument_list|(
name|p_src_physp
argument_list|,
name|p_dest_physp
argument_list|,
name|pkey
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F1A: "
literal|"Ports 0x%016"
name|PRIx64
literal|" 0x%016"
name|PRIx64
literal|" do not share specified PKey 0x%04x\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_src_physp
argument_list|)
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_dest_physp
argument_list|)
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|pkey
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|p_qos_level
operator|&&
name|p_qos_level
operator|->
name|pkey_range_len
operator|&&
operator|!
name|osm_qos_level_has_pkey
argument_list|(
name|p_qos_level
argument_list|,
name|pkey
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F1D: "
literal|"Ports do not share PKeys defined by QoS level\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|p_qos_level
operator|&&
name|p_qos_level
operator|->
name|pkey_range_len
condition|)
block|{
comment|/* 		 * PR request doesn't have a specific pkey, but QoS level 		 * has pkeys - get shared pkey from QoS level pkeys 		 */
name|pkey
operator|=
name|osm_qos_level_get_shared_pkey
argument_list|(
name|p_qos_level
argument_list|,
name|p_src_physp
argument_list|,
name|p_dest_physp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pkey
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F1E: "
literal|"Ports 0x%016"
name|PRIx64
literal|" 0x%016"
name|PRIx64
literal|" do not share PKeys defined by QoS level\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_src_physp
argument_list|)
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_dest_physp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
else|else
block|{
comment|/* 		 * Neither PR request nor QoS level have pkey. 		 * Just get any shared pkey. 		 */
name|pkey
operator|=
name|osm_physp_find_common_pkey
argument_list|(
name|p_src_physp
argument_list|,
name|p_dest_physp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pkey
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F1B: "
literal|"Ports 0x%016"
name|PRIx64
literal|" 0x%016"
name|PRIx64
literal|" do not have any shared PKeys\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_src_physp
argument_list|)
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_physp_get_port_guid
argument_list|(
name|p_dest_physp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
if|if
condition|(
name|pkey
condition|)
block|{
name|p_prtn
operator|=
operator|(
name|osm_prtn_t
operator|*
operator|)
name|cl_qmap_get
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|prtn_pkey_tbl
argument_list|,
name|pkey
operator|&
name|cl_hton16
argument_list|(
operator|(
name|uint16_t
operator|)
operator|~
literal|0x8000
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_prtn
operator|==
operator|(
name|osm_prtn_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|prtn_pkey_tbl
argument_list|)
condition|)
name|p_prtn
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Set PathRecord SL. 	 */
name|is_lash
operator|=
operator|(
name|p_osm
operator|->
name|routing_engine_used
operator|==
name|OSM_ROUTING_ENGINE_TYPE_LASH
operator|)
expr_stmt|;
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_SL
condition|)
block|{
comment|/* 		 * Specific SL was requested 		 */
name|sl
operator|=
name|ib_path_rec_sl
argument_list|(
name|p_pr
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_qos_level
operator|&&
name|p_qos_level
operator|->
name|sl_set
operator|&&
operator|(
name|p_qos_level
operator|->
name|sl
operator|!=
name|sl
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F1F: "
literal|"QoS constaraints: required PathRecord SL (%u) "
literal|"doesn't match QoS policy SL (%u)\n"
argument_list|,
name|sl
argument_list|,
name|p_qos_level
operator|->
name|sl
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|is_lash
operator|&&
name|osm_get_lash_sl
argument_list|(
name|p_osm
argument_list|,
name|p_src_port
argument_list|,
name|p_dest_port
argument_list|)
operator|!=
name|sl
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F23: "
literal|"Required PathRecord SL (%u) doesn't "
literal|"match LASH SL\n"
argument_list|,
name|sl
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|is_lash
condition|)
block|{
comment|/* 		 * No specific SL in PathRecord request. 		 * If it's LASH routing - use its SL. 		 * slid and dest_lid are stored in network in lash. 		 */
name|sl
operator|=
name|osm_get_lash_sl
argument_list|(
name|p_osm
argument_list|,
name|p_src_port
argument_list|,
name|p_dest_port
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_qos_level
operator|&&
name|p_qos_level
operator|->
name|sl_set
condition|)
block|{
comment|/* 		 * No specific SL was requested, and we're not in 		 * LASH routing, but there is an SL in QoS level. 		 */
name|sl
operator|=
name|p_qos_level
operator|->
name|sl
expr_stmt|;
if|if
condition|(
name|pkey
operator|&&
name|p_prtn
operator|&&
name|p_prtn
operator|->
name|sl
operator|!=
name|p_qos_level
operator|->
name|sl
condition|)
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"QoS level SL (%u) overrides partition SL (%u)\n"
argument_list|,
name|p_qos_level
operator|->
name|sl
argument_list|,
name|p_prtn
operator|->
name|sl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pkey
condition|)
block|{
comment|/* 		 * No specific SL in request or in QoS level - use partition SL 		 */
if|if
condition|(
operator|!
name|p_prtn
condition|)
block|{
name|sl
operator|=
name|OSM_DEFAULT_SL
expr_stmt|;
comment|/* this may be possible when pkey tables are created somehow in 			   previous runs or things are going wrong here */
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F1C: "
literal|"No partition found for PKey 0x%04x - using default SL %d\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|pkey
argument_list|)
argument_list|,
name|sl
argument_list|)
expr_stmt|;
block|}
else|else
name|sl
operator|=
name|p_prtn
operator|->
name|sl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|qos
condition|)
block|{
if|if
condition|(
name|valid_sl_mask
operator|&
operator|(
literal|1
operator|<<
name|OSM_DEFAULT_SL
operator|)
condition|)
name|sl
operator|=
name|OSM_DEFAULT_SL
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IB_MAX_NUM_VLS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|valid_sl_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
break|break;
name|sl
operator|=
name|i
expr_stmt|;
block|}
block|}
else|else
name|sl
operator|=
name|OSM_DEFAULT_SL
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|qos
operator|&&
operator|!
operator|(
name|valid_sl_mask
operator|&
operator|(
literal|1
operator|<<
name|sl
operator|)
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F24: "
literal|"Selected SL (%u) leads to VL15\n"
argument_list|,
name|sl
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_NOT_FOUND
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* reset pkey when raw traffic */
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_RAWTRAFFIC
operator|&&
name|cl_ntoh32
argument_list|(
name|p_pr
operator|->
name|hop_flow_raw
argument_list|)
operator|&
operator|(
literal|1
operator|<<
literal|31
operator|)
condition|)
name|pkey
operator|=
literal|0
expr_stmt|;
name|p_parms
operator|->
name|mtu
operator|=
name|mtu
expr_stmt|;
name|p_parms
operator|->
name|rate
operator|=
name|rate
expr_stmt|;
name|p_parms
operator|->
name|pkt_life
operator|=
name|pkt_life
expr_stmt|;
name|p_parms
operator|->
name|pkey
operator|=
name|pkey
expr_stmt|;
name|p_parms
operator|->
name|sl
operator|=
name|sl
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Path params: mtu = %u, rate = %u,"
literal|" packet lifetime = %u, pkey = 0x%04X, sl = %u\n"
argument_list|,
name|mtu
argument_list|,
name|rate
argument_list|,
name|pkt_life
argument_list|,
name|cl_ntoh16
argument_list|(
name|pkey
argument_list|)
argument_list|,
name|sl
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_pr_rcv_build_pr
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
specifier|const
name|p_src_port
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
specifier|const
name|p_dest_port
parameter_list|,
name|IN
specifier|const
name|ib_gid_t
modifier|*
specifier|const
name|p_dgid
parameter_list|,
name|IN
specifier|const
name|uint16_t
name|src_lid_ho
parameter_list|,
name|IN
specifier|const
name|uint16_t
name|dest_lid_ho
parameter_list|,
name|IN
specifier|const
name|uint8_t
name|preference
parameter_list|,
name|IN
specifier|const
name|osm_path_parms_t
modifier|*
specifier|const
name|p_parms
parameter_list|,
name|OUT
name|ib_path_rec_t
modifier|*
specifier|const
name|p_pr
parameter_list|)
block|{
specifier|const
name|osm_physp_t
modifier|*
name|p_src_physp
decl_stmt|;
specifier|const
name|osm_physp_t
modifier|*
name|p_dest_physp
decl_stmt|;
name|boolean_t
name|is_nonzero_gid
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_src_physp
operator|=
name|p_src_port
operator|->
name|p_physp
expr_stmt|;
if|if
condition|(
name|p_dgid
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|p_dgid
argument_list|,
operator|&
name|zero_gid
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_dgid
argument_list|)
argument_list|)
condition|)
name|is_nonzero_gid
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|is_nonzero_gid
condition|)
name|p_pr
operator|->
name|dgid
operator|=
operator|*
name|p_dgid
expr_stmt|;
else|else
block|{
name|p_dest_physp
operator|=
name|p_dest_port
operator|->
name|p_physp
expr_stmt|;
name|p_pr
operator|->
name|dgid
operator|.
name|unicast
operator|.
name|prefix
operator|=
name|osm_physp_get_subnet_prefix
argument_list|(
name|p_dest_physp
argument_list|)
expr_stmt|;
name|p_pr
operator|->
name|dgid
operator|.
name|unicast
operator|.
name|interface_id
operator|=
name|osm_physp_get_port_guid
argument_list|(
name|p_dest_physp
argument_list|)
expr_stmt|;
block|}
name|p_pr
operator|->
name|sgid
operator|.
name|unicast
operator|.
name|prefix
operator|=
name|osm_physp_get_subnet_prefix
argument_list|(
name|p_src_physp
argument_list|)
expr_stmt|;
name|p_pr
operator|->
name|sgid
operator|.
name|unicast
operator|.
name|interface_id
operator|=
name|osm_physp_get_port_guid
argument_list|(
name|p_src_physp
argument_list|)
expr_stmt|;
name|p_pr
operator|->
name|dlid
operator|=
name|cl_hton16
argument_list|(
name|dest_lid_ho
argument_list|)
expr_stmt|;
name|p_pr
operator|->
name|slid
operator|=
name|cl_hton16
argument_list|(
name|src_lid_ho
argument_list|)
expr_stmt|;
name|p_pr
operator|->
name|hop_flow_raw
operator|&=
name|cl_hton32
argument_list|(
literal|1
operator|<<
literal|31
argument_list|)
expr_stmt|;
comment|/* Only set HopLimit if going through a router */
if|if
condition|(
name|is_nonzero_gid
condition|)
name|p_pr
operator|->
name|hop_flow_raw
operator||=
name|cl_hton32
argument_list|(
name|IB_HOPLIMIT_MAX
argument_list|)
expr_stmt|;
name|p_pr
operator|->
name|pkey
operator|=
name|p_parms
operator|->
name|pkey
expr_stmt|;
name|ib_path_rec_set_sl
argument_list|(
name|p_pr
argument_list|,
name|p_parms
operator|->
name|sl
argument_list|)
expr_stmt|;
name|ib_path_rec_set_qos_class
argument_list|(
name|p_pr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p_pr
operator|->
name|mtu
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_parms
operator|->
name|mtu
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|p_pr
operator|->
name|rate
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_parms
operator|->
name|rate
operator||
literal|0x80
argument_list|)
expr_stmt|;
comment|/* According to 1.2 spec definition Table 205 PacketLifeTime description, 	   for loopback paths, packetLifeTime shall be zero. */
if|if
condition|(
name|p_src_port
operator|==
name|p_dest_port
condition|)
name|p_pr
operator|->
name|pkt_life
operator|=
literal|0x80
expr_stmt|;
comment|/* loopback */
else|else
name|p_pr
operator|->
name|pkt_life
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|p_parms
operator|->
name|pkt_life
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|p_pr
operator|->
name|preference
operator|=
name|preference
expr_stmt|;
comment|/* always return num_path = 0 so this is only the reversible component */
if|if
condition|(
name|p_parms
operator|->
name|reversible
condition|)
name|p_pr
operator|->
name|num_path
operator|=
literal|0x80
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|osm_pr_item_t
modifier|*
name|__osm_pr_rcv_get_lid_pair_path
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|ib_path_rec_t
modifier|*
specifier|const
name|p_pr
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
specifier|const
name|p_src_port
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
specifier|const
name|p_dest_port
parameter_list|,
name|IN
specifier|const
name|ib_gid_t
modifier|*
specifier|const
name|p_dgid
parameter_list|,
name|IN
specifier|const
name|uint16_t
name|src_lid_ho
parameter_list|,
name|IN
specifier|const
name|uint16_t
name|dest_lid_ho
parameter_list|,
name|IN
specifier|const
name|ib_net64_t
name|comp_mask
parameter_list|,
name|IN
specifier|const
name|uint8_t
name|preference
parameter_list|)
block|{
name|osm_path_parms_t
name|path_parms
decl_stmt|;
name|osm_path_parms_t
name|rev_path_parms
decl_stmt|;
name|osm_pr_item_t
modifier|*
name|p_pr_item
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|,
name|rev_path_status
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Src LID %u, Dest LID %u\n"
argument_list|,
name|src_lid_ho
argument_list|,
name|dest_lid_ho
argument_list|)
expr_stmt|;
name|p_pr_item
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p_pr_item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_pr_item
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F01: "
literal|"Unable to allocate path record\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|memset
argument_list|(
name|p_pr_item
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_pr_item
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|__osm_pr_rcv_get_path_parms
argument_list|(
name|sa
argument_list|,
name|p_pr
argument_list|,
name|p_src_port
argument_list|,
name|p_dest_port
argument_list|,
name|dest_lid_ho
argument_list|,
name|comp_mask
argument_list|,
operator|&
name|path_parms
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|free
argument_list|(
name|p_pr_item
argument_list|)
expr_stmt|;
name|p_pr_item
operator|=
name|NULL
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* now try the reversible path */
name|rev_path_status
operator|=
name|__osm_pr_rcv_get_path_parms
argument_list|(
name|sa
argument_list|,
name|p_pr
argument_list|,
name|p_dest_port
argument_list|,
name|p_src_port
argument_list|,
name|src_lid_ho
argument_list|,
name|comp_mask
argument_list|,
operator|&
name|rev_path_parms
argument_list|)
expr_stmt|;
name|path_parms
operator|.
name|reversible
operator|=
operator|(
name|rev_path_status
operator|==
name|IB_SUCCESS
operator|)
expr_stmt|;
comment|/* did we get a Reversible Path compmask ? */
comment|/* 	   NOTE that if the reversible component = 0, it is a don't care 	   rather then requiring non-reversible paths ... 	   see Vol1 Ver1.2 p900 l16 	 */
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_REVERSIBLE
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|path_parms
operator|.
name|reversible
operator|&&
operator|(
name|p_pr
operator|->
name|num_path
operator|&
literal|0x80
operator|)
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Requested reversible path but failed to get one\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_pr_item
argument_list|)
expr_stmt|;
name|p_pr_item
operator|=
name|NULL
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
name|__osm_pr_rcv_build_pr
argument_list|(
name|sa
argument_list|,
name|p_src_port
argument_list|,
name|p_dest_port
argument_list|,
name|p_dgid
argument_list|,
name|src_lid_ho
argument_list|,
name|dest_lid_ho
argument_list|,
name|preference
argument_list|,
operator|&
name|path_parms
argument_list|,
operator|&
name|p_pr_item
operator|->
name|path_rec
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|p_pr_item
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_pr_rcv_get_port_pair_paths
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
specifier|const
name|p_req_port
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
specifier|const
name|p_src_port
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
specifier|const
name|p_dest_port
parameter_list|,
name|IN
specifier|const
name|ib_gid_t
modifier|*
specifier|const
name|p_dgid
parameter_list|,
name|IN
specifier|const
name|ib_net64_t
name|comp_mask
parameter_list|,
name|IN
name|cl_qlist_t
modifier|*
specifier|const
name|p_list
parameter_list|)
block|{
specifier|const
name|ib_path_rec_t
modifier|*
name|p_pr
decl_stmt|;
specifier|const
name|ib_sa_mad_t
modifier|*
name|p_sa_mad
decl_stmt|;
name|osm_pr_item_t
modifier|*
name|p_pr_item
decl_stmt|;
name|uint16_t
name|src_lid_min_ho
decl_stmt|;
name|uint16_t
name|src_lid_max_ho
decl_stmt|;
name|uint16_t
name|dest_lid_min_ho
decl_stmt|;
name|uint16_t
name|dest_lid_max_ho
decl_stmt|;
name|uint16_t
name|src_lid_ho
decl_stmt|;
name|uint16_t
name|dest_lid_ho
decl_stmt|;
name|uint32_t
name|path_num
decl_stmt|;
name|uint8_t
name|preference
decl_stmt|;
name|uintn_t
name|iterations
decl_stmt|;
name|uintn_t
name|src_offset
decl_stmt|;
name|uintn_t
name|dest_offset
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Src port 0x%016"
name|PRIx64
literal|", Dst port 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_port_get_guid
argument_list|(
name|p_src_port
argument_list|)
argument_list|)
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_port_get_guid
argument_list|(
name|p_dest_port
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check that the req_port, src_port and dest_port all share a 	   pkey. The check is done on the default physical port of the ports. */
if|if
condition|(
name|osm_port_share_pkey
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_req_port
argument_list|,
name|p_src_port
argument_list|)
operator|==
name|FALSE
operator|||
name|osm_port_share_pkey
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_req_port
argument_list|,
name|p_dest_port
argument_list|)
operator|==
name|FALSE
operator|||
name|osm_port_share_pkey
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_src_port
argument_list|,
name|p_dest_port
argument_list|)
operator|==
name|FALSE
condition|)
comment|/* One of the pairs doesn't share a pkey so the path is disqualified. */
goto|goto
name|Exit
goto|;
name|p_sa_mad
operator|=
name|osm_madw_get_sa_mad_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_pr
operator|=
operator|(
name|ib_path_rec_t
operator|*
operator|)
name|ib_sa_mad_get_payload_ptr
argument_list|(
name|p_sa_mad
argument_list|)
expr_stmt|;
comment|/* 	   We shouldn't be here if the paths are disqualified in some way... 	   Thus, we assume every possible connection is valid.  	   We desire to return high-quality paths first. 	   In OpenSM, higher quality means least overlap with other paths. 	   This is acheived in practice by returning paths with 	   different LID value on each end, which means these 	   paths are more redundant that paths with the same LID repeated 	   on one side.  For example, in OpenSM the paths between two 	   endpoints with LMC = 1 might be as follows:  	   Port A, LID 1<-> Port B, LID 3 	   Port A, LID 1<-> Port B, LID 4 	   Port A, LID 2<-> Port B, LID 3 	   Port A, LID 2<-> Port B, LID 4  	   The OpenSM unicast routing algorithms attempt to disperse each path 	   to as varied a physical path as is reasonable.  1<->3 and 1<->4 have 	   more physical overlap (hence less redundancy) than 1<->3 and 2<->4.  	   OpenSM ranks paths in three preference groups:  	   Preference Value    Description 	   ----------------    ------------------------------------------- 	   0             Redundant in both directions with other 	   pref value = 0 paths  	   1             Redundant in one direction with other 	   pref value = 0 and pref value = 1 paths  	   2             Not redundant in either direction with 	   other paths  	   3-FF          Unused  	   SA clients don't need to know these details, only that the lower 	   preference paths are preferred, as stated in the spec.  The paths 	   may not actually be physically redundant depending on the topology 	   of the subnet, but the point of LMC> 0 is to offer redundancy, 	   so it is assumed that the subnet is physically appropriate for the 	   specified LMC value.  A more advanced implementation would inspect for 	   physical redundancy, but I'm not going to bother with that now. 	 */
comment|/* 	   Refine our search if the client specified end-point LIDs 	 */
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_DLID
condition|)
block|{
name|dest_lid_min_ho
operator|=
name|cl_ntoh16
argument_list|(
name|p_pr
operator|->
name|dlid
argument_list|)
expr_stmt|;
name|dest_lid_max_ho
operator|=
name|cl_ntoh16
argument_list|(
name|p_pr
operator|->
name|dlid
argument_list|)
expr_stmt|;
block|}
else|else
name|osm_port_get_lid_range_ho
argument_list|(
name|p_dest_port
argument_list|,
operator|&
name|dest_lid_min_ho
argument_list|,
operator|&
name|dest_lid_max_ho
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_SLID
condition|)
block|{
name|src_lid_min_ho
operator|=
name|cl_ntoh16
argument_list|(
name|p_pr
operator|->
name|slid
argument_list|)
expr_stmt|;
name|src_lid_max_ho
operator|=
name|cl_ntoh16
argument_list|(
name|p_pr
operator|->
name|slid
argument_list|)
expr_stmt|;
block|}
else|else
name|osm_port_get_lid_range_ho
argument_list|(
name|p_src_port
argument_list|,
operator|&
name|src_lid_min_ho
argument_list|,
operator|&
name|src_lid_max_ho
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_lid_min_ho
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F20:"
literal|"Obtained source LID of 0. No such LID possible\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|dest_lid_min_ho
operator|==
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F21:"
literal|"Obtained destination LID of 0. No such LID possible\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Src LIDs [%u-%u], Dest LIDs [%u-%u]\n"
argument_list|,
name|src_lid_min_ho
argument_list|,
name|src_lid_max_ho
argument_list|,
name|dest_lid_min_ho
argument_list|,
name|dest_lid_max_ho
argument_list|)
expr_stmt|;
name|src_lid_ho
operator|=
name|src_lid_min_ho
expr_stmt|;
name|dest_lid_ho
operator|=
name|dest_lid_min_ho
expr_stmt|;
comment|/* 	   Preferred paths come first in OpenSM 	 */
name|preference
operator|=
literal|0
expr_stmt|;
name|path_num
operator|=
literal|0
expr_stmt|;
comment|/* If SubnAdmGet, assume NumbPaths 1 (1.2 erratum) */
if|if
condition|(
name|p_sa_mad
operator|->
name|method
operator|!=
name|IB_MAD_METHOD_GET
condition|)
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_NUMBPATH
condition|)
name|iterations
operator|=
name|ib_path_rec_num_path
argument_list|(
name|p_pr
argument_list|)
expr_stmt|;
else|else
name|iterations
operator|=
call|(
name|uintn_t
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|iterations
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|path_num
operator|<
name|iterations
condition|)
block|{
comment|/* 		   These paths are "fully redundant" 		 */
name|p_pr_item
operator|=
name|__osm_pr_rcv_get_lid_pair_path
argument_list|(
name|sa
argument_list|,
name|p_pr
argument_list|,
name|p_src_port
argument_list|,
name|p_dest_port
argument_list|,
name|p_dgid
argument_list|,
name|src_lid_ho
argument_list|,
name|dest_lid_ho
argument_list|,
name|comp_mask
argument_list|,
name|preference
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_pr_item
condition|)
block|{
name|cl_qlist_insert_tail
argument_list|(
name|p_list
argument_list|,
operator|&
name|p_pr_item
operator|->
name|list_item
argument_list|)
expr_stmt|;
operator|++
name|path_num
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|src_lid_ho
operator|>
name|src_lid_max_ho
condition|)
break|break;
if|if
condition|(
operator|++
name|dest_lid_ho
operator|>
name|dest_lid_max_ho
condition|)
break|break;
block|}
comment|/* 	   Check if we've accumulated all the paths that the user cares to see 	 */
if|if
condition|(
name|path_num
operator|==
name|iterations
condition|)
goto|goto
name|Exit
goto|;
comment|/* 	   Don't bother reporting preference 1 paths for now. 	   It's more trouble than it's worth and can only occur 	   if ports have different LMC values, which isn't supported 	   by OpenSM right now anyway. 	 */
name|preference
operator|=
literal|2
expr_stmt|;
name|src_lid_ho
operator|=
name|src_lid_min_ho
expr_stmt|;
name|dest_lid_ho
operator|=
name|dest_lid_min_ho
expr_stmt|;
name|src_offset
operator|=
literal|0
expr_stmt|;
name|dest_offset
operator|=
literal|0
expr_stmt|;
comment|/* 	   Iterate over the remaining paths 	 */
while|while
condition|(
name|path_num
operator|<
name|iterations
condition|)
block|{
name|dest_offset
operator|++
expr_stmt|;
name|dest_lid_ho
operator|++
expr_stmt|;
if|if
condition|(
name|dest_lid_ho
operator|>
name|dest_lid_max_ho
condition|)
block|{
name|src_offset
operator|++
expr_stmt|;
name|src_lid_ho
operator|++
expr_stmt|;
if|if
condition|(
name|src_lid_ho
operator|>
name|src_lid_max_ho
condition|)
break|break;
comment|/* done */
name|dest_offset
operator|=
literal|0
expr_stmt|;
name|dest_lid_ho
operator|=
name|dest_lid_min_ho
expr_stmt|;
block|}
comment|/* 		   These paths are "fully non-redundant" with paths already 		   identified above and consequently not of much value.  		   Don't return paths we already identified above, as indicated 		   by the offset values being equal. 		 */
if|if
condition|(
name|src_offset
operator|==
name|dest_offset
condition|)
continue|continue;
comment|/* already reported */
name|p_pr_item
operator|=
name|__osm_pr_rcv_get_lid_pair_path
argument_list|(
name|sa
argument_list|,
name|p_pr
argument_list|,
name|p_src_port
argument_list|,
name|p_dest_port
argument_list|,
name|p_dgid
argument_list|,
name|src_lid_ho
argument_list|,
name|dest_lid_ho
argument_list|,
name|comp_mask
argument_list|,
name|preference
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_pr_item
condition|)
block|{
name|cl_qlist_insert_tail
argument_list|(
name|p_list
argument_list|,
operator|&
name|p_pr_item
operator|->
name|list_item
argument_list|)
expr_stmt|;
operator|++
name|path_num
expr_stmt|;
block|}
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_net16_t
name|__osm_pr_rcv_get_end_points
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|,
name|OUT
specifier|const
name|osm_port_t
modifier|*
modifier|*
specifier|const
name|pp_src_port
parameter_list|,
name|OUT
specifier|const
name|osm_port_t
modifier|*
modifier|*
specifier|const
name|pp_dest_port
parameter_list|,
name|OUT
name|ib_gid_t
modifier|*
specifier|const
name|p_dgid
parameter_list|)
block|{
specifier|const
name|ib_path_rec_t
modifier|*
name|p_pr
decl_stmt|;
specifier|const
name|ib_sa_mad_t
modifier|*
name|p_sa_mad
decl_stmt|;
name|ib_net64_t
name|comp_mask
decl_stmt|;
name|ib_net64_t
name|dest_guid
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|ib_net16_t
name|sa_status
init|=
name|IB_SA_MAD_STATUS_SUCCESS
decl_stmt|;
name|osm_router_t
modifier|*
name|p_rtr
decl_stmt|;
name|osm_port_t
modifier|*
name|p_rtr_port
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	   Determine what fields are valid and then get a pointer 	   to the source and destination port objects, if possible. 	 */
name|p_sa_mad
operator|=
name|osm_madw_get_sa_mad_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_pr
operator|=
operator|(
name|ib_path_rec_t
operator|*
operator|)
name|ib_sa_mad_get_payload_ptr
argument_list|(
name|p_sa_mad
argument_list|)
expr_stmt|;
name|comp_mask
operator|=
name|p_sa_mad
operator|->
name|comp_mask
expr_stmt|;
comment|/* 	   Check a few easy disqualifying cases up front before getting 	   into the endpoints. 	 */
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_SGID
condition|)
block|{
if|if
condition|(
operator|!
name|ib_gid_is_link_local
argument_list|(
operator|&
name|p_pr
operator|->
name|sgid
argument_list|)
condition|)
block|{
if|if
condition|(
name|ib_gid_get_subnet_prefix
argument_list|(
operator|&
name|p_pr
operator|->
name|sgid
argument_list|)
operator|!=
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|subnet_prefix
condition|)
block|{
comment|/* 				   This 'error' is the client's fault (bad gid) 				   so don't enter it as an error in our own log. 				   Return an error response to the client. 				 */
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Non local SGID subnet prefix 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_pr
operator|->
name|sgid
operator|.
name|unicast
operator|.
name|prefix
argument_list|)
argument_list|)
expr_stmt|;
name|sa_status
operator|=
name|IB_SA_MAD_STATUS_INVALID_GID
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
operator|*
name|pp_src_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|p_pr
operator|->
name|sgid
operator|.
name|unicast
operator|.
name|interface_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pp_src_port
condition|)
block|{
comment|/* 			   This 'error' is the client's fault (bad gid) so 			   don't enter it as an error in our own log. 			   Return an error response to the client. 			 */
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"No source port with GUID 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_pr
operator|->
name|sgid
operator|.
name|unicast
operator|.
name|interface_id
argument_list|)
argument_list|)
expr_stmt|;
name|sa_status
operator|=
name|IB_SA_MAD_STATUS_INVALID_GID
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
else|else
block|{
operator|*
name|pp_src_port
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_SLID
condition|)
block|{
name|status
operator|=
name|cl_ptr_vector_at
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|port_lid_tbl
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_pr
operator|->
name|slid
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
name|pp_src_port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|!=
name|CL_SUCCESS
operator|)
operator|||
operator|(
operator|*
name|pp_src_port
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* 				   This 'error' is the client's fault (bad lid) so 				   don't enter it as an error in our own log. 				   Return an error response to the client. 				 */
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"No source port with LID %u\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_pr
operator|->
name|slid
argument_list|)
argument_list|)
expr_stmt|;
name|sa_status
operator|=
name|IB_SA_MAD_STATUS_NO_RECORDS
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
block|}
if|if
condition|(
name|p_dgid
condition|)
name|memset
argument_list|(
name|p_dgid
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_dgid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_DGID
condition|)
block|{
name|dest_guid
operator|=
name|p_pr
operator|->
name|dgid
operator|.
name|unicast
operator|.
name|interface_id
expr_stmt|;
if|if
condition|(
operator|!
name|ib_gid_is_link_local
argument_list|(
operator|&
name|p_pr
operator|->
name|dgid
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ib_gid_is_multicast
argument_list|(
operator|&
name|p_pr
operator|->
name|dgid
argument_list|)
operator|&&
name|ib_gid_get_subnet_prefix
argument_list|(
operator|&
name|p_pr
operator|->
name|dgid
argument_list|)
operator|!=
name|sa
operator|->
name|p_subn
operator|->
name|opt
operator|.
name|subnet_prefix
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Non local DGID subnet prefix 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|p_pr
operator|->
name|dgid
operator|.
name|unicast
operator|.
name|prefix
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the router port that is configured to 				   handle this prefix, if any */
name|osm_prefix_route_t
modifier|*
name|route
init|=
name|NULL
decl_stmt|;
name|osm_prefix_route_t
modifier|*
name|r
init|=
operator|(
name|osm_prefix_route_t
operator|*
operator|)
name|cl_qlist_head
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|prefix_routes_list
argument_list|)
decl_stmt|;
while|while
condition|(
name|r
operator|!=
operator|(
name|osm_prefix_route_t
operator|*
operator|)
name|cl_qlist_end
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|prefix_routes_list
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|prefix
operator|==
name|p_pr
operator|->
name|dgid
operator|.
name|unicast
operator|.
name|prefix
operator|||
name|r
operator|->
name|prefix
operator|==
literal|0
condition|)
block|{
name|route
operator|=
name|r
expr_stmt|;
break|break;
block|}
name|r
operator|=
operator|(
name|osm_prefix_route_t
operator|*
operator|)
name|cl_qlist_next
argument_list|(
operator|&
name|r
operator|->
name|list_item
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|route
condition|)
block|{
comment|/* 					  This 'error' is the client's fault (bad gid) so 					  don't enter it as an error in our own log. 					  Return an error response to the client. 					*/
name|sa_status
operator|=
name|IB_SA_MAD_STATUS_INVALID_GID
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
elseif|else
if|if
condition|(
name|route
operator|->
name|guid
operator|==
literal|0
condition|)
block|{
comment|/* first router */
name|p_rtr
operator|=
operator|(
name|osm_router_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|rtr_guid_tbl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p_rtr
operator|=
operator|(
name|osm_router_t
operator|*
operator|)
name|cl_qmap_get
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|rtr_guid_tbl
argument_list|,
name|route
operator|->
name|guid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_rtr
operator|==
operator|(
name|osm_router_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|rtr_guid_tbl
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F22: "
literal|"Off subnet DGID but router not found\n"
argument_list|)
expr_stmt|;
name|sa_status
operator|=
name|IB_SA_MAD_STATUS_INVALID_GID
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|p_rtr_port
operator|=
name|osm_router_get_port_ptr
argument_list|(
name|p_rtr
argument_list|)
expr_stmt|;
name|dest_guid
operator|=
name|osm_port_get_guid
argument_list|(
name|p_rtr_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_dgid
condition|)
operator|*
name|p_dgid
operator|=
name|p_pr
operator|->
name|dgid
expr_stmt|;
block|}
block|}
operator|*
name|pp_dest_port
operator|=
name|osm_get_port_by_guid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|dest_guid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|pp_dest_port
condition|)
block|{
comment|/* 			   This 'error' is the client's fault (bad gid) so 			   don't enter it as an error in our own log. 			   Return an error response to the client. 			 */
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"No dest port with GUID 0x%016"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|dest_guid
argument_list|)
argument_list|)
expr_stmt|;
name|sa_status
operator|=
name|IB_SA_MAD_STATUS_INVALID_GID
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
else|else
block|{
operator|*
name|pp_dest_port
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_DLID
condition|)
block|{
name|status
operator|=
name|cl_ptr_vector_at
argument_list|(
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|port_lid_tbl
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_pr
operator|->
name|dlid
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
name|pp_dest_port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|!=
name|CL_SUCCESS
operator|)
operator|||
operator|(
operator|*
name|pp_dest_port
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* 				   This 'error' is the client's fault (bad lid) 				   so don't enter it as an error in our own log. 				   Return an error response to the client. 				 */
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"No dest port with LID %u\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_pr
operator|->
name|dlid
argument_list|)
argument_list|)
expr_stmt|;
name|sa_status
operator|=
name|IB_SA_MAD_STATUS_NO_RECORDS
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|sa_status
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_pr_rcv_process_world
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
specifier|const
name|requester_port
parameter_list|,
name|IN
specifier|const
name|ib_gid_t
modifier|*
specifier|const
name|p_dgid
parameter_list|,
name|IN
specifier|const
name|ib_net64_t
name|comp_mask
parameter_list|,
name|IN
name|cl_qlist_t
modifier|*
specifier|const
name|p_list
parameter_list|)
block|{
specifier|const
name|cl_qmap_t
modifier|*
name|p_tbl
decl_stmt|;
specifier|const
name|osm_port_t
modifier|*
name|p_dest_port
decl_stmt|;
specifier|const
name|osm_port_t
modifier|*
name|p_src_port
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	   Iterate the entire port space over itself. 	   A path record from a port to itself is legit, so no 	   need for a special case there.  	   We compute both A -> B and B -> A, since we don't have 	   any check to determine the reversability of the paths. 	 */
name|p_tbl
operator|=
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|port_guid_tbl
expr_stmt|;
name|p_dest_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_dest_port
operator|!=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_tbl
argument_list|)
condition|)
block|{
name|p_src_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_src_port
operator|!=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_tbl
argument_list|)
condition|)
block|{
name|__osm_pr_rcv_get_port_pair_paths
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|requester_port
argument_list|,
name|p_src_port
argument_list|,
name|p_dest_port
argument_list|,
name|p_dgid
argument_list|,
name|comp_mask
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
name|p_src_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_src_port
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
name|p_dest_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_dest_port
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_pr_rcv_process_half
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
specifier|const
name|requester_port
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
specifier|const
name|p_src_port
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
specifier|const
name|p_dest_port
parameter_list|,
name|IN
specifier|const
name|ib_gid_t
modifier|*
specifier|const
name|p_dgid
parameter_list|,
name|IN
specifier|const
name|ib_net64_t
name|comp_mask
parameter_list|,
name|IN
name|cl_qlist_t
modifier|*
specifier|const
name|p_list
parameter_list|)
block|{
specifier|const
name|cl_qmap_t
modifier|*
name|p_tbl
decl_stmt|;
specifier|const
name|osm_port_t
modifier|*
name|p_port
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	   Iterate over every port, looking for matches... 	   A path record from a port to itself is legit, so no 	   need to special case that one. 	 */
name|p_tbl
operator|=
operator|&
name|sa
operator|->
name|p_subn
operator|->
name|port_guid_tbl
expr_stmt|;
if|if
condition|(
name|p_src_port
condition|)
block|{
comment|/* 		   The src port if fixed, so iterate over destination ports. 		 */
name|p_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_port
operator|!=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_tbl
argument_list|)
condition|)
block|{
name|__osm_pr_rcv_get_port_pair_paths
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|requester_port
argument_list|,
name|p_src_port
argument_list|,
name|p_port
argument_list|,
name|p_dgid
argument_list|,
name|comp_mask
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
name|p_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_port
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		   The dest port if fixed, so iterate over source ports. 		 */
name|p_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_head
argument_list|(
name|p_tbl
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_port
operator|!=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_end
argument_list|(
name|p_tbl
argument_list|)
condition|)
block|{
name|__osm_pr_rcv_get_port_pair_paths
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|requester_port
argument_list|,
name|p_port
argument_list|,
name|p_dest_port
argument_list|,
name|p_dgid
argument_list|,
name|comp_mask
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
name|p_port
operator|=
operator|(
name|osm_port_t
operator|*
operator|)
name|cl_qmap_next
argument_list|(
operator|&
name|p_port
operator|->
name|map_item
argument_list|)
expr_stmt|;
block|}
block|}
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|__osm_pr_rcv_process_pair
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
specifier|const
name|requester_port
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
specifier|const
name|p_src_port
parameter_list|,
name|IN
specifier|const
name|osm_port_t
modifier|*
specifier|const
name|p_dest_port
parameter_list|,
name|IN
specifier|const
name|ib_gid_t
modifier|*
specifier|const
name|p_dgid
parameter_list|,
name|IN
specifier|const
name|ib_net64_t
name|comp_mask
parameter_list|,
name|IN
name|cl_qlist_t
modifier|*
specifier|const
name|p_list
parameter_list|)
block|{
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|__osm_pr_rcv_get_port_pair_paths
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|requester_port
argument_list|,
name|p_src_port
argument_list|,
name|p_dest_port
argument_list|,
name|p_dgid
argument_list|,
name|comp_mask
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|osm_mgrp_t
modifier|*
name|pr_get_mgrp
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|)
block|{
name|ib_path_rec_t
modifier|*
name|p_pr
decl_stmt|;
specifier|const
name|ib_sa_mad_t
modifier|*
name|p_sa_mad
decl_stmt|;
name|ib_net64_t
name|comp_mask
decl_stmt|;
name|osm_mgrp_t
modifier|*
name|mgrp
init|=
name|NULL
decl_stmt|;
name|p_sa_mad
operator|=
name|osm_madw_get_sa_mad_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_pr
operator|=
operator|(
name|ib_path_rec_t
operator|*
operator|)
name|ib_sa_mad_get_payload_ptr
argument_list|(
name|p_sa_mad
argument_list|)
expr_stmt|;
name|comp_mask
operator|=
name|p_sa_mad
operator|->
name|comp_mask
expr_stmt|;
if|if
condition|(
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_DGID
operator|)
operator|&&
operator|!
operator|(
name|mgrp
operator|=
name|osm_get_mgrp_by_mgid
argument_list|(
name|sa
argument_list|,
operator|&
name|p_pr
operator|->
name|dgid
argument_list|)
operator|)
condition|)
block|{
name|char
name|gid_str
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F09: "
literal|"No MC group found for PathRecord destination GID %s\n"
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|p_pr
operator|->
name|dgid
operator|.
name|raw
argument_list|,
name|gid_str
argument_list|,
sizeof|sizeof
name|gid_str
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_DLID
condition|)
block|{
if|if
condition|(
name|mgrp
condition|)
block|{
comment|/* check that the MLID in the MC group is */
comment|/* the same as the DLID in the PathRecord */
if|if
condition|(
name|mgrp
operator|->
name|mlid
operator|!=
name|p_pr
operator|->
name|dlid
condition|)
block|{
comment|/* Note: perhaps this might be better indicated as an invalid request */
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F10: "
literal|"MC group MLID 0x%x does not match "
literal|"PathRecord destination LID 0x%x\n"
argument_list|,
name|mgrp
operator|->
name|mlid
argument_list|,
name|p_pr
operator|->
name|dlid
argument_list|)
expr_stmt|;
name|mgrp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|mgrp
operator|=
name|osm_get_mgrp_by_mlid
argument_list|(
name|sa
operator|->
name|p_subn
argument_list|,
name|p_pr
operator|->
name|dlid
argument_list|)
operator|)
condition|)
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F11: "
literal|"No MC group found for PathRecord "
literal|"destination LID 0x%x\n"
argument_list|,
name|p_pr
operator|->
name|dlid
argument_list|)
expr_stmt|;
block|}
name|Exit
label|:
return|return
name|mgrp
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|ib_api_status_t
name|__osm_pr_match_mgrp_attributes
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|,
name|IN
specifier|const
name|osm_mgrp_t
modifier|*
specifier|const
name|p_mgrp
parameter_list|)
block|{
specifier|const
name|ib_path_rec_t
modifier|*
name|p_pr
decl_stmt|;
specifier|const
name|ib_sa_mad_t
modifier|*
name|p_sa_mad
decl_stmt|;
name|ib_net64_t
name|comp_mask
decl_stmt|;
name|ib_api_status_t
name|status
init|=
name|IB_ERROR
decl_stmt|;
name|uint32_t
name|flow_label
decl_stmt|;
name|uint8_t
name|sl
decl_stmt|;
name|uint8_t
name|hop_limit
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_sa_mad
operator|=
name|osm_madw_get_sa_mad_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_pr
operator|=
operator|(
name|ib_path_rec_t
operator|*
operator|)
name|ib_sa_mad_get_payload_ptr
argument_list|(
name|p_sa_mad
argument_list|)
expr_stmt|;
name|comp_mask
operator|=
name|p_sa_mad
operator|->
name|comp_mask
expr_stmt|;
comment|/* If SGID and/or SLID specified, should validate as member of MC group */
comment|/* Also, MTU, rate, packet lifetime, and raw traffic requested are not currently checked */
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_PKEY
condition|)
block|{
if|if
condition|(
name|p_pr
operator|->
name|pkey
operator|!=
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|pkey
condition|)
goto|goto
name|Exit
goto|;
block|}
name|ib_member_get_sl_flow_hop
argument_list|(
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|sl_flow_hop
argument_list|,
operator|&
name|sl
argument_list|,
operator|&
name|flow_label
argument_list|,
operator|&
name|hop_limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_SL
condition|)
block|{
if|if
condition|(
name|ib_path_rec_sl
argument_list|(
name|p_pr
argument_list|)
operator|!=
name|sl
condition|)
goto|goto
name|Exit
goto|;
block|}
comment|/* If SubnAdmGet, assume NumbPaths of 1 (1.2 erratum) */
if|if
condition|(
operator|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_NUMBPATH
operator|)
operator|&&
operator|(
name|p_sa_mad
operator|->
name|method
operator|!=
name|IB_MAD_METHOD_GET
operator|)
condition|)
block|{
if|if
condition|(
name|ib_path_rec_num_path
argument_list|(
name|p_pr
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_FLOWLABEL
condition|)
block|{
if|if
condition|(
name|ib_path_rec_flow_lbl
argument_list|(
name|p_pr
argument_list|)
operator|!=
name|flow_label
condition|)
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_HOPLIMIT
condition|)
block|{
if|if
condition|(
name|ib_path_rec_hop_limit
argument_list|(
name|p_pr
argument_list|)
operator|!=
name|hop_limit
condition|)
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_TCLASS
condition|)
block|{
if|if
condition|(
name|p_pr
operator|->
name|tclass
operator|!=
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|tclass
condition|)
goto|goto
name|Exit
goto|;
block|}
name|status
operator|=
name|IB_SUCCESS
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|__osm_pr_rcv_check_mcast_dest
parameter_list|(
name|IN
name|osm_sa_t
modifier|*
name|sa
parameter_list|,
name|IN
specifier|const
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|)
block|{
specifier|const
name|ib_path_rec_t
modifier|*
name|p_pr
decl_stmt|;
specifier|const
name|ib_sa_mad_t
modifier|*
name|p_sa_mad
decl_stmt|;
name|ib_net64_t
name|comp_mask
decl_stmt|;
name|int
name|is_multicast
init|=
literal|0
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_sa_mad
operator|=
name|osm_madw_get_sa_mad_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_pr
operator|=
operator|(
name|ib_path_rec_t
operator|*
operator|)
name|ib_sa_mad_get_payload_ptr
argument_list|(
name|p_sa_mad
argument_list|)
expr_stmt|;
name|comp_mask
operator|=
name|p_sa_mad
operator|->
name|comp_mask
expr_stmt|;
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_DGID
condition|)
block|{
name|is_multicast
operator|=
name|ib_gid_is_multicast
argument_list|(
operator|&
name|p_pr
operator|->
name|dgid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_multicast
condition|)
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|comp_mask
operator|&
name|IB_PR_COMPMASK_DLID
condition|)
block|{
if|if
condition|(
name|cl_ntoh16
argument_list|(
name|p_pr
operator|->
name|dlid
argument_list|)
operator|>=
name|IB_LID_MCAST_START_HO
operator|&&
name|cl_ntoh16
argument_list|(
name|p_pr
operator|->
name|dlid
argument_list|)
operator|<=
name|IB_LID_MCAST_END_HO
condition|)
name|is_multicast
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|is_multicast
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F12: "
literal|"PathRecord request indicates MGID but not MLID\n"
argument_list|)
expr_stmt|;
name|is_multicast
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|is_multicast
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|void
name|osm_pr_rcv_process
parameter_list|(
name|IN
name|void
modifier|*
name|context
parameter_list|,
name|IN
name|void
modifier|*
name|data
parameter_list|)
block|{
name|osm_sa_t
modifier|*
name|sa
init|=
name|context
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_madw
init|=
name|data
decl_stmt|;
specifier|const
name|ib_path_rec_t
modifier|*
name|p_pr
decl_stmt|;
specifier|const
name|ib_sa_mad_t
modifier|*
name|p_sa_mad
decl_stmt|;
specifier|const
name|osm_port_t
modifier|*
name|p_src_port
decl_stmt|;
specifier|const
name|osm_port_t
modifier|*
name|p_dest_port
decl_stmt|;
name|cl_qlist_t
name|pr_list
decl_stmt|;
name|ib_gid_t
name|dgid
decl_stmt|;
name|ib_net16_t
name|sa_status
decl_stmt|;
name|osm_port_t
modifier|*
name|requester_port
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_sa_mad
operator|=
name|osm_madw_get_sa_mad_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_pr
operator|=
operator|(
name|ib_path_rec_t
operator|*
operator|)
name|ib_sa_mad_get_payload_ptr
argument_list|(
name|p_sa_mad
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_sa_mad
operator|->
name|attr_id
operator|==
name|IB_MAD_ATTR_PATH_RECORD
argument_list|)
expr_stmt|;
comment|/* we only support SubnAdmGet and SubnAdmGetTable methods */
if|if
condition|(
name|p_sa_mad
operator|->
name|method
operator|!=
name|IB_MAD_METHOD_GET
operator|&&
name|p_sa_mad
operator|->
name|method
operator|!=
name|IB_MAD_METHOD_GETTABLE
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F17: "
literal|"Unsupported Method (%s)\n"
argument_list|,
name|ib_get_sa_method_str
argument_list|(
name|p_sa_mad
operator|->
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_MAD_STATUS_UNSUP_METHOD_ATTR
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* update the requester physical port. */
name|requester_port
operator|=
name|osm_get_port_by_mad_addr
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|sa
operator|->
name|p_subn
argument_list|,
name|osm_madw_get_mad_addr_ptr
argument_list|(
name|p_madw
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|requester_port
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F16: "
literal|"Cannot find requester physical port\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|osm_log_is_active
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
condition|)
name|osm_dump_path_record
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|p_pr
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
expr_stmt|;
name|cl_qlist_init
argument_list|(
operator|&
name|pr_list
argument_list|)
expr_stmt|;
comment|/* 	   Most SA functions (including this one) are read-only on the 	   subnet object, so we grab the lock non-exclusively. 	 */
name|cl_plock_acquire
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
comment|/* Handle multicast destinations separately */
if|if
condition|(
operator|(
name|ret
operator|=
name|__osm_pr_rcv_check_mcast_dest
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* Multicast DGID with unicast DLID */
name|cl_plock_release
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|osm_sa_send_error
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|IB_MAD_STATUS_INVALID_FIELD
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
goto|goto
name|McastDest
goto|;
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Unicast destination requested\n"
argument_list|)
expr_stmt|;
name|sa_status
operator|=
name|__osm_pr_rcv_get_end_points
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
operator|&
name|p_src_port
argument_list|,
operator|&
name|p_dest_port
argument_list|,
operator|&
name|dgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa_status
operator|==
name|IB_SA_MAD_STATUS_SUCCESS
condition|)
block|{
comment|/* 		   What happens next depends on the type of endpoint information 		   that was specified.... 		 */
if|if
condition|(
name|p_src_port
condition|)
block|{
if|if
condition|(
name|p_dest_port
condition|)
name|__osm_pr_rcv_process_pair
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|requester_port
argument_list|,
name|p_src_port
argument_list|,
name|p_dest_port
argument_list|,
operator|&
name|dgid
argument_list|,
name|p_sa_mad
operator|->
name|comp_mask
argument_list|,
operator|&
name|pr_list
argument_list|)
expr_stmt|;
else|else
name|__osm_pr_rcv_process_half
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|requester_port
argument_list|,
name|p_src_port
argument_list|,
name|NULL
argument_list|,
operator|&
name|dgid
argument_list|,
name|p_sa_mad
operator|->
name|comp_mask
argument_list|,
operator|&
name|pr_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p_dest_port
condition|)
name|__osm_pr_rcv_process_half
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|requester_port
argument_list|,
name|NULL
argument_list|,
name|p_dest_port
argument_list|,
operator|&
name|dgid
argument_list|,
name|p_sa_mad
operator|->
name|comp_mask
argument_list|,
operator|&
name|pr_list
argument_list|)
expr_stmt|;
else|else
comment|/* 				   Katie, bar the door! 				 */
name|__osm_pr_rcv_process_world
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|requester_port
argument_list|,
operator|&
name|dgid
argument_list|,
name|p_sa_mad
operator|->
name|comp_mask
argument_list|,
operator|&
name|pr_list
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|Unlock
goto|;
name|McastDest
label|:
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Multicast destination requested\n"
argument_list|)
expr_stmt|;
block|{
name|osm_mgrp_t
modifier|*
name|p_mgrp
init|=
name|NULL
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|osm_pr_item_t
modifier|*
name|p_pr_item
decl_stmt|;
name|uint32_t
name|flow_label
decl_stmt|;
name|uint8_t
name|sl
decl_stmt|;
name|uint8_t
name|hop_limit
decl_stmt|;
comment|/* First, get the MC info */
name|p_mgrp
operator|=
name|pr_get_mgrp
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_mgrp
condition|)
goto|goto
name|Unlock
goto|;
comment|/* Make sure the rest of the PathRecord matches the MC group attributes */
name|status
operator|=
name|__osm_pr_match_mgrp_attributes
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
name|p_mgrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|IB_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F19: "
literal|"MC group attributes don't match PathRecord request\n"
argument_list|)
expr_stmt|;
goto|goto
name|Unlock
goto|;
block|}
name|p_pr_item
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p_pr_item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_pr_item
operator|==
name|NULL
condition|)
block|{
name|OSM_LOG
argument_list|(
name|sa
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 1F18: "
literal|"Unable to allocate path record for MC group\n"
argument_list|)
expr_stmt|;
goto|goto
name|Unlock
goto|;
block|}
name|memset
argument_list|(
name|p_pr_item
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_pr_item
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy PathRecord request into response */
name|p_sa_mad
operator|=
name|osm_madw_get_sa_mad_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|p_pr
operator|=
operator|(
name|ib_path_rec_t
operator|*
operator|)
name|ib_sa_mad_get_payload_ptr
argument_list|(
name|p_sa_mad
argument_list|)
expr_stmt|;
name|p_pr_item
operator|->
name|path_rec
operator|=
operator|*
name|p_pr
expr_stmt|;
comment|/* Now, use the MC info to cruft up the PathRecord response */
name|p_pr_item
operator|->
name|path_rec
operator|.
name|dgid
operator|=
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|mgid
expr_stmt|;
name|p_pr_item
operator|->
name|path_rec
operator|.
name|dlid
operator|=
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|mlid
expr_stmt|;
name|p_pr_item
operator|->
name|path_rec
operator|.
name|tclass
operator|=
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|tclass
expr_stmt|;
name|p_pr_item
operator|->
name|path_rec
operator|.
name|num_path
operator|=
literal|1
expr_stmt|;
name|p_pr_item
operator|->
name|path_rec
operator|.
name|pkey
operator|=
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|pkey
expr_stmt|;
comment|/* MTU, rate, and packet lifetime should be exactly */
name|p_pr_item
operator|->
name|path_rec
operator|.
name|mtu
operator|=
operator|(
literal|2
operator|<<
literal|6
operator|)
operator||
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|mtu
expr_stmt|;
name|p_pr_item
operator|->
name|path_rec
operator|.
name|rate
operator|=
operator|(
literal|2
operator|<<
literal|6
operator|)
operator||
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|rate
expr_stmt|;
name|p_pr_item
operator|->
name|path_rec
operator|.
name|pkt_life
operator|=
operator|(
literal|2
operator|<<
literal|6
operator|)
operator||
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|pkt_life
expr_stmt|;
comment|/* SL, Hop Limit, and Flow Label */
name|ib_member_get_sl_flow_hop
argument_list|(
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|sl_flow_hop
argument_list|,
operator|&
name|sl
argument_list|,
operator|&
name|flow_label
argument_list|,
operator|&
name|hop_limit
argument_list|)
expr_stmt|;
name|ib_path_rec_set_sl
argument_list|(
operator|&
name|p_pr_item
operator|->
name|path_rec
argument_list|,
name|sl
argument_list|)
expr_stmt|;
name|ib_path_rec_set_qos_class
argument_list|(
operator|&
name|p_pr_item
operator|->
name|path_rec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* HopLimit is not yet set in non link local MC groups */
comment|/* If it were, this would not be needed */
if|if
condition|(
name|ib_mgid_get_scope
argument_list|(
operator|&
name|p_mgrp
operator|->
name|mcmember_rec
operator|.
name|mgid
argument_list|)
operator|!=
name|IB_MC_SCOPE_LINK_LOCAL
condition|)
name|hop_limit
operator|=
name|IB_HOPLIMIT_MAX
expr_stmt|;
name|p_pr_item
operator|->
name|path_rec
operator|.
name|hop_flow_raw
operator|=
name|cl_hton32
argument_list|(
name|hop_limit
argument_list|)
operator||
operator|(
name|flow_label
operator|<<
literal|8
operator|)
expr_stmt|;
name|cl_qlist_insert_tail
argument_list|(
operator|&
name|pr_list
argument_list|,
operator|&
name|p_pr_item
operator|->
name|list_item
argument_list|)
expr_stmt|;
block|}
name|Unlock
label|:
name|cl_plock_release
argument_list|(
name|sa
operator|->
name|p_lock
argument_list|)
expr_stmt|;
comment|/* Now, (finally) respond to the PathRecord request */
name|osm_sa_respond
argument_list|(
name|sa
argument_list|,
name|p_madw
argument_list|,
sizeof|sizeof
argument_list|(
name|ib_path_rec_t
argument_list|)
argument_list|,
operator|&
name|pr_list
argument_list|)
expr_stmt|;
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|sa
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

