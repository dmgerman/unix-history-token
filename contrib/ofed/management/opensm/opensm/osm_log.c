begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2008 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2006 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_log_t.  * This object represents the log file.  * This object is part of the opensm family of objects.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<opensm/osm_log.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|log_exit_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|WIN32
end_ifndef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_timer.h>
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|month_str
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_function_decl
name|void
name|OsmReportState
parameter_list|(
name|IN
specifier|const
name|char
modifier|*
name|p_str
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ndef WIN32 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WIN32
end_ifndef

begin_function
specifier|static
name|void
name|truncate_log_file
parameter_list|(
name|osm_log_t
modifier|*
specifier|const
name|p_log
parameter_list|)
block|{
name|int
name|fd
init|=
name|fileno
argument_list|(
name|p_log
operator|->
name|out_port
argument_list|)
decl_stmt|;
if|if
condition|(
name|ftruncate
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"truncate_log_file: cannot truncate: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"truncate_log_file: cannot rewind: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|p_log
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Windows */
end_comment

begin_function
specifier|static
name|void
name|truncate_log_file
parameter_list|(
name|osm_log_t
modifier|*
specifier|const
name|p_log
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"truncate_log_file: cannot truncate on windows system (yet)\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ndef WIN32 */
end_comment

begin_function
name|void
name|osm_log
parameter_list|(
name|IN
name|osm_log_t
modifier|*
specifier|const
name|p_log
parameter_list|,
name|IN
specifier|const
name|osm_log_level_t
name|verbosity
parameter_list|,
name|IN
specifier|const
name|char
modifier|*
name|p_str
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|buffer
index|[
name|LOG_ENTRY_SIZE_MAX
index|]
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|int
name|ret
decl_stmt|;
ifdef|#
directive|ifdef
name|WIN32
name|SYSTEMTIME
name|st
decl_stmt|;
name|uint32_t
name|pid
init|=
name|GetCurrentThreadId
argument_list|()
decl_stmt|;
else|#
directive|else
name|pid_t
name|pid
init|=
literal|0
decl_stmt|;
name|time_t
name|tim
decl_stmt|;
name|struct
name|tm
name|result
decl_stmt|;
name|uint64_t
name|time_usecs
decl_stmt|;
name|uint32_t
name|usecs
decl_stmt|;
endif|#
directive|endif
comment|/* WIN32 */
comment|/* If this is a call to syslog - always print it */
if|if
condition|(
operator|!
operator|(
name|verbosity
operator|&
operator|(
name|OSM_LOG_SYS
operator||
name|p_log
operator|->
name|level
operator|)
operator|)
condition|)
return|return;
name|va_start
argument_list|(
name|args
argument_list|,
name|p_str
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|buffer
argument_list|,
name|p_str
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
comment|/* this is a call to the syslog */
if|if
condition|(
name|verbosity
operator|&
name|OSM_LOG_SYS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
comment|/* SYSLOG should go to stdout too */
if|if
condition|(
name|p_log
operator|->
name|out_port
operator|!=
name|stdout
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|WIN32
name|OsmReportState
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* WIN32 */
block|}
comment|/* regular log to default out_port */
name|cl_spinlock_acquire
argument_list|(
operator|&
name|p_log
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_log
operator|->
name|max_size
operator|&&
name|p_log
operator|->
name|count
operator|>
name|p_log
operator|->
name|max_size
condition|)
block|{
comment|/* truncate here */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"osm_log: log file exceeds the limit %lu. Truncating.\n"
argument_list|,
name|p_log
operator|->
name|max_size
argument_list|)
expr_stmt|;
name|truncate_log_file
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|WIN32
name|GetLocalTime
argument_list|(
operator|&
name|st
argument_list|)
expr_stmt|;
name|_retry
label|:
name|ret
operator|=
name|fprintf
argument_list|(
name|p_log
operator|->
name|out_port
argument_list|,
literal|"[%02d:%02d:%02d:%03d][%04X] 0x%02x -> %s"
argument_list|,
name|st
operator|.
name|wHour
argument_list|,
name|st
operator|.
name|wMinute
argument_list|,
name|st
operator|.
name|wSecond
argument_list|,
name|st
operator|.
name|wMilliseconds
argument_list|,
name|pid
argument_list|,
name|verbosity
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
else|#
directive|else
name|time_usecs
operator|=
name|cl_get_time_stamp
argument_list|()
expr_stmt|;
name|tim
operator|=
name|time_usecs
operator|/
literal|1000000
expr_stmt|;
name|usecs
operator|=
name|time_usecs
operator|%
literal|1000000
expr_stmt|;
name|localtime_r
argument_list|(
operator|&
name|tim
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
name|pid
operator|=
name|pthread_self
argument_list|()
expr_stmt|;
name|_retry
label|:
name|ret
operator|=
name|fprintf
argument_list|(
name|p_log
operator|->
name|out_port
argument_list|,
literal|"%s %02d %02d:%02d:%02d %06d [%04X] 0x%02x -> %s"
argument_list|,
operator|(
name|result
operator|.
name|tm_mon
operator|<
literal|12
condition|?
name|month_str
index|[
name|result
operator|.
name|tm_mon
index|]
else|:
literal|"???"
operator|)
argument_list|,
name|result
operator|.
name|tm_mday
argument_list|,
name|result
operator|.
name|tm_hour
argument_list|,
name|result
operator|.
name|tm_min
argument_list|,
name|result
operator|.
name|tm_sec
argument_list|,
name|usecs
argument_list|,
name|pid
argument_list|,
name|verbosity
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  flush log */
if|if
condition|(
name|ret
operator|>
literal|0
operator|&&
operator|(
name|p_log
operator|->
name|flush
operator|||
operator|(
name|verbosity
operator|&
operator|(
name|OSM_LOG_ERROR
operator||
name|OSM_LOG_SYS
operator|)
operator|)
operator|)
operator|&&
name|fflush
argument_list|(
name|p_log
operator|->
name|out_port
argument_list|)
operator|<
literal|0
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
name|log_exit_count
operator|=
literal|0
expr_stmt|;
name|p_log
operator|->
name|count
operator|+=
name|ret
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|log_exit_count
operator|<
literal|3
condition|)
block|{
name|log_exit_count
operator|++
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ENOSPC
operator|&&
name|p_log
operator|->
name|max_size
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"osm_log: write failed: %s. Truncating log file.\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|truncate_log_file
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
goto|goto
name|_retry
goto|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"osm_log: write failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cl_spinlock_release
argument_list|(
operator|&
name|p_log
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|osm_log_raw
parameter_list|(
name|IN
name|osm_log_t
modifier|*
specifier|const
name|p_log
parameter_list|,
name|IN
specifier|const
name|osm_log_level_t
name|verbosity
parameter_list|,
name|IN
specifier|const
name|char
modifier|*
name|p_buf
parameter_list|)
block|{
if|if
condition|(
name|p_log
operator|->
name|level
operator|&
name|verbosity
condition|)
block|{
name|cl_spinlock_acquire
argument_list|(
operator|&
name|p_log
operator|->
name|lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|p_buf
argument_list|)
expr_stmt|;
name|cl_spinlock_release
argument_list|(
operator|&
name|p_log
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 		   Flush log on errors too. 		 */
if|if
condition|(
name|p_log
operator|->
name|flush
operator|||
operator|(
name|verbosity
operator|&
name|OSM_LOG_ERROR
operator|)
condition|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|osm_log_msg_box
parameter_list|(
name|IN
name|osm_log_t
modifier|*
name|log
parameter_list|,
name|osm_log_level_t
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|func_name
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
define|#
directive|define
name|MSG_BOX_LENGTH
value|66
name|char
name|buf
index|[
name|MSG_BOX_LENGTH
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|osm_log_is_active
argument_list|(
name|log
argument_list|,
name|level
argument_list|)
condition|)
return|return;
name|n
operator|=
operator|(
name|MSG_BOX_LENGTH
operator|-
name|strlen
argument_list|(
name|msg
argument_list|)
operator|)
operator|/
literal|2
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|sprintf
argument_list|(
name|buf
operator|+
name|i
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|n
operator|+=
name|snprintf
argument_list|(
name|buf
operator|+
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|n
argument_list|,
literal|" %s "
argument_list|,
name|msg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n
init|;
name|i
operator|<
name|MSG_BOX_LENGTH
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
literal|'*'
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|osm_log
argument_list|(
name|log
argument_list|,
name|level
argument_list|,
literal|"%s:\n\n\n"
literal|"*********************************************"
literal|"*********************\n%s\n"
literal|"*********************************************"
literal|"*********************\n\n\n"
argument_list|,
name|func_name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|osm_is_debug
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_DEBUG_
argument_list|)
return|return
name|TRUE
return|;
else|#
directive|else
return|return
name|FALSE
return|;
endif|#
directive|endif
comment|/* defined( _DEBUG_ ) */
block|}
end_function

begin_function
specifier|static
name|int
name|open_out_port
parameter_list|(
name|IN
name|osm_log_t
modifier|*
name|p_log
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|p_log
operator|->
name|accum_log_file
condition|)
name|p_log
operator|->
name|out_port
operator|=
name|fopen
argument_list|(
name|p_log
operator|->
name|log_file_name
argument_list|,
literal|"a+"
argument_list|)
expr_stmt|;
else|else
name|p_log
operator|->
name|out_port
operator|=
name|fopen
argument_list|(
name|p_log
operator|->
name|log_file_name
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p_log
operator|->
name|out_port
condition|)
block|{
name|syslog
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"Cannot open file \'%s\' for %s: %s\n"
argument_list|,
name|p_log
operator|->
name|log_file_name
argument_list|,
name|p_log
operator|->
name|accum_log_file
condition|?
literal|"appending"
else|:
literal|"writing"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot open file \'%s\': %s\n"
argument_list|,
name|p_log
operator|->
name|log_file_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|p_log
operator|->
name|out_port
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
condition|)
name|p_log
operator|->
name|count
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s log file opened\n"
argument_list|,
name|p_log
operator|->
name|log_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_log
operator|->
name|daemon
condition|)
block|{
name|dup2
argument_list|(
name|fileno
argument_list|(
name|p_log
operator|->
name|out_port
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|fileno
argument_list|(
name|p_log
operator|->
name|out_port
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|fileno
argument_list|(
name|p_log
operator|->
name|out_port
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|osm_log_reopen_file
parameter_list|(
name|osm_log_t
modifier|*
name|p_log
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|p_log
operator|->
name|out_port
operator|==
name|stdout
operator|||
name|p_log
operator|->
name|out_port
operator|==
name|stderr
condition|)
return|return
literal|0
return|;
name|cl_spinlock_acquire
argument_list|(
operator|&
name|p_log
operator|->
name|lock
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|p_log
operator|->
name|out_port
argument_list|)
expr_stmt|;
name|ret
operator|=
name|open_out_port
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|cl_spinlock_release
argument_list|(
operator|&
name|p_log
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|ib_api_status_t
name|osm_log_init_v2
parameter_list|(
name|IN
name|osm_log_t
modifier|*
specifier|const
name|p_log
parameter_list|,
name|IN
specifier|const
name|boolean_t
name|flush
parameter_list|,
name|IN
specifier|const
name|uint8_t
name|log_flags
parameter_list|,
name|IN
specifier|const
name|char
modifier|*
name|log_file
parameter_list|,
name|IN
specifier|const
name|unsigned
name|long
name|max_size
parameter_list|,
name|IN
specifier|const
name|boolean_t
name|accum_log_file
parameter_list|)
block|{
name|p_log
operator|->
name|level
operator|=
name|log_flags
expr_stmt|;
name|p_log
operator|->
name|flush
operator|=
name|flush
expr_stmt|;
name|p_log
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|p_log
operator|->
name|max_size
operator|=
name|max_size
expr_stmt|;
name|p_log
operator|->
name|accum_log_file
operator|=
name|accum_log_file
expr_stmt|;
name|p_log
operator|->
name|log_file_name
operator|=
operator|(
name|char
operator|*
operator|)
name|log_file
expr_stmt|;
name|openlog
argument_list|(
literal|"OpenSM"
argument_list|,
name|LOG_CONS
operator||
name|LOG_PID
argument_list|,
name|LOG_USER
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_file
operator|==
name|NULL
operator|||
operator|!
name|strcmp
argument_list|(
name|log_file
argument_list|,
literal|"-"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|log_file
argument_list|,
literal|"stdout"
argument_list|)
condition|)
name|p_log
operator|->
name|out_port
operator|=
name|stdout
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|log_file
argument_list|,
literal|"stderr"
argument_list|)
condition|)
name|p_log
operator|->
name|out_port
operator|=
name|stderr
expr_stmt|;
elseif|else
if|if
condition|(
name|open_out_port
argument_list|(
name|p_log
argument_list|)
condition|)
return|return
name|IB_ERROR
return|;
if|if
condition|(
name|cl_spinlock_init
argument_list|(
operator|&
name|p_log
operator|->
name|lock
argument_list|)
operator|==
name|CL_SUCCESS
condition|)
return|return
name|IB_SUCCESS
return|;
else|else
return|return
name|IB_ERROR
return|;
block|}
end_function

begin_function
name|ib_api_status_t
name|osm_log_init
parameter_list|(
name|IN
name|osm_log_t
modifier|*
specifier|const
name|p_log
parameter_list|,
name|IN
specifier|const
name|boolean_t
name|flush
parameter_list|,
name|IN
specifier|const
name|uint8_t
name|log_flags
parameter_list|,
name|IN
specifier|const
name|char
modifier|*
name|log_file
parameter_list|,
name|IN
specifier|const
name|boolean_t
name|accum_log_file
parameter_list|)
block|{
return|return
name|osm_log_init_v2
argument_list|(
name|p_log
argument_list|,
name|flush
argument_list|,
name|log_flags
argument_list|,
name|log_file
argument_list|,
literal|0
argument_list|,
name|accum_log_file
argument_list|)
return|;
block|}
end_function

end_unit

