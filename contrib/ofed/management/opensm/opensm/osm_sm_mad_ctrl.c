begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2008 Voltaire, Inc. All rights reserved.  * Copyright (c) 2002-2005 Mellanox Technologies LTD. All rights reserved.  * Copyright (c) 1996-2003 Intel Corporation. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_comment
comment|/*  * Abstract:  *    Implementation of osm_sm_mad_ctrl_t.  * This object represents the SM MAD request controller object.  * This object is part of the opensm family of objects.  */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<complib/cl_debug.h>
end_include

begin_include
include|#
directive|include
file|<iba/ib_types.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_sm_mad_ctrl.h>
end_include

begin_include
include|#
directive|include
file|<vendor/osm_vendor_api.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_madw.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_msgdef.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_helper.h>
end_include

begin_include
include|#
directive|include
file|<opensm/osm_opensm.h>
end_include

begin_comment
comment|/****f* opensm: SM/__osm_sm_mad_ctrl_retire_trans_mad  * NAME  * __osm_sm_mad_ctrl_retire_trans_mad  *  * DESCRIPTION  * This function handles clean-up of MADs associated with the SM's  * outstanding transactions on the wire.  *  * SYNOPSIS  */
end_comment

begin_function
specifier|static
name|void
name|__osm_sm_mad_ctrl_retire_trans_mad
parameter_list|(
name|IN
name|osm_sm_mad_ctrl_t
modifier|*
specifier|const
name|p_ctrl
parameter_list|,
name|IN
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
parameter_list|)
block|{
name|uint32_t
name|outstanding
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
comment|/* 	   Return the MAD& wrapper to the pool. 	 */
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Retiring MAD with TID 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
operator|->
name|trans_id
argument_list|)
argument_list|)
expr_stmt|;
name|osm_mad_pool_put
argument_list|(
name|p_ctrl
operator|->
name|p_mad_pool
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
name|outstanding
operator|=
name|osm_stats_dec_qp0_outstanding
argument_list|(
name|p_ctrl
operator|->
name|p_stats
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"%u QP0 MADs outstanding%s\n"
argument_list|,
name|p_ctrl
operator|->
name|p_stats
operator|->
name|qp0_mads_outstanding
argument_list|,
name|outstanding
condition|?
literal|""
else|:
literal|": wire is clean."
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************/
end_comment

begin_comment
comment|/****f* opensm: SM/__osm_sm_mad_ctrl_disp_done_callback  * NAME  * __osm_sm_mad_ctrl_disp_done_callback  *  * DESCRIPTION  * This function is the Dispatcher callback that indicates  * a received MAD has been processed by the recipient.  *  * SYNOPSIS  */
end_comment

begin_function
specifier|static
name|void
name|__osm_sm_mad_ctrl_disp_done_callback
parameter_list|(
name|IN
name|void
modifier|*
name|context
parameter_list|,
name|IN
name|void
modifier|*
name|p_data
parameter_list|)
block|{
name|osm_sm_mad_ctrl_t
modifier|*
specifier|const
name|p_ctrl
init|=
operator|(
name|osm_sm_mad_ctrl_t
operator|*
operator|)
name|context
decl_stmt|;
name|osm_madw_t
modifier|*
specifier|const
name|p_madw
init|=
operator|(
name|osm_madw_t
operator|*
operator|)
name|p_data
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|)
expr_stmt|;
comment|/* 	   If the MAD that just finished processing was a response, 	   then retire the transaction, since we must have generated 	   the request.  	   Otherwise, retire the transaction if a response was expected, 	   as in the case of a send failure. If a response was not expected, 	   just put the MAD back in the pool, because the MAD was a query 	   from some outside agent, e.g. Get(SMInfo) from another SM. 	 */
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_smp_is_response
argument_list|(
name|p_smp
argument_list|)
condition|)
block|{
name|CL_ASSERT
argument_list|(
name|p_madw
operator|->
name|resp_expected
operator|==
name|FALSE
argument_list|)
expr_stmt|;
name|__osm_sm_mad_ctrl_retire_trans_mad
argument_list|(
name|p_ctrl
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_madw
operator|->
name|resp_expected
operator|==
name|TRUE
condition|)
name|__osm_sm_mad_ctrl_retire_trans_mad
argument_list|(
name|p_ctrl
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
else|else
name|osm_mad_pool_put
argument_list|(
name|p_ctrl
operator|->
name|p_mad_pool
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************/
end_comment

begin_comment
comment|/****f* opensm: SM/__osm_sm_mad_ctrl_update_wire_stats  * NAME  * __osm_sm_mad_ctrl_update_wire_stats  *  * DESCRIPTION  * Updates wire stats for outstanding MADs and calls the VL15 poller.  *  * SYNOPSIS  */
end_comment

begin_function
specifier|static
name|void
name|__osm_sm_mad_ctrl_update_wire_stats
parameter_list|(
name|IN
name|osm_sm_mad_ctrl_t
modifier|*
specifier|const
name|p_ctrl
parameter_list|)
block|{
name|uint32_t
name|mads_on_wire
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|mads_on_wire
operator|=
name|cl_atomic_dec
argument_list|(
operator|&
name|p_ctrl
operator|->
name|p_stats
operator|->
name|qp0_mads_outstanding_on_wire
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"%u SMPs on the wire, %u outstanding\n"
argument_list|,
name|mads_on_wire
argument_list|,
name|p_ctrl
operator|->
name|p_stats
operator|->
name|qp0_mads_outstanding
argument_list|)
expr_stmt|;
comment|/* 	   We can signal the VL15 controller to send another MAD 	   if any are waiting for transmission. 	 */
name|osm_vl15_poll
argument_list|(
name|p_ctrl
operator|->
name|p_vl15
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****f* opensm: SM/__osm_sm_mad_ctrl_process_get_resp  * NAME  * __osm_sm_mad_ctrl_process_get_resp  *  * DESCRIPTION  * This function handles method GetResp() for received MADs.  * This is the most common path for QP0 MADs.  *  * SYNOPSIS  */
end_comment

begin_function
specifier|static
name|void
name|__osm_sm_mad_ctrl_process_get_resp
parameter_list|(
name|IN
name|osm_sm_mad_ctrl_t
modifier|*
specifier|const
name|p_ctrl
parameter_list|,
name|IN
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|,
name|IN
name|void
modifier|*
name|transaction_context
parameter_list|)
block|{
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|cl_status_t
name|status
decl_stmt|;
name|osm_madw_t
modifier|*
name|p_old_madw
decl_stmt|;
name|cl_disp_msgid_t
name|msg_id
init|=
name|CL_DISP_MSGID_NONE
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|transaction_context
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_smp
operator|->
name|mgmt_class
operator|==
name|IB_MCLASS_SUBN_DIR
operator|&&
operator|!
name|ib_smp_is_d
argument_list|(
name|p_smp
argument_list|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3102: "
literal|"'D' bit not set in returned SMP\n"
argument_list|)
expr_stmt|;
name|osm_dump_dr_smp
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|p_smp
argument_list|,
name|OSM_LOG_ERROR
argument_list|)
expr_stmt|;
block|}
name|p_old_madw
operator|=
operator|(
name|osm_madw_t
operator|*
operator|)
name|transaction_context
expr_stmt|;
name|__osm_sm_mad_ctrl_update_wire_stats
argument_list|(
name|p_ctrl
argument_list|)
expr_stmt|;
comment|/* 	   Copy the MAD Wrapper context from the requesting MAD 	   to the new MAD.  This mechanism allows the recipient 	   controller to recover its own context regarding this 	   MAD transaction.  Once we've copied the context, we 	   can return the original MAD to the pool. 	 */
name|osm_madw_copy_context
argument_list|(
name|p_madw
argument_list|,
name|p_old_madw
argument_list|)
expr_stmt|;
name|osm_mad_pool_put
argument_list|(
name|p_ctrl
operator|->
name|p_mad_pool
argument_list|,
name|p_old_madw
argument_list|)
expr_stmt|;
comment|/* 	   Note that attr_id (like the rest of the MAD) is in 	   network byte order. 	 */
switch|switch
condition|(
name|p_smp
operator|->
name|attr_id
condition|)
block|{
case|case
name|IB_MAD_ATTR_NODE_DESC
case|:
name|msg_id
operator|=
name|OSM_MSG_MAD_NODE_DESC
expr_stmt|;
break|break;
case|case
name|IB_MAD_ATTR_NODE_INFO
case|:
name|msg_id
operator|=
name|OSM_MSG_MAD_NODE_INFO
expr_stmt|;
break|break;
case|case
name|IB_MAD_ATTR_SWITCH_INFO
case|:
name|msg_id
operator|=
name|OSM_MSG_MAD_SWITCH_INFO
expr_stmt|;
break|break;
case|case
name|IB_MAD_ATTR_PORT_INFO
case|:
name|msg_id
operator|=
name|OSM_MSG_MAD_PORT_INFO
expr_stmt|;
break|break;
case|case
name|IB_MAD_ATTR_LIN_FWD_TBL
case|:
name|msg_id
operator|=
name|OSM_MSG_MAD_LFT
expr_stmt|;
break|break;
case|case
name|IB_MAD_ATTR_MCAST_FWD_TBL
case|:
name|msg_id
operator|=
name|OSM_MSG_MAD_MFT
expr_stmt|;
break|break;
case|case
name|IB_MAD_ATTR_SM_INFO
case|:
name|msg_id
operator|=
name|OSM_MSG_MAD_SM_INFO
expr_stmt|;
break|break;
case|case
name|IB_MAD_ATTR_SLVL_TABLE
case|:
name|msg_id
operator|=
name|OSM_MSG_MAD_SLVL
expr_stmt|;
break|break;
case|case
name|IB_MAD_ATTR_VL_ARBITRATION
case|:
name|msg_id
operator|=
name|OSM_MSG_MAD_VL_ARB
expr_stmt|;
break|break;
case|case
name|IB_MAD_ATTR_P_KEY_TABLE
case|:
name|msg_id
operator|=
name|OSM_MSG_MAD_PKEY
expr_stmt|;
break|break;
case|case
name|IB_MAD_ATTR_GUID_INFO
case|:
case|case
name|IB_MAD_ATTR_CLASS_PORT_INFO
case|:
case|case
name|IB_MAD_ATTR_NOTICE
case|:
case|case
name|IB_MAD_ATTR_INFORM_INFO
case|:
default|default:
name|cl_atomic_inc
argument_list|(
operator|&
name|p_ctrl
operator|->
name|p_stats
operator|->
name|qp0_mads_rcvd_unknown
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3103: "
literal|"Unsupported attribute = 0x%X\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_smp
operator|->
name|attr_id
argument_list|)
argument_list|)
expr_stmt|;
name|osm_dump_dr_smp
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|p_smp
argument_list|,
name|OSM_LOG_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|msg_id
operator|==
name|CL_DISP_MSGID_NONE
condition|)
goto|goto
name|Exit
goto|;
comment|/* 	   Post this MAD to the dispatcher for asynchronous 	   processing by the appropriate controller. 	 */
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Posting Dispatcher message %s\n"
argument_list|,
name|osm_get_disp_msg_str
argument_list|(
name|msg_id
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|cl_disp_post
argument_list|(
name|p_ctrl
operator|->
name|h_disp
argument_list|,
name|msg_id
argument_list|,
name|p_madw
argument_list|,
name|__osm_sm_mad_ctrl_disp_done_callback
argument_list|,
name|p_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CL_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3104: "
literal|"Dispatcher post message failed (%s) for attribute = 0x%X\n"
argument_list|,
name|CL_STATUS_MSG
argument_list|(
name|status
argument_list|)
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_smp
operator|->
name|attr_id
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****f* opensm: SM/__osm_sm_mad_ctrl_process_get  * NAME  * __osm_sm_mad_ctrl_process_get  *  * DESCRIPTION  * This function handles method Get() for received MADs.  *  * SYNOPSIS  */
end_comment

begin_function
specifier|static
name|void
name|__osm_sm_mad_ctrl_process_get
parameter_list|(
name|IN
name|osm_sm_mad_ctrl_t
modifier|*
specifier|const
name|p_ctrl
parameter_list|,
name|IN
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|)
block|{
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|cl_status_t
name|status
decl_stmt|;
name|cl_disp_msgid_t
name|msg_id
init|=
name|CL_DISP_MSGID_NONE
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
comment|/* 	   Note that attr_id (like the rest of the MAD) is in 	   network byte order. 	 */
switch|switch
condition|(
name|p_smp
operator|->
name|attr_id
condition|)
block|{
case|case
name|IB_MAD_ATTR_SM_INFO
case|:
name|msg_id
operator|=
name|OSM_MSG_MAD_SM_INFO
expr_stmt|;
break|break;
default|default:
name|cl_atomic_inc
argument_list|(
operator|&
name|p_ctrl
operator|->
name|p_stats
operator|->
name|qp0_mads_rcvd_unknown
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Ignoring SubnGet MAD - unsupported attribute = 0x%X\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_smp
operator|->
name|attr_id
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|msg_id
operator|==
name|CL_DISP_MSGID_NONE
condition|)
block|{
comment|/* 		   There is an unknown MAD attribute type for which there is 		   no recipient.  Simply retire the MAD here. 		 */
name|osm_mad_pool_put
argument_list|(
name|p_ctrl
operator|->
name|p_mad_pool
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	   Post this MAD to the dispatcher for asynchronous 	   processing by the appropriate controller. 	 */
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Posting Dispatcher message %s\n"
argument_list|,
name|osm_get_disp_msg_str
argument_list|(
name|msg_id
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|cl_disp_post
argument_list|(
name|p_ctrl
operator|->
name|h_disp
argument_list|,
name|msg_id
argument_list|,
name|p_madw
argument_list|,
name|__osm_sm_mad_ctrl_disp_done_callback
argument_list|,
name|p_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CL_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3106: "
literal|"Dispatcher post message failed (%s)\n"
argument_list|,
name|CL_STATUS_MSG
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * PARAMETERS  *  * RETURN VALUES  *  * NOTES  *  * SEE ALSO  *********/
end_comment

begin_comment
comment|/****f* opensm: SM/__osm_sm_mad_ctrl_process_set  * NAME  * __osm_sm_mad_ctrl_process_set  *  * DESCRIPTION  * This function handles method Set() for received MADs.  *  * SYNOPSIS  */
end_comment

begin_function
specifier|static
name|void
name|__osm_sm_mad_ctrl_process_set
parameter_list|(
name|IN
name|osm_sm_mad_ctrl_t
modifier|*
specifier|const
name|p_ctrl
parameter_list|,
name|IN
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|)
block|{
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|cl_status_t
name|status
decl_stmt|;
name|cl_disp_msgid_t
name|msg_id
init|=
name|CL_DISP_MSGID_NONE
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
comment|/* 	   Note that attr_id (like the rest of the MAD) is in 	   network byte order. 	 */
switch|switch
condition|(
name|p_smp
operator|->
name|attr_id
condition|)
block|{
case|case
name|IB_MAD_ATTR_SM_INFO
case|:
name|msg_id
operator|=
name|OSM_MSG_MAD_SM_INFO
expr_stmt|;
break|break;
default|default:
name|cl_atomic_inc
argument_list|(
operator|&
name|p_ctrl
operator|->
name|p_stats
operator|->
name|qp0_mads_rcvd_unknown
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3107: "
literal|"Unsupported attribute = 0x%X\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_smp
operator|->
name|attr_id
argument_list|)
argument_list|)
expr_stmt|;
name|osm_dump_dr_smp
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|p_smp
argument_list|,
name|OSM_LOG_ERROR
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|msg_id
operator|==
name|CL_DISP_MSGID_NONE
condition|)
block|{
comment|/* 		   There is an unknown MAD attribute type for which there is 		   no recipient.  Simply retire the MAD here. 		 */
name|osm_mad_pool_put
argument_list|(
name|p_ctrl
operator|->
name|p_mad_pool
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	   Post this MAD to the dispatcher for asynchronous 	   processing by the appropriate controller. 	 */
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Posting Dispatcher message %s\n"
argument_list|,
name|osm_get_disp_msg_str
argument_list|(
name|msg_id
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|cl_disp_post
argument_list|(
name|p_ctrl
operator|->
name|h_disp
argument_list|,
name|msg_id
argument_list|,
name|p_madw
argument_list|,
name|__osm_sm_mad_ctrl_disp_done_callback
argument_list|,
name|p_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CL_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3108: "
literal|"Dispatcher post message failed (%s)\n"
argument_list|,
name|CL_STATUS_MSG
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * PARAMETERS  *  * RETURN VALUES  *  * NOTES  *  * SEE ALSO  *********/
end_comment

begin_comment
comment|/****f* opensm: SM/__osm_sm_mad_ctrl_process_trap  * NAME  * __osm_sm_mad_ctrl_process_trap  *  * DESCRIPTION  * This function handles method Trap() for received MADs.  *  * SYNOPSIS  */
end_comment

begin_function
specifier|static
name|void
name|__osm_sm_mad_ctrl_process_trap
parameter_list|(
name|IN
name|osm_sm_mad_ctrl_t
modifier|*
specifier|const
name|p_ctrl
parameter_list|,
name|IN
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|)
block|{
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|cl_status_t
name|status
decl_stmt|;
name|cl_disp_msgid_t
name|msg_id
init|=
name|CL_DISP_MSGID_NONE
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
comment|/* Make sure OpenSM is master. If not - then we should not process the trap */
if|if
condition|(
name|p_ctrl
operator|->
name|p_subn
operator|->
name|sm_state
operator|!=
name|IB_SMINFO_STATE_MASTER
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Received trap but OpenSM is not in MASTER state. "
literal|"Dropping mad\n"
argument_list|)
expr_stmt|;
name|osm_mad_pool_put
argument_list|(
name|p_ctrl
operator|->
name|p_mad_pool
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	   Note that attr_id (like the rest of the MAD) is in 	   network byte order. 	 */
switch|switch
condition|(
name|p_smp
operator|->
name|attr_id
condition|)
block|{
case|case
name|IB_MAD_ATTR_NOTICE
case|:
name|msg_id
operator|=
name|OSM_MSG_MAD_NOTICE
expr_stmt|;
break|break;
default|default:
name|cl_atomic_inc
argument_list|(
operator|&
name|p_ctrl
operator|->
name|p_stats
operator|->
name|qp0_mads_rcvd_unknown
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3109: "
literal|"Unsupported attribute = 0x%X\n"
argument_list|,
name|cl_ntoh16
argument_list|(
name|p_smp
operator|->
name|attr_id
argument_list|)
argument_list|)
expr_stmt|;
name|osm_dump_dr_smp
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|p_smp
argument_list|,
name|OSM_LOG_ERROR
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|msg_id
operator|==
name|CL_DISP_MSGID_NONE
condition|)
block|{
comment|/* 		   There is an unknown MAD attribute type for which there is 		   no recipient.  Simply retire the MAD here. 		 */
name|osm_mad_pool_put
argument_list|(
name|p_ctrl
operator|->
name|p_mad_pool
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
comment|/* 	   Post this MAD to the dispatcher for asynchronous 	   processing by the appropriate controller. 	 */
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Posting Dispatcher message %s\n"
argument_list|,
name|osm_get_disp_msg_str
argument_list|(
name|msg_id
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|cl_disp_post
argument_list|(
name|p_ctrl
operator|->
name|h_disp
argument_list|,
name|msg_id
argument_list|,
name|p_madw
argument_list|,
name|__osm_sm_mad_ctrl_disp_done_callback
argument_list|,
name|p_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CL_SUCCESS
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3110: "
literal|"Dispatcher post message failed (%s)\n"
argument_list|,
name|CL_STATUS_MSG
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * PARAMETERS  *  * RETURN VALUES  *  * NOTES  *  * SEE ALSO  *********/
end_comment

begin_comment
comment|/****f* opensm: SM/__osm_sm_mad_ctrl_rcv_callback  * NAME  * __osm_sm_mad_ctrl_rcv_callback  *  * DESCRIPTION  * This is the callback from the transport layer for received MADs.  *  * SYNOPSIS  */
end_comment

begin_function
specifier|static
name|void
name|__osm_sm_mad_ctrl_rcv_callback
parameter_list|(
name|IN
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|,
name|IN
name|void
modifier|*
name|bind_context
parameter_list|,
name|IN
name|osm_madw_t
modifier|*
name|p_req_madw
parameter_list|)
block|{
name|osm_sm_mad_ctrl_t
modifier|*
name|p_ctrl
init|=
operator|(
name|osm_sm_mad_ctrl_t
operator|*
operator|)
name|bind_context
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|ib_net16_t
name|status
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
comment|/* 	   A MAD was received from the wire, possibly in response to a request. 	 */
name|cl_atomic_inc
argument_list|(
operator|&
name|p_ctrl
operator|->
name|p_stats
operator|->
name|qp0_mads_rcvd
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"%u QP0 MADs received\n"
argument_list|,
name|p_ctrl
operator|->
name|p_stats
operator|->
name|qp0_mads_rcvd
argument_list|)
expr_stmt|;
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
comment|/* if we are closing down simply do nothing */
if|if
condition|(
name|osm_exit_flag
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"Ignoring received mad - since we are exiting\n"
argument_list|)
expr_stmt|;
name|osm_dump_dr_smp
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|p_smp
argument_list|,
name|OSM_LOG_DEBUG
argument_list|)
expr_stmt|;
comment|/* retire the mad or put it back */
if|if
condition|(
name|ib_smp_is_response
argument_list|(
name|p_smp
argument_list|)
operator|||
operator|(
name|p_smp
operator|->
name|method
operator|==
name|IB_MAD_METHOD_TRAP_REPRESS
operator|)
condition|)
block|{
name|CL_ASSERT
argument_list|(
name|p_madw
operator|->
name|resp_expected
operator|==
name|FALSE
argument_list|)
expr_stmt|;
name|__osm_sm_mad_ctrl_retire_trans_mad
argument_list|(
name|p_ctrl
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_madw
operator|->
name|resp_expected
operator|==
name|TRUE
condition|)
name|__osm_sm_mad_ctrl_retire_trans_mad
argument_list|(
name|p_ctrl
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
else|else
name|osm_mad_pool_put
argument_list|(
name|p_ctrl
operator|->
name|p_mad_pool
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
if|if
condition|(
name|osm_log_is_active
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_FRAMES
argument_list|)
condition|)
name|osm_dump_dr_smp
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|p_smp
argument_list|,
name|OSM_LOG_FRAMES
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_smp
operator|->
name|mgmt_class
operator|==
name|IB_MCLASS_SUBN_DIR
condition|)
name|status
operator|=
name|ib_smp_get_status
argument_list|(
name|p_smp
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|p_smp
operator|->
name|status
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3111: "
literal|"Error status = 0x%X\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|osm_dump_dr_smp
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|p_smp
argument_list|,
name|OSM_LOG_ERROR
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|p_smp
operator|->
name|method
condition|)
block|{
case|case
name|IB_MAD_METHOD_GET_RESP
case|:
name|CL_ASSERT
argument_list|(
name|p_req_madw
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|__osm_sm_mad_ctrl_process_get_resp
argument_list|(
name|p_ctrl
argument_list|,
name|p_madw
argument_list|,
name|p_req_madw
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_MAD_METHOD_GET
case|:
name|CL_ASSERT
argument_list|(
name|p_req_madw
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|__osm_sm_mad_ctrl_process_get
argument_list|(
name|p_ctrl
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_MAD_METHOD_TRAP
case|:
name|CL_ASSERT
argument_list|(
name|p_req_madw
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|__osm_sm_mad_ctrl_process_trap
argument_list|(
name|p_ctrl
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_MAD_METHOD_SET
case|:
name|CL_ASSERT
argument_list|(
name|p_req_madw
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|__osm_sm_mad_ctrl_process_set
argument_list|(
name|p_ctrl
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_MAD_METHOD_SEND
case|:
case|case
name|IB_MAD_METHOD_REPORT
case|:
case|case
name|IB_MAD_METHOD_REPORT_RESP
case|:
case|case
name|IB_MAD_METHOD_TRAP_REPRESS
case|:
default|default:
name|cl_atomic_inc
argument_list|(
operator|&
name|p_ctrl
operator|->
name|p_stats
operator|->
name|qp0_mads_rcvd_unknown
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3112: "
literal|"Unsupported method = 0x%X\n"
argument_list|,
name|p_smp
operator|->
name|method
argument_list|)
expr_stmt|;
name|osm_dump_dr_smp
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|p_smp
argument_list|,
name|OSM_LOG_ERROR
argument_list|)
expr_stmt|;
name|osm_mad_pool_put
argument_list|(
name|p_ctrl
operator|->
name|p_mad_pool
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * PARAMETERS  *  * RETURN VALUES  *  * NOTES  *  * SEE ALSO  *********/
end_comment

begin_comment
comment|/****f* opensm: SM/__osm_sm_mad_ctrl_send_err_cb  * NAME  * __osm_sm_mad_ctrl_send_err_cb  *  * DESCRIPTION  * This is the callback from the transport layer for send errors  * on MADs that were expecting a response.  *  * SYNOPSIS  */
end_comment

begin_function
specifier|static
name|void
name|__osm_sm_mad_ctrl_send_err_cb
parameter_list|(
name|IN
name|void
modifier|*
name|bind_context
parameter_list|,
name|IN
name|osm_madw_t
modifier|*
name|p_madw
parameter_list|)
block|{
name|osm_sm_mad_ctrl_t
modifier|*
name|p_ctrl
init|=
operator|(
name|osm_sm_mad_ctrl_t
operator|*
operator|)
name|bind_context
decl_stmt|;
name|ib_api_status_t
name|status
decl_stmt|;
name|ib_smp_t
modifier|*
name|p_smp
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|)
expr_stmt|;
name|CL_ASSERT
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3113: "
literal|"MAD completed in error (%s)\n"
argument_list|,
name|ib_get_err_str
argument_list|(
name|p_madw
operator|->
name|status
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	   If this was a SubnSet MAD, then this error might indicate a problem 	   in configuring the subnet. In this case - need to mark that there was 	   such a problem. The subnet will not be up, and the next sweep should 	   be a heavy sweep as well. 	 */
name|p_smp
operator|=
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_smp
operator|->
name|method
operator|==
name|IB_MAD_METHOD_SET
operator|&&
operator|(
name|p_smp
operator|->
name|attr_id
operator|==
name|IB_MAD_ATTR_PORT_INFO
operator|||
name|p_smp
operator|->
name|attr_id
operator|==
name|IB_MAD_ATTR_MCAST_FWD_TBL
operator|||
name|p_smp
operator|->
name|attr_id
operator|==
name|IB_MAD_ATTR_SWITCH_INFO
operator|||
name|p_smp
operator|->
name|attr_id
operator|==
name|IB_MAD_ATTR_LIN_FWD_TBL
operator|)
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3119: "
literal|"Set method failed\n"
argument_list|)
expr_stmt|;
name|p_ctrl
operator|->
name|p_subn
operator|->
name|subnet_initialization_error
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* 	   Since we did not get any response we suspect the DR path 	   used for the target port. 	   Find it and replace it with an alternate path. 	   This is true only if the destination lid is not 0xFFFF, since 	   then we are aiming for a specific path and not specific destination 	   lid. 	 */
comment|/* For now - do not add the alternate dr path to the release */
if|#
directive|if
literal|0
block|if (p_madw->mad_addr.dest_lid != 0xFFFF) { 		osm_physp_t *p_physp = 		    osm_get_physp_by_mad_addr(p_ctrl->p_log, 					      p_ctrl->p_subn,&(p_madw->mad_addr)); 		if (!p_physp) { 			OSM_LOG(p_ctrl->p_log, OSM_LOG_ERROR, "ERR 3114: " 				"Failed to find the corresponding phys port\n"); 		} else { 			osm_physp_replace_dr_path_with_alternate_dr_path 			    (p_ctrl->p_log, p_ctrl->p_subn, p_physp, 			     p_madw->h_bind); 		} 	}
endif|#
directive|endif
comment|/* 	   An error occurred.  No response was received to a request MAD. 	   Retire the original request MAD. 	 */
name|osm_dump_dr_smp
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|osm_madw_get_smp_ptr
argument_list|(
name|p_madw
argument_list|)
argument_list|,
name|OSM_LOG_ERROR
argument_list|)
expr_stmt|;
name|__osm_sm_mad_ctrl_update_wire_stats
argument_list|(
name|p_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|osm_madw_get_err_msg
argument_list|(
name|p_madw
argument_list|)
operator|!=
name|CL_DISP_MSGID_NONE
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_DEBUG
argument_list|,
literal|"Posting Dispatcher message %s\n"
argument_list|,
name|osm_get_disp_msg_str
argument_list|(
name|osm_madw_get_err_msg
argument_list|(
name|p_madw
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|cl_disp_post
argument_list|(
name|p_ctrl
operator|->
name|h_disp
argument_list|,
name|osm_madw_get_err_msg
argument_list|(
name|p_madw
argument_list|)
argument_list|,
name|p_madw
argument_list|,
name|__osm_sm_mad_ctrl_disp_done_callback
argument_list|,
name|p_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|CL_SUCCESS
condition|)
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3115: "
literal|"Dispatcher post message failed (%s)\n"
argument_list|,
name|CL_STATUS_MSG
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* 		   No error message was provided, just retire the MAD. 		 */
name|__osm_sm_mad_ctrl_retire_trans_mad
argument_list|(
name|p_ctrl
argument_list|,
name|p_madw
argument_list|)
expr_stmt|;
name|OSM_LOG_EXIT
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * PARAMETERS  *  * RETURN VALUES  *  * NOTES  *  * SEE ALSO  *********/
end_comment

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|void
name|osm_sm_mad_ctrl_construct
parameter_list|(
name|IN
name|osm_sm_mad_ctrl_t
modifier|*
specifier|const
name|p_ctrl
parameter_list|)
block|{
name|CL_ASSERT
argument_list|(
name|p_ctrl
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_ctrl
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p_ctrl
argument_list|)
argument_list|)
expr_stmt|;
name|p_ctrl
operator|->
name|h_disp
operator|=
name|CL_DISP_INVALID_HANDLE
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|void
name|osm_sm_mad_ctrl_destroy
parameter_list|(
name|IN
name|osm_sm_mad_ctrl_t
modifier|*
specifier|const
name|p_ctrl
parameter_list|)
block|{
name|CL_ASSERT
argument_list|(
name|p_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ctrl
operator|->
name|h_bind
operator|!=
name|CL_DISP_INVALID_HANDLE
condition|)
name|osm_vendor_unbind
argument_list|(
name|p_ctrl
operator|->
name|h_bind
argument_list|)
expr_stmt|;
name|cl_disp_unregister
argument_list|(
name|p_ctrl
operator|->
name|h_disp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|ib_api_status_t
name|osm_sm_mad_ctrl_init
parameter_list|(
name|IN
name|osm_sm_mad_ctrl_t
modifier|*
specifier|const
name|p_ctrl
parameter_list|,
name|IN
name|osm_subn_t
modifier|*
specifier|const
name|p_subn
parameter_list|,
name|IN
name|osm_mad_pool_t
modifier|*
specifier|const
name|p_mad_pool
parameter_list|,
name|IN
name|osm_vl15_t
modifier|*
specifier|const
name|p_vl15
parameter_list|,
name|IN
name|osm_vendor_t
modifier|*
specifier|const
name|p_vendor
parameter_list|,
name|IN
name|osm_log_t
modifier|*
specifier|const
name|p_log
parameter_list|,
name|IN
name|osm_stats_t
modifier|*
specifier|const
name|p_stats
parameter_list|,
name|IN
name|cl_plock_t
modifier|*
specifier|const
name|p_lock
parameter_list|,
name|IN
name|cl_dispatcher_t
modifier|*
specifier|const
name|p_disp
parameter_list|)
block|{
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
name|osm_sm_mad_ctrl_construct
argument_list|(
name|p_ctrl
argument_list|)
expr_stmt|;
name|p_ctrl
operator|->
name|p_subn
operator|=
name|p_subn
expr_stmt|;
name|p_ctrl
operator|->
name|p_log
operator|=
name|p_log
expr_stmt|;
name|p_ctrl
operator|->
name|p_disp
operator|=
name|p_disp
expr_stmt|;
name|p_ctrl
operator|->
name|p_mad_pool
operator|=
name|p_mad_pool
expr_stmt|;
name|p_ctrl
operator|->
name|p_vendor
operator|=
name|p_vendor
expr_stmt|;
name|p_ctrl
operator|->
name|p_stats
operator|=
name|p_stats
expr_stmt|;
name|p_ctrl
operator|->
name|p_lock
operator|=
name|p_lock
expr_stmt|;
name|p_ctrl
operator|->
name|p_vl15
operator|=
name|p_vl15
expr_stmt|;
name|p_ctrl
operator|->
name|h_disp
operator|=
name|cl_disp_register
argument_list|(
name|p_disp
argument_list|,
name|CL_DISP_MSGID_NONE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ctrl
operator|->
name|h_disp
operator|==
name|CL_DISP_INVALID_HANDLE
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3116: "
literal|"Dispatcher registration failed\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_INSUFFICIENT_RESOURCES
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  **********************************************************************/
end_comment

begin_function
name|ib_api_status_t
name|osm_sm_mad_ctrl_bind
parameter_list|(
name|IN
name|osm_sm_mad_ctrl_t
modifier|*
specifier|const
name|p_ctrl
parameter_list|,
name|IN
specifier|const
name|ib_net64_t
name|port_guid
parameter_list|)
block|{
name|osm_bind_info_t
name|bind_info
decl_stmt|;
name|ib_api_status_t
name|status
init|=
name|IB_SUCCESS
decl_stmt|;
name|OSM_LOG_ENTER
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ctrl
operator|->
name|h_bind
operator|!=
name|OSM_BIND_INVALID_HANDLE
condition|)
block|{
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3117: "
literal|"Multiple binds not allowed\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|IB_ERROR
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|bind_info
operator|.
name|class_version
operator|=
literal|1
expr_stmt|;
name|bind_info
operator|.
name|is_report_processor
operator|=
name|FALSE
expr_stmt|;
name|bind_info
operator|.
name|is_responder
operator|=
name|TRUE
expr_stmt|;
name|bind_info
operator|.
name|is_trap_processor
operator|=
name|TRUE
expr_stmt|;
name|bind_info
operator|.
name|mad_class
operator|=
name|IB_MCLASS_SUBN_DIR
expr_stmt|;
name|bind_info
operator|.
name|port_guid
operator|=
name|port_guid
expr_stmt|;
name|bind_info
operator|.
name|recv_q_size
operator|=
name|OSM_SM_DEFAULT_QP0_RCV_SIZE
expr_stmt|;
name|bind_info
operator|.
name|send_q_size
operator|=
name|OSM_SM_DEFAULT_QP0_SEND_SIZE
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_VERBOSE
argument_list|,
literal|"Binding to port 0x%"
name|PRIx64
literal|"\n"
argument_list|,
name|cl_ntoh64
argument_list|(
name|port_guid
argument_list|)
argument_list|)
expr_stmt|;
name|p_ctrl
operator|->
name|h_bind
operator|=
name|osm_vendor_bind
argument_list|(
name|p_ctrl
operator|->
name|p_vendor
argument_list|,
operator|&
name|bind_info
argument_list|,
name|p_ctrl
operator|->
name|p_mad_pool
argument_list|,
name|__osm_sm_mad_ctrl_rcv_callback
argument_list|,
name|__osm_sm_mad_ctrl_send_err_cb
argument_list|,
name|p_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_ctrl
operator|->
name|h_bind
operator|==
name|OSM_BIND_INVALID_HANDLE
condition|)
block|{
name|status
operator|=
name|IB_ERROR
expr_stmt|;
name|OSM_LOG
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|,
name|OSM_LOG_ERROR
argument_list|,
literal|"ERR 3118: "
literal|"Vendor specific bind failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|Exit
goto|;
block|}
name|Exit
label|:
name|OSM_LOG_EXIT
argument_list|(
name|p_ctrl
operator|->
name|p_log
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

end_unit

