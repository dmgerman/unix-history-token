begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2008 Voltaire Inc.  All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_define
define|#
directive|define
name|_GNU_SOURCE
end_define

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_CONFIG_H */
end_comment

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<endian.h>
end_include

begin_include
include|#
directive|include
file|<byteswap.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_function
specifier|static
name|int
name|ret_code
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|e
operator|>
literal|0
condition|)
return|return
operator|-
name|e
return|;
return|return
name|e
return|;
block|}
end_function

begin_function
name|int
name|sys_read_string
parameter_list|(
name|char
modifier|*
name|dir_name
parameter_list|,
name|char
modifier|*
name|file_name
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|int
name|max_len
parameter_list|)
block|{
name|char
name|path
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir_name
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
operator|&
name|path
index|[
literal|0
index|]
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'/'
condition|)
operator|*
name|s
operator|=
literal|'.'
expr_stmt|;
name|len
operator|=
name|max_len
expr_stmt|;
if|if
condition|(
name|sysctlbyname
argument_list|(
operator|&
name|path
index|[
literal|1
index|]
argument_list|,
name|str
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|ret_code
argument_list|()
return|;
name|str
index|[
operator|(
name|len
operator|<
name|max_len
operator|)
condition|?
name|len
else|:
name|max_len
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|strrchr
argument_list|(
name|str
argument_list|,
literal|'\n'
argument_list|)
operator|)
condition|)
operator|*
name|s
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|sys_read_guid
parameter_list|(
name|char
modifier|*
name|dir_name
parameter_list|,
name|char
modifier|*
name|file_name
parameter_list|,
name|uint64_t
modifier|*
name|net_guid
parameter_list|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|,
modifier|*
name|str
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|int
name|r
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sys_read_string
argument_list|(
name|dir_name
argument_list|,
name|file_name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|r
return|;
name|guid
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|buf
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|str
operator|=
name|strsep
argument_list|(
operator|&
name|s
argument_list|,
literal|": \t\n"
argument_list|)
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|guid
operator|=
operator|(
name|guid
operator|<<
literal|16
operator|)
operator||
operator|(
name|strtoul
argument_list|(
name|str
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
block|}
operator|*
name|net_guid
operator|=
name|htonll
argument_list|(
name|guid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|sys_read_gid
parameter_list|(
name|char
modifier|*
name|dir_name
parameter_list|,
name|char
modifier|*
name|file_name
parameter_list|,
name|uint8_t
modifier|*
name|gid
parameter_list|)
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|,
modifier|*
name|str
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|uint16_t
modifier|*
name|ugid
init|=
operator|(
name|uint16_t
operator|*
operator|)
name|gid
decl_stmt|;
name|int
name|r
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sys_read_string
argument_list|(
name|dir_name
argument_list|,
name|file_name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|r
return|;
for|for
control|(
name|s
operator|=
name|buf
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|str
operator|=
name|strsep
argument_list|(
operator|&
name|s
argument_list|,
literal|": \t\n"
argument_list|)
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|ugid
index|[
name|i
index|]
operator|=
name|htons
argument_list|(
name|strtoul
argument_list|(
name|str
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|sys_read_uint64
parameter_list|(
name|char
modifier|*
name|dir_name
parameter_list|,
name|char
modifier|*
name|file_name
parameter_list|,
name|uint64_t
modifier|*
name|u
parameter_list|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sys_read_string
argument_list|(
name|dir_name
argument_list|,
name|file_name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|r
return|;
operator|*
name|u
operator|=
name|strtoull
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|sys_read_uint
parameter_list|(
name|char
modifier|*
name|dir_name
parameter_list|,
name|char
modifier|*
name|file_name
parameter_list|,
name|unsigned
modifier|*
name|u
parameter_list|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|sys_read_string
argument_list|(
name|dir_name
argument_list|,
name|file_name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|r
return|;
operator|*
name|u
operator|=
name|strtoul
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|DIRECTSIZ
parameter_list|(
name|namlen
parameter_list|)
define|\
value|(((uintptr_t)&((struct dirent *)0)->d_name +			\ 	((namlen)+1)*sizeof(((struct dirent *)0)->d_name[0]) + 3)& ~3)
end_define

begin_function
name|int
name|sys_scandir
parameter_list|(
specifier|const
name|char
modifier|*
name|dirname
parameter_list|,
name|struct
name|dirent
modifier|*
modifier|*
modifier|*
name|namelist
parameter_list|,
name|int
function_decl|(
modifier|*
name|select
function_decl|)
parameter_list|(
specifier|const
name|struct
name|dirent
modifier|*
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|compar
function_decl|)
parameter_list|(
specifier|const
name|struct
name|dirent
modifier|*
modifier|*
parameter_list|,
specifier|const
name|struct
name|dirent
modifier|*
modifier|*
parameter_list|)
parameter_list|)
block|{
name|struct
name|dirent
modifier|*
modifier|*
name|names
decl_stmt|;
name|struct
name|dirent
modifier|*
modifier|*
name|names2
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|char
name|name
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|lsname
index|[
literal|22
index|]
decl_stmt|;
name|int
name|chname
index|[
literal|22
index|]
decl_stmt|;
name|int
name|name2
index|[
literal|22
index|]
decl_stmt|;
name|int
name|oid
index|[
literal|22
index|]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|n1
decl_stmt|,
name|n2
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|oidlen
decl_stmt|,
name|namlen
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|max
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|*
name|namelist
operator|=
name|NULL
expr_stmt|;
comment|/* Skip the leading / */
name|strncpy
argument_list|(
name|name
argument_list|,
operator|&
name|dirname
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
operator|&
name|name
index|[
literal|0
index|]
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'/'
condition|)
operator|*
name|s
operator|=
literal|'.'
expr_stmt|;
comment|/* 	 * Resolve the path. 	 */
name|len
operator|=
sizeof|sizeof
argument_list|(
name|oid
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|namlen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|sysctlnametomib
argument_list|(
name|name
argument_list|,
name|oid
argument_list|,
operator|&
name|len
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
name|errno
operator|)
return|;
name|lsname
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Root */
name|lsname
index|[
literal|1
index|]
operator|=
literal|2
expr_stmt|;
comment|/* Get next */
name|memcpy
argument_list|(
name|lsname
operator|+
literal|2
argument_list|,
name|oid
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|n1
operator|=
literal|2
operator|+
name|len
expr_stmt|;
name|oidlen
operator|=
name|len
expr_stmt|;
comment|/* 	 * Setup the return list of dirents. 	 */
name|cnt
operator|=
literal|0
expr_stmt|;
name|max
operator|=
literal|64
expr_stmt|;
name|names
operator|=
name|malloc
argument_list|(
name|max
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|names
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|n2
operator|=
sizeof|sizeof
argument_list|(
name|name2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|lsname
argument_list|,
name|n1
argument_list|,
name|name2
argument_list|,
operator|&
name|n2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
break|break;
goto|goto
name|errout
goto|;
block|}
name|n2
operator|/=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|n2
operator|<
name|oidlen
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oidlen
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name2
index|[
name|i
index|]
operator|!=
name|oid
index|[
name|i
index|]
condition|)
goto|goto
name|out
goto|;
name|chname
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* root */
name|chname
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* oid name */
name|memcpy
argument_list|(
name|chname
operator|+
literal|2
argument_list|,
name|name2
argument_list|,
name|n2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|lsname
operator|+
literal|2
argument_list|,
name|name2
argument_list|,
name|n2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|n1
operator|=
literal|2
operator|+
name|n2
expr_stmt|;
comment|/* 		 * scandir() is not supposed to go deeper than the requested 		 * directory but sysctl also doesn't return a node for 		 * 'subdirectories' so we have to find a file in the subdir 		 * and then truncate the name to report it. 	 	 */
if|if
condition|(
name|n2
operator|>
name|oidlen
operator|+
literal|1
condition|)
block|{
comment|/* Skip to the next name after this one. */
name|n1
operator|=
literal|2
operator|+
name|oidlen
operator|+
literal|1
expr_stmt|;
name|lsname
index|[
name|n1
operator|-
literal|1
index|]
operator|++
expr_stmt|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|chname
argument_list|,
name|n2
operator|+
literal|2
argument_list|,
name|name
argument_list|,
operator|&
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|errout
goto|;
if|if
condition|(
name|len
operator|<=
literal|0
operator|||
name|len
operator|<
name|namlen
condition|)
goto|goto
name|out
goto|;
name|s
operator|=
name|name
operator|+
name|namlen
expr_stmt|;
comment|/* Just keep the first level name. */
if|if
condition|(
name|strchr
argument_list|(
name|s
argument_list|,
literal|'.'
argument_list|)
condition|)
operator|*
name|strchr
argument_list|(
name|s
argument_list|,
literal|'.'
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
expr_stmt|;
name|dp
operator|=
name|malloc
argument_list|(
name|DIRECTSIZ
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|=
name|DIRECTSIZ
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_namlen
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|dp
operator|->
name|d_name
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|select
operator|&&
operator|!
name|select
argument_list|(
name|dp
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cnt
operator|==
name|max
condition|)
block|{
name|max
operator|*=
literal|2
expr_stmt|;
name|names2
operator|=
name|realloc
argument_list|(
name|names
argument_list|,
name|max
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|names2
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
name|free
argument_list|(
name|dp
argument_list|)
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|names
operator|=
name|names2
expr_stmt|;
block|}
name|names
index|[
name|cnt
operator|++
index|]
operator|=
name|dp
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|cnt
operator|&&
name|compar
condition|)
name|qsort
argument_list|(
name|names
argument_list|,
name|cnt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dirent
operator|*
argument_list|)
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|compar
argument_list|)
expr_stmt|;
operator|*
name|namelist
operator|=
name|names
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
name|errout
label|:
name|err
operator|=
name|errno
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|names
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|err
operator|)
return|;
block|}
end_function

end_unit

