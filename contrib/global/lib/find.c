begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1996, 1997, 1998 Shigio Yamaguchi. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Shigio Yamaguchi.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	find.c					1-May-98  *  */
end_comment

begin_comment
comment|/*  * USEFIND	use find(1) to traverse directory tree.  *		Otherwise, use dirent(3) library.  */
end_comment

begin_define
define|#
directive|define
name|USEFIND
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|USEFIND
end_ifndef

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|BSD4_4
end_ifndef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"die.h"
end_include

begin_include
include|#
directive|include
file|"find.h"
end_include

begin_include
include|#
directive|include
file|"gparam.h"
end_include

begin_include
include|#
directive|include
file|"locatestring.h"
end_include

begin_include
include|#
directive|include
file|"makepath.h"
end_include

begin_include
include|#
directive|include
file|"strbuf.h"
end_include

begin_comment
comment|/*  * usage of findxxx()  *  *	findopen(db);  *	while (path = findread(&length)) {  *		...  *	}  *	findclose();  *  */
end_comment

begin_decl_stmt
specifier|static
name|regex_t
name|skip_area
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regex_t
modifier|*
name|skip
init|=
operator|&
name|skip_area
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|opened
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trim
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * trim: remove blanks and '\'.  */
end_comment

begin_function
specifier|static
name|void
name|trim
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|s
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
operator|&&
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
condition|)
name|s
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
name|s
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USEFIND
end_ifdef

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* find command version							*/
end_comment

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|ip
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|findopen
parameter_list|()
block|{
name|char
modifier|*
name|findcom
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|STRBUF
modifier|*
name|sb
decl_stmt|;
name|char
modifier|*
name|sufflist
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|skiplist
init|=
name|NULL
decl_stmt|;
name|assert
argument_list|(
name|opened
operator|==
literal|0
argument_list|)
expr_stmt|;
name|opened
operator|=
literal|1
expr_stmt|;
name|sb
operator|=
name|stropen
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|getconfs
argument_list|(
literal|"suffixes"
argument_list|,
name|sb
argument_list|)
condition|)
name|die
argument_list|(
literal|"cannot get suffixes data."
argument_list|)
expr_stmt|;
name|sufflist
operator|=
name|strdup
argument_list|(
name|strvalue
argument_list|(
name|sb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sufflist
condition|)
name|die
argument_list|(
literal|"short of memory."
argument_list|)
expr_stmt|;
name|trim
argument_list|(
name|sufflist
argument_list|)
expr_stmt|;
name|strstart
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|getconfs
argument_list|(
literal|"skip"
argument_list|,
name|sb
argument_list|)
condition|)
block|{
name|skiplist
operator|=
name|strdup
argument_list|(
name|strvalue
argument_list|(
name|sb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skiplist
condition|)
name|die
argument_list|(
literal|"short of memory."
argument_list|)
expr_stmt|;
name|trim
argument_list|(
name|skiplist
argument_list|)
expr_stmt|;
block|}
name|strstart
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|strputs
argument_list|(
name|sb
argument_list|,
literal|"find . \\( -type f -o -type l \\) \\("
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|sufflist
init|;
name|p
condition|;
control|)
block|{
name|char
modifier|*
name|suff
init|=
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|locatestring
argument_list|(
name|p
argument_list|,
literal|","
argument_list|,
name|MATCH_FIRST
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|strputs
argument_list|(
name|sb
argument_list|,
literal|" -name '*."
argument_list|)
expr_stmt|;
name|strputs
argument_list|(
name|sb
argument_list|,
name|suff
argument_list|)
expr_stmt|;
name|strputs
argument_list|(
name|sb
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|strputs
argument_list|(
name|sb
argument_list|,
literal|" -o"
argument_list|)
expr_stmt|;
block|}
name|strputs
argument_list|(
name|sb
argument_list|,
literal|" \\) -print"
argument_list|)
expr_stmt|;
name|findcom
operator|=
name|strvalue
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|skiplist
condition|)
block|{
name|char
modifier|*
name|reg
decl_stmt|;
name|STRBUF
modifier|*
name|sbb
init|=
name|stropen
argument_list|()
decl_stmt|;
comment|/* 		 * construct regular expression. 		 */
name|strputc
argument_list|(
name|sbb
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
comment|/* ) */
for|for
control|(
name|p
operator|=
name|skiplist
init|;
name|p
condition|;
control|)
block|{
name|char
modifier|*
name|skipf
init|=
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|locatestring
argument_list|(
name|p
argument_list|,
literal|","
argument_list|,
name|MATCH_FIRST
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|strputc
argument_list|(
name|sbb
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|skipf
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'.'
condition|)
name|strputc
argument_list|(
name|sbb
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
name|strputc
argument_list|(
name|sbb
argument_list|,
operator|*
name|q
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|(
name|q
operator|-
literal|1
operator|)
operator|!=
literal|'/'
condition|)
name|strputc
argument_list|(
name|sbb
argument_list|,
literal|'$'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|strputc
argument_list|(
name|sbb
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
block|}
name|strputc
argument_list|(
name|sbb
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
name|reg
operator|=
name|strvalue
argument_list|(
name|sbb
argument_list|)
expr_stmt|;
comment|/* 		 * compile regular expression. 		 */
if|if
condition|(
name|regcomp
argument_list|(
name|skip
argument_list|,
name|reg
argument_list|,
name|REG_EXTENDED
operator||
name|REG_NEWLINE
argument_list|)
operator|!=
literal|0
condition|)
name|die
argument_list|(
literal|"cannot compile regular expression."
argument_list|)
expr_stmt|;
name|strclose
argument_list|(
name|sbb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|skip
operator|=
operator|(
name|regex_t
operator|*
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|ip
operator|=
name|popen
argument_list|(
name|findcom
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
name|die
argument_list|(
literal|"cannot execute find."
argument_list|)
expr_stmt|;
name|strclose
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sufflist
condition|)
name|free
argument_list|(
name|sufflist
argument_list|)
expr_stmt|;
if|if
condition|(
name|skiplist
condition|)
name|free
argument_list|(
name|skiplist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|findread
parameter_list|(
name|length
parameter_list|)
name|int
modifier|*
name|length
decl_stmt|;
block|{
specifier|static
name|char
name|path
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|assert
argument_list|(
name|opened
operator|==
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|path
argument_list|,
name|MAXPATHLEN
argument_list|,
name|ip
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|skip
operator|||
name|regexec
argument_list|(
name|skip
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * chop(path) 			 */
name|p
operator|=
name|path
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|die
argument_list|(
literal|"output of find(1) is wrong (findread)."
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|length
condition|)
operator|*
name|length
operator|=
name|p
operator|-
name|path
expr_stmt|;
return|return
name|path
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|findclose
parameter_list|(
name|void
parameter_list|)
block|{
name|assert
argument_list|(
name|opened
operator|==
literal|1
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|opened
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* USEFIND */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* dirent version findxxx()						*/
end_comment

begin_comment
comment|/*----------------------------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|STACKSIZE
value|50
end_define

begin_decl_stmt
specifier|static
name|char
name|dir
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* directory path */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|STRBUF
modifier|*
name|sb
decl_stmt|;
name|char
modifier|*
name|dirp
decl_stmt|,
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|p
decl_stmt|;
block|}
name|stack
index|[
name|STACKSIZE
index|]
struct|,
modifier|*
name|topp
struct|,
modifier|*
name|curp
struct|;
end_struct

begin_comment
comment|/* stack */
end_comment

begin_decl_stmt
specifier|static
name|regex_t
name|suff_area
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regex_t
modifier|*
name|suff
init|=
operator|&
name|suff_area
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|getdirs
parameter_list|(
name|dir
parameter_list|,
name|sb
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|STRBUF
modifier|*
name|sb
decl_stmt|;
block|{
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
ifndef|#
directive|ifndef
name|BSD4_4
name|struct
name|stat
name|st
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|dir
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|BSD4_4
if|if
condition|(
name|dp
operator|->
name|d_namlen
operator|==
literal|1
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_namlen
operator|==
literal|2
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|DT_DIR
condition|)
name|strputc
argument_list|(
name|sb
argument_list|,
literal|'d'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|DT_REG
condition|)
name|strputc
argument_list|(
name|sb
argument_list|,
literal|'f'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|DT_LNK
condition|)
name|strputc
argument_list|(
name|sb
argument_list|,
literal|'l'
argument_list|)
expr_stmt|;
else|else
name|strputc
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|strnputs
argument_list|(
name|sb
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
operator|(
name|int
operator|)
name|dp
operator|->
name|d_namlen
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot stat '%s'. (Ignored)\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|strputc
argument_list|(
name|sb
argument_list|,
literal|'d'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|strputc
argument_list|(
name|sb
argument_list|,
literal|'f'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|S_ISLNK
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|strputc
argument_list|(
name|sb
argument_list|,
literal|'l'
argument_list|)
expr_stmt|;
else|else
name|strputc
argument_list|(
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|strputs
argument_list|(
name|sb
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD4_4 */
name|strputc
argument_list|(
name|sb
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|findopen
parameter_list|()
block|{
name|STRBUF
modifier|*
name|sb
init|=
name|stropen
argument_list|()
decl_stmt|;
name|char
modifier|*
name|sufflist
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|skiplist
init|=
name|NULL
decl_stmt|;
name|assert
argument_list|(
name|opened
operator|==
literal|0
argument_list|)
expr_stmt|;
name|opened
operator|=
literal|1
expr_stmt|;
comment|/* 	 * setup stack. 	 */
name|curp
operator|=
operator|&
name|stack
index|[
literal|0
index|]
expr_stmt|;
name|topp
operator|=
name|curp
operator|+
name|STACKSIZE
expr_stmt|;
name|strcpy
argument_list|(
name|dir
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|curp
operator|->
name|dirp
operator|=
name|dir
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|curp
operator|->
name|sb
operator|=
name|stropen
argument_list|()
expr_stmt|;
if|if
condition|(
name|getdirs
argument_list|(
name|dir
argument_list|,
name|curp
operator|->
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|"cannot open '.' directory."
argument_list|)
expr_stmt|;
name|curp
operator|->
name|start
operator|=
name|curp
operator|->
name|p
operator|=
name|strvalue
argument_list|(
name|curp
operator|->
name|sb
argument_list|)
expr_stmt|;
name|curp
operator|->
name|end
operator|=
name|curp
operator|->
name|start
operator|+
name|strbuflen
argument_list|(
name|curp
operator|->
name|sb
argument_list|)
expr_stmt|;
comment|/* 	 * preparing regular expression. 	 */
name|strstart
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getconfs
argument_list|(
literal|"suffixes"
argument_list|,
name|sb
argument_list|)
condition|)
name|die
argument_list|(
literal|"cannot get suffixes data."
argument_list|)
expr_stmt|;
name|sufflist
operator|=
name|strdup
argument_list|(
name|strvalue
argument_list|(
name|sb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sufflist
condition|)
name|die
argument_list|(
literal|"short of memory."
argument_list|)
expr_stmt|;
name|trim
argument_list|(
name|sufflist
argument_list|)
expr_stmt|;
name|strstart
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|getconfs
argument_list|(
literal|"skip"
argument_list|,
name|sb
argument_list|)
condition|)
block|{
name|skiplist
operator|=
name|strdup
argument_list|(
name|strvalue
argument_list|(
name|sb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skiplist
condition|)
name|die
argument_list|(
literal|"short of memory."
argument_list|)
expr_stmt|;
name|trim
argument_list|(
name|skiplist
argument_list|)
expr_stmt|;
block|}
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|strstart
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|strputc
argument_list|(
name|sb
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
comment|/* ) */
for|for
control|(
name|p
operator|=
name|sufflist
init|;
name|p
condition|;
control|)
block|{
name|char
modifier|*
name|suffp
init|=
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|locatestring
argument_list|(
name|p
argument_list|,
literal|","
argument_list|,
name|MATCH_FIRST
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|strputs
argument_list|(
name|sb
argument_list|,
literal|"\\."
argument_list|)
expr_stmt|;
name|strputs
argument_list|(
name|sb
argument_list|,
name|suffp
argument_list|)
expr_stmt|;
name|strputc
argument_list|(
name|sb
argument_list|,
literal|'$'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|strputc
argument_list|(
name|sb
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
block|}
name|strputc
argument_list|(
name|sb
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
comment|/* 		 * compile regular expression. 		 */
if|if
condition|(
name|regcomp
argument_list|(
name|suff
argument_list|,
name|strvalue
argument_list|(
name|sb
argument_list|)
argument_list|,
name|REG_EXTENDED
argument_list|)
operator|!=
literal|0
condition|)
name|die
argument_list|(
literal|"cannot compile regular expression."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|skiplist
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* 		 * construct regular expression. 		 */
name|strstart
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|strputc
argument_list|(
name|sb
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
comment|/* ) */
for|for
control|(
name|p
operator|=
name|skiplist
init|;
name|p
condition|;
control|)
block|{
name|char
modifier|*
name|skipf
init|=
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|locatestring
argument_list|(
name|p
argument_list|,
literal|","
argument_list|,
name|MATCH_FIRST
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|strputc
argument_list|(
name|sb
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|skipf
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'.'
condition|)
name|strputc
argument_list|(
name|sb
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
name|strputc
argument_list|(
name|sb
argument_list|,
operator|*
name|q
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|(
name|q
operator|-
literal|1
operator|)
operator|!=
literal|'/'
condition|)
name|strputc
argument_list|(
name|sb
argument_list|,
literal|'$'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|strputc
argument_list|(
name|sb
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
block|}
name|strputc
argument_list|(
name|sb
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
comment|/* 		 * compile regular expression. 		 */
if|if
condition|(
name|regcomp
argument_list|(
name|skip
argument_list|,
name|strvalue
argument_list|(
name|sb
argument_list|)
argument_list|,
name|REG_EXTENDED
argument_list|)
operator|!=
literal|0
condition|)
name|die
argument_list|(
literal|"cannot compile regular expression."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|skip
operator|=
operator|(
name|regex_t
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|strclose
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sufflist
condition|)
name|free
argument_list|(
name|sufflist
argument_list|)
expr_stmt|;
if|if
condition|(
name|skiplist
condition|)
name|free
argument_list|(
name|skiplist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|findread
parameter_list|(
name|length
parameter_list|)
name|int
modifier|*
name|length
decl_stmt|;
block|{
specifier|static
name|char
name|val
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|curp
operator|->
name|p
operator|<
name|curp
operator|->
name|end
condition|)
block|{
name|char
name|type
init|=
operator|*
operator|(
name|curp
operator|->
name|p
operator|)
decl_stmt|;
name|char
modifier|*
name|unit
init|=
name|curp
operator|->
name|p
operator|+
literal|1
decl_stmt|;
name|curp
operator|->
name|p
operator|+=
name|strlen
argument_list|(
name|curp
operator|->
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|'f'
operator|||
name|type
operator|==
literal|'l'
condition|)
block|{
name|char
modifier|*
name|path
init|=
name|makepath
argument_list|(
name|dir
argument_list|,
name|unit
argument_list|)
decl_stmt|;
if|if
condition|(
name|regexec
argument_list|(
name|suff
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|skip
operator|&&
name|regexec
argument_list|(
name|skip
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|strcpy
argument_list|(
name|val
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
if|if
condition|(
name|type
operator|==
literal|'d'
condition|)
block|{
name|STRBUF
modifier|*
name|sb
init|=
name|stropen
argument_list|()
decl_stmt|;
name|char
modifier|*
name|dirp
init|=
name|curp
operator|->
name|dirp
decl_stmt|;
name|strcat
argument_list|(
name|dirp
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dirp
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|getdirs
argument_list|(
name|dir
argument_list|,
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot open directory '%s'. (Ignored)\n"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|strclose
argument_list|(
name|sb
argument_list|)
expr_stmt|;
operator|*
operator|(
name|curp
operator|->
name|dirp
operator|)
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* 				 * Push stack. 				 */
if|if
condition|(
operator|++
name|curp
operator|>=
name|topp
condition|)
name|die
argument_list|(
literal|"directory stack over flow."
argument_list|)
expr_stmt|;
name|curp
operator|->
name|dirp
operator|=
name|dirp
operator|+
name|strlen
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|curp
operator|->
name|sb
operator|=
name|sb
expr_stmt|;
name|curp
operator|->
name|start
operator|=
name|curp
operator|->
name|p
operator|=
name|strvalue
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|curp
operator|->
name|end
operator|=
name|curp
operator|->
name|start
operator|+
name|strbuflen
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
block|}
name|strclose
argument_list|(
name|curp
operator|->
name|sb
argument_list|)
expr_stmt|;
name|curp
operator|->
name|sb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|curp
operator|==
operator|&
name|stack
index|[
literal|0
index|]
condition|)
break|break;
comment|/* 		 * Pop stack. 		 */
name|curp
operator|--
expr_stmt|;
operator|*
operator|(
name|curp
operator|->
name|dirp
operator|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|findclose
parameter_list|(
name|void
parameter_list|)
block|{
name|assert
argument_list|(
name|opened
operator|==
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|curp
operator|=
operator|&
name|stack
index|[
literal|0
index|]
init|;
name|curp
operator|<
name|topp
condition|;
name|curp
operator|++
control|)
if|if
condition|(
name|curp
operator|->
name|sb
operator|!=
name|NULL
condition|)
name|strclose
argument_list|(
name|curp
operator|->
name|sb
argument_list|)
expr_stmt|;
else|else
break|break;
name|opened
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !USEFIND */
end_comment

end_unit

