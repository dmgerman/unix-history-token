begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Interface between the opcode library and its callers.     Copyright 2001 Free Software Foundation, Inc.        This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.        Written by Cygnus Support, 1993.     The opcode library (libopcodes.a) provides instruction decoders for    a large variety of instruction sets, callable with an identical    interface, for making instruction-processing programs more independent    of the instruction set being processed.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DIS_ASM_H
end_ifndef

begin_define
define|#
directive|define
name|DIS_ASM_H
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
include|#
directive|include
file|<stdio.h>
include|#
directive|include
file|"bfd.h"
typedef|typedef
name|int
argument_list|(
argument|*fprintf_ftype
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
expr_stmt|;
enum|enum
name|dis_insn_type
block|{
name|dis_noninsn
block|,
comment|/* Not a valid instruction */
name|dis_nonbranch
block|,
comment|/* Not a branch instruction */
name|dis_branch
block|,
comment|/* Unconditional branch */
name|dis_condbranch
block|,
comment|/* Conditional branch */
name|dis_jsr
block|,
comment|/* Jump to subroutine */
name|dis_condjsr
block|,
comment|/* Conditional jump to subroutine */
name|dis_dref
block|,
comment|/* Data reference instruction */
name|dis_dref2
comment|/* Two data references in instruction */
block|}
enum|;
comment|/* This struct is passed into the instruction decoding routine,     and is passed back out into each callback.  The various fields are used    for conveying information from your main routine into your callbacks,    for passing information into the instruction decoders (such as the    addresses of the callback functions), or for passing information    back from the instruction decoders to their callers.     It must be initialized before it is first passed; this can be done    by hand, or using one of the initialization macros below.  */
typedef|typedef
struct|struct
name|disassemble_info
block|{
name|fprintf_ftype
name|fprintf_func
decl_stmt|;
name|PTR
name|stream
decl_stmt|;
name|PTR
name|application_data
decl_stmt|;
comment|/* Target description.  We could replace this with a pointer to the bfd,      but that would require one.  There currently isn't any such requirement      so to avoid introducing one we record these explicitly.  */
comment|/* The bfd_flavour.  This can be bfd_target_unknown_flavour.  */
name|enum
name|bfd_flavour
name|flavour
decl_stmt|;
comment|/* The bfd_arch value.  */
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
comment|/* The bfd_mach value.  */
name|unsigned
name|long
name|mach
decl_stmt|;
comment|/* Endianness (for bi-endian cpus).  Mono-endian cpus can ignore this.  */
name|enum
name|bfd_endian
name|endian
decl_stmt|;
comment|/* Some targets need information about the current section to accurately      display insns.  If this is NULL, the target disassembler function      will have to make its best guess.  */
name|asection
modifier|*
name|section
decl_stmt|;
comment|/* An array of pointers to symbols either at the location being disassembled      or at the start of the function being disassembled.  The array is sorted      so that the first symbol is intended to be the one used.  The others are      present for any misc. purposes.  This is not set reliably, but if it is      not NULL, it is correct.  */
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
comment|/* Number of symbols in array.  */
name|int
name|num_symbols
decl_stmt|;
comment|/* For use by the disassembler.      The top 16 bits are reserved for public use (and are documented here).      The bottom 16 bits are for the internal use of the disassembler.  */
name|unsigned
name|long
name|flags
decl_stmt|;
define|#
directive|define
name|INSN_HAS_RELOC
value|0x80000000
name|PTR
name|private_data
decl_stmt|;
comment|/* Function used to get bytes to disassemble.  MEMADDR is the      address of the stuff to be disassembled, MYADDR is the address to      put the bytes in, and LENGTH is the number of bytes to read.      INFO is a pointer to this struct.      Returns an errno value or 0 for success.  */
name|int
argument_list|(
argument|*read_memory_func
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
name|memaddr
operator|,
name|bfd_byte
operator|*
name|myaddr
operator|,
name|unsigned
name|int
name|length
operator|,
expr|struct
name|disassemble_info
operator|*
name|info
operator|)
argument_list|)
expr_stmt|;
comment|/* Function which should be called if we get an error that we can't      recover from.  STATUS is the errno value from read_memory_func and      MEMADDR is the address that we were trying to read.  INFO is a      pointer to this struct.  */
name|void
argument_list|(
argument|*memory_error_func
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
name|status
operator|,
name|bfd_vma
name|memaddr
operator|,
expr|struct
name|disassemble_info
operator|*
name|info
operator|)
argument_list|)
expr_stmt|;
comment|/* Function called to print ADDR.  */
name|void
argument_list|(
argument|*print_address_func
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
name|addr
operator|,
expr|struct
name|disassemble_info
operator|*
name|info
operator|)
argument_list|)
expr_stmt|;
comment|/* Function called to determine if there is a symbol at the given ADDR.      If there is, the function returns 1, otherwise it returns 0.      This is used by ports which support an overlay manager where      the overlay number is held in the top part of an address.  In      some circumstances we want to include the overlay number in the      address, (normally because there is a symbol associated with      that address), but sometimes we want to mask out the overlay bits.  */
name|int
argument_list|(
argument|* symbol_at_address_func
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
name|addr
operator|,
expr|struct
name|disassemble_info
operator|*
name|info
operator|)
argument_list|)
expr_stmt|;
comment|/* These are for buffer_read_memory.  */
name|bfd_byte
modifier|*
name|buffer
decl_stmt|;
name|bfd_vma
name|buffer_vma
decl_stmt|;
name|unsigned
name|int
name|buffer_length
decl_stmt|;
comment|/* This variable may be set by the instruction decoder.  It suggests       the number of bytes objdump should display on a single line.  If       the instruction decoder sets this, it should always set it to       the same value in order to get reasonable looking output.  */
name|int
name|bytes_per_line
decl_stmt|;
comment|/* the next two variables control the way objdump displays the raw data */
comment|/* For example, if bytes_per_line is 8 and bytes_per_chunk is 4, the */
comment|/* output will look like this:      00:   00000000 00000000      with the chunks displayed according to "display_endian". */
name|int
name|bytes_per_chunk
decl_stmt|;
name|enum
name|bfd_endian
name|display_endian
decl_stmt|;
comment|/* Number of octets per incremented target address       Normally one, but some DSPs have byte sizes of 16 or 32 bits    */
name|unsigned
name|int
name|octets_per_byte
decl_stmt|;
comment|/* Results from instruction decoders.  Not all decoders yet support      this information.  This info is set each time an instruction is      decoded, and is only valid for the last such instruction.       To determine whether this decoder supports this information, set      insn_info_valid to 0, decode an instruction, then check it.  */
name|char
name|insn_info_valid
decl_stmt|;
comment|/* Branch info has been set. */
name|char
name|branch_delay_insns
decl_stmt|;
comment|/* How many sequential insn's will run before 				   a branch takes effect.  (0 = normal) */
name|char
name|data_size
decl_stmt|;
comment|/* Size of data reference in insn, in bytes */
name|enum
name|dis_insn_type
name|insn_type
decl_stmt|;
comment|/* Type of instruction */
name|bfd_vma
name|target
decl_stmt|;
comment|/* Target address of branch or dref, if known; 				   zero if unknown.  */
name|bfd_vma
name|target2
decl_stmt|;
comment|/* Second target address for dref2 */
comment|/* Command line options specific to the target disassembler.  */
name|char
modifier|*
name|disassembler_options
decl_stmt|;
block|}
name|disassemble_info
typedef|;
comment|/* Standard disassemblers.  Disassemble one instruction at the given    target address.  Return number of bytes processed.  */
typedef|typedef
name|int
argument_list|(
argument|*disassembler_ftype
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
expr_stmt|;
specifier|extern
name|int
name|print_insn_big_mips
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_little_mips
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_i386_att
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_i386_intel
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_ia64
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_i370
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_m68hc11
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_m68hc12
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_m68k
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_z8001
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_z8002
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_h8300
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_h8300h
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_h8300s
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_h8500
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_alpha
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|disassembler_ftype
name|arc_get_disassembler
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_big_arm
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_little_arm
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_sparc
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_big_a29k
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_little_a29k
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_i860
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_i960
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_sh
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_shl
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_hppa
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_fr30
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_m32r
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_m88k
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_mcore
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_mn10200
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_mn10300
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_ns32k
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_big_powerpc
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_little_powerpc
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_rs6000
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_w65
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|disassembler_ftype
name|cris_get_disassembler
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_d10v
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_d30v
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_v850
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_tic30
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_vax
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_tic54x
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_tic80
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_pj
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|print_insn_avr
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|print_arm_disassembler_options
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|parse_arm_disassembler_option
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|get_arm_regname_num_options
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|set_arm_regname_option
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|get_arm_regnames
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Fetch the disassembler for a given BFD, if that support is available.  */
specifier|extern
name|disassembler_ftype
name|disassembler
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Document any target specific options available from the disassembler.  */
specifier|extern
name|void
name|disassembler_usage
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* This block of definitions is for particular callers who read instructions    into a buffer before calling the instruction decoder.  */
comment|/* Here is a function which callers may wish to use for read_memory_func.    It gets bytes from a buffer.  */
specifier|extern
name|int
name|buffer_read_memory
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|bfd_byte
operator|*
operator|,
name|unsigned
name|int
operator|,
expr|struct
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* This function goes with buffer_read_memory.    It prints a message using info->fprintf_func and info->stream.  */
specifier|extern
name|void
name|perror_memory
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|bfd_vma
operator|,
expr|struct
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Just print the address in hex.  This is included for completeness even    though both GDB and objdump provide their own (to print symbolic    addresses).  */
specifier|extern
name|void
name|generic_print_address
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
expr|struct
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Always true.  */
specifier|extern
name|int
name|generic_symbol_at_address
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
expr|struct
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Macro to initialize a disassemble_info struct.  This should be called    by all applications creating such a struct.  */
define|#
directive|define
name|INIT_DISASSEMBLE_INFO
parameter_list|(
name|INFO
parameter_list|,
name|STREAM
parameter_list|,
name|FPRINTF_FUNC
parameter_list|)
define|\
value|(INFO).flavour = bfd_target_unknown_flavour, \   (INFO).arch = bfd_arch_unknown, \   (INFO).mach = 0, \   (INFO).endian = BFD_ENDIAN_UNKNOWN, \   (INFO).octets_per_byte = 1, \   INIT_DISASSEMBLE_INFO_NO_ARCH(INFO, STREAM, FPRINTF_FUNC)
comment|/* Call this macro to initialize only the internal variables for the    disassembler.  Architecture dependent things such as byte order, or machine    variant are not touched by this macro.  This makes things much easier for    GDB which must initialize these things separately.  */
define|#
directive|define
name|INIT_DISASSEMBLE_INFO_NO_ARCH
parameter_list|(
name|INFO
parameter_list|,
name|STREAM
parameter_list|,
name|FPRINTF_FUNC
parameter_list|)
define|\
value|(INFO).fprintf_func = (fprintf_ftype)(FPRINTF_FUNC), \   (INFO).stream = (PTR)(STREAM), \   (INFO).section = NULL, \   (INFO).symbols = NULL, \   (INFO).num_symbols = 0, \   (INFO).private_data = NULL, \   (INFO).buffer = NULL, \   (INFO).buffer_vma = 0, \   (INFO).buffer_length = 0, \   (INFO).read_memory_func = buffer_read_memory, \   (INFO).memory_error_func = perror_memory, \   (INFO).print_address_func = generic_print_address, \   (INFO).symbol_at_address_func = generic_symbol_at_address, \   (INFO).flags = 0, \   (INFO).bytes_per_line = 0, \   (INFO).bytes_per_chunk = 0, \   (INFO).display_endian = BFD_ENDIAN_UNKNOWN, \   (INFO).insn_info_valid = 0
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (DIS_ASM_H) */
end_comment

end_unit

