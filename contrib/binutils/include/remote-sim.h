begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This file defines the interface between the simulator and gdb.    Copyright 1993, 1994, 1996, 1997, 1998, 2000    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REMOTE_SIM_H
argument_list|)
end_if

begin_define
define|#
directive|define
name|REMOTE_SIM_H
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* This file is used when building stand-alone simulators, so isolate this    file from gdb.  */
comment|/* Pick up CORE_ADDR_TYPE if defined (from gdb), otherwise use same value as    gdb does (unsigned int - from defs.h).  */
ifndef|#
directive|ifndef
name|CORE_ADDR_TYPE
typedef|typedef
name|unsigned
name|int
name|SIM_ADDR
typedef|;
else|#
directive|else
typedef|typedef
name|CORE_ADDR_TYPE
name|SIM_ADDR
typedef|;
endif|#
directive|endif
comment|/* Semi-opaque type used as result of sim_open and passed back to all    other routines.  "desc" is short for "descriptor".    It is up to each simulator to define `sim_state'.  */
typedef|typedef
name|struct
name|sim_state
modifier|*
name|SIM_DESC
typedef|;
comment|/* Values for `kind' arg to sim_open.  */
typedef|typedef
enum|enum
block|{
name|SIM_OPEN_STANDALONE
block|,
comment|/* simulator used standalone (run.c) */
name|SIM_OPEN_DEBUG
comment|/* simulator used by debugger (gdb) */
block|}
name|SIM_OPEN_KIND
typedef|;
comment|/* Return codes from various functions.  */
typedef|typedef
enum|enum
block|{
name|SIM_RC_FAIL
init|=
literal|0
block|,
name|SIM_RC_OK
init|=
literal|1
block|,
name|SIM_RC_UNKNOWN_BREAKPOINT
init|=
literal|2
block|,
name|SIM_RC_INSUFFICIENT_RESOURCES
init|=
literal|3
block|,
name|SIM_RC_DUPLICATE_BREAKPOINT
init|=
literal|4
block|}
name|SIM_RC
typedef|;
comment|/* The bfd struct, as an opaque type.  */
struct_decl|struct
name|_bfd
struct_decl|;
comment|/* Main simulator entry points.  */
comment|/* Create a fully initialized simulator instance.     (This function is called when the simulator is selected from the    gdb command line.)     KIND specifies how the simulator shall be used.  Currently there    are only two kinds: stand-alone and debug.     CALLBACK specifies a standard host callback (defined in callback.h).     ABFD, when non NULL, designates a target program.  The program is    not loaded.     ARGV is a standard ARGV pointer such as that passed from the    command line.  The syntax of the argument list is is assumed to be    ``SIM-PROG { SIM-OPTION } [ TARGET-PROGRAM { TARGET-OPTION } ]''.    The trailing TARGET-PROGRAM and args are only valid for a    stand-alone simulator.     On success, the result is a non NULL descriptor that shall be    passed to the other sim_foo functions.  While the simulator    configuration can be parameterized by (in decreasing precedence)    ARGV's SIM-OPTION, ARGV's TARGET-PROGRAM and the ABFD argument, the    successful creation of the simulator shall not dependent on the    presence of any of these arguments/options.     Hardware simulator: The created simulator shall be sufficiently    initialized to handle, with out restrictions any client requests    (including memory reads/writes, register fetch/stores and a    resume).     Process simulator: that process is not created until a call to    sim_create_inferior.  FIXME: What should the state of the simulator    be? */
name|SIM_DESC
name|sim_open
name|PARAMS
argument_list|(
operator|(
name|SIM_OPEN_KIND
name|kind
operator|,
expr|struct
name|host_callback_struct
operator|*
name|callback
operator|,
expr|struct
name|_bfd
operator|*
name|abfd
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
comment|/* Destory a simulator instance.     QUITTING is non-zero if we cannot hang on errors.     This may involve freeing target memory and closing any open files    and mmap'd areas.  You cannot assume sim_kill has already been    called. */
name|void
name|sim_close
name|PARAMS
argument_list|(
operator|(
name|SIM_DESC
name|sd
operator|,
name|int
name|quitting
operator|)
argument_list|)
decl_stmt|;
comment|/* Load program PROG into the simulators memory.     If ABFD is non-NULL, the bfd for the file has already been opened.    The result is a return code indicating success.     Hardware simulator: Normally, each program section is written into    memory according to that sections LMA using physical (direct)    addressing.  The exception being systems, such as PPC/CHRP, which    support more complicated program loaders.  A call to this function    should not effect the state of the processor registers.  Multiple    calls to this function are permitted and have an accumulative    effect.     Process simulator: Calls to this function may be ignored.     FIXME: Most hardware simulators load the image at the VMA using    virtual addressing.     FIXME: For some hardware targets, before a loaded program can be    executed, it requires the manipulation of VM registers and tables.    Such manipulation should probably (?) occure in    sim_create_inferior. */
name|SIM_RC
name|sim_load
name|PARAMS
argument_list|(
operator|(
name|SIM_DESC
name|sd
operator|,
name|char
operator|*
name|prog
operator|,
expr|struct
name|_bfd
operator|*
name|abfd
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
comment|/* Prepare to run the simulated program.     ABFD, if not NULL, provides initial processor state information.    ARGV and ENV, if non NULL, are NULL terminated lists of pointers.     Hardware simulator: This function shall initialize the processor    registers to a known value.  The program counter and possibly stack    pointer shall be set using information obtained from ABFD (or    hardware reset defaults).  ARGV and ENV, dependant on the target    ABI, may be written to memory.     Process simulator: After a call to this function, a new process    instance shall exist. The TEXT, DATA, BSS and stack regions shall    all be initialized, ARGV and ENV shall be written to process    address space (according to the applicable ABI) and the program    counter and stack pointer set accordingly. */
name|SIM_RC
name|sim_create_inferior
name|PARAMS
argument_list|(
operator|(
name|SIM_DESC
name|sd
operator|,
expr|struct
name|_bfd
operator|*
name|abfd
operator|,
name|char
operator|*
operator|*
name|argv
operator|,
name|char
operator|*
operator|*
name|env
operator|)
argument_list|)
decl_stmt|;
comment|/* Fetch LENGTH bytes of the simulated program's memory.  Start fetch    at virtual address MEM and store in BUF.  Result is number of bytes    read, or zero if error.  */
name|int
name|sim_read
name|PARAMS
argument_list|(
operator|(
name|SIM_DESC
name|sd
operator|,
name|SIM_ADDR
name|mem
operator|,
name|unsigned
name|char
operator|*
name|buf
operator|,
name|int
name|length
operator|)
argument_list|)
decl_stmt|;
comment|/* Store LENGTH bytes from BUF into the simulated program's    memory. Store bytes starting at virtual address MEM. Result is    number of bytes write, or zero if error.  */
name|int
name|sim_write
name|PARAMS
argument_list|(
operator|(
name|SIM_DESC
name|sd
operator|,
name|SIM_ADDR
name|mem
operator|,
name|unsigned
name|char
operator|*
name|buf
operator|,
name|int
name|length
operator|)
argument_list|)
decl_stmt|;
comment|/* Fetch register REGNO storing its raw (target endian) value in the    LENGTH byte buffer BUF.  Return the actual size of the register or    zero if REGNO is not applicable.     Legacy implementations ignore LENGTH and always return -1.     If LENGTH does not match the size of REGNO no data is transfered    (the actual register size is still returned). */
name|int
name|sim_fetch_register
name|PARAMS
argument_list|(
operator|(
name|SIM_DESC
name|sd
operator|,
name|int
name|regno
operator|,
name|unsigned
name|char
operator|*
name|buf
operator|,
name|int
name|length
operator|)
argument_list|)
decl_stmt|;
comment|/* Store register REGNO from the raw (target endian) value in BUF.    Return the actual size of the register or zero if REGNO is not    applicable.     Legacy implementations ignore LENGTH and always return -1.     If LENGTH does not match the size of REGNO no data is transfered    (the actual register size is still returned). */
name|int
name|sim_store_register
name|PARAMS
argument_list|(
operator|(
name|SIM_DESC
name|sd
operator|,
name|int
name|regno
operator|,
name|unsigned
name|char
operator|*
name|buf
operator|,
name|int
name|length
operator|)
argument_list|)
decl_stmt|;
comment|/* Print whatever statistics the simulator has collected.     VERBOSE is currently unused and must always be zero.  */
name|void
name|sim_info
name|PARAMS
argument_list|(
operator|(
name|SIM_DESC
name|sd
operator|,
name|int
name|verbose
operator|)
argument_list|)
decl_stmt|;
comment|/* Run (or resume) the simulated program.     STEP, when non-zero indicates that only a single simulator cycle    should be emulated.     SIGGNAL, if non-zero is a (HOST) SIGRC value indicating the type of    event (hardware interrupt, signal) to be delivered to the simulated    program.     Hardware simulator: If the SIGRC value returned by    sim_stop_reason() is passed back to the simulator via SIGGNAL then    the hardware simulator shall correctly deliver the hardware event    indicated by that signal.  If a value of zero is passed in then the    simulation will continue as if there were no outstanding signal.    The effect of any other SIGGNAL value is is implementation    dependant.     Process simulator: If SIGRC is non-zero then the corresponding    signal is delivered to the simulated program and execution is then    continued.  A zero SIGRC value indicates that the program should    continue as normal. */
name|void
name|sim_resume
name|PARAMS
argument_list|(
operator|(
name|SIM_DESC
name|sd
operator|,
name|int
name|step
operator|,
name|int
name|siggnal
operator|)
argument_list|)
decl_stmt|;
comment|/* Asynchronous request to stop the simulation.    A nonzero return indicates that the simulator is able to handle    the request */
name|int
name|sim_stop
name|PARAMS
argument_list|(
operator|(
name|SIM_DESC
name|sd
operator|)
argument_list|)
decl_stmt|;
comment|/* Fetch the REASON why the program stopped.     SIM_EXITED: The program has terminated. SIGRC indicates the target    dependant exit status.     SIM_STOPPED: The program has stopped.  SIGRC uses the host's signal    numbering as a way of identifying the reaon: program interrupted by    user via a sim_stop request (SIGINT); a breakpoint instruction    (SIGTRAP); a completed single step (SIGTRAP); an internal error    condition (SIGABRT); an illegal instruction (SIGILL); Access to an    undefined memory region (SIGSEGV); Mis-aligned memory access    (SIGBUS).  For some signals information in addition to the signal    number may be retained by the simulator (e.g. offending address),    that information is not directly accessable via this interface.     SIM_SIGNALLED: The program has been terminated by a signal. The    simulator has encountered target code that causes the the program    to exit with signal SIGRC.     SIM_RUNNING, SIM_POLLING: The return of one of these values    indicates a problem internal to the simulator. */
enum|enum
name|sim_stop
block|{
name|sim_running
block|,
name|sim_polling
block|,
name|sim_exited
block|,
name|sim_stopped
block|,
name|sim_signalled
block|}
enum|;
name|void
name|sim_stop_reason
name|PARAMS
argument_list|(
operator|(
name|SIM_DESC
name|sd
operator|,
expr|enum
name|sim_stop
operator|*
name|reason
operator|,
name|int
operator|*
name|sigrc
operator|)
argument_list|)
decl_stmt|;
comment|/* Passthru for other commands that the simulator might support.    Simulators should be prepared to deal with any combination of NULL    or empty CMD. */
name|void
name|sim_do_command
name|PARAMS
argument_list|(
operator|(
name|SIM_DESC
name|sd
operator|,
name|char
operator|*
name|cmd
operator|)
argument_list|)
decl_stmt|;
comment|/* Call these functions to set and clear breakpoints at ADDR. */
name|SIM_RC
name|sim_set_breakpoint
name|PARAMS
argument_list|(
operator|(
name|SIM_DESC
name|sd
operator|,
name|SIM_ADDR
name|addr
operator|)
argument_list|)
decl_stmt|;
name|SIM_RC
name|sim_clear_breakpoint
name|PARAMS
argument_list|(
operator|(
name|SIM_DESC
name|sd
operator|,
name|SIM_ADDR
name|addr
operator|)
argument_list|)
decl_stmt|;
name|SIM_RC
name|sim_clear_all_breakpoints
name|PARAMS
argument_list|(
operator|(
name|SIM_DESC
name|sd
operator|)
argument_list|)
decl_stmt|;
comment|/* These functions are used to enable and disable breakpoints. */
name|SIM_RC
name|sim_enable_breakpoint
name|PARAMS
argument_list|(
operator|(
name|SIM_DESC
name|sd
operator|,
name|SIM_ADDR
name|addr
operator|)
argument_list|)
decl_stmt|;
name|SIM_RC
name|sim_disable_breakpoint
name|PARAMS
argument_list|(
operator|(
name|SIM_DESC
name|sd
operator|,
name|SIM_ADDR
name|addr
operator|)
argument_list|)
decl_stmt|;
name|SIM_RC
name|sim_enable_all_breakpoints
name|PARAMS
argument_list|(
operator|(
name|SIM_DESC
name|sd
operator|)
argument_list|)
decl_stmt|;
name|SIM_RC
name|sim_disable_all_breakpoints
name|PARAMS
argument_list|(
operator|(
name|SIM_DESC
name|sd
operator|)
argument_list|)
decl_stmt|;
comment|/* Provide simulator with a default (global) host_callback_struct.    THIS PROCEDURE IS DEPRECIATED.    GDB and NRUN do not use this interface.    This procedure does not take a SIM_DESC argument as it is    used before sim_open. */
name|void
name|sim_set_callbacks
name|PARAMS
argument_list|(
operator|(
expr|struct
name|host_callback_struct
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Set the size of the simulator memory array.    THIS PROCEDURE IS DEPRECIATED.    GDB and NRUN do not use this interface.    This procedure does not take a SIM_DESC argument as it is    used before sim_open. */
name|void
name|sim_size
name|PARAMS
argument_list|(
operator|(
name|int
name|i
operator|)
argument_list|)
decl_stmt|;
comment|/* Single-step simulator with tracing enabled.    THIS PROCEDURE IS DEPRECIATED.    THIS PROCEDURE IS EVEN MORE DEPRECATED THAN SIM_SET_TRACE    GDB and NRUN do not use this interface.    This procedure returns: ``0'' indicating that the simulator should    be continued using sim_trace() calls; ``1'' indicating that the    simulation has finished. */
name|int
name|sim_trace
name|PARAMS
argument_list|(
operator|(
name|SIM_DESC
name|sd
operator|)
argument_list|)
decl_stmt|;
comment|/* Enable tracing.    THIS PROCEDURE IS DEPRECIATED.    GDB and NRUN do not use this interface.    This procedure returns: ``0'' indicating that the simulator should    be continued using sim_trace() calls; ``1'' indicating that the    simulation has finished. */
name|void
name|sim_set_trace
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* Configure the size of the profile buffer.    THIS PROCEDURE IS DEPRECIATED.    GDB and NRUN do not use this interface.    This procedure does not take a SIM_DESC argument as it is    used before sim_open. */
name|void
name|sim_set_profile_size
name|PARAMS
argument_list|(
operator|(
name|int
name|n
operator|)
argument_list|)
decl_stmt|;
comment|/* Kill the running program.    THIS PROCEDURE IS DEPRECIATED.    GDB and NRUN do not use this interface.    This procedure will be replaced as part of the introduction of    multi-cpu simulators. */
name|void
name|sim_kill
name|PARAMS
argument_list|(
operator|(
name|SIM_DESC
name|sd
operator|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined (REMOTE_SIM_H) */
end_comment

end_unit

