begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* An expandable hash tables datatype.      Copyright (C) 1999, 2000 Free Software Foundation, Inc.    Contributed by Vladimir Makarov (vmakarov@cygnus.com).  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This package implements basic hash table functionality.  It is possible    to search for an entry, create an entry and destroy an entry.     Elements in the table are generic pointers.     The size of the table is not fixed; if the occupancy of the table    grows too high the hash table will be expanded.     The abstract data implementation is based on generalized Algorithm D    from Knuth's book "The art of computer programming".  Hash table is    expanded by creation of new hash table and transferring elements from    the old table to the new table.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__HASHTAB_H__
end_ifndef

begin_define
define|#
directive|define
name|__HASHTAB_H__
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* __cplusplus */
include|#
directive|include
file|<ansidecl.h>
comment|/* The type for a hash code.  */
typedef|typedef
name|unsigned
name|int
name|hashval_t
typedef|;
comment|/* Callback function pointer types.  */
comment|/* Calculate hash of a table entry.  */
typedef|typedef
name|hashval_t
argument_list|(
argument|*htab_hash
argument_list|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* Compare a table entry with a possible entry.  The entry already in    the table always comes first, so the second element can be of a    different type (but in this case htab_find and htab_find_slot    cannot be used; instead the variants that accept a hash value    must be used).  */
typedef|typedef
name|int
argument_list|(
argument|*htab_eq
argument_list|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* Cleanup function called whenever a live element is removed from    the hash table.  */
typedef|typedef
name|void
argument_list|(
argument|*htab_del
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* Function called by htab_traverse for each live element.  The first    arg is the slot of the element (which can be passed to htab_clear_slot    if desired), the second arg is the auxiliary pointer handed to    htab_traverse.  Return 1 to continue scan, 0 to stop.  */
typedef|typedef
name|int
argument_list|(
argument|*htab_trav
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
comment|/* Hash tables are of the following type.  The structure    (implementation) of this type is not needed for using the hash    tables.  All work with hash table should be executed only through    functions mentioned below. */
struct|struct
name|htab
block|{
comment|/* Pointer to hash function.  */
name|htab_hash
name|hash_f
decl_stmt|;
comment|/* Pointer to comparison function.  */
name|htab_eq
name|eq_f
decl_stmt|;
comment|/* Pointer to cleanup function.  */
name|htab_del
name|del_f
decl_stmt|;
comment|/* Table itself.  */
name|PTR
modifier|*
name|entries
decl_stmt|;
comment|/* Current size (in entries) of the hash table */
name|size_t
name|size
decl_stmt|;
comment|/* Current number of elements including also deleted elements */
name|size_t
name|n_elements
decl_stmt|;
comment|/* Current number of deleted elements in the table */
name|size_t
name|n_deleted
decl_stmt|;
comment|/* The following member is used for debugging. Its value is number      of all calls of `htab_find_slot' for the hash table. */
name|unsigned
name|int
name|searches
decl_stmt|;
comment|/* The following member is used for debugging.  Its value is number      of collisions fixed for time of work with the hash table. */
name|unsigned
name|int
name|collisions
decl_stmt|;
comment|/* This is non-zero if we are allowed to return NULL for function calls      that allocate memory.  */
name|int
name|return_allocation_failure
decl_stmt|;
block|}
struct|;
typedef|typedef
name|struct
name|htab
modifier|*
name|htab_t
typedef|;
comment|/* An enum saying whether we insert into the hash table or not.  */
enum|enum
name|insert_option
block|{
name|NO_INSERT
block|,
name|INSERT
block|}
enum|;
comment|/* The prototypes of the package functions. */
specifier|extern
name|htab_t
name|htab_create
name|PARAMS
argument_list|(
operator|(
name|size_t
operator|,
name|htab_hash
operator|,
name|htab_eq
operator|,
name|htab_del
operator|)
argument_list|)
decl_stmt|;
comment|/* This function is like htab_create, but may return NULL if memory    allocation fails, and also signals that htab_find_slot_with_hash and    htab_find_slot are allowed to return NULL when inserting.  */
specifier|extern
name|htab_t
name|htab_try_create
name|PARAMS
argument_list|(
operator|(
name|size_t
operator|,
name|htab_hash
operator|,
name|htab_eq
operator|,
name|htab_del
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|htab_delete
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|htab_empty
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|PTR
name|htab_find
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|PTR
modifier|*
name|htab_find_slot
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|,
specifier|const
name|void
operator|*
operator|,
expr|enum
name|insert_option
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|PTR
name|htab_find_with_hash
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|,
specifier|const
name|void
operator|*
operator|,
name|hashval_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|PTR
modifier|*
name|htab_find_slot_with_hash
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|,
specifier|const
name|void
operator|*
operator|,
name|hashval_t
operator|,
expr|enum
name|insert_option
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|htab_clear_slot
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|,
name|void
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|htab_remove_elt
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|htab_traverse
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|,
name|htab_trav
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|size_t
name|htab_size
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|size_t
name|htab_elements
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|double
name|htab_collisions
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|)
argument_list|)
decl_stmt|;
comment|/* A hash function for pointers.  */
specifier|extern
name|htab_hash
name|htab_hash_pointer
decl_stmt|;
comment|/* An equality function for pointers.  */
specifier|extern
name|htab_eq
name|htab_eq_pointer
decl_stmt|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __cplusplus */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __HASHTAB_H */
end_comment

end_unit

