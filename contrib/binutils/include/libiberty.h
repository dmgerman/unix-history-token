begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Function declarations for libiberty.     Copyright 2001 Free Software Foundation, Inc.        Note - certain prototypes declared in this header file are for    functions whoes implementation copyright does not belong to the    FSF.  Those prototypes are present in this file for reference    purposes only and their presence in this file should not construed    as an indication of ownership by the FSF of the implementation of    those functions in any way or form whatsoever.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.        Written by Cygnus Support, 1994.     The libiberty library provides a number of functions which are    missing on some operating systems.  We do not declare those here,    to avoid conflicts with the system header files on operating    systems that do support those functions.  In this file we only    declare those functions which are specific to libiberty.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LIBIBERTY_H
end_ifndef

begin_define
define|#
directive|define
name|LIBIBERTY_H
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
include|#
directive|include
file|"ansidecl.h"
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
comment|/* Get a definition for size_t.  */
include|#
directive|include
file|<stddef.h>
comment|/* Get a definition for va_list.  */
include|#
directive|include
file|<stdarg.h>
endif|#
directive|endif
comment|/* Build an argument vector from a string.  Allocates memory using    malloc.  Use freeargv to free the vector.  */
specifier|extern
name|char
modifier|*
modifier|*
name|buildargv
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
name|ATTRIBUTE_MALLOC
decl_stmt|;
comment|/* Free a vector returned by buildargv.  */
specifier|extern
name|void
name|freeargv
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Duplicate an argument vector. Allocates memory using malloc.  Use    freeargv to free the vector.  */
specifier|extern
name|char
modifier|*
modifier|*
name|dupargv
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
name|ATTRIBUTE_MALLOC
decl_stmt|;
comment|/* Return the last component of a path name.  Note that we can't use a    prototype here because the parameter is declared inconsistently    across different systems, sometimes as "char *" and sometimes as    "const char *" */
comment|/* HAVE_DECL_* is a three-state macro: undefined, 0 or 1.  If it is    undefined, we haven't run the autoconf check so provide the    declaration without arguments.  If it is 0, we checked and failed    to find the declaration so provide a fully prototyped one.  If it    is 1, we found it so don't provide any declaration at all.  */
if|#
directive|if
name|defined
argument_list|(
name|__GNU_LIBRARY__
argument_list|)
operator|||
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN32__
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|HAVE_DECL_BASENAME
argument_list|)
operator|&&
operator|!
name|HAVE_DECL_BASENAME
operator|)
specifier|extern
name|char
modifier|*
name|basename
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
else|#
directive|else
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_DECL_BASENAME
argument_list|)
specifier|extern
name|char
modifier|*
name|basename
parameter_list|()
function_decl|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* A well-defined basename () that is always compiled in.  */
specifier|extern
name|char
modifier|*
name|lbasename
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Concatenate an arbitrary number of strings, up to (char *) NULL.    Allocates memory using xmalloc.  */
specifier|extern
name|char
modifier|*
name|concat
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_MALLOC
decl_stmt|;
comment|/* Check whether two file descriptors refer to the same file.  */
specifier|extern
name|int
name|fdmatch
name|PARAMS
argument_list|(
operator|(
name|int
name|fd1
operator|,
name|int
name|fd2
operator|)
argument_list|)
decl_stmt|;
comment|/* Get the working directory.  The result is cached, so don't call    chdir() between calls to getpwd().  */
specifier|extern
name|char
modifier|*
name|getpwd
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* Get the amount of time the process has run, in microseconds.  */
specifier|extern
name|long
name|get_run_time
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* Choose a temporary directory to use for scratch files.  */
specifier|extern
name|char
modifier|*
name|choose_temp_base
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
name|ATTRIBUTE_MALLOC
decl_stmt|;
comment|/* Return a temporary file name or NULL if unable to create one.  */
specifier|extern
name|char
modifier|*
name|make_temp_file
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
name|ATTRIBUTE_MALLOC
decl_stmt|;
comment|/* Allocate memory filled with spaces.  Allocates using malloc.  */
specifier|extern
specifier|const
name|char
modifier|*
name|spaces
name|PARAMS
argument_list|(
operator|(
name|int
name|count
operator|)
argument_list|)
decl_stmt|;
comment|/* Return the maximum error number for which strerror will return a    string.  */
specifier|extern
name|int
name|errno_max
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* Return the name of an errno value (e.g., strerrno (EINVAL) returns    "EINVAL").  */
specifier|extern
specifier|const
name|char
modifier|*
name|strerrno
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Given the name of an errno value, return the value.  */
specifier|extern
name|int
name|strtoerrno
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* ANSI's strerror(), but more robust.  */
specifier|extern
name|char
modifier|*
name|xstrerror
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Return the maximum signal number for which strsignal will return a    string.  */
specifier|extern
name|int
name|signo_max
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* Return a signal message string for a signal number    (e.g., strsignal (SIGHUP) returns something like "Hangup").  */
comment|/* This is commented out as it can conflict with one in system headers.    We still document its existence though.  */
comment|/*extern const char *strsignal PARAMS ((int));*/
comment|/* Return the name of a signal number (e.g., strsigno (SIGHUP) returns    "SIGHUP").  */
specifier|extern
specifier|const
name|char
modifier|*
name|strsigno
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Given the name of a signal, return its number.  */
specifier|extern
name|int
name|strtosigno
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Register a function to be run by xexit.  Returns 0 on success.  */
specifier|extern
name|int
name|xatexit
name|PARAMS
argument_list|(
operator|(
name|void
argument_list|(
operator|*
name|fn
argument_list|)
argument_list|(
name|void
argument_list|)
operator|)
argument_list|)
decl_stmt|;
comment|/* Exit, calling all the functions registered with xatexit.  */
specifier|extern
name|void
name|xexit
name|PARAMS
argument_list|(
operator|(
name|int
name|status
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
comment|/* Set the program name used by xmalloc.  */
specifier|extern
name|void
name|xmalloc_set_program_name
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
comment|/* Report an allocation failure.  */
specifier|extern
name|void
name|xmalloc_failed
name|PARAMS
argument_list|(
operator|(
name|size_t
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
comment|/* Allocate memory without fail.  If malloc fails, this will print a    message to stderr (using the name set by xmalloc_set_program_name,    if any) and then call xexit.  */
specifier|extern
name|PTR
name|xmalloc
name|PARAMS
argument_list|(
operator|(
name|size_t
operator|)
argument_list|)
name|ATTRIBUTE_MALLOC
decl_stmt|;
comment|/* Reallocate memory without fail.  This works like xmalloc.  Note,    realloc type functions are not suitable for attribute malloc since    they may return the same address across multiple calls. */
specifier|extern
name|PTR
name|xrealloc
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
comment|/* Allocate memory without fail and set it to zero.  This works like    xmalloc.  */
specifier|extern
name|PTR
name|xcalloc
name|PARAMS
argument_list|(
operator|(
name|size_t
operator|,
name|size_t
operator|)
argument_list|)
name|ATTRIBUTE_MALLOC
decl_stmt|;
comment|/* Copy a string into a memory buffer without fail.  */
specifier|extern
name|char
modifier|*
name|xstrdup
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
name|ATTRIBUTE_MALLOC
decl_stmt|;
comment|/* Copy an existing memory buffer to a new memory buffer without fail.  */
specifier|extern
name|PTR
name|xmemdup
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
name|size_t
operator|,
name|size_t
operator|)
argument_list|)
name|ATTRIBUTE_MALLOC
decl_stmt|;
comment|/* hex character manipulation routines */
define|#
directive|define
name|_hex_array_size
value|256
define|#
directive|define
name|_hex_bad
value|99
specifier|extern
name|char
name|_hex_value
index|[
name|_hex_array_size
index|]
decl_stmt|;
specifier|extern
name|void
name|hex_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
define|#
directive|define
name|hex_p
parameter_list|(
name|c
parameter_list|)
value|(hex_value (c) != _hex_bad)
comment|/* If you change this, note well: Some code relies on side effects in    the argument being performed exactly once.  */
define|#
directive|define
name|hex_value
parameter_list|(
name|c
parameter_list|)
value|(_hex_value[(unsigned char) (c)])
comment|/* Definitions used by the pexecute routine.  */
define|#
directive|define
name|PEXECUTE_FIRST
value|1
define|#
directive|define
name|PEXECUTE_LAST
value|2
define|#
directive|define
name|PEXECUTE_ONE
value|(PEXECUTE_FIRST + PEXECUTE_LAST)
define|#
directive|define
name|PEXECUTE_SEARCH
value|4
define|#
directive|define
name|PEXECUTE_VERBOSE
value|8
comment|/* Execute a program.  */
specifier|extern
name|int
name|pexecute
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|char
operator|*
specifier|const
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Wait for pexecute to finish.  */
specifier|extern
name|int
name|pwait
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
comment|/* Like sprintf but provides a pointer to malloc'd storage, which must    be freed by the caller.  */
specifier|extern
name|int
name|asprintf
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF_2
decl_stmt|;
comment|/* Like vsprintf but provides a pointer to malloc'd storage, which    must be freed by the caller.  */
specifier|extern
name|int
name|vasprintf
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
name|ATTRIBUTE_PRINTF
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
decl_stmt|;
define|#
directive|define
name|ARRAY_SIZE
parameter_list|(
name|a
parameter_list|)
value|(sizeof (a) / sizeof ((a)[0]))
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (LIBIBERTY_H) */
end_comment

end_unit

