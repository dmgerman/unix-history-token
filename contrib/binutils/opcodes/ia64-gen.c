begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ia64-gen.c -- Generate a shrunk set of opcode tables    Copyright 1999, 2000, 2001 Free Software Foundation, Inc.    Written by Bob Manson, Cygnus Solutions,<manson@cygnus.com>     This file is part of GDB, GAS, and the GNU binutils.     GDB, GAS, and the GNU binutils are free software; you can redistribute    them and/or modify them under the terms of the GNU General Public    License as published by the Free Software Foundation; either version    2, or (at your option) any later version.     GDB, GAS, and the GNU binutils are distributed in the hope that they    will be useful, but WITHOUT ANY WARRANTY; without even the implied    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See    the GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this file; see the file COPYING.  If not, write to the    Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* While the ia64-opc-* set of opcode tables are easy to maintain,    they waste a tremendous amount of space.  ia64-gen rearranges the    instructions into a directed acyclic graph (DAG) of instruction opcodes and     their possible completers, as well as compacting the set of strings used.       The disassembler table consists of a state machine that does    branching based on the bits of the opcode being disassembled.  The    state encodings have been chosen to minimize the amount of space    required.       The resource table is constructed based on some text dependency tables,     which are also easier to maintain than the final representation.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"ia64-opc.h"
end_include

begin_include
include|#
directive|include
file|"ia64-opc-a.c"
end_include

begin_include
include|#
directive|include
file|"ia64-opc-i.c"
end_include

begin_include
include|#
directive|include
file|"ia64-opc-m.c"
end_include

begin_include
include|#
directive|include
file|"ia64-opc-b.c"
end_include

begin_include
include|#
directive|include
file|"ia64-opc-f.c"
end_include

begin_include
include|#
directive|include
file|"ia64-opc-x.c"
end_include

begin_include
include|#
directive|include
file|"ia64-opc-d.c"
end_include

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|tmalloc
parameter_list|(
name|X
parameter_list|)
value|(X *) xmalloc (sizeof (X))
end_define

begin_comment
comment|/* The main opcode table entry.  Each entry is a unique combination of    name and flags (no two entries in the table compare as being equal    via opcodes_eq). */
end_comment

begin_struct
struct|struct
name|main_entry
block|{
comment|/* The base name of this opcode.  The names of its completers are      appended to it to generate the full instruction name. */
name|struct
name|string_entry
modifier|*
name|name
decl_stmt|;
comment|/* The base opcode entry.  Which one to use is a fairly arbitrary choice;      it uses the first one passed to add_opcode_entry. */
name|struct
name|ia64_opcode
modifier|*
name|opcode
decl_stmt|;
comment|/* The list of completers that can be applied to this opcode. */
name|struct
name|completer_entry
modifier|*
name|completers
decl_stmt|;
comment|/* Next entry in the chain. */
name|struct
name|main_entry
modifier|*
name|next
decl_stmt|;
comment|/* Index in the  main table. */
name|int
name|main_index
decl_stmt|;
block|}
modifier|*
name|maintable
struct|,
modifier|*
modifier|*
name|ordered_table
struct|;
end_struct

begin_decl_stmt
name|int
name|otlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ottotlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|opcode_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The set of possible completers for an opcode. */
end_comment

begin_struct
struct|struct
name|completer_entry
block|{
comment|/* This entry's index in the ia64_completer_table[] array. */
name|int
name|num
decl_stmt|;
comment|/* The name of the completer. */
name|struct
name|string_entry
modifier|*
name|name
decl_stmt|;
comment|/* This entry's parent. */
name|struct
name|completer_entry
modifier|*
name|parent
decl_stmt|;
comment|/* Set if this is a terminal completer (occurs at the end of an      opcode). */
name|int
name|is_terminal
decl_stmt|;
comment|/* An alternative completer. */
name|struct
name|completer_entry
modifier|*
name|alternative
decl_stmt|;
comment|/* Additional completers that can be appended to this one.  */
name|struct
name|completer_entry
modifier|*
name|addl_entries
decl_stmt|;
comment|/* Before compute_completer_bits () is invoked, this contains the actual      instruction opcode for this combination of opcode and completers.      Afterwards, it contains those bits that are different from its      parent opcode. */
name|ia64_insn
name|bits
decl_stmt|;
comment|/* Bits set to 1 correspond to those bits in this completer's opcode      that are different from its parent completer's opcode (or from      the base opcode if the entry is the root of the opcode's completer      list).  This field is filled in by compute_completer_bits (). */
name|ia64_insn
name|mask
decl_stmt|;
comment|/* Index into the opcode dependency list, or -1 if none. */
name|int
name|dependencies
decl_stmt|;
comment|/* Remember the order encountered in the opcode tables.  */
name|int
name|order
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* One entry in the disassembler name table. */
end_comment

begin_struct
struct|struct
name|disent
block|{
comment|/* The index into the ia64_name_dis array for this entry. */
name|int
name|ournum
decl_stmt|;
comment|/* The index into the main_table[] array. */
name|int
name|insn
decl_stmt|;
comment|/* The disassmbly priority of this entry. */
name|int
name|priority
decl_stmt|;
comment|/* The completer_index value for this entry. */
name|int
name|completer_index
decl_stmt|;
comment|/* How many other entries share this decode. */
name|int
name|nextcnt
decl_stmt|;
comment|/* The next entry sharing the same decode. */
name|struct
name|disent
modifier|*
name|nexte
decl_stmt|;
comment|/* The next entry in the name list. */
name|struct
name|disent
modifier|*
name|next_ent
decl_stmt|;
block|}
modifier|*
name|disinsntable
init|=
name|NULL
struct|;
end_struct

begin_comment
comment|/* A state machine that will eventually be used to generate the    disassembler table. */
end_comment

begin_struct
struct|struct
name|bittree
block|{
name|struct
name|disent
modifier|*
name|disent
decl_stmt|;
name|struct
name|bittree
modifier|*
name|bits
index|[
literal|3
index|]
decl_stmt|;
comment|/* 0, 1, and X (don't care) */
name|int
name|bits_to_skip
decl_stmt|;
name|int
name|skip_flag
decl_stmt|;
block|}
modifier|*
name|bittree
struct|;
end_struct

begin_comment
comment|/* The string table contains all opcodes and completers sorted in    alphabetical order.  */
end_comment

begin_comment
comment|/* One entry in the string table. */
end_comment

begin_struct
struct|struct
name|string_entry
block|{
comment|/* The index in the ia64_strings[] array for this entry. */
name|int
name|num
decl_stmt|;
comment|/* And the string. */
name|char
modifier|*
name|s
decl_stmt|;
block|}
modifier|*
modifier|*
name|string_table
init|=
name|NULL
struct|;
end_struct

begin_decl_stmt
name|int
name|strtablen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|strtabtotlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* resource dependency entries */
end_comment

begin_struct
struct|struct
name|rdep
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* resource name */
name|unsigned
name|mode
range|:
literal|2
decl_stmt|,
comment|/* RAW, WAW, or WAR */
name|semantics
range|:
literal|3
decl_stmt|;
comment|/* dependency semantics */
name|char
modifier|*
name|extra
decl_stmt|;
comment|/* additional semantics info */
name|int
name|nchks
decl_stmt|;
name|int
name|total_chks
decl_stmt|;
comment|/* total #of terminal insns */
name|int
modifier|*
name|chks
decl_stmt|;
comment|/* insn classes which read (RAW), write                                        (WAW), or write (WAR) this rsrc */
name|int
modifier|*
name|chknotes
decl_stmt|;
comment|/* dependency notes for each class */
name|int
name|nregs
decl_stmt|;
name|int
name|total_regs
decl_stmt|;
comment|/* total #of terminal insns */
name|int
modifier|*
name|regs
decl_stmt|;
comment|/* insn class which write (RAW), write2                                        (WAW), or read (WAR) this rsrc */
name|int
modifier|*
name|regnotes
decl_stmt|;
comment|/* dependency notes for each class */
name|int
name|waw_special
decl_stmt|;
comment|/* special WAW dependency note */
block|}
modifier|*
modifier|*
name|rdeps
init|=
name|NULL
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|rdepslen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rdepstotlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of all instruction classes */
end_comment

begin_struct
struct|struct
name|iclass
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* instruction class name */
name|int
name|is_class
decl_stmt|;
comment|/* is a class, not a terminal */
name|int
name|nsubs
decl_stmt|;
name|int
modifier|*
name|subs
decl_stmt|;
comment|/* other classes within this class */
name|int
name|nxsubs
decl_stmt|;
name|int
name|xsubs
index|[
literal|4
index|]
decl_stmt|;
comment|/* exclusions */
name|char
modifier|*
name|comment
decl_stmt|;
comment|/* optional comment */
name|int
name|note
decl_stmt|;
comment|/* optional note */
name|int
name|terminal_resolved
decl_stmt|;
comment|/* did we match this with anything? */
name|int
name|orphan
decl_stmt|;
comment|/* detect class orphans */
block|}
modifier|*
modifier|*
name|ics
init|=
name|NULL
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|iclen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ictotlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* an opcode dependency (chk/reg pair of dependency lists) */
end_comment

begin_struct
struct|struct
name|opdep
block|{
name|int
name|chk
decl_stmt|;
comment|/* index into dlists */
name|int
name|reg
decl_stmt|;
comment|/* index into dlists */
block|}
modifier|*
modifier|*
name|opdeps
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|opdeplen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|opdeptotlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a generic list of dependencies w/notes encoded.  these may be shared. */
end_comment

begin_struct
struct|struct
name|deplist
block|{
name|int
name|len
decl_stmt|;
name|unsigned
name|short
modifier|*
name|deps
decl_stmt|;
block|}
modifier|*
modifier|*
name|dlists
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|dlistlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dlisttotlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* add NAME to the resource table, where TYPE is RAW or WAW */
end_comment

begin_function
specifier|static
name|struct
name|rdep
modifier|*
name|insert_resource
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|ia64_dependency_mode
name|type
parameter_list|)
block|{
if|if
condition|(
name|rdepslen
operator|==
name|rdepstotlen
condition|)
block|{
name|rdepstotlen
operator|+=
literal|20
expr_stmt|;
name|rdeps
operator|=
operator|(
expr|struct
name|rdep
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|rdeps
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rdep
operator|*
operator|*
argument_list|)
operator|*
name|rdepstotlen
argument_list|)
expr_stmt|;
block|}
name|rdeps
index|[
name|rdepslen
index|]
operator|=
name|tmalloc
argument_list|(
expr|struct
name|rdep
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rdeps
index|[
name|rdepslen
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rdep
argument_list|)
argument_list|)
expr_stmt|;
name|rdeps
index|[
name|rdepslen
index|]
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|rdeps
index|[
name|rdepslen
index|]
operator|->
name|mode
operator|=
name|type
expr_stmt|;
name|rdeps
index|[
name|rdepslen
index|]
operator|->
name|waw_special
operator|=
literal|0
expr_stmt|;
return|return
name|rdeps
index|[
name|rdepslen
operator|++
index|]
return|;
block|}
end_function

begin_comment
comment|/* are the lists of dependency indexes equivalent? */
end_comment

begin_function
specifier|static
name|int
name|deplist_equals
parameter_list|(
name|struct
name|deplist
modifier|*
name|d1
parameter_list|,
name|struct
name|deplist
modifier|*
name|d2
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|d1
operator|->
name|len
operator|!=
name|d2
operator|->
name|len
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d1
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|d1
operator|->
name|deps
index|[
name|i
index|]
operator|!=
name|d2
operator|->
name|deps
index|[
name|i
index|]
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* add the list of dependencies to the list of dependency lists */
end_comment

begin_function
specifier|static
name|short
name|insert_deplist
parameter_list|(
name|int
name|count
parameter_list|,
name|unsigned
name|short
modifier|*
name|deps
parameter_list|)
block|{
comment|/* sort the list, then see if an equivalent list exists already.      this results in a much smaller set of dependency lists    */
name|struct
name|deplist
modifier|*
name|list
decl_stmt|;
name|char
name|set
index|[
literal|0x10000
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|set
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|set
index|[
name|deps
index|[
name|i
index|]
index|]
operator|=
literal|1
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|set
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|set
index|[
name|i
index|]
condition|)
operator|++
name|count
expr_stmt|;
name|list
operator|=
name|tmalloc
argument_list|(
expr|struct
name|deplist
argument_list|)
expr_stmt|;
name|list
operator|->
name|len
operator|=
name|count
expr_stmt|;
name|list
operator|->
name|deps
operator|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|malloc
argument_list|(
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
operator|*
name|count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|count
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|set
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|set
index|[
name|i
index|]
condition|)
block|{
name|list
operator|->
name|deps
index|[
name|count
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* does this list exist already? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dlistlen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|deplist_equals
argument_list|(
name|list
argument_list|,
name|dlists
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|list
operator|->
name|deps
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
if|if
condition|(
name|dlistlen
operator|==
name|dlisttotlen
condition|)
block|{
name|dlisttotlen
operator|+=
literal|20
expr_stmt|;
name|dlists
operator|=
operator|(
expr|struct
name|deplist
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|dlists
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|deplist
operator|*
operator|*
argument_list|)
operator|*
name|dlisttotlen
argument_list|)
expr_stmt|;
block|}
name|dlists
index|[
name|dlistlen
index|]
operator|=
name|list
expr_stmt|;
return|return
name|dlistlen
operator|++
return|;
block|}
end_function

begin_comment
comment|/* add the given pair of dependency lists to the opcode dependency list */
end_comment

begin_function
specifier|static
name|short
name|insert_dependencies
parameter_list|(
name|int
name|nchks
parameter_list|,
name|unsigned
name|short
modifier|*
name|chks
parameter_list|,
name|int
name|nregs
parameter_list|,
name|unsigned
name|short
modifier|*
name|regs
parameter_list|)
block|{
name|struct
name|opdep
modifier|*
name|pair
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|regind
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|chkind
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|nregs
operator|>
literal|0
condition|)
name|regind
operator|=
name|insert_deplist
argument_list|(
name|nregs
argument_list|,
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|nchks
operator|>
literal|0
condition|)
name|chkind
operator|=
name|insert_deplist
argument_list|(
name|nchks
argument_list|,
name|chks
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opdeplen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|opdeps
index|[
name|i
index|]
operator|->
name|chk
operator|==
name|chkind
operator|&&
name|opdeps
index|[
name|i
index|]
operator|->
name|reg
operator|==
name|regind
condition|)
return|return
name|i
return|;
block|}
name|pair
operator|=
name|tmalloc
argument_list|(
expr|struct
name|opdep
argument_list|)
expr_stmt|;
name|pair
operator|->
name|chk
operator|=
name|chkind
expr_stmt|;
name|pair
operator|->
name|reg
operator|=
name|regind
expr_stmt|;
if|if
condition|(
name|opdeplen
operator|==
name|opdeptotlen
condition|)
block|{
name|opdeptotlen
operator|+=
literal|20
expr_stmt|;
name|opdeps
operator|=
operator|(
expr|struct
name|opdep
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|opdeps
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|opdep
operator|*
operator|*
argument_list|)
operator|*
name|opdeptotlen
argument_list|)
expr_stmt|;
block|}
name|opdeps
index|[
name|opdeplen
index|]
operator|=
name|pair
expr_stmt|;
return|return
name|opdeplen
operator|++
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mark_used
parameter_list|(
name|struct
name|iclass
modifier|*
name|ic
parameter_list|,
name|int
name|clear_terminals
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ic
operator|->
name|orphan
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|clear_terminals
condition|)
name|ic
operator|->
name|terminal_resolved
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ic
operator|->
name|nsubs
condition|;
name|i
operator|++
control|)
block|{
name|mark_used
argument_list|(
name|ics
index|[
name|ic
operator|->
name|subs
index|[
name|i
index|]
index|]
argument_list|,
name|clear_terminals
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ic
operator|->
name|nxsubs
condition|;
name|i
operator|++
control|)
block|{
name|mark_used
argument_list|(
name|ics
index|[
name|ic
operator|->
name|xsubs
index|[
name|i
index|]
index|]
argument_list|,
name|clear_terminals
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* look up an instruction class; if CREATE make a new one if none found;    returns the index into the insn class array */
end_comment

begin_function
specifier|static
name|int
name|fetch_insn_class
parameter_list|(
specifier|const
name|char
modifier|*
name|full_name
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|notestr
decl_stmt|;
name|char
modifier|*
name|xsect
decl_stmt|;
name|char
modifier|*
name|comment
decl_stmt|;
name|int
name|i
decl_stmt|,
name|note
init|=
literal|0
decl_stmt|;
name|int
name|ind
decl_stmt|;
name|int
name|is_class
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|full_name
argument_list|,
literal|"IC:"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|name
operator|=
name|xstrdup
argument_list|(
name|full_name
operator|+
literal|3
argument_list|)
expr_stmt|;
name|is_class
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|name
operator|=
name|xstrdup
argument_list|(
name|full_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|xsect
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'\\'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|is_class
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|comment
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'['
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|is_class
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|notestr
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'+'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|is_class
operator|=
literal|1
expr_stmt|;
comment|/* If it is a composite class, then ignore comments and notes that come after      the '\\', since they don't apply to the part we are decoding now.  */
if|if
condition|(
name|xsect
condition|)
block|{
if|if
condition|(
name|comment
operator|>
name|xsect
condition|)
name|comment
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|notestr
operator|>
name|xsect
condition|)
name|notestr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|notestr
condition|)
block|{
name|char
modifier|*
name|nextnotestr
decl_stmt|;
name|note
operator|=
name|atoi
argument_list|(
name|notestr
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nextnotestr
operator|=
name|strchr
argument_list|(
name|notestr
operator|+
literal|1
argument_list|,
literal|'+'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|notestr
argument_list|,
literal|"+1+13"
argument_list|)
operator|==
literal|0
condition|)
name|note
operator|=
literal|13
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|xsect
operator|||
name|nextnotestr
operator|<
name|xsect
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: multiple note %s not handled\n"
argument_list|,
name|notestr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If it's a composite class, leave the notes and comments in place so that      we have a unique name for the composite class.  Otherwise, we remove      them.  */
if|if
condition|(
operator|!
name|xsect
condition|)
block|{
if|if
condition|(
name|notestr
condition|)
operator|*
name|notestr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|comment
condition|)
operator|*
name|comment
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iclen
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|ics
index|[
name|i
index|]
operator|->
name|name
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|comment
operator|==
name|NULL
operator|&&
name|ics
index|[
name|i
index|]
operator|->
name|comment
operator|==
name|NULL
operator|)
operator|||
operator|(
name|comment
operator|!=
name|NULL
operator|&&
name|ics
index|[
name|i
index|]
operator|->
name|comment
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|ics
index|[
name|i
index|]
operator|->
name|comment
argument_list|,
name|comment
argument_list|,
name|strlen
argument_list|(
name|ics
index|[
name|i
index|]
operator|->
name|comment
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|&&
name|note
operator|==
name|ics
index|[
name|i
index|]
operator|->
name|note
condition|)
return|return
name|i
return|;
if|if
condition|(
operator|!
name|create
condition|)
return|return
operator|-
literal|1
return|;
comment|/* doesn't exist, so make a new one */
if|if
condition|(
name|iclen
operator|==
name|ictotlen
condition|)
block|{
name|ictotlen
operator|+=
literal|20
expr_stmt|;
name|ics
operator|=
operator|(
expr|struct
name|iclass
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|ics
argument_list|,
operator|(
name|ictotlen
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iclass
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ind
operator|=
name|iclen
operator|++
expr_stmt|;
name|ics
index|[
name|ind
index|]
operator|=
name|tmalloc
argument_list|(
expr|struct
name|iclass
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ics
index|[
name|ind
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iclass
argument_list|)
argument_list|)
expr_stmt|;
name|ics
index|[
name|ind
index|]
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ics
index|[
name|ind
index|]
operator|->
name|is_class
operator|=
name|is_class
expr_stmt|;
name|ics
index|[
name|ind
index|]
operator|->
name|orphan
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|comment
condition|)
block|{
name|ics
index|[
name|ind
index|]
operator|->
name|comment
operator|=
name|xstrdup
argument_list|(
name|comment
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ics
index|[
name|ind
index|]
operator|->
name|comment
index|[
name|strlen
argument_list|(
name|ics
index|[
name|ind
index|]
operator|->
name|comment
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|notestr
condition|)
name|ics
index|[
name|ind
index|]
operator|->
name|note
operator|=
name|note
expr_stmt|;
comment|/* if it's a composite class, there's a comment or note, look for an      existing class or terminal with the same name. */
if|if
condition|(
operator|(
name|xsect
operator|||
name|comment
operator|||
name|notestr
operator|)
operator|&&
name|is_class
condition|)
block|{
comment|/* First, populate with the class we're based on.  */
name|char
modifier|*
name|subname
init|=
name|name
decl_stmt|;
if|if
condition|(
name|xsect
condition|)
operator|*
name|xsect
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|comment
condition|)
operator|*
name|comment
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|notestr
condition|)
operator|*
name|notestr
operator|=
literal|0
expr_stmt|;
name|ics
index|[
name|ind
index|]
operator|->
name|nsubs
operator|=
literal|1
expr_stmt|;
name|ics
index|[
name|ind
index|]
operator|->
name|subs
operator|=
name|tmalloc
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|ics
index|[
name|ind
index|]
operator|->
name|subs
index|[
literal|0
index|]
operator|=
name|fetch_insn_class
argument_list|(
name|subname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
empty_stmt|;
block|}
while|while
condition|(
name|xsect
condition|)
block|{
name|char
modifier|*
name|subname
init|=
name|xsect
operator|+
literal|1
decl_stmt|;
name|xsect
operator|=
name|strchr
argument_list|(
name|subname
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
if|if
condition|(
name|xsect
condition|)
operator|*
name|xsect
operator|=
literal|0
expr_stmt|;
name|ics
index|[
name|ind
index|]
operator|->
name|xsubs
index|[
name|ics
index|[
name|ind
index|]
operator|->
name|nxsubs
index|]
operator|=
name|fetch_insn_class
argument_list|(
name|subname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ics
index|[
name|ind
index|]
operator|->
name|nxsubs
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|ind
return|;
block|}
end_function

begin_comment
comment|/* for sorting a class's sub-class list only; make sure classes appear before    terminals  */
end_comment

begin_function
specifier|static
name|int
name|sub_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|e1
parameter_list|,
specifier|const
name|void
modifier|*
name|e2
parameter_list|)
block|{
name|struct
name|iclass
modifier|*
name|ic1
init|=
name|ics
index|[
operator|*
operator|(
name|int
operator|*
operator|)
name|e1
index|]
decl_stmt|;
name|struct
name|iclass
modifier|*
name|ic2
init|=
name|ics
index|[
operator|*
operator|(
name|int
operator|*
operator|)
name|e2
index|]
decl_stmt|;
if|if
condition|(
name|ic1
operator|->
name|is_class
condition|)
block|{
if|if
condition|(
operator|!
name|ic2
operator|->
name|is_class
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|ic2
operator|->
name|is_class
condition|)
return|return
literal|1
return|;
return|return
name|strcmp
argument_list|(
name|ic1
operator|->
name|name
argument_list|,
name|ic2
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|load_insn_classes
parameter_list|()
block|{
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
literal|"ia64-ic.tbl"
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|2048
index|]
decl_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't find ia64-ic.tbl for reading\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* discard first line */
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|int
name|iclass
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
break|break;
while|while
condition|(
name|ISSPACE
argument_list|(
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
argument_list|)
condition|)
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|tmp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|*
name|tmp
operator|!=
literal|';'
condition|)
block|{
operator|++
name|tmp
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
operator|*
name|tmp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|iclass
operator|=
name|fetch_insn_class
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ics
index|[
name|iclass
index|]
operator|->
name|is_class
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ics
index|[
name|iclass
index|]
operator|->
name|is_class
operator|=
literal|0
expr_stmt|;
name|ics
index|[
name|iclass
index|]
operator|->
name|terminal_resolved
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* for this class, record all sub-classes */
while|while
condition|(
operator|*
name|tmp
condition|)
block|{
name|char
modifier|*
name|subname
decl_stmt|;
name|int
name|sub
decl_stmt|;
while|while
condition|(
operator|*
name|tmp
operator|&&
name|ISSPACE
argument_list|(
operator|*
name|tmp
argument_list|)
condition|)
block|{
operator|++
name|tmp
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|subname
operator|=
name|tmp
expr_stmt|;
while|while
condition|(
operator|*
name|tmp
operator|&&
operator|*
name|tmp
operator|!=
literal|','
condition|)
block|{
operator|++
name|tmp
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|tmp
operator|==
literal|','
condition|)
operator|*
name|tmp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|ics
index|[
name|iclass
index|]
operator|->
name|subs
operator|=
operator|(
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ics
index|[
name|iclass
index|]
operator|->
name|subs
argument_list|,
operator|(
name|ics
index|[
name|iclass
index|]
operator|->
name|nsubs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|sub
operator|=
name|fetch_insn_class
argument_list|(
name|subname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ics
index|[
name|iclass
index|]
operator|->
name|subs
operator|=
operator|(
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
name|ics
index|[
name|iclass
index|]
operator|->
name|subs
argument_list|,
operator|(
name|ics
index|[
name|iclass
index|]
operator|->
name|nsubs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|ics
index|[
name|iclass
index|]
operator|->
name|subs
index|[
name|ics
index|[
name|iclass
index|]
operator|->
name|nsubs
operator|++
index|]
operator|=
name|sub
expr_stmt|;
block|}
comment|/* make sure classes come before terminals */
name|qsort
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ics
index|[
name|iclass
index|]
operator|->
name|subs
argument_list|,
name|ics
index|[
name|iclass
index|]
operator|->
name|nsubs
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|sub_compare
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"%d classes\n"
argument_list|,
name|iclen
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* extract the insn classes from the given line */
end_comment

begin_function
specifier|static
name|void
name|parse_resource_users
parameter_list|(
name|ref
parameter_list|,
name|usersp
parameter_list|,
name|nusersp
parameter_list|,
name|notesp
parameter_list|)
name|char
modifier|*
name|ref
decl_stmt|;
name|int
modifier|*
modifier|*
name|usersp
decl_stmt|;
name|int
modifier|*
name|nusersp
decl_stmt|;
name|int
modifier|*
modifier|*
name|notesp
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|line
init|=
name|xstrdup
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|char
modifier|*
name|tmp
init|=
name|line
decl_stmt|;
name|int
modifier|*
name|users
init|=
operator|*
name|usersp
decl_stmt|;
name|int
name|count
init|=
operator|*
name|nusersp
decl_stmt|;
name|int
modifier|*
name|notes
init|=
operator|*
name|notesp
decl_stmt|;
name|c
operator|=
operator|*
name|tmp
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|notestr
decl_stmt|;
name|int
name|note
decl_stmt|;
name|char
modifier|*
name|xsect
decl_stmt|;
name|int
name|iclass
decl_stmt|;
name|int
name|create
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|tmp
argument_list|)
condition|)
operator|++
name|tmp
expr_stmt|;
name|name
operator|=
name|tmp
expr_stmt|;
while|while
condition|(
operator|*
name|tmp
operator|&&
operator|*
name|tmp
operator|!=
literal|','
condition|)
operator|++
name|tmp
expr_stmt|;
name|c
operator|=
operator|*
name|tmp
expr_stmt|;
operator|*
name|tmp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|xsect
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|notestr
operator|=
name|strstr
argument_list|(
name|name
argument_list|,
literal|"+"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|nextnotestr
decl_stmt|;
name|note
operator|=
name|atoi
argument_list|(
name|notestr
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nextnotestr
operator|=
name|strchr
argument_list|(
name|notestr
operator|+
literal|1
argument_list|,
literal|'+'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* note 13 always implies note 1 */
if|if
condition|(
name|strcmp
argument_list|(
name|notestr
argument_list|,
literal|"+1+13"
argument_list|)
operator|==
literal|0
condition|)
name|note
operator|=
literal|13
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|xsect
operator|||
name|nextnotestr
operator|<
name|xsect
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: multiple note %s not handled\n"
argument_list|,
name|notestr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|xsect
condition|)
operator|*
name|notestr
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|note
operator|=
literal|0
expr_stmt|;
comment|/* All classes are created when the insn class table is parsed;          Individual instructions might not appear until the dependency tables          are read.  Only create new classes if it's *not* an insn class,          or if it's a composite class (which wouldn't necessarily be in the IC          table).       */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"IC:"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
operator|||
name|xsect
operator|!=
name|NULL
condition|)
name|create
operator|=
literal|1
expr_stmt|;
name|iclass
operator|=
name|fetch_insn_class
argument_list|(
name|name
argument_list|,
name|create
argument_list|)
expr_stmt|;
if|if
condition|(
name|iclass
operator|!=
operator|-
literal|1
condition|)
block|{
name|users
operator|=
operator|(
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|users
argument_list|,
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|notes
operator|=
operator|(
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|notes
argument_list|,
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|notes
index|[
name|count
index|]
operator|=
name|note
expr_stmt|;
name|users
index|[
name|count
operator|++
index|]
operator|=
name|iclass
expr_stmt|;
name|mark_used
argument_list|(
name|ics
index|[
name|iclass
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"Class %s not found\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* update the return values */
operator|*
name|usersp
operator|=
name|users
expr_stmt|;
operator|*
name|nusersp
operator|=
name|count
expr_stmt|;
operator|*
name|notesp
operator|=
name|notes
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_semantics
parameter_list|(
name|char
modifier|*
name|sem
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|sem
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|IA64_DVS_NONE
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sem
argument_list|,
literal|"implied"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|IA64_DVS_IMPLIED
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sem
argument_list|,
literal|"impliedF"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|IA64_DVS_IMPLIEDF
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sem
argument_list|,
literal|"data"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|IA64_DVS_DATA
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sem
argument_list|,
literal|"instr"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|IA64_DVS_INSTR
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sem
argument_list|,
literal|"specific"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|IA64_DVS_SPECIFIC
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sem
argument_list|,
literal|"stop"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|IA64_DVS_STOP
return|;
else|else
return|return
name|IA64_DVS_OTHER
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_dep
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|chk
parameter_list|,
specifier|const
name|char
modifier|*
name|reg
parameter_list|,
name|int
name|semantics
parameter_list|,
name|int
name|mode
parameter_list|,
name|char
modifier|*
name|extra
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|rdep
modifier|*
name|rs
decl_stmt|;
name|rs
operator|=
name|insert_resource
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|parse_resource_users
argument_list|(
name|chk
argument_list|,
operator|&
name|rs
operator|->
name|chks
argument_list|,
operator|&
name|rs
operator|->
name|nchks
argument_list|,
operator|&
name|rs
operator|->
name|chknotes
argument_list|)
expr_stmt|;
name|parse_resource_users
argument_list|(
name|reg
argument_list|,
operator|&
name|rs
operator|->
name|regs
argument_list|,
operator|&
name|rs
operator|->
name|nregs
argument_list|,
operator|&
name|rs
operator|->
name|regnotes
argument_list|)
expr_stmt|;
name|rs
operator|->
name|semantics
operator|=
name|semantics
expr_stmt|;
name|rs
operator|->
name|extra
operator|=
name|extra
expr_stmt|;
name|rs
operator|->
name|waw_special
operator|=
name|flag
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|load_depfile
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|enum
name|ia64_dependency_mode
name|mode
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't find %s for reading\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|semantics
decl_stmt|;
name|char
modifier|*
name|extra
decl_stmt|;
name|char
modifier|*
name|regp
decl_stmt|,
modifier|*
name|chkp
decl_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
break|break;
while|while
condition|(
name|ISSPACE
argument_list|(
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
argument_list|)
condition|)
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|tmp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|*
name|tmp
operator|!=
literal|';'
condition|)
operator|++
name|tmp
expr_stmt|;
operator|*
name|tmp
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|tmp
argument_list|)
condition|)
operator|++
name|tmp
expr_stmt|;
name|regp
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|strchr
argument_list|(
name|tmp
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|tmp
operator|++
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|tmp
argument_list|)
condition|)
operator|++
name|tmp
expr_stmt|;
name|chkp
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|strchr
argument_list|(
name|tmp
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
name|tmp
operator|++
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|tmp
argument_list|)
condition|)
operator|++
name|tmp
expr_stmt|;
name|semantics
operator|=
name|parse_semantics
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|extra
operator|=
name|semantics
operator|==
name|IA64_DVS_OTHER
condition|?
name|xstrdup
argument_list|(
name|tmp
argument_list|)
else|:
name|NULL
expr_stmt|;
comment|/* For WAW entries, if the chks and regs differ, we need to enter the          entries in both positions so that the tables will be parsed properly,          without a lot of extra work */
if|if
condition|(
name|mode
operator|==
name|IA64_DV_WAW
operator|&&
name|strcmp
argument_list|(
name|regp
argument_list|,
name|chkp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|add_dep
argument_list|(
name|name
argument_list|,
name|chkp
argument_list|,
name|regp
argument_list|,
name|semantics
argument_list|,
name|mode
argument_list|,
name|extra
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_dep
argument_list|(
name|name
argument_list|,
name|regp
argument_list|,
name|chkp
argument_list|,
name|semantics
argument_list|,
name|mode
argument_list|,
name|extra
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|add_dep
argument_list|(
name|name
argument_list|,
name|chkp
argument_list|,
name|regp
argument_list|,
name|semantics
argument_list|,
name|mode
argument_list|,
name|extra
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|load_dependencies
parameter_list|()
block|{
name|load_depfile
argument_list|(
literal|"ia64-raw.tbl"
argument_list|,
name|IA64_DV_RAW
argument_list|)
expr_stmt|;
name|load_depfile
argument_list|(
literal|"ia64-waw.tbl"
argument_list|,
name|IA64_DV_WAW
argument_list|)
expr_stmt|;
name|load_depfile
argument_list|(
literal|"ia64-war.tbl"
argument_list|,
name|IA64_DV_WAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|printf
argument_list|(
literal|"%d RAW/WAW/WAR dependencies\n"
argument_list|,
name|rdepslen
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* is the given operand an indirect register file operand? */
end_comment

begin_function
specifier|static
name|int
name|irf_operand
parameter_list|(
name|int
name|op
parameter_list|,
specifier|const
name|char
modifier|*
name|field
parameter_list|)
block|{
if|if
condition|(
operator|!
name|field
condition|)
block|{
return|return
name|op
operator|==
name|IA64_OPND_RR_R3
operator|||
name|op
operator|==
name|IA64_OPND_DBR_R3
operator|||
name|op
operator|==
name|IA64_OPND_IBR_R3
operator|||
name|op
operator|==
name|IA64_OPND_PKR_R3
operator|||
name|op
operator|==
name|IA64_OPND_PMC_R3
operator|||
name|op
operator|==
name|IA64_OPND_PMD_R3
operator|||
name|op
operator|==
name|IA64_OPND_MSR_R3
operator|||
name|op
operator|==
name|IA64_OPND_CPUID_R3
return|;
block|}
else|else
block|{
return|return
operator|(
operator|(
name|op
operator|==
name|IA64_OPND_RR_R3
operator|&&
name|strstr
argument_list|(
name|field
argument_list|,
literal|"rr"
argument_list|)
operator|)
operator|||
operator|(
name|op
operator|==
name|IA64_OPND_DBR_R3
operator|&&
name|strstr
argument_list|(
name|field
argument_list|,
literal|"dbr"
argument_list|)
operator|)
operator|||
operator|(
name|op
operator|==
name|IA64_OPND_IBR_R3
operator|&&
name|strstr
argument_list|(
name|field
argument_list|,
literal|"ibr"
argument_list|)
operator|)
operator|||
operator|(
name|op
operator|==
name|IA64_OPND_PKR_R3
operator|&&
name|strstr
argument_list|(
name|field
argument_list|,
literal|"pkr"
argument_list|)
operator|)
operator|||
operator|(
name|op
operator|==
name|IA64_OPND_PMC_R3
operator|&&
name|strstr
argument_list|(
name|field
argument_list|,
literal|"pmc"
argument_list|)
operator|)
operator|||
operator|(
name|op
operator|==
name|IA64_OPND_PMD_R3
operator|&&
name|strstr
argument_list|(
name|field
argument_list|,
literal|"pmd"
argument_list|)
operator|)
operator|||
operator|(
name|op
operator|==
name|IA64_OPND_MSR_R3
operator|&&
name|strstr
argument_list|(
name|field
argument_list|,
literal|"msr"
argument_list|)
operator|)
operator|||
operator|(
name|op
operator|==
name|IA64_OPND_CPUID_R3
operator|&&
name|strstr
argument_list|(
name|field
argument_list|,
literal|"cpuid"
argument_list|)
operator|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* handle mov_ar, mov_br, mov_cr, mov_indirect, mov_ip, mov_pr, mov_psr, and    mov_um insn classes */
end_comment

begin_function
specifier|static
name|int
name|in_iclass_mov_x
parameter_list|(
name|struct
name|ia64_opcode
modifier|*
name|idesc
parameter_list|,
name|struct
name|iclass
modifier|*
name|ic
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|char
modifier|*
name|field
parameter_list|)
block|{
name|int
name|plain_mov
init|=
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"mov"
argument_list|)
operator|==
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|format
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|ic
operator|->
name|name
index|[
literal|4
index|]
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
literal|'a'
case|:
block|{
name|int
name|i
init|=
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"mov.i"
argument_list|)
operator|==
literal|0
decl_stmt|;
name|int
name|m
init|=
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"mov.m"
argument_list|)
operator|==
literal|0
decl_stmt|;
name|int
name|i2627
init|=
name|i
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_AR3
decl_stmt|;
name|int
name|i28
init|=
name|i
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_AR3
decl_stmt|;
name|int
name|m2930
init|=
name|m
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_AR3
decl_stmt|;
name|int
name|m31
init|=
name|m
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_AR3
decl_stmt|;
name|int
name|pseudo0
init|=
name|plain_mov
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_AR3
decl_stmt|;
name|int
name|pseudo1
init|=
name|plain_mov
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_AR3
decl_stmt|;
comment|/* IC:mov ar */
if|if
condition|(
name|i2627
condition|)
return|return
name|strstr
argument_list|(
name|format
argument_list|,
literal|"I26"
argument_list|)
operator|||
name|strstr
argument_list|(
name|format
argument_list|,
literal|"I27"
argument_list|)
return|;
if|if
condition|(
name|i28
condition|)
return|return
name|strstr
argument_list|(
name|format
argument_list|,
literal|"I28"
argument_list|)
operator|!=
name|NULL
return|;
if|if
condition|(
name|m2930
condition|)
return|return
name|strstr
argument_list|(
name|format
argument_list|,
literal|"M29"
argument_list|)
operator|||
name|strstr
argument_list|(
name|format
argument_list|,
literal|"M30"
argument_list|)
return|;
if|if
condition|(
name|m31
condition|)
return|return
name|strstr
argument_list|(
name|format
argument_list|,
literal|"M31"
argument_list|)
operator|!=
name|NULL
return|;
if|if
condition|(
name|pseudo0
operator|||
name|pseudo1
condition|)
return|return
literal|1
return|;
block|}
break|break;
case|case
literal|'b'
case|:
block|{
name|int
name|i21
init|=
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_B1
decl_stmt|;
name|int
name|i22
init|=
name|plain_mov
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_B2
decl_stmt|;
if|if
condition|(
name|i22
condition|)
return|return
name|strstr
argument_list|(
name|format
argument_list|,
literal|"I22"
argument_list|)
operator|!=
name|NULL
return|;
if|if
condition|(
name|i21
condition|)
return|return
name|strstr
argument_list|(
name|format
argument_list|,
literal|"I21"
argument_list|)
operator|!=
name|NULL
return|;
block|}
break|break;
case|case
literal|'c'
case|:
block|{
name|int
name|m32
init|=
name|plain_mov
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_CR3
decl_stmt|;
name|int
name|m33
init|=
name|plain_mov
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_CR3
decl_stmt|;
if|if
condition|(
name|m32
condition|)
return|return
name|strstr
argument_list|(
name|format
argument_list|,
literal|"M32"
argument_list|)
operator|!=
name|NULL
return|;
if|if
condition|(
name|m33
condition|)
return|return
name|strstr
argument_list|(
name|format
argument_list|,
literal|"M33"
argument_list|)
operator|!=
name|NULL
return|;
block|}
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|ic
operator|->
name|name
index|[
literal|5
index|]
operator|==
literal|'n'
condition|)
block|{
name|int
name|m42
init|=
name|plain_mov
operator|&&
name|irf_operand
argument_list|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
argument_list|,
name|field
argument_list|)
decl_stmt|;
name|int
name|m43
init|=
name|plain_mov
operator|&&
name|irf_operand
argument_list|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
argument_list|,
name|field
argument_list|)
decl_stmt|;
if|if
condition|(
name|m42
condition|)
return|return
name|strstr
argument_list|(
name|format
argument_list|,
literal|"M42"
argument_list|)
operator|!=
name|NULL
return|;
if|if
condition|(
name|m43
condition|)
return|return
name|strstr
argument_list|(
name|format
argument_list|,
literal|"M43"
argument_list|)
operator|!=
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|ic
operator|->
name|name
index|[
literal|5
index|]
operator|==
literal|'p'
condition|)
block|{
return|return
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_IP
return|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|ic
operator|->
name|name
index|[
literal|5
index|]
operator|==
literal|'r'
condition|)
block|{
name|int
name|i25
init|=
name|plain_mov
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_PR
decl_stmt|;
name|int
name|i23
init|=
name|plain_mov
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_PR
decl_stmt|;
name|int
name|i24
init|=
name|plain_mov
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_PR_ROT
decl_stmt|;
if|if
condition|(
name|i23
condition|)
return|return
name|strstr
argument_list|(
name|format
argument_list|,
literal|"I23"
argument_list|)
operator|!=
name|NULL
return|;
if|if
condition|(
name|i24
condition|)
return|return
name|strstr
argument_list|(
name|format
argument_list|,
literal|"I24"
argument_list|)
operator|!=
name|NULL
return|;
if|if
condition|(
name|i25
condition|)
return|return
name|strstr
argument_list|(
name|format
argument_list|,
literal|"I25"
argument_list|)
operator|!=
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|ic
operator|->
name|name
index|[
literal|5
index|]
operator|==
literal|'s'
condition|)
block|{
name|int
name|m35
init|=
name|plain_mov
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_PSR_L
decl_stmt|;
name|int
name|m36
init|=
name|plain_mov
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_PSR
decl_stmt|;
if|if
condition|(
name|m35
condition|)
return|return
name|strstr
argument_list|(
name|format
argument_list|,
literal|"M35"
argument_list|)
operator|!=
name|NULL
return|;
if|if
condition|(
name|m36
condition|)
return|return
name|strstr
argument_list|(
name|format
argument_list|,
literal|"M36"
argument_list|)
operator|!=
name|NULL
return|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
block|{
name|int
name|m35
init|=
name|plain_mov
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_PSR_UM
decl_stmt|;
name|int
name|m36
init|=
name|plain_mov
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_PSR_UM
decl_stmt|;
if|if
condition|(
name|m35
condition|)
return|return
name|strstr
argument_list|(
name|format
argument_list|,
literal|"M35"
argument_list|)
operator|!=
name|NULL
return|;
if|if
condition|(
name|m36
condition|)
return|return
name|strstr
argument_list|(
name|format
argument_list|,
literal|"M36"
argument_list|)
operator|!=
name|NULL
return|;
block|}
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* is the given opcode in the given insn class? */
end_comment

begin_function
specifier|static
name|int
name|in_iclass
parameter_list|(
name|struct
name|ia64_opcode
modifier|*
name|idesc
parameter_list|,
name|struct
name|iclass
modifier|*
name|ic
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|char
modifier|*
name|field
parameter_list|,
name|int
modifier|*
name|notep
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|resolved
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|comment
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ic
operator|->
name|comment
argument_list|,
literal|"Format"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
comment|/* assume that the first format seen is the most restrictive, and              only keep a later one if it looks like it's more restrictive. */
if|if
condition|(
name|format
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|ic
operator|->
name|comment
argument_list|)
operator|<
name|strlen
argument_list|(
name|format
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: most recent format '%s'\n"
literal|"appears more restrictive than '%s'\n"
argument_list|,
name|ic
operator|->
name|comment
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|format
operator|=
name|ic
operator|->
name|comment
expr_stmt|;
block|}
block|}
else|else
name|format
operator|=
name|ic
operator|->
name|comment
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ic
operator|->
name|comment
argument_list|,
literal|"Field"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
if|if
condition|(
name|field
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Overlapping field %s->%s\n"
argument_list|,
name|ic
operator|->
name|comment
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|field
operator|=
name|ic
operator|->
name|comment
expr_stmt|;
block|}
block|}
comment|/* an insn class matches anything that is the same followed by completers,      except when the absence and presence of completers constitutes different      instructions */
if|if
condition|(
name|ic
operator|->
name|nsubs
operator|==
literal|0
operator|&&
name|ic
operator|->
name|nxsubs
operator|==
literal|0
condition|)
block|{
name|int
name|is_mov
init|=
name|strncmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"mov"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
decl_stmt|;
name|int
name|plain_mov
init|=
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"mov"
argument_list|)
operator|==
literal|0
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|ic
operator|->
name|name
argument_list|)
decl_stmt|;
name|resolved
operator|=
operator|(
operator|(
name|strncmp
argument_list|(
name|ic
operator|->
name|name
argument_list|,
name|idesc
operator|->
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|idesc
operator|->
name|name
index|[
name|len
index|]
operator|==
literal|'\0'
operator|||
name|idesc
operator|->
name|name
index|[
name|len
index|]
operator|==
literal|'.'
operator|)
operator|)
expr_stmt|;
comment|/* all break and nop variations must match exactly */
if|if
condition|(
name|resolved
operator|&&
operator|(
name|strcmp
argument_list|(
name|ic
operator|->
name|name
argument_list|,
literal|"break"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|ic
operator|->
name|name
argument_list|,
literal|"nop"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|resolved
operator|=
name|strcmp
argument_list|(
name|ic
operator|->
name|name
argument_list|,
name|idesc
operator|->
name|name
argument_list|)
operator|==
literal|0
expr_stmt|;
comment|/* assume restrictions in the FORMAT/FIELD negate resolution,          unless specifically allowed by clauses in this block */
if|if
condition|(
name|resolved
operator|&&
name|field
condition|)
block|{
comment|/* check Field(sf)==sN against opcode sN */
if|if
condition|(
name|strstr
argument_list|(
name|field
argument_list|,
literal|"(sf)=="
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|sf
decl_stmt|;
if|if
condition|(
operator|(
name|sf
operator|=
name|strstr
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|".s"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|resolved
operator|=
name|strcmp
argument_list|(
name|sf
operator|+
literal|1
argument_list|,
name|strstr
argument_list|(
name|field
argument_list|,
literal|"=="
argument_list|)
operator|+
literal|2
argument_list|)
operator|==
literal|0
expr_stmt|;
block|}
block|}
comment|/* check Field(lftype)==XXX */
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|field
argument_list|,
literal|"(lftype)"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"fault"
argument_list|)
operator|!=
name|NULL
condition|)
name|resolved
operator|=
name|strstr
argument_list|(
name|field
argument_list|,
literal|"fault"
argument_list|)
operator|!=
name|NULL
expr_stmt|;
else|else
name|resolved
operator|=
name|strstr
argument_list|(
name|field
argument_list|,
literal|"fault"
argument_list|)
operator|==
name|NULL
expr_stmt|;
block|}
comment|/* handle Field(ctype)==XXX */
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|field
argument_list|,
literal|"(ctype)"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"or.andcm"
argument_list|)
condition|)
name|resolved
operator|=
name|strstr
argument_list|(
name|field
argument_list|,
literal|"or.andcm"
argument_list|)
operator|!=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"and.orcm"
argument_list|)
condition|)
name|resolved
operator|=
name|strstr
argument_list|(
name|field
argument_list|,
literal|"and.orcm"
argument_list|)
operator|!=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"orcm"
argument_list|)
condition|)
name|resolved
operator|=
name|strstr
argument_list|(
name|field
argument_list|,
literal|"or orcm"
argument_list|)
operator|!=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"or"
argument_list|)
condition|)
name|resolved
operator|=
name|strstr
argument_list|(
name|field
argument_list|,
literal|"or orcm"
argument_list|)
operator|!=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"andcm"
argument_list|)
condition|)
name|resolved
operator|=
name|strstr
argument_list|(
name|field
argument_list|,
literal|"and andcm"
argument_list|)
operator|!=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"and"
argument_list|)
condition|)
name|resolved
operator|=
name|strstr
argument_list|(
name|field
argument_list|,
literal|"and andcm"
argument_list|)
operator|!=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"unc"
argument_list|)
condition|)
name|resolved
operator|=
name|strstr
argument_list|(
name|field
argument_list|,
literal|"unc"
argument_list|)
operator|!=
name|NULL
expr_stmt|;
else|else
name|resolved
operator|=
name|strcmp
argument_list|(
name|field
argument_list|,
literal|"Field(ctype)=="
argument_list|)
operator|==
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|resolved
operator|&&
name|format
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"dep"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|&&
name|strstr
argument_list|(
name|format
argument_list|,
literal|"I13"
argument_list|)
operator|!=
name|NULL
condition|)
name|resolved
operator|=
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_IMM8
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"chk"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|&&
name|strstr
argument_list|(
name|format
argument_list|,
literal|"M21"
argument_list|)
operator|!=
name|NULL
condition|)
name|resolved
operator|=
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_F2
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"lfetch"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|resolved
operator|=
operator|(
name|strstr
argument_list|(
name|format
argument_list|,
literal|"M14 M15"
argument_list|)
operator|!=
name|NULL
operator|&&
operator|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_R2
operator|||
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_IMM9b
operator|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"br.call"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|&&
name|strstr
argument_list|(
name|format
argument_list|,
literal|"B5"
argument_list|)
operator|!=
name|NULL
condition|)
name|resolved
operator|=
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_B2
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"br.call"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|&&
name|strstr
argument_list|(
name|format
argument_list|,
literal|"B3"
argument_list|)
operator|!=
name|NULL
condition|)
name|resolved
operator|=
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_TGT25c
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"brp"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|&&
name|strstr
argument_list|(
name|format
argument_list|,
literal|"B7"
argument_list|)
operator|!=
name|NULL
condition|)
name|resolved
operator|=
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_B2
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ic
operator|->
name|name
argument_list|,
literal|"invala"
argument_list|)
operator|==
literal|0
condition|)
name|resolved
operator|=
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
name|ic
operator|->
name|name
argument_list|)
operator|==
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"st"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|&&
name|strstr
argument_list|(
name|format
argument_list|,
literal|"M5"
argument_list|)
operator|!=
name|NULL
condition|)
name|resolved
operator|=
name|idesc
operator|->
name|flags
operator|&
name|IA64_OPCODE_POSTINC
expr_stmt|;
else|else
name|resolved
operator|=
literal|0
expr_stmt|;
block|}
comment|/* misc brl variations ('.cond' is optional);           plain brl matches brl.cond */
if|if
condition|(
operator|!
name|resolved
operator|&&
operator|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"brl"
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"brl."
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|strcmp
argument_list|(
name|ic
operator|->
name|name
argument_list|,
literal|"brl.cond"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|resolved
operator|=
literal|1
expr_stmt|;
block|}
comment|/* misc br variations ('.cond' is optional) */
if|if
condition|(
operator|!
name|resolved
operator|&&
operator|(
name|strcmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"br"
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"br."
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|strcmp
argument_list|(
name|ic
operator|->
name|name
argument_list|,
literal|"br.cond"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|format
condition|)
name|resolved
operator|=
operator|(
name|strstr
argument_list|(
name|format
argument_list|,
literal|"B4"
argument_list|)
operator|!=
name|NULL
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_B2
operator|)
operator|||
operator|(
name|strstr
argument_list|(
name|format
argument_list|,
literal|"B1"
argument_list|)
operator|!=
name|NULL
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_TGT25c
operator|)
expr_stmt|;
else|else
name|resolved
operator|=
literal|1
expr_stmt|;
block|}
comment|/* probe variations */
if|if
condition|(
operator|!
name|resolved
operator|&&
name|strncmp
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"probe"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|resolved
operator|=
name|strcmp
argument_list|(
name|ic
operator|->
name|name
argument_list|,
literal|"probe"
argument_list|)
operator|==
literal|0
operator|&&
operator|!
operator|(
operator|(
name|strstr
argument_list|(
name|idesc
operator|->
name|name
argument_list|,
literal|"fault"
argument_list|)
operator|!=
name|NULL
operator|)
operator|^
operator|(
name|format
operator|&&
name|strstr
argument_list|(
name|format
argument_list|,
literal|"M40"
argument_list|)
operator|!=
name|NULL
operator|)
operator|)
expr_stmt|;
block|}
comment|/* mov variations */
if|if
condition|(
operator|!
name|resolved
operator|&&
name|is_mov
condition|)
block|{
if|if
condition|(
name|plain_mov
condition|)
block|{
comment|/* mov alias for fmerge */
if|if
condition|(
name|strcmp
argument_list|(
name|ic
operator|->
name|name
argument_list|,
literal|"fmerge"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|resolved
operator|=
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_F1
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_F3
expr_stmt|;
block|}
comment|/* mov alias for adds (r3 or imm14) */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ic
operator|->
name|name
argument_list|,
literal|"adds"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|resolved
operator|=
operator|(
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_R1
operator|&&
operator|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_R3
operator|||
operator|(
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_IMM14
operator|)
operator|)
operator|)
expr_stmt|;
block|}
comment|/* mov alias for addl */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ic
operator|->
name|name
argument_list|,
literal|"addl"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|resolved
operator|=
name|idesc
operator|->
name|operands
index|[
literal|0
index|]
operator|==
name|IA64_OPND_R1
operator|&&
name|idesc
operator|->
name|operands
index|[
literal|1
index|]
operator|==
name|IA64_OPND_IMM22
expr_stmt|;
block|}
block|}
comment|/* some variants of mov and mov.[im] */
if|if
condition|(
operator|!
name|resolved
operator|&&
name|strncmp
argument_list|(
name|ic
operator|->
name|name
argument_list|,
literal|"mov_"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|resolved
operator|=
name|in_iclass_mov_x
argument_list|(
name|idesc
argument_list|,
name|ic
argument_list|,
name|format
argument_list|,
name|field
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* keep track of this so we can flag any insn classes which aren't           mapped onto at least one real insn */
if|if
condition|(
name|resolved
condition|)
block|{
name|ic
operator|->
name|terminal_resolved
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ic
operator|->
name|nsubs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|in_iclass
argument_list|(
name|idesc
argument_list|,
name|ics
index|[
name|ic
operator|->
name|subs
index|[
name|i
index|]
index|]
argument_list|,
name|format
argument_list|,
name|field
argument_list|,
name|notep
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ic
operator|->
name|nxsubs
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|in_iclass
argument_list|(
name|idesc
argument_list|,
name|ics
index|[
name|ic
operator|->
name|xsubs
index|[
name|j
index|]
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"%s is in IC %s\n"
argument_list|,
name|idesc
operator|->
name|name
argument_list|,
name|ic
operator|->
name|name
argument_list|)
expr_stmt|;
name|resolved
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* If it's in this IC, add the IC note (if any) to the insn */
if|if
condition|(
name|resolved
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|note
operator|&&
name|notep
condition|)
block|{
if|if
condition|(
operator|*
name|notep
operator|&&
operator|*
name|notep
operator|!=
name|ic
operator|->
name|note
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: overwriting note %d with note %d"
literal|"(IC:%s)\n"
argument_list|,
operator|*
name|notep
argument_list|,
name|ic
operator|->
name|note
argument_list|,
name|ic
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
operator|*
name|notep
operator|=
name|ic
operator|->
name|note
expr_stmt|;
block|}
block|}
return|return
name|resolved
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|lookup_regindex
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|specifier
parameter_list|)
block|{
switch|switch
condition|(
name|specifier
condition|)
block|{
case|case
name|IA64_RS_ARX
case|:
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[RSC]"
argument_list|)
condition|)
return|return
literal|16
return|;
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[BSP]"
argument_list|)
condition|)
return|return
literal|17
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[BSPSTORE]"
argument_list|)
condition|)
return|return
literal|18
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[RNAT]"
argument_list|)
condition|)
return|return
literal|19
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[CCV]"
argument_list|)
condition|)
return|return
literal|32
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[ITC]"
argument_list|)
condition|)
return|return
literal|44
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[PFS]"
argument_list|)
condition|)
return|return
literal|64
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[LC]"
argument_list|)
condition|)
return|return
literal|65
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[EC]"
argument_list|)
condition|)
return|return
literal|66
return|;
name|abort
argument_list|()
expr_stmt|;
case|case
name|IA64_RS_CRX
case|:
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[DCR]"
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[ITM]"
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[IVA]"
argument_list|)
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[PTA]"
argument_list|)
condition|)
return|return
literal|8
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[GPTA]"
argument_list|)
condition|)
return|return
literal|9
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[IPSR]"
argument_list|)
condition|)
return|return
literal|16
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[ISR]"
argument_list|)
condition|)
return|return
literal|17
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[IIP]"
argument_list|)
condition|)
return|return
literal|19
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[IFA]"
argument_list|)
condition|)
return|return
literal|20
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[ITIR]"
argument_list|)
condition|)
return|return
literal|21
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[IIPA]"
argument_list|)
condition|)
return|return
literal|22
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[IFS]"
argument_list|)
condition|)
return|return
literal|23
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[IIM]"
argument_list|)
condition|)
return|return
literal|24
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[IHA]"
argument_list|)
condition|)
return|return
literal|25
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[LID]"
argument_list|)
condition|)
return|return
literal|64
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[IVR]"
argument_list|)
condition|)
return|return
literal|65
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[TPR]"
argument_list|)
condition|)
return|return
literal|66
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[EOI]"
argument_list|)
condition|)
return|return
literal|67
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[ITV]"
argument_list|)
condition|)
return|return
literal|72
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[PMV]"
argument_list|)
condition|)
return|return
literal|73
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"[CMCV]"
argument_list|)
condition|)
return|return
literal|74
return|;
name|abort
argument_list|()
expr_stmt|;
case|case
name|IA64_RS_PSR
case|:
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".be"
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".up"
argument_list|)
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".ac"
argument_list|)
condition|)
return|return
literal|3
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".mfl"
argument_list|)
condition|)
return|return
literal|4
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".mfh"
argument_list|)
condition|)
return|return
literal|5
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".ic"
argument_list|)
condition|)
return|return
literal|13
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".i"
argument_list|)
condition|)
return|return
literal|14
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".pk"
argument_list|)
condition|)
return|return
literal|15
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".dt"
argument_list|)
condition|)
return|return
literal|17
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".dfl"
argument_list|)
condition|)
return|return
literal|18
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".dfh"
argument_list|)
condition|)
return|return
literal|19
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".sp"
argument_list|)
condition|)
return|return
literal|20
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".pp"
argument_list|)
condition|)
return|return
literal|21
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".di"
argument_list|)
condition|)
return|return
literal|22
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".si"
argument_list|)
condition|)
return|return
literal|23
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".db"
argument_list|)
condition|)
return|return
literal|24
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".lp"
argument_list|)
condition|)
return|return
literal|25
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".tb"
argument_list|)
condition|)
return|return
literal|26
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".rt"
argument_list|)
condition|)
return|return
literal|27
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".cpl"
argument_list|)
condition|)
return|return
literal|32
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".rs"
argument_list|)
condition|)
return|return
literal|34
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".mc"
argument_list|)
condition|)
return|return
literal|35
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".it"
argument_list|)
condition|)
return|return
literal|36
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".id"
argument_list|)
condition|)
return|return
literal|37
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".da"
argument_list|)
condition|)
return|return
literal|38
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".dd"
argument_list|)
condition|)
return|return
literal|39
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".ss"
argument_list|)
condition|)
return|return
literal|40
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".ri"
argument_list|)
condition|)
return|return
literal|41
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".ed"
argument_list|)
condition|)
return|return
literal|43
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".bn"
argument_list|)
condition|)
return|return
literal|44
return|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|".ia"
argument_list|)
condition|)
return|return
literal|45
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
default|default:
break|break;
block|}
return|return
name|REG_NONE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lookup_specifier
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'%'
argument_list|)
condition|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"AR[K%]"
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|IA64_RS_AR_K
return|;
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"AR[UNAT]"
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|IA64_RS_AR_UNAT
return|;
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"AR%, % in 8"
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|IA64_RS_AR
return|;
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"AR%, % in 48"
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|IA64_RS_ARb
return|;
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"BR%"
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|IA64_RS_BR
return|;
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"CR[IRR%]"
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|IA64_RS_CR_IRR
return|;
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"CR[LRR%]"
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|IA64_RS_CR_LRR
return|;
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"CR%"
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|IA64_RS_CR
return|;
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"FR%, % in 0"
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|IA64_RS_FR
return|;
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"FR%, % in 2"
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|IA64_RS_FRb
return|;
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"GR%"
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|IA64_RS_GR
return|;
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"PR%, % in 1 "
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|IA64_RS_PR
return|;
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"PR%, % in 16 "
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|IA64_RS_PRr
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning! Don't know how to specify %% dependency %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'#'
argument_list|)
condition|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"CPUID#"
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|IA64_RS_CPUID
return|;
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"DBR#"
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|IA64_RS_DBR
return|;
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"IBR#"
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|IA64_RS_IBR
return|;
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"MSR#"
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|IA64_RS_MSR
return|;
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"PKR#"
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|IA64_RS_PKR
return|;
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"PMC#"
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|IA64_RS_PMC
return|;
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"PMD#"
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|IA64_RS_PMD
return|;
if|if
condition|(
name|strstr
argument_list|(
name|name
argument_list|,
literal|"RR#"
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|IA64_RS_RR
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning! Don't know how to specify # dependency %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"AR[FPSR]"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
return|return
name|IA64_RS_AR_FPSR
return|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"AR["
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
name|IA64_RS_ARX
return|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"CR["
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
name|IA64_RS_CRX
return|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"PSR."
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
name|IA64_RS_PSR
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"InService*"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|IA64_RS_INSERVICE
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"GR0"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|IA64_RS_GR0
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"CFM"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|IA64_RS_CFM
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"PR63"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|IA64_RS_PR63
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"RSE"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|IA64_RS_RSE
return|;
return|return
name|IA64_RS_ANY
return|;
block|}
end_function

begin_function
name|void
name|print_dependency_table
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iclen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ics
index|[
name|i
index|]
operator|->
name|is_class
condition|)
block|{
if|if
condition|(
operator|!
name|ics
index|[
name|i
index|]
operator|->
name|nsubs
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: IC:%s"
argument_list|,
name|ics
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ics
index|[
name|i
index|]
operator|->
name|comment
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[%s]"
argument_list|,
name|ics
index|[
name|i
index|]
operator|->
name|comment
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" has no terminals or sub-classes\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ics
index|[
name|i
index|]
operator|->
name|terminal_resolved
operator|&&
operator|!
name|ics
index|[
name|i
index|]
operator|->
name|orphan
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: no insns mapped directly to "
literal|"terminal IC %s"
argument_list|,
name|ics
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ics
index|[
name|i
index|]
operator|->
name|comment
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[%s] "
argument_list|,
name|ics
index|[
name|i
index|]
operator|->
name|comment
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iclen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ics
index|[
name|i
index|]
operator|->
name|orphan
condition|)
block|{
name|mark_used
argument_list|(
name|ics
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: class %s is defined but not used\n"
argument_list|,
name|ics
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rdepslen
condition|;
name|i
operator|++
control|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|mode_str
index|[]
init|=
block|{
literal|"RAW"
block|,
literal|"WAW"
block|,
literal|"WAR"
block|}
decl_stmt|;
if|if
condition|(
name|rdeps
index|[
name|i
index|]
operator|->
name|total_chks
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: rsrc %s (%s) has no chks%s\n"
argument_list|,
name|rdeps
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|mode_str
index|[
name|rdeps
index|[
name|i
index|]
operator|->
name|mode
index|]
argument_list|,
name|rdeps
index|[
name|i
index|]
operator|->
name|total_regs
condition|?
literal|""
else|:
literal|" or regs"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rdeps
index|[
name|i
index|]
operator|->
name|total_regs
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: rsrc %s (%s) has no regs\n"
argument_list|,
name|rdeps
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|mode_str
index|[
name|rdeps
index|[
name|i
index|]
operator|->
name|mode
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* the dependencies themselves */
name|printf
argument_list|(
literal|"static const struct ia64_dependency\ndependencies[] = {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rdepslen
condition|;
name|i
operator|++
control|)
block|{
comment|/* '%', '#', AR[], CR[], or PSR. indicates we need to specify the actual          resource used */
name|int
name|specifier
init|=
name|lookup_specifier
argument_list|(
name|rdeps
index|[
name|i
index|]
operator|->
name|name
argument_list|)
decl_stmt|;
name|int
name|regindex
init|=
name|lookup_regindex
argument_list|(
name|rdeps
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|specifier
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"  { \"%s\", %d, %d, %d, %d, "
argument_list|,
name|rdeps
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|specifier
argument_list|,
operator|(
name|int
operator|)
name|rdeps
index|[
name|i
index|]
operator|->
name|mode
argument_list|,
operator|(
name|int
operator|)
name|rdeps
index|[
name|i
index|]
operator|->
name|semantics
argument_list|,
name|regindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdeps
index|[
name|i
index|]
operator|->
name|semantics
operator|==
name|IA64_DVS_OTHER
condition|)
name|printf
argument_list|(
literal|"\"%s\", "
argument_list|,
name|rdeps
index|[
name|i
index|]
operator|->
name|extra
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"NULL, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"},\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"};\n\n"
argument_list|)
expr_stmt|;
comment|/* and dependency lists */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dlistlen
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
literal|2
decl_stmt|;
name|printf
argument_list|(
literal|"static const short dep%d[] = {\n  "
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|dlists
index|[
name|i
index|]
operator|->
name|len
condition|;
name|j
operator|++
control|)
block|{
name|len
operator|+=
name|printf
argument_list|(
literal|"%d, "
argument_list|,
name|dlists
index|[
name|i
index|]
operator|->
name|deps
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|75
condition|)
block|{
name|printf
argument_list|(
literal|"\n  "
argument_list|)
expr_stmt|;
name|len
operator|=
literal|2
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n};\n\n"
argument_list|)
expr_stmt|;
block|}
comment|/* and opcode dependency list */
name|printf
argument_list|(
literal|"#define NELS(X) (sizeof(X)/sizeof(X[0]))\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"static const struct ia64_opcode_dependency\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"op_dependencies[] = {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opdeplen
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"  { "
argument_list|)
expr_stmt|;
if|if
condition|(
name|opdeps
index|[
name|i
index|]
operator|->
name|chk
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"0, NULL, "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"NELS(dep%d), dep%d, "
argument_list|,
name|opdeps
index|[
name|i
index|]
operator|->
name|chk
argument_list|,
name|opdeps
index|[
name|i
index|]
operator|->
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|opdeps
index|[
name|i
index|]
operator|->
name|reg
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"0, NULL, "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"NELS(dep%d), dep%d, "
argument_list|,
name|opdeps
index|[
name|i
index|]
operator|->
name|reg
argument_list|,
name|opdeps
index|[
name|i
index|]
operator|->
name|reg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"},\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"};\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add STR to the string table. */
end_comment

begin_function
specifier|static
name|struct
name|string_entry
modifier|*
name|insert_string
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|start
init|=
literal|0
decl_stmt|,
name|end
init|=
name|strtablen
decl_stmt|;
name|int
name|i
decl_stmt|,
name|x
decl_stmt|;
if|if
condition|(
name|strtablen
operator|==
name|strtabtotlen
condition|)
block|{
name|strtabtotlen
operator|+=
literal|20
expr_stmt|;
name|string_table
operator|=
operator|(
expr|struct
name|string_entry
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|string_table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|string_entry
operator|*
operator|*
argument_list|)
operator|*
name|strtabtotlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strtablen
operator|==
literal|0
condition|)
block|{
name|strtablen
operator|=
literal|1
expr_stmt|;
name|string_table
index|[
literal|0
index|]
operator|=
name|tmalloc
argument_list|(
expr|struct
name|string_entry
argument_list|)
expr_stmt|;
name|string_table
index|[
literal|0
index|]
operator|->
name|s
operator|=
name|xstrdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|string_table
index|[
literal|0
index|]
operator|->
name|num
operator|=
literal|0
expr_stmt|;
return|return
name|string_table
index|[
literal|0
index|]
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|string_table
index|[
name|strtablen
operator|-
literal|1
index|]
operator|->
name|s
argument_list|)
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|end
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|string_table
index|[
literal|0
index|]
operator|->
name|s
argument_list|)
operator|<
literal|0
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|c
decl_stmt|;
name|i
operator|=
operator|(
name|start
operator|+
name|end
operator|)
operator|/
literal|2
expr_stmt|;
name|c
operator|=
name|strcmp
argument_list|(
name|str
argument_list|,
name|string_table
index|[
name|i
index|]
operator|->
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
name|end
operator|=
name|i
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
return|return
name|string_table
index|[
name|i
index|]
return|;
block|}
else|else
block|{
name|start
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|>
name|end
condition|)
block|{
break|break;
block|}
block|}
block|}
for|for
control|(
init|;
name|i
operator|>
literal|0
operator|&&
name|i
operator|<
name|strtablen
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|string_table
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|s
argument_list|)
operator|>
literal|0
condition|)
block|{
break|break;
block|}
block|}
for|for
control|(
init|;
name|i
operator|<
name|strtablen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|string_table
index|[
name|i
index|]
operator|->
name|s
argument_list|)
operator|<
literal|0
condition|)
block|{
break|break;
block|}
block|}
for|for
control|(
name|x
operator|=
name|strtablen
operator|-
literal|1
init|;
name|x
operator|>=
name|i
condition|;
name|x
operator|--
control|)
block|{
name|string_table
index|[
name|x
operator|+
literal|1
index|]
operator|=
name|string_table
index|[
name|x
index|]
expr_stmt|;
name|string_table
index|[
name|x
operator|+
literal|1
index|]
operator|->
name|num
operator|=
name|x
operator|+
literal|1
expr_stmt|;
block|}
name|string_table
index|[
name|i
index|]
operator|=
name|tmalloc
argument_list|(
expr|struct
name|string_entry
argument_list|)
expr_stmt|;
name|string_table
index|[
name|i
index|]
operator|->
name|s
operator|=
name|xstrdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|string_table
index|[
name|i
index|]
operator|->
name|num
operator|=
name|i
expr_stmt|;
name|strtablen
operator|++
expr_stmt|;
return|return
name|string_table
index|[
name|i
index|]
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|struct
name|bittree
modifier|*
name|make_bittree_entry
parameter_list|()
block|{
name|struct
name|bittree
modifier|*
name|res
init|=
name|tmalloc
argument_list|(
expr|struct
name|bittree
argument_list|)
decl_stmt|;
name|res
operator|->
name|disent
operator|=
name|NULL
expr_stmt|;
name|res
operator|->
name|bits
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|res
operator|->
name|bits
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|res
operator|->
name|bits
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
name|res
operator|->
name|skip_flag
operator|=
literal|0
expr_stmt|;
name|res
operator|->
name|bits_to_skip
operator|=
literal|0
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|struct
name|disent
modifier|*
name|add_dis_table_ent
parameter_list|(
name|which
parameter_list|,
name|insn
parameter_list|,
name|order
parameter_list|,
name|completer_index
parameter_list|)
name|struct
name|disent
modifier|*
name|which
decl_stmt|;
name|int
name|insn
decl_stmt|;
name|int
name|order
decl_stmt|;
name|int
name|completer_index
decl_stmt|;
block|{
name|int
name|ci
init|=
literal|0
decl_stmt|;
name|struct
name|disent
modifier|*
name|ent
decl_stmt|;
if|if
condition|(
name|which
operator|!=
name|NULL
condition|)
block|{
name|ent
operator|=
name|which
expr_stmt|;
name|ent
operator|->
name|nextcnt
operator|++
expr_stmt|;
while|while
condition|(
name|ent
operator|->
name|nexte
operator|!=
name|NULL
condition|)
block|{
name|ent
operator|=
name|ent
operator|->
name|nexte
expr_stmt|;
block|}
name|ent
operator|=
operator|(
name|ent
operator|->
name|nexte
operator|=
name|tmalloc
argument_list|(
expr|struct
name|disent
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ent
operator|=
name|tmalloc
argument_list|(
expr|struct
name|disent
argument_list|)
expr_stmt|;
name|ent
operator|->
name|next_ent
operator|=
name|disinsntable
expr_stmt|;
name|disinsntable
operator|=
name|ent
expr_stmt|;
name|which
operator|=
name|ent
expr_stmt|;
block|}
name|ent
operator|->
name|nextcnt
operator|=
literal|0
expr_stmt|;
name|ent
operator|->
name|nexte
operator|=
name|NULL
expr_stmt|;
name|ent
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|ent
operator|->
name|priority
operator|=
name|order
expr_stmt|;
while|while
condition|(
name|completer_index
operator|!=
literal|1
condition|)
block|{
name|ci
operator|=
operator|(
name|ci
operator|<<
literal|1
operator|)
operator||
operator|(
name|completer_index
operator|&
literal|1
operator|)
expr_stmt|;
name|completer_index
operator|>>=
literal|1
expr_stmt|;
block|}
name|ent
operator|->
name|completer_index
operator|=
name|ci
expr_stmt|;
return|return
name|which
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|finish_distable
parameter_list|()
block|{
name|struct
name|disent
modifier|*
name|ent
init|=
name|disinsntable
decl_stmt|;
name|struct
name|disent
modifier|*
name|prev
init|=
name|ent
decl_stmt|;
name|ent
operator|->
name|ournum
operator|=
literal|32768
expr_stmt|;
while|while
condition|(
operator|(
name|ent
operator|=
name|ent
operator|->
name|next_ent
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ent
operator|->
name|ournum
operator|=
name|prev
operator|->
name|ournum
operator|+
name|prev
operator|->
name|nextcnt
operator|+
literal|1
expr_stmt|;
name|prev
operator|=
name|ent
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|insert_bit_table_ent
parameter_list|(
name|curr_ent
parameter_list|,
name|bit
parameter_list|,
name|opcode
parameter_list|,
name|mask
parameter_list|,
name|opcodenum
parameter_list|,
name|order
parameter_list|,
name|completer_index
parameter_list|)
name|struct
name|bittree
modifier|*
name|curr_ent
decl_stmt|;
name|int
name|bit
decl_stmt|;
name|ia64_insn
name|opcode
decl_stmt|;
name|ia64_insn
name|mask
decl_stmt|;
name|int
name|opcodenum
decl_stmt|;
name|int
name|order
decl_stmt|;
name|int
name|completer_index
decl_stmt|;
block|{
name|ia64_insn
name|m
decl_stmt|;
name|int
name|b
decl_stmt|;
name|struct
name|bittree
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|bit
operator|==
operator|-
literal|1
condition|)
block|{
name|struct
name|disent
modifier|*
name|nent
init|=
name|add_dis_table_ent
argument_list|(
name|curr_ent
operator|->
name|disent
argument_list|,
name|opcodenum
argument_list|,
name|order
argument_list|,
name|completer_index
argument_list|)
decl_stmt|;
name|curr_ent
operator|->
name|disent
operator|=
name|nent
expr_stmt|;
return|return;
block|}
name|m
operator|=
operator|(
operator|(
name|ia64_insn
operator|)
literal|1
operator|)
operator|<<
name|bit
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|m
condition|)
block|{
name|b
operator|=
operator|(
name|opcode
operator|&
name|m
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
name|b
operator|=
literal|2
expr_stmt|;
block|}
name|next
operator|=
name|curr_ent
operator|->
name|bits
index|[
name|b
index|]
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
block|{
name|next
operator|=
name|make_bittree_entry
argument_list|()
expr_stmt|;
name|curr_ent
operator|->
name|bits
index|[
name|b
index|]
operator|=
name|next
expr_stmt|;
block|}
name|insert_bit_table_ent
argument_list|(
name|next
argument_list|,
name|bit
operator|-
literal|1
argument_list|,
name|opcode
argument_list|,
name|mask
argument_list|,
name|opcodenum
argument_list|,
name|order
argument_list|,
name|completer_index
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|add_dis_entry
parameter_list|(
name|first
parameter_list|,
name|opcode
parameter_list|,
name|mask
parameter_list|,
name|opcodenum
parameter_list|,
name|ent
parameter_list|,
name|completer_index
parameter_list|)
name|struct
name|bittree
modifier|*
name|first
decl_stmt|;
name|ia64_insn
name|opcode
decl_stmt|;
name|ia64_insn
name|mask
decl_stmt|;
name|int
name|opcodenum
decl_stmt|;
name|struct
name|completer_entry
modifier|*
name|ent
decl_stmt|;
name|int
name|completer_index
decl_stmt|;
block|{
if|if
condition|(
name|completer_index
operator|&
operator|(
literal|1
operator|<<
literal|20
operator|)
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|ent
operator|!=
name|NULL
condition|)
block|{
name|ia64_insn
name|newopcode
init|=
operator|(
name|opcode
operator|&
operator|(
operator|~
name|ent
operator|->
name|mask
operator|)
operator|)
operator||
name|ent
operator|->
name|bits
decl_stmt|;
name|add_dis_entry
argument_list|(
name|first
argument_list|,
name|newopcode
argument_list|,
name|mask
argument_list|,
name|opcodenum
argument_list|,
name|ent
operator|->
name|addl_entries
argument_list|,
operator|(
name|completer_index
operator|<<
literal|1
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|is_terminal
condition|)
block|{
name|insert_bit_table_ent
argument_list|(
name|bittree
argument_list|,
literal|40
argument_list|,
name|newopcode
argument_list|,
name|mask
argument_list|,
name|opcodenum
argument_list|,
name|opcode_count
operator|-
name|ent
operator|->
name|order
operator|-
literal|1
argument_list|,
operator|(
name|completer_index
operator|<<
literal|1
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
block|}
name|completer_index
operator|<<=
literal|1
expr_stmt|;
name|ent
operator|=
name|ent
operator|->
name|alternative
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This optimization pass combines multiple "don't care" nodes. */
end_comment

begin_function
name|void
name|compact_distree
parameter_list|(
name|ent
parameter_list|)
name|struct
name|bittree
modifier|*
name|ent
decl_stmt|;
block|{
define|#
directive|define
name|IS_SKIP
parameter_list|(
name|ent
parameter_list|)
define|\
value|((ent->bits[2] !=NULL) \&& (ent->bits[0] == NULL&& ent->bits[1] == NULL&& ent->skip_flag == 0))
name|int
name|bitcnt
init|=
literal|0
decl_stmt|;
name|struct
name|bittree
modifier|*
name|nent
init|=
name|ent
decl_stmt|;
name|int
name|x
decl_stmt|;
while|while
condition|(
name|IS_SKIP
argument_list|(
name|nent
argument_list|)
condition|)
block|{
name|bitcnt
operator|++
expr_stmt|;
name|nent
operator|=
name|nent
operator|->
name|bits
index|[
literal|2
index|]
expr_stmt|;
block|}
if|if
condition|(
name|bitcnt
condition|)
block|{
name|struct
name|bittree
modifier|*
name|next
init|=
name|ent
operator|->
name|bits
index|[
literal|2
index|]
decl_stmt|;
name|ent
operator|->
name|bits
index|[
literal|0
index|]
operator|=
name|nent
operator|->
name|bits
index|[
literal|0
index|]
expr_stmt|;
name|ent
operator|->
name|bits
index|[
literal|1
index|]
operator|=
name|nent
operator|->
name|bits
index|[
literal|1
index|]
expr_stmt|;
name|ent
operator|->
name|bits
index|[
literal|2
index|]
operator|=
name|nent
operator|->
name|bits
index|[
literal|2
index|]
expr_stmt|;
name|ent
operator|->
name|disent
operator|=
name|nent
operator|->
name|disent
expr_stmt|;
name|ent
operator|->
name|skip_flag
operator|=
literal|1
expr_stmt|;
name|ent
operator|->
name|bits_to_skip
operator|=
name|bitcnt
expr_stmt|;
while|while
condition|(
name|next
operator|!=
name|nent
condition|)
block|{
name|struct
name|bittree
modifier|*
name|b
init|=
name|next
decl_stmt|;
name|next
operator|=
name|next
operator|->
name|bits
index|[
literal|2
index|]
expr_stmt|;
name|free
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|nent
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|3
condition|;
name|x
operator|++
control|)
block|{
name|struct
name|bittree
modifier|*
name|i
init|=
name|ent
operator|->
name|bits
index|[
name|x
index|]
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|NULL
condition|)
block|{
name|compact_distree
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|insn_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_list_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tot_insn_list_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generate the disassembler state machine corresponding to the tree    in ENT.  */
end_comment

begin_function
name|void
name|gen_dis_table
parameter_list|(
name|ent
parameter_list|)
name|struct
name|bittree
modifier|*
name|ent
decl_stmt|;
block|{
name|int
name|x
decl_stmt|;
name|int
name|our_offset
init|=
name|insn_list_len
decl_stmt|;
name|int
name|bitsused
init|=
literal|5
decl_stmt|;
name|int
name|totbits
init|=
name|bitsused
decl_stmt|;
name|int
name|needed_bytes
decl_stmt|;
name|int
name|zero_count
init|=
literal|0
decl_stmt|;
name|int
name|zero_dest
init|=
literal|0
decl_stmt|;
comment|/* initialize this with 0 to keep gcc quiet... */
comment|/* If this is a terminal entry, there's no point in skipping any      bits. */
if|if
condition|(
name|ent
operator|->
name|skip_flag
operator|&&
name|ent
operator|->
name|bits
index|[
literal|0
index|]
operator|==
name|NULL
operator|&&
name|ent
operator|->
name|bits
index|[
literal|1
index|]
operator|==
name|NULL
operator|&&
name|ent
operator|->
name|bits
index|[
literal|2
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ent
operator|->
name|disent
operator|==
name|NULL
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ent
operator|->
name|skip_flag
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Calculate the amount of space needed for this entry, or at least      a conservatively large approximation. */
if|if
condition|(
name|ent
operator|->
name|skip_flag
condition|)
block|{
name|totbits
operator|+=
literal|5
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<
literal|3
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|ent
operator|->
name|bits
index|[
name|x
index|]
operator|!=
name|NULL
condition|)
block|{
name|totbits
operator|+=
literal|16
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ent
operator|->
name|disent
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ent
operator|->
name|bits
index|[
literal|2
index|]
operator|!=
name|NULL
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
name|totbits
operator|+=
literal|16
expr_stmt|;
block|}
comment|/* Now allocate the space. */
name|needed_bytes
operator|=
operator|(
name|totbits
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
operator|(
name|needed_bytes
operator|+
name|insn_list_len
operator|)
operator|>
name|tot_insn_list_len
condition|)
block|{
name|tot_insn_list_len
operator|+=
literal|256
expr_stmt|;
name|insn_list
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|insn_list
argument_list|,
name|tot_insn_list_len
argument_list|)
expr_stmt|;
block|}
name|our_offset
operator|=
name|insn_list_len
expr_stmt|;
name|insn_list_len
operator|+=
name|needed_bytes
expr_stmt|;
name|memset
argument_list|(
name|insn_list
operator|+
name|our_offset
argument_list|,
literal|0
argument_list|,
name|needed_bytes
argument_list|)
expr_stmt|;
comment|/* Encode the skip entry by setting bit 6 set in the state op field,      and store the # of bits to skip immediately after. */
if|if
condition|(
name|ent
operator|->
name|skip_flag
condition|)
block|{
name|bitsused
operator|+=
literal|5
expr_stmt|;
name|insn_list
index|[
name|our_offset
operator|+
literal|0
index|]
operator||=
literal|0x40
operator||
operator|(
operator|(
name|ent
operator|->
name|bits_to_skip
operator|>>
literal|2
operator|)
operator|&
literal|0xf
operator|)
expr_stmt|;
name|insn_list
index|[
name|our_offset
operator|+
literal|1
index|]
operator||=
operator|(
operator|(
name|ent
operator|->
name|bits_to_skip
operator|&
literal|3
operator|)
operator|<<
literal|6
operator|)
expr_stmt|;
block|}
define|#
directive|define
name|IS_ONLY_IFZERO
parameter_list|(
name|ENT
parameter_list|)
define|\
value|((ENT)->bits[0] != NULL&& (ENT)->bits[1] == NULL&& (ENT)->bits[2] == NULL \&& (ENT)->disent == NULL&& (ENT)->skip_flag == 0)
comment|/* Store an "if (bit is zero)" instruction by setting bit 7 in the      state op field. */
if|if
condition|(
name|ent
operator|->
name|bits
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
name|struct
name|bittree
modifier|*
name|nent
init|=
name|ent
operator|->
name|bits
index|[
literal|0
index|]
decl_stmt|;
name|zero_count
operator|=
literal|0
expr_stmt|;
name|insn_list
index|[
name|our_offset
index|]
operator||=
literal|0x80
expr_stmt|;
comment|/* We can encode sequences of multiple "if (bit is zero)" tests 	 by storing the # of zero bits to check in the lower 3 bits of 	 the instruction.  However, this only applies if the state 	 solely tests for a zero bit.  */
if|if
condition|(
name|IS_ONLY_IFZERO
argument_list|(
name|ent
argument_list|)
condition|)
block|{
while|while
condition|(
name|IS_ONLY_IFZERO
argument_list|(
name|nent
argument_list|)
operator|&&
name|zero_count
operator|<
literal|7
condition|)
block|{
name|nent
operator|=
name|nent
operator|->
name|bits
index|[
literal|0
index|]
expr_stmt|;
name|zero_count
operator|++
expr_stmt|;
block|}
name|insn_list
index|[
name|our_offset
operator|+
literal|0
index|]
operator||=
name|zero_count
expr_stmt|;
block|}
name|zero_dest
operator|=
name|insn_list_len
expr_stmt|;
name|gen_dis_table
argument_list|(
name|nent
argument_list|)
expr_stmt|;
block|}
comment|/* Now store the remaining tests.  We also handle a sole "termination      entry" by storing it as an "any bit" test.  */
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<
literal|3
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|ent
operator|->
name|bits
index|[
name|x
index|]
operator|!=
name|NULL
operator|||
operator|(
name|x
operator|==
literal|2
operator|&&
name|ent
operator|->
name|disent
operator|!=
name|NULL
operator|)
condition|)
block|{
name|struct
name|bittree
modifier|*
name|i
init|=
name|ent
operator|->
name|bits
index|[
name|x
index|]
decl_stmt|;
name|int
name|idest
decl_stmt|;
name|int
name|currbits
init|=
literal|15
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|NULL
condition|)
block|{
comment|/* If the instruction being branched to only consists of 		 a termination entry, use the termination entry as the 		 place to branch to instead.  */
if|if
condition|(
name|i
operator|->
name|bits
index|[
literal|0
index|]
operator|==
name|NULL
operator|&&
name|i
operator|->
name|bits
index|[
literal|1
index|]
operator|==
name|NULL
operator|&&
name|i
operator|->
name|bits
index|[
literal|2
index|]
operator|==
name|NULL
operator|&&
name|i
operator|->
name|disent
operator|!=
name|NULL
condition|)
block|{
name|idest
operator|=
name|i
operator|->
name|disent
operator|->
name|ournum
expr_stmt|;
name|i
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|idest
operator|=
name|insn_list_len
operator|-
name|our_offset
expr_stmt|;
block|}
block|}
else|else
block|{
name|idest
operator|=
name|ent
operator|->
name|disent
operator|->
name|ournum
expr_stmt|;
block|}
comment|/* If the destination offset for the if (bit is 1) test is less  	     than 256 bytes away, we can store it as 8-bits instead of 16; 	     the instruction has bit 5 set for the 16-bit address, and bit 	     4 for the 8-bit address.  Since we've already allocated 16 	     bits for the address we need to deallocate the space.  	     Note that branchings within the table are relative, and 	     there are no branches that branch past our instruction yet 	     so we do not need to adjust any other offsets. */
if|if
condition|(
name|x
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|idest
operator|<=
literal|256
condition|)
block|{
name|int
name|start
init|=
name|our_offset
operator|+
name|bitsused
operator|/
literal|8
operator|+
literal|1
decl_stmt|;
name|memmove
argument_list|(
name|insn_list
operator|+
name|start
argument_list|,
name|insn_list
operator|+
name|start
operator|+
literal|1
argument_list|,
name|insn_list_len
operator|-
operator|(
name|start
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|currbits
operator|=
literal|7
expr_stmt|;
name|totbits
operator|-=
literal|8
expr_stmt|;
name|needed_bytes
operator|--
expr_stmt|;
name|insn_list_len
operator|--
expr_stmt|;
name|insn_list
index|[
name|our_offset
index|]
operator||=
literal|0x10
expr_stmt|;
name|idest
operator|--
expr_stmt|;
block|}
else|else
block|{
name|insn_list
index|[
name|our_offset
index|]
operator||=
literal|0x20
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* An instruction which solely consists of a termination 		 marker and whose disassembly name index is< 4096 		 can be stored in 16 bits.  The encoding is slightly 		 odd; the upper 4 bits of the instruction are 0x3, and 		 bit 3 loses its normal meaning.  */
if|if
condition|(
name|ent
operator|->
name|bits
index|[
literal|0
index|]
operator|==
name|NULL
operator|&&
name|ent
operator|->
name|bits
index|[
literal|1
index|]
operator|==
name|NULL
operator|&&
name|ent
operator|->
name|bits
index|[
literal|2
index|]
operator|==
name|NULL
operator|&&
name|ent
operator|->
name|skip_flag
operator|==
literal|0
operator|&&
name|ent
operator|->
name|disent
operator|!=
name|NULL
operator|&&
name|ent
operator|->
name|disent
operator|->
name|ournum
operator|<
operator|(
literal|32768
operator|+
literal|4096
operator|)
condition|)
block|{
name|int
name|start
init|=
name|our_offset
operator|+
name|bitsused
operator|/
literal|8
operator|+
literal|1
decl_stmt|;
name|memmove
argument_list|(
name|insn_list
operator|+
name|start
argument_list|,
name|insn_list
operator|+
name|start
operator|+
literal|1
argument_list|,
name|insn_list_len
operator|-
operator|(
name|start
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|currbits
operator|=
literal|11
expr_stmt|;
name|totbits
operator|-=
literal|5
expr_stmt|;
name|bitsused
operator|--
expr_stmt|;
name|needed_bytes
operator|--
expr_stmt|;
name|insn_list_len
operator|--
expr_stmt|;
name|insn_list
index|[
name|our_offset
index|]
operator||=
literal|0x30
expr_stmt|;
name|idest
operator|&=
operator|~
literal|32768
expr_stmt|;
block|}
else|else
block|{
name|insn_list
index|[
name|our_offset
index|]
operator||=
literal|0x08
expr_stmt|;
block|}
block|}
if|if
condition|(
name|debug
condition|)
block|{
name|int
name|id
init|=
name|idest
decl_stmt|;
if|if
condition|(
name|i
operator|==
name|NULL
condition|)
block|{
name|id
operator||=
literal|32768
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|id
operator|&
literal|32768
operator|)
condition|)
block|{
name|id
operator|+=
name|our_offset
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"%d: if (1) goto %d\n"
argument_list|,
name|our_offset
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%d: try %d\n"
argument_list|,
name|our_offset
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Store the address of the entry being branched to. */
while|while
condition|(
name|currbits
operator|>=
literal|0
condition|)
block|{
name|char
modifier|*
name|byte
init|=
name|insn_list
operator|+
name|our_offset
operator|+
name|bitsused
operator|/
literal|8
decl_stmt|;
if|if
condition|(
name|idest
operator|&
operator|(
literal|1
operator|<<
name|currbits
operator|)
condition|)
block|{
operator|*
name|byte
operator||=
operator|(
literal|1
operator|<<
operator|(
literal|7
operator|-
operator|(
name|bitsused
operator|%
literal|8
operator|)
operator|)
operator|)
expr_stmt|;
block|}
name|bitsused
operator|++
expr_stmt|;
name|currbits
operator|--
expr_stmt|;
block|}
comment|/* Now generate the states for the entry being branched to. */
if|if
condition|(
name|i
operator|!=
name|NULL
condition|)
block|{
name|gen_dis_table
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|debug
condition|)
block|{
if|if
condition|(
name|ent
operator|->
name|skip_flag
condition|)
block|{
name|printf
argument_list|(
literal|"%d: skipping %d\n"
argument_list|,
name|our_offset
argument_list|,
name|ent
operator|->
name|bits_to_skip
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ent
operator|->
name|bits
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%d: if (0:%d) goto %d\n"
argument_list|,
name|our_offset
argument_list|,
name|zero_count
operator|+
literal|1
argument_list|,
name|zero_dest
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bitsused
operator|!=
name|totbits
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|print_dis_table
parameter_list|()
block|{
name|int
name|x
decl_stmt|;
name|struct
name|disent
modifier|*
name|cent
init|=
name|disinsntable
decl_stmt|;
name|printf
argument_list|(
literal|"static const char dis_table[] = {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|insn_list_len
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|x
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|x
operator|%
literal|12
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"0x%02x, "
argument_list|,
name|insn_list
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n};\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"static const struct ia64_dis_names ia64_dis_names[] = {\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|cent
operator|!=
name|NULL
condition|)
block|{
name|struct
name|disent
modifier|*
name|ent
init|=
name|cent
decl_stmt|;
while|while
condition|(
name|ent
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"{ 0x%x, %d, %d, %d },\n"
argument_list|,
name|ent
operator|->
name|completer_index
argument_list|,
name|ent
operator|->
name|insn
argument_list|,
operator|(
name|ent
operator|->
name|nexte
operator|!=
name|NULL
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|,
name|ent
operator|->
name|priority
argument_list|)
expr_stmt|;
name|ent
operator|=
name|ent
operator|->
name|nexte
expr_stmt|;
block|}
name|cent
operator|=
name|cent
operator|->
name|next_ent
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"};\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|generate_disassembler
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|bittree
operator|=
name|make_bittree_entry
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|otlen
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|main_entry
modifier|*
name|ptr
init|=
name|ordered_table
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|ptr
operator|->
name|opcode
operator|->
name|type
operator|!=
name|IA64_TYPE_DYN
condition|)
block|{
name|add_dis_entry
argument_list|(
name|bittree
argument_list|,
name|ptr
operator|->
name|opcode
operator|->
name|opcode
argument_list|,
name|ptr
operator|->
name|opcode
operator|->
name|mask
argument_list|,
name|ptr
operator|->
name|main_index
argument_list|,
name|ptr
operator|->
name|completers
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|compact_distree
argument_list|(
name|bittree
argument_list|)
expr_stmt|;
name|finish_distable
argument_list|()
expr_stmt|;
name|gen_dis_table
argument_list|(
name|bittree
argument_list|)
expr_stmt|;
name|print_dis_table
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|print_string_table
parameter_list|()
block|{
name|int
name|x
decl_stmt|;
name|char
name|lbuf
index|[
literal|80
index|]
decl_stmt|,
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|int
name|blen
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"static const char *ia64_strings[] = {\n"
argument_list|)
expr_stmt|;
name|lbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|strtablen
condition|;
name|x
operator|++
control|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|string_table
index|[
name|x
index|]
operator|->
name|s
argument_list|)
operator|>
literal|75
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|" \"%s\","
argument_list|,
name|string_table
index|[
name|x
index|]
operator|->
name|s
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|blen
operator|+
name|len
operator|)
operator|>
literal|75
condition|)
block|{
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|lbuf
argument_list|)
expr_stmt|;
name|lbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|blen
operator|=
literal|0
expr_stmt|;
block|}
name|strcat
argument_list|(
name|lbuf
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|blen
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|blen
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|lbuf
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"};\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|struct
name|completer_entry
modifier|*
modifier|*
name|glist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|glistlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|glisttotlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If the completer trees ENT1 and ENT2 are equal, return 1. */
end_comment

begin_function
name|int
name|completer_entries_eq
parameter_list|(
name|ent1
parameter_list|,
name|ent2
parameter_list|)
name|struct
name|completer_entry
modifier|*
name|ent1
decl_stmt|,
decl|*
name|ent2
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
name|ent1
operator|!=
name|NULL
operator|&&
name|ent2
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ent1
operator|->
name|name
operator|->
name|num
operator|!=
name|ent2
operator|->
name|name
operator|->
name|num
operator|||
name|ent1
operator|->
name|bits
operator|!=
name|ent2
operator|->
name|bits
operator|||
name|ent1
operator|->
name|mask
operator|!=
name|ent2
operator|->
name|mask
operator|||
name|ent1
operator|->
name|is_terminal
operator|!=
name|ent2
operator|->
name|is_terminal
operator|||
name|ent1
operator|->
name|dependencies
operator|!=
name|ent2
operator|->
name|dependencies
operator|||
name|ent1
operator|->
name|order
operator|!=
name|ent2
operator|->
name|order
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|completer_entries_eq
argument_list|(
name|ent1
operator|->
name|addl_entries
argument_list|,
name|ent2
operator|->
name|addl_entries
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
name|ent1
operator|=
name|ent1
operator|->
name|alternative
expr_stmt|;
name|ent2
operator|=
name|ent2
operator|->
name|alternative
expr_stmt|;
block|}
return|return
name|ent1
operator|==
name|ent2
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Insert ENT into the global list of completers and return it.  If an    equivalent entry (according to completer_entries_eq) already exists,    it is returned instead. */
end_comment

begin_function
name|struct
name|completer_entry
modifier|*
name|insert_gclist
parameter_list|(
name|ent
parameter_list|)
name|struct
name|completer_entry
modifier|*
name|ent
decl_stmt|;
block|{
if|if
condition|(
name|ent
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|x
decl_stmt|;
name|int
name|start
init|=
literal|0
decl_stmt|,
name|end
decl_stmt|;
name|ent
operator|->
name|addl_entries
operator|=
name|insert_gclist
argument_list|(
name|ent
operator|->
name|addl_entries
argument_list|)
expr_stmt|;
name|ent
operator|->
name|alternative
operator|=
name|insert_gclist
argument_list|(
name|ent
operator|->
name|alternative
argument_list|)
expr_stmt|;
name|i
operator|=
name|glistlen
operator|/
literal|2
expr_stmt|;
name|end
operator|=
name|glistlen
expr_stmt|;
if|if
condition|(
name|glisttotlen
operator|==
name|glistlen
condition|)
block|{
name|glisttotlen
operator|+=
literal|20
expr_stmt|;
name|glist
operator|=
operator|(
expr|struct
name|completer_entry
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|glist
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|completer_entry
operator|*
argument_list|)
operator|*
name|glisttotlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|glistlen
operator|==
literal|0
condition|)
block|{
name|glist
index|[
literal|0
index|]
operator|=
name|ent
expr_stmt|;
name|glistlen
operator|=
literal|1
expr_stmt|;
return|return
name|ent
return|;
block|}
if|if
condition|(
name|ent
operator|->
name|name
operator|->
name|num
operator|<
name|glist
index|[
literal|0
index|]
operator|->
name|name
operator|->
name|num
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ent
operator|->
name|name
operator|->
name|num
operator|>
name|glist
index|[
name|end
operator|-
literal|1
index|]
operator|->
name|name
operator|->
name|num
condition|)
block|{
name|i
operator|=
name|end
expr_stmt|;
block|}
else|else
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|i
operator|=
operator|(
name|start
operator|+
name|end
operator|)
operator|/
literal|2
expr_stmt|;
name|c
operator|=
name|ent
operator|->
name|name
operator|->
name|num
operator|-
name|glist
index|[
name|i
index|]
operator|->
name|name
operator|->
name|num
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
name|end
operator|=
name|i
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
while|while
condition|(
name|i
operator|>
literal|0
operator|&&
name|ent
operator|->
name|name
operator|->
name|num
operator|==
name|glist
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|name
operator|->
name|num
condition|)
block|{
name|i
operator|--
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
name|start
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|>
name|end
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
while|while
condition|(
name|i
operator|<
name|glistlen
condition|)
block|{
if|if
condition|(
name|ent
operator|->
name|name
operator|->
name|num
operator|!=
name|glist
index|[
name|i
index|]
operator|->
name|name
operator|->
name|num
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|completer_entries_eq
argument_list|(
name|ent
argument_list|,
name|glist
index|[
name|i
index|]
argument_list|)
condition|)
block|{
return|return
name|glist
index|[
name|i
index|]
return|;
block|}
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
init|;
name|i
operator|>
literal|0
operator|&&
name|i
operator|<
name|glistlen
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|ent
operator|->
name|name
operator|->
name|num
operator|>=
name|glist
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|name
operator|->
name|num
condition|)
block|{
break|break;
block|}
block|}
for|for
control|(
init|;
name|i
operator|<
name|glistlen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ent
operator|->
name|name
operator|->
name|num
operator|<
name|glist
index|[
name|i
index|]
operator|->
name|name
operator|->
name|num
condition|)
block|{
break|break;
block|}
block|}
for|for
control|(
name|x
operator|=
name|glistlen
operator|-
literal|1
init|;
name|x
operator|>=
name|i
condition|;
name|x
operator|--
control|)
block|{
name|glist
index|[
name|x
operator|+
literal|1
index|]
operator|=
name|glist
index|[
name|x
index|]
expr_stmt|;
block|}
name|glist
index|[
name|i
index|]
operator|=
name|ent
expr_stmt|;
name|glistlen
operator|++
expr_stmt|;
block|}
return|return
name|ent
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|get_prefix_len
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
return|return
literal|0
return|;
block|}
name|c
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
block|{
return|return
name|c
operator|-
name|name
return|;
block|}
else|else
block|{
return|return
name|strlen
argument_list|(
name|name
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|compute_completer_bits
parameter_list|(
name|ment
parameter_list|,
name|ent
parameter_list|)
name|struct
name|main_entry
modifier|*
name|ment
decl_stmt|;
name|struct
name|completer_entry
modifier|*
name|ent
decl_stmt|;
block|{
while|while
condition|(
name|ent
operator|!=
name|NULL
condition|)
block|{
name|compute_completer_bits
argument_list|(
name|ment
argument_list|,
name|ent
operator|->
name|addl_entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|is_terminal
condition|)
block|{
name|ia64_insn
name|mask
init|=
literal|0
decl_stmt|;
name|ia64_insn
name|our_bits
init|=
name|ent
operator|->
name|bits
decl_stmt|;
name|struct
name|completer_entry
modifier|*
name|p
init|=
name|ent
operator|->
name|parent
decl_stmt|;
name|ia64_insn
name|p_bits
decl_stmt|;
name|int
name|x
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|!
name|p
operator|->
name|is_terminal
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|parent
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|p_bits
operator|=
name|p
operator|->
name|bits
expr_stmt|;
block|}
else|else
block|{
name|p_bits
operator|=
name|ment
operator|->
name|opcode
operator|->
name|opcode
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|64
condition|;
name|x
operator|++
control|)
block|{
name|ia64_insn
name|m
init|=
operator|(
operator|(
name|ia64_insn
operator|)
literal|1
operator|)
operator|<<
name|x
decl_stmt|;
if|if
condition|(
operator|(
name|p_bits
operator|&
name|m
operator|)
operator|!=
operator|(
name|our_bits
operator|&
name|m
operator|)
condition|)
block|{
name|mask
operator||=
name|m
expr_stmt|;
block|}
else|else
block|{
name|our_bits
operator|&=
operator|~
name|m
expr_stmt|;
block|}
block|}
name|ent
operator|->
name|bits
operator|=
name|our_bits
expr_stmt|;
name|ent
operator|->
name|mask
operator|=
name|mask
expr_stmt|;
block|}
else|else
block|{
name|ent
operator|->
name|bits
operator|=
literal|0
expr_stmt|;
name|ent
operator|->
name|mask
operator|=
literal|0
expr_stmt|;
block|}
name|ent
operator|=
name|ent
operator|->
name|alternative
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find identical completer trees that are used in different    instructions and collapse their entries. */
end_comment

begin_function
name|void
name|collapse_redundant_completers
parameter_list|()
block|{
name|struct
name|main_entry
modifier|*
name|ptr
decl_stmt|;
name|int
name|x
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|maintable
init|;
name|ptr
operator|!=
name|NULL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ptr
operator|->
name|completers
operator|==
name|NULL
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
name|compute_completer_bits
argument_list|(
name|ptr
argument_list|,
name|ptr
operator|->
name|completers
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|completers
operator|=
name|insert_gclist
argument_list|(
name|ptr
operator|->
name|completers
argument_list|)
expr_stmt|;
block|}
comment|/* The table has been finalized, now number the indexes.  */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|glistlen
condition|;
name|x
operator|++
control|)
block|{
name|glist
index|[
name|x
index|]
operator|->
name|num
operator|=
name|x
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* attach two lists of dependencies to each opcode.    1) all resources which, when already marked in use, conflict with this    opcode (chks)     2) all resources which must be marked in use when this opcode is used    (regs)  */
end_comment

begin_function
name|int
name|insert_opcode_dependencies
parameter_list|(
name|opc
parameter_list|,
name|cmp
parameter_list|)
name|struct
name|ia64_opcode
modifier|*
name|opc
decl_stmt|;
name|struct
name|completer_entry
modifier|*
name|cmp
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* note all resources which point to this opcode.  rfi has the most chks      (79) and cmpxchng has the most regs (54) so 100 here should be enough */
name|int
name|i
decl_stmt|;
name|int
name|nregs
init|=
literal|0
decl_stmt|;
name|unsigned
name|short
name|regs
index|[
literal|256
index|]
decl_stmt|;
name|int
name|nchks
init|=
literal|0
decl_stmt|;
name|unsigned
name|short
name|chks
index|[
literal|256
index|]
decl_stmt|;
comment|/* flag insns for which no class matched; there should be none */
name|int
name|no_class_found
init|=
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rdepslen
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|rdep
modifier|*
name|rs
init|=
name|rdeps
index|[
name|i
index|]
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|opc
operator|->
name|name
argument_list|,
literal|"cmp.eq.and"
argument_list|)
operator|==
literal|0
operator|&&
name|strncmp
argument_list|(
name|rs
operator|->
name|name
argument_list|,
literal|"PR%"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|&&
name|rs
operator|->
name|mode
operator|==
literal|1
condition|)
name|no_class_found
operator|=
literal|99
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|rs
operator|->
name|nregs
condition|;
name|j
operator|++
control|)
block|{
name|int
name|ic_note
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|in_iclass
argument_list|(
name|opc
argument_list|,
name|ics
index|[
name|rs
operator|->
name|regs
index|[
name|j
index|]
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ic_note
argument_list|)
condition|)
block|{
comment|/* We can ignore ic_note 11 for non PR resources */
if|if
condition|(
name|ic_note
operator|==
literal|11
operator|&&
name|strncmp
argument_list|(
name|rs
operator|->
name|name
argument_list|,
literal|"PR"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
name|ic_note
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ic_note
operator|!=
literal|0
operator|&&
name|rs
operator|->
name|regnotes
index|[
name|j
index|]
operator|!=
literal|0
operator|&&
name|ic_note
operator|!=
name|rs
operator|->
name|regnotes
index|[
name|j
index|]
operator|&&
operator|!
operator|(
name|ic_note
operator|==
literal|11
operator|&&
name|rs
operator|->
name|regnotes
index|[
name|j
index|]
operator|==
literal|1
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: IC note %d in opcode %s (IC:%s)"
literal|" conflicts with resource %s note %d\n"
argument_list|,
name|ic_note
argument_list|,
name|opc
operator|->
name|name
argument_list|,
name|ics
index|[
name|rs
operator|->
name|regs
index|[
name|j
index|]
index|]
operator|->
name|name
argument_list|,
name|rs
operator|->
name|name
argument_list|,
name|rs
operator|->
name|regnotes
index|[
name|j
index|]
argument_list|)
expr_stmt|;
comment|/* Instruction class notes override resource notes.                  So far, only note 11 applies to an IC instead of a resource,                  and note 11 implies note 1.                */
if|if
condition|(
name|ic_note
condition|)
name|regs
index|[
name|nregs
operator|++
index|]
operator|=
name|RDEP
argument_list|(
name|ic_note
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|regs
index|[
name|nregs
operator|++
index|]
operator|=
name|RDEP
argument_list|(
name|rs
operator|->
name|regnotes
index|[
name|j
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|no_class_found
operator|=
literal|0
expr_stmt|;
operator|++
name|rs
operator|->
name|total_regs
expr_stmt|;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|rs
operator|->
name|nchks
condition|;
name|j
operator|++
control|)
block|{
name|int
name|ic_note
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|in_iclass
argument_list|(
name|opc
argument_list|,
name|ics
index|[
name|rs
operator|->
name|chks
index|[
name|j
index|]
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ic_note
argument_list|)
condition|)
block|{
comment|/* We can ignore ic_note 11 for non PR resources */
if|if
condition|(
name|ic_note
operator|==
literal|11
operator|&&
name|strncmp
argument_list|(
name|rs
operator|->
name|name
argument_list|,
literal|"PR"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
name|ic_note
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ic_note
operator|!=
literal|0
operator|&&
name|rs
operator|->
name|chknotes
index|[
name|j
index|]
operator|!=
literal|0
operator|&&
name|ic_note
operator|!=
name|rs
operator|->
name|chknotes
index|[
name|j
index|]
operator|&&
operator|!
operator|(
name|ic_note
operator|==
literal|11
operator|&&
name|rs
operator|->
name|chknotes
index|[
name|j
index|]
operator|==
literal|1
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: IC note %d for opcode %s (IC:%s)"
literal|" conflicts with resource %s note %d\n"
argument_list|,
name|ic_note
argument_list|,
name|opc
operator|->
name|name
argument_list|,
name|ics
index|[
name|rs
operator|->
name|chks
index|[
name|j
index|]
index|]
operator|->
name|name
argument_list|,
name|rs
operator|->
name|name
argument_list|,
name|rs
operator|->
name|chknotes
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic_note
condition|)
name|chks
index|[
name|nchks
operator|++
index|]
operator|=
name|RDEP
argument_list|(
name|ic_note
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|chks
index|[
name|nchks
operator|++
index|]
operator|=
name|RDEP
argument_list|(
name|rs
operator|->
name|chknotes
index|[
name|j
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|no_class_found
operator|=
literal|0
expr_stmt|;
operator|++
name|rs
operator|->
name|total_chks
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|no_class_found
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: opcode %s has no class (ops %d %d %d)\n"
argument_list|,
name|opc
operator|->
name|name
argument_list|,
name|opc
operator|->
name|operands
index|[
literal|0
index|]
argument_list|,
name|opc
operator|->
name|operands
index|[
literal|1
index|]
argument_list|,
name|opc
operator|->
name|operands
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
name|insert_dependencies
argument_list|(
name|nchks
argument_list|,
name|chks
argument_list|,
name|nregs
argument_list|,
name|regs
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|insert_completer_entry
parameter_list|(
name|opc
parameter_list|,
name|tabent
parameter_list|,
name|order
parameter_list|)
name|struct
name|ia64_opcode
modifier|*
name|opc
decl_stmt|;
name|struct
name|main_entry
modifier|*
name|tabent
decl_stmt|;
name|int
name|order
decl_stmt|;
block|{
name|struct
name|completer_entry
modifier|*
modifier|*
name|ptr
init|=
operator|&
name|tabent
operator|->
name|completers
decl_stmt|;
name|struct
name|completer_entry
modifier|*
name|parent
init|=
name|NULL
decl_stmt|;
name|char
name|pcopy
index|[
literal|129
index|]
decl_stmt|,
modifier|*
name|prefix
decl_stmt|;
name|int
name|at_end
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|opc
operator|->
name|name
argument_list|)
operator|>
literal|128
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|pcopy
argument_list|,
name|opc
operator|->
name|name
argument_list|)
expr_stmt|;
name|prefix
operator|=
name|pcopy
operator|+
name|get_prefix_len
argument_list|(
name|pcopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|prefix
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|at_end
condition|)
block|{
name|int
name|need_new_ent
init|=
literal|1
decl_stmt|;
name|int
name|plen
init|=
name|get_prefix_len
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
name|struct
name|string_entry
modifier|*
name|sent
decl_stmt|;
name|at_end
operator|=
operator|(
name|prefix
index|[
name|plen
index|]
operator|==
literal|'\0'
operator|)
expr_stmt|;
name|prefix
index|[
name|plen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sent
operator|=
name|insert_string
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|int
name|cmpres
init|=
name|sent
operator|->
name|num
operator|-
operator|(
operator|*
name|ptr
operator|)
operator|->
name|name
operator|->
name|num
decl_stmt|;
if|if
condition|(
name|cmpres
operator|==
literal|0
condition|)
block|{
name|need_new_ent
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|else
block|{
name|ptr
operator|=
operator|&
operator|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|alternative
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|need_new_ent
condition|)
block|{
name|struct
name|completer_entry
modifier|*
name|nent
init|=
name|tmalloc
argument_list|(
expr|struct
name|completer_entry
argument_list|)
decl_stmt|;
name|nent
operator|->
name|name
operator|=
name|sent
expr_stmt|;
name|nent
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|nent
operator|->
name|addl_entries
operator|=
name|NULL
expr_stmt|;
name|nent
operator|->
name|alternative
operator|=
operator|*
name|ptr
expr_stmt|;
operator|*
name|ptr
operator|=
name|nent
expr_stmt|;
name|nent
operator|->
name|is_terminal
operator|=
literal|0
expr_stmt|;
name|nent
operator|->
name|dependencies
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|at_end
condition|)
block|{
name|parent
operator|=
operator|*
name|ptr
expr_stmt|;
name|ptr
operator|=
operator|&
operator|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|addl_entries
operator|)
expr_stmt|;
name|prefix
operator|+=
name|plen
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|*
name|ptr
operator|)
operator|->
name|is_terminal
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
operator|(
operator|*
name|ptr
operator|)
operator|->
name|is_terminal
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|ptr
operator|)
operator|->
name|mask
operator|=
operator|(
name|ia64_insn
operator|)
operator|-
literal|1
expr_stmt|;
operator|(
operator|*
name|ptr
operator|)
operator|->
name|bits
operator|=
name|opc
operator|->
name|opcode
expr_stmt|;
operator|(
operator|*
name|ptr
operator|)
operator|->
name|dependencies
operator|=
name|insert_opcode_dependencies
argument_list|(
name|opc
argument_list|,
operator|*
name|ptr
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ptr
operator|)
operator|->
name|order
operator|=
name|order
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|print_completer_entry
parameter_list|(
name|ent
parameter_list|)
name|struct
name|completer_entry
modifier|*
name|ent
decl_stmt|;
block|{
name|int
name|moffset
init|=
literal|0
decl_stmt|;
name|ia64_insn
name|mask
init|=
name|ent
operator|->
name|mask
decl_stmt|,
name|bits
init|=
name|ent
operator|->
name|bits
decl_stmt|;
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|!
operator|(
name|mask
operator|&
literal|1
operator|)
condition|)
block|{
name|moffset
operator|++
expr_stmt|;
name|mask
operator|=
name|mask
operator|>>
literal|1
expr_stmt|;
name|bits
operator|=
name|bits
operator|>>
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bits
operator|&
literal|0xffffffff00000000LL
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"  { 0x%x, 0x%x, %d, %d, %d, %d, %d, %d },\n"
argument_list|,
operator|(
name|int
operator|)
name|bits
argument_list|,
operator|(
name|int
operator|)
name|mask
argument_list|,
name|ent
operator|->
name|name
operator|->
name|num
argument_list|,
name|ent
operator|->
name|alternative
operator|!=
name|NULL
condition|?
name|ent
operator|->
name|alternative
operator|->
name|num
else|:
operator|-
literal|1
argument_list|,
name|ent
operator|->
name|addl_entries
operator|!=
name|NULL
condition|?
name|ent
operator|->
name|addl_entries
operator|->
name|num
else|:
operator|-
literal|1
argument_list|,
name|moffset
argument_list|,
name|ent
operator|->
name|is_terminal
condition|?
literal|1
else|:
literal|0
argument_list|,
name|ent
operator|->
name|dependencies
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|print_completer_table
parameter_list|()
block|{
name|int
name|x
decl_stmt|;
name|printf
argument_list|(
literal|"static const struct ia64_completer_table\ncompleter_table[] = {\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|glistlen
condition|;
name|x
operator|++
control|)
block|{
name|print_completer_entry
argument_list|(
name|glist
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"};\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|opcodes_eq
parameter_list|(
name|opc1
parameter_list|,
name|opc2
parameter_list|)
name|struct
name|ia64_opcode
modifier|*
name|opc1
decl_stmt|;
name|struct
name|ia64_opcode
modifier|*
name|opc2
decl_stmt|;
block|{
name|int
name|x
decl_stmt|;
name|int
name|plen1
decl_stmt|,
name|plen2
decl_stmt|;
if|if
condition|(
operator|(
name|opc1
operator|->
name|mask
operator|!=
name|opc2
operator|->
name|mask
operator|)
operator|||
operator|(
name|opc1
operator|->
name|type
operator|!=
name|opc2
operator|->
name|type
operator|)
operator|||
operator|(
name|opc1
operator|->
name|num_outputs
operator|!=
name|opc2
operator|->
name|num_outputs
operator|)
operator|||
operator|(
name|opc1
operator|->
name|flags
operator|!=
name|opc2
operator|->
name|flags
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|5
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|opc1
operator|->
name|operands
index|[
name|x
index|]
operator|!=
name|opc2
operator|->
name|operands
index|[
name|x
index|]
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
name|plen1
operator|=
name|get_prefix_len
argument_list|(
name|opc1
operator|->
name|name
argument_list|)
expr_stmt|;
name|plen2
operator|=
name|get_prefix_len
argument_list|(
name|opc2
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen1
operator|==
name|plen2
operator|&&
operator|(
name|memcmp
argument_list|(
name|opc1
operator|->
name|name
argument_list|,
name|opc2
operator|->
name|name
argument_list|,
name|plen1
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|add_opcode_entry
parameter_list|(
name|opc
parameter_list|)
name|struct
name|ia64_opcode
modifier|*
name|opc
decl_stmt|;
block|{
name|struct
name|main_entry
modifier|*
modifier|*
name|place
decl_stmt|;
name|struct
name|string_entry
modifier|*
name|name
decl_stmt|;
name|char
name|prefix
index|[
literal|129
index|]
decl_stmt|;
name|int
name|found_it
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|opc
operator|->
name|name
argument_list|)
operator|>
literal|128
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
name|place
operator|=
operator|&
name|maintable
expr_stmt|;
name|strcpy
argument_list|(
name|prefix
argument_list|,
name|opc
operator|->
name|name
argument_list|)
expr_stmt|;
name|prefix
index|[
name|get_prefix_len
argument_list|(
name|prefix
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|insert_string
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
comment|/* Walk the list of opcode table entries.  If it's a new      instruction, allocate and fill in a new entry.  Note       the main table is alphabetical by opcode name. */
while|while
condition|(
operator|*
name|place
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|place
operator|)
operator|->
name|name
operator|->
name|num
operator|==
name|name
operator|->
name|num
operator|&&
name|opcodes_eq
argument_list|(
operator|(
operator|*
name|place
operator|)
operator|->
name|opcode
argument_list|,
name|opc
argument_list|)
condition|)
block|{
name|found_it
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
operator|*
name|place
operator|)
operator|->
name|name
operator|->
name|num
operator|>
name|name
operator|->
name|num
condition|)
block|{
break|break;
block|}
name|place
operator|=
operator|&
operator|(
operator|(
operator|*
name|place
operator|)
operator|->
name|next
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found_it
condition|)
block|{
name|struct
name|main_entry
modifier|*
name|nent
init|=
name|tmalloc
argument_list|(
expr|struct
name|main_entry
argument_list|)
decl_stmt|;
name|nent
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|nent
operator|->
name|opcode
operator|=
name|opc
expr_stmt|;
name|nent
operator|->
name|next
operator|=
operator|*
name|place
expr_stmt|;
name|nent
operator|->
name|completers
operator|=
literal|0
expr_stmt|;
operator|*
name|place
operator|=
name|nent
expr_stmt|;
if|if
condition|(
name|otlen
operator|==
name|ottotlen
condition|)
block|{
name|ottotlen
operator|+=
literal|20
expr_stmt|;
name|ordered_table
operator|=
operator|(
expr|struct
name|main_entry
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|ordered_table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|main_entry
operator|*
argument_list|)
operator|*
name|ottotlen
argument_list|)
expr_stmt|;
block|}
name|ordered_table
index|[
name|otlen
operator|++
index|]
operator|=
name|nent
expr_stmt|;
block|}
name|insert_completer_entry
argument_list|(
name|opc
argument_list|,
operator|*
name|place
argument_list|,
name|opcode_count
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|print_main_table
parameter_list|()
block|{
name|struct
name|main_entry
modifier|*
name|ptr
init|=
name|maintable
decl_stmt|;
name|int
name|index
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"static const struct ia64_main_table\nmain_table[] = {\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"  { %d, %d, %d, 0x"
argument_list|,
name|ptr
operator|->
name|name
operator|->
name|num
argument_list|,
name|ptr
operator|->
name|opcode
operator|->
name|type
argument_list|,
name|ptr
operator|->
name|opcode
operator|->
name|num_outputs
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|stdout
argument_list|,
name|ptr
operator|->
name|opcode
operator|->
name|opcode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ull, 0x"
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|stdout
argument_list|,
name|ptr
operator|->
name|opcode
operator|->
name|mask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ull, { %d, %d, %d, %d, %d }, 0x%x, %d, },\n"
argument_list|,
name|ptr
operator|->
name|opcode
operator|->
name|operands
index|[
literal|0
index|]
argument_list|,
name|ptr
operator|->
name|opcode
operator|->
name|operands
index|[
literal|1
index|]
argument_list|,
name|ptr
operator|->
name|opcode
operator|->
name|operands
index|[
literal|2
index|]
argument_list|,
name|ptr
operator|->
name|opcode
operator|->
name|operands
index|[
literal|3
index|]
argument_list|,
name|ptr
operator|->
name|opcode
operator|->
name|operands
index|[
literal|4
index|]
argument_list|,
name|ptr
operator|->
name|opcode
operator|->
name|flags
argument_list|,
name|ptr
operator|->
name|completers
operator|->
name|num
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|main_index
operator|=
name|index
operator|++
expr_stmt|;
name|ptr
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"};\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|shrink
parameter_list|(
name|table
parameter_list|)
name|struct
name|ia64_opcode
modifier|*
name|table
decl_stmt|;
block|{
name|int
name|curr_opcode
decl_stmt|;
for|for
control|(
name|curr_opcode
operator|=
literal|0
init|;
name|table
index|[
name|curr_opcode
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|curr_opcode
operator|++
control|)
block|{
name|add_opcode_entry
argument_list|(
name|table
operator|+
name|curr_opcode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|debug
operator|=
literal|1
expr_stmt|;
block|}
name|load_insn_classes
argument_list|()
expr_stmt|;
name|load_dependencies
argument_list|()
expr_stmt|;
name|shrink
argument_list|(
name|ia64_opcodes_a
argument_list|)
expr_stmt|;
name|shrink
argument_list|(
name|ia64_opcodes_b
argument_list|)
expr_stmt|;
name|shrink
argument_list|(
name|ia64_opcodes_f
argument_list|)
expr_stmt|;
name|shrink
argument_list|(
name|ia64_opcodes_i
argument_list|)
expr_stmt|;
name|shrink
argument_list|(
name|ia64_opcodes_m
argument_list|)
expr_stmt|;
name|shrink
argument_list|(
name|ia64_opcodes_x
argument_list|)
expr_stmt|;
name|shrink
argument_list|(
name|ia64_opcodes_d
argument_list|)
expr_stmt|;
name|collapse_redundant_completers
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"/* This file is automatically generated by ia64-gen.  Do not edit! */\n"
argument_list|)
expr_stmt|;
name|print_string_table
argument_list|()
expr_stmt|;
name|print_dependency_table
argument_list|()
expr_stmt|;
name|print_completer_table
argument_list|()
expr_stmt|;
name|print_main_table
argument_list|()
expr_stmt|;
name|generate_disassembler
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

