begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Instruction printing code for the ARC.    Copyright (C) 1994, 1995, 1997, 1998 Free Software Foundation, Inc.     Contributed by Doug Evans (dje@cygnus.com).  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"opcode/arc.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/arc.h"
end_include

begin_include
include|#
directive|include
file|"opintl.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|print_insn_arc_base_little
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|print_insn_arc_base_big
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|print_insn
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
name|disassemble_info
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print one instruction from PC on INFO->STREAM.    Return the size of the instruction (4 or 8 for the ARC). */
end_comment

begin_function
specifier|static
name|int
name|print_insn
parameter_list|(
name|pc
parameter_list|,
name|info
parameter_list|,
name|mach
parameter_list|,
name|big_p
parameter_list|)
name|bfd_vma
name|pc
decl_stmt|;
name|disassemble_info
modifier|*
name|info
decl_stmt|;
name|int
name|mach
decl_stmt|;
name|int
name|big_p
decl_stmt|;
block|{
specifier|const
name|struct
name|arc_opcode
modifier|*
name|opcode
decl_stmt|;
name|bfd_byte
name|buffer
index|[
literal|4
index|]
decl_stmt|;
name|void
modifier|*
name|stream
init|=
name|info
operator|->
name|stream
decl_stmt|;
name|fprintf_ftype
name|func
init|=
name|info
operator|->
name|fprintf_func
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* First element is insn, second element is limm (if present).  */
name|arc_insn
name|insn
index|[
literal|2
index|]
decl_stmt|;
name|int
name|got_limm_p
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|initialized
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|current_mach
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
operator|||
name|mach
operator|!=
name|current_mach
condition|)
block|{
name|initialized
operator|=
literal|1
expr_stmt|;
name|current_mach
operator|=
name|arc_get_opcode_mach
argument_list|(
name|mach
argument_list|,
name|big_p
argument_list|)
expr_stmt|;
name|arc_opcode_init_tables
argument_list|(
name|current_mach
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|pc
argument_list|,
name|buffer
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|memory_error_func
call|)
argument_list|(
name|status
argument_list|,
name|pc
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|big_p
condition|)
name|insn
index|[
literal|0
index|]
operator|=
name|bfd_getb32
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
else|else
name|insn
index|[
literal|0
index|]
operator|=
name|bfd_getl32
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
call|(
modifier|*
name|func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%08lx\t"
argument_list|,
name|insn
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* The instructions are stored in lists hashed by the insn code      (though we needn't care how they're hashed).  */
name|opcode
operator|=
name|arc_opcode_lookup_dis
argument_list|(
name|insn
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|opcode
operator|!=
name|NULL
condition|;
name|opcode
operator|=
name|ARC_OPCODE_NEXT_DIS
argument_list|(
name|opcode
argument_list|)
control|)
block|{
name|char
modifier|*
name|syn
decl_stmt|;
name|int
name|mods
decl_stmt|,
name|invalid
decl_stmt|;
name|long
name|value
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|opval
decl_stmt|;
comment|/* Basic bit mask must be correct.  */
if|if
condition|(
operator|(
name|insn
index|[
literal|0
index|]
operator|&
name|opcode
operator|->
name|mask
operator|)
operator|!=
name|opcode
operator|->
name|value
condition|)
continue|continue;
comment|/* Supported by this cpu?  */
if|if
condition|(
operator|!
name|arc_opcode_supported
argument_list|(
name|opcode
argument_list|)
condition|)
continue|continue;
comment|/* Make two passes over the operands.  First see if any of them 	 have extraction functions, and, if they do, make sure the 	 instruction is valid.  */
name|arc_opcode_init_extract
argument_list|()
expr_stmt|;
name|invalid
operator|=
literal|0
expr_stmt|;
comment|/* ??? Granted, this is slower than the `ppc' way.  Maybe when this is 	 done it'll be clear what the right way to do this is.  */
comment|/* Instructions like "add.f r0,r1,1" are tricky because the ".f" gets 	 printed first, but we don't know how to print it until we've processed 	 the regs.  Since we're scanning all the args before printing the insn 	 anyways, it's actually quite easy.  */
for|for
control|(
name|syn
operator|=
name|opcode
operator|->
name|syntax
init|;
operator|*
name|syn
condition|;
operator|++
name|syn
control|)
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|*
name|syn
operator|!=
literal|'%'
operator|||
operator|*
operator|++
name|syn
operator|==
literal|'%'
condition|)
continue|continue;
name|mods
operator|=
literal|0
expr_stmt|;
name|c
operator|=
operator|*
name|syn
expr_stmt|;
while|while
condition|(
name|ARC_MOD_P
argument_list|(
name|arc_operands
index|[
name|arc_operand_map
index|[
name|c
index|]
index|]
operator|.
name|flags
argument_list|)
condition|)
block|{
name|mods
operator||=
name|arc_operands
index|[
name|arc_operand_map
index|[
name|c
index|]
index|]
operator|.
name|flags
operator|&
name|ARC_MOD_BITS
expr_stmt|;
operator|++
name|syn
expr_stmt|;
name|c
operator|=
operator|*
name|syn
expr_stmt|;
block|}
name|operand
operator|=
name|arc_operands
operator|+
name|arc_operand_map
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|extract
condition|)
call|(
modifier|*
name|operand
operator|->
name|extract
call|)
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|mods
argument_list|,
operator|(
specifier|const
expr|struct
name|arc_operand_value
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|invalid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|invalid
condition|)
continue|continue;
comment|/* The instruction is valid.  */
comment|/* If we have an insn with a limm, fetch it now.  Scanning the insns 	 twice lets us do this.  */
if|if
condition|(
name|arc_opcode_limm_p
argument_list|(
name|NULL
argument_list|)
condition|)
block|{
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|pc
operator|+
literal|4
argument_list|,
name|buffer
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|memory_error_func
call|)
argument_list|(
name|status
argument_list|,
name|pc
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|big_p
condition|)
name|insn
index|[
literal|1
index|]
operator|=
name|bfd_getb32
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
else|else
name|insn
index|[
literal|1
index|]
operator|=
name|bfd_getl32
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|got_limm_p
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|syn
operator|=
name|opcode
operator|->
name|syntax
init|;
operator|*
name|syn
condition|;
operator|++
name|syn
control|)
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|*
name|syn
operator|!=
literal|'%'
operator|||
operator|*
operator|++
name|syn
operator|==
literal|'%'
condition|)
block|{
call|(
modifier|*
name|func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|syn
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* We have an operand.  Fetch any special modifiers.  */
name|mods
operator|=
literal|0
expr_stmt|;
name|c
operator|=
operator|*
name|syn
expr_stmt|;
while|while
condition|(
name|ARC_MOD_P
argument_list|(
name|arc_operands
index|[
name|arc_operand_map
index|[
name|c
index|]
index|]
operator|.
name|flags
argument_list|)
condition|)
block|{
name|mods
operator||=
name|arc_operands
index|[
name|arc_operand_map
index|[
name|c
index|]
index|]
operator|.
name|flags
operator|&
name|ARC_MOD_BITS
expr_stmt|;
operator|++
name|syn
expr_stmt|;
name|c
operator|=
operator|*
name|syn
expr_stmt|;
block|}
name|operand
operator|=
name|arc_operands
operator|+
name|arc_operand_map
index|[
name|c
index|]
expr_stmt|;
comment|/* Extract the value from the instruction.  */
name|opval
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|extract
condition|)
block|{
name|value
operator|=
call|(
modifier|*
name|operand
operator|->
name|extract
call|)
argument_list|(
name|insn
argument_list|,
name|operand
argument_list|,
name|mods
argument_list|,
operator|&
name|opval
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
operator|(
name|insn
index|[
literal|0
index|]
operator|>>
name|operand
operator|->
name|shift
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_SIGNED
operator|)
operator|&&
operator|(
name|value
operator|&
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|value
operator|-=
literal|1
operator|<<
name|operand
operator|->
name|bits
expr_stmt|;
comment|/* If this is a suffix operand, set `opval'.  */
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_SUFFIX
condition|)
name|opval
operator|=
name|arc_opcode_lookup_suffix
argument_list|(
name|operand
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* Print the operand as directed by the flags.  */
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_FAKE
condition|)
empty_stmt|;
comment|/* nothing to do (??? at least not yet) */
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_SUFFIX
condition|)
block|{
comment|/* Default suffixes aren't printed.  Fortunately, they all have 		 zero values.  Also, zero values for boolean suffixes are 		 represented by the absence of text.  */
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
block|{
comment|/* ??? OPVAL should have a value.  If it doesn't just cope 		     as we want disassembly to be reasonably robust. 		     Also remember that several condition code values (16-31) 		     aren't defined yet.  For these cases just print the 		     number suitably decorated.  */
if|if
condition|(
name|opval
condition|)
call|(
modifier|*
name|func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%s%s"
argument_list|,
name|mods
operator|&
name|ARC_MOD_DOT
condition|?
literal|"."
else|:
literal|""
argument_list|,
name|opval
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%s%c%d"
argument_list|,
name|mods
operator|&
name|ARC_MOD_DOT
condition|?
literal|"."
else|:
literal|""
argument_list|,
name|operand
operator|->
name|fmt
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_RELATIVE_BRANCH
condition|)
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|pc
operator|+
literal|4
operator|+
name|value
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* ??? Not all cases of this are currently caught.  */
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_ABSOLUTE_BRANCH
condition|)
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
operator|&
literal|0xffffffff
argument_list|,
name|info
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_ADDRESS
condition|)
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
operator|&
literal|0xffffffff
argument_list|,
name|info
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opval
condition|)
comment|/* Note that this case catches both normal and auxiliary regs.  */
call|(
modifier|*
name|func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|opval
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%ld"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* We have found and printed an instruction; return.  */
return|return
name|got_limm_p
condition|?
literal|8
else|:
literal|4
return|;
block|}
call|(
modifier|*
name|func
call|)
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"*unknown*"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|4
return|;
block|}
end_function

begin_comment
comment|/* Given MACH, one of bfd_mach_arc_xxx, return the print_insn function to use.    This does things a non-standard way (the "standard" way would be to copy    this code into disassemble.c).  Since there are more than a couple of    variants, hiding all this crud here seems cleaner.  */
end_comment

begin_function
name|disassembler_ftype
name|arc_get_disassembler
parameter_list|(
name|mach
parameter_list|,
name|big_p
parameter_list|)
name|int
name|mach
decl_stmt|;
name|int
name|big_p
decl_stmt|;
block|{
switch|switch
condition|(
name|mach
condition|)
block|{
case|case
name|bfd_mach_arc_base
case|:
return|return
name|big_p
condition|?
name|print_insn_arc_base_big
else|:
name|print_insn_arc_base_little
return|;
block|}
return|return
name|print_insn_arc_base_little
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|print_insn_arc_base_little
parameter_list|(
name|pc
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|pc
decl_stmt|;
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
return|return
name|print_insn
argument_list|(
name|pc
argument_list|,
name|info
argument_list|,
name|bfd_mach_arc_base
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|print_insn_arc_base_big
parameter_list|(
name|pc
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|pc
decl_stmt|;
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
return|return
name|print_insn
argument_list|(
name|pc
argument_list|,
name|info
argument_list|,
name|bfd_mach_arc_base
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

end_unit

