begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* CGEN generic opcode support.  Copyright (C) 1996, 1997 Free Software Foundation, Inc.  This file is part of the GNU Binutils and GDB, the GNU debugger.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"opcode/cgen.h"
end_include

begin_comment
comment|/* State variables.    These record the state of the currently selected cpu, machine, endian, etc.    They are set by cgen_set_cpu.  */
end_comment

begin_comment
comment|/* Current opcode data.  */
end_comment

begin_decl_stmt
name|CGEN_OPCODE_DATA
modifier|*
name|cgen_current_opcode_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current machine (a la BFD machine number).  */
end_comment

begin_decl_stmt
name|int
name|cgen_current_mach
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current endian.  */
end_comment

begin_decl_stmt
name|enum
name|cgen_endian
name|cgen_current_endian
init|=
name|CGEN_ENDIAN_UNKNOWN
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|cgen_set_cpu
parameter_list|(
name|data
parameter_list|,
name|mach
parameter_list|,
name|endian
parameter_list|)
name|CGEN_OPCODE_DATA
modifier|*
name|data
decl_stmt|;
name|int
name|mach
decl_stmt|;
name|enum
name|cgen_endian
name|endian
decl_stmt|;
block|{
name|cgen_current_opcode_data
operator|=
name|data
expr_stmt|;
name|cgen_current_mach
operator|=
name|mach
expr_stmt|;
name|cgen_current_endian
operator|=
name|endian
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This isn't done here because it would put assembler support in the 	 disassembler, etc.  The caller is required to call these after calling 	 us.  */
comment|/* Reset the hash tables.  */
block|cgen_asm_init ();   cgen_dis_init ();
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|hash_keyword_name
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|cgen_keyword
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|hash_keyword_value
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|cgen_keyword
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_keyword_hash_tables
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cgen_keyword
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return number of hash table entries to use for N elements.  */
end_comment

begin_define
define|#
directive|define
name|KEYWORD_HASH_SIZE
parameter_list|(
name|n
parameter_list|)
value|((n)<= 31 ? 17 : 31)
end_define

begin_comment
comment|/* Look up *NAMEP in the keyword table KT.    The result is the keyword entry or NULL if not found.  */
end_comment

begin_function
specifier|const
name|struct
name|cgen_keyword_entry
modifier|*
name|cgen_keyword_lookup_name
parameter_list|(
name|kt
parameter_list|,
name|name
parameter_list|)
name|struct
name|cgen_keyword
modifier|*
name|kt
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|const
name|struct
name|cgen_keyword_entry
modifier|*
name|ke
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|kt
operator|->
name|name_hash_table
operator|==
name|NULL
condition|)
name|build_keyword_hash_tables
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|ke
operator|=
name|kt
operator|->
name|name_hash_table
index|[
name|hash_keyword_name
argument_list|(
name|kt
argument_list|,
name|name
argument_list|)
index|]
expr_stmt|;
comment|/* We do case insensitive comparisons.      If that ever becomes a problem, add an attribute that denotes      "do case sensitive comparisons".  */
while|while
condition|(
name|ke
operator|!=
name|NULL
condition|)
block|{
name|n
operator|=
name|name
expr_stmt|;
name|p
operator|=
name|ke
operator|->
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
operator|*
name|p
operator|==
operator|*
name|n
operator|||
operator|(
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
operator|==
name|tolower
argument_list|(
operator|*
name|n
argument_list|)
operator|)
operator|)
condition|)
operator|++
name|n
operator|,
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
operator|&&
operator|!
operator|*
name|n
condition|)
return|return
name|ke
return|;
name|ke
operator|=
name|ke
operator|->
name|next_name
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Look up VALUE in the keyword table KT.    The result is the keyword entry or NULL if not found.  */
end_comment

begin_function
specifier|const
name|struct
name|cgen_keyword_entry
modifier|*
name|cgen_keyword_lookup_value
parameter_list|(
name|kt
parameter_list|,
name|value
parameter_list|)
name|struct
name|cgen_keyword
modifier|*
name|kt
decl_stmt|;
name|int
name|value
decl_stmt|;
block|{
specifier|const
name|struct
name|cgen_keyword_entry
modifier|*
name|ke
decl_stmt|;
if|if
condition|(
name|kt
operator|->
name|name_hash_table
operator|==
name|NULL
condition|)
name|build_keyword_hash_tables
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|ke
operator|=
name|kt
operator|->
name|value_hash_table
index|[
name|hash_keyword_value
argument_list|(
name|kt
argument_list|,
name|value
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|ke
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|value
operator|==
name|ke
operator|->
name|value
condition|)
return|return
name|ke
return|;
name|ke
operator|=
name|ke
operator|->
name|next_value
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Add an entry to a keyword table.  */
end_comment

begin_function
name|void
name|cgen_keyword_add
parameter_list|(
name|kt
parameter_list|,
name|ke
parameter_list|)
name|struct
name|cgen_keyword
modifier|*
name|kt
decl_stmt|;
name|struct
name|cgen_keyword_entry
modifier|*
name|ke
decl_stmt|;
block|{
name|unsigned
name|int
name|hash
decl_stmt|;
if|if
condition|(
name|kt
operator|->
name|name_hash_table
operator|==
name|NULL
condition|)
name|build_keyword_hash_tables
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|hash
operator|=
name|hash_keyword_name
argument_list|(
name|kt
argument_list|,
name|ke
operator|->
name|name
argument_list|)
expr_stmt|;
name|ke
operator|->
name|next_name
operator|=
name|kt
operator|->
name|name_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|kt
operator|->
name|name_hash_table
index|[
name|hash
index|]
operator|=
name|ke
expr_stmt|;
name|hash
operator|=
name|hash_keyword_value
argument_list|(
name|kt
argument_list|,
name|ke
operator|->
name|value
argument_list|)
expr_stmt|;
name|ke
operator|->
name|next_value
operator|=
name|kt
operator|->
name|value_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|kt
operator|->
name|value_hash_table
index|[
name|hash
index|]
operator|=
name|ke
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FIXME: Need function to return count of keywords.  */
end_comment

begin_comment
comment|/* Initialize a keyword table search.    SPEC is a specification of what to search for.    A value of NULL means to find every keyword.    Currently NULL is the only acceptable value [further specification    deferred].    The result is an opaque data item used to record the search status.    It is passed to each call to cgen_keyword_search_next.  */
end_comment

begin_function
name|struct
name|cgen_keyword_search
name|cgen_keyword_search_init
parameter_list|(
name|kt
parameter_list|,
name|spec
parameter_list|)
name|struct
name|cgen_keyword
modifier|*
name|kt
decl_stmt|;
specifier|const
name|char
modifier|*
name|spec
decl_stmt|;
block|{
name|struct
name|cgen_keyword_search
name|search
decl_stmt|;
comment|/* FIXME: Need to specify format of PARAMS.  */
if|if
condition|(
name|spec
operator|!=
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|kt
operator|->
name|name_hash_table
operator|==
name|NULL
condition|)
name|build_keyword_hash_tables
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|search
operator|.
name|table
operator|=
name|kt
expr_stmt|;
name|search
operator|.
name|spec
operator|=
name|spec
expr_stmt|;
name|search
operator|.
name|current_hash
operator|=
literal|0
expr_stmt|;
name|search
operator|.
name|current_entry
operator|=
name|NULL
expr_stmt|;
return|return
name|search
return|;
block|}
end_function

begin_comment
comment|/* Return the next keyword specified by SEARCH.    The result is the next entry or NULL if there are no more.  */
end_comment

begin_function
specifier|const
name|struct
name|cgen_keyword_entry
modifier|*
name|cgen_keyword_search_next
parameter_list|(
name|search
parameter_list|)
name|struct
name|cgen_keyword_search
modifier|*
name|search
decl_stmt|;
block|{
specifier|const
name|struct
name|cgen_keyword_entry
modifier|*
name|ke
decl_stmt|;
comment|/* Has search finished?  */
if|if
condition|(
name|search
operator|->
name|current_hash
operator|==
name|search
operator|->
name|table
operator|->
name|hash_table_size
condition|)
return|return
name|NULL
return|;
comment|/* Search in progress?  */
if|if
condition|(
name|search
operator|->
name|current_entry
operator|!=
name|NULL
comment|/* Anything left on this hash chain?  */
operator|&&
name|search
operator|->
name|current_entry
operator|->
name|next_name
operator|!=
name|NULL
condition|)
block|{
name|search
operator|->
name|current_entry
operator|=
name|search
operator|->
name|current_entry
operator|->
name|next_name
expr_stmt|;
return|return
name|search
operator|->
name|current_entry
return|;
block|}
comment|/* Move to next hash chain [unless we haven't started yet].  */
if|if
condition|(
name|search
operator|->
name|current_entry
operator|!=
name|NULL
condition|)
operator|++
name|search
operator|->
name|current_hash
expr_stmt|;
while|while
condition|(
name|search
operator|->
name|current_hash
operator|<
name|search
operator|->
name|table
operator|->
name|hash_table_size
condition|)
block|{
name|search
operator|->
name|current_entry
operator|=
name|search
operator|->
name|table
operator|->
name|name_hash_table
index|[
name|search
operator|->
name|current_hash
index|]
expr_stmt|;
if|if
condition|(
name|search
operator|->
name|current_entry
operator|!=
name|NULL
condition|)
return|return
name|search
operator|->
name|current_entry
return|;
operator|++
name|search
operator|->
name|current_hash
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return first entry in hash chain for NAME.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|hash_keyword_name
parameter_list|(
name|kt
parameter_list|,
name|name
parameter_list|)
specifier|const
name|struct
name|cgen_keyword
modifier|*
name|kt
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|unsigned
name|int
name|hash
decl_stmt|;
for|for
control|(
name|hash
operator|=
literal|0
init|;
operator|*
name|name
condition|;
operator|++
name|name
control|)
name|hash
operator|=
operator|(
name|hash
operator|*
literal|97
operator|)
operator|+
operator|(
name|unsigned
name|char
operator|)
operator|*
name|name
expr_stmt|;
return|return
name|hash
operator|%
name|kt
operator|->
name|hash_table_size
return|;
block|}
end_function

begin_comment
comment|/* Return first entry in hash chain for VALUE.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|hash_keyword_value
parameter_list|(
name|kt
parameter_list|,
name|value
parameter_list|)
specifier|const
name|struct
name|cgen_keyword
modifier|*
name|kt
decl_stmt|;
name|int
name|value
decl_stmt|;
block|{
return|return
name|value
operator|%
name|kt
operator|->
name|hash_table_size
return|;
block|}
end_function

begin_comment
comment|/* Build a keyword table's hash tables.    We probably needn't build the value hash table for the assembler when    we're using the disassembler, but we keep things simple.  */
end_comment

begin_function
specifier|static
name|void
name|build_keyword_hash_tables
parameter_list|(
name|kt
parameter_list|)
name|struct
name|cgen_keyword
modifier|*
name|kt
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Use the number of compiled in entries as an estimate for the      typical sized table [not too many added at runtime].  */
name|unsigned
name|int
name|size
init|=
name|KEYWORD_HASH_SIZE
argument_list|(
name|kt
operator|->
name|num_init_entries
argument_list|)
decl_stmt|;
name|kt
operator|->
name|hash_table_size
operator|=
name|size
expr_stmt|;
name|kt
operator|->
name|name_hash_table
operator|=
operator|(
expr|struct
name|cgen_keyword_entry
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cgen_keyword_entry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|kt
operator|->
name|name_hash_table
argument_list|,
literal|0
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cgen_keyword_entry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|->
name|value_hash_table
operator|=
operator|(
expr|struct
name|cgen_keyword_entry
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cgen_keyword_entry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|kt
operator|->
name|value_hash_table
argument_list|,
literal|0
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cgen_keyword_entry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The table is scanned backwards as we want keywords appearing earlier to      be prefered over later ones.  */
for|for
control|(
name|i
operator|=
name|kt
operator|->
name|num_init_entries
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|cgen_keyword_add
argument_list|(
name|kt
argument_list|,
operator|&
name|kt
operator|->
name|init_entries
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hardware support.  */
end_comment

begin_function
name|CGEN_HW_ENTRY
modifier|*
name|cgen_hw_lookup
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|CGEN_HW_ENTRY
modifier|*
name|hw
init|=
name|cgen_current_opcode_data
operator|->
name|hw_list
decl_stmt|;
while|while
condition|(
name|hw
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|hw
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|hw
return|;
name|hw
operator|=
name|hw
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Instruction support.  */
end_comment

begin_comment
comment|/* Return number of instructions.  This includes any added at runtime.  */
end_comment

begin_function
name|int
name|cgen_insn_count
parameter_list|()
block|{
name|int
name|count
init|=
name|cgen_current_opcode_data
operator|->
name|insn_table
operator|->
name|num_init_entries
decl_stmt|;
name|CGEN_INSN_LIST
modifier|*
name|insn
init|=
name|cgen_current_opcode_data
operator|->
name|insn_table
operator|->
name|new_entries
decl_stmt|;
for|for
control|(
init|;
name|insn
operator|!=
name|NULL
condition|;
name|insn
operator|=
name|insn
operator|->
name|next
control|)
operator|++
name|count
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

end_unit

