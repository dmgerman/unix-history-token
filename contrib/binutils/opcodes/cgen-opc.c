begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* CGEN generic opcode support.     Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2005    Free Software Foundation, Inc.     This file is part of the GNU Binutils and GDB, the GNU debugger.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symcat.h"
end_include

begin_include
include|#
directive|include
file|"opcode/cgen.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ALLOCA_H
end_ifdef

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|unsigned
name|int
name|hash_keyword_name
parameter_list|(
specifier|const
name|CGEN_KEYWORD
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|hash_keyword_value
parameter_list|(
specifier|const
name|CGEN_KEYWORD
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_keyword_hash_tables
parameter_list|(
name|CGEN_KEYWORD
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Return number of hash table entries to use for N elements.  */
end_comment

begin_define
define|#
directive|define
name|KEYWORD_HASH_SIZE
parameter_list|(
name|n
parameter_list|)
value|((n)<= 31 ? 17 : 31)
end_define

begin_comment
comment|/* Look up *NAMEP in the keyword table KT.    The result is the keyword entry or NULL if not found.  */
end_comment

begin_function
specifier|const
name|CGEN_KEYWORD_ENTRY
modifier|*
name|cgen_keyword_lookup_name
parameter_list|(
name|CGEN_KEYWORD
modifier|*
name|kt
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|CGEN_KEYWORD_ENTRY
modifier|*
name|ke
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|kt
operator|->
name|name_hash_table
operator|==
name|NULL
condition|)
name|build_keyword_hash_tables
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|ke
operator|=
name|kt
operator|->
name|name_hash_table
index|[
name|hash_keyword_name
argument_list|(
name|kt
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
index|]
expr_stmt|;
comment|/* We do case insensitive comparisons.      If that ever becomes a problem, add an attribute that denotes      "do case sensitive comparisons".  */
while|while
condition|(
name|ke
operator|!=
name|NULL
condition|)
block|{
name|n
operator|=
name|name
expr_stmt|;
name|p
operator|=
name|ke
operator|->
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
operator|*
name|p
operator|==
operator|*
name|n
operator|||
operator|(
name|ISALPHA
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|(
name|TOLOWER
argument_list|(
operator|*
name|p
argument_list|)
operator|==
name|TOLOWER
argument_list|(
operator|*
name|n
argument_list|)
operator|)
operator|)
operator|)
condition|)
operator|++
name|n
operator|,
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
operator|&&
operator|!
operator|*
name|n
condition|)
return|return
name|ke
return|;
name|ke
operator|=
name|ke
operator|->
name|next_name
expr_stmt|;
block|}
if|if
condition|(
name|kt
operator|->
name|null_entry
condition|)
return|return
name|kt
operator|->
name|null_entry
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Look up VALUE in the keyword table KT.    The result is the keyword entry or NULL if not found.  */
end_comment

begin_function
specifier|const
name|CGEN_KEYWORD_ENTRY
modifier|*
name|cgen_keyword_lookup_value
parameter_list|(
name|CGEN_KEYWORD
modifier|*
name|kt
parameter_list|,
name|int
name|value
parameter_list|)
block|{
specifier|const
name|CGEN_KEYWORD_ENTRY
modifier|*
name|ke
decl_stmt|;
if|if
condition|(
name|kt
operator|->
name|name_hash_table
operator|==
name|NULL
condition|)
name|build_keyword_hash_tables
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|ke
operator|=
name|kt
operator|->
name|value_hash_table
index|[
name|hash_keyword_value
argument_list|(
name|kt
argument_list|,
name|value
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|ke
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|value
operator|==
name|ke
operator|->
name|value
condition|)
return|return
name|ke
return|;
name|ke
operator|=
name|ke
operator|->
name|next_value
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Add an entry to a keyword table.  */
end_comment

begin_function
name|void
name|cgen_keyword_add
parameter_list|(
name|CGEN_KEYWORD
modifier|*
name|kt
parameter_list|,
name|CGEN_KEYWORD_ENTRY
modifier|*
name|ke
parameter_list|)
block|{
name|unsigned
name|int
name|hash
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|kt
operator|->
name|name_hash_table
operator|==
name|NULL
condition|)
name|build_keyword_hash_tables
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|hash
operator|=
name|hash_keyword_name
argument_list|(
name|kt
argument_list|,
name|ke
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ke
operator|->
name|next_name
operator|=
name|kt
operator|->
name|name_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|kt
operator|->
name|name_hash_table
index|[
name|hash
index|]
operator|=
name|ke
expr_stmt|;
name|hash
operator|=
name|hash_keyword_value
argument_list|(
name|kt
argument_list|,
name|ke
operator|->
name|value
argument_list|)
expr_stmt|;
name|ke
operator|->
name|next_value
operator|=
name|kt
operator|->
name|value_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|kt
operator|->
name|value_hash_table
index|[
name|hash
index|]
operator|=
name|ke
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|kt
operator|->
name|null_entry
operator|=
name|ke
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|strlen
argument_list|(
name|ke
operator|->
name|name
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|ISALNUM
argument_list|(
name|ke
operator|->
name|name
index|[
name|i
index|]
argument_list|)
operator|&&
operator|!
name|strchr
argument_list|(
name|kt
operator|->
name|nonalpha_chars
argument_list|,
name|ke
operator|->
name|name
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|size_t
name|idx
init|=
name|strlen
argument_list|(
name|kt
operator|->
name|nonalpha_chars
argument_list|)
decl_stmt|;
comment|/* If you hit this limit, please don't just 	   increase the size of the field, instead 	   look for a better algorithm.  */
if|if
condition|(
name|idx
operator|>=
sizeof|sizeof
argument_list|(
name|kt
operator|->
name|nonalpha_chars
argument_list|)
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|kt
operator|->
name|nonalpha_chars
index|[
name|idx
index|]
operator|=
name|ke
operator|->
name|name
index|[
name|i
index|]
expr_stmt|;
name|kt
operator|->
name|nonalpha_chars
index|[
name|idx
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* FIXME: Need function to return count of keywords.  */
end_comment

begin_comment
comment|/* Initialize a keyword table search.    SPEC is a specification of what to search for.    A value of NULL means to find every keyword.    Currently NULL is the only acceptable value [further specification    deferred].    The result is an opaque data item used to record the search status.    It is passed to each call to cgen_keyword_search_next.  */
end_comment

begin_function
name|CGEN_KEYWORD_SEARCH
name|cgen_keyword_search_init
parameter_list|(
name|CGEN_KEYWORD
modifier|*
name|kt
parameter_list|,
specifier|const
name|char
modifier|*
name|spec
parameter_list|)
block|{
name|CGEN_KEYWORD_SEARCH
name|search
decl_stmt|;
comment|/* FIXME: Need to specify format of params.  */
if|if
condition|(
name|spec
operator|!=
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|kt
operator|->
name|name_hash_table
operator|==
name|NULL
condition|)
name|build_keyword_hash_tables
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|search
operator|.
name|table
operator|=
name|kt
expr_stmt|;
name|search
operator|.
name|spec
operator|=
name|spec
expr_stmt|;
name|search
operator|.
name|current_hash
operator|=
literal|0
expr_stmt|;
name|search
operator|.
name|current_entry
operator|=
name|NULL
expr_stmt|;
return|return
name|search
return|;
block|}
end_function

begin_comment
comment|/* Return the next keyword specified by SEARCH.    The result is the next entry or NULL if there are no more.  */
end_comment

begin_function
specifier|const
name|CGEN_KEYWORD_ENTRY
modifier|*
name|cgen_keyword_search_next
parameter_list|(
name|CGEN_KEYWORD_SEARCH
modifier|*
name|search
parameter_list|)
block|{
comment|/* Has search finished?  */
if|if
condition|(
name|search
operator|->
name|current_hash
operator|==
name|search
operator|->
name|table
operator|->
name|hash_table_size
condition|)
return|return
name|NULL
return|;
comment|/* Search in progress?  */
if|if
condition|(
name|search
operator|->
name|current_entry
operator|!=
name|NULL
comment|/* Anything left on this hash chain?  */
operator|&&
name|search
operator|->
name|current_entry
operator|->
name|next_name
operator|!=
name|NULL
condition|)
block|{
name|search
operator|->
name|current_entry
operator|=
name|search
operator|->
name|current_entry
operator|->
name|next_name
expr_stmt|;
return|return
name|search
operator|->
name|current_entry
return|;
block|}
comment|/* Move to next hash chain [unless we haven't started yet].  */
if|if
condition|(
name|search
operator|->
name|current_entry
operator|!=
name|NULL
condition|)
operator|++
name|search
operator|->
name|current_hash
expr_stmt|;
while|while
condition|(
name|search
operator|->
name|current_hash
operator|<
name|search
operator|->
name|table
operator|->
name|hash_table_size
condition|)
block|{
name|search
operator|->
name|current_entry
operator|=
name|search
operator|->
name|table
operator|->
name|name_hash_table
index|[
name|search
operator|->
name|current_hash
index|]
expr_stmt|;
if|if
condition|(
name|search
operator|->
name|current_entry
operator|!=
name|NULL
condition|)
return|return
name|search
operator|->
name|current_entry
return|;
operator|++
name|search
operator|->
name|current_hash
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return first entry in hash chain for NAME.    If CASE_SENSITIVE_P is non-zero, return a case sensitive hash.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|hash_keyword_name
parameter_list|(
specifier|const
name|CGEN_KEYWORD
modifier|*
name|kt
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|case_sensitive_p
parameter_list|)
block|{
name|unsigned
name|int
name|hash
decl_stmt|;
if|if
condition|(
name|case_sensitive_p
condition|)
for|for
control|(
name|hash
operator|=
literal|0
init|;
operator|*
name|name
condition|;
operator|++
name|name
control|)
name|hash
operator|=
operator|(
name|hash
operator|*
literal|97
operator|)
operator|+
operator|(
name|unsigned
name|char
operator|)
operator|*
name|name
expr_stmt|;
else|else
for|for
control|(
name|hash
operator|=
literal|0
init|;
operator|*
name|name
condition|;
operator|++
name|name
control|)
name|hash
operator|=
operator|(
name|hash
operator|*
literal|97
operator|)
operator|+
operator|(
name|unsigned
name|char
operator|)
name|TOLOWER
argument_list|(
operator|*
name|name
argument_list|)
expr_stmt|;
return|return
name|hash
operator|%
name|kt
operator|->
name|hash_table_size
return|;
block|}
end_function

begin_comment
comment|/* Return first entry in hash chain for VALUE.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|hash_keyword_value
parameter_list|(
specifier|const
name|CGEN_KEYWORD
modifier|*
name|kt
parameter_list|,
name|unsigned
name|int
name|value
parameter_list|)
block|{
return|return
name|value
operator|%
name|kt
operator|->
name|hash_table_size
return|;
block|}
end_function

begin_comment
comment|/* Build a keyword table's hash tables.    We probably needn't build the value hash table for the assembler when    we're using the disassembler, but we keep things simple.  */
end_comment

begin_function
specifier|static
name|void
name|build_keyword_hash_tables
parameter_list|(
name|CGEN_KEYWORD
modifier|*
name|kt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Use the number of compiled in entries as an estimate for the      typical sized table [not too many added at runtime].  */
name|unsigned
name|int
name|size
init|=
name|KEYWORD_HASH_SIZE
argument_list|(
name|kt
operator|->
name|num_init_entries
argument_list|)
decl_stmt|;
name|kt
operator|->
name|hash_table_size
operator|=
name|size
expr_stmt|;
name|kt
operator|->
name|name_hash_table
operator|=
operator|(
name|CGEN_KEYWORD_ENTRY
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|CGEN_KEYWORD_ENTRY
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|kt
operator|->
name|name_hash_table
argument_list|,
literal|0
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|CGEN_KEYWORD_ENTRY
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|->
name|value_hash_table
operator|=
operator|(
name|CGEN_KEYWORD_ENTRY
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|CGEN_KEYWORD_ENTRY
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|kt
operator|->
name|value_hash_table
argument_list|,
literal|0
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|CGEN_KEYWORD_ENTRY
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The table is scanned backwards as we want keywords appearing earlier to      be prefered over later ones.  */
for|for
control|(
name|i
operator|=
name|kt
operator|->
name|num_init_entries
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|cgen_keyword_add
argument_list|(
name|kt
argument_list|,
operator|&
name|kt
operator|->
name|init_entries
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hardware support.  */
end_comment

begin_comment
comment|/* Lookup a hardware element by its name.    Returns NULL if NAME is not supported by the currently selected    mach/isa.  */
end_comment

begin_function
specifier|const
name|CGEN_HW_ENTRY
modifier|*
name|cgen_hw_lookup_by_name
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
specifier|const
name|CGEN_HW_ENTRY
modifier|*
modifier|*
name|hw
init|=
name|cd
operator|->
name|hw_table
operator|.
name|entries
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cd
operator|->
name|hw_table
operator|.
name|num_entries
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|hw
index|[
name|i
index|]
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|hw
index|[
name|i
index|]
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|hw
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Lookup a hardware element by its number.    Hardware elements are enumerated, however it may be possible to add some    at runtime, thus HWNUM is not an enum type but rather an int.    Returns NULL if HWNUM is not supported by the currently selected mach.  */
end_comment

begin_function
specifier|const
name|CGEN_HW_ENTRY
modifier|*
name|cgen_hw_lookup_by_num
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|,
name|unsigned
name|int
name|hwnum
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
specifier|const
name|CGEN_HW_ENTRY
modifier|*
modifier|*
name|hw
init|=
name|cd
operator|->
name|hw_table
operator|.
name|entries
decl_stmt|;
comment|/* ??? This can be speeded up.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cd
operator|->
name|hw_table
operator|.
name|num_entries
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|hw
index|[
name|i
index|]
operator|&&
name|hwnum
operator|==
name|hw
index|[
name|i
index|]
operator|->
name|type
condition|)
return|return
name|hw
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Operand support.  */
end_comment

begin_comment
comment|/* Lookup an operand by its name.    Returns NULL if NAME is not supported by the currently selected    mach/isa.  */
end_comment

begin_function
specifier|const
name|CGEN_OPERAND
modifier|*
name|cgen_operand_lookup_by_name
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
specifier|const
name|CGEN_OPERAND
modifier|*
modifier|*
name|op
init|=
name|cd
operator|->
name|operand_table
operator|.
name|entries
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cd
operator|->
name|operand_table
operator|.
name|num_entries
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|op
index|[
name|i
index|]
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|op
index|[
name|i
index|]
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|op
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Lookup an operand by its number.    Operands are enumerated, however it may be possible to add some    at runtime, thus OPNUM is not an enum type but rather an int.    Returns NULL if OPNUM is not supported by the currently selected    mach/isa.  */
end_comment

begin_function
specifier|const
name|CGEN_OPERAND
modifier|*
name|cgen_operand_lookup_by_num
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|,
name|int
name|opnum
parameter_list|)
block|{
return|return
name|cd
operator|->
name|operand_table
operator|.
name|entries
index|[
name|opnum
index|]
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Instruction support.  */
end_comment

begin_comment
comment|/* Return number of instructions.  This includes any added at runtime.  */
end_comment

begin_function
name|int
name|cgen_insn_count
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|)
block|{
name|int
name|count
init|=
name|cd
operator|->
name|insn_table
operator|.
name|num_init_entries
decl_stmt|;
name|CGEN_INSN_LIST
modifier|*
name|rt_insns
init|=
name|cd
operator|->
name|insn_table
operator|.
name|new_entries
decl_stmt|;
for|for
control|(
init|;
name|rt_insns
operator|!=
name|NULL
condition|;
name|rt_insns
operator|=
name|rt_insns
operator|->
name|next
control|)
operator|++
name|count
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Return number of macro-instructions.    This includes any added at runtime.  */
end_comment

begin_function
name|int
name|cgen_macro_insn_count
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|)
block|{
name|int
name|count
init|=
name|cd
operator|->
name|macro_insn_table
operator|.
name|num_init_entries
decl_stmt|;
name|CGEN_INSN_LIST
modifier|*
name|rt_insns
init|=
name|cd
operator|->
name|macro_insn_table
operator|.
name|new_entries
decl_stmt|;
for|for
control|(
init|;
name|rt_insns
operator|!=
name|NULL
condition|;
name|rt_insns
operator|=
name|rt_insns
operator|->
name|next
control|)
operator|++
name|count
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Cover function to read and properly byteswap an insn value.  */
end_comment

begin_function
name|CGEN_INSN_INT
name|cgen_get_insn_value
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|big_p
init|=
operator|(
name|cd
operator|->
name|insn_endian
operator|==
name|CGEN_ENDIAN_BIG
operator|)
decl_stmt|;
name|int
name|insn_chunk_bitsize
init|=
name|cd
operator|->
name|insn_chunk_bitsize
decl_stmt|;
name|CGEN_INSN_INT
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|insn_chunk_bitsize
operator|!=
literal|0
operator|&&
name|insn_chunk_bitsize
operator|<
name|length
condition|)
block|{
comment|/* We need to divide up the incoming value into insn_chunk_bitsize-length 	 segments, and endian-convert them, one at a time. */
name|int
name|i
decl_stmt|;
comment|/* Enforce divisibility. */
if|if
condition|(
operator|(
name|length
operator|%
name|insn_chunk_bitsize
operator|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|+=
name|insn_chunk_bitsize
control|)
comment|/* NB: i == bits */
block|{
name|int
name|index
decl_stmt|;
name|bfd_vma
name|this_value
decl_stmt|;
name|index
operator|=
name|i
expr_stmt|;
comment|/* NB: not dependent on endianness; opposite of cgen_put_insn_value! */
name|this_value
operator|=
name|bfd_get_bits
argument_list|(
operator|&
name|buf
index|[
name|index
operator|/
literal|8
index|]
argument_list|,
name|insn_chunk_bitsize
argument_list|,
name|big_p
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|<<
name|insn_chunk_bitsize
operator|)
operator||
name|this_value
expr_stmt|;
block|}
block|}
else|else
block|{
name|value
operator|=
name|bfd_get_bits
argument_list|(
name|buf
argument_list|,
name|length
argument_list|,
name|cd
operator|->
name|insn_endian
operator|==
name|CGEN_ENDIAN_BIG
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Cover function to store an insn value properly byteswapped.  */
end_comment

begin_function
name|void
name|cgen_put_insn_value
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|length
parameter_list|,
name|CGEN_INSN_INT
name|value
parameter_list|)
block|{
name|int
name|big_p
init|=
operator|(
name|cd
operator|->
name|insn_endian
operator|==
name|CGEN_ENDIAN_BIG
operator|)
decl_stmt|;
name|int
name|insn_chunk_bitsize
init|=
name|cd
operator|->
name|insn_chunk_bitsize
decl_stmt|;
if|if
condition|(
name|insn_chunk_bitsize
operator|!=
literal|0
operator|&&
name|insn_chunk_bitsize
operator|<
name|length
condition|)
block|{
comment|/* We need to divide up the incoming value into insn_chunk_bitsize-length 	 segments, and endian-convert them, one at a time. */
name|int
name|i
decl_stmt|;
comment|/* Enforce divisibility. */
if|if
condition|(
operator|(
name|length
operator|%
name|insn_chunk_bitsize
operator|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|+=
name|insn_chunk_bitsize
control|)
comment|/* NB: i == bits */
block|{
name|int
name|index
decl_stmt|;
name|index
operator|=
operator|(
name|length
operator|-
name|insn_chunk_bitsize
operator|-
name|i
operator|)
expr_stmt|;
comment|/* NB: not dependent on endianness! */
name|bfd_put_bits
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
operator|&
name|buf
index|[
name|index
operator|/
literal|8
index|]
argument_list|,
name|insn_chunk_bitsize
argument_list|,
name|big_p
argument_list|)
expr_stmt|;
name|value
operator|>>=
name|insn_chunk_bitsize
expr_stmt|;
block|}
block|}
else|else
block|{
name|bfd_put_bits
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
name|buf
argument_list|,
name|length
argument_list|,
name|big_p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look up instruction INSN_*_VALUE and extract its fields.    INSN_INT_VALUE is used if CGEN_INT_INSN_P.    Otherwise INSN_BYTES_VALUE is used.    INSN, if non-null, is the insn table entry.    Otherwise INSN_*_VALUE is examined to compute it.    LENGTH is the bit length of INSN_*_VALUE if known, otherwise 0.    0 is only valid if `insn == NULL&& ! CGEN_INT_INSN_P'.    If INSN != NULL, LENGTH must be valid.    ALIAS_P is non-zero if alias insns are to be included in the search.     The result is a pointer to the insn table entry, or NULL if the instruction    wasn't recognized.  */
end_comment

begin_comment
comment|/* ??? Will need to be revisited for VLIW architectures.  */
end_comment

begin_function
specifier|const
name|CGEN_INSN
modifier|*
name|cgen_lookup_insn
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|,
specifier|const
name|CGEN_INSN
modifier|*
name|insn
parameter_list|,
name|CGEN_INSN_INT
name|insn_int_value
parameter_list|,
comment|/* ??? CGEN_INSN_BYTES would be a nice type name to use here.  */
name|unsigned
name|char
modifier|*
name|insn_bytes_value
parameter_list|,
name|int
name|length
parameter_list|,
name|CGEN_FIELDS
modifier|*
name|fields
parameter_list|,
name|int
name|alias_p
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|CGEN_INSN_INT
name|base_insn
decl_stmt|;
name|CGEN_EXTRACT_INFO
name|ex_info
decl_stmt|;
name|CGEN_EXTRACT_INFO
modifier|*
name|info
decl_stmt|;
if|if
condition|(
name|cd
operator|->
name|int_insn_p
condition|)
block|{
name|info
operator|=
name|NULL
expr_stmt|;
name|buf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|cd
operator|->
name|max_insn_bitsize
operator|/
literal|8
argument_list|)
expr_stmt|;
name|cgen_put_insn_value
argument_list|(
name|cd
argument_list|,
name|buf
argument_list|,
name|length
argument_list|,
name|insn_int_value
argument_list|)
expr_stmt|;
name|base_insn
operator|=
name|insn_int_value
expr_stmt|;
block|}
else|else
block|{
name|info
operator|=
operator|&
name|ex_info
expr_stmt|;
name|ex_info
operator|.
name|dis_info
operator|=
name|NULL
expr_stmt|;
name|ex_info
operator|.
name|insn_bytes
operator|=
name|insn_bytes_value
expr_stmt|;
name|ex_info
operator|.
name|valid
operator|=
operator|-
literal|1
expr_stmt|;
name|buf
operator|=
name|insn_bytes_value
expr_stmt|;
name|base_insn
operator|=
name|cgen_get_insn_value
argument_list|(
name|cd
argument_list|,
name|buf
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|insn
condition|)
block|{
specifier|const
name|CGEN_INSN_LIST
modifier|*
name|insn_list
decl_stmt|;
comment|/* The instructions are stored in hash lists. 	 Pick the first one and keep trying until we find the right one.  */
name|insn_list
operator|=
name|cgen_dis_lookup_insn
argument_list|(
name|cd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|base_insn
argument_list|)
expr_stmt|;
while|while
condition|(
name|insn_list
operator|!=
name|NULL
condition|)
block|{
name|insn
operator|=
name|insn_list
operator|->
name|insn
expr_stmt|;
if|if
condition|(
name|alias_p
comment|/* FIXME: Ensure ALIAS attribute always has same index.  */
operator|||
operator|!
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
argument_list|,
name|CGEN_INSN_ALIAS
argument_list|)
condition|)
block|{
comment|/* Basic bit mask must be correct.  */
comment|/* ??? May wish to allow target to defer this check until the 		 extract handler.  */
if|if
condition|(
operator|(
name|base_insn
operator|&
name|CGEN_INSN_BASE_MASK
argument_list|(
name|insn
argument_list|)
operator|)
operator|==
name|CGEN_INSN_BASE_VALUE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* ??? 0 is passed for `pc' */
name|int
name|elength
init|=
name|CGEN_EXTRACT_FN
argument_list|(
name|cd
argument_list|,
name|insn
argument_list|)
argument_list|(
name|cd
argument_list|,
name|insn
argument_list|,
name|info
argument_list|,
name|base_insn
argument_list|,
name|fields
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|elength
operator|>
literal|0
condition|)
block|{
comment|/* sanity check */
if|if
condition|(
name|length
operator|!=
literal|0
operator|&&
name|length
operator|!=
name|elength
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|insn
return|;
block|}
block|}
block|}
name|insn_list
operator|=
name|insn_list
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Sanity check: can't pass an alias insn if ! alias_p.  */
if|if
condition|(
operator|!
name|alias_p
operator|&&
name|CGEN_INSN_ATTR_VALUE
argument_list|(
name|insn
argument_list|,
name|CGEN_INSN_ALIAS
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Sanity check: length must be correct.  */
if|if
condition|(
name|length
operator|!=
name|CGEN_INSN_BITSIZE
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* ??? 0 is passed for `pc' */
name|length
operator|=
name|CGEN_EXTRACT_FN
argument_list|(
name|cd
argument_list|,
name|insn
argument_list|)
argument_list|(
name|cd
argument_list|,
name|insn
argument_list|,
name|info
argument_list|,
name|base_insn
argument_list|,
name|fields
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Sanity check: must succeed. 	 Could relax this later if it ever proves useful.  */
if|if
condition|(
name|length
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|insn
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Fill in the operand instances used by INSN whose operands are FIELDS.    INDICES is a pointer to a buffer of MAX_OPERAND_INSTANCES ints to be filled    in.  */
end_comment

begin_function
name|void
name|cgen_get_insn_operands
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|,
specifier|const
name|CGEN_INSN
modifier|*
name|insn
parameter_list|,
specifier|const
name|CGEN_FIELDS
modifier|*
name|fields
parameter_list|,
name|int
modifier|*
name|indices
parameter_list|)
block|{
specifier|const
name|CGEN_OPINST
modifier|*
name|opinst
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|insn
operator|->
name|opinst
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|opinst
operator|=
name|insn
operator|->
name|opinst
init|;
name|opinst
operator|->
name|type
operator|!=
name|CGEN_OPINST_END
condition|;
operator|++
name|i
operator|,
operator|++
name|opinst
control|)
block|{
name|enum
name|cgen_operand_type
name|op_type
init|=
name|opinst
operator|->
name|op_type
decl_stmt|;
if|if
condition|(
name|op_type
operator|==
name|CGEN_OPERAND_NIL
condition|)
name|indices
index|[
name|i
index|]
operator|=
name|opinst
operator|->
name|index
expr_stmt|;
else|else
name|indices
index|[
name|i
index|]
operator|=
call|(
modifier|*
name|cd
operator|->
name|get_int_operand
call|)
argument_list|(
name|cd
argument_list|,
name|op_type
argument_list|,
name|fields
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Cover function to cgen_get_insn_operands when either INSN or FIELDS    isn't known.    The INSN, INSN_*_VALUE, and LENGTH arguments are passed to    cgen_lookup_insn unchanged.    INSN_INT_VALUE is used if CGEN_INT_INSN_P.    Otherwise INSN_BYTES_VALUE is used.     The result is the insn table entry or NULL if the instruction wasn't    recognized.  */
end_comment

begin_function
specifier|const
name|CGEN_INSN
modifier|*
name|cgen_lookup_get_insn_operands
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|,
specifier|const
name|CGEN_INSN
modifier|*
name|insn
parameter_list|,
name|CGEN_INSN_INT
name|insn_int_value
parameter_list|,
comment|/* ??? CGEN_INSN_BYTES would be a nice type name to use here.  */
name|unsigned
name|char
modifier|*
name|insn_bytes_value
parameter_list|,
name|int
name|length
parameter_list|,
name|int
modifier|*
name|indices
parameter_list|,
name|CGEN_FIELDS
modifier|*
name|fields
parameter_list|)
block|{
comment|/* Pass non-zero for ALIAS_P only if INSN != NULL.      If INSN == NULL, we want a real insn.  */
name|insn
operator|=
name|cgen_lookup_insn
argument_list|(
name|cd
argument_list|,
name|insn
argument_list|,
name|insn_int_value
argument_list|,
name|insn_bytes_value
argument_list|,
name|length
argument_list|,
name|fields
argument_list|,
name|insn
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
condition|)
return|return
name|NULL
return|;
name|cgen_get_insn_operands
argument_list|(
name|cd
argument_list|,
name|insn
argument_list|,
name|fields
argument_list|,
name|indices
argument_list|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Allow signed overflow of instruction fields.  */
end_comment

begin_function
name|void
name|cgen_set_signed_overflow_ok
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|)
block|{
name|cd
operator|->
name|signed_overflow_ok_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate an error message if a signed field in an instruction overflows.  */
end_comment

begin_function
name|void
name|cgen_clear_signed_overflow_ok
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|)
block|{
name|cd
operator|->
name|signed_overflow_ok_p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Will an error message be generated if a signed field in an instruction overflows ? */
end_comment

begin_function
name|unsigned
name|int
name|cgen_signed_overflow_ok_p
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|)
block|{
return|return
name|cd
operator|->
name|signed_overflow_ok_p
return|;
block|}
end_function

end_unit

