begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* CGEN generic opcode support.     Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.     This file is part of the GNU Binutils and GDB, the GNU debugger.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symcat.h"
end_include

begin_include
include|#
directive|include
file|"opcode/cgen.h"
end_include

begin_comment
comment|/* State variables.    These record the state of the currently selected cpu, machine, endian, etc.    They are set by cgen_set_cpu.  */
end_comment

begin_comment
comment|/* Current opcode data.  */
end_comment

begin_decl_stmt
name|CGEN_OPCODE_DATA
modifier|*
name|cgen_current_opcode_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current machine (a la BFD machine number).  */
end_comment

begin_decl_stmt
name|int
name|cgen_current_mach
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current endian.  */
end_comment

begin_decl_stmt
name|enum
name|cgen_endian
name|cgen_current_endian
init|=
name|CGEN_ENDIAN_UNKNOWN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME: To support multiple architectures, we need to return a handle    to the state set up by this function, and pass the handle back to the    other functions.  Later.  */
end_comment

begin_function
name|void
name|cgen_set_cpu
parameter_list|(
name|data
parameter_list|,
name|mach
parameter_list|,
name|endian
parameter_list|)
name|CGEN_OPCODE_DATA
modifier|*
name|data
decl_stmt|;
name|int
name|mach
decl_stmt|;
name|enum
name|cgen_endian
name|endian
decl_stmt|;
block|{
specifier|static
name|int
name|init_once_p
decl_stmt|;
name|cgen_current_opcode_data
operator|=
name|data
expr_stmt|;
name|cgen_current_mach
operator|=
name|mach
expr_stmt|;
name|cgen_current_endian
operator|=
name|endian
expr_stmt|;
comment|/* Initialize those things that only need be done once.  */
if|if
condition|(
operator|!
name|init_once_p
condition|)
block|{
comment|/* Nothing to do currently.  */
name|init_once_p
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* This isn't done here because it would put assembler support in the 	 disassembler, etc.  The caller is required to call these after calling 	 us.  */
comment|/* Reset the hash tables.  */
block|cgen_asm_init ();   cgen_dis_init ();
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|hash_keyword_name
name|PARAMS
argument_list|(
operator|(
specifier|const
name|CGEN_KEYWORD
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|hash_keyword_value
name|PARAMS
argument_list|(
operator|(
specifier|const
name|CGEN_KEYWORD
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_keyword_hash_tables
name|PARAMS
argument_list|(
operator|(
name|CGEN_KEYWORD
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return number of hash table entries to use for N elements.  */
end_comment

begin_define
define|#
directive|define
name|KEYWORD_HASH_SIZE
parameter_list|(
name|n
parameter_list|)
value|((n)<= 31 ? 17 : 31)
end_define

begin_comment
comment|/* Look up *NAMEP in the keyword table KT.    The result is the keyword entry or NULL if not found.  */
end_comment

begin_function
specifier|const
name|CGEN_KEYWORD_ENTRY
modifier|*
name|cgen_keyword_lookup_name
parameter_list|(
name|kt
parameter_list|,
name|name
parameter_list|)
name|CGEN_KEYWORD
modifier|*
name|kt
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|const
name|CGEN_KEYWORD_ENTRY
modifier|*
name|ke
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|kt
operator|->
name|name_hash_table
operator|==
name|NULL
condition|)
name|build_keyword_hash_tables
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|ke
operator|=
name|kt
operator|->
name|name_hash_table
index|[
name|hash_keyword_name
argument_list|(
name|kt
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
index|]
expr_stmt|;
comment|/* We do case insensitive comparisons.      If that ever becomes a problem, add an attribute that denotes      "do case sensitive comparisons".  */
while|while
condition|(
name|ke
operator|!=
name|NULL
condition|)
block|{
name|n
operator|=
name|name
expr_stmt|;
name|p
operator|=
name|ke
operator|->
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
operator|*
name|p
operator|==
operator|*
name|n
operator|||
operator|(
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
operator|&&
operator|(
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
operator|==
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|n
argument_list|)
operator|)
operator|)
operator|)
condition|)
operator|++
name|n
operator|,
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
operator|&&
operator|!
operator|*
name|n
condition|)
return|return
name|ke
return|;
name|ke
operator|=
name|ke
operator|->
name|next_name
expr_stmt|;
block|}
if|if
condition|(
name|kt
operator|->
name|null_entry
condition|)
return|return
name|kt
operator|->
name|null_entry
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Look up VALUE in the keyword table KT.    The result is the keyword entry or NULL if not found.  */
end_comment

begin_function
specifier|const
name|CGEN_KEYWORD_ENTRY
modifier|*
name|cgen_keyword_lookup_value
parameter_list|(
name|kt
parameter_list|,
name|value
parameter_list|)
name|CGEN_KEYWORD
modifier|*
name|kt
decl_stmt|;
name|int
name|value
decl_stmt|;
block|{
specifier|const
name|CGEN_KEYWORD_ENTRY
modifier|*
name|ke
decl_stmt|;
if|if
condition|(
name|kt
operator|->
name|name_hash_table
operator|==
name|NULL
condition|)
name|build_keyword_hash_tables
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|ke
operator|=
name|kt
operator|->
name|value_hash_table
index|[
name|hash_keyword_value
argument_list|(
name|kt
argument_list|,
name|value
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|ke
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|value
operator|==
name|ke
operator|->
name|value
condition|)
return|return
name|ke
return|;
name|ke
operator|=
name|ke
operator|->
name|next_value
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Add an entry to a keyword table.  */
end_comment

begin_function
name|void
name|cgen_keyword_add
parameter_list|(
name|kt
parameter_list|,
name|ke
parameter_list|)
name|CGEN_KEYWORD
modifier|*
name|kt
decl_stmt|;
name|CGEN_KEYWORD_ENTRY
modifier|*
name|ke
decl_stmt|;
block|{
name|unsigned
name|int
name|hash
decl_stmt|;
if|if
condition|(
name|kt
operator|->
name|name_hash_table
operator|==
name|NULL
condition|)
name|build_keyword_hash_tables
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|hash
operator|=
name|hash_keyword_name
argument_list|(
name|kt
argument_list|,
name|ke
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ke
operator|->
name|next_name
operator|=
name|kt
operator|->
name|name_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|kt
operator|->
name|name_hash_table
index|[
name|hash
index|]
operator|=
name|ke
expr_stmt|;
name|hash
operator|=
name|hash_keyword_value
argument_list|(
name|kt
argument_list|,
name|ke
operator|->
name|value
argument_list|)
expr_stmt|;
name|ke
operator|->
name|next_value
operator|=
name|kt
operator|->
name|value_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|kt
operator|->
name|value_hash_table
index|[
name|hash
index|]
operator|=
name|ke
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|kt
operator|->
name|null_entry
operator|=
name|ke
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FIXME: Need function to return count of keywords.  */
end_comment

begin_comment
comment|/* Initialize a keyword table search.    SPEC is a specification of what to search for.    A value of NULL means to find every keyword.    Currently NULL is the only acceptable value [further specification    deferred].    The result is an opaque data item used to record the search status.    It is passed to each call to cgen_keyword_search_next.  */
end_comment

begin_function
name|CGEN_KEYWORD_SEARCH
name|cgen_keyword_search_init
parameter_list|(
name|kt
parameter_list|,
name|spec
parameter_list|)
name|CGEN_KEYWORD
modifier|*
name|kt
decl_stmt|;
specifier|const
name|char
modifier|*
name|spec
decl_stmt|;
block|{
name|CGEN_KEYWORD_SEARCH
name|search
decl_stmt|;
comment|/* FIXME: Need to specify format of PARAMS.  */
if|if
condition|(
name|spec
operator|!=
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|kt
operator|->
name|name_hash_table
operator|==
name|NULL
condition|)
name|build_keyword_hash_tables
argument_list|(
name|kt
argument_list|)
expr_stmt|;
name|search
operator|.
name|table
operator|=
name|kt
expr_stmt|;
name|search
operator|.
name|spec
operator|=
name|spec
expr_stmt|;
name|search
operator|.
name|current_hash
operator|=
literal|0
expr_stmt|;
name|search
operator|.
name|current_entry
operator|=
name|NULL
expr_stmt|;
return|return
name|search
return|;
block|}
end_function

begin_comment
comment|/* Return the next keyword specified by SEARCH.    The result is the next entry or NULL if there are no more.  */
end_comment

begin_function
specifier|const
name|CGEN_KEYWORD_ENTRY
modifier|*
name|cgen_keyword_search_next
parameter_list|(
name|search
parameter_list|)
name|CGEN_KEYWORD_SEARCH
modifier|*
name|search
decl_stmt|;
block|{
comment|/* Has search finished?  */
if|if
condition|(
name|search
operator|->
name|current_hash
operator|==
name|search
operator|->
name|table
operator|->
name|hash_table_size
condition|)
return|return
name|NULL
return|;
comment|/* Search in progress?  */
if|if
condition|(
name|search
operator|->
name|current_entry
operator|!=
name|NULL
comment|/* Anything left on this hash chain?  */
operator|&&
name|search
operator|->
name|current_entry
operator|->
name|next_name
operator|!=
name|NULL
condition|)
block|{
name|search
operator|->
name|current_entry
operator|=
name|search
operator|->
name|current_entry
operator|->
name|next_name
expr_stmt|;
return|return
name|search
operator|->
name|current_entry
return|;
block|}
comment|/* Move to next hash chain [unless we haven't started yet].  */
if|if
condition|(
name|search
operator|->
name|current_entry
operator|!=
name|NULL
condition|)
operator|++
name|search
operator|->
name|current_hash
expr_stmt|;
while|while
condition|(
name|search
operator|->
name|current_hash
operator|<
name|search
operator|->
name|table
operator|->
name|hash_table_size
condition|)
block|{
name|search
operator|->
name|current_entry
operator|=
name|search
operator|->
name|table
operator|->
name|name_hash_table
index|[
name|search
operator|->
name|current_hash
index|]
expr_stmt|;
if|if
condition|(
name|search
operator|->
name|current_entry
operator|!=
name|NULL
condition|)
return|return
name|search
operator|->
name|current_entry
return|;
operator|++
name|search
operator|->
name|current_hash
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return first entry in hash chain for NAME.    If CASE_SENSITIVE_P is non-zero, return a case sensitive hash.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|hash_keyword_name
parameter_list|(
name|kt
parameter_list|,
name|name
parameter_list|,
name|case_sensitive_p
parameter_list|)
specifier|const
name|CGEN_KEYWORD
modifier|*
name|kt
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|case_sensitive_p
decl_stmt|;
block|{
name|unsigned
name|int
name|hash
decl_stmt|;
if|if
condition|(
name|case_sensitive_p
condition|)
for|for
control|(
name|hash
operator|=
literal|0
init|;
operator|*
name|name
condition|;
operator|++
name|name
control|)
name|hash
operator|=
operator|(
name|hash
operator|*
literal|97
operator|)
operator|+
operator|(
name|unsigned
name|char
operator|)
operator|*
name|name
expr_stmt|;
else|else
for|for
control|(
name|hash
operator|=
literal|0
init|;
operator|*
name|name
condition|;
operator|++
name|name
control|)
name|hash
operator|=
operator|(
name|hash
operator|*
literal|97
operator|)
operator|+
operator|(
name|unsigned
name|char
operator|)
name|tolower
argument_list|(
operator|*
name|name
argument_list|)
expr_stmt|;
return|return
name|hash
operator|%
name|kt
operator|->
name|hash_table_size
return|;
block|}
end_function

begin_comment
comment|/* Return first entry in hash chain for VALUE.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|hash_keyword_value
parameter_list|(
name|kt
parameter_list|,
name|value
parameter_list|)
specifier|const
name|CGEN_KEYWORD
modifier|*
name|kt
decl_stmt|;
name|unsigned
name|int
name|value
decl_stmt|;
block|{
return|return
name|value
operator|%
name|kt
operator|->
name|hash_table_size
return|;
block|}
end_function

begin_comment
comment|/* Build a keyword table's hash tables.    We probably needn't build the value hash table for the assembler when    we're using the disassembler, but we keep things simple.  */
end_comment

begin_function
specifier|static
name|void
name|build_keyword_hash_tables
parameter_list|(
name|kt
parameter_list|)
name|CGEN_KEYWORD
modifier|*
name|kt
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Use the number of compiled in entries as an estimate for the      typical sized table [not too many added at runtime].  */
name|unsigned
name|int
name|size
init|=
name|KEYWORD_HASH_SIZE
argument_list|(
name|kt
operator|->
name|num_init_entries
argument_list|)
decl_stmt|;
name|kt
operator|->
name|hash_table_size
operator|=
name|size
expr_stmt|;
name|kt
operator|->
name|name_hash_table
operator|=
operator|(
name|CGEN_KEYWORD_ENTRY
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|CGEN_KEYWORD_ENTRY
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|kt
operator|->
name|name_hash_table
argument_list|,
literal|0
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|CGEN_KEYWORD_ENTRY
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|kt
operator|->
name|value_hash_table
operator|=
operator|(
name|CGEN_KEYWORD_ENTRY
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|CGEN_KEYWORD_ENTRY
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|kt
operator|->
name|value_hash_table
argument_list|,
literal|0
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|CGEN_KEYWORD_ENTRY
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The table is scanned backwards as we want keywords appearing earlier to      be prefered over later ones.  */
for|for
control|(
name|i
operator|=
name|kt
operator|->
name|num_init_entries
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|cgen_keyword_add
argument_list|(
name|kt
argument_list|,
operator|&
name|kt
operator|->
name|init_entries
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hardware support.  */
end_comment

begin_function
specifier|const
name|CGEN_HW_ENTRY
modifier|*
name|cgen_hw_lookup
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|const
name|CGEN_HW_ENTRY
modifier|*
name|hw
init|=
name|cgen_current_opcode_data
operator|->
name|hw_list
decl_stmt|;
while|while
condition|(
name|hw
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|hw
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|hw
return|;
name|hw
operator|=
name|hw
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Instruction support.  */
end_comment

begin_comment
comment|/* Return number of instructions.  This includes any added at runtime.  */
end_comment

begin_function
name|int
name|cgen_insn_count
parameter_list|()
block|{
name|int
name|count
init|=
name|cgen_current_opcode_data
operator|->
name|insn_table
operator|->
name|num_init_entries
decl_stmt|;
name|CGEN_INSN_LIST
modifier|*
name|insn
init|=
name|cgen_current_opcode_data
operator|->
name|insn_table
operator|->
name|new_entries
decl_stmt|;
for|for
control|(
init|;
name|insn
operator|!=
name|NULL
condition|;
name|insn
operator|=
name|insn
operator|->
name|next
control|)
operator|++
name|count
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

end_unit

