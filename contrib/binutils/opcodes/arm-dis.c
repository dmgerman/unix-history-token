begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Instruction printing code for the ARM    Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.    Contributed by Richard Earnshaw (rwe@pegasus.esprit.ec.org)    Modification by James G. Smith (jsmith@cygnus.co.uk)  This file is part of libopcodes.   This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.   This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.   You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_define
define|#
directive|define
name|DEFINE_TABLE
end_define

begin_include
include|#
directive|include
file|"arm-opc.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_include
include|#
directive|include
file|"opintl.h"
end_include

begin_comment
comment|/* FIXME: This shouldn't be done here */
end_comment

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/internal.h"
end_include

begin_include
include|#
directive|include
file|"elf/arm.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|streq
end_ifndef

begin_define
define|#
directive|define
name|streq
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(strcmp ((a), (b)) == 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|strneq
end_ifndef

begin_define
define|#
directive|define
name|strneq
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|n
parameter_list|)
value|(strncmp ((a), (b), (n)) == 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NUM_ELEM
end_ifndef

begin_define
define|#
directive|define
name|NUM_ELEM
parameter_list|(
name|a
parameter_list|)
value|(sizeof (a) / sizeof (a)[0])
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|arm_conditional
index|[]
init|=
block|{
literal|"eq"
block|,
literal|"ne"
block|,
literal|"cs"
block|,
literal|"cc"
block|,
literal|"mi"
block|,
literal|"pl"
block|,
literal|"vs"
block|,
literal|"vc"
block|,
literal|"hi"
block|,
literal|"ls"
block|,
literal|"ge"
block|,
literal|"lt"
block|,
literal|"gt"
block|,
literal|"le"
block|,
literal|""
block|,
literal|"nv"
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|description
decl_stmt|;
specifier|const
name|char
modifier|*
name|reg_names
index|[
literal|16
index|]
decl_stmt|;
block|}
name|arm_regname
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|arm_regname
name|regnames
index|[]
init|=
block|{
block|{
literal|"raw"
block|,
literal|"Select raw register names"
block|,
block|{
literal|"r0"
block|,
literal|"r1"
block|,
literal|"r2"
block|,
literal|"r3"
block|,
literal|"r4"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
literal|"r8"
block|,
literal|"r9"
block|,
literal|"r10"
block|,
literal|"r11"
block|,
literal|"r12"
block|,
literal|"r13"
block|,
literal|"r14"
block|,
literal|"r15"
block|}
block|}
block|,
block|{
literal|"gcc"
block|,
literal|"Select register names used by GCC"
block|,
block|{
literal|"r0"
block|,
literal|"r1"
block|,
literal|"r2"
block|,
literal|"r3"
block|,
literal|"r4"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
literal|"r8"
block|,
literal|"r9"
block|,
literal|"sl"
block|,
literal|"fp"
block|,
literal|"ip"
block|,
literal|"sp"
block|,
literal|"lr"
block|,
literal|"pc"
block|}
block|}
block|,
block|{
literal|"std"
block|,
literal|"Select register names used in ARM's ISA documentation"
block|,
block|{
literal|"r0"
block|,
literal|"r1"
block|,
literal|"r2"
block|,
literal|"r3"
block|,
literal|"r4"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
literal|"r8"
block|,
literal|"r9"
block|,
literal|"r10"
block|,
literal|"r11"
block|,
literal|"r12"
block|,
literal|"sp"
block|,
literal|"lr"
block|,
literal|"pc"
block|}
block|}
block|,
block|{
literal|"apcs"
block|,
literal|"Select register names used in the APCS"
block|,
block|{
literal|"a1"
block|,
literal|"a2"
block|,
literal|"a3"
block|,
literal|"a4"
block|,
literal|"v1"
block|,
literal|"v2"
block|,
literal|"v3"
block|,
literal|"v4"
block|,
literal|"v5"
block|,
literal|"v6"
block|,
literal|"sl"
block|,
literal|"fp"
block|,
literal|"ip"
block|,
literal|"sp"
block|,
literal|"lr"
block|,
literal|"pc"
block|}
block|}
block|,
block|{
literal|"atpcs"
block|,
literal|"Select register names used in the ATPCS"
block|,
block|{
literal|"a1"
block|,
literal|"a2"
block|,
literal|"a3"
block|,
literal|"a4"
block|,
literal|"v1"
block|,
literal|"v2"
block|,
literal|"v3"
block|,
literal|"v4"
block|,
literal|"v5"
block|,
literal|"v6"
block|,
literal|"v7"
block|,
literal|"v8"
block|,
literal|"IP"
block|,
literal|"SP"
block|,
literal|"LR"
block|,
literal|"PC"
block|}
block|}
block|,
block|{
literal|"special-atpcs"
block|,
literal|"Select special register names used in the ATPCS"
block|,
block|{
literal|"a1"
block|,
literal|"a2"
block|,
literal|"a3"
block|,
literal|"a4"
block|,
literal|"v1"
block|,
literal|"v2"
block|,
literal|"v3"
block|,
literal|"WR"
block|,
literal|"v5"
block|,
literal|"SB"
block|,
literal|"SL"
block|,
literal|"FP"
block|,
literal|"IP"
block|,
literal|"SP"
block|,
literal|"LR"
block|,
literal|"PC"
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default to GCC register name set.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|regname_selected
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUM_ARM_REGNAMES
value|NUM_ELEM (regnames)
end_define

begin_define
define|#
directive|define
name|arm_regnames
value|regnames[regname_selected].reg_names
end_define

begin_decl_stmt
specifier|static
name|boolean
name|force_thumb
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|arm_fp_const
index|[]
init|=
block|{
literal|"0.0"
block|,
literal|"1.0"
block|,
literal|"2.0"
block|,
literal|"3.0"
block|,
literal|"4.0"
block|,
literal|"5.0"
block|,
literal|"0.5"
block|,
literal|"10.0"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|arm_shift
index|[]
init|=
block|{
literal|"lsl"
block|,
literal|"lsr"
block|,
literal|"asr"
block|,
literal|"ror"
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|arm_decode_shift
name|PARAMS
argument_list|(
operator|(
name|long
operator|,
name|fprintf_ftype
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|print_insn_arm
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
expr|struct
name|disassemble_info
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|print_insn_thumb
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
expr|struct
name|disassemble_info
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|parse_disassembler_options
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|print_insn
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
expr|struct
name|disassemble_info
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|get_arm_regname_num_options
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|set_arm_regname_option
parameter_list|(
name|int
name|option
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|get_arm_regnames
parameter_list|(
name|int
name|option
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|setname
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|setdescription
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
modifier|*
name|register_names
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Functions. */
end_comment

begin_function
name|int
name|get_arm_regname_num_options
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|NUM_ARM_REGNAMES
return|;
block|}
end_function

begin_function
name|int
name|set_arm_regname_option
parameter_list|(
name|int
name|option
parameter_list|)
block|{
name|int
name|old
init|=
name|regname_selected
decl_stmt|;
name|regname_selected
operator|=
name|option
expr_stmt|;
return|return
name|old
return|;
block|}
end_function

begin_function
name|int
name|get_arm_regnames
parameter_list|(
name|int
name|option
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|setname
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|setdescription
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
modifier|*
name|register_names
parameter_list|)
block|{
operator|*
name|setname
operator|=
name|regnames
index|[
name|option
index|]
operator|.
name|name
expr_stmt|;
operator|*
name|setdescription
operator|=
name|regnames
index|[
name|option
index|]
operator|.
name|description
expr_stmt|;
operator|*
name|register_names
operator|=
name|regnames
index|[
name|option
index|]
operator|.
name|reg_names
expr_stmt|;
return|return
literal|16
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_decode_shift
parameter_list|(
name|given
parameter_list|,
name|func
parameter_list|,
name|stream
parameter_list|)
name|long
name|given
decl_stmt|;
name|fprintf_ftype
name|func
decl_stmt|;
name|void
modifier|*
name|stream
decl_stmt|;
block|{
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|arm_regnames
index|[
name|given
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|given
operator|&
literal|0xff0
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|given
operator|&
literal|0x10
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|amount
init|=
operator|(
name|given
operator|&
literal|0xf80
operator|)
operator|>>
literal|7
decl_stmt|;
name|int
name|shift
init|=
operator|(
name|given
operator|&
literal|0x60
operator|)
operator|>>
literal|5
decl_stmt|;
if|if
condition|(
name|amount
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|shift
operator|==
literal|3
condition|)
block|{
name|func
argument_list|(
name|stream
argument_list|,
literal|", rrx"
argument_list|)
expr_stmt|;
return|return;
block|}
name|amount
operator|=
literal|32
expr_stmt|;
block|}
name|func
argument_list|(
name|stream
argument_list|,
literal|", %s #%d"
argument_list|,
name|arm_shift
index|[
name|shift
index|]
argument_list|,
name|amount
argument_list|)
expr_stmt|;
block|}
else|else
name|func
argument_list|(
name|stream
argument_list|,
literal|", %s %s"
argument_list|,
name|arm_shift
index|[
operator|(
name|given
operator|&
literal|0x60
operator|)
operator|>>
literal|5
index|]
argument_list|,
name|arm_regnames
index|[
operator|(
name|given
operator|&
literal|0xf00
operator|)
operator|>>
literal|8
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print one instruction from PC on INFO->STREAM.    Return the size of the instruction (always 4 on ARM). */
end_comment

begin_function
specifier|static
name|int
name|print_insn_arm
parameter_list|(
name|pc
parameter_list|,
name|info
parameter_list|,
name|given
parameter_list|)
name|bfd_vma
name|pc
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
name|long
name|given
decl_stmt|;
block|{
name|struct
name|arm_opcode
modifier|*
name|insn
decl_stmt|;
name|void
modifier|*
name|stream
init|=
name|info
operator|->
name|stream
decl_stmt|;
name|fprintf_ftype
name|func
init|=
name|info
operator|->
name|fprintf_func
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|arm_opcodes
init|;
name|insn
operator|->
name|assembler
condition|;
name|insn
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|given
operator|&
name|insn
operator|->
name|mask
operator|)
operator|==
name|insn
operator|->
name|value
condition|)
block|{
name|char
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|insn
operator|->
name|assembler
init|;
operator|*
name|c
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|c
operator|==
literal|'%'
condition|)
block|{
switch|switch
condition|(
operator|*
operator|++
name|c
condition|)
block|{
case|case
literal|'%'
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"%%"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
if|if
condition|(
operator|(
operator|(
name|given
operator|&
literal|0x000f0000
operator|)
operator|==
literal|0x000f0000
operator|)
operator|&&
operator|(
operator|(
name|given
operator|&
literal|0x02000000
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|int
name|offset
init|=
name|given
operator|&
literal|0xfff
decl_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"[pc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|given
operator|&
literal|0x01000000
condition|)
block|{
if|if
condition|(
operator|(
name|given
operator|&
literal|0x00800000
operator|)
operator|==
literal|0
condition|)
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
comment|/* pre-indexed */
name|func
argument_list|(
name|stream
argument_list|,
literal|", #%d]"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|pc
operator|+
literal|8
expr_stmt|;
comment|/* Cope with the possibility of write-back 				 being used.  Probably a very dangerous thing 				 for the programmer to do, but who are we to 				 argue ?  */
if|if
condition|(
name|given
operator|&
literal|0x00200000
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"!"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Post indexed.  */
name|func
argument_list|(
name|stream
argument_list|,
literal|"], #%d"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|pc
operator|+
literal|8
expr_stmt|;
comment|/* ie ignore the offset.  */
block|}
name|func
argument_list|(
name|stream
argument_list|,
literal|"\t; "
argument_list|)
expr_stmt|;
name|info
operator|->
name|print_address_func
argument_list|(
name|offset
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|func
argument_list|(
name|stream
argument_list|,
literal|"[%s"
argument_list|,
name|arm_regnames
index|[
operator|(
name|given
operator|>>
literal|16
operator|)
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|given
operator|&
literal|0x01000000
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|given
operator|&
literal|0x02000000
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|offset
init|=
name|given
operator|&
literal|0xfff
decl_stmt|;
if|if
condition|(
name|offset
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|", %s#%d"
argument_list|,
operator|(
operator|(
operator|(
name|given
operator|&
literal|0x00800000
operator|)
operator|==
literal|0
operator|)
condition|?
literal|"-"
else|:
literal|""
operator|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|func
argument_list|(
name|stream
argument_list|,
literal|", %s"
argument_list|,
operator|(
operator|(
operator|(
name|given
operator|&
literal|0x00800000
operator|)
operator|==
literal|0
operator|)
condition|?
literal|"-"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|arm_decode_shift
argument_list|(
name|given
argument_list|,
name|func
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|func
argument_list|(
name|stream
argument_list|,
literal|"]%s"
argument_list|,
operator|(
operator|(
name|given
operator|&
literal|0x00200000
operator|)
operator|!=
literal|0
operator|)
condition|?
literal|"!"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|given
operator|&
literal|0x02000000
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|offset
init|=
name|given
operator|&
literal|0xfff
decl_stmt|;
if|if
condition|(
name|offset
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"], %s#%d"
argument_list|,
operator|(
operator|(
operator|(
name|given
operator|&
literal|0x00800000
operator|)
operator|==
literal|0
operator|)
condition|?
literal|"-"
else|:
literal|""
operator|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
name|func
argument_list|(
name|stream
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|func
argument_list|(
name|stream
argument_list|,
literal|"], %s"
argument_list|,
operator|(
operator|(
operator|(
name|given
operator|&
literal|0x00800000
operator|)
operator|==
literal|0
operator|)
condition|?
literal|"-"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|arm_decode_shift
argument_list|(
name|given
argument_list|,
name|func
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
operator|(
name|given
operator|&
literal|0x004f0000
operator|)
operator|==
literal|0x004f0000
condition|)
block|{
comment|/* PC relative with immediate offset.  */
name|int
name|offset
init|=
operator|(
operator|(
name|given
operator|&
literal|0xf00
operator|)
operator|>>
literal|4
operator|)
operator||
operator|(
name|given
operator|&
literal|0xf
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|given
operator|&
literal|0x00800000
operator|)
operator|==
literal|0
condition|)
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"[pc, #%d]\t; "
argument_list|,
name|offset
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|offset
operator|+
name|pc
operator|+
literal|8
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|func
argument_list|(
name|stream
argument_list|,
literal|"[%s"
argument_list|,
name|arm_regnames
index|[
operator|(
name|given
operator|>>
literal|16
operator|)
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|given
operator|&
literal|0x01000000
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Pre-indexed.  */
if|if
condition|(
operator|(
name|given
operator|&
literal|0x00400000
operator|)
operator|==
literal|0x00400000
condition|)
block|{
comment|/* Immediate.  */
name|int
name|offset
init|=
operator|(
operator|(
name|given
operator|&
literal|0xf00
operator|)
operator|>>
literal|4
operator|)
operator||
operator|(
name|given
operator|&
literal|0xf
operator|)
decl_stmt|;
if|if
condition|(
name|offset
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|", %s#%d"
argument_list|,
operator|(
operator|(
operator|(
name|given
operator|&
literal|0x00800000
operator|)
operator|==
literal|0
operator|)
condition|?
literal|"-"
else|:
literal|""
operator|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Register.  */
name|func
argument_list|(
name|stream
argument_list|,
literal|", %s%s"
argument_list|,
operator|(
operator|(
operator|(
name|given
operator|&
literal|0x00800000
operator|)
operator|==
literal|0
operator|)
condition|?
literal|"-"
else|:
literal|""
operator|)
argument_list|,
name|arm_regnames
index|[
name|given
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
block|}
name|func
argument_list|(
name|stream
argument_list|,
literal|"]%s"
argument_list|,
operator|(
operator|(
name|given
operator|&
literal|0x00200000
operator|)
operator|!=
literal|0
operator|)
condition|?
literal|"!"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Post-indexed.  */
if|if
condition|(
operator|(
name|given
operator|&
literal|0x00400000
operator|)
operator|==
literal|0x00400000
condition|)
block|{
comment|/* Immediate.  */
name|int
name|offset
init|=
operator|(
operator|(
name|given
operator|&
literal|0xf00
operator|)
operator|>>
literal|4
operator|)
operator||
operator|(
name|given
operator|&
literal|0xf
operator|)
decl_stmt|;
if|if
condition|(
name|offset
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"], %s#%d"
argument_list|,
operator|(
operator|(
operator|(
name|given
operator|&
literal|0x00800000
operator|)
operator|==
literal|0
operator|)
condition|?
literal|"-"
else|:
literal|""
operator|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
name|func
argument_list|(
name|stream
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Register.  */
name|func
argument_list|(
name|stream
argument_list|,
literal|"], %s%s"
argument_list|,
operator|(
operator|(
operator|(
name|given
operator|&
literal|0x00800000
operator|)
operator|==
literal|0
operator|)
condition|?
literal|"-"
else|:
literal|""
operator|)
argument_list|,
name|arm_regnames
index|[
name|given
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
literal|'b'
case|:
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|BDISP
argument_list|(
name|given
argument_list|)
operator|*
literal|4
operator|+
name|pc
operator|+
literal|8
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|arm_conditional
index|[
operator|(
name|given
operator|>>
literal|28
operator|)
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
block|{
name|int
name|started
init|=
literal|0
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
literal|16
condition|;
name|reg
operator|++
control|)
if|if
condition|(
operator|(
name|given
operator|&
operator|(
literal|1
operator|<<
name|reg
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|started
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|started
operator|=
literal|1
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|arm_regnames
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
block|}
name|func
argument_list|(
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
operator|(
name|given
operator|&
literal|0x02000000
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|rotate
init|=
operator|(
name|given
operator|&
literal|0xf00
operator|)
operator|>>
literal|7
decl_stmt|;
name|int
name|immed
init|=
operator|(
name|given
operator|&
literal|0xff
operator|)
decl_stmt|;
name|immed
operator|=
operator|(
operator|(
operator|(
name|immed
operator|<<
operator|(
literal|32
operator|-
name|rotate
operator|)
operator|)
operator||
operator|(
name|immed
operator|>>
name|rotate
operator|)
operator|)
operator|&
literal|0xffffffff
operator|)
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"#%d\t; 0x%x"
argument_list|,
name|immed
argument_list|,
name|immed
argument_list|)
expr_stmt|;
block|}
else|else
name|arm_decode_shift
argument_list|(
name|given
argument_list|,
name|func
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
operator|(
name|given
operator|&
literal|0x0000f000
operator|)
operator|==
literal|0x0000f000
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"p"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
operator|(
name|given
operator|&
literal|0x01200000
operator|)
operator|==
literal|0x00200000
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
if|if
condition|(
operator|(
name|given
operator|&
literal|0x00000020
operator|)
operator|==
literal|0x00000020
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"h"
argument_list|)
expr_stmt|;
else|else
name|func
argument_list|(
name|stream
argument_list|,
literal|"b"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"[%s"
argument_list|,
name|arm_regnames
index|[
operator|(
name|given
operator|>>
literal|16
operator|)
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|given
operator|&
literal|0x01000000
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|offset
init|=
name|given
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
name|offset
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|", %s#%d]%s"
argument_list|,
operator|(
operator|(
name|given
operator|&
literal|0x00800000
operator|)
operator|==
literal|0
condition|?
literal|"-"
else|:
literal|""
operator|)
argument_list|,
name|offset
operator|*
literal|4
argument_list|,
operator|(
operator|(
name|given
operator|&
literal|0x00200000
operator|)
operator|!=
literal|0
condition|?
literal|"!"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
else|else
name|func
argument_list|(
name|stream
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|offset
init|=
name|given
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
name|offset
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"], %s#%d"
argument_list|,
operator|(
operator|(
name|given
operator|&
literal|0x00800000
operator|)
operator|==
literal|0
condition|?
literal|"-"
else|:
literal|""
operator|)
argument_list|,
name|offset
operator|*
literal|4
argument_list|)
expr_stmt|;
else|else
name|func
argument_list|(
name|stream
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'B'
case|:
comment|/* Print ARM V5 BLX(1) address: pc+25 bits.  */
block|{
name|bfd_vma
name|address
decl_stmt|;
name|bfd_vma
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|given
operator|&
literal|0x00800000
condition|)
comment|/* Is signed, hi bits should be ones.  */
name|offset
operator|=
operator|(
operator|-
literal|1
operator|)
operator|^
literal|0x00ffffff
expr_stmt|;
comment|/* Offset is (SignExtend(offset field)<<2).  */
name|offset
operator|+=
name|given
operator|&
literal|0x00ffffff
expr_stmt|;
name|offset
operator|<<=
literal|2
expr_stmt|;
name|address
operator|=
name|offset
operator|+
name|pc
operator|+
literal|8
expr_stmt|;
if|if
condition|(
name|given
operator|&
literal|0x01000000
condition|)
comment|/* H bit allows addressing to 2-byte boundaries.  */
name|address
operator|+=
literal|2
expr_stmt|;
name|info
operator|->
name|print_address_func
argument_list|(
name|address
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"_"
argument_list|)
expr_stmt|;
if|if
condition|(
name|given
operator|&
literal|0x80000
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"f"
argument_list|)
expr_stmt|;
if|if
condition|(
name|given
operator|&
literal|0x40000
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|given
operator|&
literal|0x20000
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
if|if
condition|(
name|given
operator|&
literal|0x10000
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"c"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
switch|switch
condition|(
name|given
operator|&
literal|0x00408000
condition|)
block|{
case|case
literal|0
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"4"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x8000
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x00400000
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"2"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|func
argument_list|(
name|stream
argument_list|,
literal|"3"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'P'
case|:
switch|switch
condition|(
name|given
operator|&
literal|0x00080080
condition|)
block|{
case|case
literal|0
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"s"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x80
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"d"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x00080000
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"e"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|func
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"<illegal precision>"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'Q'
case|:
switch|switch
condition|(
name|given
operator|&
literal|0x00408000
condition|)
block|{
case|case
literal|0
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"s"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x8000
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"d"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x00400000
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"e"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|func
argument_list|(
name|stream
argument_list|,
literal|"p"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'R'
case|:
switch|switch
condition|(
name|given
operator|&
literal|0x60
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|0x20
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"p"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x40
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"m"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|func
argument_list|(
name|stream
argument_list|,
literal|"z"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
block|{
name|int
name|bitstart
init|=
operator|*
name|c
operator|++
operator|-
literal|'0'
decl_stmt|;
name|int
name|bitend
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|c
operator|>=
literal|'0'
operator|&&
operator|*
name|c
operator|<=
literal|'9'
condition|)
name|bitstart
operator|=
operator|(
name|bitstart
operator|*
literal|10
operator|)
operator|+
operator|*
name|c
operator|++
operator|-
literal|'0'
expr_stmt|;
switch|switch
condition|(
operator|*
name|c
condition|)
block|{
case|case
literal|'-'
case|:
name|c
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|c
operator|>=
literal|'0'
operator|&&
operator|*
name|c
operator|<=
literal|'9'
condition|)
name|bitend
operator|=
operator|(
name|bitend
operator|*
literal|10
operator|)
operator|+
operator|*
name|c
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|!
name|bitend
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
name|c
condition|)
block|{
case|case
literal|'r'
case|:
block|{
name|long
name|reg
decl_stmt|;
name|reg
operator|=
name|given
operator|>>
name|bitstart
expr_stmt|;
name|reg
operator|&=
operator|(
literal|2
operator|<<
operator|(
name|bitend
operator|-
name|bitstart
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|arm_regnames
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
block|{
name|long
name|reg
decl_stmt|;
name|reg
operator|=
name|given
operator|>>
name|bitstart
expr_stmt|;
name|reg
operator|&=
operator|(
literal|2
operator|<<
operator|(
name|bitend
operator|-
name|bitstart
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'x'
case|:
block|{
name|long
name|reg
decl_stmt|;
name|reg
operator|=
name|given
operator|>>
name|bitstart
expr_stmt|;
name|reg
operator|&=
operator|(
literal|2
operator|<<
operator|(
name|bitend
operator|-
name|bitstart
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"0x%08x"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Some SWI instructions have special 				     meanings.  */
if|if
condition|(
operator|(
name|given
operator|&
literal|0x0fffffff
operator|)
operator|==
literal|0x0FF00000
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"\t; IMB"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|given
operator|&
literal|0x0fffffff
operator|)
operator|==
literal|0x0FF00001
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"\t; IMBRange"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'X'
case|:
block|{
name|long
name|reg
decl_stmt|;
name|reg
operator|=
name|given
operator|>>
name|bitstart
expr_stmt|;
name|reg
operator|&=
operator|(
literal|2
operator|<<
operator|(
name|bitend
operator|-
name|bitstart
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"%01x"
argument_list|,
name|reg
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
block|{
name|long
name|reg
decl_stmt|;
name|reg
operator|=
name|given
operator|>>
name|bitstart
expr_stmt|;
name|reg
operator|&=
operator|(
literal|2
operator|<<
operator|(
name|bitend
operator|-
name|bitstart
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|reg
operator|>
literal|7
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"#%s"
argument_list|,
name|arm_fp_const
index|[
name|reg
operator|&
literal|7
index|]
argument_list|)
expr_stmt|;
else|else
name|func
argument_list|(
name|stream
argument_list|,
literal|"f%d"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'`'
case|:
name|c
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|given
operator|&
operator|(
literal|1
operator|<<
name|bitstart
operator|)
operator|)
operator|==
literal|0
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|c
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|given
operator|&
operator|(
literal|1
operator|<<
name|bitstart
operator|)
operator|)
operator|!=
literal|0
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|++
name|c
expr_stmt|;
if|if
condition|(
operator|(
name|given
operator|&
operator|(
literal|1
operator|<<
name|bitstart
operator|)
operator|)
operator|!=
literal|0
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|c
operator|++
argument_list|)
expr_stmt|;
else|else
name|func
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
operator|*
operator|++
name|c
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
else|else
name|func
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
return|return
literal|4
return|;
block|}
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print one instruction from PC on INFO->STREAM.    Return the size of the instruction. */
end_comment

begin_function
specifier|static
name|int
name|print_insn_thumb
parameter_list|(
name|pc
parameter_list|,
name|info
parameter_list|,
name|given
parameter_list|)
name|bfd_vma
name|pc
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
name|long
name|given
decl_stmt|;
block|{
name|struct
name|thumb_opcode
modifier|*
name|insn
decl_stmt|;
name|void
modifier|*
name|stream
init|=
name|info
operator|->
name|stream
decl_stmt|;
name|fprintf_ftype
name|func
init|=
name|info
operator|->
name|fprintf_func
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|thumb_opcodes
init|;
name|insn
operator|->
name|assembler
condition|;
name|insn
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|given
operator|&
name|insn
operator|->
name|mask
operator|)
operator|==
name|insn
operator|->
name|value
condition|)
block|{
name|char
modifier|*
name|c
init|=
name|insn
operator|->
name|assembler
decl_stmt|;
comment|/* Special processing for Thumb 2 instruction BL sequence:  */
if|if
condition|(
operator|!
operator|*
name|c
condition|)
comment|/* Check for empty (not NULL) assembler string.  */
block|{
name|info
operator|->
name|bytes_per_chunk
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|bytes_per_line
operator|=
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|given
operator|&
literal|0x10000000
operator|)
operator|==
literal|0
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"blx\t"
argument_list|)
expr_stmt|;
else|else
name|func
argument_list|(
name|stream
argument_list|,
literal|"bl\t"
argument_list|)
expr_stmt|;
name|info
operator|->
name|print_address_func
argument_list|(
name|BDISP23
argument_list|(
name|given
argument_list|)
operator|*
literal|2
operator|+
name|pc
operator|+
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
literal|4
return|;
block|}
else|else
block|{
name|info
operator|->
name|bytes_per_chunk
operator|=
literal|2
expr_stmt|;
name|info
operator|->
name|bytes_per_line
operator|=
literal|4
expr_stmt|;
name|given
operator|&=
literal|0xffff
expr_stmt|;
for|for
control|(
init|;
operator|*
name|c
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|c
operator|==
literal|'%'
condition|)
block|{
name|int
name|domaskpc
init|=
literal|0
decl_stmt|;
name|int
name|domasklr
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
operator|*
operator|++
name|c
condition|)
block|{
case|case
literal|'%'
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"%%"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
block|{
name|long
name|reg
decl_stmt|;
name|reg
operator|=
operator|(
name|given
operator|>>
literal|3
operator|)
operator|&
literal|0x7
expr_stmt|;
if|if
condition|(
name|given
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
condition|)
name|reg
operator|+=
literal|8
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|arm_regnames
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'D'
case|:
block|{
name|long
name|reg
decl_stmt|;
name|reg
operator|=
name|given
operator|&
literal|0x7
expr_stmt|;
if|if
condition|(
name|given
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
condition|)
name|reg
operator|+=
literal|8
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|arm_regnames
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'T'
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|arm_conditional
index|[
operator|(
name|given
operator|>>
literal|8
operator|)
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
if|if
condition|(
name|given
operator|&
operator|(
literal|1
operator|<<
literal|8
operator|)
condition|)
name|domasklr
operator|=
literal|1
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'O'
case|:
if|if
condition|(
operator|*
name|c
operator|==
literal|'O'
operator|&&
operator|(
name|given
operator|&
operator|(
literal|1
operator|<<
literal|8
operator|)
operator|)
condition|)
name|domaskpc
operator|=
literal|1
expr_stmt|;
comment|/* Fall through.  */
case|case
literal|'M'
case|:
block|{
name|int
name|started
init|=
literal|0
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
comment|/* It would be nice if we could spot                                ranges, and generate the rS-rE format: */
for|for
control|(
name|reg
operator|=
literal|0
init|;
operator|(
name|reg
operator|<
literal|8
operator|)
condition|;
name|reg
operator|++
control|)
if|if
condition|(
operator|(
name|given
operator|&
operator|(
literal|1
operator|<<
name|reg
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|started
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|started
operator|=
literal|1
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|arm_regnames
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|domasklr
condition|)
block|{
if|if
condition|(
name|started
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|started
operator|=
literal|1
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
name|arm_regnames
index|[
literal|14
index|]
comment|/* "lr" */
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|domaskpc
condition|)
block|{
if|if
condition|(
name|started
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
name|arm_regnames
index|[
literal|15
index|]
comment|/* "pc" */
argument_list|)
expr_stmt|;
block|}
name|func
argument_list|(
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
block|{
name|int
name|bitstart
init|=
operator|*
name|c
operator|++
operator|-
literal|'0'
decl_stmt|;
name|int
name|bitend
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|c
operator|>=
literal|'0'
operator|&&
operator|*
name|c
operator|<=
literal|'9'
condition|)
name|bitstart
operator|=
operator|(
name|bitstart
operator|*
literal|10
operator|)
operator|+
operator|*
name|c
operator|++
operator|-
literal|'0'
expr_stmt|;
switch|switch
condition|(
operator|*
name|c
condition|)
block|{
case|case
literal|'-'
case|:
block|{
name|long
name|reg
decl_stmt|;
name|c
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|c
operator|>=
literal|'0'
operator|&&
operator|*
name|c
operator|<=
literal|'9'
condition|)
name|bitend
operator|=
operator|(
name|bitend
operator|*
literal|10
operator|)
operator|+
operator|*
name|c
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|!
name|bitend
condition|)
name|abort
argument_list|()
expr_stmt|;
name|reg
operator|=
name|given
operator|>>
name|bitstart
expr_stmt|;
name|reg
operator|&=
operator|(
literal|2
operator|<<
operator|(
name|bitend
operator|-
name|bitstart
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
operator|*
name|c
condition|)
block|{
case|case
literal|'r'
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|arm_regnames
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|reg
operator|<<
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|reg
operator|<<
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* PC-relative address -- the bottom two 					 bits of the address are dropped 					 before the calculation.  */
name|info
operator|->
name|print_address_func
argument_list|(
operator|(
operator|(
name|pc
operator|+
literal|4
operator|)
operator|&
operator|~
literal|3
operator|)
operator|+
operator|(
name|reg
operator|<<
literal|2
operator|)
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|func
argument_list|(
name|stream
argument_list|,
literal|"0x%04x"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|reg
operator|=
operator|(
operator|(
name|reg
operator|^
operator|(
literal|1
operator|<<
name|bitend
operator|)
operator|)
operator|-
operator|(
literal|1
operator|<<
name|bitend
operator|)
operator|)
expr_stmt|;
name|func
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|reg
operator|=
operator|(
operator|(
name|reg
operator|^
operator|(
literal|1
operator|<<
name|bitend
operator|)
operator|)
operator|-
operator|(
literal|1
operator|<<
name|bitend
operator|)
operator|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|reg
operator|*
literal|2
operator|+
name|pc
operator|+
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'\''
case|:
name|c
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|given
operator|&
operator|(
literal|1
operator|<<
name|bitstart
operator|)
operator|)
operator|!=
literal|0
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|++
name|c
expr_stmt|;
if|if
condition|(
operator|(
name|given
operator|&
operator|(
literal|1
operator|<<
name|bitstart
operator|)
operator|)
operator|!=
literal|0
condition|)
name|func
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|c
operator|++
argument_list|)
expr_stmt|;
else|else
name|func
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
operator|*
operator|++
name|c
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|func
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|2
return|;
block|}
block|}
comment|/* No match.  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse an individual disassembler option.  */
end_comment

begin_function
name|void
name|parse_arm_disassembler_option
parameter_list|(
name|option
parameter_list|)
name|char
modifier|*
name|option
decl_stmt|;
block|{
if|if
condition|(
name|option
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|strneq
argument_list|(
name|option
argument_list|,
literal|"reg-names-"
argument_list|,
literal|10
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|option
operator|+=
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NUM_ARM_REGNAMES
init|;
name|i
operator|--
condition|;
control|)
if|if
condition|(
name|streq
argument_list|(
name|option
argument_list|,
name|regnames
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
name|regname_selected
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Unrecognised register name set: %s\n"
argument_list|)
argument_list|,
name|option
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|streq
argument_list|(
name|option
argument_list|,
literal|"force-thumb"
argument_list|)
condition|)
name|force_thumb
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|streq
argument_list|(
name|option
argument_list|,
literal|"no-force-thumb"
argument_list|)
condition|)
name|force_thumb
operator|=
literal|0
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Unrecognised disassembler option: %s\n"
argument_list|)
argument_list|,
name|option
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Parse the string of disassembler options, spliting it at whitespaces.  */
end_comment

begin_function
specifier|static
name|void
name|parse_disassembler_options
parameter_list|(
name|options
parameter_list|)
name|char
modifier|*
name|options
decl_stmt|;
block|{
name|char
modifier|*
name|space
decl_stmt|;
if|if
condition|(
name|options
operator|==
name|NULL
condition|)
return|return;
do|do
block|{
name|space
operator|=
name|strchr
argument_list|(
name|options
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
condition|)
block|{
operator|*
name|space
operator|=
literal|'\0'
expr_stmt|;
name|parse_arm_disassembler_option
argument_list|(
name|options
argument_list|)
expr_stmt|;
operator|*
name|space
operator|=
literal|' '
expr_stmt|;
name|options
operator|=
name|space
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|parse_arm_disassembler_option
argument_list|(
name|options
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|space
condition|)
do|;
block|}
end_function

begin_comment
comment|/* NOTE: There are no checks in these routines that    the relevant number of data bytes exist.  */
end_comment

begin_function
specifier|static
name|int
name|print_insn
parameter_list|(
name|pc
parameter_list|,
name|info
parameter_list|,
name|little
parameter_list|)
name|bfd_vma
name|pc
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
name|boolean
name|little
decl_stmt|;
block|{
name|unsigned
name|char
name|b
index|[
literal|4
index|]
decl_stmt|;
name|long
name|given
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|is_thumb
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|disassembler_options
condition|)
block|{
name|parse_disassembler_options
argument_list|(
name|info
operator|->
name|disassembler_options
argument_list|)
expr_stmt|;
comment|/* To avoid repeated parsing of these options, we remove them here.  */
name|info
operator|->
name|disassembler_options
operator|=
name|NULL
expr_stmt|;
block|}
name|is_thumb
operator|=
name|force_thumb
expr_stmt|;
if|if
condition|(
operator|!
name|is_thumb
operator|&&
name|info
operator|->
name|symbols
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bfd_asymbol_flavour
argument_list|(
operator|*
name|info
operator|->
name|symbols
argument_list|)
operator|==
name|bfd_target_coff_flavour
condition|)
block|{
name|coff_symbol_type
modifier|*
name|cs
decl_stmt|;
name|cs
operator|=
name|coffsymbol
argument_list|(
operator|*
name|info
operator|->
name|symbols
argument_list|)
expr_stmt|;
name|is_thumb
operator|=
operator|(
name|cs
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_THUMBEXT
operator|||
name|cs
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_THUMBSTAT
operator|||
name|cs
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_THUMBLABEL
operator|||
name|cs
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_THUMBEXTFUNC
operator|||
name|cs
operator|->
name|native
operator|->
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|==
name|C_THUMBSTATFUNC
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bfd_asymbol_flavour
argument_list|(
operator|*
name|info
operator|->
name|symbols
argument_list|)
operator|==
name|bfd_target_elf_flavour
condition|)
block|{
name|elf_symbol_type
modifier|*
name|es
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
name|es
operator|=
operator|*
operator|(
name|elf_symbol_type
operator|*
operator|*
operator|)
operator|(
name|info
operator|->
name|symbols
operator|)
expr_stmt|;
name|type
operator|=
name|ELF_ST_TYPE
argument_list|(
name|es
operator|->
name|internal_elf_sym
operator|.
name|st_info
argument_list|)
expr_stmt|;
name|is_thumb
operator|=
operator|(
name|type
operator|==
name|STT_ARM_TFUNC
operator|)
operator|||
operator|(
name|type
operator|==
name|STT_ARM_16BIT
operator|)
expr_stmt|;
block|}
block|}
name|info
operator|->
name|bytes_per_chunk
operator|=
literal|4
expr_stmt|;
name|info
operator|->
name|display_endian
operator|=
name|little
condition|?
name|BFD_ENDIAN_LITTLE
else|:
name|BFD_ENDIAN_BIG
expr_stmt|;
if|if
condition|(
name|little
condition|)
block|{
name|status
operator|=
name|info
operator|->
name|read_memory_func
argument_list|(
name|pc
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|&
name|b
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
operator|&&
name|is_thumb
condition|)
block|{
name|info
operator|->
name|bytes_per_chunk
operator|=
literal|2
expr_stmt|;
name|status
operator|=
name|info
operator|->
name|read_memory_func
argument_list|(
name|pc
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|b
argument_list|,
literal|2
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|b
index|[
literal|3
index|]
operator|=
name|b
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|info
operator|->
name|memory_error_func
argument_list|(
name|status
argument_list|,
name|pc
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|given
operator|=
operator|(
name|b
index|[
literal|0
index|]
operator|)
operator||
operator|(
name|b
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|b
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|b
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|info
operator|->
name|read_memory_func
argument_list|(
name|pc
operator|&
operator|~
literal|0x3
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|&
name|b
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|info
operator|->
name|memory_error_func
argument_list|(
name|status
argument_list|,
name|pc
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|is_thumb
condition|)
block|{
if|if
condition|(
name|pc
operator|&
literal|0x2
condition|)
block|{
name|given
operator|=
operator|(
name|b
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|b
index|[
literal|3
index|]
expr_stmt|;
name|status
operator|=
name|info
operator|->
name|read_memory_func
argument_list|(
operator|(
name|pc
operator|+
literal|4
operator|)
operator|&
operator|~
literal|0x3
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|b
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|info
operator|->
name|memory_error_func
argument_list|(
name|status
argument_list|,
name|pc
operator|+
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|given
operator||=
operator|(
name|b
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|b
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
block|}
else|else
name|given
operator|=
operator|(
name|b
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|b
index|[
literal|1
index|]
operator||
operator|(
name|b
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|b
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
block|}
else|else
name|given
operator|=
operator|(
name|b
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|b
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|b
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|b
index|[
literal|3
index|]
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|flags
operator|&
name|INSN_HAS_RELOC
condition|)
comment|/* If the instruction has a reloc associated with it, then        the offset field in the instruction will actually be the        addend for the reloc.  (We are using REL type relocs).        In such cases, we can ignore the pc when computing        addresses, since the addend is not currently pc-relative.  */
name|pc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_thumb
condition|)
name|status
operator|=
name|print_insn_thumb
argument_list|(
name|pc
argument_list|,
name|info
argument_list|,
name|given
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|print_insn_arm
argument_list|(
name|pc
argument_list|,
name|info
argument_list|,
name|given
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|int
name|print_insn_big_arm
parameter_list|(
name|pc
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|pc
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
return|return
name|print_insn
argument_list|(
name|pc
argument_list|,
name|info
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|print_insn_little_arm
parameter_list|(
name|pc
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|pc
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
return|return
name|print_insn
argument_list|(
name|pc
argument_list|,
name|info
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|print_arm_disassembler_options
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\n\ The following ARM specific disassembler options are supported for use with\n\ the -M switch:\n"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NUM_ARM_REGNAMES
init|;
name|i
operator|--
condition|;
control|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  reg-names-%s %*c%s\n"
argument_list|,
name|regnames
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|14
operator|-
name|strlen
argument_list|(
name|regnames
index|[
name|i
index|]
operator|.
name|name
argument_list|)
argument_list|,
literal|' '
argument_list|,
name|regnames
index|[
name|i
index|]
operator|.
name|description
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  force-thumb              Assume all insns are Thumb insns\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"  no-force-thumb           Examine preceeding label to determine an insn's type\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

