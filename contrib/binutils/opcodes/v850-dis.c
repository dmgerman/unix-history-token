begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Disassemble V850 instructions.    Copyright 1996, 1997, 1998, 2000, 2001 Free Software Foundation, Inc.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"opcode/v850.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"opintl.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|v850_reg_names
index|[]
init|=
block|{
literal|"r0"
block|,
literal|"r1"
block|,
literal|"r2"
block|,
literal|"sp"
block|,
literal|"gp"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
literal|"r8"
block|,
literal|"r9"
block|,
literal|"r10"
block|,
literal|"r11"
block|,
literal|"r12"
block|,
literal|"r13"
block|,
literal|"r14"
block|,
literal|"r15"
block|,
literal|"r16"
block|,
literal|"r17"
block|,
literal|"r18"
block|,
literal|"r19"
block|,
literal|"r20"
block|,
literal|"r21"
block|,
literal|"r22"
block|,
literal|"r23"
block|,
literal|"r24"
block|,
literal|"r25"
block|,
literal|"r26"
block|,
literal|"r27"
block|,
literal|"r28"
block|,
literal|"r29"
block|,
literal|"ep"
block|,
literal|"lp"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|v850_sreg_names
index|[]
init|=
block|{
literal|"eipc"
block|,
literal|"eipsw"
block|,
literal|"fepc"
block|,
literal|"fepsw"
block|,
literal|"ecr"
block|,
literal|"psw"
block|,
literal|"sr6"
block|,
literal|"sr7"
block|,
literal|"sr8"
block|,
literal|"sr9"
block|,
literal|"sr10"
block|,
literal|"sr11"
block|,
literal|"sr12"
block|,
literal|"sr13"
block|,
literal|"sr14"
block|,
literal|"sr15"
block|,
literal|"ctpc"
block|,
literal|"ctpsw"
block|,
literal|"dbpc"
block|,
literal|"dbpsw"
block|,
literal|"ctbp"
block|,
literal|"sr21"
block|,
literal|"sr22"
block|,
literal|"sr23"
block|,
literal|"sr24"
block|,
literal|"sr25"
block|,
literal|"sr26"
block|,
literal|"sr27"
block|,
literal|"sr28"
block|,
literal|"sr29"
block|,
literal|"sr30"
block|,
literal|"sr31"
block|,
literal|"sr16"
block|,
literal|"sr17"
block|,
literal|"sr18"
block|,
literal|"sr19"
block|,
literal|"sr20"
block|,
literal|"sr21"
block|,
literal|"sr22"
block|,
literal|"sr23"
block|,
literal|"sr24"
block|,
literal|"sr25"
block|,
literal|"sr26"
block|,
literal|"sr27"
block|,
literal|"sr28"
block|,
literal|"sr29"
block|,
literal|"sr30"
block|,
literal|"sr31"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|v850_cc_names
index|[]
init|=
block|{
literal|"v"
block|,
literal|"c/l"
block|,
literal|"z"
block|,
literal|"nh"
block|,
literal|"s/n"
block|,
literal|"t"
block|,
literal|"lt"
block|,
literal|"le"
block|,
literal|"nv"
block|,
literal|"nc/nl"
block|,
literal|"nz"
block|,
literal|"h"
block|,
literal|"ns/p"
block|,
literal|"sa"
block|,
literal|"ge"
block|,
literal|"gt"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|disassemble
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
expr|struct
name|disassemble_info
operator|*
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|disassemble
parameter_list|(
name|memaddr
parameter_list|,
name|info
parameter_list|,
name|insn
parameter_list|)
name|bfd_vma
name|memaddr
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
block|{
name|struct
name|v850_opcode
modifier|*
name|op
init|=
operator|(
expr|struct
name|v850_opcode
operator|*
operator|)
name|v850_opcodes
decl_stmt|;
specifier|const
name|struct
name|v850_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|match
init|=
literal|0
decl_stmt|;
name|int
name|short_op
init|=
operator|(
operator|(
name|insn
operator|&
literal|0x0600
operator|)
operator|!=
literal|0x0600
operator|)
decl_stmt|;
name|int
name|bytes_read
decl_stmt|;
name|int
name|target_processor
decl_stmt|;
comment|/* Special case: 32 bit MOV */
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffe0
operator|)
operator|==
literal|0x0620
condition|)
name|short_op
operator|=
name|true
expr_stmt|;
name|bytes_read
operator|=
name|short_op
condition|?
literal|2
else|:
literal|4
expr_stmt|;
comment|/* If this is a two byte insn, then mask off the high bits. */
if|if
condition|(
name|short_op
condition|)
name|insn
operator|&=
literal|0xffff
expr_stmt|;
switch|switch
condition|(
name|info
operator|->
name|mach
condition|)
block|{
case|case
literal|0
case|:
default|default:
name|target_processor
operator|=
name|PROCESSOR_V850
expr_stmt|;
break|break;
case|case
name|bfd_mach_v850e
case|:
name|target_processor
operator|=
name|PROCESSOR_V850E
expr_stmt|;
break|break;
case|case
name|bfd_mach_v850ea
case|:
name|target_processor
operator|=
name|PROCESSOR_V850EA
expr_stmt|;
break|break;
block|}
comment|/* Find the opcode.  */
while|while
condition|(
name|op
operator|->
name|name
condition|)
block|{
if|if
condition|(
operator|(
name|op
operator|->
name|mask
operator|&
name|insn
operator|)
operator|==
name|op
operator|->
name|opcode
operator|&&
operator|(
name|op
operator|->
name|processors
operator|&
name|target_processor
operator|)
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|opindex_ptr
decl_stmt|;
name|unsigned
name|int
name|opnum
decl_stmt|;
name|unsigned
name|int
name|memop
decl_stmt|;
name|match
operator|=
literal|1
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s\t"
argument_list|,
name|op
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/*fprintf (stderr, "match: mask: %x insn: %x, opcode: %x, name: %s\n", op->mask, insn, op->opcode, op->name );*/
name|memop
operator|=
name|op
operator|->
name|memop
expr_stmt|;
comment|/* Now print the operands.  	     MEMOP is the operand number at which a memory 	     address specification starts, or zero if this 	     instruction has no memory addresses.  	     A memory address is always two arguments.  	     This information allows us to determine when to 	     insert commas into the output stream as well as 	     when to insert disp[reg] expressions onto the 	     output stream.  */
for|for
control|(
name|opindex_ptr
operator|=
name|op
operator|->
name|operands
operator|,
name|opnum
operator|=
literal|1
init|;
operator|*
name|opindex_ptr
operator|!=
literal|0
condition|;
name|opindex_ptr
operator|++
operator|,
name|opnum
operator|++
control|)
block|{
name|long
name|value
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|status
decl_stmt|;
name|bfd_byte
name|buffer
index|[
literal|4
index|]
decl_stmt|;
name|operand
operator|=
operator|&
name|v850_operands
index|[
operator|*
name|opindex_ptr
index|]
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|extract
condition|)
name|value
operator|=
call|(
name|operand
operator|->
name|extract
call|)
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
operator|-
literal|1
condition|)
name|value
operator|=
operator|(
name|insn
operator|&
name|operand
operator|->
name|shift
operator|)
expr_stmt|;
else|else
name|value
operator|=
operator|(
name|insn
operator|>>
name|operand
operator|->
name|shift
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_SIGNED
condition|)
name|value
operator|=
operator|(
call|(
name|long
call|)
argument_list|(
name|value
operator|<<
operator|(
literal|32
operator|-
name|operand
operator|->
name|bits
operator|)
argument_list|)
operator|>>
operator|(
literal|32
operator|-
name|operand
operator|->
name|bits
operator|)
operator|)
expr_stmt|;
block|}
comment|/* The first operand is always output without any 		 special handling.  		 For the following arguments:  		   If memop&& opnum == memop + 1, then we need '[' since 		   we're about to output the register used in a memory 		   reference.  		   If memop&& opnum == memop + 2, then we need ']' since 		   we just finished the register in a memory reference.  We 		   also need a ',' before this operand.  		   Else we just need a comma.  		   We may need to output a trailing ']' if the last operand 		   in an instruction is the register for a memory address.   		   The exception (and there's always an exception) is the 		   "jmp" insn which needs square brackets around it's only 		   register argument.  */
if|if
condition|(
name|memop
operator|&&
name|opnum
operator|==
name|memop
operator|+
literal|1
condition|)
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|memop
operator|&&
name|opnum
operator|==
name|memop
operator|+
literal|2
condition|)
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"],"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|memop
operator|==
literal|1
operator|&&
name|opnum
operator|==
literal|1
operator|&&
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_REG
operator|)
condition|)
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opnum
operator|>
literal|1
condition|)
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
comment|/* extract the flags, ignorng ones which do not effect disassembly output. */
name|flag
operator|=
name|operand
operator|->
name|flags
expr_stmt|;
name|flag
operator|&=
operator|~
name|V850_OPERAND_SIGNED
expr_stmt|;
name|flag
operator|&=
operator|~
name|V850_OPERAND_RELAX
expr_stmt|;
name|flag
operator|&=
operator|-
name|flag
expr_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|V850_OPERAND_REG
case|:
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|v850_reg_names
index|[
name|value
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|V850_OPERAND_SRG
case|:
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|v850_sreg_names
index|[
name|value
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|V850_OPERAND_CC
case|:
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|v850_cc_names
index|[
name|value
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|V850_OPERAND_EP
case|:
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"ep"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|V850_OPERAND_DISP
case|:
block|{
name|bfd_vma
name|addr
init|=
name|value
operator|+
name|memaddr
decl_stmt|;
comment|/* On the v850 the top 8 bits of an address are used by an overlay manager. 		       Thus it may happen that when we are looking for a symbol to match 		       against an address with some of its top bits set, the search fails to 		       turn up an exact match.  In this case we try to find an exact match 		       against a symbol in the lower address space, and if we find one, we 		       use that address.   We only do this for JARL instructions however, as 		       we do not want to misinterpret branch instructions.  */
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
literal|22
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|symbol_at_address_func
argument_list|(
name|addr
argument_list|,
name|info
argument_list|)
operator|&&
operator|(
operator|(
name|addr
operator|&
literal|0xFF000000
operator|)
operator|!=
literal|0
operator|)
operator|&&
name|info
operator|->
name|symbol_at_address_func
argument_list|(
name|addr
operator|&
literal|0x00FFFFFF
argument_list|,
name|info
argument_list|)
condition|)
block|{
name|addr
operator|&=
literal|0x00FFFFFF
expr_stmt|;
block|}
block|}
name|info
operator|->
name|print_address_func
argument_list|(
name|addr
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|V850E_PUSH_POP
case|:
block|{
specifier|static
name|int
name|list12_regs
index|[
literal|32
index|]
init|=
block|{
literal|30
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|31
block|,
literal|29
block|,
literal|28
block|,
literal|23
block|,
literal|22
block|,
literal|21
block|,
literal|20
block|,
literal|27
block|,
literal|26
block|,
literal|25
block|,
literal|24
block|}
decl_stmt|;
specifier|static
name|int
name|list18_h_regs
index|[
literal|32
index|]
init|=
block|{
literal|19
block|,
literal|18
block|,
literal|17
block|,
literal|16
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|30
block|,
literal|31
block|,
literal|29
block|,
literal|28
block|,
literal|23
block|,
literal|22
block|,
literal|21
block|,
literal|20
block|,
literal|27
block|,
literal|26
block|,
literal|25
block|,
literal|24
block|}
decl_stmt|;
specifier|static
name|int
name|list18_l_regs
index|[
literal|32
index|]
init|=
block|{
literal|3
block|,
literal|2
block|,
literal|1
block|,
operator|-
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|14
block|,
literal|15
block|,
literal|13
block|,
literal|12
block|,
literal|7
block|,
literal|6
block|,
literal|5
block|,
literal|4
block|,
literal|11
block|,
literal|10
block|,
literal|9
block|,
literal|8
block|}
decl_stmt|;
name|int
modifier|*
name|regs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|int
name|mask
init|=
literal|0
decl_stmt|;
name|int
name|pc
init|=
name|false
decl_stmt|;
name|int
name|sr
init|=
name|false
decl_stmt|;
switch|switch
condition|(
name|operand
operator|->
name|shift
condition|)
block|{
case|case
literal|0xffe00001
case|:
name|regs
operator|=
name|list12_regs
expr_stmt|;
break|break;
case|case
literal|0xfff8000f
case|:
name|regs
operator|=
name|list18_h_regs
expr_stmt|;
break|break;
case|case
literal|0xfff8001f
case|:
name|regs
operator|=
name|list18_l_regs
expr_stmt|;
name|value
operator|&=
operator|~
literal|0x10
expr_stmt|;
break|break;
comment|/* Do not include magic bit */
default|default:
comment|/* xgettext:c-format */
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"unknown operand shift: %x\n"
argument_list|)
argument_list|,
name|operand
operator|->
name|shift
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|value
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
switch|switch
condition|(
name|regs
index|[
name|i
index|]
condition|)
block|{
default|default:
name|mask
operator||=
operator|(
literal|1
operator|<<
name|regs
index|[
name|i
index|]
operator|)
expr_stmt|;
break|break;
comment|/* xgettext:c-format */
case|case
literal|0
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"unknown pop reg: %d\n"
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
case|case
operator|-
literal|1
case|:
name|pc
operator|=
name|true
expr_stmt|;
break|break;
case|case
operator|-
literal|2
case|:
name|sr
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
block|}
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|||
name|pc
operator|||
name|sr
condition|)
block|{
if|if
condition|(
name|mask
condition|)
block|{
name|unsigned
name|int
name|bit
decl_stmt|;
name|int
name|shown_one
init|=
name|false
decl_stmt|;
for|for
control|(
name|bit
operator|=
literal|0
init|;
name|bit
operator|<
literal|32
condition|;
name|bit
operator|++
control|)
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|bit
operator|)
condition|)
block|{
name|unsigned
name|long
name|int
name|first
init|=
name|bit
decl_stmt|;
name|unsigned
name|long
name|int
name|last
decl_stmt|;
if|if
condition|(
name|shown_one
condition|)
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
else|else
name|shown_one
operator|=
name|true
expr_stmt|;
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
name|v850_reg_names
index|[
name|first
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|bit
operator|++
init|;
name|bit
operator|<
literal|32
condition|;
name|bit
operator|++
control|)
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|bit
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|last
operator|=
name|bit
expr_stmt|;
if|if
condition|(
name|last
operator|>
name|first
operator|+
literal|1
condition|)
block|{
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|" - %s"
argument_list|,
name|v850_reg_names
index|[
name|last
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|pc
condition|)
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%sPC"
argument_list|,
name|mask
condition|?
literal|", "
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr
condition|)
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%sSR"
argument_list|,
operator|(
name|mask
operator|||
name|pc
operator|)
condition|?
literal|", "
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|V850E_IMMEDIATE16
case|:
name|status
operator|=
name|info
operator|->
name|read_memory_func
argument_list|(
name|memaddr
operator|+
name|bytes_read
argument_list|,
name|buffer
argument_list|,
literal|2
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|bytes_read
operator|+=
literal|2
expr_stmt|;
name|value
operator|=
name|bfd_getl16
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* If this is a DISPOSE instruction with ff set to 0x10, then shift value up by 16.  */
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x001fffc0
operator|)
operator|==
literal|0x00130780
condition|)
name|value
operator|<<=
literal|16
expr_stmt|;
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|info
operator|->
name|memory_error_func
argument_list|(
name|status
argument_list|,
name|memaddr
operator|+
name|bytes_read
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|V850E_IMMEDIATE32
case|:
name|status
operator|=
name|info
operator|->
name|read_memory_func
argument_list|(
name|memaddr
operator|+
name|bytes_read
argument_list|,
name|buffer
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|bytes_read
operator|+=
literal|4
expr_stmt|;
name|value
operator|=
name|bfd_getl32
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|info
operator|->
name|memory_error_func
argument_list|(
name|status
argument_list|,
name|memaddr
operator|+
name|bytes_read
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* Handle jmp correctly.  */
if|if
condition|(
name|memop
operator|==
literal|1
operator|&&
name|opnum
operator|==
literal|1
operator|&&
operator|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|V850_OPERAND_REG
operator|)
operator|!=
literal|0
operator|)
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
block|}
comment|/* Close any square bracket we left open.  */
if|if
condition|(
name|memop
operator|&&
name|opnum
operator|==
name|memop
operator|+
literal|2
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
comment|/* All done. */
break|break;
block|}
name|op
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|match
condition|)
block|{
if|if
condition|(
name|short_op
condition|)
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|".short\t0x%04x"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|info
operator|->
name|fprintf_func
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|".long\t0x%08x"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
name|bytes_read
return|;
block|}
end_function

begin_function
name|int
name|print_insn_v850
parameter_list|(
name|memaddr
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|memaddr
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|bfd_byte
name|buffer
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|long
name|insn
init|=
literal|0
decl_stmt|;
comment|/* First figure out how big the opcode is.  */
name|status
operator|=
name|info
operator|->
name|read_memory_func
argument_list|(
name|memaddr
argument_list|,
name|buffer
argument_list|,
literal|2
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|insn
operator|=
name|bfd_getl16
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x0600
operator|)
operator|==
literal|0x0600
operator|&&
operator|(
name|insn
operator|&
literal|0xffe0
operator|)
operator|!=
literal|0x0620
condition|)
block|{
comment|/* If this is a 4 byte insn, read 4 bytes of stuff.  */
name|status
operator|=
name|info
operator|->
name|read_memory_func
argument_list|(
name|memaddr
argument_list|,
name|buffer
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|insn
operator|=
name|bfd_getl32
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|info
operator|->
name|memory_error_func
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Make sure we tell our caller how many bytes we consumed.  */
return|return
name|disassemble
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|,
name|insn
argument_list|)
return|;
block|}
end_function

end_unit

