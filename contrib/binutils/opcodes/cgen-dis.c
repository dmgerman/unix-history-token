begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* CGEN generic disassembler support code.     Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.     This file is part of the GNU Binutils and GDB, the GNU debugger.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symcat.h"
end_include

begin_include
include|#
directive|include
file|"opcode/cgen.h"
end_include

begin_comment
comment|/* This is not published as part of the public interface so we don't    declare this in cgen.h.  */
end_comment

begin_decl_stmt
specifier|extern
name|CGEN_OPCODE_DATA
modifier|*
name|cgen_current_opcode_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Disassembler instruction hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|CGEN_INSN_LIST
modifier|*
modifier|*
name|dis_hash_table
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|cgen_dis_init
parameter_list|()
block|{
if|if
condition|(
name|dis_hash_table
condition|)
block|{
name|free
argument_list|(
name|dis_hash_table
argument_list|)
expr_stmt|;
name|dis_hash_table
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build the disassembler instruction hash table.  */
end_comment

begin_function
specifier|static
name|void
name|build_dis_hash_table
parameter_list|()
block|{
name|int
name|bigend
init|=
name|cgen_current_endian
operator|==
name|CGEN_ENDIAN_BIG
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
name|int
name|count
init|=
name|cgen_insn_count
argument_list|()
decl_stmt|;
name|CGEN_OPCODE_DATA
modifier|*
name|data
init|=
name|cgen_current_opcode_data
decl_stmt|;
name|CGEN_INSN_TABLE
modifier|*
name|insn_table
init|=
name|data
operator|->
name|insn_table
decl_stmt|;
name|unsigned
name|int
name|entry_size
init|=
name|insn_table
operator|->
name|entry_size
decl_stmt|;
name|unsigned
name|int
name|hash_size
init|=
name|insn_table
operator|->
name|dis_hash_table_size
decl_stmt|;
specifier|const
name|CGEN_INSN
modifier|*
name|insn
decl_stmt|;
name|CGEN_INSN_LIST
modifier|*
name|insn_lists
decl_stmt|;
name|CGEN_INSN_LIST
modifier|*
name|new_insns
decl_stmt|;
comment|/* The space allocated for the hash table consists of two parts:      the hash table and the hash lists.  */
name|dis_hash_table
operator|=
operator|(
name|CGEN_INSN_LIST
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|hash_size
operator|*
sizeof|sizeof
argument_list|(
name|CGEN_INSN_LIST
operator|*
argument_list|)
operator|+
name|count
operator|*
sizeof|sizeof
argument_list|(
name|CGEN_INSN_LIST
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dis_hash_table
argument_list|,
literal|0
argument_list|,
name|hash_size
operator|*
sizeof|sizeof
argument_list|(
name|CGEN_INSN_LIST
operator|*
argument_list|)
operator|+
name|count
operator|*
sizeof|sizeof
argument_list|(
name|CGEN_INSN_LIST
argument_list|)
argument_list|)
expr_stmt|;
name|insn_lists
operator|=
operator|(
name|CGEN_INSN_LIST
operator|*
operator|)
operator|(
name|dis_hash_table
operator|+
name|hash_size
operator|)
expr_stmt|;
comment|/* Add compiled in insns.      The table is scanned backwards as later additions are inserted in      front of earlier ones and we want earlier ones to be prefered.      We stop at the first one as it is a reserved entry.      This is a bit tricky as the attribute member of CGEN_INSN is variable      among architectures.  This code could be moved to cgen-asm.in, but      I prefer to keep it here for now.  */
for|for
control|(
name|insn
operator|=
operator|(
name|CGEN_INSN
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|insn_table
operator|->
name|init_entries
operator|+
name|entry_size
operator|*
operator|(
name|insn_table
operator|->
name|num_init_entries
operator|-
literal|1
operator|)
operator|)
init|;
name|insn
operator|>
name|insn_table
operator|->
name|init_entries
condition|;
name|insn
operator|=
operator|(
name|CGEN_INSN
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|insn
operator|-
name|entry_size
operator|)
operator|,
operator|++
name|insn_lists
control|)
block|{
comment|/* We don't know whether the target uses the buffer or the base insn 	 to hash on, so set both up.  */
name|value
operator|=
name|CGEN_INSN_VALUE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|CGEN_INSN_MASK_BITSIZE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
literal|8
case|:
name|buf
index|[
literal|0
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|16
case|:
if|if
condition|(
name|bigend
condition|)
name|bfd_putb16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
if|if
condition|(
name|bigend
condition|)
name|bfd_putb32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|bfd_putl32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|hash
operator|=
name|insn_table
operator|->
name|dis_hash
argument_list|(
name|buf
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|insn_lists
operator|->
name|next
operator|=
name|dis_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|insn_lists
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|dis_hash_table
index|[
name|hash
index|]
operator|=
name|insn_lists
expr_stmt|;
block|}
comment|/* Add runtime added insns.      ??? Currently later added insns will be prefered over earlier ones.      Not sure this is a bug or not.  */
for|for
control|(
name|new_insns
operator|=
name|insn_table
operator|->
name|new_entries
init|;
name|new_insns
operator|!=
name|NULL
condition|;
name|new_insns
operator|=
name|new_insns
operator|->
name|next
operator|,
operator|++
name|insn_lists
control|)
block|{
comment|/* We don't know whether the target uses the buffer or the base insn 	 to hash on, so set both up.  */
name|value
operator|=
name|CGEN_INSN_VALUE
argument_list|(
name|new_insns
operator|->
name|insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|CGEN_INSN_MASK_BITSIZE
argument_list|(
name|new_insns
operator|->
name|insn
argument_list|)
condition|)
block|{
case|case
literal|8
case|:
name|buf
index|[
literal|0
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|16
case|:
if|if
condition|(
name|bigend
condition|)
name|bfd_putb16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|bfd_putl16
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
if|if
condition|(
name|bigend
condition|)
name|bfd_putb32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|bfd_putl32
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|hash
operator|=
name|insn_table
operator|->
name|dis_hash
argument_list|(
name|buf
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|insn_lists
operator|->
name|next
operator|=
name|dis_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|insn_lists
operator|->
name|insn
operator|=
name|new_insns
operator|->
name|insn
expr_stmt|;
name|dis_hash_table
index|[
name|hash
index|]
operator|=
name|insn_lists
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the first entry in the hash list for INSN.  */
end_comment

begin_function
name|CGEN_INSN_LIST
modifier|*
name|cgen_dis_lookup_insn
parameter_list|(
name|buf
parameter_list|,
name|value
parameter_list|)
specifier|const
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
block|{
name|unsigned
name|int
name|hash
decl_stmt|;
if|if
condition|(
name|dis_hash_table
operator|==
name|NULL
condition|)
name|build_dis_hash_table
argument_list|()
expr_stmt|;
name|hash
operator|=
name|cgen_current_opcode_data
operator|->
name|insn_table
operator|->
name|dis_hash
argument_list|(
name|buf
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|dis_hash_table
index|[
name|hash
index|]
return|;
block|}
end_function

end_unit

