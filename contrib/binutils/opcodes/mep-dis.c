begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Disassembler interface for targets using CGEN. -*- C -*-    CGEN: Cpu tools GENerator     THIS FILE IS MACHINE GENERATED WITH CGEN.    - the resultant file is machine generated, cgen-dis.in isn't     Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005    Free Software Foundation, Inc.     This file is part of the GNU Binutils and GDB, the GNU debugger.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation, Inc.,    51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* ??? Eventually more and more of this stuff can go to cpu-independent files.    Keep that in mind.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symcat.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"mep-desc.h"
end_include

begin_include
include|#
directive|include
file|"mep-opc.h"
end_include

begin_include
include|#
directive|include
file|"opintl.h"
end_include

begin_comment
comment|/* Default text to print if an instruction isn't recognized.  */
end_comment

begin_define
define|#
directive|define
name|UNKNOWN_INSN_MSG
value|_("*unknown*")
end_define

begin_function_decl
specifier|static
name|void
name|print_normal
parameter_list|(
name|CGEN_CPU_DESC
parameter_list|,
name|void
modifier|*
parameter_list|,
name|long
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|bfd_vma
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|print_address
argument_list|(
name|CGEN_CPU_DESC
argument_list|,
name|void
operator|*
argument_list|,
name|bfd_vma
argument_list|,
name|unsigned
name|int
argument_list|,
name|bfd_vma
argument_list|,
name|int
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_keyword
argument_list|(
name|CGEN_CPU_DESC
argument_list|,
name|void
operator|*
argument_list|,
name|CGEN_KEYWORD
operator|*
argument_list|,
name|long
argument_list|,
name|unsigned
name|int
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|print_insn_normal
parameter_list|(
name|CGEN_CPU_DESC
parameter_list|,
name|void
modifier|*
parameter_list|,
specifier|const
name|CGEN_INSN
modifier|*
parameter_list|,
name|CGEN_FIELDS
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|print_insn
parameter_list|(
name|CGEN_CPU_DESC
parameter_list|,
name|bfd_vma
parameter_list|,
name|disassemble_info
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|default_print_insn
argument_list|(
name|CGEN_CPU_DESC
argument_list|,
name|bfd_vma
argument_list|,
name|disassemble_info
operator|*
argument_list|)
name|ATTRIBUTE_UNUSED
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|read_insn
parameter_list|(
name|CGEN_CPU_DESC
parameter_list|,
name|bfd_vma
parameter_list|,
name|disassemble_info
modifier|*
parameter_list|,
name|bfd_byte
modifier|*
parameter_list|,
name|int
parameter_list|,
name|CGEN_EXTRACT_INFO
modifier|*
parameter_list|,
name|unsigned
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* -- disassembler routines inserted here.  */
end_comment

begin_comment
comment|/* -- dis.c */
end_comment

begin_include
include|#
directive|include
file|"elf/mep.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_define
define|#
directive|define
name|CGEN_VALIDATE_INSN_SUPPORTED
end_define

begin_function_decl
specifier|static
name|void
name|print_tpreg
parameter_list|(
name|CGEN_CPU_DESC
parameter_list|,
name|PTR
parameter_list|,
name|CGEN_KEYWORD
modifier|*
parameter_list|,
name|long
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_spreg
parameter_list|(
name|CGEN_CPU_DESC
parameter_list|,
name|PTR
parameter_list|,
name|CGEN_KEYWORD
modifier|*
parameter_list|,
name|long
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|print_tpreg
parameter_list|(
name|CGEN_CPU_DESC
name|cd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|PTR
name|dis_info
parameter_list|,
name|CGEN_KEYWORD
modifier|*
name|table
name|ATTRIBUTE_UNUSED
parameter_list|,
name|long
name|val
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|disassemble_info
modifier|*
name|info
init|=
operator|(
name|disassemble_info
operator|*
operator|)
name|dis_info
decl_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"$tp"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_spreg
parameter_list|(
name|CGEN_CPU_DESC
name|cd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|PTR
name|dis_info
parameter_list|,
name|CGEN_KEYWORD
modifier|*
name|table
name|ATTRIBUTE_UNUSED
parameter_list|,
name|long
name|val
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|disassemble_info
modifier|*
name|info
init|=
operator|(
name|disassemble_info
operator|*
operator|)
name|dis_info
decl_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"$sp"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* begin-cop-ip-print-handlers */
end_comment

begin_function
specifier|static
name|void
name|print_fmax_cr
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|,
name|void
modifier|*
name|dis_info
parameter_list|,
name|CGEN_KEYWORD
modifier|*
name|keyword_table
name|ATTRIBUTE_UNUSED
parameter_list|,
name|long
name|value
parameter_list|,
name|unsigned
name|int
name|attrs
parameter_list|)
block|{
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|dis_info
argument_list|,
operator|&
name|mep_cgen_opval_h_cr_fmax
argument_list|,
name|value
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_fmax_ccr
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|,
name|void
modifier|*
name|dis_info
parameter_list|,
name|CGEN_KEYWORD
modifier|*
name|keyword_table
name|ATTRIBUTE_UNUSED
parameter_list|,
name|long
name|value
parameter_list|,
name|unsigned
name|int
name|attrs
parameter_list|)
block|{
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|dis_info
argument_list|,
operator|&
name|mep_cgen_opval_h_ccr_fmax
argument_list|,
name|value
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end-cop-ip-print-handlers */
end_comment

begin_comment
comment|/************************************************************\ *********************** Experimental ************************* \************************************************************/
end_comment

begin_undef
undef|#
directive|undef
name|CGEN_PRINT_INSN
end_undef

begin_define
define|#
directive|define
name|CGEN_PRINT_INSN
value|mep_print_insn
end_define

begin_function
specifier|static
name|int
name|mep_print_vliw_insns
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|,
name|bfd_vma
name|pc
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|bfd_byte
modifier|*
name|buf
parameter_list|,
name|int
name|corelength
parameter_list|,
name|int
name|copro1length
parameter_list|,
name|int
name|copro2length
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
comment|/* char insnbuf[CGEN_MAX_INSN_SIZE]; */
name|bfd_byte
name|insnbuf
index|[
literal|64
index|]
decl_stmt|;
comment|/* If corelength> 0 then there is a core insn present. It      will be at the beginning of the buffer.  After printing      the core insn, we need to print the + on the next line.  */
if|if
condition|(
name|corelength
operator|>
literal|0
condition|)
block|{
name|int
name|my_status
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|corelength
condition|;
name|i
operator|++
control|)
name|insnbuf
index|[
name|i
index|]
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
name|cd
operator|->
name|isas
operator|=
operator|&
name|MEP_CORE_ISA
expr_stmt|;
name|my_status
operator|=
name|print_insn
argument_list|(
name|cd
argument_list|,
name|pc
argument_list|,
name|info
argument_list|,
name|insnbuf
argument_list|,
name|corelength
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_status
operator|!=
name|corelength
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
name|UNKNOWN_INSN_MSG
argument_list|)
expr_stmt|;
name|my_status
operator|=
name|corelength
expr_stmt|;
block|}
name|status
operator|+=
name|my_status
expr_stmt|;
comment|/* Print the + to indicate that the following copro insn is   */
comment|/* part of a vliw group.                                      */
if|if
condition|(
name|copro1length
operator|>
literal|0
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|" + "
argument_list|)
expr_stmt|;
block|}
comment|/* Now all that is left to be processed is the coprocessor insns      In vliw mode, there will always be one.  Its positioning will      be from byte corelength to byte corelength+copro1length -1.      No need to check for existence.   Also, the first vliw insn,      will, as spec'd, always be at least as long as the core insn      so we don't need to flush the buffer.  */
if|if
condition|(
name|copro1length
operator|>
literal|0
condition|)
block|{
name|int
name|my_status
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|corelength
init|;
name|i
operator|<
name|corelength
operator|+
name|copro1length
condition|;
name|i
operator|++
control|)
name|insnbuf
index|[
name|i
operator|-
name|corelength
index|]
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|copro1length
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|2
case|:
name|cd
operator|->
name|isas
operator|=
operator|&
name|MEP_COP16_ISA
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|cd
operator|->
name|isas
operator|=
operator|&
name|MEP_COP32_ISA
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|cd
operator|->
name|isas
operator|=
operator|&
name|MEP_COP48_ISA
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|cd
operator|->
name|isas
operator|=
operator|&
name|MEP_COP64_ISA
expr_stmt|;
break|break;
default|default:
comment|/* Shouldn't be anything but 16,32,48,64.  */
break|break;
block|}
name|my_status
operator|=
name|print_insn
argument_list|(
name|cd
argument_list|,
name|pc
argument_list|,
name|info
argument_list|,
name|insnbuf
argument_list|,
name|copro1length
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_status
operator|!=
name|copro1length
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
name|UNKNOWN_INSN_MSG
argument_list|)
expr_stmt|;
name|my_status
operator|=
name|copro1length
expr_stmt|;
block|}
name|status
operator|+=
name|my_status
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Now we need to process the second copro insn if it exists. We      have no guarantee that the second copro insn will be longer      than the first, so we have to flush the buffer if we are have      a second copro insn to process.  If present, this insn will      be in the position from byte corelength+copro1length to byte      corelength+copro1length+copro2length-1 (which better equal 8      or else we're in big trouble.  */
block|if (copro2length> 0)     {       int my_status = 0;        for (i = 0; i< 64 ; i++) 	insnbuf[i] = 0;        for (i = corelength + copro1length; i< 64; i++) 	insnbuf[i - (corelength + copro1length)] = buf[i];              switch (copro2length) 	{ 	case 2: 	  cd->isas = 1<< ISA_EXT_COP1_16; 	  break; 	case 4: 	  cd->isas = 1<< ISA_EXT_COP1_32; 	  break; 	case 6: 	  cd->isas = 1<< ISA_EXT_COP1_48; 	  break; 	case 8: 	  cd->isas = 1<< ISA_EXT_COP1_64;  	  break; 	default:
comment|/* Shouldn't be anything but 16,32,48,64.  */
block|break; 	}        my_status = print_insn (cd, pc, info, insnbuf, copro2length);        if (my_status != copro2length) 	{ 	  (*info->fprintf_func) (info->stream, UNKNOWN_INSN_MSG); 	  my_status = copro2length; 	}        status += my_status;     }
endif|#
directive|endif
comment|/* Status should now be the number of bytes that were printed      which should be 4 for VLIW32 mode and 64 for VLIW64 mode.  */
if|if
condition|(
operator|(
operator|!
name|MEP_VLIW64
operator|&&
operator|(
name|status
operator|!=
literal|4
operator|)
operator|)
operator|||
operator|(
name|MEP_VLIW64
operator|&&
operator|(
name|status
operator|!=
literal|8
operator|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* The two functions mep_examine_vliw[32,64]_insns are used find out     which vliw combinaion (16 bit core with 48 bit copro, 32 bit core     with 32 bit copro, etc.) is present.  Later on, when internally       parallel coprocessors are handled, only these functions should        need to be changed.                                                    At this time only the following combinations are supported:         VLIW32 Mode:    16 bit core insn (core) and 16 bit coprocessor insn (cop1)    32 bit core insn (core)    32 bit coprocessor insn (cop1)    Note: As of this time, I do not believe we have enough information          to distinguish a 32 bit core insn from a 32 bit cop insn. Also,          no 16 bit coprocessor insns have been specified.       VLIW64 Mode:    16 bit core insn (core) and 48 bit coprocessor insn (cop1)    32 bit core insn (core) and 32 bit coprocessor insn (cop1)    64 bit coprocessor insn (cop1)       The framework for an internally parallel coprocessor is also    present (2nd coprocessor insn is cop2), but at this time it     is not used.  This only appears to be valid in VLIW64 mode.  */
end_comment

begin_function
specifier|static
name|int
name|mep_examine_vliw32_insns
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|,
name|bfd_vma
name|pc
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|buflength
decl_stmt|;
name|int
name|corebuflength
decl_stmt|;
name|int
name|cop1buflength
decl_stmt|;
name|int
name|cop2buflength
decl_stmt|;
name|bfd_byte
name|buf
index|[
name|CGEN_MAX_INSN_SIZE
index|]
decl_stmt|;
name|char
name|indicator16
index|[
literal|1
index|]
decl_stmt|;
name|char
name|indicatorcop32
index|[
literal|2
index|]
decl_stmt|;
comment|/* At this time we're not supporting internally parallel coprocessors,      so cop2buflength will always be 0.  */
name|cop2buflength
operator|=
literal|0
expr_stmt|;
comment|/* Read in 32 bits.  */
name|buflength
operator|=
literal|4
expr_stmt|;
comment|/* VLIW insn spans 4 bytes.  */
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|pc
argument_list|,
name|buf
argument_list|,
name|buflength
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|memory_error_func
call|)
argument_list|(
name|status
argument_list|,
name|pc
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Put the big endian representation of the bytes to be examined      in the temporary buffers for examination.  */
if|if
condition|(
name|info
operator|->
name|endian
operator|==
name|BFD_ENDIAN_BIG
condition|)
block|{
name|indicator16
index|[
literal|0
index|]
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|indicatorcop32
index|[
literal|0
index|]
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|indicatorcop32
index|[
literal|1
index|]
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|indicator16
index|[
literal|0
index|]
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|indicatorcop32
index|[
literal|0
index|]
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|indicatorcop32
index|[
literal|1
index|]
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* If the two high order bits are 00, 01 or 10, we have a 16 bit      core insn and a 48 bit copro insn.  */
if|if
condition|(
operator|(
name|indicator16
index|[
literal|0
index|]
operator|&
literal|0x80
operator|)
operator|&&
operator|(
name|indicator16
index|[
literal|0
index|]
operator|&
literal|0x40
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|indicatorcop32
index|[
literal|0
index|]
operator|&
literal|0xf0
operator|)
operator|==
literal|0xf0
operator|&&
operator|(
name|indicatorcop32
index|[
literal|1
index|]
operator|&
literal|0x07
operator|)
operator|==
literal|0x07
condition|)
block|{
comment|/* We have a 32 bit copro insn.  */
name|corebuflength
operator|=
literal|0
expr_stmt|;
comment|/* All 4 4ytes are one copro insn. */
name|cop1buflength
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* We have a 32 bit core.  */
name|corebuflength
operator|=
literal|4
expr_stmt|;
name|cop1buflength
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We have a 16 bit core insn and a 16 bit copro insn.  */
name|corebuflength
operator|=
literal|2
expr_stmt|;
name|cop1buflength
operator|=
literal|2
expr_stmt|;
block|}
comment|/* Now we have the distrubution set.  Print them out.  */
name|status
operator|=
name|mep_print_vliw_insns
argument_list|(
name|cd
argument_list|,
name|pc
argument_list|,
name|info
argument_list|,
name|buf
argument_list|,
name|corebuflength
argument_list|,
name|cop1buflength
argument_list|,
name|cop2buflength
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mep_examine_vliw64_insns
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|,
name|bfd_vma
name|pc
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|buflength
decl_stmt|;
name|int
name|corebuflength
decl_stmt|;
name|int
name|cop1buflength
decl_stmt|;
name|int
name|cop2buflength
decl_stmt|;
name|bfd_byte
name|buf
index|[
name|CGEN_MAX_INSN_SIZE
index|]
decl_stmt|;
name|char
name|indicator16
index|[
literal|1
index|]
decl_stmt|;
name|char
name|indicator64
index|[
literal|4
index|]
decl_stmt|;
comment|/* At this time we're not supporting internally parallel      coprocessors, so cop2buflength will always be 0.  */
name|cop2buflength
operator|=
literal|0
expr_stmt|;
comment|/* Read in 64 bits.  */
name|buflength
operator|=
literal|8
expr_stmt|;
comment|/* VLIW insn spans 8 bytes.  */
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|pc
argument_list|,
name|buf
argument_list|,
name|buflength
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|memory_error_func
call|)
argument_list|(
name|status
argument_list|,
name|pc
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* We have all 64 bits in the buffer now.  We have to figure out      what combination of instruction sizes are present.  The two      high order bits will indicate whether or not we have a 16 bit      core insn or not.  If not, then we have to look at the 7,8th      bytes to tell whether we have 64 bit copro insn or a 32 bit      core insn with a 32 bit copro insn.  Endianness will make a      difference here.  */
comment|/* Put the big endian representation of the bytes to be examined      in the temporary buffers for examination.  */
comment|/* indicator16[0] = buf[0];  */
if|if
condition|(
name|info
operator|->
name|endian
operator|==
name|BFD_ENDIAN_BIG
condition|)
block|{
name|indicator16
index|[
literal|0
index|]
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|indicator64
index|[
literal|0
index|]
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|indicator64
index|[
literal|1
index|]
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|indicator64
index|[
literal|2
index|]
operator|=
name|buf
index|[
literal|2
index|]
expr_stmt|;
name|indicator64
index|[
literal|3
index|]
operator|=
name|buf
index|[
literal|3
index|]
expr_stmt|;
block|}
else|else
block|{
name|indicator16
index|[
literal|0
index|]
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|indicator64
index|[
literal|0
index|]
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|indicator64
index|[
literal|1
index|]
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
name|indicator64
index|[
literal|2
index|]
operator|=
name|buf
index|[
literal|3
index|]
expr_stmt|;
name|indicator64
index|[
literal|3
index|]
operator|=
name|buf
index|[
literal|2
index|]
expr_stmt|;
block|}
comment|/* If the two high order bits are 00, 01 or 10, we have a 16 bit      core insn and a 48 bit copro insn.  */
if|if
condition|(
operator|(
name|indicator16
index|[
literal|0
index|]
operator|&
literal|0x80
operator|)
operator|&&
operator|(
name|indicator16
index|[
literal|0
index|]
operator|&
literal|0x40
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|indicator64
index|[
literal|0
index|]
operator|&
literal|0xf0
operator|)
operator|==
literal|0xf0
operator|&&
operator|(
name|indicator64
index|[
literal|1
index|]
operator|&
literal|0x07
operator|)
operator|==
literal|0x07
operator|&&
operator|(
operator|(
name|indicator64
index|[
literal|2
index|]
operator|&
literal|0xfe
operator|)
operator|!=
literal|0xf0
operator|||
operator|(
name|indicator64
index|[
literal|3
index|]
operator|&
literal|0xf4
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* We have a 64 bit copro insn.  */
name|corebuflength
operator|=
literal|0
expr_stmt|;
comment|/* All 8 bytes are one copro insn.  */
name|cop1buflength
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
comment|/* We have a 32 bit core insn and a 32 bit copro insn.  */
name|corebuflength
operator|=
literal|4
expr_stmt|;
name|cop1buflength
operator|=
literal|4
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We have a 16 bit core insn and a 48 bit copro insn.  */
name|corebuflength
operator|=
literal|2
expr_stmt|;
name|cop1buflength
operator|=
literal|6
expr_stmt|;
block|}
comment|/* Now we have the distrubution set.  Print them out. */
name|status
operator|=
name|mep_print_vliw_insns
argument_list|(
name|cd
argument_list|,
name|pc
argument_list|,
name|info
argument_list|,
name|buf
argument_list|,
name|corebuflength
argument_list|,
name|cop1buflength
argument_list|,
name|cop2buflength
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mep_print_insn
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|,
name|bfd_vma
name|pc
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
comment|/* Extract and adapt to configuration number, if available. */
if|if
condition|(
name|info
operator|->
name|section
operator|&&
name|info
operator|->
name|section
operator|->
name|owner
condition|)
block|{
name|bfd
modifier|*
name|abfd
init|=
name|info
operator|->
name|section
operator|->
name|owner
decl_stmt|;
name|mep_config_index
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|elf_obj_data
operator|->
name|elf_header
operator|->
name|e_flags
operator|&
name|EF_MEP_INDEX_MASK
expr_stmt|;
comment|/* This instantly redefines MEP_CONFIG, MEP_OMASK, .... MEP_VLIW64 */
block|}
comment|/* Picking the right ISA bitmask for the current context is tricky.  */
if|if
condition|(
name|info
operator|->
name|section
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|section
operator|->
name|flags
operator|&
name|SEC_MEP_VLIW
condition|)
block|{
comment|/* Are we in 32 or 64 bit vliw mode?  */
if|if
condition|(
name|MEP_VLIW64
condition|)
name|status
operator|=
name|mep_examine_vliw64_insns
argument_list|(
name|cd
argument_list|,
name|pc
argument_list|,
name|info
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|mep_examine_vliw32_insns
argument_list|(
name|cd
argument_list|,
name|pc
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* Both the above branches set their own isa bitmasks.  */
block|}
else|else
block|{
name|cd
operator|->
name|isas
operator|=
operator|&
name|MEP_CORE_ISA
expr_stmt|;
name|status
operator|=
name|default_print_insn
argument_list|(
name|cd
argument_list|,
name|pc
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* sid or gdb */
block|{
name|status
operator|=
name|default_print_insn
argument_list|(
name|cd
argument_list|,
name|pc
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* -- opc.c */
end_comment

begin_function_decl
name|void
name|mep_cgen_print_operand
parameter_list|(
name|CGEN_CPU_DESC
parameter_list|,
name|int
parameter_list|,
name|PTR
parameter_list|,
name|CGEN_FIELDS
modifier|*
parameter_list|,
name|void
specifier|const
modifier|*
parameter_list|,
name|bfd_vma
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Main entry point for printing operands.    XINFO is a `void *' and not a `disassemble_info *' to not put a requirement    of dis-asm.h on cgen.h.     This function is basically just a big switch statement.  Earlier versions    used tables to look up the function to use, but    - if the table contains both assembler and disassembler functions then      the disassembler contains much of the assembler and vice-versa,    - there's a lot of inlining possibilities as things grow,    - using a switch statement avoids the function call overhead.     This function could be moved into `print_insn_normal', but keeping it    separate makes clear the interface between `print_insn_normal' and each of    the handlers.  */
end_comment

begin_function
name|void
name|mep_cgen_print_operand
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|,
name|int
name|opindex
parameter_list|,
name|void
modifier|*
name|xinfo
parameter_list|,
name|CGEN_FIELDS
modifier|*
name|fields
parameter_list|,
name|void
specifier|const
modifier|*
name|attrs
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_vma
name|pc
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|disassemble_info
modifier|*
name|info
init|=
operator|(
name|disassemble_info
operator|*
operator|)
name|xinfo
decl_stmt|;
switch|switch
condition|(
name|opindex
condition|)
block|{
case|case
name|MEP_OPERAND_ADDR24A4
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_24u8a4n
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_VIRTUAL
operator|)
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_CALLNUM
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_callnum
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_VIRTUAL
operator|)
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_CCCC
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_rm
argument_list|,
literal|0
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_CCRN
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_ccr
argument_list|,
name|fields
operator|->
name|f_ccrn
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_VIRTUAL
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_CDISP8
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_8s24
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_SIGNED
operator|)
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_CDISP8A2
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_8s24a2
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_SIGNED
operator|)
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_CDISP8A4
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_8s24a4
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_SIGNED
operator|)
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_CDISP8A8
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_8s24a8
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_SIGNED
operator|)
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_CIMM4
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_rn
argument_list|,
literal|0
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_CIMM5
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_5u24
argument_list|,
literal|0
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_CODE16
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_16u16
argument_list|,
literal|0
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_CODE24
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_24u4n
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_VIRTUAL
operator|)
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_CP_FLAG
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_ccr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_CRN
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_cr
argument_list|,
name|fields
operator|->
name|f_crn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_CRN64
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_cr64
argument_list|,
name|fields
operator|->
name|f_crn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_CRNX
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_cr
argument_list|,
name|fields
operator|->
name|f_crnx
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_VIRTUAL
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_CRNX64
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_cr64
argument_list|,
name|fields
operator|->
name|f_crnx
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_VIRTUAL
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_CSRN
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_csr
argument_list|,
name|fields
operator|->
name|f_csrn
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_VIRTUAL
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_CSRN_IDX
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_csrn
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_VIRTUAL
operator|)
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_DBG
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_csr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_DEPC
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_csr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_EPC
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_csr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_EXC
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_csr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_FMAX_CCRN
case|:
name|print_fmax_ccr
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_ccr
argument_list|,
name|fields
operator|->
name|f_fmax_4_4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_FMAX_FRD
case|:
name|print_fmax_cr
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_cr
argument_list|,
name|fields
operator|->
name|f_fmax_frd
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_VIRTUAL
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_FMAX_FRD_INT
case|:
name|print_fmax_cr
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_cr
argument_list|,
name|fields
operator|->
name|f_fmax_frd
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_VIRTUAL
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_FMAX_FRM
case|:
name|print_fmax_cr
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_cr
argument_list|,
name|fields
operator|->
name|f_fmax_frm
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_VIRTUAL
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_FMAX_FRN
case|:
name|print_fmax_cr
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_cr
argument_list|,
name|fields
operator|->
name|f_fmax_frn
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_VIRTUAL
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_FMAX_FRN_INT
case|:
name|print_fmax_cr
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_cr
argument_list|,
name|fields
operator|->
name|f_fmax_frn
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_VIRTUAL
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_FMAX_RM
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_gpr
argument_list|,
name|fields
operator|->
name|f_fmax_rm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_HI
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_csr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_LO
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_csr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_LP
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_csr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_MB0
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_csr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_MB1
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_csr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_ME0
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_csr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_ME1
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_csr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_NPC
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_csr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_OPT
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_csr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_PCABS24A2
case|:
name|print_address
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_24u5a2n
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_ABS_ADDR
operator|)
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_VIRTUAL
operator|)
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_PCREL12A2
case|:
name|print_address
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_12s4a2
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_SIGNED
operator|)
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_RELAX
operator|)
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_PCREL_ADDR
operator|)
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_PCREL17A2
case|:
name|print_address
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_17s16a2
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_SIGNED
operator|)
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_RELAX
operator|)
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_PCREL_ADDR
operator|)
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_PCREL24A2
case|:
name|print_address
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_24s5a2n
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_SIGNED
operator|)
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_PCREL_ADDR
operator|)
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_VIRTUAL
operator|)
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_PCREL8A2
case|:
name|print_address
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_8s8a2
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_SIGNED
operator|)
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_RELAX
operator|)
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_PCREL_ADDR
operator|)
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_PSW
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_csr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_R0
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_gpr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_R1
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_gpr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_RL
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_gpr
argument_list|,
name|fields
operator|->
name|f_rl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_RM
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_gpr
argument_list|,
name|fields
operator|->
name|f_rm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_RMA
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_gpr
argument_list|,
name|fields
operator|->
name|f_rm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_RN
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_gpr
argument_list|,
name|fields
operator|->
name|f_rn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_RN3
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_gpr
argument_list|,
name|fields
operator|->
name|f_rn3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_RN3C
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_gpr
argument_list|,
name|fields
operator|->
name|f_rn3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_RN3L
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_gpr
argument_list|,
name|fields
operator|->
name|f_rn3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_RN3S
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_gpr
argument_list|,
name|fields
operator|->
name|f_rn3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_RN3UC
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_gpr
argument_list|,
name|fields
operator|->
name|f_rn3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_RN3UL
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_gpr
argument_list|,
name|fields
operator|->
name|f_rn3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_RN3US
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_gpr
argument_list|,
name|fields
operator|->
name|f_rn3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_RNC
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_gpr
argument_list|,
name|fields
operator|->
name|f_rn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_RNL
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_gpr
argument_list|,
name|fields
operator|->
name|f_rn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_RNS
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_gpr
argument_list|,
name|fields
operator|->
name|f_rn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_RNUC
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_gpr
argument_list|,
name|fields
operator|->
name|f_rn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_RNUL
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_gpr
argument_list|,
name|fields
operator|->
name|f_rn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_RNUS
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_gpr
argument_list|,
name|fields
operator|->
name|f_rn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_SAR
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_csr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_SDISP16
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_16s16
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_SIGNED
operator|)
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_SIMM16
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_16s16
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_SIGNED
operator|)
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_SIMM6
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_6s8
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_SIGNED
operator|)
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_SIMM8
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_8s8
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_SIGNED
operator|)
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_RELOC_IMPLIES_OVERFLOW
operator|)
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_SP
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_gpr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_SPR
case|:
name|print_spreg
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_gpr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_TP
case|:
name|print_keyword
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_gpr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_TPR
case|:
name|print_tpreg
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
operator|&
name|mep_cgen_opval_h_gpr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_UDISP2
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_2u6
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_SIGNED
operator|)
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_UDISP7
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_7u9
argument_list|,
literal|0
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_UDISP7A2
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_7u9a2
argument_list|,
literal|0
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_UDISP7A4
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_7u9a4
argument_list|,
literal|0
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_UIMM16
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_16u16
argument_list|,
literal|0
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_UIMM2
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_2u10
argument_list|,
literal|0
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_UIMM24
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_24u8n
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_VIRTUAL
operator|)
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_UIMM3
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_3u5
argument_list|,
literal|0
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_UIMM4
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_4u8
argument_list|,
literal|0
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_UIMM5
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_5u8
argument_list|,
literal|0
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_UIMM7A4
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|fields
operator|->
name|f_7u9a4
argument_list|,
literal|0
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEP_OPERAND_ZERO
case|:
name|print_normal
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
literal|0
argument_list|,
literal|0
operator||
operator|(
literal|1
operator|<<
name|CGEN_OPERAND_SIGNED
operator|)
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
default|default :
comment|/* xgettext:c-format */
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Unrecognized field %d while printing insn.\n"
argument_list|)
argument_list|,
name|opindex
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|cgen_print_fn
modifier|*
specifier|const
name|mep_cgen_print_handlers
index|[]
init|=
block|{
name|print_insn_normal
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|mep_cgen_init_dis
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|)
block|{
name|mep_cgen_init_opcode_table
argument_list|(
name|cd
argument_list|)
expr_stmt|;
name|mep_cgen_init_ibld_table
argument_list|(
name|cd
argument_list|)
expr_stmt|;
name|cd
operator|->
name|print_handlers
operator|=
operator|&
name|mep_cgen_print_handlers
index|[
literal|0
index|]
expr_stmt|;
name|cd
operator|->
name|print_operand
operator|=
name|mep_cgen_print_operand
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Default print handler.  */
end_comment

begin_function
specifier|static
name|void
name|print_normal
parameter_list|(
name|CGEN_CPU_DESC
name|cd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|dis_info
parameter_list|,
name|long
name|value
parameter_list|,
name|unsigned
name|int
name|attrs
parameter_list|,
name|bfd_vma
name|pc
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|length
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|disassemble_info
modifier|*
name|info
init|=
operator|(
name|disassemble_info
operator|*
operator|)
name|dis_info
decl_stmt|;
ifdef|#
directive|ifdef
name|CGEN_PRINT_NORMAL
name|CGEN_PRINT_NORMAL
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|value
argument_list|,
name|attrs
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Print the operand as directed by the attributes.  */
if|if
condition|(
name|CGEN_BOOL_ATTR
argument_list|(
name|attrs
argument_list|,
name|CGEN_OPERAND_SEM_ONLY
argument_list|)
condition|)
empty_stmt|;
comment|/* nothing to do */
elseif|else
if|if
condition|(
name|CGEN_BOOL_ATTR
argument_list|(
name|attrs
argument_list|,
name|CGEN_OPERAND_SIGNED
argument_list|)
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%ld"
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Default address handler.  */
end_comment

begin_function
specifier|static
name|void
name|print_address
parameter_list|(
name|CGEN_CPU_DESC
name|cd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|dis_info
parameter_list|,
name|bfd_vma
name|value
parameter_list|,
name|unsigned
name|int
name|attrs
parameter_list|,
name|bfd_vma
name|pc
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|length
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|disassemble_info
modifier|*
name|info
init|=
operator|(
name|disassemble_info
operator|*
operator|)
name|dis_info
decl_stmt|;
ifdef|#
directive|ifdef
name|CGEN_PRINT_ADDRESS
name|CGEN_PRINT_ADDRESS
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|value
argument_list|,
name|attrs
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Print the operand as directed by the attributes.  */
if|if
condition|(
name|CGEN_BOOL_ATTR
argument_list|(
name|attrs
argument_list|,
name|CGEN_OPERAND_SEM_ONLY
argument_list|)
condition|)
empty_stmt|;
comment|/* Nothing to do.  */
elseif|else
if|if
condition|(
name|CGEN_BOOL_ATTR
argument_list|(
name|attrs
argument_list|,
name|CGEN_OPERAND_PCREL_ADDR
argument_list|)
condition|)
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|value
argument_list|,
name|info
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CGEN_BOOL_ATTR
argument_list|(
name|attrs
argument_list|,
name|CGEN_OPERAND_ABS_ADDR
argument_list|)
condition|)
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|value
argument_list|,
name|info
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CGEN_BOOL_ATTR
argument_list|(
name|attrs
argument_list|,
name|CGEN_OPERAND_SIGNED
argument_list|)
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Keyword print handler.  */
end_comment

begin_function
specifier|static
name|void
name|print_keyword
parameter_list|(
name|CGEN_CPU_DESC
name|cd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|dis_info
parameter_list|,
name|CGEN_KEYWORD
modifier|*
name|keyword_table
parameter_list|,
name|long
name|value
parameter_list|,
name|unsigned
name|int
name|attrs
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|disassemble_info
modifier|*
name|info
init|=
operator|(
name|disassemble_info
operator|*
operator|)
name|dis_info
decl_stmt|;
specifier|const
name|CGEN_KEYWORD_ENTRY
modifier|*
name|ke
decl_stmt|;
name|ke
operator|=
name|cgen_keyword_lookup_value
argument_list|(
name|keyword_table
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|ke
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"???"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Default insn printer.     DIS_INFO is defined as `void *' so the disassembler needn't know anything    about disassemble_info.  */
end_comment

begin_function
specifier|static
name|void
name|print_insn_normal
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|,
name|void
modifier|*
name|dis_info
parameter_list|,
specifier|const
name|CGEN_INSN
modifier|*
name|insn
parameter_list|,
name|CGEN_FIELDS
modifier|*
name|fields
parameter_list|,
name|bfd_vma
name|pc
parameter_list|,
name|int
name|length
parameter_list|)
block|{
specifier|const
name|CGEN_SYNTAX
modifier|*
name|syntax
init|=
name|CGEN_INSN_SYNTAX
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|disassemble_info
modifier|*
name|info
init|=
operator|(
name|disassemble_info
operator|*
operator|)
name|dis_info
decl_stmt|;
specifier|const
name|CGEN_SYNTAX_CHAR_TYPE
modifier|*
name|syn
decl_stmt|;
name|CGEN_INIT_PRINT
argument_list|(
name|cd
argument_list|)
expr_stmt|;
for|for
control|(
name|syn
operator|=
name|CGEN_SYNTAX_STRING
argument_list|(
name|syntax
argument_list|)
init|;
operator|*
name|syn
condition|;
operator|++
name|syn
control|)
block|{
if|if
condition|(
name|CGEN_SYNTAX_MNEMONIC_P
argument_list|(
operator|*
name|syn
argument_list|)
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|CGEN_INSN_MNEMONIC
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|CGEN_SYNTAX_CHAR_P
argument_list|(
operator|*
name|syn
argument_list|)
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%c"
argument_list|,
name|CGEN_SYNTAX_CHAR
argument_list|(
operator|*
name|syn
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* We have an operand.  */
name|mep_cgen_print_operand
argument_list|(
name|cd
argument_list|,
name|CGEN_SYNTAX_FIELD
argument_list|(
operator|*
name|syn
argument_list|)
argument_list|,
name|info
argument_list|,
name|fields
argument_list|,
name|CGEN_INSN_ATTRS
argument_list|(
name|insn
argument_list|)
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of print_insn. Reads an insn into the given buffers and updates    the extract info.    Returns 0 if all is well, non-zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|read_insn
parameter_list|(
name|CGEN_CPU_DESC
name|cd
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bfd_vma
name|pc
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|bfd_byte
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|,
name|CGEN_EXTRACT_INFO
modifier|*
name|ex_info
parameter_list|,
name|unsigned
name|long
modifier|*
name|insn_value
parameter_list|)
block|{
name|int
name|status
init|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|pc
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|memory_error_func
call|)
argument_list|(
name|status
argument_list|,
name|pc
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ex_info
operator|->
name|dis_info
operator|=
name|info
expr_stmt|;
name|ex_info
operator|->
name|valid
operator|=
operator|(
literal|1
operator|<<
name|buflen
operator|)
operator|-
literal|1
expr_stmt|;
name|ex_info
operator|->
name|insn_bytes
operator|=
name|buf
expr_stmt|;
operator|*
name|insn_value
operator|=
name|bfd_get_bits
argument_list|(
name|buf
argument_list|,
name|buflen
operator|*
literal|8
argument_list|,
name|info
operator|->
name|endian
operator|==
name|BFD_ENDIAN_BIG
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Utility to print an insn.    BUF is the base part of the insn, target byte order, BUFLEN bytes long.    The result is the size of the insn in bytes or zero for an unknown insn    or -1 if an error occurs fetching data (memory_error_func will have    been called).  */
end_comment

begin_function
specifier|static
name|int
name|print_insn
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|,
name|bfd_vma
name|pc
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|bfd_byte
modifier|*
name|buf
parameter_list|,
name|unsigned
name|int
name|buflen
parameter_list|)
block|{
name|CGEN_INSN_INT
name|insn_value
decl_stmt|;
specifier|const
name|CGEN_INSN_LIST
modifier|*
name|insn_list
decl_stmt|;
name|CGEN_EXTRACT_INFO
name|ex_info
decl_stmt|;
name|int
name|basesize
decl_stmt|;
comment|/* Extract base part of instruction, just in case CGEN_DIS_* uses it. */
name|basesize
operator|=
name|cd
operator|->
name|base_insn_bitsize
operator|<
name|buflen
operator|*
literal|8
condition|?
name|cd
operator|->
name|base_insn_bitsize
else|:
name|buflen
operator|*
literal|8
expr_stmt|;
name|insn_value
operator|=
name|cgen_get_insn_value
argument_list|(
name|cd
argument_list|,
name|buf
argument_list|,
name|basesize
argument_list|)
expr_stmt|;
comment|/* Fill in ex_info fields like read_insn would.  Don't actually call      read_insn, since the incoming buffer is already read (and possibly      modified a la m32r).  */
name|ex_info
operator|.
name|valid
operator|=
operator|(
literal|1
operator|<<
name|buflen
operator|)
operator|-
literal|1
expr_stmt|;
name|ex_info
operator|.
name|dis_info
operator|=
name|info
expr_stmt|;
name|ex_info
operator|.
name|insn_bytes
operator|=
name|buf
expr_stmt|;
comment|/* The instructions are stored in hash lists.      Pick the first one and keep trying until we find the right one.  */
name|insn_list
operator|=
name|CGEN_DIS_LOOKUP_INSN
argument_list|(
name|cd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|insn_value
argument_list|)
expr_stmt|;
while|while
condition|(
name|insn_list
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|CGEN_INSN
modifier|*
name|insn
init|=
name|insn_list
operator|->
name|insn
decl_stmt|;
name|CGEN_FIELDS
name|fields
decl_stmt|;
name|int
name|length
decl_stmt|;
name|unsigned
name|long
name|insn_value_cropped
decl_stmt|;
ifdef|#
directive|ifdef
name|CGEN_VALIDATE_INSN_SUPPORTED
comment|/* Not needed as insn shouldn't be in hash lists if not supported.  */
comment|/* Supported by this cpu?  */
if|if
condition|(
operator|!
name|mep_cgen_insn_supported
argument_list|(
name|cd
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|insn_list
operator|=
name|CGEN_DIS_NEXT_INSN
argument_list|(
name|insn_list
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* Basic bit mask must be correct.  */
comment|/* ??? May wish to allow target to defer this check until the extract 	 handler.  */
comment|/* Base size may exceed this instruction's size.  Extract the          relevant part from the buffer. */
if|if
condition|(
call|(
name|unsigned
call|)
argument_list|(
name|CGEN_INSN_BITSIZE
argument_list|(
name|insn
argument_list|)
operator|/
literal|8
argument_list|)
operator|<
name|buflen
operator|&&
call|(
name|unsigned
call|)
argument_list|(
name|CGEN_INSN_BITSIZE
argument_list|(
name|insn
argument_list|)
operator|/
literal|8
argument_list|)
operator|<=
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
condition|)
name|insn_value_cropped
operator|=
name|bfd_get_bits
argument_list|(
name|buf
argument_list|,
name|CGEN_INSN_BITSIZE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|info
operator|->
name|endian
operator|==
name|BFD_ENDIAN_BIG
argument_list|)
expr_stmt|;
else|else
name|insn_value_cropped
operator|=
name|insn_value
expr_stmt|;
if|if
condition|(
operator|(
name|insn_value_cropped
operator|&
name|CGEN_INSN_BASE_MASK
argument_list|(
name|insn
argument_list|)
operator|)
operator|==
name|CGEN_INSN_BASE_VALUE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* Printing is handled in two passes.  The first pass parses the 	     machine insn and extracts the fields.  The second pass prints 	     them.  */
comment|/* Make sure the entire insn is loaded into insn_value, if it 	     can fit.  */
if|if
condition|(
operator|(
operator|(
name|unsigned
operator|)
name|CGEN_INSN_BITSIZE
argument_list|(
name|insn
argument_list|)
operator|>
name|cd
operator|->
name|base_insn_bitsize
operator|)
operator|&&
call|(
name|unsigned
call|)
argument_list|(
name|CGEN_INSN_BITSIZE
argument_list|(
name|insn
argument_list|)
operator|/
literal|8
argument_list|)
operator|<=
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
condition|)
block|{
name|unsigned
name|long
name|full_insn_value
decl_stmt|;
name|int
name|rc
init|=
name|read_insn
argument_list|(
name|cd
argument_list|,
name|pc
argument_list|,
name|info
argument_list|,
name|buf
argument_list|,
name|CGEN_INSN_BITSIZE
argument_list|(
name|insn
argument_list|)
operator|/
literal|8
argument_list|,
operator|&
name|ex_info
argument_list|,
operator|&
name|full_insn_value
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
name|rc
return|;
name|length
operator|=
name|CGEN_EXTRACT_FN
argument_list|(
name|cd
argument_list|,
name|insn
argument_list|)
argument_list|(
name|cd
argument_list|,
name|insn
argument_list|,
operator|&
name|ex_info
argument_list|,
name|full_insn_value
argument_list|,
operator|&
name|fields
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
else|else
name|length
operator|=
name|CGEN_EXTRACT_FN
argument_list|(
name|cd
argument_list|,
name|insn
argument_list|)
argument_list|(
name|cd
argument_list|,
name|insn
argument_list|,
operator|&
name|ex_info
argument_list|,
name|insn_value_cropped
argument_list|,
operator|&
name|fields
argument_list|,
name|pc
argument_list|)
expr_stmt|;
comment|/* Length< 0 -> error.  */
if|if
condition|(
name|length
operator|<
literal|0
condition|)
return|return
name|length
return|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|CGEN_PRINT_FN
argument_list|(
name|cd
argument_list|,
name|insn
argument_list|)
argument_list|(
name|cd
argument_list|,
name|info
argument_list|,
name|insn
argument_list|,
operator|&
name|fields
argument_list|,
name|pc
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* Length is in bits, result is in bytes.  */
return|return
name|length
operator|/
literal|8
return|;
block|}
block|}
name|insn_list
operator|=
name|CGEN_DIS_NEXT_INSN
argument_list|(
name|insn_list
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Default value for CGEN_PRINT_INSN.    The result is the size of the insn in bytes or zero for an unknown insn    or -1 if an error occured fetching bytes.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CGEN_PRINT_INSN
end_ifndef

begin_define
define|#
directive|define
name|CGEN_PRINT_INSN
value|default_print_insn
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|default_print_insn
parameter_list|(
name|CGEN_CPU_DESC
name|cd
parameter_list|,
name|bfd_vma
name|pc
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|bfd_byte
name|buf
index|[
name|CGEN_MAX_INSN_SIZE
index|]
decl_stmt|;
name|int
name|buflen
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* Attempt to read the base part of the insn.  */
name|buflen
operator|=
name|cd
operator|->
name|base_insn_bitsize
operator|/
literal|8
expr_stmt|;
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|pc
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/* Try again with the minimum part, if min< base.  */
if|if
condition|(
name|status
operator|!=
literal|0
operator|&&
operator|(
name|cd
operator|->
name|min_insn_bitsize
operator|<
name|cd
operator|->
name|base_insn_bitsize
operator|)
condition|)
block|{
name|buflen
operator|=
name|cd
operator|->
name|min_insn_bitsize
operator|/
literal|8
expr_stmt|;
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|pc
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|memory_error_func
call|)
argument_list|(
name|status
argument_list|,
name|pc
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|print_insn
argument_list|(
name|cd
argument_list|,
name|pc
argument_list|,
name|info
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Main entry point.    Print one instruction from PC on INFO->STREAM.    Return the size of the instruction (in bytes).  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|cpu_desc_list
block|{
name|struct
name|cpu_desc_list
modifier|*
name|next
decl_stmt|;
name|CGEN_BITSET
modifier|*
name|isa
decl_stmt|;
name|int
name|mach
decl_stmt|;
name|int
name|endian
decl_stmt|;
name|CGEN_CPU_DESC
name|cd
decl_stmt|;
block|}
name|cpu_desc_list
typedef|;
end_typedef

begin_function
name|int
name|print_insn_mep
parameter_list|(
name|bfd_vma
name|pc
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
specifier|static
name|cpu_desc_list
modifier|*
name|cd_list
init|=
literal|0
decl_stmt|;
name|cpu_desc_list
modifier|*
name|cl
init|=
literal|0
decl_stmt|;
specifier|static
name|CGEN_CPU_DESC
name|cd
init|=
literal|0
decl_stmt|;
specifier|static
name|CGEN_BITSET
modifier|*
name|prev_isa
decl_stmt|;
specifier|static
name|int
name|prev_mach
decl_stmt|;
specifier|static
name|int
name|prev_endian
decl_stmt|;
name|int
name|length
decl_stmt|;
name|CGEN_BITSET
modifier|*
name|isa
decl_stmt|;
name|int
name|mach
decl_stmt|;
name|int
name|endian
init|=
operator|(
name|info
operator|->
name|endian
operator|==
name|BFD_ENDIAN_BIG
condition|?
name|CGEN_ENDIAN_BIG
else|:
name|CGEN_ENDIAN_LITTLE
operator|)
decl_stmt|;
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
comment|/* ??? gdb will set mach but leave the architecture as "unknown" */
ifndef|#
directive|ifndef
name|CGEN_BFD_ARCH
define|#
directive|define
name|CGEN_BFD_ARCH
value|bfd_arch_mep
endif|#
directive|endif
name|arch
operator|=
name|info
operator|->
name|arch
expr_stmt|;
if|if
condition|(
name|arch
operator|==
name|bfd_arch_unknown
condition|)
name|arch
operator|=
name|CGEN_BFD_ARCH
expr_stmt|;
comment|/* There's no standard way to compute the machine or isa number      so we leave it to the target.  */
ifdef|#
directive|ifdef
name|CGEN_COMPUTE_MACH
name|mach
operator|=
name|CGEN_COMPUTE_MACH
argument_list|(
name|info
argument_list|)
expr_stmt|;
else|#
directive|else
name|mach
operator|=
name|info
operator|->
name|mach
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CGEN_COMPUTE_ISA
block|{
specifier|static
name|CGEN_BITSET
modifier|*
name|permanent_isa
decl_stmt|;
if|if
condition|(
operator|!
name|permanent_isa
condition|)
name|permanent_isa
operator|=
name|cgen_bitset_create
argument_list|(
name|MAX_ISAS
argument_list|)
expr_stmt|;
name|isa
operator|=
name|permanent_isa
expr_stmt|;
name|cgen_bitset_clear
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|cgen_bitset_add
argument_list|(
name|isa
argument_list|,
name|CGEN_COMPUTE_ISA
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|isa
operator|=
name|info
operator|->
name|insn_sets
expr_stmt|;
endif|#
directive|endif
comment|/* If we've switched cpu's, try to find a handle we've used before */
if|if
condition|(
name|cd
operator|&&
operator|(
name|cgen_bitset_compare
argument_list|(
name|isa
argument_list|,
name|prev_isa
argument_list|)
operator|!=
literal|0
operator|||
name|mach
operator|!=
name|prev_mach
operator|||
name|endian
operator|!=
name|prev_endian
operator|)
condition|)
block|{
name|cd
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cl
operator|=
name|cd_list
init|;
name|cl
condition|;
name|cl
operator|=
name|cl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|cgen_bitset_compare
argument_list|(
name|cl
operator|->
name|isa
argument_list|,
name|isa
argument_list|)
operator|==
literal|0
operator|&&
name|cl
operator|->
name|mach
operator|==
name|mach
operator|&&
name|cl
operator|->
name|endian
operator|==
name|endian
condition|)
block|{
name|cd
operator|=
name|cl
operator|->
name|cd
expr_stmt|;
name|prev_isa
operator|=
name|cd
operator|->
name|isas
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If we haven't initialized yet, initialize the opcode table.  */
if|if
condition|(
operator|!
name|cd
condition|)
block|{
specifier|const
name|bfd_arch_info_type
modifier|*
name|arch_type
init|=
name|bfd_lookup_arch
argument_list|(
name|arch
argument_list|,
name|mach
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|mach_name
decl_stmt|;
if|if
condition|(
operator|!
name|arch_type
condition|)
name|abort
argument_list|()
expr_stmt|;
name|mach_name
operator|=
name|arch_type
operator|->
name|printable_name
expr_stmt|;
name|prev_isa
operator|=
name|cgen_bitset_copy
argument_list|(
name|isa
argument_list|)
expr_stmt|;
name|prev_mach
operator|=
name|mach
expr_stmt|;
name|prev_endian
operator|=
name|endian
expr_stmt|;
name|cd
operator|=
name|mep_cgen_cpu_open
argument_list|(
name|CGEN_CPU_OPEN_ISAS
argument_list|,
name|prev_isa
argument_list|,
name|CGEN_CPU_OPEN_BFDMACH
argument_list|,
name|mach_name
argument_list|,
name|CGEN_CPU_OPEN_ENDIAN
argument_list|,
name|prev_endian
argument_list|,
name|CGEN_CPU_OPEN_END
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cd
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Save this away for future reference.  */
name|cl
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cpu_desc_list
argument_list|)
argument_list|)
expr_stmt|;
name|cl
operator|->
name|cd
operator|=
name|cd
expr_stmt|;
name|cl
operator|->
name|isa
operator|=
name|prev_isa
expr_stmt|;
name|cl
operator|->
name|mach
operator|=
name|mach
expr_stmt|;
name|cl
operator|->
name|endian
operator|=
name|endian
expr_stmt|;
name|cl
operator|->
name|next
operator|=
name|cd_list
expr_stmt|;
name|cd_list
operator|=
name|cl
expr_stmt|;
name|mep_cgen_init_dis
argument_list|(
name|cd
argument_list|)
expr_stmt|;
block|}
comment|/* We try to have as much common code as possible.      But at this point some targets need to take over.  */
comment|/* ??? Some targets may need a hook elsewhere.  Try to avoid this,      but if not possible try to move this hook elsewhere rather than      have two hooks.  */
name|length
operator|=
name|CGEN_PRINT_INSN
argument_list|(
name|cd
argument_list|,
name|pc
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
condition|)
return|return
name|length
return|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
name|UNKNOWN_INSN_MSG
argument_list|)
expr_stmt|;
return|return
name|cd
operator|->
name|default_insn_bitsize
operator|/
literal|8
return|;
block|}
end_function

end_unit

