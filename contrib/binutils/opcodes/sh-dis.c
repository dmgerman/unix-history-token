begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Disassemble SH instructions.    Copyright (C) 1993, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|STATIC_TABLE
end_define

begin_define
define|#
directive|define
name|DEFINE_TABLE
end_define

begin_include
include|#
directive|include
file|"sh-opc.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_define
define|#
directive|define
name|LITTLE_BIT
value|2
end_define

begin_function
specifier|static
name|int
name|print_insn_shx
parameter_list|(
name|memaddr
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|memaddr
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
name|fprintf_ftype
name|fprintf_fn
init|=
name|info
operator|->
name|fprintf_func
decl_stmt|;
name|void
modifier|*
name|stream
init|=
name|info
operator|->
name|stream
decl_stmt|;
name|unsigned
name|char
name|insn
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|char
name|nibs
index|[
literal|4
index|]
decl_stmt|;
name|int
name|status
decl_stmt|;
name|bfd_vma
name|relmask
init|=
operator|~
operator|(
name|bfd_vma
operator|)
literal|0
decl_stmt|;
name|sh_opcode_info
modifier|*
name|op
decl_stmt|;
name|status
operator|=
name|info
operator|->
name|read_memory_func
argument_list|(
name|memaddr
argument_list|,
name|insn
argument_list|,
literal|2
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|info
operator|->
name|memory_error_func
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|info
operator|->
name|flags
operator|&
name|LITTLE_BIT
condition|)
block|{
name|nibs
index|[
literal|0
index|]
operator|=
operator|(
name|insn
index|[
literal|1
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
name|nibs
index|[
literal|1
index|]
operator|=
name|insn
index|[
literal|1
index|]
operator|&
literal|0xf
expr_stmt|;
name|nibs
index|[
literal|2
index|]
operator|=
operator|(
name|insn
index|[
literal|0
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
name|nibs
index|[
literal|3
index|]
operator|=
name|insn
index|[
literal|0
index|]
operator|&
literal|0xf
expr_stmt|;
block|}
else|else
block|{
name|nibs
index|[
literal|0
index|]
operator|=
operator|(
name|insn
index|[
literal|0
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
name|nibs
index|[
literal|1
index|]
operator|=
name|insn
index|[
literal|0
index|]
operator|&
literal|0xf
expr_stmt|;
name|nibs
index|[
literal|2
index|]
operator|=
operator|(
name|insn
index|[
literal|1
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
name|nibs
index|[
literal|3
index|]
operator|=
name|insn
index|[
literal|1
index|]
operator|&
literal|0xf
expr_stmt|;
block|}
for|for
control|(
name|op
operator|=
name|sh_table
init|;
name|op
operator|->
name|name
condition|;
name|op
operator|++
control|)
block|{
name|int
name|n
decl_stmt|;
name|int
name|imm
init|=
literal|0
decl_stmt|;
name|int
name|rn
init|=
literal|0
decl_stmt|;
name|int
name|rm
init|=
literal|0
decl_stmt|;
name|int
name|rb
init|=
literal|0
decl_stmt|;
name|int
name|disp_pc
decl_stmt|;
name|bfd_vma
name|disp_pc_addr
init|=
literal|0
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|4
condition|;
name|n
operator|++
control|)
block|{
name|int
name|i
init|=
name|op
operator|->
name|nibbles
index|[
name|n
index|]
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|16
condition|)
block|{
if|if
condition|(
name|nibs
index|[
name|n
index|]
operator|==
name|i
condition|)
continue|continue;
goto|goto
name|fail
goto|;
block|}
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|BRANCH_8
case|:
name|imm
operator|=
operator|(
name|nibs
index|[
literal|2
index|]
operator|<<
literal|4
operator|)
operator||
operator|(
name|nibs
index|[
literal|3
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|imm
operator|&
literal|0x80
condition|)
name|imm
operator||=
operator|~
literal|0xff
expr_stmt|;
name|imm
operator|=
operator|(
operator|(
name|char
operator|)
name|imm
operator|)
operator|*
literal|2
operator|+
literal|4
expr_stmt|;
goto|goto
name|ok
goto|;
case|case
name|BRANCH_12
case|:
name|imm
operator|=
operator|(
operator|(
name|nibs
index|[
literal|1
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|nibs
index|[
literal|2
index|]
operator|<<
literal|4
operator|)
operator||
operator|(
name|nibs
index|[
literal|3
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|imm
operator|&
literal|0x800
condition|)
name|imm
operator||=
operator|~
literal|0xfff
expr_stmt|;
name|imm
operator|=
name|imm
operator|*
literal|2
operator|+
literal|4
expr_stmt|;
goto|goto
name|ok
goto|;
case|case
name|IMM_4
case|:
name|imm
operator|=
name|nibs
index|[
literal|3
index|]
expr_stmt|;
goto|goto
name|ok
goto|;
case|case
name|IMM_4BY2
case|:
name|imm
operator|=
name|nibs
index|[
literal|3
index|]
operator|<<
literal|1
expr_stmt|;
goto|goto
name|ok
goto|;
case|case
name|IMM_4BY4
case|:
name|imm
operator|=
name|nibs
index|[
literal|3
index|]
operator|<<
literal|2
expr_stmt|;
goto|goto
name|ok
goto|;
case|case
name|IMM_8
case|:
name|imm
operator|=
operator|(
name|nibs
index|[
literal|2
index|]
operator|<<
literal|4
operator|)
operator||
name|nibs
index|[
literal|3
index|]
expr_stmt|;
goto|goto
name|ok
goto|;
case|case
name|PCRELIMM_8BY2
case|:
name|imm
operator|=
operator|(
operator|(
name|nibs
index|[
literal|2
index|]
operator|<<
literal|4
operator|)
operator||
name|nibs
index|[
literal|3
index|]
operator|)
operator|<<
literal|1
expr_stmt|;
name|relmask
operator|=
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
expr_stmt|;
goto|goto
name|ok
goto|;
case|case
name|PCRELIMM_8BY4
case|:
name|imm
operator|=
operator|(
operator|(
name|nibs
index|[
literal|2
index|]
operator|<<
literal|4
operator|)
operator||
name|nibs
index|[
literal|3
index|]
operator|)
operator|<<
literal|2
expr_stmt|;
name|relmask
operator|=
operator|~
operator|(
name|bfd_vma
operator|)
literal|3
expr_stmt|;
goto|goto
name|ok
goto|;
case|case
name|IMM_8BY2
case|:
name|imm
operator|=
operator|(
operator|(
name|nibs
index|[
literal|2
index|]
operator|<<
literal|4
operator|)
operator||
name|nibs
index|[
literal|3
index|]
operator|)
operator|<<
literal|1
expr_stmt|;
goto|goto
name|ok
goto|;
case|case
name|IMM_8BY4
case|:
name|imm
operator|=
operator|(
operator|(
name|nibs
index|[
literal|2
index|]
operator|<<
literal|4
operator|)
operator||
name|nibs
index|[
literal|3
index|]
operator|)
operator|<<
literal|2
expr_stmt|;
goto|goto
name|ok
goto|;
case|case
name|DISP_8
case|:
name|imm
operator|=
operator|(
name|nibs
index|[
literal|2
index|]
operator|<<
literal|4
operator|)
operator||
operator|(
name|nibs
index|[
literal|3
index|]
operator|)
expr_stmt|;
goto|goto
name|ok
goto|;
case|case
name|DISP_4
case|:
name|imm
operator|=
name|nibs
index|[
literal|3
index|]
expr_stmt|;
goto|goto
name|ok
goto|;
case|case
name|REG_N
case|:
name|rn
operator|=
name|nibs
index|[
name|n
index|]
expr_stmt|;
break|break;
case|case
name|REG_M
case|:
name|rm
operator|=
name|nibs
index|[
name|n
index|]
expr_stmt|;
break|break;
case|case
name|REG_NM
case|:
name|rn
operator|=
operator|(
name|nibs
index|[
name|n
index|]
operator|&
literal|0xc
operator|)
operator|>>
literal|2
expr_stmt|;
name|rm
operator|=
operator|(
name|nibs
index|[
name|n
index|]
operator|&
literal|0x3
operator|)
expr_stmt|;
break|break;
case|case
name|REG_B
case|:
name|rb
operator|=
name|nibs
index|[
name|n
index|]
operator|&
literal|0x07
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|ok
label|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"%s\t"
argument_list|,
name|op
operator|->
name|name
argument_list|)
expr_stmt|;
name|disp_pc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|3
operator|&&
name|op
operator|->
name|arg
index|[
name|n
index|]
operator|!=
name|A_END
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|n
operator|&&
name|op
operator|->
name|arg
index|[
literal|1
index|]
operator|!=
name|A_END
condition|)
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|","
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
operator|->
name|arg
index|[
name|n
index|]
condition|)
block|{
case|case
name|A_IMM
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"#%d"
argument_list|,
call|(
name|char
call|)
argument_list|(
name|imm
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_R0
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"r0"
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_REG_N
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"r%d"
argument_list|,
name|rn
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_INC_N
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"@r%d+"
argument_list|,
name|rn
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_DEC_N
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"@-r%d"
argument_list|,
name|rn
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_IND_N
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"@r%d"
argument_list|,
name|rn
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_DISP_REG_N
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"@(%d,r%d)"
argument_list|,
name|imm
argument_list|,
name|rn
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_REG_M
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"r%d"
argument_list|,
name|rm
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_INC_M
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"@r%d+"
argument_list|,
name|rm
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_DEC_M
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"@-r%d"
argument_list|,
name|rm
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_IND_M
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"@r%d"
argument_list|,
name|rm
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_DISP_REG_M
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"@(%d,r%d)"
argument_list|,
name|imm
argument_list|,
name|rm
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_REG_B
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"r%d_bank"
argument_list|,
name|rb
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_DISP_PC
case|:
name|disp_pc
operator|=
literal|1
expr_stmt|;
name|disp_pc_addr
operator|=
name|imm
operator|+
literal|4
operator|+
operator|(
name|memaddr
operator|&
name|relmask
operator|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|disp_pc_addr
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_IND_R0_REG_N
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"@(r0,r%d)"
argument_list|,
name|rn
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_IND_R0_REG_M
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"@(r0,r%d)"
argument_list|,
name|rm
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_DISP_GBR
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"@(%d,gbr)"
argument_list|,
name|imm
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_R0_GBR
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"@(r0,gbr)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_BDISP12
case|:
case|case
name|A_BDISP8
case|:
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|imm
operator|+
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_SR
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"sr"
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_GBR
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"gbr"
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_VBR
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"vbr"
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_SSR
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"ssr"
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_SPC
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"spc"
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_MACH
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"mach"
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_MACL
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"macl"
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_PR
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"pr"
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_SGR
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"sgr"
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_DBR
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"dbr"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FD_REG_N
case|:
if|if
condition|(
literal|0
condition|)
goto|goto
name|d_reg_n
goto|;
case|case
name|F_REG_N
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"fr%d"
argument_list|,
name|rn
argument_list|)
expr_stmt|;
break|break;
case|case
name|F_REG_M
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"fr%d"
argument_list|,
name|rm
argument_list|)
expr_stmt|;
break|break;
case|case
name|DX_REG_N
case|:
if|if
condition|(
name|rn
operator|&
literal|1
condition|)
block|{
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"xd%d"
argument_list|,
name|rn
operator|&
operator|~
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|d_reg_n
label|:
case|case
name|D_REG_N
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"dr%d"
argument_list|,
name|rn
argument_list|)
expr_stmt|;
break|break;
case|case
name|DX_REG_M
case|:
if|if
condition|(
name|rm
operator|&
literal|1
condition|)
block|{
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"xd%d"
argument_list|,
name|rm
operator|&
operator|~
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|D_REG_M
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"dr%d"
argument_list|,
name|rm
argument_list|)
expr_stmt|;
break|break;
case|case
name|FPSCR_M
case|:
case|case
name|FPSCR_N
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"fpscr"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FPUL_M
case|:
case|case
name|FPUL_N
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"fpul"
argument_list|)
expr_stmt|;
break|break;
case|case
name|F_FR0
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"fr0"
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_REG_N
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"fv%d"
argument_list|,
name|rn
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|V_REG_M
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"fv%d"
argument_list|,
name|rm
operator|*
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|XMTRX_M4
case|:
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"xmtrx"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* This code prints instructions in delay slots on the same line          as the instruction which needs the delay slots.  This can be          confusing, since other disassembler don't work this way, and          it means that the instructions are not all in a line.  So I          disabled it.  Ian.  */
block|if (!(info->flags& 1)&& (op->name[0] == 'j' 	      || (op->name[0] == 'b'&& (op->name[1] == 'r'  		      || op->name[1] == 's')) 	      || (op->name[0] == 'r'&& op->name[1] == 't') 	      || (op->name[0] == 'b'&& op->name[2] == '.'))) 	{ 	  info->flags |= 1; 	  fprintf_fn (stream, "\t(slot "); 	  print_insn_shx (memaddr + 2, info); 	  info->flags&= ~1; 	  fprintf_fn (stream, ")"); 	  return 4; 	}
endif|#
directive|endif
if|if
condition|(
name|disp_pc
operator|&&
name|strcmp
argument_list|(
name|op
operator|->
name|name
argument_list|,
literal|"mova"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|size
decl_stmt|;
name|bfd_byte
name|bytes
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|relmask
operator|==
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
condition|)
name|size
operator|=
literal|2
expr_stmt|;
else|else
name|size
operator|=
literal|4
expr_stmt|;
name|status
operator|=
name|info
operator|->
name|read_memory_func
argument_list|(
name|disp_pc_addr
argument_list|,
name|bytes
argument_list|,
name|size
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|unsigned
name|int
name|val
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|LITTLE_BIT
operator|)
operator|!=
literal|0
condition|)
name|val
operator|=
name|bfd_getl16
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|bfd_getb16
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|LITTLE_BIT
operator|)
operator|!=
literal|0
condition|)
name|val
operator|=
name|bfd_getl32
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|bfd_getb32
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|"\t! 0x%x"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|2
return|;
name|fail
label|:
empty_stmt|;
block|}
name|fprintf_fn
argument_list|(
name|stream
argument_list|,
literal|".word 0x%x%x%x%x"
argument_list|,
name|nibs
index|[
literal|0
index|]
argument_list|,
name|nibs
index|[
literal|1
index|]
argument_list|,
name|nibs
index|[
literal|2
index|]
argument_list|,
name|nibs
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
end_function

begin_function
name|int
name|print_insn_shl
parameter_list|(
name|memaddr
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|memaddr
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
name|int
name|r
decl_stmt|;
name|info
operator|->
name|flags
operator|=
name|LITTLE_BIT
expr_stmt|;
name|r
operator|=
name|print_insn_shx
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|print_insn_sh
parameter_list|(
name|memaddr
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|memaddr
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
name|int
name|r
decl_stmt|;
name|info
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|r
operator|=
name|print_insn_shx
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

end_unit

