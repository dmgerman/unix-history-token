begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ppc-dis.c -- Disassemble PowerPC instructions    Copyright 1994, 1995, 2000, 2001, 2002 Free Software Foundation, Inc.    Written by Ian Lance Taylor, Cygnus Support  This file is part of GDB, GAS, and the GNU binutils.  GDB, GAS, and the GNU binutils are free software; you can redistribute them and/or modify them under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GDB, GAS, and the GNU binutils are distributed in the hope that they will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this file; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"opcode/ppc.h"
end_include

begin_comment
comment|/* This file provides several disassembler functions, all of which use    the disassembler interface defined in dis-asm.h.  Several functions    are provided because this file handles disassembly for the PowerPC    in both big and little endian mode and also for the POWER (RS/6000)    chip.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_insn_powerpc
name|PARAMS
argument_list|(
operator|(
name|bfd_vma
operator|,
expr|struct
name|disassemble_info
operator|*
operator|,
name|int
name|bigendian
operator|,
name|int
name|dialect
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|powerpc_dialect
name|PARAMS
argument_list|(
operator|(
expr|struct
name|disassemble_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Determine which set of machines to disassemble for.  PPC403/601 or    BookE.  For convenience, also disassemble instructions supported    by the AltiVec vector unit.  */
end_comment

begin_function
name|int
name|powerpc_dialect
parameter_list|(
name|info
parameter_list|)
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
name|int
name|dialect
init|=
name|PPC_OPCODE_PPC
operator||
name|PPC_OPCODE_ALTIVEC
decl_stmt|;
if|if
condition|(
name|BFD_DEFAULT_TARGET_SIZE
operator|==
literal|64
condition|)
name|dialect
operator||=
name|PPC_OPCODE_64
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|disassembler_options
operator|&&
operator|(
name|strcmp
argument_list|(
name|info
operator|->
name|disassembler_options
argument_list|,
literal|"booke"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|info
operator|->
name|disassembler_options
argument_list|,
literal|"booke32"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|info
operator|->
name|disassembler_options
argument_list|,
literal|"booke64"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|dialect
operator||=
name|PPC_OPCODE_BOOKE
operator||
name|PPC_OPCODE_BOOKE64
expr_stmt|;
else|else
name|dialect
operator||=
name|PPC_OPCODE_403
operator||
name|PPC_OPCODE_601
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|disassembler_options
operator|&&
name|strcmp
argument_list|(
name|info
operator|->
name|disassembler_options
argument_list|,
literal|"power4"
argument_list|)
operator|==
literal|0
condition|)
name|dialect
operator||=
name|PPC_OPCODE_POWER4
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|disassembler_options
condition|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|info
operator|->
name|disassembler_options
argument_list|,
literal|"32"
argument_list|)
operator|!=
name|NULL
condition|)
name|dialect
operator|&=
operator|~
name|PPC_OPCODE_64
expr_stmt|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|info
operator|->
name|disassembler_options
argument_list|,
literal|"64"
argument_list|)
operator|!=
name|NULL
condition|)
name|dialect
operator||=
name|PPC_OPCODE_64
expr_stmt|;
block|}
return|return
name|dialect
return|;
block|}
end_function

begin_comment
comment|/* Print a big endian PowerPC instruction.  */
end_comment

begin_function
name|int
name|print_insn_big_powerpc
parameter_list|(
name|memaddr
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|memaddr
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
return|return
name|print_insn_powerpc
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|,
literal|1
argument_list|,
name|powerpc_dialect
argument_list|(
name|info
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Print a little endian PowerPC instruction.  */
end_comment

begin_function
name|int
name|print_insn_little_powerpc
parameter_list|(
name|memaddr
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|memaddr
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
return|return
name|print_insn_powerpc
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|,
literal|0
argument_list|,
name|powerpc_dialect
argument_list|(
name|info
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Print a POWER (RS/6000) instruction.  */
end_comment

begin_function
name|int
name|print_insn_rs6000
parameter_list|(
name|memaddr
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|memaddr
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
return|return
name|print_insn_powerpc
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|,
literal|1
argument_list|,
name|PPC_OPCODE_POWER
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Print a PowerPC or POWER instruction.  */
end_comment

begin_function
specifier|static
name|int
name|print_insn_powerpc
parameter_list|(
name|memaddr
parameter_list|,
name|info
parameter_list|,
name|bigendian
parameter_list|,
name|dialect
parameter_list|)
name|bfd_vma
name|memaddr
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
name|int
name|bigendian
decl_stmt|;
name|int
name|dialect
decl_stmt|;
block|{
name|bfd_byte
name|buffer
index|[
literal|4
index|]
decl_stmt|;
name|int
name|status
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
specifier|const
name|struct
name|powerpc_opcode
modifier|*
name|opcode
decl_stmt|;
specifier|const
name|struct
name|powerpc_opcode
modifier|*
name|opcode_end
decl_stmt|;
name|unsigned
name|long
name|op
decl_stmt|;
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|memaddr
argument_list|,
name|buffer
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|memory_error_func
call|)
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|bigendian
condition|)
name|insn
operator|=
name|bfd_getb32
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|bfd_getl32
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* Get the major opcode of the instruction.  */
name|op
operator|=
name|PPC_OP
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Find the first match in the opcode table.  We could speed this up      a bit by doing a binary search on the major opcode.  */
name|opcode_end
operator|=
name|powerpc_opcodes
operator|+
name|powerpc_num_opcodes
expr_stmt|;
for|for
control|(
name|opcode
operator|=
name|powerpc_opcodes
init|;
name|opcode
operator|<
name|opcode_end
condition|;
name|opcode
operator|++
control|)
block|{
name|unsigned
name|long
name|table_op
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|opindex
decl_stmt|;
specifier|const
name|struct
name|powerpc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|invalid
decl_stmt|;
name|int
name|need_comma
decl_stmt|;
name|int
name|need_paren
decl_stmt|;
name|table_op
operator|=
name|PPC_OP
argument_list|(
name|opcode
operator|->
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|<
name|table_op
condition|)
break|break;
if|if
condition|(
name|op
operator|>
name|table_op
condition|)
continue|continue;
if|if
condition|(
operator|(
name|insn
operator|&
name|opcode
operator|->
name|mask
operator|)
operator|!=
name|opcode
operator|->
name|opcode
operator|||
operator|(
name|opcode
operator|->
name|flags
operator|&
name|dialect
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Make two passes over the operands.  First see if any of them 	 have extraction functions, and, if they do, make sure the 	 instruction is valid.  */
name|invalid
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|opindex
operator|=
name|opcode
operator|->
name|operands
init|;
operator|*
name|opindex
operator|!=
literal|0
condition|;
name|opindex
operator|++
control|)
block|{
name|operand
operator|=
name|powerpc_operands
operator|+
operator|*
name|opindex
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|extract
condition|)
call|(
modifier|*
name|operand
operator|->
name|extract
call|)
argument_list|(
name|insn
argument_list|,
name|dialect
argument_list|,
operator|&
name|invalid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|invalid
condition|)
continue|continue;
comment|/* The instruction is valid.  */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|operands
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
comment|/* Now extract and print the operands.  */
name|need_comma
operator|=
literal|0
expr_stmt|;
name|need_paren
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|opindex
operator|=
name|opcode
operator|->
name|operands
init|;
operator|*
name|opindex
operator|!=
literal|0
condition|;
name|opindex
operator|++
control|)
block|{
name|long
name|value
decl_stmt|;
name|operand
operator|=
name|powerpc_operands
operator|+
operator|*
name|opindex
expr_stmt|;
comment|/* Operands that are marked FAKE are simply ignored.  We 	     already made sure that the extract function considered 	     the instruction to be valid.  */
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_FAKE
operator|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* Extract the value from the instruction.  */
if|if
condition|(
name|operand
operator|->
name|extract
condition|)
name|value
operator|=
call|(
modifier|*
name|operand
operator|->
name|extract
call|)
argument_list|(
name|insn
argument_list|,
name|dialect
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|value
operator|=
operator|(
name|insn
operator|>>
name|operand
operator|->
name|shift
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_SIGNED
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|value
operator|&
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
name|value
operator|-=
literal|1
operator|<<
name|operand
operator|->
name|bits
expr_stmt|;
block|}
comment|/* If the operand is optional, and the value is zero, don't 	     print anything.  */
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_OPTIONAL
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_NEXT
operator|)
operator|==
literal|0
operator|&&
name|value
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|need_comma
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Print the operand as directed by the flags.  */
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_GPR
operator|)
operator|!=
literal|0
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"r%ld"
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_FPR
operator|)
operator|!=
literal|0
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"f%ld"
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_VR
operator|)
operator|!=
literal|0
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"v%ld"
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_RELATIVE
operator|)
operator|!=
literal|0
condition|)
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|memaddr
operator|+
name|value
argument_list|,
name|info
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_ABSOLUTE
operator|)
operator|!=
literal|0
condition|)
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
operator|(
name|bfd_vma
operator|)
name|value
operator|&
literal|0xffffffff
argument_list|,
name|info
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_CR
operator|)
operator|==
literal|0
operator|||
operator|(
name|dialect
operator|&
name|PPC_OPCODE_PPC
operator|)
operator|==
literal|0
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%ld"
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|operand
operator|->
name|bits
operator|==
literal|3
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"cr%d"
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
block|{
specifier|static
specifier|const
name|char
modifier|*
name|cbnames
index|[
literal|4
index|]
init|=
block|{
literal|"lt"
block|,
literal|"gt"
block|,
literal|"eq"
block|,
literal|"so"
block|}
decl_stmt|;
name|int
name|cr
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|cr
operator|=
name|value
operator|>>
literal|2
expr_stmt|;
if|if
condition|(
name|cr
operator|!=
literal|0
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"4*cr%d"
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|cc
operator|=
name|value
operator|&
literal|3
expr_stmt|;
if|if
condition|(
name|cc
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cr
operator|!=
literal|0
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|cbnames
index|[
name|cc
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|need_paren
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|need_paren
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|PPC_OPERAND_PARENS
operator|)
operator|==
literal|0
condition|)
name|need_comma
operator|=
literal|1
expr_stmt|;
else|else
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|need_paren
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* We have found and printed an instruction; return.  */
return|return
literal|4
return|;
block|}
comment|/* We could not find a match.  */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|".long 0x%lx"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
literal|4
return|;
block|}
end_function

end_unit

