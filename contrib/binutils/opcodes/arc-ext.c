begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ARC target-dependent stuff. Extension structure access functions    Copyright 1995, 1997, 2000, 2001, 2004, 2005    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"arc-ext.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_comment
comment|/* Extension structure  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|arcExtMap
name|arc_extension_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get the name of an extension instruction.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|arcExtMap_instName
parameter_list|(
name|int
name|opcode
parameter_list|,
name|int
name|minor
parameter_list|,
name|int
modifier|*
name|flags
parameter_list|)
block|{
if|if
condition|(
name|opcode
operator|==
literal|3
condition|)
block|{
comment|/* FIXME: ??? need to also check 0/1/2 in bit0 for (3f) brk/sleep/swi  */
if|if
condition|(
name|minor
operator|<
literal|0x09
operator|||
name|minor
operator|==
literal|0x3f
condition|)
return|return
literal|0
return|;
else|else
name|opcode
operator|=
literal|0x1f
operator|-
literal|0x10
operator|+
name|minor
operator|-
literal|0x09
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|<
literal|0x10
condition|)
return|return
literal|0
return|;
else|else
name|opcode
operator|-=
literal|0x10
expr_stmt|;
if|if
condition|(
operator|!
name|arc_extension_map
operator|.
name|instructions
index|[
name|opcode
index|]
condition|)
return|return
literal|0
return|;
operator|*
name|flags
operator|=
name|arc_extension_map
operator|.
name|instructions
index|[
name|opcode
index|]
operator|->
name|flags
expr_stmt|;
return|return
name|arc_extension_map
operator|.
name|instructions
index|[
name|opcode
index|]
operator|->
name|name
return|;
block|}
end_function

begin_comment
comment|/* Get the name of an extension core register.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|arcExtMap_coreRegName
parameter_list|(
name|int
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|<
literal|32
condition|)
return|return
literal|0
return|;
return|return
name|arc_extension_map
operator|.
name|coreRegisters
index|[
name|value
operator|-
literal|32
index|]
return|;
block|}
end_function

begin_comment
comment|/* Get the name of an extension condition code.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|arcExtMap_condCodeName
parameter_list|(
name|int
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|<
literal|16
condition|)
return|return
literal|0
return|;
return|return
name|arc_extension_map
operator|.
name|condCodes
index|[
name|value
operator|-
literal|16
index|]
return|;
block|}
end_function

begin_comment
comment|/* Get the name of an extension aux register.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|arcExtMap_auxRegName
parameter_list|(
name|long
name|address
parameter_list|)
block|{
comment|/* walk the list of aux reg names and find the name  */
name|struct
name|ExtAuxRegister
modifier|*
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
name|arc_extension_map
operator|.
name|auxRegisters
init|;
name|r
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
if|if
condition|(
name|r
operator|->
name|address
operator|==
name|address
condition|)
return|return
operator|(
specifier|const
name|char
operator|*
operator|)
name|r
operator|->
name|name
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Recursively free auxilliary register strcture pointers until    the list is empty.  */
end_comment

begin_function
specifier|static
name|void
name|clean_aux_registers
parameter_list|(
name|struct
name|ExtAuxRegister
modifier|*
name|r
parameter_list|)
block|{
if|if
condition|(
name|r
operator|->
name|next
condition|)
block|{
name|clean_aux_registers
argument_list|(
name|r
operator|->
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
operator|->
name|next
argument_list|)
expr_stmt|;
name|r
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|free
argument_list|(
name|r
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free memory that has been allocated for the extensions.  */
end_comment

begin_function
specifier|static
name|void
name|cleanup_ext_map
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ExtAuxRegister
modifier|*
name|r
decl_stmt|;
name|struct
name|ExtInstruction
modifier|*
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* clean aux reg structure  */
name|r
operator|=
name|arc_extension_map
operator|.
name|auxRegisters
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
operator|(
name|clean_aux_registers
argument_list|(
name|r
argument_list|)
operator|)
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
comment|/* clean instructions  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_EXT_INST
condition|;
name|i
operator|++
control|)
block|{
name|insn
operator|=
name|arc_extension_map
operator|.
name|instructions
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|insn
condition|)
name|free
argument_list|(
name|insn
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* clean core reg struct  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_EXT_CORE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|arc_extension_map
operator|.
name|coreRegisters
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|arc_extension_map
operator|.
name|coreRegisters
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_EXT_COND
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|arc_extension_map
operator|.
name|condCodes
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|arc_extension_map
operator|.
name|condCodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|arc_extension_map
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|arcExtMap
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|arcExtMap_add
parameter_list|(
name|void
modifier|*
name|base
parameter_list|,
name|unsigned
name|long
name|length
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|block
init|=
name|base
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
init|=
name|block
decl_stmt|;
comment|/* Clean up and reset everything if needed.  */
name|cleanup_ext_map
argument_list|()
expr_stmt|;
while|while
condition|(
name|p
operator|&&
name|p
operator|<
operator|(
name|block
operator|+
name|length
operator|)
condition|)
block|{
comment|/* p[0] == length of record 	 p[1] == type of record 	 For instructions: 	   p[2]  = opcode 	   p[3]  = minor opcode (if opcode == 3) 	   p[4]  = flags 	   p[5]+ = name 	 For core regs and condition codes: 	   p[2]  = value 	   p[3]+ = name 	 For aux regs: 	   p[2..5] = value 	   p[6]+   = name 	 (value is p[2]<<24|p[3]<<16|p[4]<<8|p[5])  */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|p
index|[
literal|1
index|]
condition|)
block|{
case|case
name|EXT_INSTRUCTION
case|:
block|{
name|char
name|opcode
init|=
name|p
index|[
literal|2
index|]
decl_stmt|;
name|char
name|minor
init|=
name|p
index|[
literal|3
index|]
decl_stmt|;
name|char
modifier|*
name|insn_name
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
operator|(
name|int
operator|)
operator|*
name|p
operator|-
literal|5
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ExtInstruction
modifier|*
name|insn
init|=
operator|(
expr|struct
name|ExtInstruction
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ExtInstruction
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|opcode
operator|==
literal|3
condition|)
name|opcode
operator|=
literal|0x1f
operator|-
literal|0x10
operator|+
name|minor
operator|-
literal|0x09
operator|+
literal|1
expr_stmt|;
else|else
name|opcode
operator|-=
literal|0x10
expr_stmt|;
name|insn
operator|->
name|flags
operator|=
operator|(
name|char
operator|)
operator|*
operator|(
name|p
operator|+
literal|4
operator|)
expr_stmt|;
name|strcpy
argument_list|(
name|insn_name
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|+
literal|5
operator|)
argument_list|)
expr_stmt|;
name|insn
operator|->
name|name
operator|=
name|insn_name
expr_stmt|;
name|arc_extension_map
operator|.
name|instructions
index|[
operator|(
name|int
operator|)
name|opcode
index|]
operator|=
name|insn
expr_stmt|;
block|}
break|break;
case|case
name|EXT_CORE_REGISTER
case|:
block|{
name|char
modifier|*
name|core_name
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
operator|(
name|int
operator|)
operator|*
name|p
operator|-
literal|3
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|core_name
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
name|arc_extension_map
operator|.
name|coreRegisters
index|[
name|p
index|[
literal|2
index|]
operator|-
literal|32
index|]
operator|=
name|core_name
expr_stmt|;
block|}
break|break;
case|case
name|EXT_COND_CODE
case|:
block|{
name|char
modifier|*
name|cc_name
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
operator|(
name|int
operator|)
operator|*
name|p
operator|-
literal|3
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|cc_name
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
name|arc_extension_map
operator|.
name|condCodes
index|[
name|p
index|[
literal|2
index|]
operator|-
literal|16
index|]
operator|=
name|cc_name
expr_stmt|;
block|}
break|break;
case|case
name|EXT_AUX_REGISTER
case|:
block|{
comment|/* trickier -- need to store linked list to these  */
name|struct
name|ExtAuxRegister
modifier|*
name|newAuxRegister
init|=
operator|(
expr|struct
name|ExtAuxRegister
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ExtAuxRegister
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|aux_name
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
operator|(
name|int
operator|)
operator|*
name|p
operator|-
literal|6
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|aux_name
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|+
literal|6
operator|)
argument_list|)
expr_stmt|;
name|newAuxRegister
operator|->
name|name
operator|=
name|aux_name
expr_stmt|;
name|newAuxRegister
operator|->
name|address
operator|=
name|p
index|[
literal|2
index|]
operator|<<
literal|24
operator||
name|p
index|[
literal|3
index|]
operator|<<
literal|16
operator||
name|p
index|[
literal|4
index|]
operator|<<
literal|8
operator||
name|p
index|[
literal|5
index|]
expr_stmt|;
name|newAuxRegister
operator|->
name|next
operator|=
name|arc_extension_map
operator|.
name|auxRegisters
expr_stmt|;
name|arc_extension_map
operator|.
name|auxRegisters
operator|=
name|newAuxRegister
expr_stmt|;
block|}
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
name|p
operator|+=
name|p
index|[
literal|0
index|]
expr_stmt|;
comment|/* move to next record  */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Load hw extension descibed in .extArcMap ELF section.  */
end_comment

begin_function
name|void
name|build_ARC_extmap
parameter_list|(
name|text_bfd
parameter_list|)
name|bfd
modifier|*
name|text_bfd
decl_stmt|;
block|{
name|char
modifier|*
name|arcExtMap
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
name|asection
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|text_bfd
operator|->
name|sections
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
literal|".arcextmap"
argument_list|)
condition|)
block|{
name|count
operator|=
name|bfd_get_section_size
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|arcExtMap
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_get_section_contents
argument_list|(
name|text_bfd
argument_list|,
name|p
argument_list|,
operator|(
name|PTR
operator|)
name|arcExtMap
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
condition|)
block|{
name|arcExtMap_add
argument_list|(
operator|(
name|PTR
operator|)
name|arcExtMap
argument_list|,
name|count
argument_list|)
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|arcExtMap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

