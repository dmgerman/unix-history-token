begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* CGEN generic assembler support code.     Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.     This file is part of the GNU Binutils and GDB, the GNU debugger.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symcat.h"
end_include

begin_include
include|#
directive|include
file|"opcode/cgen.h"
end_include

begin_include
include|#
directive|include
file|"opintl.h"
end_include

begin_comment
comment|/* Set the cgen_parse_operand_fn callback.  */
end_comment

begin_function
name|void
name|cgen_set_parse_operand_fn
parameter_list|(
name|cd
parameter_list|,
name|fn
parameter_list|)
name|CGEN_CPU_DESC
name|cd
decl_stmt|;
name|cgen_parse_operand_fn
name|fn
decl_stmt|;
block|{
name|cd
operator|->
name|parse_operand_fn
operator|=
name|fn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called whenever starting to parse an insn.  */
end_comment

begin_function
name|void
name|cgen_init_parse_operand
parameter_list|(
name|cd
parameter_list|)
name|CGEN_CPU_DESC
name|cd
decl_stmt|;
block|{
comment|/* This tells the callback to re-initialize.  */
call|(
name|void
call|)
argument_list|(
operator|*
name|cd
operator|->
name|parse_operand_fn
argument_list|)
argument_list|(
name|cd
argument_list|,
name|CGEN_PARSE_OPERAND_INIT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of build_asm_hash_table to add INSNS to the hash table.     COUNT is the number of elements in INSNS.    ENTSIZE is sizeof (CGEN_IBASE) for the target.    ??? No longer used but leave in for now.    HTABLE points to the hash table.    HENTBUF is a pointer to sufficiently large buffer of hash entries.    The result is a pointer to the next entry to use.     The table is scanned backwards as additions are made to the front of the    list and we want earlier ones to be prefered.  */
end_comment

begin_function
specifier|static
name|CGEN_INSN_LIST
modifier|*
name|hash_insn_array
parameter_list|(
name|cd
parameter_list|,
name|insns
parameter_list|,
name|count
parameter_list|,
name|entsize
parameter_list|,
name|htable
parameter_list|,
name|hentbuf
parameter_list|)
name|CGEN_CPU_DESC
name|cd
decl_stmt|;
specifier|const
name|CGEN_INSN
modifier|*
name|insns
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|entsize
decl_stmt|;
name|CGEN_INSN_LIST
modifier|*
modifier|*
name|htable
decl_stmt|;
name|CGEN_INSN_LIST
modifier|*
name|hentbuf
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
operator|,
operator|++
name|hentbuf
control|)
block|{
name|unsigned
name|int
name|hash
decl_stmt|;
specifier|const
name|CGEN_INSN
modifier|*
name|insn
init|=
operator|&
name|insns
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|cd
operator|->
name|asm_hash_p
call|)
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
name|hash
operator|=
call|(
modifier|*
name|cd
operator|->
name|asm_hash
call|)
argument_list|(
name|CGEN_INSN_MNEMONIC
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|hentbuf
operator|->
name|next
operator|=
name|htable
index|[
name|hash
index|]
expr_stmt|;
name|hentbuf
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|htable
index|[
name|hash
index|]
operator|=
name|hentbuf
expr_stmt|;
block|}
return|return
name|hentbuf
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of build_asm_hash_table to add INSNS to the hash table.    This function is identical to hash_insn_array except the insns are    in a list.  */
end_comment

begin_function
specifier|static
name|CGEN_INSN_LIST
modifier|*
name|hash_insn_list
parameter_list|(
name|cd
parameter_list|,
name|insns
parameter_list|,
name|htable
parameter_list|,
name|hentbuf
parameter_list|)
name|CGEN_CPU_DESC
name|cd
decl_stmt|;
specifier|const
name|CGEN_INSN_LIST
modifier|*
name|insns
decl_stmt|;
name|CGEN_INSN_LIST
modifier|*
modifier|*
name|htable
decl_stmt|;
name|CGEN_INSN_LIST
modifier|*
name|hentbuf
decl_stmt|;
block|{
specifier|const
name|CGEN_INSN_LIST
modifier|*
name|ilist
decl_stmt|;
for|for
control|(
name|ilist
operator|=
name|insns
init|;
name|ilist
operator|!=
name|NULL
condition|;
name|ilist
operator|=
name|ilist
operator|->
name|next
operator|,
operator|++
name|hentbuf
control|)
block|{
name|unsigned
name|int
name|hash
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|cd
operator|->
name|asm_hash_p
call|)
argument_list|(
name|ilist
operator|->
name|insn
argument_list|)
condition|)
continue|continue;
name|hash
operator|=
call|(
modifier|*
name|cd
operator|->
name|asm_hash
call|)
argument_list|(
name|CGEN_INSN_MNEMONIC
argument_list|(
name|ilist
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|hentbuf
operator|->
name|next
operator|=
name|htable
index|[
name|hash
index|]
expr_stmt|;
name|hentbuf
operator|->
name|insn
operator|=
name|ilist
operator|->
name|insn
expr_stmt|;
name|htable
index|[
name|hash
index|]
operator|=
name|hentbuf
expr_stmt|;
block|}
return|return
name|hentbuf
return|;
block|}
end_function

begin_comment
comment|/* Build the assembler instruction hash table.  */
end_comment

begin_function
specifier|static
name|void
name|build_asm_hash_table
parameter_list|(
name|cd
parameter_list|)
name|CGEN_CPU_DESC
name|cd
decl_stmt|;
block|{
name|int
name|count
init|=
name|cgen_insn_count
argument_list|(
name|cd
argument_list|)
operator|+
name|cgen_macro_insn_count
argument_list|(
name|cd
argument_list|)
decl_stmt|;
name|CGEN_INSN_TABLE
modifier|*
name|insn_table
init|=
operator|&
name|cd
operator|->
name|insn_table
decl_stmt|;
name|CGEN_INSN_TABLE
modifier|*
name|macro_insn_table
init|=
operator|&
name|cd
operator|->
name|macro_insn_table
decl_stmt|;
name|unsigned
name|int
name|hash_size
init|=
name|cd
operator|->
name|asm_hash_size
decl_stmt|;
name|CGEN_INSN_LIST
modifier|*
name|hash_entry_buf
decl_stmt|;
name|CGEN_INSN_LIST
modifier|*
modifier|*
name|asm_hash_table
decl_stmt|;
name|CGEN_INSN_LIST
modifier|*
name|asm_hash_table_entries
decl_stmt|;
comment|/* The space allocated for the hash table consists of two parts:      the hash table and the hash lists.  */
name|asm_hash_table
operator|=
operator|(
name|CGEN_INSN_LIST
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|hash_size
operator|*
sizeof|sizeof
argument_list|(
name|CGEN_INSN_LIST
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|asm_hash_table
argument_list|,
literal|0
argument_list|,
name|hash_size
operator|*
sizeof|sizeof
argument_list|(
name|CGEN_INSN_LIST
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|asm_hash_table_entries
operator|=
name|hash_entry_buf
operator|=
operator|(
name|CGEN_INSN_LIST
operator|*
operator|)
name|xmalloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|CGEN_INSN_LIST
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add compiled in insns.      Don't include the first one as it is a reserved entry.  */
comment|/* ??? It was the end of all hash chains, and also the special      "invalid insn" marker.  May be able to do it differently now.  */
name|hash_entry_buf
operator|=
name|hash_insn_array
argument_list|(
name|cd
argument_list|,
name|insn_table
operator|->
name|init_entries
operator|+
literal|1
argument_list|,
name|insn_table
operator|->
name|num_init_entries
operator|-
literal|1
argument_list|,
name|insn_table
operator|->
name|entry_size
argument_list|,
name|asm_hash_table
argument_list|,
name|hash_entry_buf
argument_list|)
expr_stmt|;
comment|/* Add compiled in macro-insns.  */
name|hash_entry_buf
operator|=
name|hash_insn_array
argument_list|(
name|cd
argument_list|,
name|macro_insn_table
operator|->
name|init_entries
argument_list|,
name|macro_insn_table
operator|->
name|num_init_entries
argument_list|,
name|macro_insn_table
operator|->
name|entry_size
argument_list|,
name|asm_hash_table
argument_list|,
name|hash_entry_buf
argument_list|)
expr_stmt|;
comment|/* Add runtime added insns.      Later added insns will be prefered over earlier ones.  */
name|hash_entry_buf
operator|=
name|hash_insn_list
argument_list|(
name|cd
argument_list|,
name|insn_table
operator|->
name|new_entries
argument_list|,
name|asm_hash_table
argument_list|,
name|hash_entry_buf
argument_list|)
expr_stmt|;
comment|/* Add runtime added macro-insns.  */
name|hash_insn_list
argument_list|(
name|cd
argument_list|,
name|macro_insn_table
operator|->
name|new_entries
argument_list|,
name|asm_hash_table
argument_list|,
name|hash_entry_buf
argument_list|)
expr_stmt|;
name|cd
operator|->
name|asm_hash_table
operator|=
name|asm_hash_table
expr_stmt|;
name|cd
operator|->
name|asm_hash_table_entries
operator|=
name|asm_hash_table_entries
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the first entry in the hash list for INSN.  */
end_comment

begin_function
name|CGEN_INSN_LIST
modifier|*
name|cgen_asm_lookup_insn
parameter_list|(
name|cd
parameter_list|,
name|insn
parameter_list|)
name|CGEN_CPU_DESC
name|cd
decl_stmt|;
specifier|const
name|char
modifier|*
name|insn
decl_stmt|;
block|{
name|unsigned
name|int
name|hash
decl_stmt|;
if|if
condition|(
name|cd
operator|->
name|asm_hash_table
operator|==
name|NULL
condition|)
name|build_asm_hash_table
argument_list|(
name|cd
argument_list|)
expr_stmt|;
name|hash
operator|=
call|(
modifier|*
name|cd
operator|->
name|asm_hash
call|)
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|cd
operator|->
name|asm_hash_table
index|[
name|hash
index|]
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Keyword parser.    The result is NULL upon success or an error message.    If successful, *STRP is updated to point passed the keyword.     ??? At present we have a static notion of how to pick out a keyword.    Later we can allow a target to customize this if necessary [say by    recording something in the keyword table].  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cgen_parse_keyword
parameter_list|(
name|cd
parameter_list|,
name|strp
parameter_list|,
name|keyword_table
parameter_list|,
name|valuep
parameter_list|)
name|CGEN_CPU_DESC
name|cd
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|strp
decl_stmt|;
name|CGEN_KEYWORD
modifier|*
name|keyword_table
decl_stmt|;
name|long
modifier|*
name|valuep
decl_stmt|;
block|{
specifier|const
name|CGEN_KEYWORD_ENTRY
modifier|*
name|ke
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|start
decl_stmt|;
name|p
operator|=
name|start
operator|=
operator|*
name|strp
expr_stmt|;
comment|/* Allow any first character.      Note that this allows recognizing ",a" for the annul flag in sparc      even though "," is subsequently not a valid keyword char.  */
if|if
condition|(
operator|*
name|p
condition|)
operator|++
name|p
expr_stmt|;
comment|/* Now allow letters, digits, and _.  */
while|while
condition|(
operator|(
operator|(
name|p
operator|-
name|start
operator|)
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|)
operator|&&
operator|(
name|isalnum
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|)
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|-
name|start
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
return|return
name|_
argument_list|(
literal|"unrecognized keyword/register name"
argument_list|)
return|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|start
argument_list|,
name|p
operator|-
name|start
argument_list|)
expr_stmt|;
name|buf
index|[
name|p
operator|-
name|start
index|]
operator|=
literal|0
expr_stmt|;
name|ke
operator|=
name|cgen_keyword_lookup_name
argument_list|(
name|keyword_table
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|!=
name|NULL
condition|)
block|{
operator|*
name|valuep
operator|=
name|ke
operator|->
name|value
expr_stmt|;
comment|/* Don't advance pointer if we recognized the null keyword.  */
if|if
condition|(
name|ke
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
operator|*
name|strp
operator|=
name|p
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
literal|"unrecognized keyword/register name"
return|;
block|}
end_function

begin_comment
comment|/* Parse a small signed integer parser.    ??? VALUEP is not a bfd_vma * on purpose, though this is confusing.    Note that if the caller expects a bfd_vma result, it should call    cgen_parse_address.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cgen_parse_signed_integer
parameter_list|(
name|cd
parameter_list|,
name|strp
parameter_list|,
name|opindex
parameter_list|,
name|valuep
parameter_list|)
name|CGEN_CPU_DESC
name|cd
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|strp
decl_stmt|;
name|int
name|opindex
decl_stmt|;
name|long
modifier|*
name|valuep
decl_stmt|;
block|{
name|bfd_vma
name|value
decl_stmt|;
name|enum
name|cgen_parse_operand_result
name|result
decl_stmt|;
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|errmsg
operator|=
call|(
modifier|*
name|cd
operator|->
name|parse_operand_fn
call|)
argument_list|(
name|cd
argument_list|,
name|CGEN_PARSE_OPERAND_INTEGER
argument_list|,
name|strp
argument_list|,
name|opindex
argument_list|,
name|BFD_RELOC_NONE
argument_list|,
operator|&
name|result
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* FIXME: Examine `result'.  */
if|if
condition|(
operator|!
name|errmsg
condition|)
operator|*
name|valuep
operator|=
name|value
expr_stmt|;
return|return
name|errmsg
return|;
block|}
end_function

begin_comment
comment|/* Parse a small unsigned integer parser.    ??? VALUEP is not a bfd_vma * on purpose, though this is confusing.    Note that if the caller expects a bfd_vma result, it should call    cgen_parse_address.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cgen_parse_unsigned_integer
parameter_list|(
name|cd
parameter_list|,
name|strp
parameter_list|,
name|opindex
parameter_list|,
name|valuep
parameter_list|)
name|CGEN_CPU_DESC
name|cd
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|strp
decl_stmt|;
name|int
name|opindex
decl_stmt|;
name|unsigned
name|long
modifier|*
name|valuep
decl_stmt|;
block|{
name|bfd_vma
name|value
decl_stmt|;
name|enum
name|cgen_parse_operand_result
name|result
decl_stmt|;
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|errmsg
operator|=
call|(
modifier|*
name|cd
operator|->
name|parse_operand_fn
call|)
argument_list|(
name|cd
argument_list|,
name|CGEN_PARSE_OPERAND_INTEGER
argument_list|,
name|strp
argument_list|,
name|opindex
argument_list|,
name|BFD_RELOC_NONE
argument_list|,
operator|&
name|result
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* FIXME: Examine `result'.  */
if|if
condition|(
operator|!
name|errmsg
condition|)
operator|*
name|valuep
operator|=
name|value
expr_stmt|;
return|return
name|errmsg
return|;
block|}
end_function

begin_comment
comment|/* Address parser.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cgen_parse_address
parameter_list|(
name|cd
parameter_list|,
name|strp
parameter_list|,
name|opindex
parameter_list|,
name|opinfo
parameter_list|,
name|resultp
parameter_list|,
name|valuep
parameter_list|)
name|CGEN_CPU_DESC
name|cd
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|strp
decl_stmt|;
name|int
name|opindex
decl_stmt|;
name|int
name|opinfo
decl_stmt|;
name|enum
name|cgen_parse_operand_result
modifier|*
name|resultp
decl_stmt|;
name|bfd_vma
modifier|*
name|valuep
decl_stmt|;
block|{
name|bfd_vma
name|value
decl_stmt|;
name|enum
name|cgen_parse_operand_result
name|result_type
decl_stmt|;
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|errmsg
operator|=
call|(
modifier|*
name|cd
operator|->
name|parse_operand_fn
call|)
argument_list|(
name|cd
argument_list|,
name|CGEN_PARSE_OPERAND_ADDRESS
argument_list|,
name|strp
argument_list|,
name|opindex
argument_list|,
name|opinfo
argument_list|,
operator|&
name|result_type
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* FIXME: Examine `result'.  */
if|if
condition|(
operator|!
name|errmsg
condition|)
block|{
if|if
condition|(
name|resultp
operator|!=
name|NULL
condition|)
operator|*
name|resultp
operator|=
name|result_type
expr_stmt|;
operator|*
name|valuep
operator|=
name|value
expr_stmt|;
block|}
return|return
name|errmsg
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Signed integer validation routine.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cgen_validate_signed_integer
parameter_list|(
name|value
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|)
name|long
name|value
decl_stmt|,
name|min
decl_stmt|,
name|max
decl_stmt|;
block|{
if|if
condition|(
name|value
operator|<
name|min
operator|||
name|value
operator|>
name|max
condition|)
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
comment|/* xgettext:c-format */
name|sprintf
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"operand out of range (%ld not between %ld and %ld)"
argument_list|)
argument_list|,
name|value
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Unsigned integer validation routine.    Supplying `min' here may seem unnecessary, but we also want to handle    cases where min != 0 (and max> LONG_MAX).  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cgen_validate_unsigned_integer
parameter_list|(
name|value
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|)
name|unsigned
name|long
name|value
decl_stmt|,
name|min
decl_stmt|,
name|max
decl_stmt|;
block|{
if|if
condition|(
name|value
operator|<
name|min
operator|||
name|value
operator|>
name|max
condition|)
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
comment|/* xgettext:c-format */
name|sprintf
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"operand out of range (%lu not between %lu and %lu)"
argument_list|)
argument_list|,
name|value
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

end_unit

