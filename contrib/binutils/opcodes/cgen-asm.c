begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* CGEN generic assembler support code.  Copyright (C) 1996, 1997 Free Software Foundation, Inc.  This file is part of the GNU Binutils and GDB, the GNU debugger.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"opcode/cgen.h"
end_include

begin_comment
comment|/* Operand parsing callback.  */
end_comment

begin_expr_stmt
specifier|const
name|char
operator|*
operator|(
operator|*
name|cgen_parse_operand_fn
operator|)
name|PARAMS
argument_list|(
operator|(
expr|enum
name|cgen_parse_operand_type
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|enum
name|cgen_parse_operand_result
operator|*
operator|,
name|bfd_vma
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* This is not published as part of the public interface so we don't    declare this in cgen.h.  */
end_comment

begin_decl_stmt
specifier|extern
name|CGEN_OPCODE_DATA
modifier|*
name|cgen_current_opcode_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Assembler instruction hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|CGEN_INSN_LIST
modifier|*
modifier|*
name|asm_hash_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called once at startup and whenever machine/endian change.  */
end_comment

begin_function
name|void
name|cgen_asm_init
parameter_list|()
block|{
if|if
condition|(
name|asm_hash_table
condition|)
block|{
name|free
argument_list|(
name|asm_hash_table
argument_list|)
expr_stmt|;
name|asm_hash_table
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called whenever starting to parse an insn.  */
end_comment

begin_function
name|void
name|cgen_init_parse_operand
parameter_list|()
block|{
comment|/* This tells the callback to re-initialize.  */
call|(
name|void
call|)
argument_list|(
operator|*
name|cgen_parse_operand_fn
argument_list|)
argument_list|(
name|CGEN_PARSE_OPERAND_INIT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build the assembler instruction hash table.  */
end_comment

begin_function
specifier|static
name|void
name|build_asm_hash_table
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|;
name|int
name|count
init|=
name|cgen_insn_count
argument_list|()
decl_stmt|;
name|CGEN_OPCODE_DATA
modifier|*
name|data
init|=
name|cgen_current_opcode_data
decl_stmt|;
name|CGEN_INSN_TABLE
modifier|*
name|insn_table
init|=
name|data
operator|->
name|insn_table
decl_stmt|;
name|unsigned
name|int
name|hash_size
init|=
name|insn_table
operator|->
name|asm_hash_table_size
decl_stmt|;
specifier|const
name|CGEN_INSN
modifier|*
name|insn
decl_stmt|;
name|CGEN_INSN_LIST
modifier|*
name|insn_lists
decl_stmt|,
modifier|*
name|new_insns
decl_stmt|;
comment|/* The space allocated for the hash table consists of two parts:      the hash table and the hash lists.  */
name|asm_hash_table
operator|=
operator|(
name|CGEN_INSN_LIST
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|hash_size
operator|*
sizeof|sizeof
argument_list|(
name|CGEN_INSN_LIST
operator|*
argument_list|)
operator|+
name|count
operator|*
sizeof|sizeof
argument_list|(
name|CGEN_INSN_LIST
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|asm_hash_table
argument_list|,
literal|0
argument_list|,
name|hash_size
operator|*
sizeof|sizeof
argument_list|(
name|CGEN_INSN_LIST
operator|*
argument_list|)
operator|+
name|count
operator|*
sizeof|sizeof
argument_list|(
name|CGEN_INSN_LIST
argument_list|)
argument_list|)
expr_stmt|;
name|insn_lists
operator|=
operator|(
name|CGEN_INSN_LIST
operator|*
operator|)
operator|(
name|asm_hash_table
operator|+
name|hash_size
operator|)
expr_stmt|;
comment|/* Add compiled in insns.      The table is scanned backwards as later additions are inserted in      front of earlier ones and we want earlier ones to be prefered.      We stop at the first one as it is a reserved entry.  */
for|for
control|(
name|insn
operator|=
name|insn_table
operator|->
name|init_entries
operator|+
name|insn_table
operator|->
name|num_init_entries
operator|-
literal|1
init|;
name|insn
operator|>
name|insn_table
operator|->
name|init_entries
condition|;
operator|--
name|insn
operator|,
operator|++
name|insn_lists
control|)
block|{
name|hash
operator|=
call|(
modifier|*
name|insn_table
operator|->
name|asm_hash
call|)
argument_list|(
name|insn
operator|->
name|syntax
operator|.
name|mnemonic
argument_list|)
expr_stmt|;
name|insn_lists
operator|->
name|next
operator|=
name|asm_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|insn_lists
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|asm_hash_table
index|[
name|hash
index|]
operator|=
name|insn_lists
expr_stmt|;
block|}
comment|/* Add runtime added insns.      ??? Currently later added insns will be prefered over earlier ones.      Not sure this is a bug or not.  */
for|for
control|(
name|new_insns
operator|=
name|insn_table
operator|->
name|new_entries
init|;
name|new_insns
operator|!=
name|NULL
condition|;
name|new_insns
operator|=
name|new_insns
operator|->
name|next
operator|,
operator|++
name|insn_lists
control|)
block|{
name|hash
operator|=
call|(
modifier|*
name|insn_table
operator|->
name|asm_hash
call|)
argument_list|(
name|new_insns
operator|->
name|insn
operator|->
name|syntax
operator|.
name|mnemonic
argument_list|)
expr_stmt|;
name|insn_lists
operator|->
name|next
operator|=
name|asm_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|insn_lists
operator|->
name|insn
operator|=
name|new_insns
operator|->
name|insn
expr_stmt|;
name|asm_hash_table
index|[
name|hash
index|]
operator|=
name|insn_lists
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the first entry in the hash list for INSN.  */
end_comment

begin_function
name|CGEN_INSN_LIST
modifier|*
name|cgen_asm_lookup_insn
parameter_list|(
name|insn
parameter_list|)
specifier|const
name|char
modifier|*
name|insn
decl_stmt|;
block|{
name|unsigned
name|int
name|hash
decl_stmt|;
if|if
condition|(
name|asm_hash_table
operator|==
name|NULL
condition|)
name|build_asm_hash_table
argument_list|()
expr_stmt|;
name|hash
operator|=
call|(
modifier|*
name|cgen_current_opcode_data
operator|->
name|insn_table
operator|->
name|asm_hash
call|)
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|asm_hash_table
index|[
name|hash
index|]
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Keyword parser.    The result is NULL upon success or an error message.    If successful, *STRP is updated to point passed the keyword.     ??? At present we have a static notion of how to pick out a keyword.    Later we can allow a target to customize this if necessary [say by    recording something in the keyword table].  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cgen_parse_keyword
parameter_list|(
name|strp
parameter_list|,
name|keyword_table
parameter_list|,
name|valuep
parameter_list|)
specifier|const
name|char
modifier|*
modifier|*
name|strp
decl_stmt|;
name|struct
name|cgen_keyword
modifier|*
name|keyword_table
decl_stmt|;
name|long
modifier|*
name|valuep
decl_stmt|;
block|{
specifier|const
name|struct
name|cgen_keyword_entry
modifier|*
name|ke
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|*
name|strp
expr_stmt|;
comment|/* Allow any first character.  */
if|if
condition|(
operator|*
name|p
condition|)
operator|++
name|p
expr_stmt|;
comment|/* Now allow letters, digits, and _.  */
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'_'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|-
operator|*
name|strp
operator|>
literal|255
condition|)
return|return
literal|"unrecognized keyword/register name"
return|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|*
name|strp
argument_list|,
name|p
operator|-
operator|*
name|strp
argument_list|)
expr_stmt|;
name|buf
index|[
name|p
operator|-
operator|*
name|strp
index|]
operator|=
literal|0
expr_stmt|;
name|ke
operator|=
name|cgen_keyword_lookup_name
argument_list|(
name|keyword_table
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|!=
name|NULL
condition|)
block|{
operator|*
name|valuep
operator|=
name|ke
operator|->
name|value
expr_stmt|;
operator|*
name|strp
operator|=
name|p
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
literal|"unrecognized keyword/register name"
return|;
block|}
end_function

begin_comment
comment|/* Signed integer parser.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cgen_parse_signed_integer
parameter_list|(
name|strp
parameter_list|,
name|opindex
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|,
name|valuep
parameter_list|)
specifier|const
name|char
modifier|*
modifier|*
name|strp
decl_stmt|;
name|int
name|opindex
decl_stmt|;
name|long
name|min
decl_stmt|,
name|max
decl_stmt|;
name|long
modifier|*
name|valuep
decl_stmt|;
block|{
name|long
name|value
decl_stmt|;
name|enum
name|cgen_parse_operand_result
name|result
decl_stmt|;
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|errmsg
operator|=
call|(
modifier|*
name|cgen_parse_operand_fn
call|)
argument_list|(
name|CGEN_PARSE_OPERAND_INTEGER
argument_list|,
name|strp
argument_list|,
name|opindex
argument_list|,
name|BFD_RELOC_NONE
argument_list|,
operator|&
name|result
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* FIXME: Examine `result'.  */
if|if
condition|(
operator|!
name|errmsg
condition|)
block|{
if|if
condition|(
name|value
operator|<
name|min
operator|||
name|value
operator|>
name|max
condition|)
return|return
literal|"integer operand out of range"
return|;
operator|*
name|valuep
operator|=
name|value
expr_stmt|;
block|}
return|return
name|errmsg
return|;
block|}
end_function

begin_comment
comment|/* Unsigned integer parser.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cgen_parse_unsigned_integer
parameter_list|(
name|strp
parameter_list|,
name|opindex
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|,
name|valuep
parameter_list|)
specifier|const
name|char
modifier|*
modifier|*
name|strp
decl_stmt|;
name|int
name|opindex
decl_stmt|;
name|unsigned
name|long
name|min
decl_stmt|,
name|max
decl_stmt|;
name|unsigned
name|long
modifier|*
name|valuep
decl_stmt|;
block|{
name|unsigned
name|long
name|value
decl_stmt|;
name|enum
name|cgen_parse_operand_result
name|result
decl_stmt|;
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|errmsg
operator|=
call|(
modifier|*
name|cgen_parse_operand_fn
call|)
argument_list|(
name|CGEN_PARSE_OPERAND_INTEGER
argument_list|,
name|strp
argument_list|,
name|opindex
argument_list|,
name|BFD_RELOC_NONE
argument_list|,
operator|&
name|result
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* FIXME: Examine `result'.  */
if|if
condition|(
operator|!
name|errmsg
condition|)
block|{
if|if
condition|(
name|value
operator|<
name|min
operator|||
name|value
operator|>
name|max
condition|)
return|return
literal|"integer operand out of range"
return|;
operator|*
name|valuep
operator|=
name|value
expr_stmt|;
block|}
return|return
name|errmsg
return|;
block|}
end_function

begin_comment
comment|/* Address parser.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cgen_parse_address
parameter_list|(
name|strp
parameter_list|,
name|opindex
parameter_list|,
name|opinfo
parameter_list|,
name|valuep
parameter_list|)
specifier|const
name|char
modifier|*
modifier|*
name|strp
decl_stmt|;
name|int
name|opindex
decl_stmt|;
name|int
name|opinfo
decl_stmt|;
name|long
modifier|*
name|valuep
decl_stmt|;
block|{
name|long
name|value
decl_stmt|;
name|enum
name|cgen_parse_operand_result
name|result
decl_stmt|;
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|errmsg
operator|=
call|(
modifier|*
name|cgen_parse_operand_fn
call|)
argument_list|(
name|CGEN_PARSE_OPERAND_ADDRESS
argument_list|,
name|strp
argument_list|,
name|opindex
argument_list|,
name|opinfo
argument_list|,
operator|&
name|result
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* FIXME: Examine `result'.  */
if|if
condition|(
operator|!
name|errmsg
condition|)
block|{
operator|*
name|valuep
operator|=
name|value
expr_stmt|;
block|}
return|return
name|errmsg
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Signed integer validation routine.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cgen_validate_signed_integer
parameter_list|(
name|value
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|)
name|long
name|value
decl_stmt|,
name|min
decl_stmt|,
name|max
decl_stmt|;
block|{
if|if
condition|(
name|value
operator|<
name|min
operator|||
name|value
operator|>
name|max
condition|)
block|{
specifier|const
name|char
modifier|*
name|err
init|=
literal|"operand out of range (%ld not between %ld and %ld)"
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|err
argument_list|,
name|value
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Unsigned integer validation routine.    Supplying `min' here may seem unnecessary, but we also want to handle    cases where min != 0 (and max> LONG_MAX).  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cgen_validate_unsigned_integer
parameter_list|(
name|value
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|)
name|unsigned
name|long
name|value
decl_stmt|,
name|min
decl_stmt|,
name|max
decl_stmt|;
block|{
if|if
condition|(
name|value
operator|<
name|min
operator|||
name|value
operator|>
name|max
condition|)
block|{
specifier|const
name|char
modifier|*
name|err
init|=
literal|"operand out of range (%lu not between %lu and %lu)"
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|err
argument_list|,
name|value
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

end_unit

