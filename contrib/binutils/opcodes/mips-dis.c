begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print mips instructions for GDB, the GNU debugger, or for objdump.    Copyright 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003, 2005    Free Software Foundation, Inc.    Contributed by Nobuyuki Hikichi(hikichi@sra.co.jp).     This file is part of GDB, GAS, and the GNU binutils.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,    MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"opcode/mips.h"
end_include

begin_include
include|#
directive|include
file|"opintl.h"
end_include

begin_comment
comment|/* FIXME: These are needed to figure out if the code is mips16 or    not. The low bit of the address is often a good indicator.  No    symbol table is available when this code runs out in an embedded    system as when it is used for disassembler support in a monitor.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EMBEDDED_ENV
argument_list|)
end_if

begin_define
define|#
directive|define
name|SYMTAB_AVAILABLE
value|1
end_define

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf/mips.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Mips instructions are at maximum this many bytes long.  */
end_comment

begin_define
define|#
directive|define
name|INSNLEN
value|4
end_define

begin_comment
comment|/* Generate Octeon/MIPS unaligned load and store instructions. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INCLUDE_OCTEON_USEUN
end_ifdef

begin_decl_stmt
name|int
name|octeon_use_unalign
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|octeon_use_unalign
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* FIXME: These should be shared with gdb somehow.  */
end_comment

begin_struct
struct|struct
name|mips_cp0sel_name
block|{
name|unsigned
name|int
name|cp0reg
decl_stmt|;
name|unsigned
name|int
name|sel
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The mips16 registers.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|int
name|mips16_to_32_reg_map
index|[]
init|=
block|{
literal|16
block|,
literal|17
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|mips16_reg_names
parameter_list|(
name|rn
parameter_list|)
value|mips_gpr_names[mips16_to_32_reg_map[rn]]
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mips_gpr_names_numeric
index|[
literal|32
index|]
init|=
block|{
literal|"$0"
block|,
literal|"$1"
block|,
literal|"$2"
block|,
literal|"$3"
block|,
literal|"$4"
block|,
literal|"$5"
block|,
literal|"$6"
block|,
literal|"$7"
block|,
literal|"$8"
block|,
literal|"$9"
block|,
literal|"$10"
block|,
literal|"$11"
block|,
literal|"$12"
block|,
literal|"$13"
block|,
literal|"$14"
block|,
literal|"$15"
block|,
literal|"$16"
block|,
literal|"$17"
block|,
literal|"$18"
block|,
literal|"$19"
block|,
literal|"$20"
block|,
literal|"$21"
block|,
literal|"$22"
block|,
literal|"$23"
block|,
literal|"$24"
block|,
literal|"$25"
block|,
literal|"$26"
block|,
literal|"$27"
block|,
literal|"$28"
block|,
literal|"$29"
block|,
literal|"$30"
block|,
literal|"$31"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mips_gpr_names_oldabi
index|[
literal|32
index|]
init|=
block|{
literal|"zero"
block|,
literal|"at"
block|,
literal|"v0"
block|,
literal|"v1"
block|,
literal|"a0"
block|,
literal|"a1"
block|,
literal|"a2"
block|,
literal|"a3"
block|,
literal|"t0"
block|,
literal|"t1"
block|,
literal|"t2"
block|,
literal|"t3"
block|,
literal|"t4"
block|,
literal|"t5"
block|,
literal|"t6"
block|,
literal|"t7"
block|,
literal|"s0"
block|,
literal|"s1"
block|,
literal|"s2"
block|,
literal|"s3"
block|,
literal|"s4"
block|,
literal|"s5"
block|,
literal|"s6"
block|,
literal|"s7"
block|,
literal|"t8"
block|,
literal|"t9"
block|,
literal|"k0"
block|,
literal|"k1"
block|,
literal|"gp"
block|,
literal|"sp"
block|,
literal|"s8"
block|,
literal|"ra"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mips_gpr_names_newabi
index|[
literal|32
index|]
init|=
block|{
literal|"zero"
block|,
literal|"at"
block|,
literal|"v0"
block|,
literal|"v1"
block|,
literal|"a0"
block|,
literal|"a1"
block|,
literal|"a2"
block|,
literal|"a3"
block|,
literal|"a4"
block|,
literal|"a5"
block|,
literal|"a6"
block|,
literal|"a7"
block|,
literal|"t0"
block|,
literal|"t1"
block|,
literal|"t2"
block|,
literal|"t3"
block|,
literal|"s0"
block|,
literal|"s1"
block|,
literal|"s2"
block|,
literal|"s3"
block|,
literal|"s4"
block|,
literal|"s5"
block|,
literal|"s6"
block|,
literal|"s7"
block|,
literal|"t8"
block|,
literal|"t9"
block|,
literal|"k0"
block|,
literal|"k1"
block|,
literal|"gp"
block|,
literal|"sp"
block|,
literal|"s8"
block|,
literal|"ra"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mips_fpr_names_numeric
index|[
literal|32
index|]
init|=
block|{
literal|"$f0"
block|,
literal|"$f1"
block|,
literal|"$f2"
block|,
literal|"$f3"
block|,
literal|"$f4"
block|,
literal|"$f5"
block|,
literal|"$f6"
block|,
literal|"$f7"
block|,
literal|"$f8"
block|,
literal|"$f9"
block|,
literal|"$f10"
block|,
literal|"$f11"
block|,
literal|"$f12"
block|,
literal|"$f13"
block|,
literal|"$f14"
block|,
literal|"$f15"
block|,
literal|"$f16"
block|,
literal|"$f17"
block|,
literal|"$f18"
block|,
literal|"$f19"
block|,
literal|"$f20"
block|,
literal|"$f21"
block|,
literal|"$f22"
block|,
literal|"$f23"
block|,
literal|"$f24"
block|,
literal|"$f25"
block|,
literal|"$f26"
block|,
literal|"$f27"
block|,
literal|"$f28"
block|,
literal|"$f29"
block|,
literal|"$f30"
block|,
literal|"$f31"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mips_fpr_names_32
index|[
literal|32
index|]
init|=
block|{
literal|"fv0"
block|,
literal|"fv0f"
block|,
literal|"fv1"
block|,
literal|"fv1f"
block|,
literal|"ft0"
block|,
literal|"ft0f"
block|,
literal|"ft1"
block|,
literal|"ft1f"
block|,
literal|"ft2"
block|,
literal|"ft2f"
block|,
literal|"ft3"
block|,
literal|"ft3f"
block|,
literal|"fa0"
block|,
literal|"fa0f"
block|,
literal|"fa1"
block|,
literal|"fa1f"
block|,
literal|"ft4"
block|,
literal|"ft4f"
block|,
literal|"ft5"
block|,
literal|"ft5f"
block|,
literal|"fs0"
block|,
literal|"fs0f"
block|,
literal|"fs1"
block|,
literal|"fs1f"
block|,
literal|"fs2"
block|,
literal|"fs2f"
block|,
literal|"fs3"
block|,
literal|"fs3f"
block|,
literal|"fs4"
block|,
literal|"fs4f"
block|,
literal|"fs5"
block|,
literal|"fs5f"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mips_fpr_names_n32
index|[
literal|32
index|]
init|=
block|{
literal|"fv0"
block|,
literal|"ft14"
block|,
literal|"fv1"
block|,
literal|"ft15"
block|,
literal|"ft0"
block|,
literal|"ft1"
block|,
literal|"ft2"
block|,
literal|"ft3"
block|,
literal|"ft4"
block|,
literal|"ft5"
block|,
literal|"ft6"
block|,
literal|"ft7"
block|,
literal|"fa0"
block|,
literal|"fa1"
block|,
literal|"fa2"
block|,
literal|"fa3"
block|,
literal|"fa4"
block|,
literal|"fa5"
block|,
literal|"fa6"
block|,
literal|"fa7"
block|,
literal|"fs0"
block|,
literal|"ft8"
block|,
literal|"fs1"
block|,
literal|"ft9"
block|,
literal|"fs2"
block|,
literal|"ft10"
block|,
literal|"fs3"
block|,
literal|"ft11"
block|,
literal|"fs4"
block|,
literal|"ft12"
block|,
literal|"fs5"
block|,
literal|"ft13"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mips_fpr_names_64
index|[
literal|32
index|]
init|=
block|{
literal|"fv0"
block|,
literal|"ft12"
block|,
literal|"fv1"
block|,
literal|"ft13"
block|,
literal|"ft0"
block|,
literal|"ft1"
block|,
literal|"ft2"
block|,
literal|"ft3"
block|,
literal|"ft4"
block|,
literal|"ft5"
block|,
literal|"ft6"
block|,
literal|"ft7"
block|,
literal|"fa0"
block|,
literal|"fa1"
block|,
literal|"fa2"
block|,
literal|"fa3"
block|,
literal|"fa4"
block|,
literal|"fa5"
block|,
literal|"fa6"
block|,
literal|"fa7"
block|,
literal|"ft8"
block|,
literal|"ft9"
block|,
literal|"ft10"
block|,
literal|"ft11"
block|,
literal|"fs0"
block|,
literal|"fs1"
block|,
literal|"fs2"
block|,
literal|"fs3"
block|,
literal|"fs4"
block|,
literal|"fs5"
block|,
literal|"fs6"
block|,
literal|"fs7"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mips_cp0_names_numeric
index|[
literal|32
index|]
init|=
block|{
literal|"$0"
block|,
literal|"$1"
block|,
literal|"$2"
block|,
literal|"$3"
block|,
literal|"$4"
block|,
literal|"$5"
block|,
literal|"$6"
block|,
literal|"$7"
block|,
literal|"$8"
block|,
literal|"$9"
block|,
literal|"$10"
block|,
literal|"$11"
block|,
literal|"$12"
block|,
literal|"$13"
block|,
literal|"$14"
block|,
literal|"$15"
block|,
literal|"$16"
block|,
literal|"$17"
block|,
literal|"$18"
block|,
literal|"$19"
block|,
literal|"$20"
block|,
literal|"$21"
block|,
literal|"$22"
block|,
literal|"$23"
block|,
literal|"$24"
block|,
literal|"$25"
block|,
literal|"$26"
block|,
literal|"$27"
block|,
literal|"$28"
block|,
literal|"$29"
block|,
literal|"$30"
block|,
literal|"$31"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mips_cp0_names_mips3264
index|[
literal|32
index|]
init|=
block|{
literal|"c0_index"
block|,
literal|"c0_random"
block|,
literal|"c0_entrylo0"
block|,
literal|"c0_entrylo1"
block|,
literal|"c0_context"
block|,
literal|"c0_pagemask"
block|,
literal|"c0_wired"
block|,
literal|"$7"
block|,
literal|"c0_badvaddr"
block|,
literal|"c0_count"
block|,
literal|"c0_entryhi"
block|,
literal|"c0_compare"
block|,
literal|"c0_status"
block|,
literal|"c0_cause"
block|,
literal|"c0_epc"
block|,
literal|"c0_prid"
block|,
literal|"c0_config"
block|,
literal|"c0_lladdr"
block|,
literal|"c0_watchlo"
block|,
literal|"c0_watchhi"
block|,
literal|"c0_xcontext"
block|,
literal|"$21"
block|,
literal|"$22"
block|,
literal|"c0_debug"
block|,
literal|"c0_depc"
block|,
literal|"c0_perfcnt"
block|,
literal|"c0_errctl"
block|,
literal|"c0_cacheerr"
block|,
literal|"c0_taglo"
block|,
literal|"c0_taghi"
block|,
literal|"c0_errorepc"
block|,
literal|"c0_desave"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|mips_cp0sel_name
name|mips_cp0sel_names_mips3264
index|[]
init|=
block|{
block|{
literal|16
block|,
literal|1
block|,
literal|"c0_config1"
block|}
block|,
block|{
literal|16
block|,
literal|2
block|,
literal|"c0_config2"
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|"c0_config3"
block|}
block|,
block|{
literal|18
block|,
literal|1
block|,
literal|"c0_watchlo,1"
block|}
block|,
block|{
literal|18
block|,
literal|2
block|,
literal|"c0_watchlo,2"
block|}
block|,
block|{
literal|18
block|,
literal|3
block|,
literal|"c0_watchlo,3"
block|}
block|,
block|{
literal|18
block|,
literal|4
block|,
literal|"c0_watchlo,4"
block|}
block|,
block|{
literal|18
block|,
literal|5
block|,
literal|"c0_watchlo,5"
block|}
block|,
block|{
literal|18
block|,
literal|6
block|,
literal|"c0_watchlo,6"
block|}
block|,
block|{
literal|18
block|,
literal|7
block|,
literal|"c0_watchlo,7"
block|}
block|,
block|{
literal|19
block|,
literal|1
block|,
literal|"c0_watchhi,1"
block|}
block|,
block|{
literal|19
block|,
literal|2
block|,
literal|"c0_watchhi,2"
block|}
block|,
block|{
literal|19
block|,
literal|3
block|,
literal|"c0_watchhi,3"
block|}
block|,
block|{
literal|19
block|,
literal|4
block|,
literal|"c0_watchhi,4"
block|}
block|,
block|{
literal|19
block|,
literal|5
block|,
literal|"c0_watchhi,5"
block|}
block|,
block|{
literal|19
block|,
literal|6
block|,
literal|"c0_watchhi,6"
block|}
block|,
block|{
literal|19
block|,
literal|7
block|,
literal|"c0_watchhi,7"
block|}
block|,
block|{
literal|25
block|,
literal|1
block|,
literal|"c0_perfcnt,1"
block|}
block|,
block|{
literal|25
block|,
literal|2
block|,
literal|"c0_perfcnt,2"
block|}
block|,
block|{
literal|25
block|,
literal|3
block|,
literal|"c0_perfcnt,3"
block|}
block|,
block|{
literal|25
block|,
literal|4
block|,
literal|"c0_perfcnt,4"
block|}
block|,
block|{
literal|25
block|,
literal|5
block|,
literal|"c0_perfcnt,5"
block|}
block|,
block|{
literal|25
block|,
literal|6
block|,
literal|"c0_perfcnt,6"
block|}
block|,
block|{
literal|25
block|,
literal|7
block|,
literal|"c0_perfcnt,7"
block|}
block|,
block|{
literal|27
block|,
literal|1
block|,
literal|"c0_cacheerr,1"
block|}
block|,
block|{
literal|27
block|,
literal|2
block|,
literal|"c0_cacheerr,2"
block|}
block|,
block|{
literal|27
block|,
literal|3
block|,
literal|"c0_cacheerr,3"
block|}
block|,
block|{
literal|28
block|,
literal|1
block|,
literal|"c0_datalo"
block|}
block|,
block|{
literal|29
block|,
literal|1
block|,
literal|"c0_datahi"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mips_cp0_names_mips3264r2
index|[
literal|32
index|]
init|=
block|{
literal|"c0_index"
block|,
literal|"c0_random"
block|,
literal|"c0_entrylo0"
block|,
literal|"c0_entrylo1"
block|,
literal|"c0_context"
block|,
literal|"c0_pagemask"
block|,
literal|"c0_wired"
block|,
literal|"c0_hwrena"
block|,
literal|"c0_badvaddr"
block|,
literal|"c0_count"
block|,
literal|"c0_entryhi"
block|,
literal|"c0_compare"
block|,
literal|"c0_status"
block|,
literal|"c0_cause"
block|,
literal|"c0_epc"
block|,
literal|"c0_prid"
block|,
literal|"c0_config"
block|,
literal|"c0_lladdr"
block|,
literal|"c0_watchlo"
block|,
literal|"c0_watchhi"
block|,
literal|"c0_xcontext"
block|,
literal|"$21"
block|,
literal|"$22"
block|,
literal|"c0_debug"
block|,
literal|"c0_depc"
block|,
literal|"c0_perfcnt"
block|,
literal|"c0_errctl"
block|,
literal|"c0_cacheerr"
block|,
literal|"c0_taglo"
block|,
literal|"c0_taghi"
block|,
literal|"c0_errorepc"
block|,
literal|"c0_desave"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|mips_cp0sel_name
name|mips_cp0sel_names_mips3264r2
index|[]
init|=
block|{
block|{
literal|4
block|,
literal|1
block|,
literal|"c0_contextconfig"
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|"c0_mvpcontrol"
block|}
block|,
block|{
literal|0
block|,
literal|2
block|,
literal|"c0_mvpconf0"
block|}
block|,
block|{
literal|0
block|,
literal|3
block|,
literal|"c0_mvpconf1"
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|"c0_vpecontrol"
block|}
block|,
block|{
literal|1
block|,
literal|2
block|,
literal|"c0_vpeconf0"
block|}
block|,
block|{
literal|1
block|,
literal|3
block|,
literal|"c0_vpeconf1"
block|}
block|,
block|{
literal|1
block|,
literal|4
block|,
literal|"c0_yqmask"
block|}
block|,
block|{
literal|1
block|,
literal|5
block|,
literal|"c0_vpeschedule"
block|}
block|,
block|{
literal|1
block|,
literal|6
block|,
literal|"c0_vpeschefback"
block|}
block|,
block|{
literal|2
block|,
literal|1
block|,
literal|"c0_tcstatus"
block|}
block|,
block|{
literal|2
block|,
literal|2
block|,
literal|"c0_tcbind"
block|}
block|,
block|{
literal|2
block|,
literal|3
block|,
literal|"c0_tcrestart"
block|}
block|,
block|{
literal|2
block|,
literal|4
block|,
literal|"c0_tchalt"
block|}
block|,
block|{
literal|2
block|,
literal|5
block|,
literal|"c0_tccontext"
block|}
block|,
block|{
literal|2
block|,
literal|6
block|,
literal|"c0_tcschedule"
block|}
block|,
block|{
literal|2
block|,
literal|7
block|,
literal|"c0_tcschefback"
block|}
block|,
block|{
literal|5
block|,
literal|1
block|,
literal|"c0_pagegrain"
block|}
block|,
block|{
literal|6
block|,
literal|1
block|,
literal|"c0_srsconf0"
block|}
block|,
block|{
literal|6
block|,
literal|2
block|,
literal|"c0_srsconf1"
block|}
block|,
block|{
literal|6
block|,
literal|3
block|,
literal|"c0_srsconf2"
block|}
block|,
block|{
literal|6
block|,
literal|4
block|,
literal|"c0_srsconf3"
block|}
block|,
block|{
literal|6
block|,
literal|5
block|,
literal|"c0_srsconf4"
block|}
block|,
block|{
literal|12
block|,
literal|1
block|,
literal|"c0_intctl"
block|}
block|,
block|{
literal|12
block|,
literal|2
block|,
literal|"c0_srsctl"
block|}
block|,
block|{
literal|12
block|,
literal|3
block|,
literal|"c0_srsmap"
block|}
block|,
block|{
literal|15
block|,
literal|1
block|,
literal|"c0_ebase"
block|}
block|,
block|{
literal|16
block|,
literal|1
block|,
literal|"c0_config1"
block|}
block|,
block|{
literal|16
block|,
literal|2
block|,
literal|"c0_config2"
block|}
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|"c0_config3"
block|}
block|,
block|{
literal|18
block|,
literal|1
block|,
literal|"c0_watchlo,1"
block|}
block|,
block|{
literal|18
block|,
literal|2
block|,
literal|"c0_watchlo,2"
block|}
block|,
block|{
literal|18
block|,
literal|3
block|,
literal|"c0_watchlo,3"
block|}
block|,
block|{
literal|18
block|,
literal|4
block|,
literal|"c0_watchlo,4"
block|}
block|,
block|{
literal|18
block|,
literal|5
block|,
literal|"c0_watchlo,5"
block|}
block|,
block|{
literal|18
block|,
literal|6
block|,
literal|"c0_watchlo,6"
block|}
block|,
block|{
literal|18
block|,
literal|7
block|,
literal|"c0_watchlo,7"
block|}
block|,
block|{
literal|19
block|,
literal|1
block|,
literal|"c0_watchhi,1"
block|}
block|,
block|{
literal|19
block|,
literal|2
block|,
literal|"c0_watchhi,2"
block|}
block|,
block|{
literal|19
block|,
literal|3
block|,
literal|"c0_watchhi,3"
block|}
block|,
block|{
literal|19
block|,
literal|4
block|,
literal|"c0_watchhi,4"
block|}
block|,
block|{
literal|19
block|,
literal|5
block|,
literal|"c0_watchhi,5"
block|}
block|,
block|{
literal|19
block|,
literal|6
block|,
literal|"c0_watchhi,6"
block|}
block|,
block|{
literal|19
block|,
literal|7
block|,
literal|"c0_watchhi,7"
block|}
block|,
block|{
literal|23
block|,
literal|1
block|,
literal|"c0_tracecontrol"
block|}
block|,
block|{
literal|23
block|,
literal|2
block|,
literal|"c0_tracecontrol2"
block|}
block|,
block|{
literal|23
block|,
literal|3
block|,
literal|"c0_usertracedata"
block|}
block|,
block|{
literal|23
block|,
literal|4
block|,
literal|"c0_tracebpc"
block|}
block|,
block|{
literal|25
block|,
literal|1
block|,
literal|"c0_perfcnt,1"
block|}
block|,
block|{
literal|25
block|,
literal|2
block|,
literal|"c0_perfcnt,2"
block|}
block|,
block|{
literal|25
block|,
literal|3
block|,
literal|"c0_perfcnt,3"
block|}
block|,
block|{
literal|25
block|,
literal|4
block|,
literal|"c0_perfcnt,4"
block|}
block|,
block|{
literal|25
block|,
literal|5
block|,
literal|"c0_perfcnt,5"
block|}
block|,
block|{
literal|25
block|,
literal|6
block|,
literal|"c0_perfcnt,6"
block|}
block|,
block|{
literal|25
block|,
literal|7
block|,
literal|"c0_perfcnt,7"
block|}
block|,
block|{
literal|27
block|,
literal|1
block|,
literal|"c0_cacheerr,1"
block|}
block|,
block|{
literal|27
block|,
literal|2
block|,
literal|"c0_cacheerr,2"
block|}
block|,
block|{
literal|27
block|,
literal|3
block|,
literal|"c0_cacheerr,3"
block|}
block|,
block|{
literal|28
block|,
literal|1
block|,
literal|"c0_datalo"
block|}
block|,
block|{
literal|28
block|,
literal|2
block|,
literal|"c0_taglo1"
block|}
block|,
block|{
literal|28
block|,
literal|3
block|,
literal|"c0_datalo1"
block|}
block|,
block|{
literal|28
block|,
literal|4
block|,
literal|"c0_taglo2"
block|}
block|,
block|{
literal|28
block|,
literal|5
block|,
literal|"c0_datalo2"
block|}
block|,
block|{
literal|28
block|,
literal|6
block|,
literal|"c0_taglo3"
block|}
block|,
block|{
literal|28
block|,
literal|7
block|,
literal|"c0_datalo3"
block|}
block|,
block|{
literal|29
block|,
literal|1
block|,
literal|"c0_datahi"
block|}
block|,
block|{
literal|29
block|,
literal|2
block|,
literal|"c0_taghi1"
block|}
block|,
block|{
literal|29
block|,
literal|3
block|,
literal|"c0_datahi1"
block|}
block|,
block|{
literal|29
block|,
literal|4
block|,
literal|"c0_taghi2"
block|}
block|,
block|{
literal|29
block|,
literal|5
block|,
literal|"c0_datahi2"
block|}
block|,
block|{
literal|29
block|,
literal|6
block|,
literal|"c0_taghi3"
block|}
block|,
block|{
literal|29
block|,
literal|7
block|,
literal|"c0_datahi3"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SB-1: MIPS64 (mips_cp0_names_mips3264) with minor mods.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mips_cp0_names_sb1
index|[
literal|32
index|]
init|=
block|{
literal|"c0_index"
block|,
literal|"c0_random"
block|,
literal|"c0_entrylo0"
block|,
literal|"c0_entrylo1"
block|,
literal|"c0_context"
block|,
literal|"c0_pagemask"
block|,
literal|"c0_wired"
block|,
literal|"$7"
block|,
literal|"c0_badvaddr"
block|,
literal|"c0_count"
block|,
literal|"c0_entryhi"
block|,
literal|"c0_compare"
block|,
literal|"c0_status"
block|,
literal|"c0_cause"
block|,
literal|"c0_epc"
block|,
literal|"c0_prid"
block|,
literal|"c0_config"
block|,
literal|"c0_lladdr"
block|,
literal|"c0_watchlo"
block|,
literal|"c0_watchhi"
block|,
literal|"c0_xcontext"
block|,
literal|"$21"
block|,
literal|"$22"
block|,
literal|"c0_debug"
block|,
literal|"c0_depc"
block|,
literal|"c0_perfcnt"
block|,
literal|"c0_errctl"
block|,
literal|"c0_cacheerr_i"
block|,
literal|"c0_taglo_i"
block|,
literal|"c0_taghi_i"
block|,
literal|"c0_errorepc"
block|,
literal|"c0_desave"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|mips_cp0sel_name
name|mips_cp0sel_names_sb1
index|[]
init|=
block|{
block|{
literal|16
block|,
literal|1
block|,
literal|"c0_config1"
block|}
block|,
block|{
literal|18
block|,
literal|1
block|,
literal|"c0_watchlo,1"
block|}
block|,
block|{
literal|19
block|,
literal|1
block|,
literal|"c0_watchhi,1"
block|}
block|,
block|{
literal|22
block|,
literal|0
block|,
literal|"c0_perftrace"
block|}
block|,
block|{
literal|23
block|,
literal|3
block|,
literal|"c0_edebug"
block|}
block|,
block|{
literal|25
block|,
literal|1
block|,
literal|"c0_perfcnt,1"
block|}
block|,
block|{
literal|25
block|,
literal|2
block|,
literal|"c0_perfcnt,2"
block|}
block|,
block|{
literal|25
block|,
literal|3
block|,
literal|"c0_perfcnt,3"
block|}
block|,
block|{
literal|25
block|,
literal|4
block|,
literal|"c0_perfcnt,4"
block|}
block|,
block|{
literal|25
block|,
literal|5
block|,
literal|"c0_perfcnt,5"
block|}
block|,
block|{
literal|25
block|,
literal|6
block|,
literal|"c0_perfcnt,6"
block|}
block|,
block|{
literal|25
block|,
literal|7
block|,
literal|"c0_perfcnt,7"
block|}
block|,
block|{
literal|26
block|,
literal|1
block|,
literal|"c0_buserr_pa"
block|}
block|,
block|{
literal|27
block|,
literal|1
block|,
literal|"c0_cacheerr_d"
block|}
block|,
block|{
literal|27
block|,
literal|3
block|,
literal|"c0_cacheerr_d_pa"
block|}
block|,
block|{
literal|28
block|,
literal|1
block|,
literal|"c0_datalo_i"
block|}
block|,
block|{
literal|28
block|,
literal|2
block|,
literal|"c0_taglo_d"
block|}
block|,
block|{
literal|28
block|,
literal|3
block|,
literal|"c0_datalo_d"
block|}
block|,
block|{
literal|29
block|,
literal|1
block|,
literal|"c0_datahi_i"
block|}
block|,
block|{
literal|29
block|,
literal|2
block|,
literal|"c0_taghi_d"
block|}
block|,
block|{
literal|29
block|,
literal|3
block|,
literal|"c0_datahi_d"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mips_cp0_names_octeon
index|[
literal|32
index|]
init|=
block|{
literal|"c0_index"
block|,
literal|"c0_random"
block|,
literal|"c0_entrylo0"
block|,
literal|"c0_entrylo1"
block|,
literal|"c0_context"
block|,
literal|"c0_pagemask"
block|,
literal|"c0_wired"
block|,
literal|"c0_hwrena"
block|,
literal|"c0_badvaddr"
block|,
literal|"c0_count"
block|,
literal|"c0_entryhi"
block|,
literal|"c0_compare"
block|,
literal|"c0_status"
block|,
literal|"c0_cause"
block|,
literal|"c0_epc"
block|,
literal|"c0_prid"
block|,
literal|"c0_config"
block|,
literal|"$17"
block|,
literal|"c0_watchlo"
block|,
literal|"c0_watchhi"
block|,
literal|"c0_xcontext"
block|,
literal|"$21"
block|,
literal|"c0_mdebug"
block|,
literal|"c0_debug"
block|,
literal|"c0_depc"
block|,
literal|"c0_perfcnt"
block|,
literal|"$26"
block|,
literal|"c0_cacheerr"
block|,
literal|"c0_taglo"
block|,
literal|"c0_taghi"
block|,
literal|"c0_errorepc"
block|,
literal|"c0_desave"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|mips_cp0sel_name
name|mips_cp0sel_names_octeon
index|[]
init|=
block|{
block|{
literal|5
block|,
literal|1
block|,
literal|"c0_pagegrain"
block|}
block|,
block|{
literal|9
block|,
literal|6
block|,
literal|"c0_cvmcount"
block|}
block|,
block|{
literal|9
block|,
literal|7
block|,
literal|"c0_cvmctl"
block|}
block|,
block|{
literal|11
block|,
literal|7
block|,
literal|"c0_cvmmemctl"
block|}
block|,
block|{
literal|12
block|,
literal|1
block|,
literal|"c0_intctl"
block|}
block|,
block|{
literal|12
block|,
literal|2
block|,
literal|"c0_srsctl"
block|}
block|,
block|{
literal|15
block|,
literal|1
block|,
literal|"c0_ebase"
block|}
block|,
block|{
literal|16
block|,
literal|1
block|,
literal|"c0_config1"
block|,                }
block|,
block|{
literal|16
block|,
literal|2
block|,
literal|"c0_config2"
block|,                }
block|,
block|{
literal|16
block|,
literal|3
block|,
literal|"c0_config3"
block|,                }
block|,
block|{
literal|18
block|,
literal|1
block|,
literal|"c0_watchlo,1"
block|}
block|,
block|{
literal|19
block|,
literal|1
block|,
literal|"c0_watchhi,1"
block|}
block|,
block|{
literal|25
block|,
literal|2
block|,
literal|"c0_perfcnt,2"
block|}
block|,
block|{
literal|27
block|,
literal|1
block|,
literal|"c0_cacheerr,1"
block|}
block|,
block|{
literal|28
block|,
literal|3
block|,
literal|"c0_datalo"
block|}
block|,
block|{
literal|29
block|,
literal|3
block|,
literal|"c0_datahi"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mips_hwr_names_numeric
index|[
literal|32
index|]
init|=
block|{
literal|"$0"
block|,
literal|"$1"
block|,
literal|"$2"
block|,
literal|"$3"
block|,
literal|"$4"
block|,
literal|"$5"
block|,
literal|"$6"
block|,
literal|"$7"
block|,
literal|"$8"
block|,
literal|"$9"
block|,
literal|"$10"
block|,
literal|"$11"
block|,
literal|"$12"
block|,
literal|"$13"
block|,
literal|"$14"
block|,
literal|"$15"
block|,
literal|"$16"
block|,
literal|"$17"
block|,
literal|"$18"
block|,
literal|"$19"
block|,
literal|"$20"
block|,
literal|"$21"
block|,
literal|"$22"
block|,
literal|"$23"
block|,
literal|"$24"
block|,
literal|"$25"
block|,
literal|"$26"
block|,
literal|"$27"
block|,
literal|"$28"
block|,
literal|"$29"
block|,
literal|"$30"
block|,
literal|"$31"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mips_hwr_names_mips3264r2
index|[
literal|32
index|]
init|=
block|{
literal|"hwr_cpunum"
block|,
literal|"hwr_synci_step"
block|,
literal|"hwr_cc"
block|,
literal|"hwr_ccres"
block|,
literal|"$4"
block|,
literal|"$5"
block|,
literal|"$6"
block|,
literal|"$7"
block|,
literal|"$8"
block|,
literal|"$9"
block|,
literal|"$10"
block|,
literal|"$11"
block|,
literal|"$12"
block|,
literal|"$13"
block|,
literal|"$14"
block|,
literal|"$15"
block|,
literal|"$16"
block|,
literal|"$17"
block|,
literal|"$18"
block|,
literal|"$19"
block|,
literal|"$20"
block|,
literal|"$21"
block|,
literal|"$22"
block|,
literal|"$23"
block|,
literal|"$24"
block|,
literal|"$25"
block|,
literal|"$26"
block|,
literal|"$27"
block|,
literal|"$28"
block|,
literal|"$29"
block|,
literal|"$30"
block|,
literal|"$31"
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|mips_abi_choice
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|gpr_names
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|fpr_names
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|mips_abi_choice
name|mips_abi_choices
index|[]
init|=
block|{
block|{
literal|"numeric"
block|,
name|mips_gpr_names_numeric
block|,
name|mips_fpr_names_numeric
block|}
block|,
block|{
literal|"32"
block|,
name|mips_gpr_names_oldabi
block|,
name|mips_fpr_names_32
block|}
block|,
block|{
literal|"n32"
block|,
name|mips_gpr_names_newabi
block|,
name|mips_fpr_names_n32
block|}
block|,
block|{
literal|"64"
block|,
name|mips_gpr_names_newabi
block|,
name|mips_fpr_names_64
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|mips_arch_choice
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|bfd_mach_valid
decl_stmt|;
name|unsigned
name|long
name|bfd_mach
decl_stmt|;
name|int
name|processor
decl_stmt|;
name|int
name|isa
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|cp0_names
decl_stmt|;
specifier|const
name|struct
name|mips_cp0sel_name
modifier|*
name|cp0sel_names
decl_stmt|;
name|unsigned
name|int
name|cp0sel_names_len
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|hwr_names
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|const
name|struct
name|mips_arch_choice
name|mips_arch_choices
index|[]
init|=
block|{
block|{
literal|"numeric"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|mips_cp0_names_numeric
block|,
name|NULL
block|,
literal|0
block|,
name|mips_hwr_names_numeric
block|}
block|,
block|{
literal|"r3000"
block|,
literal|1
block|,
name|bfd_mach_mips3000
block|,
name|CPU_R3000
block|,
name|ISA_MIPS1
block|,
name|mips_cp0_names_numeric
block|,
name|NULL
block|,
literal|0
block|,
name|mips_hwr_names_numeric
block|}
block|,
block|{
literal|"r3900"
block|,
literal|1
block|,
name|bfd_mach_mips3900
block|,
name|CPU_R3900
block|,
name|ISA_MIPS1
block|,
name|mips_cp0_names_numeric
block|,
name|NULL
block|,
literal|0
block|,
name|mips_hwr_names_numeric
block|}
block|,
block|{
literal|"r4000"
block|,
literal|1
block|,
name|bfd_mach_mips4000
block|,
name|CPU_R4000
block|,
name|ISA_MIPS3
block|,
name|mips_cp0_names_numeric
block|,
name|NULL
block|,
literal|0
block|,
name|mips_hwr_names_numeric
block|}
block|,
block|{
literal|"r4010"
block|,
literal|1
block|,
name|bfd_mach_mips4010
block|,
name|CPU_R4010
block|,
name|ISA_MIPS2
block|,
name|mips_cp0_names_numeric
block|,
name|NULL
block|,
literal|0
block|,
name|mips_hwr_names_numeric
block|}
block|,
block|{
literal|"vr4100"
block|,
literal|1
block|,
name|bfd_mach_mips4100
block|,
name|CPU_VR4100
block|,
name|ISA_MIPS3
block|,
name|mips_cp0_names_numeric
block|,
name|NULL
block|,
literal|0
block|,
name|mips_hwr_names_numeric
block|}
block|,
block|{
literal|"vr4111"
block|,
literal|1
block|,
name|bfd_mach_mips4111
block|,
name|CPU_R4111
block|,
name|ISA_MIPS3
block|,
name|mips_cp0_names_numeric
block|,
name|NULL
block|,
literal|0
block|,
name|mips_hwr_names_numeric
block|}
block|,
block|{
literal|"vr4120"
block|,
literal|1
block|,
name|bfd_mach_mips4120
block|,
name|CPU_VR4120
block|,
name|ISA_MIPS3
block|,
name|mips_cp0_names_numeric
block|,
name|NULL
block|,
literal|0
block|,
name|mips_hwr_names_numeric
block|}
block|,
block|{
literal|"r4300"
block|,
literal|1
block|,
name|bfd_mach_mips4300
block|,
name|CPU_R4300
block|,
name|ISA_MIPS3
block|,
name|mips_cp0_names_numeric
block|,
name|NULL
block|,
literal|0
block|,
name|mips_hwr_names_numeric
block|}
block|,
block|{
literal|"r4400"
block|,
literal|1
block|,
name|bfd_mach_mips4400
block|,
name|CPU_R4400
block|,
name|ISA_MIPS3
block|,
name|mips_cp0_names_numeric
block|,
name|NULL
block|,
literal|0
block|,
name|mips_hwr_names_numeric
block|}
block|,
block|{
literal|"r4600"
block|,
literal|1
block|,
name|bfd_mach_mips4600
block|,
name|CPU_R4600
block|,
name|ISA_MIPS3
block|,
name|mips_cp0_names_numeric
block|,
name|NULL
block|,
literal|0
block|,
name|mips_hwr_names_numeric
block|}
block|,
block|{
literal|"r4650"
block|,
literal|1
block|,
name|bfd_mach_mips4650
block|,
name|CPU_R4650
block|,
name|ISA_MIPS3
block|,
name|mips_cp0_names_numeric
block|,
name|NULL
block|,
literal|0
block|,
name|mips_hwr_names_numeric
block|}
block|,
block|{
literal|"r5000"
block|,
literal|1
block|,
name|bfd_mach_mips5000
block|,
name|CPU_R5000
block|,
name|ISA_MIPS4
block|,
name|mips_cp0_names_numeric
block|,
name|NULL
block|,
literal|0
block|,
name|mips_hwr_names_numeric
block|}
block|,
block|{
literal|"vr5400"
block|,
literal|1
block|,
name|bfd_mach_mips5400
block|,
name|CPU_VR5400
block|,
name|ISA_MIPS4
block|,
name|mips_cp0_names_numeric
block|,
name|NULL
block|,
literal|0
block|,
name|mips_hwr_names_numeric
block|}
block|,
block|{
literal|"vr5500"
block|,
literal|1
block|,
name|bfd_mach_mips5500
block|,
name|CPU_VR5500
block|,
name|ISA_MIPS4
block|,
name|mips_cp0_names_numeric
block|,
name|NULL
block|,
literal|0
block|,
name|mips_hwr_names_numeric
block|}
block|,
block|{
literal|"r6000"
block|,
literal|1
block|,
name|bfd_mach_mips6000
block|,
name|CPU_R6000
block|,
name|ISA_MIPS2
block|,
name|mips_cp0_names_numeric
block|,
name|NULL
block|,
literal|0
block|,
name|mips_hwr_names_numeric
block|}
block|,
block|{
literal|"rm7000"
block|,
literal|1
block|,
name|bfd_mach_mips7000
block|,
name|CPU_RM7000
block|,
name|ISA_MIPS4
block|,
name|mips_cp0_names_numeric
block|,
name|NULL
block|,
literal|0
block|,
name|mips_hwr_names_numeric
block|}
block|,
block|{
literal|"rm9000"
block|,
literal|1
block|,
name|bfd_mach_mips7000
block|,
name|CPU_RM7000
block|,
name|ISA_MIPS4
block|,
name|mips_cp0_names_numeric
block|,
name|NULL
block|,
literal|0
block|,
name|mips_hwr_names_numeric
block|}
block|,
block|{
literal|"r8000"
block|,
literal|1
block|,
name|bfd_mach_mips8000
block|,
name|CPU_R8000
block|,
name|ISA_MIPS4
block|,
name|mips_cp0_names_numeric
block|,
name|NULL
block|,
literal|0
block|,
name|mips_hwr_names_numeric
block|}
block|,
block|{
literal|"r10000"
block|,
literal|1
block|,
name|bfd_mach_mips10000
block|,
name|CPU_R10000
block|,
name|ISA_MIPS4
block|,
name|mips_cp0_names_numeric
block|,
name|NULL
block|,
literal|0
block|,
name|mips_hwr_names_numeric
block|}
block|,
block|{
literal|"r12000"
block|,
literal|1
block|,
name|bfd_mach_mips12000
block|,
name|CPU_R12000
block|,
name|ISA_MIPS4
block|,
name|mips_cp0_names_numeric
block|,
name|NULL
block|,
literal|0
block|,
name|mips_hwr_names_numeric
block|}
block|,
block|{
literal|"mips5"
block|,
literal|1
block|,
name|bfd_mach_mips5
block|,
name|CPU_MIPS5
block|,
name|ISA_MIPS5
block|,
name|mips_cp0_names_numeric
block|,
name|NULL
block|,
literal|0
block|,
name|mips_hwr_names_numeric
block|}
block|,
comment|/* For stock MIPS32, disassemble all applicable MIPS-specified ASEs.      Note that MIPS-3D and MDMX are not applicable to MIPS32.  (See      _MIPS32 Architecture For Programmers Volume I: Introduction to the      MIPS32 Architecture_ (MIPS Document Number MD00082, Revision 0.95),      page 1.  */
block|{
literal|"mips32"
block|,
literal|1
block|,
name|bfd_mach_mipsisa32
block|,
name|CPU_MIPS32
block|,
name|ISA_MIPS32
operator||
name|INSN_MIPS16
operator||
name|INSN_SMARTMIPS
block|,
name|mips_cp0_names_mips3264
block|,
name|mips_cp0sel_names_mips3264
block|,
name|ARRAY_SIZE
argument_list|(
name|mips_cp0sel_names_mips3264
argument_list|)
block|,
name|mips_hwr_names_numeric
block|}
block|,
block|{
literal|"mips32r2"
block|,
literal|1
block|,
name|bfd_mach_mipsisa32r2
block|,
name|CPU_MIPS32R2
block|,
operator|(
name|ISA_MIPS32R2
operator||
name|INSN_MIPS16
operator||
name|INSN_SMARTMIPS
operator||
name|INSN_DSP
operator||
name|INSN_DSPR2
operator||
name|INSN_MIPS3D
operator||
name|INSN_MT
operator|)
block|,
name|mips_cp0_names_mips3264r2
block|,
name|mips_cp0sel_names_mips3264r2
block|,
name|ARRAY_SIZE
argument_list|(
name|mips_cp0sel_names_mips3264r2
argument_list|)
block|,
name|mips_hwr_names_mips3264r2
block|}
block|,
comment|/* For stock MIPS64, disassemble all applicable MIPS-specified ASEs.  */
block|{
literal|"mips64"
block|,
literal|1
block|,
name|bfd_mach_mipsisa64
block|,
name|CPU_MIPS64
block|,
name|ISA_MIPS64
operator||
name|INSN_MIPS16
operator||
name|INSN_MIPS3D
operator||
name|INSN_MDMX
block|,
name|mips_cp0_names_mips3264
block|,
name|mips_cp0sel_names_mips3264
block|,
name|ARRAY_SIZE
argument_list|(
name|mips_cp0sel_names_mips3264
argument_list|)
block|,
name|mips_hwr_names_numeric
block|}
block|,
block|{
literal|"mips64r2"
block|,
literal|1
block|,
name|bfd_mach_mipsisa64r2
block|,
name|CPU_MIPS64R2
block|,
operator|(
name|ISA_MIPS64R2
operator||
name|INSN_MIPS16
operator||
name|INSN_MIPS3D
operator||
name|INSN_DSP
operator||
name|INSN_DSPR2
operator||
name|INSN_DSP64
operator||
name|INSN_MT
operator||
name|INSN_MDMX
operator|)
block|,
name|mips_cp0_names_mips3264r2
block|,
name|mips_cp0sel_names_mips3264r2
block|,
name|ARRAY_SIZE
argument_list|(
name|mips_cp0sel_names_mips3264r2
argument_list|)
block|,
name|mips_hwr_names_mips3264r2
block|}
block|,
block|{
literal|"sb1"
block|,
literal|1
block|,
name|bfd_mach_mips_sb1
block|,
name|CPU_SB1
block|,
name|ISA_MIPS64
operator||
name|INSN_MIPS3D
operator||
name|INSN_SB1
block|,
name|mips_cp0_names_sb1
block|,
name|mips_cp0sel_names_sb1
block|,
name|ARRAY_SIZE
argument_list|(
name|mips_cp0sel_names_sb1
argument_list|)
block|,
name|mips_hwr_names_numeric
block|}
block|,
block|{
literal|"octeon"
block|,
literal|1
block|,
name|bfd_mach_mips_octeon
block|,
name|CPU_OCTEON
block|,
name|ISA_MIPS64R2
operator||
name|INSN_OCTEON
block|,
name|mips_cp0_names_octeon
block|,
name|mips_cp0sel_names_octeon
block|,
name|ARRAY_SIZE
argument_list|(
name|mips_cp0sel_names_octeon
argument_list|)
block|,
name|mips_hwr_names_numeric
block|}
block|,
comment|/* This entry, mips16, is here only for ISA/processor selection; do      not print its name.  */
block|{
literal|""
block|,
literal|1
block|,
name|bfd_mach_mips16
block|,
name|CPU_MIPS16
block|,
name|ISA_MIPS3
operator||
name|INSN_MIPS16
block|,
name|mips_cp0_names_numeric
block|,
name|NULL
block|,
literal|0
block|,
name|mips_hwr_names_numeric
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ISA and processor type to disassemble for, and register names to use.    set_default_mips_dis_options and parse_mips_dis_options fill in these    values.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_processor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mips_isa
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|mips_gpr_names
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|mips_fpr_names
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|mips_cp0_names
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|mips_cp0sel_name
modifier|*
name|mips_cp0sel_names
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mips_cp0sel_names_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|mips_hwr_names
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Other options */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_aliases
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If set disassemble as most general inst.  */
end_comment

begin_escape
end_escape

begin_function
specifier|static
specifier|const
name|struct
name|mips_abi_choice
modifier|*
name|choose_abi_by_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|namelen
parameter_list|)
block|{
specifier|const
name|struct
name|mips_abi_choice
modifier|*
name|c
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|c
operator|=
name|NULL
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|mips_abi_choices
argument_list|)
operator|&&
name|c
operator|==
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|mips_abi_choices
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
operator|==
literal|0
operator|&&
name|strlen
argument_list|(
name|mips_abi_choices
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
name|namelen
condition|)
name|c
operator|=
operator|&
name|mips_abi_choices
index|[
name|i
index|]
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|mips_arch_choice
modifier|*
name|choose_arch_by_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|namelen
parameter_list|)
block|{
specifier|const
name|struct
name|mips_arch_choice
modifier|*
name|c
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|c
operator|=
name|NULL
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|mips_arch_choices
argument_list|)
operator|&&
name|c
operator|==
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|mips_arch_choices
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
operator|==
literal|0
operator|&&
name|strlen
argument_list|(
name|mips_arch_choices
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
name|namelen
condition|)
name|c
operator|=
operator|&
name|mips_arch_choices
index|[
name|i
index|]
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|mips_arch_choice
modifier|*
name|choose_arch_by_number
parameter_list|(
name|unsigned
name|long
name|mach
parameter_list|)
block|{
specifier|static
name|unsigned
name|long
name|hint_bfd_mach
decl_stmt|;
specifier|static
specifier|const
name|struct
name|mips_arch_choice
modifier|*
name|hint_arch_choice
decl_stmt|;
specifier|const
name|struct
name|mips_arch_choice
modifier|*
name|c
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* We optimize this because even if the user specifies no      flags, this will be done for every instruction!  */
if|if
condition|(
name|hint_bfd_mach
operator|==
name|mach
operator|&&
name|hint_arch_choice
operator|!=
name|NULL
operator|&&
name|hint_arch_choice
operator|->
name|bfd_mach
operator|==
name|hint_bfd_mach
condition|)
return|return
name|hint_arch_choice
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|c
operator|=
name|NULL
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|mips_arch_choices
argument_list|)
operator|&&
name|c
operator|==
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mips_arch_choices
index|[
name|i
index|]
operator|.
name|bfd_mach_valid
operator|&&
name|mips_arch_choices
index|[
name|i
index|]
operator|.
name|bfd_mach
operator|==
name|mach
condition|)
block|{
name|c
operator|=
operator|&
name|mips_arch_choices
index|[
name|i
index|]
expr_stmt|;
name|hint_bfd_mach
operator|=
name|mach
expr_stmt|;
name|hint_arch_choice
operator|=
name|c
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Check if the object uses NewABI conventions.  */
end_comment

begin_function
specifier|static
name|int
name|is_newabi
parameter_list|(
name|Elf_Internal_Ehdr
modifier|*
name|header
parameter_list|)
block|{
comment|/* There are no old-style ABIs which use 64-bit ELF.  */
if|if
condition|(
name|header
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|ELFCLASS64
condition|)
return|return
literal|1
return|;
comment|/* If a 32-bit ELF file, n32 is a new-style ABI.  */
if|if
condition|(
operator|(
name|header
operator|->
name|e_flags
operator|&
name|EF_MIPS_ABI2
operator|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_default_mips_dis_options
parameter_list|(
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
specifier|const
name|struct
name|mips_arch_choice
modifier|*
name|chosen_arch
decl_stmt|;
comment|/* Defaults: mipsIII/r3000 (?!), (o)32-style ("oldabi") GPR names,      and numeric FPR, CP0 register, and HWR names.  */
name|mips_isa
operator|=
name|ISA_MIPS3
expr_stmt|;
name|mips_processor
operator|=
name|CPU_R3000
expr_stmt|;
name|mips_gpr_names
operator|=
name|mips_gpr_names_oldabi
expr_stmt|;
name|mips_fpr_names
operator|=
name|mips_fpr_names_numeric
expr_stmt|;
name|mips_cp0_names
operator|=
name|mips_cp0_names_numeric
expr_stmt|;
name|mips_cp0sel_names
operator|=
name|NULL
expr_stmt|;
name|mips_cp0sel_names_len
operator|=
literal|0
expr_stmt|;
name|mips_hwr_names
operator|=
name|mips_hwr_names_numeric
expr_stmt|;
name|no_aliases
operator|=
literal|0
expr_stmt|;
comment|/* If an ELF "newabi" binary, use the n32/(n)64 GPR names.  */
if|if
condition|(
name|info
operator|->
name|flavour
operator|==
name|bfd_target_elf_flavour
operator|&&
name|info
operator|->
name|section
operator|!=
name|NULL
condition|)
block|{
name|Elf_Internal_Ehdr
modifier|*
name|header
decl_stmt|;
name|header
operator|=
name|elf_elfheader
argument_list|(
name|info
operator|->
name|section
operator|->
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_newabi
argument_list|(
name|header
argument_list|)
condition|)
name|mips_gpr_names
operator|=
name|mips_gpr_names_newabi
expr_stmt|;
block|}
comment|/* Set ISA, architecture, and cp0 register names as best we can.  */
if|#
directive|if
operator|!
name|SYMTAB_AVAILABLE
comment|/* This is running out on a target machine, not in a host tool.      FIXME: Where does mips_target_info come from?  */
name|target_processor
operator|=
name|mips_target_info
operator|.
name|processor
expr_stmt|;
name|mips_isa
operator|=
name|mips_target_info
operator|.
name|isa
expr_stmt|;
else|#
directive|else
name|chosen_arch
operator|=
name|choose_arch_by_number
argument_list|(
name|info
operator|->
name|mach
argument_list|)
expr_stmt|;
if|if
condition|(
name|chosen_arch
operator|!=
name|NULL
condition|)
block|{
name|mips_processor
operator|=
name|chosen_arch
operator|->
name|processor
expr_stmt|;
name|mips_isa
operator|=
name|chosen_arch
operator|->
name|isa
expr_stmt|;
name|mips_cp0_names
operator|=
name|chosen_arch
operator|->
name|cp0_names
expr_stmt|;
name|mips_cp0sel_names
operator|=
name|chosen_arch
operator|->
name|cp0sel_names
expr_stmt|;
name|mips_cp0sel_names_len
operator|=
name|chosen_arch
operator|->
name|cp0sel_names_len
expr_stmt|;
name|mips_hwr_names
operator|=
name|chosen_arch
operator|->
name|hwr_names
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|parse_mips_dis_option
parameter_list|(
specifier|const
name|char
modifier|*
name|option
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|optionlen
decl_stmt|,
name|vallen
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
specifier|const
name|struct
name|mips_abi_choice
modifier|*
name|chosen_abi
decl_stmt|;
specifier|const
name|struct
name|mips_arch_choice
modifier|*
name|chosen_arch
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
literal|"octeon-useun"
argument_list|,
name|option
argument_list|)
operator|==
literal|0
condition|)
block|{
name|octeon_use_unalign
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
literal|"no-octeon-useun"
argument_list|,
name|option
argument_list|)
operator|==
literal|0
condition|)
block|{
name|octeon_use_unalign
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Try to match options that are simple flags */
if|if
condition|(
name|CONST_STRNEQ
argument_list|(
name|option
argument_list|,
literal|"no-aliases"
argument_list|)
condition|)
block|{
name|no_aliases
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* Look for the = that delimits the end of the option name.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|option
index|[
name|i
index|]
operator|==
literal|'='
condition|)
break|break;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
comment|/* Invalid option: no name before '='.  */
return|return;
if|if
condition|(
name|i
operator|==
name|len
condition|)
comment|/* Invalid option: no '='.  */
return|return;
if|if
condition|(
name|i
operator|==
operator|(
name|len
operator|-
literal|1
operator|)
condition|)
comment|/* Invalid option: no value after '='.  */
return|return;
name|optionlen
operator|=
name|i
expr_stmt|;
name|val
operator|=
name|option
operator|+
operator|(
name|optionlen
operator|+
literal|1
operator|)
expr_stmt|;
name|vallen
operator|=
name|len
operator|-
operator|(
name|optionlen
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
literal|"gpr-names"
argument_list|,
name|option
argument_list|,
name|optionlen
argument_list|)
operator|==
literal|0
operator|&&
name|strlen
argument_list|(
literal|"gpr-names"
argument_list|)
operator|==
name|optionlen
condition|)
block|{
name|chosen_abi
operator|=
name|choose_abi_by_name
argument_list|(
name|val
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
if|if
condition|(
name|chosen_abi
operator|!=
name|NULL
condition|)
name|mips_gpr_names
operator|=
name|chosen_abi
operator|->
name|gpr_names
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strncmp
argument_list|(
literal|"fpr-names"
argument_list|,
name|option
argument_list|,
name|optionlen
argument_list|)
operator|==
literal|0
operator|&&
name|strlen
argument_list|(
literal|"fpr-names"
argument_list|)
operator|==
name|optionlen
condition|)
block|{
name|chosen_abi
operator|=
name|choose_abi_by_name
argument_list|(
name|val
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
if|if
condition|(
name|chosen_abi
operator|!=
name|NULL
condition|)
name|mips_fpr_names
operator|=
name|chosen_abi
operator|->
name|fpr_names
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strncmp
argument_list|(
literal|"cp0-names"
argument_list|,
name|option
argument_list|,
name|optionlen
argument_list|)
operator|==
literal|0
operator|&&
name|strlen
argument_list|(
literal|"cp0-names"
argument_list|)
operator|==
name|optionlen
condition|)
block|{
name|chosen_arch
operator|=
name|choose_arch_by_name
argument_list|(
name|val
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
if|if
condition|(
name|chosen_arch
operator|!=
name|NULL
condition|)
block|{
name|mips_cp0_names
operator|=
name|chosen_arch
operator|->
name|cp0_names
expr_stmt|;
name|mips_cp0sel_names
operator|=
name|chosen_arch
operator|->
name|cp0sel_names
expr_stmt|;
name|mips_cp0sel_names_len
operator|=
name|chosen_arch
operator|->
name|cp0sel_names_len
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|strncmp
argument_list|(
literal|"hwr-names"
argument_list|,
name|option
argument_list|,
name|optionlen
argument_list|)
operator|==
literal|0
operator|&&
name|strlen
argument_list|(
literal|"hwr-names"
argument_list|)
operator|==
name|optionlen
condition|)
block|{
name|chosen_arch
operator|=
name|choose_arch_by_name
argument_list|(
name|val
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
if|if
condition|(
name|chosen_arch
operator|!=
name|NULL
condition|)
name|mips_hwr_names
operator|=
name|chosen_arch
operator|->
name|hwr_names
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strncmp
argument_list|(
literal|"reg-names"
argument_list|,
name|option
argument_list|,
name|optionlen
argument_list|)
operator|==
literal|0
operator|&&
name|strlen
argument_list|(
literal|"reg-names"
argument_list|)
operator|==
name|optionlen
condition|)
block|{
comment|/* We check both ABI and ARCH here unconditionally, so 	 that "numeric" will do the desirable thing: select 	 numeric register names for all registers.  Other than 	 that, a given name probably won't match both.  */
name|chosen_abi
operator|=
name|choose_abi_by_name
argument_list|(
name|val
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
if|if
condition|(
name|chosen_abi
operator|!=
name|NULL
condition|)
block|{
name|mips_gpr_names
operator|=
name|chosen_abi
operator|->
name|gpr_names
expr_stmt|;
name|mips_fpr_names
operator|=
name|chosen_abi
operator|->
name|fpr_names
expr_stmt|;
block|}
name|chosen_arch
operator|=
name|choose_arch_by_name
argument_list|(
name|val
argument_list|,
name|vallen
argument_list|)
expr_stmt|;
if|if
condition|(
name|chosen_arch
operator|!=
name|NULL
condition|)
block|{
name|mips_cp0_names
operator|=
name|chosen_arch
operator|->
name|cp0_names
expr_stmt|;
name|mips_cp0sel_names
operator|=
name|chosen_arch
operator|->
name|cp0sel_names
expr_stmt|;
name|mips_cp0sel_names_len
operator|=
name|chosen_arch
operator|->
name|cp0sel_names_len
expr_stmt|;
name|mips_hwr_names
operator|=
name|chosen_arch
operator|->
name|hwr_names
expr_stmt|;
block|}
return|return;
block|}
comment|/* Invalid option.  */
block|}
end_function

begin_function
specifier|static
name|void
name|parse_mips_dis_options
parameter_list|(
specifier|const
name|char
modifier|*
name|options
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|option_end
decl_stmt|;
if|if
condition|(
name|options
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
operator|*
name|options
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Skip empty options.  */
if|if
condition|(
operator|*
name|options
operator|==
literal|','
condition|)
block|{
name|options
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* We know that *options is neither NUL or a comma.  */
name|option_end
operator|=
name|options
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|option_end
operator|!=
literal|','
operator|&&
operator|*
name|option_end
operator|!=
literal|'\0'
condition|)
name|option_end
operator|++
expr_stmt|;
name|parse_mips_dis_option
argument_list|(
name|options
argument_list|,
name|option_end
operator|-
name|options
argument_list|)
expr_stmt|;
comment|/* Go on to the next one.  If option_end points to a comma, it 	 will be skipped above.  */
name|options
operator|=
name|option_end
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|mips_cp0sel_name
modifier|*
name|lookup_mips_cp0sel_name
parameter_list|(
specifier|const
name|struct
name|mips_cp0sel_name
modifier|*
name|names
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|,
name|unsigned
name|int
name|cp0reg
parameter_list|,
name|unsigned
name|int
name|sel
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|names
index|[
name|i
index|]
operator|.
name|cp0reg
operator|==
name|cp0reg
operator|&&
name|names
index|[
name|i
index|]
operator|.
name|sel
operator|==
name|sel
condition|)
return|return
operator|&
name|names
index|[
name|i
index|]
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print insn arguments for 32/64-bit code.  */
end_comment

begin_function
specifier|static
name|void
name|print_insn_args
parameter_list|(
specifier|const
name|char
modifier|*
name|d
parameter_list|,
specifier|register
name|unsigned
name|long
name|int
name|l
parameter_list|,
name|bfd_vma
name|pc
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|,
specifier|const
name|struct
name|mips_opcode
modifier|*
name|opp
parameter_list|)
block|{
name|int
name|op
decl_stmt|,
name|delta
decl_stmt|;
name|unsigned
name|int
name|lsb
decl_stmt|,
name|msb
decl_stmt|,
name|msbd
decl_stmt|;
name|lsb
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|d
operator|!=
literal|'\0'
condition|;
name|d
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|d
condition|)
block|{
case|case
literal|','
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'['
case|:
case|case
literal|']'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
comment|/* Extension character; switch for second char.  */
name|d
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|d
condition|)
block|{
case|case
literal|'\0'
case|:
comment|/* xgettext:c-format */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
name|_
argument_list|(
literal|"# internal error, incomplete extension sequence (+)"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'A'
case|:
name|lsb
operator|=
operator|(
name|l
operator|>>
name|OP_SH_SHAMT
operator|)
operator|&
name|OP_MASK_SHAMT
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|msb
operator|=
operator|(
name|l
operator|>>
name|OP_SH_INSMSB
operator|)
operator|&
name|OP_MASK_INSMSB
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
name|msb
operator|-
name|lsb
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_UDI1
operator|)
operator|&
name|OP_MASK_UDI1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_UDI2
operator|)
operator|&
name|OP_MASK_UDI2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_UDI3
operator|)
operator|&
name|OP_MASK_UDI3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_UDI4
operator|)
operator|&
name|OP_MASK_UDI4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
case|case
literal|'H'
case|:
name|msbd
operator|=
operator|(
name|l
operator|>>
name|OP_SH_EXTMSBD
operator|)
operator|&
name|OP_MASK_EXTMSBD
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
name|msbd
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
block|{
specifier|const
name|struct
name|mips_cp0sel_name
modifier|*
name|n
decl_stmt|;
name|unsigned
name|int
name|cp0reg
decl_stmt|,
name|sel
decl_stmt|;
name|cp0reg
operator|=
operator|(
name|l
operator|>>
name|OP_SH_RD
operator|)
operator|&
name|OP_MASK_RD
expr_stmt|;
name|sel
operator|=
operator|(
name|l
operator|>>
name|OP_SH_SEL
operator|)
operator|&
name|OP_MASK_SEL
expr_stmt|;
comment|/* CP0 register including 'sel' code for mtcN (et al.), to be 		   printed textually if known.  If not known, print both 		   CP0 register name and sel numerically since CP0 register 		   with sel 0 may have a name unrelated to register being 		   printed.  */
name|n
operator|=
name|lookup_mips_cp0sel_name
argument_list|(
name|mips_cp0sel_names
argument_list|,
name|mips_cp0sel_names_len
argument_list|,
name|cp0reg
argument_list|,
name|sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|n
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"$%d,%d"
argument_list|,
name|cp0reg
argument_list|,
name|sel
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'E'
case|:
name|lsb
operator|=
operator|(
operator|(
name|l
operator|>>
name|OP_SH_SHAMT
operator|)
operator|&
name|OP_MASK_SHAMT
operator|)
operator|+
literal|32
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
name|lsb
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|msb
operator|=
operator|(
operator|(
name|l
operator|>>
name|OP_SH_INSMSB
operator|)
operator|&
name|OP_MASK_INSMSB
operator|)
operator|+
literal|32
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
name|msb
operator|-
name|lsb
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|msbd
operator|=
operator|(
operator|(
name|l
operator|>>
name|OP_SH_EXTMSBD
operator|)
operator|&
name|OP_MASK_EXTMSBD
operator|)
operator|+
literal|32
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
name|msbd
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* Coprocessor 0 reg name */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|mips_cp0_names
index|[
operator|(
name|l
operator|>>
name|OP_SH_RT
operator|)
operator|&
name|OP_MASK_RT
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* Coprocessor 0 reg name */
block|{
specifier|const
name|struct
name|mips_cp0sel_name
modifier|*
name|n
decl_stmt|;
name|unsigned
name|int
name|cp0reg
decl_stmt|,
name|sel
decl_stmt|;
name|cp0reg
operator|=
operator|(
name|l
operator|>>
name|OP_SH_RT
operator|)
operator|&
name|OP_MASK_RT
expr_stmt|;
name|sel
operator|=
operator|(
name|l
operator|>>
name|OP_SH_SEL
operator|)
operator|&
name|OP_MASK_SEL
expr_stmt|;
comment|/* CP0 register including 'sel' code for mftc0, to be 		   printed textually if known.  If not known, print both 		   CP0 register name and sel numerically since CP0 register 		   with sel 0 may have a name unrelated to register being 		   printed.  */
name|n
operator|=
name|lookup_mips_cp0sel_name
argument_list|(
name|mips_cp0sel_names
argument_list|,
name|mips_cp0sel_names_len
argument_list|,
name|cp0reg
argument_list|,
name|sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|n
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"$%d,%d"
argument_list|,
name|cp0reg
argument_list|,
name|sel
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
comment|/* xgettext:c-format */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
name|_
argument_list|(
literal|"# internal error, undefined extension sequence (+%c)"
argument_list|)
argument_list|,
operator|*
name|d
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
literal|'2'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_BP
operator|)
operator|&
name|OP_MASK_BP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_SA3
operator|)
operator|&
name|OP_MASK_SA3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_SA4
operator|)
operator|&
name|OP_MASK_SA4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'5'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_IMM8
operator|)
operator|&
name|OP_MASK_IMM8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_RS
operator|)
operator|&
name|OP_MASK_RS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'7'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"$ac%ld"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_DSPACC
operator|)
operator|&
name|OP_MASK_DSPACC
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'8'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_WRDSP
operator|)
operator|&
name|OP_MASK_WRDSP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'9'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"$ac%ld"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_DSPACC_S
operator|)
operator|&
name|OP_MASK_DSPACC_S
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
comment|/* dsp 6-bit signed immediate in bit 20 */
name|delta
operator|=
operator|(
operator|(
name|l
operator|>>
name|OP_SH_DSPSFT
operator|)
operator|&
name|OP_MASK_DSPSFT
operator|)
expr_stmt|;
if|if
condition|(
name|delta
operator|&
literal|0x20
condition|)
comment|/* test sign bit */
name|delta
operator||=
operator|~
name|OP_MASK_DSPSFT
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|delta
argument_list|)
expr_stmt|;
break|break;
case|case
literal|':'
case|:
comment|/* dsp 7-bit signed immediate in bit 19 */
name|delta
operator|=
operator|(
operator|(
name|l
operator|>>
name|OP_SH_DSPSFT_7
operator|)
operator|&
name|OP_MASK_DSPSFT_7
operator|)
expr_stmt|;
if|if
condition|(
name|delta
operator|&
literal|0x40
condition|)
comment|/* test sign bit */
name|delta
operator||=
operator|~
name|OP_MASK_DSPSFT_7
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|delta
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_RDDSP
operator|)
operator|&
name|OP_MASK_RDDSP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
comment|/* dsp 10-bit signed immediate in bit 16 */
name|delta
operator|=
operator|(
operator|(
name|l
operator|>>
name|OP_SH_IMM10
operator|)
operator|&
name|OP_MASK_IMM10
operator|)
expr_stmt|;
if|if
condition|(
name|delta
operator|&
literal|0x200
condition|)
comment|/* test sign bit */
name|delta
operator||=
operator|~
name|OP_MASK_IMM10
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|delta
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_MT_U
operator|)
operator|&
name|OP_MASK_MT_U
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_MT_H
operator|)
operator|&
name|OP_MASK_MT_H
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"$ac%ld"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_MTACC_T
operator|)
operator|&
name|OP_MASK_MTACC_T
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"$ac%ld"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_MTACC_D
operator|)
operator|&
name|OP_MASK_MTACC_D
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* Coprocessor register for CTTC1, MTTC2, MTHC2, CTTC2.  */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"$%ld"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_RD
operator|)
operator|&
name|OP_MASK_RD
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'b'
case|:
case|case
literal|'r'
case|:
case|case
literal|'v'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|mips_gpr_names
index|[
operator|(
name|l
operator|>>
name|OP_SH_RS
operator|)
operator|&
name|OP_MASK_RS
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
case|case
literal|'w'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|mips_gpr_names
index|[
operator|(
name|l
operator|>>
name|OP_SH_RT
operator|)
operator|&
name|OP_MASK_RT
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'u'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_IMMEDIATE
operator|)
operator|&
name|OP_MASK_IMMEDIATE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
comment|/* Same as i, but sign-extended.  */
case|case
literal|'o'
case|:
name|delta
operator|=
operator|(
name|l
operator|>>
name|OP_SH_DELTA
operator|)
operator|&
name|OP_MASK_DELTA
expr_stmt|;
if|if
condition|(
name|delta
operator|&
literal|0x8000
condition|)
name|delta
operator||=
operator|~
literal|0xffff
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|delta
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
name|l
operator|>>
name|OP_SH_PREFX
operator|)
operator|&
name|OP_MASK_PREFX
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
name|l
operator|>>
name|OP_SH_CACHE
operator|)
operator|&
name|OP_MASK_CACHE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|info
operator|->
name|target
operator|=
operator|(
operator|(
operator|(
name|pc
operator|+
literal|4
operator|)
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x0fffffff
operator|)
operator||
operator|(
operator|(
operator|(
name|l
operator|>>
name|OP_SH_TARGET
operator|)
operator|&
name|OP_MASK_TARGET
operator|)
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
comment|/* For gdb disassembler, force odd address on jalx.  */
if|if
condition|(
name|info
operator|->
name|flavour
operator|==
name|bfd_target_unknown_flavour
operator|&&
name|strcmp
argument_list|(
name|opp
operator|->
name|name
argument_list|,
literal|"jalx"
argument_list|)
operator|==
literal|0
condition|)
name|info
operator|->
name|target
operator||=
literal|1
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|info
operator|->
name|target
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* Sign extend the displacement.  */
name|delta
operator|=
operator|(
name|l
operator|>>
name|OP_SH_DELTA
operator|)
operator|&
name|OP_MASK_DELTA
expr_stmt|;
if|if
condition|(
name|delta
operator|&
literal|0x8000
condition|)
name|delta
operator||=
operator|~
literal|0xffff
expr_stmt|;
name|info
operator|->
name|target
operator|=
operator|(
name|delta
operator|<<
literal|2
operator|)
operator|+
name|pc
operator|+
name|INSNLEN
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|info
operator|->
name|target
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|mips_gpr_names
index|[
operator|(
name|l
operator|>>
name|OP_SH_RD
operator|)
operator|&
name|OP_MASK_RD
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
block|{
comment|/* First check for both rd and rt being equal.  */
name|unsigned
name|int
name|reg
init|=
operator|(
name|l
operator|>>
name|OP_SH_RD
operator|)
operator|&
name|OP_MASK_RD
decl_stmt|;
if|if
condition|(
name|reg
operator|==
operator|(
operator|(
name|l
operator|>>
name|OP_SH_RT
operator|)
operator|&
name|OP_MASK_RT
operator|)
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|mips_gpr_names
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If one is zero use the other.  */
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|mips_gpr_names
index|[
operator|(
name|l
operator|>>
name|OP_SH_RT
operator|)
operator|&
name|OP_MASK_RT
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|l
operator|>>
name|OP_SH_RT
operator|)
operator|&
name|OP_MASK_RT
operator|)
operator|==
literal|0
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|mips_gpr_names
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
else|else
comment|/* Bogus, result depends on processor.  */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s or %s"
argument_list|,
name|mips_gpr_names
index|[
name|reg
index|]
argument_list|,
name|mips_gpr_names
index|[
operator|(
name|l
operator|>>
name|OP_SH_RT
operator|)
operator|&
name|OP_MASK_RT
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'z'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|mips_gpr_names
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_SHAMT
operator|)
operator|&
name|OP_MASK_SHAMT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_CODE
operator|)
operator|&
name|OP_MASK_CODE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_CODE2
operator|)
operator|&
name|OP_MASK_CODE2
argument_list|)
expr_stmt|;
break|break;
comment|/* Display 5 bits of bbit0/1 bit index amount. */
case|case
literal|'^'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_BITIND
operator|)
operator|&
name|OP_MASK_BITIND
argument_list|)
expr_stmt|;
break|break;
comment|/* Display 10 bits signed constant from seqi/snei instruction. */
case|case
literal|'y'
case|:
block|{
name|int
name|imm
init|=
operator|(
name|l
operator|>>
name|OP_SH_CODE2
operator|)
operator|&
name|OP_MASK_CODE2
decl_stmt|;
name|imm
operator|<<=
literal|22
expr_stmt|;
name|imm
operator|>>=
literal|22
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|imm
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_COPZ
operator|)
operator|&
name|OP_MASK_COPZ
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_CODE20
operator|)
operator|&
name|OP_MASK_CODE20
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_CODE19
operator|)
operator|&
name|OP_MASK_CODE19
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
case|case
literal|'V'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|mips_fpr_names
index|[
operator|(
name|l
operator|>>
name|OP_SH_FS
operator|)
operator|&
name|OP_MASK_FS
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
case|case
literal|'W'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|mips_fpr_names
index|[
operator|(
name|l
operator|>>
name|OP_SH_FT
operator|)
operator|&
name|OP_MASK_FT
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|mips_fpr_names
index|[
operator|(
name|l
operator|>>
name|OP_SH_FD
operator|)
operator|&
name|OP_MASK_FD
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|mips_fpr_names
index|[
operator|(
name|l
operator|>>
name|OP_SH_FR
operator|)
operator|&
name|OP_MASK_FR
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* Coprocessor register for lwcN instructions, et al.  	     Note that there is no load/store cp0 instructions, and 	     that FPU (cp1) instructions disassemble this field using 	     'T' format.  Therefore, until we gain understanding of 	     cp2 register names, we can simply print the register 	     numbers.  */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"$%ld"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_RT
operator|)
operator|&
name|OP_MASK_RT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
comment|/* Coprocessor register for mtcN instructions, et al.  Note 	     that FPU (cp1) instructions disassemble this field using 	     'S' format.  Therefore, we only need to worry about cp0, 	     cp2, and cp3.  */
name|op
operator|=
operator|(
name|l
operator|>>
name|OP_SH_OP
operator|)
operator|&
name|OP_MASK_OP
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|OP_OP_COP0
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|mips_cp0_names
index|[
operator|(
name|l
operator|>>
name|OP_SH_RD
operator|)
operator|&
name|OP_MASK_RD
index|]
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"$%ld"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_RD
operator|)
operator|&
name|OP_MASK_RD
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|mips_hwr_names
index|[
operator|(
name|l
operator|>>
name|OP_SH_RD
operator|)
operator|&
name|OP_MASK_RD
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
operator|(
operator|(
name|opp
operator|->
name|pinfo
operator|&
operator|(
name|FP_D
operator||
name|FP_S
operator|)
operator|)
operator|!=
literal|0
condition|?
literal|"$fcc%ld"
else|:
literal|"$cc%ld"
operator|)
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_BCC
operator|)
operator|&
name|OP_MASK_BCC
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"$fcc%ld"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_CCC
operator|)
operator|&
name|OP_MASK_CCC
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_PERFREG
operator|)
operator|&
name|OP_MASK_PERFREG
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_VECBYTE
operator|)
operator|&
name|OP_MASK_VECBYTE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_VECALIGN
operator|)
operator|&
name|OP_MASK_VECALIGN
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_SEL
operator|)
operator|&
name|OP_MASK_SEL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_ALN
operator|)
operator|&
name|OP_MASK_ALN
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
block|{
name|unsigned
name|int
name|vsel
init|=
operator|(
name|l
operator|>>
name|OP_SH_VSEL
operator|)
operator|&
name|OP_MASK_VSEL
decl_stmt|;
if|if
condition|(
operator|(
name|vsel
operator|&
literal|0x10
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|fmt
decl_stmt|;
name|vsel
operator|&=
literal|0x0f
expr_stmt|;
for|for
control|(
name|fmt
operator|=
literal|0
init|;
name|fmt
operator|<
literal|3
condition|;
name|fmt
operator|++
operator|,
name|vsel
operator|>>=
literal|1
control|)
if|if
condition|(
operator|(
name|vsel
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
break|break;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"$v%ld[%d]"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_FT
operator|)
operator|&
name|OP_MASK_FT
argument_list|,
name|vsel
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|vsel
operator|&
literal|0x08
operator|)
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"$v%ld"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_FT
operator|)
operator|&
name|OP_MASK_FT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_FT
operator|)
operator|&
name|OP_MASK_FT
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'X'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"$v%ld"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_FD
operator|)
operator|&
name|OP_MASK_FD
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"$v%ld"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_FS
operator|)
operator|&
name|OP_MASK_FS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"$v%ld"
argument_list|,
operator|(
name|l
operator|>>
name|OP_SH_FT
operator|)
operator|&
name|OP_MASK_FT
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* xgettext:c-format */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
name|_
argument_list|(
literal|"# internal error, undefined modifier(%c)"
argument_list|)
argument_list|,
operator|*
name|d
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the mips instruction at address MEMADDR in debugged memory,    on using INFO.  Returns length of the instruction, in bytes, which is    always INSNLEN.  BIGENDIAN must be 1 if this is big-endian code, 0 if    this is little-endian code.  */
end_comment

begin_function
specifier|static
name|int
name|print_insn_mips
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|unsigned
name|long
name|int
name|word
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
specifier|const
name|struct
name|mips_opcode
modifier|*
name|op
decl_stmt|;
specifier|static
name|bfd_boolean
name|init
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|struct
name|mips_opcode
modifier|*
name|mips_hash
index|[
name|OP_MASK_OP
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Build a hash table to shorten the search time.  */
if|if
condition|(
operator|!
name|init
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|OP_MASK_OP
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|op
operator|=
name|mips_opcodes
init|;
name|op
operator|<
operator|&
name|mips_opcodes
index|[
name|NUMOPCODES
index|]
condition|;
name|op
operator|++
control|)
block|{
if|if
condition|(
name|op
operator|->
name|pinfo
operator|==
name|INSN_MACRO
operator|||
operator|(
name|no_aliases
operator|&&
operator|(
name|op
operator|->
name|pinfo2
operator|&
name|INSN2_ALIAS
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|i
operator|==
operator|(
operator|(
name|op
operator|->
name|match
operator|>>
name|OP_SH_OP
operator|)
operator|&
name|OP_MASK_OP
operator|)
condition|)
block|{
name|mips_hash
index|[
name|i
index|]
operator|=
name|op
expr_stmt|;
break|break;
block|}
block|}
block|}
name|init
operator|=
literal|1
expr_stmt|;
block|}
name|info
operator|->
name|bytes_per_chunk
operator|=
name|INSNLEN
expr_stmt|;
name|info
operator|->
name|display_endian
operator|=
name|info
operator|->
name|endian
expr_stmt|;
name|info
operator|->
name|insn_info_valid
operator|=
literal|1
expr_stmt|;
name|info
operator|->
name|branch_delay_insns
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|data_size
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|insn_type
operator|=
name|dis_nonbranch
expr_stmt|;
name|info
operator|->
name|target
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|target2
operator|=
literal|0
expr_stmt|;
name|op
operator|=
name|mips_hash
index|[
operator|(
name|word
operator|>>
name|OP_SH_OP
operator|)
operator|&
name|OP_MASK_OP
index|]
expr_stmt|;
if|if
condition|(
name|op
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
name|op
operator|<
operator|&
name|mips_opcodes
index|[
name|NUMOPCODES
index|]
condition|;
name|op
operator|++
control|)
block|{
if|if
condition|(
name|op
operator|->
name|pinfo
operator|!=
name|INSN_MACRO
operator|&&
operator|!
operator|(
name|no_aliases
operator|&&
operator|(
name|op
operator|->
name|pinfo2
operator|&
name|INSN2_ALIAS
operator|)
operator|)
operator|&&
operator|(
name|word
operator|&
name|op
operator|->
name|mask
operator|)
operator|==
name|op
operator|->
name|match
condition|)
block|{
specifier|const
name|char
modifier|*
name|d
decl_stmt|;
comment|/* We always allow to disassemble the jalx instruction.  */
if|if
condition|(
operator|!
name|OPCODE_IS_MEMBER
argument_list|(
name|op
argument_list|,
name|mips_isa
argument_list|,
name|mips_processor
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|op
operator|->
name|name
argument_list|,
literal|"jalx"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|info
operator|->
name|mach
operator|==
name|CPU_OCTEON
operator|&&
name|octeon_use_unalign
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|op
operator|->
name|name
argument_list|,
literal|"lwl"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|op
operator|->
name|name
argument_list|,
literal|"ldl"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|op
operator|->
name|name
argument_list|,
literal|"swl"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|op
operator|->
name|name
argument_list|,
literal|"sdl"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|op
operator|->
name|name
argument_list|,
literal|"lcache"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|op
operator|->
name|name
argument_list|,
literal|"scache"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|op
operator|->
name|name
argument_list|,
literal|"flush"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|op
operator|->
name|name
argument_list|,
literal|"ldr"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|op
operator|->
name|name
argument_list|,
literal|"lwr"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|op
operator|->
name|name
argument_list|,
literal|"swr"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|op
operator|->
name|name
argument_list|,
literal|"sdr"
argument_list|)
operator|==
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"nop"
argument_list|)
expr_stmt|;
return|return
name|INSNLEN
return|;
block|}
block|}
comment|/* Figure out instruction type and branch delay information.  */
if|if
condition|(
operator|(
name|op
operator|->
name|pinfo
operator|&
name|INSN_UNCOND_BRANCH_DELAY
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|info
operator|->
name|insn_type
operator|&
name|INSN_WRITE_GPR_31
operator|)
operator|!=
literal|0
condition|)
name|info
operator|->
name|insn_type
operator|=
name|dis_jsr
expr_stmt|;
else|else
name|info
operator|->
name|insn_type
operator|=
name|dis_branch
expr_stmt|;
name|info
operator|->
name|branch_delay_insns
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|op
operator|->
name|pinfo
operator|&
operator|(
name|INSN_COND_BRANCH_DELAY
operator||
name|INSN_COND_BRANCH_LIKELY
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|info
operator|->
name|insn_type
operator|&
name|INSN_WRITE_GPR_31
operator|)
operator|!=
literal|0
condition|)
name|info
operator|->
name|insn_type
operator|=
name|dis_condjsr
expr_stmt|;
else|else
name|info
operator|->
name|insn_type
operator|=
name|dis_condbranch
expr_stmt|;
name|info
operator|->
name|branch_delay_insns
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|op
operator|->
name|pinfo
operator|&
operator|(
name|INSN_STORE_MEMORY
operator||
name|INSN_LOAD_MEMORY_DELAY
operator|)
operator|)
operator|!=
literal|0
condition|)
name|info
operator|->
name|insn_type
operator|=
name|dis_dref
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|op
operator|->
name|name
argument_list|)
expr_stmt|;
name|d
operator|=
name|op
operator|->
name|args
expr_stmt|;
if|if
condition|(
name|d
operator|!=
name|NULL
operator|&&
operator|*
name|d
operator|!=
literal|'\0'
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
name|print_insn_args
argument_list|(
name|d
argument_list|,
name|word
argument_list|,
name|memaddr
argument_list|,
name|info
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
return|return
name|INSNLEN
return|;
block|}
block|}
block|}
comment|/* Handle undefined instructions.  */
name|info
operator|->
name|insn_type
operator|=
name|dis_noninsn
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
name|word
argument_list|)
expr_stmt|;
return|return
name|INSNLEN
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Disassemble an operand for a mips16 instruction.  */
end_comment

begin_function
specifier|static
name|void
name|print_mips16_insn_arg
parameter_list|(
name|char
name|type
parameter_list|,
specifier|const
name|struct
name|mips_opcode
modifier|*
name|op
parameter_list|,
name|int
name|l
parameter_list|,
name|bfd_boolean
name|use_extend
parameter_list|,
name|int
name|extend
parameter_list|,
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|','
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%c"
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
case|case
literal|'w'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|mips16_reg_names
argument_list|(
operator|(
operator|(
name|l
operator|>>
name|MIPS16OP_SH_RY
operator|)
operator|&
name|MIPS16OP_MASK_RY
operator|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'v'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|mips16_reg_names
argument_list|(
operator|(
operator|(
name|l
operator|>>
name|MIPS16OP_SH_RX
operator|)
operator|&
name|MIPS16OP_MASK_RX
operator|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|mips16_reg_names
argument_list|(
operator|(
operator|(
name|l
operator|>>
name|MIPS16OP_SH_RZ
operator|)
operator|&
name|MIPS16OP_MASK_RZ
operator|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|mips16_reg_names
argument_list|(
operator|(
operator|(
name|l
operator|>>
name|MIPS16OP_SH_MOVE32Z
operator|)
operator|&
name|MIPS16OP_MASK_MOVE32Z
operator|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|mips_gpr_names
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|mips_gpr_names
index|[
literal|29
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"$pc"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|mips_gpr_names
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|mips_gpr_names
index|[
operator|(
operator|(
name|l
operator|>>
name|MIPS16OP_SH_REGR32
operator|)
operator|&
name|MIPS16OP_MASK_REGR32
operator|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|mips_gpr_names
index|[
name|MIPS16OP_EXTRACT_REG32R
argument_list|(
name|l
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'['
case|:
case|case
literal|']'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'H'
case|:
case|case
literal|'W'
case|:
case|case
literal|'D'
case|:
case|case
literal|'j'
case|:
case|case
literal|'6'
case|:
case|case
literal|'8'
case|:
case|case
literal|'V'
case|:
case|case
literal|'C'
case|:
case|case
literal|'U'
case|:
case|case
literal|'k'
case|:
case|case
literal|'K'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'E'
case|:
block|{
name|int
name|immed
decl_stmt|,
name|nbits
decl_stmt|,
name|shift
decl_stmt|,
name|signedp
decl_stmt|,
name|extbits
decl_stmt|,
name|pcrel
decl_stmt|,
name|extu
decl_stmt|,
name|branch
decl_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
name|signedp
operator|=
literal|0
expr_stmt|;
name|extbits
operator|=
literal|16
expr_stmt|;
name|pcrel
operator|=
literal|0
expr_stmt|;
name|extu
operator|=
literal|0
expr_stmt|;
name|branch
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'<'
case|:
name|nbits
operator|=
literal|3
expr_stmt|;
name|immed
operator|=
operator|(
name|l
operator|>>
name|MIPS16OP_SH_RZ
operator|)
operator|&
name|MIPS16OP_MASK_RZ
expr_stmt|;
name|extbits
operator|=
literal|5
expr_stmt|;
name|extu
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|nbits
operator|=
literal|3
expr_stmt|;
name|immed
operator|=
operator|(
name|l
operator|>>
name|MIPS16OP_SH_RX
operator|)
operator|&
name|MIPS16OP_MASK_RX
expr_stmt|;
name|extbits
operator|=
literal|5
expr_stmt|;
name|extu
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|nbits
operator|=
literal|3
expr_stmt|;
name|immed
operator|=
operator|(
name|l
operator|>>
name|MIPS16OP_SH_RZ
operator|)
operator|&
name|MIPS16OP_MASK_RZ
expr_stmt|;
name|extbits
operator|=
literal|6
expr_stmt|;
name|extu
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|']'
case|:
name|nbits
operator|=
literal|3
expr_stmt|;
name|immed
operator|=
operator|(
name|l
operator|>>
name|MIPS16OP_SH_RX
operator|)
operator|&
name|MIPS16OP_MASK_RX
expr_stmt|;
name|extbits
operator|=
literal|6
expr_stmt|;
name|extu
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
name|nbits
operator|=
literal|4
expr_stmt|;
name|immed
operator|=
operator|(
name|l
operator|>>
name|MIPS16OP_SH_IMM4
operator|)
operator|&
name|MIPS16OP_MASK_IMM4
expr_stmt|;
name|signedp
operator|=
literal|1
expr_stmt|;
name|extbits
operator|=
literal|15
expr_stmt|;
break|break;
case|case
literal|'5'
case|:
name|nbits
operator|=
literal|5
expr_stmt|;
name|immed
operator|=
operator|(
name|l
operator|>>
name|MIPS16OP_SH_IMM5
operator|)
operator|&
name|MIPS16OP_MASK_IMM5
expr_stmt|;
name|info
operator|->
name|insn_type
operator|=
name|dis_dref
expr_stmt|;
name|info
operator|->
name|data_size
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|nbits
operator|=
literal|5
expr_stmt|;
name|shift
operator|=
literal|1
expr_stmt|;
name|immed
operator|=
operator|(
name|l
operator|>>
name|MIPS16OP_SH_IMM5
operator|)
operator|&
name|MIPS16OP_MASK_IMM5
expr_stmt|;
name|info
operator|->
name|insn_type
operator|=
name|dis_dref
expr_stmt|;
name|info
operator|->
name|data_size
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|nbits
operator|=
literal|5
expr_stmt|;
name|shift
operator|=
literal|2
expr_stmt|;
name|immed
operator|=
operator|(
name|l
operator|>>
name|MIPS16OP_SH_IMM5
operator|)
operator|&
name|MIPS16OP_MASK_IMM5
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|->
name|pinfo
operator|&
name|MIPS16_INSN_READ_PC
operator|)
operator|==
literal|0
operator|&&
operator|(
name|op
operator|->
name|pinfo
operator|&
name|MIPS16_INSN_READ_SP
operator|)
operator|==
literal|0
condition|)
block|{
name|info
operator|->
name|insn_type
operator|=
name|dis_dref
expr_stmt|;
name|info
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
block|}
break|break;
case|case
literal|'D'
case|:
name|nbits
operator|=
literal|5
expr_stmt|;
name|shift
operator|=
literal|3
expr_stmt|;
name|immed
operator|=
operator|(
name|l
operator|>>
name|MIPS16OP_SH_IMM5
operator|)
operator|&
name|MIPS16OP_MASK_IMM5
expr_stmt|;
name|info
operator|->
name|insn_type
operator|=
name|dis_dref
expr_stmt|;
name|info
operator|->
name|data_size
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|nbits
operator|=
literal|5
expr_stmt|;
name|immed
operator|=
operator|(
name|l
operator|>>
name|MIPS16OP_SH_IMM5
operator|)
operator|&
name|MIPS16OP_MASK_IMM5
expr_stmt|;
name|signedp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
name|nbits
operator|=
literal|6
expr_stmt|;
name|immed
operator|=
operator|(
name|l
operator|>>
name|MIPS16OP_SH_IMM6
operator|)
operator|&
name|MIPS16OP_MASK_IMM6
expr_stmt|;
break|break;
case|case
literal|'8'
case|:
name|nbits
operator|=
literal|8
expr_stmt|;
name|immed
operator|=
operator|(
name|l
operator|>>
name|MIPS16OP_SH_IMM8
operator|)
operator|&
name|MIPS16OP_MASK_IMM8
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|nbits
operator|=
literal|8
expr_stmt|;
name|shift
operator|=
literal|2
expr_stmt|;
name|immed
operator|=
operator|(
name|l
operator|>>
name|MIPS16OP_SH_IMM8
operator|)
operator|&
name|MIPS16OP_MASK_IMM8
expr_stmt|;
comment|/* FIXME: This might be lw, or it might be addiu to $sp or                $pc.  We assume it's load.  */
name|info
operator|->
name|insn_type
operator|=
name|dis_dref
expr_stmt|;
name|info
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|nbits
operator|=
literal|8
expr_stmt|;
name|shift
operator|=
literal|3
expr_stmt|;
name|immed
operator|=
operator|(
name|l
operator|>>
name|MIPS16OP_SH_IMM8
operator|)
operator|&
name|MIPS16OP_MASK_IMM8
expr_stmt|;
name|info
operator|->
name|insn_type
operator|=
name|dis_dref
expr_stmt|;
name|info
operator|->
name|data_size
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|nbits
operator|=
literal|8
expr_stmt|;
name|immed
operator|=
operator|(
name|l
operator|>>
name|MIPS16OP_SH_IMM8
operator|)
operator|&
name|MIPS16OP_MASK_IMM8
expr_stmt|;
name|extu
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|nbits
operator|=
literal|8
expr_stmt|;
name|immed
operator|=
operator|(
name|l
operator|>>
name|MIPS16OP_SH_IMM8
operator|)
operator|&
name|MIPS16OP_MASK_IMM8
expr_stmt|;
name|signedp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|nbits
operator|=
literal|8
expr_stmt|;
name|shift
operator|=
literal|3
expr_stmt|;
name|immed
operator|=
operator|(
name|l
operator|>>
name|MIPS16OP_SH_IMM8
operator|)
operator|&
name|MIPS16OP_MASK_IMM8
expr_stmt|;
name|signedp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|nbits
operator|=
literal|8
expr_stmt|;
name|immed
operator|=
operator|(
name|l
operator|>>
name|MIPS16OP_SH_IMM8
operator|)
operator|&
name|MIPS16OP_MASK_IMM8
expr_stmt|;
name|signedp
operator|=
literal|1
expr_stmt|;
name|pcrel
operator|=
literal|1
expr_stmt|;
name|branch
operator|=
literal|1
expr_stmt|;
name|info
operator|->
name|insn_type
operator|=
name|dis_condbranch
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|nbits
operator|=
literal|11
expr_stmt|;
name|immed
operator|=
operator|(
name|l
operator|>>
name|MIPS16OP_SH_IMM11
operator|)
operator|&
name|MIPS16OP_MASK_IMM11
expr_stmt|;
name|signedp
operator|=
literal|1
expr_stmt|;
name|pcrel
operator|=
literal|1
expr_stmt|;
name|branch
operator|=
literal|1
expr_stmt|;
name|info
operator|->
name|insn_type
operator|=
name|dis_branch
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|nbits
operator|=
literal|8
expr_stmt|;
name|shift
operator|=
literal|2
expr_stmt|;
name|immed
operator|=
operator|(
name|l
operator|>>
name|MIPS16OP_SH_IMM8
operator|)
operator|&
name|MIPS16OP_MASK_IMM8
expr_stmt|;
name|pcrel
operator|=
literal|1
expr_stmt|;
comment|/* FIXME: This can be lw or la.  We assume it is lw.  */
name|info
operator|->
name|insn_type
operator|=
name|dis_dref
expr_stmt|;
name|info
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|nbits
operator|=
literal|5
expr_stmt|;
name|shift
operator|=
literal|3
expr_stmt|;
name|immed
operator|=
operator|(
name|l
operator|>>
name|MIPS16OP_SH_IMM5
operator|)
operator|&
name|MIPS16OP_MASK_IMM5
expr_stmt|;
name|pcrel
operator|=
literal|1
expr_stmt|;
name|info
operator|->
name|insn_type
operator|=
name|dis_dref
expr_stmt|;
name|info
operator|->
name|data_size
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|nbits
operator|=
literal|5
expr_stmt|;
name|shift
operator|=
literal|2
expr_stmt|;
name|immed
operator|=
operator|(
name|l
operator|>>
name|MIPS16OP_SH_IMM5
operator|)
operator|&
name|MIPS16OP_MASK_IMM5
expr_stmt|;
name|pcrel
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|use_extend
condition|)
block|{
if|if
condition|(
name|signedp
operator|&&
name|immed
operator|>=
operator|(
literal|1
operator|<<
operator|(
name|nbits
operator|-
literal|1
operator|)
operator|)
condition|)
name|immed
operator|-=
literal|1
operator|<<
name|nbits
expr_stmt|;
name|immed
operator|<<=
name|shift
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
literal|'<'
operator|||
name|type
operator|==
literal|'>'
operator|||
name|type
operator|==
literal|'['
operator|||
name|type
operator|==
literal|']'
operator|)
operator|&&
name|immed
operator|==
literal|0
condition|)
name|immed
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|extbits
operator|==
literal|16
condition|)
name|immed
operator||=
operator|(
operator|(
name|extend
operator|&
literal|0x1f
operator|)
operator|<<
literal|11
operator|)
operator||
operator|(
name|extend
operator|&
literal|0x7e0
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|extbits
operator|==
literal|15
condition|)
name|immed
operator||=
operator|(
operator|(
name|extend
operator|&
literal|0xf
operator|)
operator|<<
literal|11
operator|)
operator||
operator|(
name|extend
operator|&
literal|0x7f0
operator|)
expr_stmt|;
else|else
name|immed
operator|=
operator|(
operator|(
name|extend
operator|>>
literal|6
operator|)
operator|&
literal|0x1f
operator|)
operator||
operator|(
name|extend
operator|&
literal|0x20
operator|)
expr_stmt|;
name|immed
operator|&=
operator|(
literal|1
operator|<<
name|extbits
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|extu
operator|&&
name|immed
operator|>=
operator|(
literal|1
operator|<<
operator|(
name|extbits
operator|-
literal|1
operator|)
operator|)
condition|)
name|immed
operator|-=
literal|1
operator|<<
name|extbits
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pcrel
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|immed
argument_list|)
expr_stmt|;
else|else
block|{
name|bfd_vma
name|baseaddr
decl_stmt|;
if|if
condition|(
name|branch
condition|)
block|{
name|immed
operator|*=
literal|2
expr_stmt|;
name|baseaddr
operator|=
name|memaddr
operator|+
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|use_extend
condition|)
name|baseaddr
operator|=
name|memaddr
operator|-
literal|2
expr_stmt|;
else|else
block|{
name|int
name|status
decl_stmt|;
name|bfd_byte
name|buffer
index|[
literal|2
index|]
decl_stmt|;
name|baseaddr
operator|=
name|memaddr
expr_stmt|;
comment|/* If this instruction is in the delay slot of a jr                    instruction, the base address is the address of the                    jr instruction.  If it is in the delay slot of jalr                    instruction, the base address is the address of the                    jalr instruction.  This test is unreliable: we have                    no way of knowing whether the previous word is                    instruction or data.  */
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|memaddr
operator|-
literal|4
argument_list|,
name|buffer
argument_list|,
literal|2
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
operator|&&
operator|(
operator|(
operator|(
name|info
operator|->
name|endian
operator|==
name|BFD_ENDIAN_BIG
condition|?
name|bfd_getb16
argument_list|(
name|buffer
argument_list|)
else|:
name|bfd_getl16
argument_list|(
name|buffer
argument_list|)
operator|)
operator|&
literal|0xf800
operator|)
operator|==
literal|0x1800
operator|)
condition|)
name|baseaddr
operator|=
name|memaddr
operator|-
literal|4
expr_stmt|;
else|else
block|{
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|memaddr
operator|-
literal|2
argument_list|,
name|buffer
argument_list|,
literal|2
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
operator|&&
operator|(
operator|(
operator|(
name|info
operator|->
name|endian
operator|==
name|BFD_ENDIAN_BIG
condition|?
name|bfd_getb16
argument_list|(
name|buffer
argument_list|)
else|:
name|bfd_getl16
argument_list|(
name|buffer
argument_list|)
operator|)
operator|&
literal|0xf81f
operator|)
operator|==
literal|0xe800
operator|)
condition|)
name|baseaddr
operator|=
name|memaddr
operator|-
literal|2
expr_stmt|;
block|}
block|}
name|info
operator|->
name|target
operator|=
operator|(
name|baseaddr
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
name|shift
operator|)
operator|-
literal|1
operator|)
operator|)
operator|+
name|immed
expr_stmt|;
if|if
condition|(
name|pcrel
operator|&&
name|branch
operator|&&
name|info
operator|->
name|flavour
operator|==
name|bfd_target_unknown_flavour
condition|)
comment|/* For gdb disassembler, maintain odd address.  */
name|info
operator|->
name|target
operator||=
literal|1
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|info
operator|->
name|target
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'a'
case|:
block|{
name|int
name|jalx
init|=
name|l
operator|&
literal|0x400
decl_stmt|;
if|if
condition|(
operator|!
name|use_extend
condition|)
name|extend
operator|=
literal|0
expr_stmt|;
name|l
operator|=
operator|(
operator|(
name|l
operator|&
literal|0x1f
operator|)
operator|<<
literal|23
operator|)
operator||
operator|(
operator|(
name|l
operator|&
literal|0x3e0
operator|)
operator|<<
literal|13
operator|)
operator||
operator|(
name|extend
operator|<<
literal|2
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|jalx
operator|&&
name|info
operator|->
name|flavour
operator|==
name|bfd_target_unknown_flavour
condition|)
comment|/* For gdb disassembler, maintain odd address.  */
name|l
operator||=
literal|1
expr_stmt|;
block|}
name|info
operator|->
name|target
operator|=
operator|(
operator|(
name|memaddr
operator|+
literal|4
operator|)
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|0x0fffffff
operator|)
operator||
name|l
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|info
operator|->
name|target
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|info
operator|->
name|insn_type
operator|=
name|dis_jsr
expr_stmt|;
name|info
operator|->
name|branch_delay_insns
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
block|{
name|int
name|need_comma
decl_stmt|,
name|amask
decl_stmt|,
name|smask
decl_stmt|;
name|need_comma
operator|=
literal|0
expr_stmt|;
name|l
operator|=
operator|(
name|l
operator|>>
name|MIPS16OP_SH_IMM6
operator|)
operator|&
name|MIPS16OP_MASK_IMM6
expr_stmt|;
name|amask
operator|=
operator|(
name|l
operator|>>
literal|3
operator|)
operator|&
literal|7
expr_stmt|;
if|if
condition|(
name|amask
operator|>
literal|0
operator|&&
name|amask
operator|<
literal|5
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|mips_gpr_names
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|amask
operator|>
literal|1
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"-%s"
argument_list|,
name|mips_gpr_names
index|[
name|amask
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
name|smask
operator|=
operator|(
name|l
operator|>>
literal|1
operator|)
operator|&
literal|3
expr_stmt|;
if|if
condition|(
name|smask
operator|==
literal|3
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s??"
argument_list|,
name|need_comma
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|smask
operator|>
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s%s"
argument_list|,
name|need_comma
condition|?
literal|","
else|:
literal|""
argument_list|,
name|mips_gpr_names
index|[
literal|16
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|smask
operator|>
literal|1
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"-%s"
argument_list|,
name|mips_gpr_names
index|[
name|smask
operator|+
literal|15
index|]
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|&
literal|1
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s%s"
argument_list|,
name|need_comma
condition|?
literal|","
else|:
literal|""
argument_list|,
name|mips_gpr_names
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|amask
operator|==
literal|5
operator|||
name|amask
operator|==
literal|6
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s$f0"
argument_list|,
name|need_comma
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|amask
operator|==
literal|6
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"-$f1"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'m'
case|:
case|case
literal|'M'
case|:
comment|/* MIPS16e save/restore.  */
block|{
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
name|int
name|amask
decl_stmt|,
name|args
decl_stmt|,
name|statics
decl_stmt|;
name|int
name|nsreg
decl_stmt|,
name|smask
decl_stmt|;
name|int
name|framesz
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|l
operator|=
name|l
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
name|use_extend
condition|)
name|l
operator||=
name|extend
operator|<<
literal|16
expr_stmt|;
name|amask
operator|=
operator|(
name|l
operator|>>
literal|16
operator|)
operator|&
literal|0xf
expr_stmt|;
if|if
condition|(
name|amask
operator|==
name|MIPS16_ALL_ARGS
condition|)
block|{
name|args
operator|=
literal|4
expr_stmt|;
name|statics
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|amask
operator|==
name|MIPS16_ALL_STATICS
condition|)
block|{
name|args
operator|=
literal|0
expr_stmt|;
name|statics
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|args
operator|=
name|amask
operator|>>
literal|2
expr_stmt|;
name|statics
operator|=
name|amask
operator|&
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|>
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|mips_gpr_names
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|>
literal|1
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"-%s"
argument_list|,
name|mips_gpr_names
index|[
literal|4
operator|+
name|args
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
name|framesz
operator|=
operator|(
operator|(
operator|(
name|l
operator|>>
literal|16
operator|)
operator|&
literal|0xf0
operator|)
operator||
operator|(
name|l
operator|&
literal|0x0f
operator|)
operator|)
operator|*
literal|8
expr_stmt|;
if|if
condition|(
name|framesz
operator|==
literal|0
operator|&&
operator|!
name|use_extend
condition|)
name|framesz
operator|=
literal|128
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s%d"
argument_list|,
name|need_comma
condition|?
literal|","
else|:
literal|""
argument_list|,
name|framesz
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|&
literal|0x40
condition|)
comment|/* $ra */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|",%s"
argument_list|,
name|mips_gpr_names
index|[
literal|31
index|]
argument_list|)
expr_stmt|;
name|nsreg
operator|=
operator|(
name|l
operator|>>
literal|24
operator|)
operator|&
literal|0x7
expr_stmt|;
name|smask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|l
operator|&
literal|0x20
condition|)
comment|/* $s0 */
name|smask
operator||=
literal|1
operator|<<
literal|0
expr_stmt|;
if|if
condition|(
name|l
operator|&
literal|0x10
condition|)
comment|/* $s1 */
name|smask
operator||=
literal|1
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|nsreg
operator|>
literal|0
condition|)
comment|/* $s2-$s8 */
name|smask
operator||=
operator|(
operator|(
literal|1
operator|<<
name|nsreg
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|2
expr_stmt|;
comment|/* Find first set static reg bit.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|smask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|",%s"
argument_list|,
name|mips_gpr_names
index|[
name|i
operator|==
literal|8
condition|?
literal|30
else|:
operator|(
literal|16
operator|+
name|i
operator|)
index|]
argument_list|)
expr_stmt|;
comment|/* Skip over string of set bits.  */
for|for
control|(
name|j
operator|=
name|i
init|;
name|smask
operator|&
operator|(
literal|2
operator|<<
name|j
operator|)
condition|;
name|j
operator|++
control|)
continue|continue;
if|if
condition|(
name|j
operator|>
name|i
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"-%s"
argument_list|,
name|mips_gpr_names
index|[
name|j
operator|==
literal|8
condition|?
literal|30
else|:
operator|(
literal|16
operator|+
name|j
operator|)
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
name|j
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* Statics $ax - $a3.  */
if|if
condition|(
name|statics
operator|==
literal|1
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|",%s"
argument_list|,
name|mips_gpr_names
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|statics
operator|>
literal|0
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|",%s-%s"
argument_list|,
name|mips_gpr_names
index|[
literal|7
operator|-
name|statics
operator|+
literal|1
index|]
argument_list|,
name|mips_gpr_names
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* xgettext:c-format */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
name|_
argument_list|(
literal|"# internal disassembler error, unrecognised modifier (%c)"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Disassemble mips16 instructions.  */
end_comment

begin_function
specifier|static
name|int
name|print_insn_mips16
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|bfd_byte
name|buffer
index|[
literal|2
index|]
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|insn
decl_stmt|;
name|bfd_boolean
name|use_extend
decl_stmt|;
name|int
name|extend
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|mips_opcode
modifier|*
name|op
decl_stmt|,
modifier|*
name|opend
decl_stmt|;
name|info
operator|->
name|bytes_per_chunk
operator|=
literal|2
expr_stmt|;
name|info
operator|->
name|display_endian
operator|=
name|info
operator|->
name|endian
expr_stmt|;
name|info
operator|->
name|insn_info_valid
operator|=
literal|1
expr_stmt|;
name|info
operator|->
name|branch_delay_insns
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|data_size
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|insn_type
operator|=
name|dis_nonbranch
expr_stmt|;
name|info
operator|->
name|target
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|target2
operator|=
literal|0
expr_stmt|;
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|memaddr
argument_list|,
name|buffer
argument_list|,
literal|2
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|memory_error_func
call|)
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|length
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|endian
operator|==
name|BFD_ENDIAN_BIG
condition|)
name|insn
operator|=
name|bfd_getb16
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|bfd_getl16
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* Handle the extend opcode specially.  */
name|use_extend
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xf800
operator|)
operator|==
literal|0xf000
condition|)
block|{
name|use_extend
operator|=
name|TRUE
expr_stmt|;
name|extend
operator|=
name|insn
operator|&
literal|0x7ff
expr_stmt|;
name|memaddr
operator|+=
literal|2
expr_stmt|;
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|memaddr
argument_list|,
name|buffer
argument_list|,
literal|2
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"extend 0x%x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|extend
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|memory_error_func
call|)
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|info
operator|->
name|endian
operator|==
name|BFD_ENDIAN_BIG
condition|)
name|insn
operator|=
name|bfd_getb16
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|bfd_getl16
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* Check for an extend opcode followed by an extend opcode.  */
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xf800
operator|)
operator|==
literal|0xf000
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"extend 0x%x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|extend
argument_list|)
expr_stmt|;
name|info
operator|->
name|insn_type
operator|=
name|dis_noninsn
expr_stmt|;
return|return
name|length
return|;
block|}
name|length
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* FIXME: Should probably use a hash table on the major opcode here.  */
name|opend
operator|=
name|mips16_opcodes
operator|+
name|bfd_mips16_num_opcodes
expr_stmt|;
for|for
control|(
name|op
operator|=
name|mips16_opcodes
init|;
name|op
operator|<
name|opend
condition|;
name|op
operator|++
control|)
block|{
if|if
condition|(
name|op
operator|->
name|pinfo
operator|!=
name|INSN_MACRO
operator|&&
operator|!
operator|(
name|no_aliases
operator|&&
operator|(
name|op
operator|->
name|pinfo2
operator|&
name|INSN2_ALIAS
operator|)
operator|)
operator|&&
operator|(
name|insn
operator|&
name|op
operator|->
name|mask
operator|)
operator|==
name|op
operator|->
name|match
condition|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|op
operator|->
name|args
argument_list|,
literal|'a'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|use_extend
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"extend 0x%x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|extend
argument_list|)
expr_stmt|;
name|info
operator|->
name|insn_type
operator|=
name|dis_noninsn
expr_stmt|;
return|return
name|length
operator|-
literal|2
return|;
block|}
name|use_extend
operator|=
name|FALSE
expr_stmt|;
name|memaddr
operator|+=
literal|2
expr_stmt|;
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|memaddr
argument_list|,
name|buffer
argument_list|,
literal|2
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|use_extend
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|endian
operator|==
name|BFD_ENDIAN_BIG
condition|)
name|extend
operator|=
name|bfd_getb16
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
else|else
name|extend
operator|=
name|bfd_getl16
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|length
operator|+=
literal|2
expr_stmt|;
block|}
block|}
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|op
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|args
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|op
operator|->
name|args
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|','
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'w'
operator|&&
operator|(
operator|(
operator|(
name|insn
operator|>>
name|MIPS16OP_SH_RX
operator|)
operator|&
name|MIPS16OP_MASK_RX
operator|)
operator|==
operator|(
operator|(
name|insn
operator|>>
name|MIPS16OP_SH_RY
operator|)
operator|&
name|MIPS16OP_MASK_RY
operator|)
operator|)
condition|)
block|{
comment|/* Skip the register and the comma.  */
operator|++
name|s
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|','
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'v'
operator|&&
operator|(
operator|(
operator|(
name|insn
operator|>>
name|MIPS16OP_SH_RZ
operator|)
operator|&
name|MIPS16OP_MASK_RZ
operator|)
operator|==
operator|(
operator|(
name|insn
operator|>>
name|MIPS16OP_SH_RX
operator|)
operator|&
name|MIPS16OP_MASK_RX
operator|)
operator|)
condition|)
block|{
comment|/* Skip the register and the comma.  */
operator|++
name|s
expr_stmt|;
continue|continue;
block|}
name|print_mips16_insn_arg
argument_list|(
operator|*
name|s
argument_list|,
name|op
argument_list|,
name|insn
argument_list|,
name|use_extend
argument_list|,
name|extend
argument_list|,
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|op
operator|->
name|pinfo
operator|&
name|INSN_UNCOND_BRANCH_DELAY
operator|)
operator|!=
literal|0
condition|)
block|{
name|info
operator|->
name|branch_delay_insns
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|insn_type
operator|!=
name|dis_jsr
condition|)
name|info
operator|->
name|insn_type
operator|=
name|dis_branch
expr_stmt|;
block|}
return|return
name|length
return|;
block|}
block|}
if|if
condition|(
name|use_extend
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
name|extend
operator||
literal|0xf000
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|info
operator|->
name|insn_type
operator|=
name|dis_noninsn
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_comment
comment|/* In an environment where we do not know the symbol type of the    instruction we are forced to assume that the low order bit of the    instructions' address may mark it as a mips16 instruction.  If we    are single stepping, or the pc is within the disassembled function,    this works.  Otherwise, we need a clue.  Sometimes.  */
end_comment

begin_function
specifier|static
name|int
name|_print_insn_mips
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|,
name|enum
name|bfd_endian
name|endianness
parameter_list|)
block|{
name|bfd_byte
name|buffer
index|[
name|INSNLEN
index|]
decl_stmt|;
name|int
name|status
decl_stmt|;
name|set_default_mips_dis_options
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|parse_mips_dis_options
argument_list|(
name|info
operator|->
name|disassembler_options
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* FIXME: If odd address, this is CLEARLY a mips 16 instruction.  */
comment|/* Only a few tools will work this way.  */
if|if
condition|(
name|memaddr
operator|&
literal|0x01
condition|)
return|return
name|print_insn_mips16
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
name|SYMTAB_AVAILABLE
if|if
condition|(
name|info
operator|->
name|mach
operator|==
name|bfd_mach_mips16
operator|||
operator|(
name|info
operator|->
name|flavour
operator|==
name|bfd_target_elf_flavour
operator|&&
name|info
operator|->
name|symbols
operator|!=
name|NULL
operator|&&
operator|(
operator|(
operator|*
operator|(
name|elf_symbol_type
operator|*
operator|*
operator|)
name|info
operator|->
name|symbols
operator|)
operator|->
name|internal_elf_sym
operator|.
name|st_other
operator|==
name|STO_MIPS16
operator|)
operator|)
condition|)
return|return
name|print_insn_mips16
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
return|;
endif|#
directive|endif
name|status
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|memaddr
argument_list|,
name|buffer
argument_list|,
name|INSNLEN
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
if|if
condition|(
name|endianness
operator|==
name|BFD_ENDIAN_BIG
condition|)
name|insn
operator|=
operator|(
name|unsigned
name|long
operator|)
name|bfd_getb32
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
operator|(
name|unsigned
name|long
operator|)
name|bfd_getl32
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
name|print_insn_mips
argument_list|(
name|memaddr
argument_list|,
name|insn
argument_list|,
name|info
argument_list|)
return|;
block|}
else|else
block|{
call|(
modifier|*
name|info
operator|->
name|memory_error_func
call|)
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
name|int
name|print_insn_big_mips
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
return|return
name|_print_insn_mips
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|,
name|BFD_ENDIAN_BIG
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|print_insn_little_mips
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
return|return
name|_print_insn_mips
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|,
name|BFD_ENDIAN_LITTLE
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|print_mips_disassembler_options
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\n\ The following MIPS specific disassembler options are supported for use\n\ with the -M switch (multiple options should be separated by commas):\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\n\   octeon-useun             Disassemble Octeon unaligned load/store instructions.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\n\   no-octeon-useun          Disassemble mips unaligned load/store instructions.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\n\   gpr-names=ABI            Print GPR names according to  specified ABI.\n\                            Default: based on binary being disassembled.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\n\   fpr-names=ABI            Print FPR names according to specified ABI.\n\                            Default: numeric.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\n\   cp0-names=ARCH           Print CP0 register names according to\n\                            specified architecture.\n\                            Default: based on binary being disassembled.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\n\   hwr-names=ARCH           Print HWR names according to specified \n\ 			   architecture.\n\                            Default: based on binary being disassembled.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\n\   reg-names=ABI            Print GPR and FPR names according to\n\                            specified ABI.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\n\   reg-names=ARCH           Print CP0 register and HWR names according to\n\                            specified architecture.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\n\   For the options above, the following values are supported for \"ABI\":\n\    "
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|mips_abi_choices
argument_list|)
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" %s"
argument_list|,
name|mips_abi_choices
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\n\   For the options above, The following values are supported for \"ARCH\":\n\    "
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|mips_arch_choices
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|*
name|mips_arch_choices
index|[
name|i
index|]
operator|.
name|name
operator|!=
literal|'\0'
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|" %s"
argument_list|,
name|mips_arch_choices
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

