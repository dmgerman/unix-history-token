begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Opcode table for the ARC.    Copyright (c) 1994, 1995, 1997, 1998 Free Software Foundation, Inc.    Contributed by Doug Evans (dje@cygnus.com).        This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"opcode/arc.h"
end_include

begin_include
include|#
directive|include
file|"opintl.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|INSERT_FN
parameter_list|(
name|fn
parameter_list|)
define|\
value|static arc_insn fn PARAMS ((arc_insn, const struct arc_operand *, \ 			    int, const struct arc_operand_value *, long, \ 			    const char **))
end_define

begin_define
define|#
directive|define
name|EXTRACT_FN
parameter_list|(
name|fn
parameter_list|)
define|\
value|static long fn PARAMS ((arc_insn *, const struct arc_operand *, \ 			int, const struct arc_operand_value **, int *))
end_define

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_reg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_shimmfinish
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_limmfinish
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_shimmoffset
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_shimmzero
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_flag
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_flagfinish
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_cond
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_forcelimm
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_reladdr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_absaddr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_unopmacro
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXTRACT_FN
argument_list|(
name|extract_reg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXTRACT_FN
argument_list|(
name|extract_flag
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXTRACT_FN
argument_list|(
name|extract_cond
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXTRACT_FN
argument_list|(
name|extract_reladdr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXTRACT_FN
argument_list|(
name|extract_unopmacro
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Various types of ARC operands, including insn suffixes.  */
end_comment

begin_comment
comment|/* Insn format values:     'a'	REGA		register A field    'b'	REGB		register B field    'c'	REGC		register C field    'S'	SHIMMFINISH	finish inserting a shimm value    'L'	LIMMFINISH	finish inserting a limm value    'd'	SHIMMOFFSET	shimm offset in ld,st insns    '0'	SHIMMZERO	0 shimm value in ld,st insns    'f'	FLAG		F flag    'F'	FLAGFINISH	finish inserting the F flag    'G'	FLAGINSN	insert F flag in "flag" insn    'n'	DELAY		N field (nullify field)    'q'	COND		condition code field    'Q'	FORCELIMM	set `cond_p' to 1 to ensure a constant is a limm    'B'	BRANCH		branch address (22 bit pc relative)    'J'	JUMP		jump address (26 bit absolute)    'z'	SIZE1		size field in ld a,[b,c]    'Z'	SIZE10		size field in ld a,[b,shimm]    'y'	SIZE22		size field in st c,[b,shimm]    'x'	SIGN0		sign extend field ld a,[b,c]    'X'	SIGN9		sign extend field ld a,[b,shimm]    'w'	ADDRESS3	write-back field in ld a,[b,c]    'W'	ADDRESS12	write-back field in ld a,[b,shimm]    'v'	ADDRESS24	write-back field in st c,[b,shimm]    'e'	CACHEBYPASS5	cache bypass in ld a,[b,c]    'E'	CACHEBYPASS14	cache bypass in ld a,[b,shimm]    'D'	CACHEBYPASS26	cache bypass in st c,[b,shimm]    'U'	UNOPMACRO	fake operand to copy REGB to REGC for unop macros     The following modifiers may appear between the % and char (eg: %.f):     '.'	MODDOT		'.' prefix must be present    'r'	REG		generic register value, for register table    'A'	AUXREG		auxiliary register in lr a,[b], sr c,[b]     Fields are:     CHAR BITS SHIFT FLAGS INSERT_FN EXTRACT_FN */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|arc_operand
name|arc_operands
index|[]
init|=
block|{
comment|/* place holder (??? not sure if needed) */
define|#
directive|define
name|UNUSED
value|0
block|{
literal|0
block|}
block|,
comment|/* register A or shimm/limm indicator */
define|#
directive|define
name|REGA
value|(UNUSED + 1)
block|{
literal|'a'
block|,
literal|6
block|,
name|ARC_SHIFT_REGA
block|,
name|ARC_OPERAND_SIGNED
block|,
name|insert_reg
block|,
name|extract_reg
block|}
block|,
comment|/* register B or shimm/limm indicator */
define|#
directive|define
name|REGB
value|(REGA + 1)
block|{
literal|'b'
block|,
literal|6
block|,
name|ARC_SHIFT_REGB
block|,
name|ARC_OPERAND_SIGNED
block|,
name|insert_reg
block|,
name|extract_reg
block|}
block|,
comment|/* register C or shimm/limm indicator */
define|#
directive|define
name|REGC
value|(REGB + 1)
block|{
literal|'c'
block|,
literal|6
block|,
name|ARC_SHIFT_REGC
block|,
name|ARC_OPERAND_SIGNED
block|,
name|insert_reg
block|,
name|extract_reg
block|}
block|,
comment|/* fake operand used to insert shimm value into most instructions */
define|#
directive|define
name|SHIMMFINISH
value|(REGC + 1)
block|{
literal|'S'
block|,
literal|9
block|,
literal|0
block|,
name|ARC_OPERAND_SIGNED
operator|+
name|ARC_OPERAND_FAKE
block|,
name|insert_shimmfinish
block|,
literal|0
block|}
block|,
comment|/* fake operand used to insert limm value into most instructions.  */
define|#
directive|define
name|LIMMFINISH
value|(SHIMMFINISH + 1)
block|{
literal|'L'
block|,
literal|32
block|,
literal|32
block|,
name|ARC_OPERAND_ADDRESS
operator|+
name|ARC_OPERAND_LIMM
operator|+
name|ARC_OPERAND_FAKE
block|,
name|insert_limmfinish
block|,
literal|0
block|}
block|,
comment|/* shimm operand when there is no reg indicator (ld,st) */
define|#
directive|define
name|SHIMMOFFSET
value|(LIMMFINISH + 1)
block|{
literal|'d'
block|,
literal|9
block|,
literal|0
block|,
name|ARC_OPERAND_SIGNED
block|,
name|insert_shimmoffset
block|,
literal|0
block|}
block|,
comment|/* 0 shimm operand for ld,st insns */
define|#
directive|define
name|SHIMMZERO
value|(SHIMMOFFSET + 1)
block|{
literal|'0'
block|,
literal|9
block|,
literal|0
block|,
name|ARC_OPERAND_FAKE
block|,
name|insert_shimmzero
block|,
literal|0
block|}
block|,
comment|/* flag update bit (insertion is defered until we know how) */
define|#
directive|define
name|FLAG
value|(SHIMMZERO + 1)
block|{
literal|'f'
block|,
literal|1
block|,
literal|8
block|,
name|ARC_OPERAND_SUFFIX
block|,
name|insert_flag
block|,
name|extract_flag
block|}
block|,
comment|/* fake utility operand to finish 'f' suffix handling */
define|#
directive|define
name|FLAGFINISH
value|(FLAG + 1)
block|{
literal|'F'
block|,
literal|1
block|,
literal|8
block|,
name|ARC_OPERAND_FAKE
block|,
name|insert_flagfinish
block|,
literal|0
block|}
block|,
comment|/* fake utility operand to set the 'f' flag for the "flag" insn */
define|#
directive|define
name|FLAGINSN
value|(FLAGFINISH + 1)
block|{
literal|'G'
block|,
literal|1
block|,
literal|8
block|,
name|ARC_OPERAND_FAKE
block|,
name|insert_flag
block|,
literal|0
block|}
block|,
comment|/* branch delay types */
define|#
directive|define
name|DELAY
value|(FLAGINSN + 1)
block|{
literal|'n'
block|,
literal|2
block|,
literal|5
block|,
name|ARC_OPERAND_SUFFIX
block|}
block|,
comment|/* conditions */
define|#
directive|define
name|COND
value|(DELAY + 1)
block|{
literal|'q'
block|,
literal|5
block|,
literal|0
block|,
name|ARC_OPERAND_SUFFIX
block|,
name|insert_cond
block|,
name|extract_cond
block|}
block|,
comment|/* set `cond_p' to 1 to ensure a constant is treated as a limm */
define|#
directive|define
name|FORCELIMM
value|(COND + 1)
block|{
literal|'Q'
block|,
literal|0
block|,
literal|0
block|,
name|ARC_OPERAND_FAKE
block|,
name|insert_forcelimm
block|}
block|,
comment|/* branch address; b, bl, and lp insns */
define|#
directive|define
name|BRANCH
value|(FORCELIMM + 1)
block|{
literal|'B'
block|,
literal|20
block|,
literal|7
block|,
name|ARC_OPERAND_RELATIVE_BRANCH
operator|+
name|ARC_OPERAND_SIGNED
block|,
name|insert_reladdr
block|,
name|extract_reladdr
block|}
block|,
comment|/* jump address; j insn (this is basically the same as 'L' except that the    value is right shifted by 2) */
define|#
directive|define
name|JUMP
value|(BRANCH + 1)
block|{
literal|'J'
block|,
literal|24
block|,
literal|32
block|,
name|ARC_OPERAND_ABSOLUTE_BRANCH
operator|+
name|ARC_OPERAND_LIMM
operator|+
name|ARC_OPERAND_FAKE
block|,
name|insert_absaddr
block|}
block|,
comment|/* size field, stored in bit 1,2 */
define|#
directive|define
name|SIZE1
value|(JUMP + 1)
block|{
literal|'z'
block|,
literal|2
block|,
literal|1
block|,
name|ARC_OPERAND_SUFFIX
block|}
block|,
comment|/* size field, stored in bit 10,11 */
define|#
directive|define
name|SIZE10
value|(SIZE1 + 1)
block|{
literal|'Z'
block|,
literal|2
block|,
literal|10
block|,
name|ARC_OPERAND_SUFFIX
block|, }
block|,
comment|/* size field, stored in bit 22,23 */
define|#
directive|define
name|SIZE22
value|(SIZE10 + 1)
block|{
literal|'y'
block|,
literal|2
block|,
literal|22
block|,
name|ARC_OPERAND_SUFFIX
block|, }
block|,
comment|/* sign extend field, stored in bit 0 */
define|#
directive|define
name|SIGN0
value|(SIZE22 + 1)
block|{
literal|'x'
block|,
literal|1
block|,
literal|0
block|,
name|ARC_OPERAND_SUFFIX
block|}
block|,
comment|/* sign extend field, stored in bit 9 */
define|#
directive|define
name|SIGN9
value|(SIGN0 + 1)
block|{
literal|'X'
block|,
literal|1
block|,
literal|9
block|,
name|ARC_OPERAND_SUFFIX
block|}
block|,
comment|/* address write back, stored in bit 3 */
define|#
directive|define
name|ADDRESS3
value|(SIGN9 + 1)
block|{
literal|'w'
block|,
literal|1
block|,
literal|3
block|,
name|ARC_OPERAND_SUFFIX
block|}
block|,
comment|/* address write back, stored in bit 12 */
define|#
directive|define
name|ADDRESS12
value|(ADDRESS3 + 1)
block|{
literal|'W'
block|,
literal|1
block|,
literal|12
block|,
name|ARC_OPERAND_SUFFIX
block|}
block|,
comment|/* address write back, stored in bit 24 */
define|#
directive|define
name|ADDRESS24
value|(ADDRESS12 + 1)
block|{
literal|'v'
block|,
literal|1
block|,
literal|24
block|,
name|ARC_OPERAND_SUFFIX
block|}
block|,
comment|/* cache bypass, stored in bit 5 */
define|#
directive|define
name|CACHEBYPASS5
value|(ADDRESS24 + 1)
block|{
literal|'e'
block|,
literal|1
block|,
literal|5
block|,
name|ARC_OPERAND_SUFFIX
block|}
block|,
comment|/* cache bypass, stored in bit 14 */
define|#
directive|define
name|CACHEBYPASS14
value|(CACHEBYPASS5 + 1)
block|{
literal|'E'
block|,
literal|1
block|,
literal|14
block|,
name|ARC_OPERAND_SUFFIX
block|}
block|,
comment|/* cache bypass, stored in bit 26 */
define|#
directive|define
name|CACHEBYPASS26
value|(CACHEBYPASS14 + 1)
block|{
literal|'D'
block|,
literal|1
block|,
literal|26
block|,
name|ARC_OPERAND_SUFFIX
block|}
block|,
comment|/* unop macro, used to copy REGB to REGC */
define|#
directive|define
name|UNOPMACRO
value|(CACHEBYPASS26 + 1)
block|{
literal|'U'
block|,
literal|6
block|,
name|ARC_SHIFT_REGC
block|,
name|ARC_OPERAND_FAKE
block|,
name|insert_unopmacro
block|,
name|extract_unopmacro
block|}
block|,
comment|/* '.' modifier ('.' required).  */
define|#
directive|define
name|MODDOT
value|(UNOPMACRO + 1)
block|{
literal|'.'
block|,
literal|1
block|,
literal|0
block|,
name|ARC_MOD_DOT
block|}
block|,
comment|/* Dummy 'r' modifier for the register table.    It's called a "dummy" because there's no point in inserting an 'r' into all    the %a/%b/%c occurrences in the insn table.  */
define|#
directive|define
name|REG
value|(MODDOT + 1)
block|{
literal|'r'
block|,
literal|6
block|,
literal|0
block|,
name|ARC_MOD_REG
block|}
block|,
comment|/* Known auxiliary register modifier (stored in shimm field).  */
define|#
directive|define
name|AUXREG
value|(REG + 1)
block|{
literal|'A'
block|,
literal|9
block|,
literal|0
block|,
name|ARC_MOD_AUXREG
block|}
block|,
comment|/* end of list place holder */
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Given a format letter, yields the index into `arc_operands'.    eg: arc_operand_map['a'] = REGA.  */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|arc_operand_map
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|I
parameter_list|(
name|x
parameter_list|)
value|(((x)& 31)<< 27)
end_define

begin_define
define|#
directive|define
name|A
parameter_list|(
name|x
parameter_list|)
value|(((x)& ARC_MASK_REG)<< ARC_SHIFT_REGA)
end_define

begin_define
define|#
directive|define
name|B
parameter_list|(
name|x
parameter_list|)
value|(((x)& ARC_MASK_REG)<< ARC_SHIFT_REGB)
end_define

begin_define
define|#
directive|define
name|C
parameter_list|(
name|x
parameter_list|)
value|(((x)& ARC_MASK_REG)<< ARC_SHIFT_REGC)
end_define

begin_define
define|#
directive|define
name|R
parameter_list|(
name|x
parameter_list|,
name|b
parameter_list|,
name|m
parameter_list|)
value|(((x)& (m))<< (b))
end_define

begin_comment
comment|/* value X, mask M, at bit B */
end_comment

begin_comment
comment|/* ARC instructions.     Longer versions of insns must appear before shorter ones (if gas sees    "lsr r2,r3,1" when it's parsing "lsr %a,%b" it will think the ",1" is    junk).  This isn't necessary for `ld' because of the trailing ']'.     Instructions that are really macros based on other insns must appear    before the real insn so they're chosen when disassembling.  Eg: The `mov'    insn is really the `and' insn.     This table is best viewed on a wide screen (161 columns).  I'd prefer to    keep it this way.  The rest of the file, however, should be viewable on an    80 column terminal.  */
end_comment

begin_comment
comment|/* ??? This table also includes macros: asl, lsl, and mov.  The ppc port has    a more general facility for dealing with macros which could be used if    we need to.  */
end_comment

begin_comment
comment|/* This table can't be `const' because members `next_asm' and `next_dis' are    computed at run-time.  We could split this into two, but that doesn't seem    worth it.  */
end_comment

begin_decl_stmt
name|struct
name|arc_opcode
name|arc_opcodes
index|[]
init|=
block|{
comment|/* Macros appear first.  */
comment|/* "mov" is really an "and".  */
block|{
literal|"mov%.q%.f %a,%b%F%S%L%U"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|12
argument_list|)
block|}
block|,
comment|/* "asl" is really an "add".  */
block|{
literal|"asl%.q%.f %a,%b%F%S%L%U"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|8
argument_list|)
block|}
block|,
comment|/* "lsl" is really an "add".  */
block|{
literal|"lsl%.q%.f %a,%b%F%S%L%U"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|8
argument_list|)
block|}
block|,
comment|/* "nop" is really an "xor".  */
block|{
literal|"nop"
block|,
literal|0xffffffff
block|,
literal|0x7fffffff
block|}
block|,
comment|/* "rlc" is really an "adc".  */
block|{
literal|"rlc%.q%.f %a,%b%F%S%L%U"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|9
argument_list|)
block|}
block|,
comment|/* The rest of these needn't be sorted, but it helps to find them if they are.  */
block|{
literal|"adc%.q%.f %a,%b,%c%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|9
argument_list|)
block|}
block|,
block|{
literal|"add%.q%.f %a,%b,%c%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|8
argument_list|)
block|}
block|,
block|{
literal|"and%.q%.f %a,%b,%c%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|12
argument_list|)
block|}
block|,
block|{
literal|"asr%.q%.f %a,%b%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator|+
name|C
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|3
argument_list|)
operator|+
name|C
argument_list|(
literal|1
argument_list|)
block|}
block|,
block|{
literal|"bic%.q%.f %a,%b,%c%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|14
argument_list|)
block|}
block|,
block|{
literal|"b%q%.n %B"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|4
argument_list|)
block|,
name|ARC_OPCODE_COND_BRANCH
block|}
block|,
block|{
literal|"bl%q%.n %B"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|5
argument_list|)
block|,
name|ARC_OPCODE_COND_BRANCH
block|}
block|,
block|{
literal|"extb%.q%.f %a,%b%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator|+
name|C
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|3
argument_list|)
operator|+
name|C
argument_list|(
literal|7
argument_list|)
block|}
block|,
block|{
literal|"extw%.q%.f %a,%b%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator|+
name|C
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|3
argument_list|)
operator|+
name|C
argument_list|(
literal|8
argument_list|)
block|}
block|,
block|{
literal|"flag%.q %b%G%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator|+
name|A
argument_list|(
operator|-
literal|1
argument_list|)
operator|+
name|C
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|3
argument_list|)
operator|+
name|A
argument_list|(
name|ARC_REG_SHIMM_UPDATE
argument_list|)
operator|+
name|C
argument_list|(
literal|0
argument_list|)
block|}
block|,
comment|/* %Q: force cond_p=1 --> no shimm values */
comment|/* ??? This insn allows an optional flags spec.  */
block|{
literal|"j%q%Q%.n%.f %b%J"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator|+
name|A
argument_list|(
operator|-
literal|1
argument_list|)
operator|+
name|C
argument_list|(
operator|-
literal|1
argument_list|)
operator|+
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|7
argument_list|)
operator|+
name|A
argument_list|(
literal|0
argument_list|)
operator|+
name|C
argument_list|(
literal|0
argument_list|)
operator|+
name|R
argument_list|(
literal|0
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|)
block|}
block|,
comment|/* Put opcode 1 ld insns first so shimm gets prefered over limm.  */
comment|/* "[%b]" is before "[%b,%d]" so 0 offsets don't get printed.  */
block|{
literal|"ld%Z%.X%.W%.E %0%a,[%b]%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator|+
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|13
argument_list|,
literal|1
argument_list|)
operator|+
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|511
argument_list|)
block|,
name|I
argument_list|(
literal|1
argument_list|)
operator|+
name|R
argument_list|(
literal|0
argument_list|,
literal|13
argument_list|,
literal|1
argument_list|)
operator|+
name|R
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|511
argument_list|)
block|}
block|,
block|{
literal|"ld%Z%.X%.W%.E %a,[%b,%d]%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator|+
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|13
argument_list|,
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|1
argument_list|)
operator|+
name|R
argument_list|(
literal|0
argument_list|,
literal|13
argument_list|,
literal|1
argument_list|)
block|}
block|,
block|{
literal|"ld%z%.x%.w%.e%Q %a,[%b,%c]%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator|+
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|)
operator|+
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|6
argument_list|,
literal|7
argument_list|)
block|,
name|I
argument_list|(
literal|0
argument_list|)
operator|+
name|R
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|)
operator|+
name|R
argument_list|(
literal|0
argument_list|,
literal|6
argument_list|,
literal|7
argument_list|)
block|}
block|,
block|{
literal|"lp%q%.n %B"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|6
argument_list|)
block|, }
block|,
block|{
literal|"lr %a,[%Ab]%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator|+
name|C
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|1
argument_list|)
operator|+
name|C
argument_list|(
literal|0x10
argument_list|)
block|}
block|,
block|{
literal|"lsr%.q%.f %a,%b%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator|+
name|C
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|3
argument_list|)
operator|+
name|C
argument_list|(
literal|2
argument_list|)
block|}
block|,
block|{
literal|"or%.q%.f %a,%b,%c%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|13
argument_list|)
block|}
block|,
block|{
literal|"ror%.q%.f %a,%b%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator|+
name|C
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|3
argument_list|)
operator|+
name|C
argument_list|(
literal|3
argument_list|)
block|}
block|,
block|{
literal|"rrc%.q%.f %a,%b%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator|+
name|C
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|3
argument_list|)
operator|+
name|C
argument_list|(
literal|4
argument_list|)
block|}
block|,
block|{
literal|"sbc%.q%.f %a,%b,%c%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|11
argument_list|)
block|}
block|,
block|{
literal|"sexb%.q%.f %a,%b%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator|+
name|C
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|3
argument_list|)
operator|+
name|C
argument_list|(
literal|5
argument_list|)
block|}
block|,
block|{
literal|"sexw%.q%.f %a,%b%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator|+
name|C
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|3
argument_list|)
operator|+
name|C
argument_list|(
literal|6
argument_list|)
block|}
block|,
block|{
literal|"sr %c,[%Ab]%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator|+
name|A
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|2
argument_list|)
operator|+
name|A
argument_list|(
literal|0x10
argument_list|)
block|}
block|,
comment|/* "[%b]" is before "[%b,%d]" so 0 offsets don't get printed.  */
block|{
literal|"st%y%.v%.D%Q %0%c,[%b]%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator|+
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|25
argument_list|,
literal|1
argument_list|)
operator|+
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|21
argument_list|,
literal|1
argument_list|)
operator|+
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|511
argument_list|)
block|,
name|I
argument_list|(
literal|2
argument_list|)
operator|+
name|R
argument_list|(
literal|0
argument_list|,
literal|25
argument_list|,
literal|1
argument_list|)
operator|+
name|R
argument_list|(
literal|0
argument_list|,
literal|21
argument_list|,
literal|1
argument_list|)
operator|+
name|R
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|511
argument_list|)
block|}
block|,
block|{
literal|"st%y%.v%.D %c,[%b,%d]%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator|+
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|25
argument_list|,
literal|1
argument_list|)
operator|+
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|21
argument_list|,
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|2
argument_list|)
operator|+
name|R
argument_list|(
literal|0
argument_list|,
literal|25
argument_list|,
literal|1
argument_list|)
operator|+
name|R
argument_list|(
literal|0
argument_list|,
literal|21
argument_list|,
literal|1
argument_list|)
block|}
block|,
block|{
literal|"sub%.q%.f %a,%b,%c%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|10
argument_list|)
block|}
block|,
block|{
literal|"xor%.q%.f %a,%b,%c%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|15
argument_list|)
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|arc_opcodes_count
init|=
sizeof|sizeof
argument_list|(
name|arc_opcodes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|arc_opcodes
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|arc_operand_value
name|arc_reg_names
index|[]
init|=
block|{
comment|/* Sort this so that the first 61 entries are sequential.      IE: For each i (i<61), arc_reg_names[i].value == i.  */
block|{
literal|"r0"
block|,
literal|0
block|,
name|REG
block|}
block|,
block|{
literal|"r1"
block|,
literal|1
block|,
name|REG
block|}
block|,
block|{
literal|"r2"
block|,
literal|2
block|,
name|REG
block|}
block|,
block|{
literal|"r3"
block|,
literal|3
block|,
name|REG
block|}
block|,
block|{
literal|"r4"
block|,
literal|4
block|,
name|REG
block|}
block|,
block|{
literal|"r5"
block|,
literal|5
block|,
name|REG
block|}
block|,
block|{
literal|"r6"
block|,
literal|6
block|,
name|REG
block|}
block|,
block|{
literal|"r7"
block|,
literal|7
block|,
name|REG
block|}
block|,
block|{
literal|"r8"
block|,
literal|8
block|,
name|REG
block|}
block|,
block|{
literal|"r9"
block|,
literal|9
block|,
name|REG
block|}
block|,
block|{
literal|"r10"
block|,
literal|10
block|,
name|REG
block|}
block|,
block|{
literal|"r11"
block|,
literal|11
block|,
name|REG
block|}
block|,
block|{
literal|"r12"
block|,
literal|12
block|,
name|REG
block|}
block|,
block|{
literal|"r13"
block|,
literal|13
block|,
name|REG
block|}
block|,
block|{
literal|"r14"
block|,
literal|14
block|,
name|REG
block|}
block|,
block|{
literal|"r15"
block|,
literal|15
block|,
name|REG
block|}
block|,
block|{
literal|"r16"
block|,
literal|16
block|,
name|REG
block|}
block|,
block|{
literal|"r17"
block|,
literal|17
block|,
name|REG
block|}
block|,
block|{
literal|"r18"
block|,
literal|18
block|,
name|REG
block|}
block|,
block|{
literal|"r19"
block|,
literal|19
block|,
name|REG
block|}
block|,
block|{
literal|"r20"
block|,
literal|20
block|,
name|REG
block|}
block|,
block|{
literal|"r21"
block|,
literal|21
block|,
name|REG
block|}
block|,
block|{
literal|"r22"
block|,
literal|22
block|,
name|REG
block|}
block|,
block|{
literal|"r23"
block|,
literal|23
block|,
name|REG
block|}
block|,
block|{
literal|"r24"
block|,
literal|24
block|,
name|REG
block|}
block|,
block|{
literal|"r25"
block|,
literal|25
block|,
name|REG
block|}
block|,
block|{
literal|"r26"
block|,
literal|26
block|,
name|REG
block|}
block|,
block|{
literal|"fp"
block|,
literal|27
block|,
name|REG
block|}
block|,
block|{
literal|"sp"
block|,
literal|28
block|,
name|REG
block|}
block|,
block|{
literal|"ilink1"
block|,
literal|29
block|,
name|REG
block|}
block|,
block|{
literal|"ilink2"
block|,
literal|30
block|,
name|REG
block|}
block|,
block|{
literal|"blink"
block|,
literal|31
block|,
name|REG
block|}
block|,
block|{
literal|"r32"
block|,
literal|32
block|,
name|REG
block|}
block|,
block|{
literal|"r33"
block|,
literal|33
block|,
name|REG
block|}
block|,
block|{
literal|"r34"
block|,
literal|34
block|,
name|REG
block|}
block|,
block|{
literal|"r35"
block|,
literal|35
block|,
name|REG
block|}
block|,
block|{
literal|"r36"
block|,
literal|36
block|,
name|REG
block|}
block|,
block|{
literal|"r37"
block|,
literal|37
block|,
name|REG
block|}
block|,
block|{
literal|"r38"
block|,
literal|38
block|,
name|REG
block|}
block|,
block|{
literal|"r39"
block|,
literal|39
block|,
name|REG
block|}
block|,
block|{
literal|"r40"
block|,
literal|40
block|,
name|REG
block|}
block|,
block|{
literal|"r41"
block|,
literal|41
block|,
name|REG
block|}
block|,
block|{
literal|"r42"
block|,
literal|42
block|,
name|REG
block|}
block|,
block|{
literal|"r43"
block|,
literal|43
block|,
name|REG
block|}
block|,
block|{
literal|"r44"
block|,
literal|44
block|,
name|REG
block|}
block|,
block|{
literal|"r45"
block|,
literal|45
block|,
name|REG
block|}
block|,
block|{
literal|"r46"
block|,
literal|46
block|,
name|REG
block|}
block|,
block|{
literal|"r47"
block|,
literal|47
block|,
name|REG
block|}
block|,
block|{
literal|"r48"
block|,
literal|48
block|,
name|REG
block|}
block|,
block|{
literal|"r49"
block|,
literal|49
block|,
name|REG
block|}
block|,
block|{
literal|"r50"
block|,
literal|50
block|,
name|REG
block|}
block|,
block|{
literal|"r51"
block|,
literal|51
block|,
name|REG
block|}
block|,
block|{
literal|"r52"
block|,
literal|52
block|,
name|REG
block|}
block|,
block|{
literal|"r53"
block|,
literal|53
block|,
name|REG
block|}
block|,
block|{
literal|"r54"
block|,
literal|54
block|,
name|REG
block|}
block|,
block|{
literal|"r55"
block|,
literal|55
block|,
name|REG
block|}
block|,
block|{
literal|"r56"
block|,
literal|56
block|,
name|REG
block|}
block|,
block|{
literal|"r57"
block|,
literal|57
block|,
name|REG
block|}
block|,
block|{
literal|"r58"
block|,
literal|58
block|,
name|REG
block|}
block|,
block|{
literal|"r59"
block|,
literal|59
block|,
name|REG
block|}
block|,
block|{
literal|"lp_count"
block|,
literal|60
block|,
name|REG
block|}
block|,
comment|/* I'd prefer to output these as "fp" and "sp" by default, but we still need      to recognize the canonical values.  */
block|{
literal|"r27"
block|,
literal|27
block|,
name|REG
block|}
block|,
block|{
literal|"r28"
block|,
literal|28
block|,
name|REG
block|}
block|,
comment|/* Someone may wish to refer to these in this way, and it's probably a      good idea to reserve them as such anyway.  */
block|{
literal|"r29"
block|,
literal|29
block|,
name|REG
block|}
block|,
block|{
literal|"r30"
block|,
literal|30
block|,
name|REG
block|}
block|,
block|{
literal|"r31"
block|,
literal|31
block|,
name|REG
block|}
block|,
block|{
literal|"r60"
block|,
literal|60
block|,
name|REG
block|}
block|,
comment|/* Standard auxiliary registers.  */
block|{
literal|"status"
block|,
literal|0
block|,
name|AUXREG
block|}
block|,
block|{
literal|"semaphore"
block|,
literal|1
block|,
name|AUXREG
block|}
block|,
block|{
literal|"lp_start"
block|,
literal|2
block|,
name|AUXREG
block|}
block|,
block|{
literal|"lp_end"
block|,
literal|3
block|,
name|AUXREG
block|}
block|,
block|{
literal|"identity"
block|,
literal|4
block|,
name|AUXREG
block|}
block|,
block|{
literal|"debug"
block|,
literal|5
block|,
name|AUXREG
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|arc_reg_names_count
init|=
sizeof|sizeof
argument_list|(
name|arc_reg_names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|arc_reg_names
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The suffix table.    Operands with the same name must be stored together.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|arc_operand_value
name|arc_suffixes
index|[]
init|=
block|{
comment|/* Entry 0 is special, default values aren't printed by the disassembler.  */
block|{
literal|""
block|,
literal|0
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|"al"
block|,
literal|0
block|,
name|COND
block|}
block|,
block|{
literal|"ra"
block|,
literal|0
block|,
name|COND
block|}
block|,
block|{
literal|"eq"
block|,
literal|1
block|,
name|COND
block|}
block|,
block|{
literal|"z"
block|,
literal|1
block|,
name|COND
block|}
block|,
block|{
literal|"ne"
block|,
literal|2
block|,
name|COND
block|}
block|,
block|{
literal|"nz"
block|,
literal|2
block|,
name|COND
block|}
block|,
block|{
literal|"p"
block|,
literal|3
block|,
name|COND
block|}
block|,
block|{
literal|"pl"
block|,
literal|3
block|,
name|COND
block|}
block|,
block|{
literal|"n"
block|,
literal|4
block|,
name|COND
block|}
block|,
block|{
literal|"mi"
block|,
literal|4
block|,
name|COND
block|}
block|,
block|{
literal|"c"
block|,
literal|5
block|,
name|COND
block|}
block|,
block|{
literal|"cs"
block|,
literal|5
block|,
name|COND
block|}
block|,
block|{
literal|"lo"
block|,
literal|5
block|,
name|COND
block|}
block|,
block|{
literal|"nc"
block|,
literal|6
block|,
name|COND
block|}
block|,
block|{
literal|"cc"
block|,
literal|6
block|,
name|COND
block|}
block|,
block|{
literal|"hs"
block|,
literal|6
block|,
name|COND
block|}
block|,
block|{
literal|"v"
block|,
literal|7
block|,
name|COND
block|}
block|,
block|{
literal|"vs"
block|,
literal|7
block|,
name|COND
block|}
block|,
block|{
literal|"nv"
block|,
literal|8
block|,
name|COND
block|}
block|,
block|{
literal|"vc"
block|,
literal|8
block|,
name|COND
block|}
block|,
block|{
literal|"gt"
block|,
literal|9
block|,
name|COND
block|}
block|,
block|{
literal|"ge"
block|,
literal|10
block|,
name|COND
block|}
block|,
block|{
literal|"lt"
block|,
literal|11
block|,
name|COND
block|}
block|,
block|{
literal|"le"
block|,
literal|12
block|,
name|COND
block|}
block|,
block|{
literal|"hi"
block|,
literal|13
block|,
name|COND
block|}
block|,
block|{
literal|"ls"
block|,
literal|14
block|,
name|COND
block|}
block|,
block|{
literal|"pnz"
block|,
literal|15
block|,
name|COND
block|}
block|,
block|{
literal|"f"
block|,
literal|1
block|,
name|FLAG
block|}
block|,
block|{
literal|"nd"
block|,
name|ARC_DELAY_NONE
block|,
name|DELAY
block|}
block|,
block|{
literal|"d"
block|,
name|ARC_DELAY_NORMAL
block|,
name|DELAY
block|}
block|,
block|{
literal|"jd"
block|,
name|ARC_DELAY_JUMP
block|,
name|DELAY
block|}
block|,
comment|/*{ "b", 7, SIZEEXT },*/
comment|/*{ "b", 5, SIZESEX },*/
block|{
literal|"b"
block|,
literal|1
block|,
name|SIZE1
block|}
block|,
block|{
literal|"b"
block|,
literal|1
block|,
name|SIZE10
block|}
block|,
block|{
literal|"b"
block|,
literal|1
block|,
name|SIZE22
block|}
block|,
comment|/*{ "w", 8, SIZEEXT },*/
comment|/*{ "w", 6, SIZESEX },*/
block|{
literal|"w"
block|,
literal|2
block|,
name|SIZE1
block|}
block|,
block|{
literal|"w"
block|,
literal|2
block|,
name|SIZE10
block|}
block|,
block|{
literal|"w"
block|,
literal|2
block|,
name|SIZE22
block|}
block|,
block|{
literal|"x"
block|,
literal|1
block|,
name|SIGN0
block|}
block|,
block|{
literal|"x"
block|,
literal|1
block|,
name|SIGN9
block|}
block|,
block|{
literal|"a"
block|,
literal|1
block|,
name|ADDRESS3
block|}
block|,
block|{
literal|"a"
block|,
literal|1
block|,
name|ADDRESS12
block|}
block|,
block|{
literal|"a"
block|,
literal|1
block|,
name|ADDRESS24
block|}
block|,
block|{
literal|"di"
block|,
literal|1
block|,
name|CACHEBYPASS5
block|}
block|,
block|{
literal|"di"
block|,
literal|1
block|,
name|CACHEBYPASS14
block|}
block|,
block|{
literal|"di"
block|,
literal|1
block|,
name|CACHEBYPASS26
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|arc_suffixes_count
init|=
sizeof|sizeof
argument_list|(
name|arc_suffixes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|arc_suffixes
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by first letter of opcode.  Points to chain of opcodes with same    first letter.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|arc_opcode
modifier|*
name|opcode_map
index|[
literal|26
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by insn code.  Points to chain of opcodes with same insn code.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|arc_opcode
modifier|*
name|icode_map
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Configuration flags.  */
end_comment

begin_comment
comment|/* Various ARC_HAVE_XXX bits.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cpu_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Translate a bfd_mach_arc_xxx value to a ARC_MACH_XXX value.  */
end_comment

begin_function
name|int
name|arc_get_opcode_mach
parameter_list|(
name|bfd_mach
parameter_list|,
name|big_p
parameter_list|)
name|int
name|bfd_mach
decl_stmt|,
name|big_p
decl_stmt|;
block|{
specifier|static
name|int
name|mach_type_map
index|[]
init|=
block|{
name|ARC_MACH_BASE
block|}
decl_stmt|;
return|return
name|mach_type_map
index|[
name|bfd_mach
index|]
operator||
operator|(
name|big_p
condition|?
name|ARC_MACH_BIG
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize any tables that need it.    Must be called once at start up (or when first needed).     FLAGS is a set of bits that say what version of the cpu we have,    and in particular at least (one of) ARC_MACH_XXX.  */
end_comment

begin_function
name|void
name|arc_opcode_init_tables
parameter_list|(
name|flags
parameter_list|)
name|int
name|flags
decl_stmt|;
block|{
specifier|static
name|int
name|init_p
init|=
literal|0
decl_stmt|;
name|cpu_type
operator|=
name|flags
expr_stmt|;
comment|/* We may be intentionally called more than once (for example gdb will call      us each time the user switches cpu).  These tables only need to be init'd      once though.  */
comment|/* ??? We can remove the need for arc_opcode_supported by taking it into      account here, but I'm not sure I want to do that yet (if ever).  */
if|if
condition|(
operator|!
name|init_p
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|memset
argument_list|(
name|arc_operand_map
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_operand_map
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
sizeof|sizeof
argument_list|(
name|arc_operands
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|arc_operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|arc_operand_map
index|[
name|arc_operands
index|[
name|i
index|]
operator|.
name|fmt
index|]
operator|=
name|i
expr_stmt|;
name|memset
argument_list|(
name|opcode_map
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opcode_map
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|icode_map
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|icode_map
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Scan the table backwards so macros appear at the front.  */
for|for
control|(
name|i
operator|=
name|arc_opcodes_count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|int
name|opcode_hash
init|=
name|ARC_HASH_OPCODE
argument_list|(
name|arc_opcodes
index|[
name|i
index|]
operator|.
name|syntax
argument_list|)
decl_stmt|;
name|int
name|icode_hash
init|=
name|ARC_HASH_ICODE
argument_list|(
name|arc_opcodes
index|[
name|i
index|]
operator|.
name|value
argument_list|)
decl_stmt|;
name|arc_opcodes
index|[
name|i
index|]
operator|.
name|next_asm
operator|=
name|opcode_map
index|[
name|opcode_hash
index|]
expr_stmt|;
name|opcode_map
index|[
name|opcode_hash
index|]
operator|=
operator|&
name|arc_opcodes
index|[
name|i
index|]
expr_stmt|;
name|arc_opcodes
index|[
name|i
index|]
operator|.
name|next_dis
operator|=
name|icode_map
index|[
name|icode_hash
index|]
expr_stmt|;
name|icode_map
index|[
name|icode_hash
index|]
operator|=
operator|&
name|arc_opcodes
index|[
name|i
index|]
expr_stmt|;
block|}
name|init_p
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return non-zero if OPCODE is supported on the specified cpu.    Cpu selection is made when calling `arc_opcode_init_tables'.  */
end_comment

begin_function
name|int
name|arc_opcode_supported
parameter_list|(
name|opcode
parameter_list|)
specifier|const
name|struct
name|arc_opcode
modifier|*
name|opcode
decl_stmt|;
block|{
if|if
condition|(
name|ARC_OPCODE_CPU
argument_list|(
name|opcode
operator|->
name|flags
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ARC_OPCODE_CPU
argument_list|(
name|opcode
operator|->
name|flags
argument_list|)
operator|&
name|ARC_HAVE_CPU
argument_list|(
name|cpu_type
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if OPVAL is supported on the specified cpu.    Cpu selection is made when calling `arc_opcode_init_tables'.  */
end_comment

begin_function
name|int
name|arc_opval_supported
parameter_list|(
name|opval
parameter_list|)
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|opval
decl_stmt|;
block|{
if|if
condition|(
name|ARC_OPVAL_CPU
argument_list|(
name|opval
operator|->
name|flags
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|ARC_OPVAL_CPU
argument_list|(
name|opval
operator|->
name|flags
argument_list|)
operator|&
name|ARC_HAVE_CPU
argument_list|(
name|cpu_type
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the first insn in the chain for assembling INSN.  */
end_comment

begin_function
specifier|const
name|struct
name|arc_opcode
modifier|*
name|arc_opcode_lookup_asm
parameter_list|(
name|insn
parameter_list|)
specifier|const
name|char
modifier|*
name|insn
decl_stmt|;
block|{
return|return
name|opcode_map
index|[
name|ARC_HASH_OPCODE
argument_list|(
name|insn
argument_list|)
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the first insn in the chain for disassembling INSN.  */
end_comment

begin_function
specifier|const
name|struct
name|arc_opcode
modifier|*
name|arc_opcode_lookup_dis
parameter_list|(
name|insn
parameter_list|)
name|unsigned
name|int
name|insn
decl_stmt|;
block|{
return|return
name|icode_map
index|[
name|ARC_HASH_ICODE
argument_list|(
name|insn
argument_list|)
index|]
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if we've seen an 'f' suffix (in certain insns).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we've finished processing the 'f' suffix.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flagshimm_handled_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we've seen a 'q' suffix (condition code).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cond_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we've inserted a shimm.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|shimm_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The value of the shimm we inserted (each insn only gets one but it can    appear multiple times.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|shimm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we've inserted a limm (during assembly) or seen a limm    (during disassembly).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|limm_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The value of the limm we inserted.  Each insn only gets one but it can    appear multiple times.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|limm
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Insertion functions.  */
end_comment

begin_comment
comment|/* Called by the assembler before parsing an instruction.  */
end_comment

begin_function
name|void
name|arc_opcode_init_insert
parameter_list|()
block|{
name|flag_p
operator|=
literal|0
expr_stmt|;
name|flagshimm_handled_p
operator|=
literal|0
expr_stmt|;
name|cond_p
operator|=
literal|0
expr_stmt|;
name|shimm_p
operator|=
literal|0
expr_stmt|;
name|limm_p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called by the assembler to see if the insn has a limm operand.    Also called by the disassembler to see if the insn contains a limm.  */
end_comment

begin_function
name|int
name|arc_opcode_limm_p
parameter_list|(
name|limmp
parameter_list|)
name|long
modifier|*
name|limmp
decl_stmt|;
block|{
if|if
condition|(
name|limmp
condition|)
operator|*
name|limmp
operator|=
name|limm
expr_stmt|;
return|return
name|limm_p
return|;
block|}
end_function

begin_comment
comment|/* Insert a value into a register field.    If REG is NULL, then this is actually a constant.     We must also handle auxiliary registers for lr/sr insns.  */
end_comment

begin_function
specifier|static
name|arc_insn
name|insert_reg
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
decl_stmt|;
name|long
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL
condition|)
block|{
comment|/* We have a constant that also requires a value stored in a register 	 field.  Handle these by updating the register field and saving the 	 value for later handling by either %S (shimm) or %L (limm).  */
comment|/* Try to use a shimm value before a limm one.  */
if|if
condition|(
name|ARC_SHIMM_CONST_P
argument_list|(
name|value
argument_list|)
comment|/* If we've seen a conditional suffix we have to use a limm.  */
operator|&&
operator|!
name|cond_p
comment|/* If we already have a shimm value that is different than ours 	     we have to use a limm.  */
operator|&&
operator|(
operator|!
name|shimm_p
operator|||
name|shimm
operator|==
name|value
operator|)
condition|)
block|{
name|int
name|marker
init|=
name|flag_p
condition|?
name|ARC_REG_SHIMM_UPDATE
else|:
name|ARC_REG_SHIMM
decl_stmt|;
name|flagshimm_handled_p
operator|=
literal|1
expr_stmt|;
name|shimm_p
operator|=
literal|1
expr_stmt|;
name|shimm
operator|=
name|value
expr_stmt|;
name|insn
operator||=
name|marker
operator|<<
name|operand
operator|->
name|shift
expr_stmt|;
comment|/* insn |= value& 511; - done later */
block|}
comment|/* We have to use a limm.  If we've already seen one they must match.  */
elseif|else
if|if
condition|(
operator|!
name|limm_p
operator|||
name|limm
operator|==
name|value
condition|)
block|{
name|limm_p
operator|=
literal|1
expr_stmt|;
name|limm
operator|=
name|value
expr_stmt|;
name|insn
operator||=
name|ARC_REG_LIMM
operator|<<
name|operand
operator|->
name|shift
expr_stmt|;
comment|/* The constant is stored later.  */
block|}
else|else
block|{
operator|*
name|errmsg
operator|=
name|_
argument_list|(
literal|"unable to fit different valued constants into instruction"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We have to handle both normal and auxiliary registers.  */
if|if
condition|(
name|reg
operator|->
name|type
operator|==
name|AUXREG
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|mods
operator|&
name|ARC_MOD_AUXREG
operator|)
condition|)
operator|*
name|errmsg
operator|=
name|_
argument_list|(
literal|"auxiliary register not allowed here"
argument_list|)
expr_stmt|;
else|else
block|{
name|insn
operator||=
name|ARC_REG_SHIMM
operator|<<
name|operand
operator|->
name|shift
expr_stmt|;
name|insn
operator||=
name|reg
operator|->
name|value
operator|<<
name|arc_operands
index|[
name|reg
operator|->
name|type
index|]
operator|.
name|shift
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We should never get an invalid register number here.  */
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|reg
operator|->
name|value
operator|>
literal|60
condition|)
block|{
comment|/* xgettext:c-format */
name|sprintf
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"invalid register number `%d'"
argument_list|)
argument_list|,
name|reg
operator|->
name|value
argument_list|)
expr_stmt|;
operator|*
name|errmsg
operator|=
name|buf
expr_stmt|;
block|}
else|else
name|insn
operator||=
name|reg
operator|->
name|value
operator|<<
name|operand
operator|->
name|shift
expr_stmt|;
block|}
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Called when we see an 'f' flag.  */
end_comment

begin_function
specifier|static
name|arc_insn
name|insert_flag
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
decl_stmt|;
name|long
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
decl_stmt|;
block|{
comment|/* We can't store anything in the insn until we've parsed the registers.      Just record the fact that we've got this flag.  `insert_reg' will use it      to store the correct value (ARC_REG_SHIMM_UPDATE or bit 0x100).  */
name|flag_p
operator|=
literal|1
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Called after completely building an insn to ensure the 'f' flag gets set    properly.  This is needed because we don't know how to set this flag until    we've parsed the registers.  */
end_comment

begin_function
specifier|static
name|arc_insn
name|insert_flagfinish
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
decl_stmt|;
name|long
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
decl_stmt|;
block|{
if|if
condition|(
name|flag_p
operator|&&
operator|!
name|flagshimm_handled_p
condition|)
block|{
if|if
condition|(
name|shimm_p
condition|)
name|abort
argument_list|()
expr_stmt|;
name|flagshimm_handled_p
operator|=
literal|1
expr_stmt|;
name|insn
operator||=
operator|(
literal|1
operator|<<
name|operand
operator|->
name|shift
operator|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Called when we see a conditional flag (eg: .eq).  */
end_comment

begin_function
specifier|static
name|arc_insn
name|insert_cond
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
decl_stmt|;
name|long
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
decl_stmt|;
block|{
name|cond_p
operator|=
literal|1
expr_stmt|;
name|insn
operator||=
operator|(
name|value
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|operand
operator|->
name|shift
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Used in the "j" instruction to prevent constants from being interpreted as    shimm values (which the jump insn doesn't accept).  This can also be used    to force the use of limm values in other situations (eg: ld r0,[foo] uses    this).    ??? The mechanism is sound.  Access to it is a bit klunky right now.  */
end_comment

begin_function
specifier|static
name|arc_insn
name|insert_forcelimm
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
decl_stmt|;
name|long
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
decl_stmt|;
block|{
name|cond_p
operator|=
literal|1
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Used in ld/st insns to handle the shimm offset field.  */
end_comment

begin_function
specifier|static
name|arc_insn
name|insert_shimmoffset
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
decl_stmt|;
name|long
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
decl_stmt|;
block|{
name|long
name|minval
decl_stmt|,
name|maxval
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|reg
operator|!=
name|NULL
condition|)
block|{
operator|*
name|errmsg
operator|=
literal|"register appears where shimm value expected"
expr_stmt|;
block|}
else|else
block|{
comment|/* This is *way* more general than necessary, but maybe some day it'll 	 be useful.  */
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_SIGNED
condition|)
block|{
name|minval
operator|=
operator|-
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|maxval
operator|=
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|minval
operator|=
literal|0
expr_stmt|;
name|maxval
operator|=
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|<
name|minval
operator|||
name|value
operator|>
name|maxval
condition|)
block|{
comment|/* xgettext:c-format */
name|sprintf
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"value won't fit in range %ld - %ld"
argument_list|)
argument_list|,
name|minval
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
operator|*
name|errmsg
operator|=
name|buf
expr_stmt|;
block|}
else|else
name|insn
operator||=
operator|(
name|value
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|operand
operator|->
name|shift
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Used in ld/st insns when the shimm offset is 0.  */
end_comment

begin_function
specifier|static
name|arc_insn
name|insert_shimmzero
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
decl_stmt|;
name|long
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
decl_stmt|;
block|{
name|shimm_p
operator|=
literal|1
expr_stmt|;
name|shimm
operator|=
literal|0
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Called at the end of processing normal insns (eg: add) to insert a shimm    value (if present) into the insn.  */
end_comment

begin_function
specifier|static
name|arc_insn
name|insert_shimmfinish
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
decl_stmt|;
name|long
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
decl_stmt|;
block|{
if|if
condition|(
name|shimm_p
condition|)
name|insn
operator||=
operator|(
name|shimm
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|operand
operator|->
name|shift
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Called at the end of processing normal insns (eg: add) to insert a limm    value (if present) into the insn.     Note that this function is only intended to handle instructions (with 4 byte    immediate operands).  It is not intended to handle data.  */
end_comment

begin_comment
comment|/* ??? Actually, there's nothing for us to do as we can't call frag_more, the    caller must do that.  The extract fns take a pointer to two words.  The    insert fns could be converted and then we could do something useful, but    then the reloc handlers would have to know to work on the second word of    a 2 word quantity.  That's too much so we don't handle them.  */
end_comment

begin_function
specifier|static
name|arc_insn
name|insert_limmfinish
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
decl_stmt|;
name|long
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
decl_stmt|;
block|{
if|if
condition|(
name|limm_p
condition|)
empty_stmt|;
comment|/* nothing to do, gas does it */
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Called at the end of unary operand macros to copy the B field to C.  */
end_comment

begin_function
specifier|static
name|arc_insn
name|insert_unopmacro
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
decl_stmt|;
name|long
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
decl_stmt|;
block|{
name|insn
operator||=
operator|(
operator|(
name|insn
operator|>>
name|ARC_SHIFT_REGB
operator|)
operator|&
name|ARC_MASK_REG
operator|)
operator|<<
name|operand
operator|->
name|shift
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Insert a relative address for a branch insn (b, bl, or lp).  */
end_comment

begin_function
specifier|static
name|arc_insn
name|insert_reladdr
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
decl_stmt|;
name|long
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
decl_stmt|;
block|{
if|if
condition|(
name|value
operator|&
literal|3
condition|)
operator|*
name|errmsg
operator|=
name|_
argument_list|(
literal|"branch address not on 4 byte boundary"
argument_list|)
expr_stmt|;
name|insn
operator||=
operator|(
operator|(
name|value
operator|>>
literal|2
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|operand
operator|->
name|shift
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Insert a limm value as a 26 bit address right shifted 2 into the insn.     Note that this function is only intended to handle instructions (with 4 byte    immediate operands).  It is not intended to handle data.  */
end_comment

begin_comment
comment|/* ??? Actually, there's nothing for us to do as we can't call frag_more, the    caller must do that.  The extract fns take a pointer to two words.  The    insert fns could be converted and then we could do something useful, but    then the reloc handlers would have to know to work on the second word of    a 2 word quantity.  That's too much so we don't handle them.  */
end_comment

begin_function
specifier|static
name|arc_insn
name|insert_absaddr
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
decl_stmt|;
name|long
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
decl_stmt|;
block|{
if|if
condition|(
name|limm_p
condition|)
empty_stmt|;
comment|/* nothing to do */
return|return
name|insn
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Extraction functions.     The suffix extraction functions' return value is redundant since it can be    obtained from (*OPVAL)->value.  However, the boolean suffixes don't have    a suffix table entry for the "false" case, so values of zero must be    obtained from the return value (*OPVAL == NULL).  */
end_comment

begin_function_decl
specifier|static
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|lookup_register
parameter_list|(
name|int
name|type
parameter_list|,
name|long
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Called by the disassembler before printing an instruction.  */
end_comment

begin_function
name|void
name|arc_opcode_init_extract
parameter_list|()
block|{
name|flag_p
operator|=
literal|0
expr_stmt|;
name|flagshimm_handled_p
operator|=
literal|0
expr_stmt|;
name|shimm_p
operator|=
literal|0
expr_stmt|;
name|limm_p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* As we're extracting registers, keep an eye out for the 'f' indicator    (ARC_REG_SHIMM_UPDATE).  If we find a register (not a constant marker,    like ARC_REG_SHIMM), set OPVAL so our caller will know this is a register.     We must also handle auxiliary registers for lr/sr insns.  They are just    constants with special names.  */
end_comment

begin_function
specifier|static
name|long
name|extract_reg
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|opval
parameter_list|,
name|invalid
parameter_list|)
name|arc_insn
modifier|*
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
modifier|*
name|opval
decl_stmt|;
name|int
modifier|*
name|invalid
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
name|long
name|value
decl_stmt|;
comment|/* Get the register number.  */
name|regno
operator|=
operator|(
name|insn
index|[
literal|0
index|]
operator|>>
name|operand
operator|->
name|shift
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Is it a constant marker?  */
if|if
condition|(
name|regno
operator|==
name|ARC_REG_SHIMM
condition|)
block|{
name|value
operator|=
name|insn
index|[
literal|0
index|]
operator|&
literal|511
expr_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_SIGNED
operator|)
operator|&&
operator|(
name|value
operator|&
literal|256
operator|)
condition|)
name|value
operator|-=
literal|512
expr_stmt|;
name|flagshimm_handled_p
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
name|ARC_REG_SHIMM_UPDATE
condition|)
block|{
name|value
operator|=
name|insn
index|[
literal|0
index|]
operator|&
literal|511
expr_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_SIGNED
operator|)
operator|&&
operator|(
name|value
operator|&
literal|256
operator|)
condition|)
name|value
operator|-=
literal|512
expr_stmt|;
name|flag_p
operator|=
literal|1
expr_stmt|;
name|flagshimm_handled_p
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
name|ARC_REG_LIMM
condition|)
block|{
name|value
operator|=
name|insn
index|[
literal|1
index|]
expr_stmt|;
name|limm_p
operator|=
literal|1
expr_stmt|;
block|}
comment|/* It's a register, set OPVAL (that's the only way we distinguish registers      from constants here).  */
else|else
block|{
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
init|=
name|lookup_register
argument_list|(
name|REG
argument_list|,
name|regno
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|opval
operator|!=
name|NULL
condition|)
operator|*
name|opval
operator|=
name|reg
expr_stmt|;
name|value
operator|=
name|regno
expr_stmt|;
block|}
comment|/* If this field takes an auxiliary register, see if it's a known one.  */
if|if
condition|(
operator|(
name|mods
operator|&
name|ARC_MOD_AUXREG
operator|)
operator|&&
name|ARC_REG_CONSTANT_P
argument_list|(
name|regno
argument_list|)
condition|)
block|{
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
init|=
name|lookup_register
argument_list|(
name|AUXREG
argument_list|,
name|value
argument_list|)
decl_stmt|;
comment|/* This is really a constant, but tell the caller it has a special 	 name.  */
if|if
condition|(
name|reg
operator|!=
name|NULL
operator|&&
name|opval
operator|!=
name|NULL
condition|)
operator|*
name|opval
operator|=
name|reg
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Return the value of the "flag update" field for shimm insns.    This value is actually stored in the register field.  */
end_comment

begin_function
specifier|static
name|long
name|extract_flag
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|opval
parameter_list|,
name|invalid
parameter_list|)
name|arc_insn
modifier|*
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
modifier|*
name|opval
decl_stmt|;
name|int
modifier|*
name|invalid
decl_stmt|;
block|{
name|int
name|f
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|val
decl_stmt|;
if|if
condition|(
name|flagshimm_handled_p
condition|)
name|f
operator|=
name|flag_p
operator|!=
literal|0
expr_stmt|;
else|else
name|f
operator|=
operator|(
name|insn
index|[
literal|0
index|]
operator|&
operator|(
literal|1
operator|<<
name|operand
operator|->
name|shift
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* There is no text for zero values.  */
if|if
condition|(
name|f
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|val
operator|=
name|arc_opcode_lookup_suffix
argument_list|(
name|operand
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|opval
operator|!=
name|NULL
operator|&&
name|val
operator|!=
name|NULL
condition|)
operator|*
name|opval
operator|=
name|val
expr_stmt|;
return|return
name|val
operator|->
name|value
return|;
block|}
end_function

begin_comment
comment|/* Extract the condition code (if it exists).    If we've seen a shimm value in this insn (meaning that the insn can't have    a condition code field), then we don't store anything in OPVAL and return    zero.  */
end_comment

begin_function
specifier|static
name|long
name|extract_cond
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|opval
parameter_list|,
name|invalid
parameter_list|)
name|arc_insn
modifier|*
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
modifier|*
name|opval
decl_stmt|;
name|int
modifier|*
name|invalid
decl_stmt|;
block|{
name|long
name|cond
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|val
decl_stmt|;
if|if
condition|(
name|flagshimm_handled_p
condition|)
return|return
literal|0
return|;
name|cond
operator|=
operator|(
name|insn
index|[
literal|0
index|]
operator|>>
name|operand
operator|->
name|shift
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|val
operator|=
name|arc_opcode_lookup_suffix
argument_list|(
name|operand
argument_list|,
name|cond
argument_list|)
expr_stmt|;
comment|/* Ignore NULL values of `val'.  Several condition code values are      reserved for extensions.  */
if|if
condition|(
name|opval
operator|!=
name|NULL
operator|&&
name|val
operator|!=
name|NULL
condition|)
operator|*
name|opval
operator|=
name|val
expr_stmt|;
return|return
name|cond
return|;
block|}
end_function

begin_comment
comment|/* Extract a branch address.    We return the value as a real address (not right shifted by 2).  */
end_comment

begin_function
specifier|static
name|long
name|extract_reladdr
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|opval
parameter_list|,
name|invalid
parameter_list|)
name|arc_insn
modifier|*
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
modifier|*
name|opval
decl_stmt|;
name|int
modifier|*
name|invalid
decl_stmt|;
block|{
name|long
name|addr
decl_stmt|;
name|addr
operator|=
operator|(
name|insn
index|[
literal|0
index|]
operator|>>
name|operand
operator|->
name|shift
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_SIGNED
operator|)
operator|&&
operator|(
name|addr
operator|&
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|addr
operator|-=
literal|1
operator|<<
name|operand
operator|->
name|bits
expr_stmt|;
return|return
name|addr
operator|<<
literal|2
return|;
block|}
end_function

begin_comment
comment|/* The only thing this does is set the `invalid' flag if B != C.    This is needed because the "mov" macro appears before it's real insn "and"    and we don't want the disassembler to confuse them.  */
end_comment

begin_function
specifier|static
name|long
name|extract_unopmacro
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|opval
parameter_list|,
name|invalid
parameter_list|)
name|arc_insn
modifier|*
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
modifier|*
name|opval
decl_stmt|;
name|int
modifier|*
name|invalid
decl_stmt|;
block|{
comment|/* This misses the case where B == ARC_REG_SHIMM_UPDATE&&      C == ARC_REG_SHIMM (or vice versa).  No big deal.  Those insns will get      printed as "and"s.  */
if|if
condition|(
operator|(
operator|(
name|insn
index|[
literal|0
index|]
operator|>>
name|ARC_SHIFT_REGB
operator|)
operator|&
name|ARC_MASK_REG
operator|)
operator|!=
operator|(
operator|(
name|insn
index|[
literal|0
index|]
operator|>>
name|ARC_SHIFT_REGC
operator|)
operator|&
name|ARC_MASK_REG
operator|)
condition|)
if|if
condition|(
name|invalid
operator|!=
name|NULL
condition|)
operator|*
name|invalid
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Utility for the extraction functions to return the index into    `arc_suffixes'.  */
end_comment

begin_function
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|arc_opcode_lookup_suffix
parameter_list|(
name|type
parameter_list|,
name|value
parameter_list|)
specifier|const
name|struct
name|arc_operand
modifier|*
name|type
decl_stmt|;
name|int
name|value
decl_stmt|;
block|{
specifier|register
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|v
decl_stmt|,
modifier|*
name|end
decl_stmt|;
comment|/* ??? This is a little slow and can be speeded up.  */
for|for
control|(
name|v
operator|=
name|arc_suffixes
operator|,
name|end
operator|=
name|arc_suffixes
operator|+
name|arc_suffixes_count
init|;
name|v
operator|<
name|end
condition|;
operator|++
name|v
control|)
if|if
condition|(
name|type
operator|==
operator|&
name|arc_operands
index|[
name|v
operator|->
name|type
index|]
operator|&&
name|value
operator|==
name|v
operator|->
name|value
condition|)
return|return
name|v
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|lookup_register
parameter_list|(
name|type
parameter_list|,
name|regno
parameter_list|)
name|int
name|type
decl_stmt|;
name|long
name|regno
decl_stmt|;
block|{
specifier|register
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|r
decl_stmt|,
modifier|*
name|end
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|REG
condition|)
return|return
operator|&
name|arc_reg_names
index|[
name|regno
index|]
return|;
comment|/* ??? This is a little slow and can be speeded up.  */
for|for
control|(
name|r
operator|=
name|arc_reg_names
operator|,
name|end
operator|=
name|arc_reg_names
operator|+
name|arc_reg_names_count
init|;
name|r
operator|<
name|end
condition|;
operator|++
name|r
control|)
if|if
condition|(
name|type
operator|==
name|r
operator|->
name|type
operator|&&
name|regno
operator|==
name|r
operator|->
name|value
condition|)
return|return
name|r
return|;
return|return
literal|0
return|;
block|}
end_function

end_unit

