begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Opcode table for the ARC.    Copyright 1994, 1995, 1997, 1998, 2000, 2001    Free Software Foundation, Inc.    Contributed by Doug Evans (dje@cygnus.com).     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"opcode/arc.h"
end_include

begin_define
define|#
directive|define
name|INSERT_FN
parameter_list|(
name|fn
parameter_list|)
define|\
value|static arc_insn fn PARAMS ((arc_insn, const struct arc_operand *, \ 			    int, const struct arc_operand_value *, long, \ 			    const char **))
end_define

begin_define
define|#
directive|define
name|EXTRACT_FN
parameter_list|(
name|fn
parameter_list|)
define|\
value|static long fn PARAMS ((arc_insn *, const struct arc_operand *, \ 			int, const struct arc_operand_value **, int *))
end_define

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_reg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_shimmfinish
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_limmfinish
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_offset
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_base
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_st_syntax
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_ld_syntax
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_addr_wb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_flag
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_nullify
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_flagfinish
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_cond
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_forcelimm
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_reladdr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_absaddr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_jumpflags
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|INSERT_FN
argument_list|(
name|insert_unopmacro
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXTRACT_FN
argument_list|(
name|extract_reg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXTRACT_FN
argument_list|(
name|extract_ld_offset
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXTRACT_FN
argument_list|(
name|extract_ld_syntax
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXTRACT_FN
argument_list|(
name|extract_st_offset
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXTRACT_FN
argument_list|(
name|extract_st_syntax
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXTRACT_FN
argument_list|(
name|extract_flag
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXTRACT_FN
argument_list|(
name|extract_cond
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXTRACT_FN
argument_list|(
name|extract_reladdr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXTRACT_FN
argument_list|(
name|extract_jumpflags
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXTRACT_FN
argument_list|(
name|extract_unopmacro
argument_list|)
expr_stmt|;
end_expr_stmt

begin_enum
enum|enum
name|operand
block|{
name|OP_NONE
block|,
name|OP_REG
block|,
name|OP_SHIMM
block|,
name|OP_LIMM
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|OPERANDS
value|3
end_define

begin_decl_stmt
name|enum
name|operand
name|ls_operand
index|[
name|OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|arc_opcode
modifier|*
name|arc_ext_opcodes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|arc_ext_operand_value
modifier|*
name|arc_ext_operands
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LS_VALUE
value|0
end_define

begin_define
define|#
directive|define
name|LS_DEST
value|0
end_define

begin_define
define|#
directive|define
name|LS_BASE
value|1
end_define

begin_define
define|#
directive|define
name|LS_OFFSET
value|2
end_define

begin_comment
comment|/* Various types of ARC operands, including insn suffixes.  */
end_comment

begin_comment
comment|/* Insn format values:     'a'	REGA		register A field    'b'	REGB		register B field    'c'	REGC		register C field    'S'	SHIMMFINISH	finish inserting a shimm value    'L'	LIMMFINISH	finish inserting a limm value    'o'	OFFSET		offset in st insns    'O'	OFFSET		offset in ld insns    '0'	SYNTAX_ST_NE	enforce store insn syntax, no errors    '1'	SYNTAX_LD_NE	enforce load insn syntax, no errors    '2'  SYNTAX_ST       enforce store insn syntax, errors, last pattern only    '3'  SYNTAX_LD       enforce load insn syntax, errors, last pattern only    's'  BASE            base in st insn    'f'	FLAG		F flag    'F'	FLAGFINISH	finish inserting the F flag    'G'	FLAGINSN	insert F flag in "flag" insn    'n'	DELAY		N field (nullify field)    'q'	COND		condition code field    'Q'	FORCELIMM	set `cond_p' to 1 to ensure a constant is a limm    'B'	BRANCH		branch address (22 bit pc relative)    'J'	JUMP		jump address (26 bit absolute)    'j'  JUMPFLAGS       optional high order bits of 'J'    'z'	SIZE1		size field in ld a,[b,c]    'Z'	SIZE10		size field in ld a,[b,shimm]    'y'	SIZE22		size field in st c,[b,shimm]    'x'	SIGN0		sign extend field ld a,[b,c]    'X'	SIGN9		sign extend field ld a,[b,shimm]    'w'	ADDRESS3	write-back field in ld a,[b,c]    'W'	ADDRESS12	write-back field in ld a,[b,shimm]    'v'	ADDRESS24	write-back field in st c,[b,shimm]    'e'	CACHEBYPASS5	cache bypass in ld a,[b,c]    'E'	CACHEBYPASS14	cache bypass in ld a,[b,shimm]    'D'	CACHEBYPASS26	cache bypass in st c,[b,shimm]    'U'	UNOPMACRO	fake operand to copy REGB to REGC for unop macros     The following modifiers may appear between the % and char (eg: %.f):     '.'	MODDOT		'.' prefix must be present    'r'	REG		generic register value, for register table    'A'	AUXREG		auxiliary register in lr a,[b], sr c,[b]     Fields are:     CHAR BITS SHIFT FLAGS INSERT_FN EXTRACT_FN  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|arc_operand
name|arc_operands
index|[]
init|=
block|{
comment|/* place holder (??? not sure if needed).  */
define|#
directive|define
name|UNUSED
value|0
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* register A or shimm/limm indicator.  */
define|#
directive|define
name|REGA
value|(UNUSED + 1)
block|{
literal|'a'
block|,
literal|6
block|,
name|ARC_SHIFT_REGA
block|,
name|ARC_OPERAND_SIGNED
operator||
name|ARC_OPERAND_ERROR
block|,
name|insert_reg
block|,
name|extract_reg
block|}
block|,
comment|/* register B or shimm/limm indicator.  */
define|#
directive|define
name|REGB
value|(REGA + 1)
block|{
literal|'b'
block|,
literal|6
block|,
name|ARC_SHIFT_REGB
block|,
name|ARC_OPERAND_SIGNED
operator||
name|ARC_OPERAND_ERROR
block|,
name|insert_reg
block|,
name|extract_reg
block|}
block|,
comment|/* register C or shimm/limm indicator.  */
define|#
directive|define
name|REGC
value|(REGB + 1)
block|{
literal|'c'
block|,
literal|6
block|,
name|ARC_SHIFT_REGC
block|,
name|ARC_OPERAND_SIGNED
operator||
name|ARC_OPERAND_ERROR
block|,
name|insert_reg
block|,
name|extract_reg
block|}
block|,
comment|/* fake operand used to insert shimm value into most instructions.  */
define|#
directive|define
name|SHIMMFINISH
value|(REGC + 1)
block|{
literal|'S'
block|,
literal|9
block|,
literal|0
block|,
name|ARC_OPERAND_SIGNED
operator|+
name|ARC_OPERAND_FAKE
block|,
name|insert_shimmfinish
block|,
literal|0
block|}
block|,
comment|/* fake operand used to insert limm value into most instructions.  */
define|#
directive|define
name|LIMMFINISH
value|(SHIMMFINISH + 1)
block|{
literal|'L'
block|,
literal|32
block|,
literal|32
block|,
name|ARC_OPERAND_ADDRESS
operator|+
name|ARC_OPERAND_LIMM
operator|+
name|ARC_OPERAND_FAKE
block|,
name|insert_limmfinish
block|,
literal|0
block|}
block|,
comment|/* shimm operand when there is no reg indicator (st).  */
define|#
directive|define
name|ST_OFFSET
value|(LIMMFINISH + 1)
block|{
literal|'o'
block|,
literal|9
block|,
literal|0
block|,
name|ARC_OPERAND_LIMM
operator||
name|ARC_OPERAND_SIGNED
operator||
name|ARC_OPERAND_STORE
block|,
name|insert_offset
block|,
name|extract_st_offset
block|}
block|,
comment|/* shimm operand when there is no reg indicator (ld).  */
define|#
directive|define
name|LD_OFFSET
value|(ST_OFFSET + 1)
block|{
literal|'O'
block|,
literal|9
block|,
literal|0
block|,
name|ARC_OPERAND_LIMM
operator||
name|ARC_OPERAND_SIGNED
operator||
name|ARC_OPERAND_LOAD
block|,
name|insert_offset
block|,
name|extract_ld_offset
block|}
block|,
comment|/* operand for base.  */
define|#
directive|define
name|BASE
value|(LD_OFFSET + 1)
block|{
literal|'s'
block|,
literal|6
block|,
name|ARC_SHIFT_REGB
block|,
name|ARC_OPERAND_LIMM
operator||
name|ARC_OPERAND_SIGNED
block|,
name|insert_base
block|,
name|extract_reg
block|}
block|,
comment|/* 0 enforce syntax for st insns.  */
define|#
directive|define
name|SYNTAX_ST_NE
value|(BASE + 1)
block|{
literal|'0'
block|,
literal|9
block|,
literal|0
block|,
name|ARC_OPERAND_FAKE
block|,
name|insert_st_syntax
block|,
name|extract_st_syntax
block|}
block|,
comment|/* 1 enforce syntax for ld insns.  */
define|#
directive|define
name|SYNTAX_LD_NE
value|(SYNTAX_ST_NE + 1)
block|{
literal|'1'
block|,
literal|9
block|,
literal|0
block|,
name|ARC_OPERAND_FAKE
block|,
name|insert_ld_syntax
block|,
name|extract_ld_syntax
block|}
block|,
comment|/* 0 enforce syntax for st insns.  */
define|#
directive|define
name|SYNTAX_ST
value|(SYNTAX_LD_NE + 1)
block|{
literal|'2'
block|,
literal|9
block|,
literal|0
block|,
name|ARC_OPERAND_FAKE
operator||
name|ARC_OPERAND_ERROR
block|,
name|insert_st_syntax
block|,
name|extract_st_syntax
block|}
block|,
comment|/* 0 enforce syntax for ld insns.  */
define|#
directive|define
name|SYNTAX_LD
value|(SYNTAX_ST + 1)
block|{
literal|'3'
block|,
literal|9
block|,
literal|0
block|,
name|ARC_OPERAND_FAKE
operator||
name|ARC_OPERAND_ERROR
block|,
name|insert_ld_syntax
block|,
name|extract_ld_syntax
block|}
block|,
comment|/* flag update bit (insertion is defered until we know how).  */
define|#
directive|define
name|FLAG
value|(SYNTAX_LD + 1)
block|{
literal|'f'
block|,
literal|1
block|,
literal|8
block|,
name|ARC_OPERAND_SUFFIX
block|,
name|insert_flag
block|,
name|extract_flag
block|}
block|,
comment|/* fake utility operand to finish 'f' suffix handling.  */
define|#
directive|define
name|FLAGFINISH
value|(FLAG + 1)
block|{
literal|'F'
block|,
literal|1
block|,
literal|8
block|,
name|ARC_OPERAND_FAKE
block|,
name|insert_flagfinish
block|,
literal|0
block|}
block|,
comment|/* fake utility operand to set the 'f' flag for the "flag" insn.  */
define|#
directive|define
name|FLAGINSN
value|(FLAGFINISH + 1)
block|{
literal|'G'
block|,
literal|1
block|,
literal|8
block|,
name|ARC_OPERAND_FAKE
block|,
name|insert_flag
block|,
literal|0
block|}
block|,
comment|/* branch delay types.  */
define|#
directive|define
name|DELAY
value|(FLAGINSN + 1)
block|{
literal|'n'
block|,
literal|2
block|,
literal|5
block|,
name|ARC_OPERAND_SUFFIX
block|,
name|insert_nullify
block|,
literal|0
block|}
block|,
comment|/* conditions.  */
define|#
directive|define
name|COND
value|(DELAY + 1)
block|{
literal|'q'
block|,
literal|5
block|,
literal|0
block|,
name|ARC_OPERAND_SUFFIX
block|,
name|insert_cond
block|,
name|extract_cond
block|}
block|,
comment|/* set `cond_p' to 1 to ensure a constant is treated as a limm.  */
define|#
directive|define
name|FORCELIMM
value|(COND + 1)
block|{
literal|'Q'
block|,
literal|0
block|,
literal|0
block|,
name|ARC_OPERAND_FAKE
block|,
name|insert_forcelimm
block|,
literal|0
block|}
block|,
comment|/* branch address; b, bl, and lp insns.  */
define|#
directive|define
name|BRANCH
value|(FORCELIMM + 1)
block|{
literal|'B'
block|,
literal|20
block|,
literal|7
block|,
operator|(
name|ARC_OPERAND_RELATIVE_BRANCH
operator|+
name|ARC_OPERAND_SIGNED
operator|)
operator||
name|ARC_OPERAND_ERROR
block|,
name|insert_reladdr
block|,
name|extract_reladdr
block|}
block|,
comment|/* jump address; j insn (this is basically the same as 'L' except that the    value is right shifted by 2).  */
define|#
directive|define
name|JUMP
value|(BRANCH + 1)
block|{
literal|'J'
block|,
literal|24
block|,
literal|32
block|,
name|ARC_OPERAND_ERROR
operator||
operator|(
name|ARC_OPERAND_ABSOLUTE_BRANCH
operator|+
name|ARC_OPERAND_LIMM
operator|+
name|ARC_OPERAND_FAKE
operator|)
block|,
name|insert_absaddr
block|,
literal|0
block|}
block|,
comment|/* jump flags; j{,l} insn value or'ed into 'J' addr for flag values.  */
define|#
directive|define
name|JUMPFLAGS
value|(JUMP + 1)
block|{
literal|'j'
block|,
literal|6
block|,
literal|26
block|,
name|ARC_OPERAND_JUMPFLAGS
operator||
name|ARC_OPERAND_ERROR
block|,
name|insert_jumpflags
block|,
name|extract_jumpflags
block|}
block|,
comment|/* size field, stored in bit 1,2.  */
define|#
directive|define
name|SIZE1
value|(JUMPFLAGS + 1)
block|{
literal|'z'
block|,
literal|2
block|,
literal|1
block|,
name|ARC_OPERAND_SUFFIX
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* size field, stored in bit 10,11.  */
define|#
directive|define
name|SIZE10
value|(SIZE1 + 1)
block|{
literal|'Z'
block|,
literal|2
block|,
literal|10
block|,
name|ARC_OPERAND_SUFFIX
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* size field, stored in bit 22,23.  */
define|#
directive|define
name|SIZE22
value|(SIZE10 + 1)
block|{
literal|'y'
block|,
literal|2
block|,
literal|22
block|,
name|ARC_OPERAND_SUFFIX
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* sign extend field, stored in bit 0.  */
define|#
directive|define
name|SIGN0
value|(SIZE22 + 1)
block|{
literal|'x'
block|,
literal|1
block|,
literal|0
block|,
name|ARC_OPERAND_SUFFIX
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* sign extend field, stored in bit 9.  */
define|#
directive|define
name|SIGN9
value|(SIGN0 + 1)
block|{
literal|'X'
block|,
literal|1
block|,
literal|9
block|,
name|ARC_OPERAND_SUFFIX
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* address write back, stored in bit 3.  */
define|#
directive|define
name|ADDRESS3
value|(SIGN9 + 1)
block|{
literal|'w'
block|,
literal|1
block|,
literal|3
block|,
name|ARC_OPERAND_SUFFIX
block|,
name|insert_addr_wb
block|,
literal|0
block|}
block|,
comment|/* address write back, stored in bit 12.  */
define|#
directive|define
name|ADDRESS12
value|(ADDRESS3 + 1)
block|{
literal|'W'
block|,
literal|1
block|,
literal|12
block|,
name|ARC_OPERAND_SUFFIX
block|,
name|insert_addr_wb
block|,
literal|0
block|}
block|,
comment|/* address write back, stored in bit 24.  */
define|#
directive|define
name|ADDRESS24
value|(ADDRESS12 + 1)
block|{
literal|'v'
block|,
literal|1
block|,
literal|24
block|,
name|ARC_OPERAND_SUFFIX
block|,
name|insert_addr_wb
block|,
literal|0
block|}
block|,
comment|/* cache bypass, stored in bit 5.  */
define|#
directive|define
name|CACHEBYPASS5
value|(ADDRESS24 + 1)
block|{
literal|'e'
block|,
literal|1
block|,
literal|5
block|,
name|ARC_OPERAND_SUFFIX
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* cache bypass, stored in bit 14.  */
define|#
directive|define
name|CACHEBYPASS14
value|(CACHEBYPASS5 + 1)
block|{
literal|'E'
block|,
literal|1
block|,
literal|14
block|,
name|ARC_OPERAND_SUFFIX
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* cache bypass, stored in bit 26.  */
define|#
directive|define
name|CACHEBYPASS26
value|(CACHEBYPASS14 + 1)
block|{
literal|'D'
block|,
literal|1
block|,
literal|26
block|,
name|ARC_OPERAND_SUFFIX
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unop macro, used to copy REGB to REGC.  */
define|#
directive|define
name|UNOPMACRO
value|(CACHEBYPASS26 + 1)
block|{
literal|'U'
block|,
literal|6
block|,
name|ARC_SHIFT_REGC
block|,
name|ARC_OPERAND_FAKE
block|,
name|insert_unopmacro
block|,
name|extract_unopmacro
block|}
block|,
comment|/* '.' modifier ('.' required).  */
define|#
directive|define
name|MODDOT
value|(UNOPMACRO + 1)
block|{
literal|'.'
block|,
literal|1
block|,
literal|0
block|,
name|ARC_MOD_DOT
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Dummy 'r' modifier for the register table.    It's called a "dummy" because there's no point in inserting an 'r' into all    the %a/%b/%c occurrences in the insn table.  */
define|#
directive|define
name|REG
value|(MODDOT + 1)
block|{
literal|'r'
block|,
literal|6
block|,
literal|0
block|,
name|ARC_MOD_REG
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Known auxiliary register modifier (stored in shimm field).  */
define|#
directive|define
name|AUXREG
value|(REG + 1)
block|{
literal|'A'
block|,
literal|9
block|,
literal|0
block|,
name|ARC_MOD_AUXREG
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* end of list place holder.  */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Given a format letter, yields the index into `arc_operands'.    eg: arc_operand_map['a'] = REGA.  */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|arc_operand_map
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARC instructions.     Longer versions of insns must appear before shorter ones (if gas sees    "lsr r2,r3,1" when it's parsing "lsr %a,%b" it will think the ",1" is    junk).  This isn't necessary for `ld' because of the trailing ']'.     Instructions that are really macros based on other insns must appear    before the real insn so they're chosen when disassembling.  Eg: The `mov'    insn is really the `and' insn.  */
end_comment

begin_decl_stmt
name|struct
name|arc_opcode
name|arc_opcodes
index|[]
init|=
block|{
comment|/* Base case instruction set (core versions 5-8)  */
comment|/* "mov" is really an "and".  */
block|{
literal|"mov%.q%.f %a,%b%F%S%L%U"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|12
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* "asl" is really an "add".  */
block|{
literal|"asl%.q%.f %a,%b%F%S%L%U"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|8
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* "lsl" is really an "add".  */
block|{
literal|"lsl%.q%.f %a,%b%F%S%L%U"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|8
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* "nop" is really an "xor".  */
block|{
literal|"nop"
block|,
literal|0x7fffffff
block|,
literal|0x7fffffff
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* "rlc" is really an "adc".  */
block|{
literal|"rlc%.q%.f %a,%b%F%S%L%U"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|9
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"adc%.q%.f %a,%b,%c%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|9
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"add%.q%.f %a,%b,%c%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|8
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"and%.q%.f %a,%b,%c%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|12
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"asr%.q%.f %a,%b%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|C
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|3
argument_list|)
operator||
name|C
argument_list|(
literal|1
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"bic%.q%.f %a,%b,%c%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|14
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"b%q%.n %B"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|4
argument_list|)
block|,
name|ARC_MACH_5
operator||
name|ARC_OPCODE_COND_BRANCH
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"bl%q%.n %B"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|5
argument_list|)
block|,
name|ARC_MACH_5
operator||
name|ARC_OPCODE_COND_BRANCH
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"extb%.q%.f %a,%b%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|C
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|3
argument_list|)
operator||
name|C
argument_list|(
literal|7
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"extw%.q%.f %a,%b%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|C
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|3
argument_list|)
operator||
name|C
argument_list|(
literal|8
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"flag%.q %b%G%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|A
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|C
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|3
argument_list|)
operator||
name|A
argument_list|(
name|ARC_REG_SHIMM_UPDATE
argument_list|)
operator||
name|C
argument_list|(
literal|0
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"brk"
block|,
literal|0x1ffffe00
block|,
literal|0x1ffffe00
block|,
name|ARC_MACH_7
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"sleep"
block|,
literal|0x1ffffe01
block|,
literal|0x1ffffe01
block|,
name|ARC_MACH_7
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"swi"
block|,
literal|0x1ffffe02
block|,
literal|0x1ffffe02
block|,
name|ARC_MACH_8
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* %Q: force cond_p=1 -> no shimm values. This insn allows an      optional flags spec.  */
block|{
literal|"j%q%Q%.n%.f %b%F%J,%j"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|A
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|C
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|7
argument_list|)
operator||
name|A
argument_list|(
literal|0
argument_list|)
operator||
name|C
argument_list|(
literal|0
argument_list|)
operator||
name|R
argument_list|(
literal|0
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|)
block|,
name|ARC_MACH_5
operator||
name|ARC_OPCODE_COND_BRANCH
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"j%q%Q%.n%.f %b%F%J"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|A
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|C
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|7
argument_list|)
operator||
name|A
argument_list|(
literal|0
argument_list|)
operator||
name|C
argument_list|(
literal|0
argument_list|)
operator||
name|R
argument_list|(
literal|0
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|)
block|,
name|ARC_MACH_5
operator||
name|ARC_OPCODE_COND_BRANCH
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* This insn allows an optional flags spec.  */
block|{
literal|"jl%q%Q%.n%.f %b%F%J,%j"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|A
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|C
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|)
operator||
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|9
argument_list|,
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|7
argument_list|)
operator||
name|A
argument_list|(
literal|0
argument_list|)
operator||
name|C
argument_list|(
literal|0
argument_list|)
operator||
name|R
argument_list|(
literal|0
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|)
operator||
name|R
argument_list|(
literal|1
argument_list|,
literal|9
argument_list|,
literal|1
argument_list|)
block|,
name|ARC_MACH_6
operator||
name|ARC_OPCODE_COND_BRANCH
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"jl%q%Q%.n%.f %b%F%J"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|A
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|C
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|)
operator||
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|9
argument_list|,
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|7
argument_list|)
operator||
name|A
argument_list|(
literal|0
argument_list|)
operator||
name|C
argument_list|(
literal|0
argument_list|)
operator||
name|R
argument_list|(
literal|0
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|)
operator||
name|R
argument_list|(
literal|1
argument_list|,
literal|9
argument_list|,
literal|1
argument_list|)
block|,
name|ARC_MACH_6
operator||
name|ARC_OPCODE_COND_BRANCH
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Put opcode 1 ld insns first so shimm gets prefered over limm.      "[%b]" is before "[%b,%o]" so 0 offsets don't get printed.  */
block|{
literal|"ld%Z%.X%.W%.E %a,[%s]%S%L%1"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|13
argument_list|,
literal|1
argument_list|)
operator||
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|511
argument_list|)
block|,
name|I
argument_list|(
literal|1
argument_list|)
operator||
name|R
argument_list|(
literal|0
argument_list|,
literal|13
argument_list|,
literal|1
argument_list|)
operator||
name|R
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|511
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"ld%z%.x%.w%.e %a,[%s]%S%L%1"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|)
operator||
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|6
argument_list|,
literal|7
argument_list|)
block|,
name|I
argument_list|(
literal|0
argument_list|)
operator||
name|R
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|)
operator||
name|R
argument_list|(
literal|0
argument_list|,
literal|6
argument_list|,
literal|7
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"ld%z%.x%.w%.e %a,[%s,%O]%S%L%1"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|)
operator||
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|6
argument_list|,
literal|7
argument_list|)
block|,
name|I
argument_list|(
literal|0
argument_list|)
operator||
name|R
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|)
operator||
name|R
argument_list|(
literal|0
argument_list|,
literal|6
argument_list|,
literal|7
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"ld%Z%.X%.W%.E %a,[%s,%O]%S%L%3"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|13
argument_list|,
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|1
argument_list|)
operator||
name|R
argument_list|(
literal|0
argument_list|,
literal|13
argument_list|,
literal|1
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"lp%q%.n %B"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|6
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"lr %a,[%Ab]%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|C
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|1
argument_list|)
operator||
name|C
argument_list|(
literal|0x10
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"lsr%.q%.f %a,%b%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|C
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|3
argument_list|)
operator||
name|C
argument_list|(
literal|2
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"or%.q%.f %a,%b,%c%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|13
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"ror%.q%.f %a,%b%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|C
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|3
argument_list|)
operator||
name|C
argument_list|(
literal|3
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"rrc%.q%.f %a,%b%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|C
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|3
argument_list|)
operator||
name|C
argument_list|(
literal|4
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"sbc%.q%.f %a,%b,%c%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|11
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"sexb%.q%.f %a,%b%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|C
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|3
argument_list|)
operator||
name|C
argument_list|(
literal|5
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"sexw%.q%.f %a,%b%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|C
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|3
argument_list|)
operator||
name|C
argument_list|(
literal|6
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"sr %c,[%Ab]%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|A
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|2
argument_list|)
operator||
name|A
argument_list|(
literal|0x10
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* "[%b]" is before "[%b,%o]" so 0 offsets don't get printed.  */
block|{
literal|"st%y%.v%.D %c,[%s]%L%S%0"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|25
argument_list|,
literal|1
argument_list|)
operator||
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|21
argument_list|,
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|2
argument_list|)
operator||
name|R
argument_list|(
literal|0
argument_list|,
literal|25
argument_list|,
literal|1
argument_list|)
operator||
name|R
argument_list|(
literal|0
argument_list|,
literal|21
argument_list|,
literal|1
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"st%y%.v%.D %c,[%s,%o]%S%L%2"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|25
argument_list|,
literal|1
argument_list|)
operator||
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|21
argument_list|,
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|2
argument_list|)
operator||
name|R
argument_list|(
literal|0
argument_list|,
literal|25
argument_list|,
literal|1
argument_list|)
operator||
name|R
argument_list|(
literal|0
argument_list|,
literal|21
argument_list|,
literal|1
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"sub%.q%.f %a,%b,%c%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|10
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"xor%.q%.f %a,%b,%c%F%S%L"
block|,
name|I
argument_list|(
operator|-
literal|1
argument_list|)
block|,
name|I
argument_list|(
literal|15
argument_list|)
block|,
name|ARC_MACH_5
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|arc_opcodes_count
init|=
sizeof|sizeof
argument_list|(
name|arc_opcodes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|arc_opcodes
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|arc_operand_value
name|arc_reg_names
index|[]
init|=
block|{
comment|/* Core register set r0-r63.  */
comment|/* r0-r28 - general purpose registers.  */
block|{
literal|"r0"
block|,
literal|0
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r1"
block|,
literal|1
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r2"
block|,
literal|2
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r3"
block|,
literal|3
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r4"
block|,
literal|4
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r5"
block|,
literal|5
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r6"
block|,
literal|6
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r7"
block|,
literal|7
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r8"
block|,
literal|8
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r9"
block|,
literal|9
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r10"
block|,
literal|10
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r11"
block|,
literal|11
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r12"
block|,
literal|12
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r13"
block|,
literal|13
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r14"
block|,
literal|14
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r15"
block|,
literal|15
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r16"
block|,
literal|16
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r17"
block|,
literal|17
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r18"
block|,
literal|18
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r19"
block|,
literal|19
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r20"
block|,
literal|20
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r21"
block|,
literal|21
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r22"
block|,
literal|22
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r23"
block|,
literal|23
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r24"
block|,
literal|24
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r25"
block|,
literal|25
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r26"
block|,
literal|26
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r27"
block|,
literal|27
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r28"
block|,
literal|28
block|,
name|REG
block|,
literal|0
block|}
block|,
comment|/* Maskable interrupt link register.  */
block|{
literal|"ilink1"
block|,
literal|29
block|,
name|REG
block|,
literal|0
block|}
block|,
comment|/* Maskable interrupt link register.  */
block|{
literal|"ilink2"
block|,
literal|30
block|,
name|REG
block|,
literal|0
block|}
block|,
comment|/* Branch-link register.  */
block|{
literal|"blink"
block|,
literal|31
block|,
name|REG
block|,
literal|0
block|}
block|,
comment|/* r32-r59 reserved for extensions.  */
block|{
literal|"r32"
block|,
literal|32
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r33"
block|,
literal|33
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r34"
block|,
literal|34
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r35"
block|,
literal|35
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r36"
block|,
literal|36
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r37"
block|,
literal|37
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r38"
block|,
literal|38
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r39"
block|,
literal|39
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r40"
block|,
literal|40
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r41"
block|,
literal|41
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r42"
block|,
literal|42
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r43"
block|,
literal|43
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r44"
block|,
literal|44
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r45"
block|,
literal|45
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r46"
block|,
literal|46
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r47"
block|,
literal|47
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r48"
block|,
literal|48
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r49"
block|,
literal|49
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r50"
block|,
literal|50
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r51"
block|,
literal|51
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r52"
block|,
literal|52
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r53"
block|,
literal|53
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r54"
block|,
literal|54
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r55"
block|,
literal|55
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r56"
block|,
literal|56
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r57"
block|,
literal|57
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r58"
block|,
literal|58
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r59"
block|,
literal|59
block|,
name|REG
block|,
literal|0
block|}
block|,
comment|/* Loop count register (24 bits).  */
block|{
literal|"lp_count"
block|,
literal|60
block|,
name|REG
block|,
literal|0
block|}
block|,
comment|/* Short immediate data indicator setting flags.  */
block|{
literal|"r61"
block|,
literal|61
block|,
name|REG
block|,
name|ARC_REGISTER_READONLY
block|}
block|,
comment|/* Long immediate data indicator setting flags.  */
block|{
literal|"r62"
block|,
literal|62
block|,
name|REG
block|,
name|ARC_REGISTER_READONLY
block|}
block|,
comment|/* Short immediate data indicator not setting flags.  */
block|{
literal|"r63"
block|,
literal|63
block|,
name|REG
block|,
name|ARC_REGISTER_READONLY
block|}
block|,
comment|/* Small-data base register.  */
block|{
literal|"gp"
block|,
literal|26
block|,
name|REG
block|,
literal|0
block|}
block|,
comment|/* Frame pointer.  */
block|{
literal|"fp"
block|,
literal|27
block|,
name|REG
block|,
literal|0
block|}
block|,
comment|/* Stack pointer.  */
block|{
literal|"sp"
block|,
literal|28
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r29"
block|,
literal|29
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r30"
block|,
literal|30
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r31"
block|,
literal|31
block|,
name|REG
block|,
literal|0
block|}
block|,
block|{
literal|"r60"
block|,
literal|60
block|,
name|REG
block|,
literal|0
block|}
block|,
comment|/* Auxiliary register set.  */
comment|/* Auxiliary register address map:      0xffffffff-0xffffff00 (-1..-256) - customer shimm allocation      0xfffffeff-0x80000000 - customer limm allocation      0x7fffffff-0x00000100 - ARC limm allocation      0x000000ff-0x00000000 - ARC shimm allocation  */
comment|/* Base case auxiliary registers (shimm address).  */
block|{
literal|"status"
block|,
literal|0x00
block|,
name|AUXREG
block|,
literal|0
block|}
block|,
block|{
literal|"semaphore"
block|,
literal|0x01
block|,
name|AUXREG
block|,
literal|0
block|}
block|,
block|{
literal|"lp_start"
block|,
literal|0x02
block|,
name|AUXREG
block|,
literal|0
block|}
block|,
block|{
literal|"lp_end"
block|,
literal|0x03
block|,
name|AUXREG
block|,
literal|0
block|}
block|,
block|{
literal|"identity"
block|,
literal|0x04
block|,
name|AUXREG
block|,
name|ARC_REGISTER_READONLY
block|}
block|,
block|{
literal|"debug"
block|,
literal|0x05
block|,
name|AUXREG
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|arc_reg_names_count
init|=
sizeof|sizeof
argument_list|(
name|arc_reg_names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|arc_reg_names
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The suffix table.    Operands with the same name must be stored together.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|arc_operand_value
name|arc_suffixes
index|[]
init|=
block|{
comment|/* Entry 0 is special, default values aren't printed by the disassembler.  */
block|{
literal|""
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|}
block|,
comment|/* Base case condition codes.  */
block|{
literal|"al"
block|,
literal|0
block|,
name|COND
block|,
literal|0
block|}
block|,
block|{
literal|"ra"
block|,
literal|0
block|,
name|COND
block|,
literal|0
block|}
block|,
block|{
literal|"eq"
block|,
literal|1
block|,
name|COND
block|,
literal|0
block|}
block|,
block|{
literal|"z"
block|,
literal|1
block|,
name|COND
block|,
literal|0
block|}
block|,
block|{
literal|"ne"
block|,
literal|2
block|,
name|COND
block|,
literal|0
block|}
block|,
block|{
literal|"nz"
block|,
literal|2
block|,
name|COND
block|,
literal|0
block|}
block|,
block|{
literal|"pl"
block|,
literal|3
block|,
name|COND
block|,
literal|0
block|}
block|,
block|{
literal|"p"
block|,
literal|3
block|,
name|COND
block|,
literal|0
block|}
block|,
block|{
literal|"mi"
block|,
literal|4
block|,
name|COND
block|,
literal|0
block|}
block|,
block|{
literal|"n"
block|,
literal|4
block|,
name|COND
block|,
literal|0
block|}
block|,
block|{
literal|"cs"
block|,
literal|5
block|,
name|COND
block|,
literal|0
block|}
block|,
block|{
literal|"c"
block|,
literal|5
block|,
name|COND
block|,
literal|0
block|}
block|,
block|{
literal|"lo"
block|,
literal|5
block|,
name|COND
block|,
literal|0
block|}
block|,
block|{
literal|"cc"
block|,
literal|6
block|,
name|COND
block|,
literal|0
block|}
block|,
block|{
literal|"nc"
block|,
literal|6
block|,
name|COND
block|,
literal|0
block|}
block|,
block|{
literal|"hs"
block|,
literal|6
block|,
name|COND
block|,
literal|0
block|}
block|,
block|{
literal|"vs"
block|,
literal|7
block|,
name|COND
block|,
literal|0
block|}
block|,
block|{
literal|"v"
block|,
literal|7
block|,
name|COND
block|,
literal|0
block|}
block|,
block|{
literal|"vc"
block|,
literal|8
block|,
name|COND
block|,
literal|0
block|}
block|,
block|{
literal|"nv"
block|,
literal|8
block|,
name|COND
block|,
literal|0
block|}
block|,
block|{
literal|"gt"
block|,
literal|9
block|,
name|COND
block|,
literal|0
block|}
block|,
block|{
literal|"ge"
block|,
literal|10
block|,
name|COND
block|,
literal|0
block|}
block|,
block|{
literal|"lt"
block|,
literal|11
block|,
name|COND
block|,
literal|0
block|}
block|,
block|{
literal|"le"
block|,
literal|12
block|,
name|COND
block|,
literal|0
block|}
block|,
block|{
literal|"hi"
block|,
literal|13
block|,
name|COND
block|,
literal|0
block|}
block|,
block|{
literal|"ls"
block|,
literal|14
block|,
name|COND
block|,
literal|0
block|}
block|,
block|{
literal|"pnz"
block|,
literal|15
block|,
name|COND
block|,
literal|0
block|}
block|,
comment|/* Condition codes 16-31 reserved for extensions.  */
block|{
literal|"f"
block|,
literal|1
block|,
name|FLAG
block|,
literal|0
block|}
block|,
block|{
literal|"nd"
block|,
name|ARC_DELAY_NONE
block|,
name|DELAY
block|,
literal|0
block|}
block|,
block|{
literal|"d"
block|,
name|ARC_DELAY_NORMAL
block|,
name|DELAY
block|,
literal|0
block|}
block|,
block|{
literal|"jd"
block|,
name|ARC_DELAY_JUMP
block|,
name|DELAY
block|,
literal|0
block|}
block|,
block|{
literal|"b"
block|,
literal|1
block|,
name|SIZE1
block|,
literal|0
block|}
block|,
block|{
literal|"b"
block|,
literal|1
block|,
name|SIZE10
block|,
literal|0
block|}
block|,
block|{
literal|"b"
block|,
literal|1
block|,
name|SIZE22
block|,
literal|0
block|}
block|,
block|{
literal|"w"
block|,
literal|2
block|,
name|SIZE1
block|,
literal|0
block|}
block|,
block|{
literal|"w"
block|,
literal|2
block|,
name|SIZE10
block|,
literal|0
block|}
block|,
block|{
literal|"w"
block|,
literal|2
block|,
name|SIZE22
block|,
literal|0
block|}
block|,
block|{
literal|"x"
block|,
literal|1
block|,
name|SIGN0
block|,
literal|0
block|}
block|,
block|{
literal|"x"
block|,
literal|1
block|,
name|SIGN9
block|,
literal|0
block|}
block|,
block|{
literal|"a"
block|,
literal|1
block|,
name|ADDRESS3
block|,
literal|0
block|}
block|,
block|{
literal|"a"
block|,
literal|1
block|,
name|ADDRESS12
block|,
literal|0
block|}
block|,
block|{
literal|"a"
block|,
literal|1
block|,
name|ADDRESS24
block|,
literal|0
block|}
block|,
block|{
literal|"di"
block|,
literal|1
block|,
name|CACHEBYPASS5
block|,
literal|0
block|}
block|,
block|{
literal|"di"
block|,
literal|1
block|,
name|CACHEBYPASS14
block|,
literal|0
block|}
block|,
block|{
literal|"di"
block|,
literal|1
block|,
name|CACHEBYPASS26
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|arc_suffixes_count
init|=
sizeof|sizeof
argument_list|(
name|arc_suffixes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|arc_suffixes
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by first letter of opcode.  Points to chain of opcodes with same    first letter.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|arc_opcode
modifier|*
name|opcode_map
index|[
literal|26
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by insn code.  Points to chain of opcodes with same insn code.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|arc_opcode
modifier|*
name|icode_map
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Configuration flags.  */
end_comment

begin_comment
comment|/* Various ARC_HAVE_XXX bits.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cpu_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Translate a bfd_mach_arc_xxx value to a ARC_MACH_XXX value.  */
end_comment

begin_function
name|int
name|arc_get_opcode_mach
parameter_list|(
name|bfd_mach
parameter_list|,
name|big_p
parameter_list|)
name|int
name|bfd_mach
decl_stmt|,
name|big_p
decl_stmt|;
block|{
specifier|static
name|int
name|mach_type_map
index|[]
init|=
block|{
name|ARC_MACH_5
block|,
name|ARC_MACH_6
block|,
name|ARC_MACH_7
block|,
name|ARC_MACH_8
block|}
decl_stmt|;
return|return
name|mach_type_map
index|[
name|bfd_mach
operator|-
name|bfd_mach_arc_5
index|]
operator||
operator|(
name|big_p
condition|?
name|ARC_MACH_BIG
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize any tables that need it.    Must be called once at start up (or when first needed).     FLAGS is a set of bits that say what version of the cpu we have,    and in particular at least (one of) ARC_MACH_XXX.  */
end_comment

begin_function
name|void
name|arc_opcode_init_tables
parameter_list|(
name|flags
parameter_list|)
name|int
name|flags
decl_stmt|;
block|{
specifier|static
name|int
name|init_p
init|=
literal|0
decl_stmt|;
name|cpu_type
operator|=
name|flags
expr_stmt|;
comment|/* We may be intentionally called more than once (for example gdb will call      us each time the user switches cpu).  These tables only need to be init'd      once though.  */
if|if
condition|(
operator|!
name|init_p
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|memset
argument_list|(
name|arc_operand_map
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_operand_map
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
sizeof|sizeof
argument_list|(
name|arc_operands
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|arc_operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|arc_operand_map
index|[
name|arc_operands
index|[
name|i
index|]
operator|.
name|fmt
index|]
operator|=
name|i
expr_stmt|;
name|memset
argument_list|(
name|opcode_map
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opcode_map
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|icode_map
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|icode_map
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Scan the table backwards so macros appear at the front.  */
for|for
control|(
name|i
operator|=
name|arc_opcodes_count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|int
name|opcode_hash
init|=
name|ARC_HASH_OPCODE
argument_list|(
name|arc_opcodes
index|[
name|i
index|]
operator|.
name|syntax
argument_list|)
decl_stmt|;
name|int
name|icode_hash
init|=
name|ARC_HASH_ICODE
argument_list|(
name|arc_opcodes
index|[
name|i
index|]
operator|.
name|value
argument_list|)
decl_stmt|;
name|arc_opcodes
index|[
name|i
index|]
operator|.
name|next_asm
operator|=
name|opcode_map
index|[
name|opcode_hash
index|]
expr_stmt|;
name|opcode_map
index|[
name|opcode_hash
index|]
operator|=
operator|&
name|arc_opcodes
index|[
name|i
index|]
expr_stmt|;
name|arc_opcodes
index|[
name|i
index|]
operator|.
name|next_dis
operator|=
name|icode_map
index|[
name|icode_hash
index|]
expr_stmt|;
name|icode_map
index|[
name|icode_hash
index|]
operator|=
operator|&
name|arc_opcodes
index|[
name|i
index|]
expr_stmt|;
block|}
name|init_p
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return non-zero if OPCODE is supported on the specified cpu.    Cpu selection is made when calling `arc_opcode_init_tables'.  */
end_comment

begin_function
name|int
name|arc_opcode_supported
parameter_list|(
name|opcode
parameter_list|)
specifier|const
name|struct
name|arc_opcode
modifier|*
name|opcode
decl_stmt|;
block|{
if|if
condition|(
name|ARC_OPCODE_CPU
argument_list|(
name|opcode
operator|->
name|flags
argument_list|)
operator|<=
name|cpu_type
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the first insn in the chain for assembling INSN.  */
end_comment

begin_function
specifier|const
name|struct
name|arc_opcode
modifier|*
name|arc_opcode_lookup_asm
parameter_list|(
name|insn
parameter_list|)
specifier|const
name|char
modifier|*
name|insn
decl_stmt|;
block|{
return|return
name|opcode_map
index|[
name|ARC_HASH_OPCODE
argument_list|(
name|insn
argument_list|)
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the first insn in the chain for disassembling INSN.  */
end_comment

begin_function
specifier|const
name|struct
name|arc_opcode
modifier|*
name|arc_opcode_lookup_dis
parameter_list|(
name|insn
parameter_list|)
name|unsigned
name|int
name|insn
decl_stmt|;
block|{
return|return
name|icode_map
index|[
name|ARC_HASH_ICODE
argument_list|(
name|insn
argument_list|)
index|]
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if we've seen an 'f' suffix (in certain insns).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we've finished processing the 'f' suffix.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flagshimm_handled_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we've seen a 'a' suffix (address writeback).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|addrwb_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we've seen a 'q' suffix (condition code).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cond_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we've inserted a nullify condition.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nullify_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The value of the a nullify condition we inserted.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nullify
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we've inserted jumpflags.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|jumpflags_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we've inserted a shimm.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|shimm_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The value of the shimm we inserted (each insn only gets one but it can    appear multiple times).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|shimm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we've inserted a limm (during assembly) or seen a limm    (during disassembly).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|limm_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The value of the limm we inserted.  Each insn only gets one but it can    appear multiple times.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|limm
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Insertion functions.  */
end_comment

begin_comment
comment|/* Called by the assembler before parsing an instruction.  */
end_comment

begin_function
name|void
name|arc_opcode_init_insert
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OPERANDS
condition|;
name|i
operator|++
control|)
name|ls_operand
index|[
name|i
index|]
operator|=
name|OP_NONE
expr_stmt|;
name|flag_p
operator|=
literal|0
expr_stmt|;
name|flagshimm_handled_p
operator|=
literal|0
expr_stmt|;
name|cond_p
operator|=
literal|0
expr_stmt|;
name|addrwb_p
operator|=
literal|0
expr_stmt|;
name|shimm_p
operator|=
literal|0
expr_stmt|;
name|limm_p
operator|=
literal|0
expr_stmt|;
name|jumpflags_p
operator|=
literal|0
expr_stmt|;
name|nullify_p
operator|=
literal|0
expr_stmt|;
name|nullify
operator|=
literal|0
expr_stmt|;
comment|/* the default is important.  */
block|}
end_function

begin_comment
comment|/* Called by the assembler to see if the insn has a limm operand.    Also called by the disassembler to see if the insn contains a limm.  */
end_comment

begin_function
name|int
name|arc_opcode_limm_p
parameter_list|(
name|limmp
parameter_list|)
name|long
modifier|*
name|limmp
decl_stmt|;
block|{
if|if
condition|(
name|limmp
condition|)
operator|*
name|limmp
operator|=
name|limm
expr_stmt|;
return|return
name|limm_p
return|;
block|}
end_function

begin_comment
comment|/* Insert a value into a register field.    If REG is NULL, then this is actually a constant.     We must also handle auxiliary registers for lr/sr insns.  */
end_comment

begin_function
specifier|static
name|arc_insn
name|insert_reg
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
decl_stmt|;
name|long
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|enum
name|operand
name|op_type
init|=
name|OP_NONE
decl_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL
condition|)
block|{
comment|/* We have a constant that also requires a value stored in a register 	 field.  Handle these by updating the register field and saving the 	 value for later handling by either %S (shimm) or %L (limm).  */
comment|/* Try to use a shimm value before a limm one.  */
if|if
condition|(
name|ARC_SHIMM_CONST_P
argument_list|(
name|value
argument_list|)
comment|/* If we've seen a conditional suffix we have to use a limm.  */
operator|&&
operator|!
name|cond_p
comment|/* If we already have a shimm value that is different than ours 	     we have to use a limm.  */
operator|&&
operator|(
operator|!
name|shimm_p
operator|||
name|shimm
operator|==
name|value
operator|)
condition|)
block|{
name|int
name|marker
decl_stmt|;
name|op_type
operator|=
name|OP_SHIMM
expr_stmt|;
comment|/* forget about shimm as dest mlm.  */
if|if
condition|(
literal|'a'
operator|!=
name|operand
operator|->
name|fmt
condition|)
block|{
name|shimm_p
operator|=
literal|1
expr_stmt|;
name|shimm
operator|=
name|value
expr_stmt|;
name|flagshimm_handled_p
operator|=
literal|1
expr_stmt|;
name|marker
operator|=
name|flag_p
condition|?
name|ARC_REG_SHIMM_UPDATE
else|:
name|ARC_REG_SHIMM
expr_stmt|;
block|}
else|else
block|{
comment|/* don't request flag setting on shimm as dest.  */
name|marker
operator|=
name|ARC_REG_SHIMM
expr_stmt|;
block|}
name|insn
operator||=
name|marker
operator|<<
name|operand
operator|->
name|shift
expr_stmt|;
comment|/* insn |= value& 511; - done later.  */
block|}
comment|/* We have to use a limm.  If we've already seen one they must match.  */
elseif|else
if|if
condition|(
operator|!
name|limm_p
operator|||
name|limm
operator|==
name|value
condition|)
block|{
name|op_type
operator|=
name|OP_LIMM
expr_stmt|;
name|limm_p
operator|=
literal|1
expr_stmt|;
name|limm
operator|=
name|value
expr_stmt|;
name|insn
operator||=
name|ARC_REG_LIMM
operator|<<
name|operand
operator|->
name|shift
expr_stmt|;
comment|/* The constant is stored later.  */
block|}
else|else
block|{
operator|*
name|errmsg
operator|=
literal|"unable to fit different valued constants into instruction"
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We have to handle both normal and auxiliary registers.  */
if|if
condition|(
name|reg
operator|->
name|type
operator|==
name|AUXREG
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|mods
operator|&
name|ARC_MOD_AUXREG
operator|)
condition|)
operator|*
name|errmsg
operator|=
literal|"auxiliary register not allowed here"
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|insn
operator|&
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
operator|==
name|I
argument_list|(
literal|2
argument_list|)
condition|)
comment|/* check for use validity.  */
block|{
if|if
condition|(
name|reg
operator|->
name|flags
operator|&
name|ARC_REGISTER_READONLY
condition|)
operator|*
name|errmsg
operator|=
literal|"attempt to set readonly register"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|reg
operator|->
name|flags
operator|&
name|ARC_REGISTER_WRITEONLY
condition|)
operator|*
name|errmsg
operator|=
literal|"attempt to read writeonly register"
expr_stmt|;
block|}
name|insn
operator||=
name|ARC_REG_SHIMM
operator|<<
name|operand
operator|->
name|shift
expr_stmt|;
name|insn
operator||=
name|reg
operator|->
name|value
operator|<<
name|arc_operands
index|[
name|reg
operator|->
name|type
index|]
operator|.
name|shift
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* check for use validity.  */
if|if
condition|(
literal|'a'
operator|==
name|operand
operator|->
name|fmt
operator|||
operator|(
operator|(
name|insn
operator|&
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
operator|<
name|I
argument_list|(
literal|2
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|reg
operator|->
name|flags
operator|&
name|ARC_REGISTER_READONLY
condition|)
operator|*
name|errmsg
operator|=
literal|"attempt to set readonly register"
expr_stmt|;
block|}
if|if
condition|(
literal|'a'
operator|!=
name|operand
operator|->
name|fmt
condition|)
block|{
if|if
condition|(
name|reg
operator|->
name|flags
operator|&
name|ARC_REGISTER_WRITEONLY
condition|)
operator|*
name|errmsg
operator|=
literal|"attempt to read writeonly register"
expr_stmt|;
block|}
comment|/* We should never get an invalid register number here.  */
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|reg
operator|->
name|value
operator|>
literal|60
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"invalid register number `%d'"
argument_list|,
name|reg
operator|->
name|value
argument_list|)
expr_stmt|;
operator|*
name|errmsg
operator|=
name|buf
expr_stmt|;
block|}
name|insn
operator||=
name|reg
operator|->
name|value
operator|<<
name|operand
operator|->
name|shift
expr_stmt|;
name|op_type
operator|=
name|OP_REG
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|operand
operator|->
name|fmt
condition|)
block|{
case|case
literal|'a'
case|:
name|ls_operand
index|[
name|LS_DEST
index|]
operator|=
name|op_type
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|ls_operand
index|[
name|LS_BASE
index|]
operator|=
name|op_type
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
operator|(
name|insn
operator|&
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
operator|==
name|I
argument_list|(
literal|2
argument_list|)
condition|)
name|ls_operand
index|[
name|LS_VALUE
index|]
operator|=
name|op_type
expr_stmt|;
else|else
name|ls_operand
index|[
name|LS_OFFSET
index|]
operator|=
name|op_type
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
case|case
literal|'O'
case|:
name|ls_operand
index|[
name|LS_OFFSET
index|]
operator|=
name|op_type
expr_stmt|;
break|break;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Called when we see an 'f' flag.  */
end_comment

begin_function
specifier|static
name|arc_insn
name|insert_flag
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|mods
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|long
name|value
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* We can't store anything in the insn until we've parsed the registers.      Just record the fact that we've got this flag.  `insert_reg' will use it      to store the correct value (ARC_REG_SHIMM_UPDATE or bit 0x100).  */
name|flag_p
operator|=
literal|1
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Called when we see an nullify condition.  */
end_comment

begin_function
specifier|static
name|arc_insn
name|insert_nullify
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|long
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|nullify_p
operator|=
literal|1
expr_stmt|;
name|insn
operator||=
operator|(
name|value
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|operand
operator|->
name|shift
expr_stmt|;
name|nullify
operator|=
name|value
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Called after completely building an insn to ensure the 'f' flag gets set    properly.  This is needed because we don't know how to set this flag until    we've parsed the registers.  */
end_comment

begin_function
specifier|static
name|arc_insn
name|insert_flagfinish
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|long
name|value
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|flag_p
operator|&&
operator|!
name|flagshimm_handled_p
condition|)
block|{
if|if
condition|(
name|shimm_p
condition|)
name|abort
argument_list|()
expr_stmt|;
name|flagshimm_handled_p
operator|=
literal|1
expr_stmt|;
name|insn
operator||=
operator|(
literal|1
operator|<<
name|operand
operator|->
name|shift
operator|)
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Called when we see a conditional flag (eg: .eq).  */
end_comment

begin_function
specifier|static
name|arc_insn
name|insert_cond
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|long
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|cond_p
operator|=
literal|1
expr_stmt|;
name|insn
operator||=
operator|(
name|value
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|operand
operator|->
name|shift
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Used in the "j" instruction to prevent constants from being interpreted as    shimm values (which the jump insn doesn't accept).  This can also be used    to force the use of limm values in other situations (eg: ld r0,[foo] uses    this).    ??? The mechanism is sound.  Access to it is a bit klunky right now.  */
end_comment

begin_function
specifier|static
name|arc_insn
name|insert_forcelimm
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|mods
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|long
name|value
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|cond_p
operator|=
literal|1
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_function
specifier|static
name|arc_insn
name|insert_addr_wb
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|long
name|value
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|addrwb_p
operator|=
literal|1
operator|<<
name|operand
operator|->
name|shift
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_function
specifier|static
name|arc_insn
name|insert_base
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
decl_stmt|;
name|long
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
decl_stmt|;
block|{
if|if
condition|(
name|reg
operator|!=
name|NULL
condition|)
block|{
name|arc_insn
name|myinsn
decl_stmt|;
name|myinsn
operator|=
name|insert_reg
argument_list|(
literal|0
argument_list|,
name|operand
argument_list|,
name|mods
argument_list|,
name|reg
argument_list|,
name|value
argument_list|,
name|errmsg
argument_list|)
operator|>>
name|operand
operator|->
name|shift
expr_stmt|;
name|insn
operator||=
name|B
argument_list|(
name|myinsn
argument_list|)
expr_stmt|;
name|ls_operand
index|[
name|LS_BASE
index|]
operator|=
name|OP_REG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ARC_SHIMM_CONST_P
argument_list|(
name|value
argument_list|)
operator|&&
operator|!
name|cond_p
condition|)
block|{
if|if
condition|(
name|shimm_p
operator|&&
name|value
operator|!=
name|shimm
condition|)
block|{
comment|/* convert the previous shimm operand to a limm.  */
name|limm_p
operator|=
literal|1
expr_stmt|;
name|limm
operator|=
name|shimm
expr_stmt|;
name|insn
operator|&=
operator|~
name|C
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* we know where the value is in insn.  */
name|insn
operator||=
name|C
argument_list|(
name|ARC_REG_LIMM
argument_list|)
expr_stmt|;
name|ls_operand
index|[
name|LS_VALUE
index|]
operator|=
name|OP_LIMM
expr_stmt|;
block|}
name|insn
operator||=
name|ARC_REG_SHIMM
operator|<<
name|operand
operator|->
name|shift
expr_stmt|;
name|shimm_p
operator|=
literal|1
expr_stmt|;
name|shimm
operator|=
name|value
expr_stmt|;
name|ls_operand
index|[
name|LS_BASE
index|]
operator|=
name|OP_SHIMM
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|limm_p
operator|&&
name|value
operator|!=
name|limm
condition|)
block|{
operator|*
name|errmsg
operator|=
literal|"too many long constants"
expr_stmt|;
return|return
name|insn
return|;
block|}
name|limm_p
operator|=
literal|1
expr_stmt|;
name|limm
operator|=
name|value
expr_stmt|;
name|insn
operator||=
name|B
argument_list|(
name|ARC_REG_LIMM
argument_list|)
expr_stmt|;
name|ls_operand
index|[
name|LS_BASE
index|]
operator|=
name|OP_LIMM
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Used in ld/st insns to handle the offset field. We don't try to    match operand syntax here. we catch bad combinations later.  */
end_comment

begin_function
specifier|static
name|arc_insn
name|insert_offset
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
decl_stmt|;
name|long
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
decl_stmt|;
block|{
name|long
name|minval
decl_stmt|,
name|maxval
decl_stmt|;
if|if
condition|(
name|reg
operator|!=
name|NULL
condition|)
block|{
name|arc_insn
name|myinsn
decl_stmt|;
name|myinsn
operator|=
name|insert_reg
argument_list|(
literal|0
argument_list|,
name|operand
argument_list|,
name|mods
argument_list|,
name|reg
argument_list|,
name|value
argument_list|,
name|errmsg
argument_list|)
operator|>>
name|operand
operator|->
name|shift
expr_stmt|;
name|ls_operand
index|[
name|LS_OFFSET
index|]
operator|=
name|OP_REG
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_LOAD
condition|)
comment|/* not if store, catch it later.  */
if|if
condition|(
operator|(
name|insn
operator|&
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
operator|!=
name|I
argument_list|(
literal|1
argument_list|)
condition|)
comment|/* not if opcode == 1, catch it later.  */
name|insn
operator||=
name|C
argument_list|(
name|myinsn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is *way* more general than necessary, but maybe some day it'll 	 be useful.  */
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_SIGNED
condition|)
block|{
name|minval
operator|=
operator|-
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|maxval
operator|=
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|minval
operator|=
literal|0
expr_stmt|;
name|maxval
operator|=
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cond_p
operator|&&
operator|!
name|limm_p
operator|)
operator|||
operator|(
name|value
operator|<
name|minval
operator|||
name|value
operator|>
name|maxval
operator|)
condition|)
block|{
if|if
condition|(
name|limm_p
operator|&&
name|value
operator|!=
name|limm
condition|)
block|{
operator|*
name|errmsg
operator|=
literal|"too many long constants"
expr_stmt|;
block|}
else|else
block|{
name|limm_p
operator|=
literal|1
expr_stmt|;
name|limm
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_STORE
condition|)
name|insn
operator||=
name|B
argument_list|(
name|ARC_REG_LIMM
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_LOAD
condition|)
name|insn
operator||=
name|C
argument_list|(
name|ARC_REG_LIMM
argument_list|)
expr_stmt|;
name|ls_operand
index|[
name|LS_OFFSET
index|]
operator|=
name|OP_LIMM
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|value
operator|<
name|minval
operator|||
name|value
operator|>
name|maxval
operator|)
condition|)
operator|*
name|errmsg
operator|=
literal|"need too many limms"
expr_stmt|;
elseif|else
if|if
condition|(
name|shimm_p
operator|&&
name|value
operator|!=
name|shimm
condition|)
block|{
comment|/* check for bad operand combinations before we lose info about them.  */
if|if
condition|(
operator|(
name|insn
operator|&
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
operator|==
name|I
argument_list|(
literal|1
argument_list|)
condition|)
block|{
operator|*
name|errmsg
operator|=
literal|"to many shimms in load"
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|limm_p
operator|&&
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_LOAD
condition|)
block|{
operator|*
name|errmsg
operator|=
literal|"too many long constants"
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* convert what we thought was a shimm to a limm.  */
name|limm_p
operator|=
literal|1
expr_stmt|;
name|limm
operator|=
name|shimm
expr_stmt|;
if|if
condition|(
name|ls_operand
index|[
name|LS_VALUE
index|]
operator|==
name|OP_SHIMM
operator|&&
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_STORE
condition|)
block|{
name|insn
operator|&=
operator|~
name|C
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|insn
operator||=
name|C
argument_list|(
name|ARC_REG_LIMM
argument_list|)
expr_stmt|;
name|ls_operand
index|[
name|LS_VALUE
index|]
operator|=
name|OP_LIMM
expr_stmt|;
block|}
if|if
condition|(
name|ls_operand
index|[
name|LS_BASE
index|]
operator|==
name|OP_SHIMM
operator|&&
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_STORE
condition|)
block|{
name|insn
operator|&=
operator|~
name|B
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|insn
operator||=
name|B
argument_list|(
name|ARC_REG_LIMM
argument_list|)
expr_stmt|;
name|ls_operand
index|[
name|LS_BASE
index|]
operator|=
name|OP_LIMM
expr_stmt|;
block|}
block|}
name|shimm
operator|=
name|value
expr_stmt|;
name|shimm_p
operator|=
literal|1
expr_stmt|;
name|ls_operand
index|[
name|LS_OFFSET
index|]
operator|=
name|OP_SHIMM
expr_stmt|;
block|}
block|}
name|out
label|:
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Used in st insns to do final disasemble syntax check.  */
end_comment

begin_function
specifier|static
name|long
name|extract_st_syntax
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|opval
parameter_list|,
name|invalid
parameter_list|)
name|arc_insn
modifier|*
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|mods
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
modifier|*
name|opval
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
modifier|*
name|invalid
decl_stmt|;
block|{
define|#
directive|define
name|ST_SYNTAX
parameter_list|(
name|V
parameter_list|,
name|B
parameter_list|,
name|O
parameter_list|)
define|\
value|((ls_operand[LS_VALUE]  == (V)&& \   ls_operand[LS_BASE]   == (B)&& \   ls_operand[LS_OFFSET] == (O)))
if|if
condition|(
operator|!
operator|(
operator|(
name|ST_SYNTAX
argument_list|(
name|OP_REG
argument_list|,
name|OP_REG
argument_list|,
name|OP_NONE
argument_list|)
operator|&&
operator|(
name|insn
index|[
literal|0
index|]
operator|&
literal|511
operator|)
operator|==
literal|0
operator|)
operator|||
name|ST_SYNTAX
argument_list|(
name|OP_REG
argument_list|,
name|OP_LIMM
argument_list|,
name|OP_NONE
argument_list|)
operator|||
operator|(
name|ST_SYNTAX
argument_list|(
name|OP_SHIMM
argument_list|,
name|OP_REG
argument_list|,
name|OP_NONE
argument_list|)
operator|&&
operator|(
name|insn
index|[
literal|0
index|]
operator|&
literal|511
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|ST_SYNTAX
argument_list|(
name|OP_SHIMM
argument_list|,
name|OP_SHIMM
argument_list|,
name|OP_NONE
argument_list|)
operator|&&
operator|(
name|insn
index|[
literal|0
index|]
operator|&
literal|511
operator|)
operator|==
literal|0
operator|)
operator|||
name|ST_SYNTAX
argument_list|(
name|OP_SHIMM
argument_list|,
name|OP_LIMM
argument_list|,
name|OP_NONE
argument_list|)
operator|||
name|ST_SYNTAX
argument_list|(
name|OP_SHIMM
argument_list|,
name|OP_LIMM
argument_list|,
name|OP_SHIMM
argument_list|)
operator|||
name|ST_SYNTAX
argument_list|(
name|OP_SHIMM
argument_list|,
name|OP_SHIMM
argument_list|,
name|OP_SHIMM
argument_list|)
operator|||
operator|(
name|ST_SYNTAX
argument_list|(
name|OP_LIMM
argument_list|,
name|OP_REG
argument_list|,
name|OP_NONE
argument_list|)
operator|&&
operator|(
name|insn
index|[
literal|0
index|]
operator|&
literal|511
operator|)
operator|==
literal|0
operator|)
operator|||
name|ST_SYNTAX
argument_list|(
name|OP_REG
argument_list|,
name|OP_REG
argument_list|,
name|OP_SHIMM
argument_list|)
operator|||
name|ST_SYNTAX
argument_list|(
name|OP_REG
argument_list|,
name|OP_SHIMM
argument_list|,
name|OP_SHIMM
argument_list|)
operator|||
name|ST_SYNTAX
argument_list|(
name|OP_SHIMM
argument_list|,
name|OP_REG
argument_list|,
name|OP_SHIMM
argument_list|)
operator|||
name|ST_SYNTAX
argument_list|(
name|OP_LIMM
argument_list|,
name|OP_SHIMM
argument_list|,
name|OP_SHIMM
argument_list|)
operator|||
name|ST_SYNTAX
argument_list|(
name|OP_LIMM
argument_list|,
name|OP_SHIMM
argument_list|,
name|OP_NONE
argument_list|)
operator|||
name|ST_SYNTAX
argument_list|(
name|OP_LIMM
argument_list|,
name|OP_REG
argument_list|,
name|OP_SHIMM
argument_list|)
operator|)
condition|)
operator|*
name|invalid
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|arc_limm_fixup_adjust
parameter_list|(
name|insn
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
comment|/* check for st shimm,[limm].  */
if|if
condition|(
operator|(
name|insn
operator|&
operator|(
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|C
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|B
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
operator|)
operator|==
operator|(
name|I
argument_list|(
literal|2
argument_list|)
operator||
name|C
argument_list|(
name|ARC_REG_SHIMM
argument_list|)
operator||
name|B
argument_list|(
name|ARC_REG_LIMM
argument_list|)
operator|)
condition|)
block|{
name|retval
operator|=
name|insn
operator|&
literal|0x1ff
expr_stmt|;
if|if
condition|(
name|retval
operator|&
literal|0x100
condition|)
comment|/* sign extend 9 bit offset.  */
name|retval
operator||=
operator|~
literal|0x1ff
expr_stmt|;
block|}
return|return
operator|-
name|retval
return|;
comment|/* negate offset for return.  */
block|}
end_function

begin_comment
comment|/* Used in st insns to do final syntax check.  */
end_comment

begin_function
specifier|static
name|arc_insn
name|insert_st_syntax
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|mods
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|long
name|value
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
decl_stmt|;
block|{
if|if
condition|(
name|ST_SYNTAX
argument_list|(
name|OP_SHIMM
argument_list|,
name|OP_REG
argument_list|,
name|OP_NONE
argument_list|)
operator|&&
name|shimm
operator|!=
literal|0
condition|)
block|{
comment|/* change an illegal insn into a legal one, it's easier to 	 do it here than to try to handle it during operand scan.  */
name|limm_p
operator|=
literal|1
expr_stmt|;
name|limm
operator|=
name|shimm
expr_stmt|;
name|shimm_p
operator|=
literal|0
expr_stmt|;
name|shimm
operator|=
literal|0
expr_stmt|;
name|insn
operator|=
name|insn
operator|&
operator|~
operator|(
name|C
argument_list|(
operator|-
literal|1
argument_list|)
operator||
literal|511
operator|)
expr_stmt|;
name|insn
operator||=
name|ARC_REG_LIMM
operator|<<
name|ARC_SHIFT_REGC
expr_stmt|;
name|ls_operand
index|[
name|LS_VALUE
index|]
operator|=
name|OP_LIMM
expr_stmt|;
block|}
if|if
condition|(
name|ST_SYNTAX
argument_list|(
name|OP_REG
argument_list|,
name|OP_SHIMM
argument_list|,
name|OP_NONE
argument_list|)
operator|||
name|ST_SYNTAX
argument_list|(
name|OP_LIMM
argument_list|,
name|OP_SHIMM
argument_list|,
name|OP_NONE
argument_list|)
condition|)
block|{
comment|/* try to salvage this syntax.  */
if|if
condition|(
name|shimm
operator|&
literal|0x1
condition|)
comment|/* odd shimms won't work.  */
block|{
if|if
condition|(
name|limm_p
condition|)
comment|/* do we have a limm already?  */
block|{
operator|*
name|errmsg
operator|=
literal|"impossible store"
expr_stmt|;
block|}
name|limm_p
operator|=
literal|1
expr_stmt|;
name|limm
operator|=
name|shimm
expr_stmt|;
name|shimm
operator|=
literal|0
expr_stmt|;
name|shimm_p
operator|=
literal|0
expr_stmt|;
name|insn
operator|=
name|insn
operator|&
operator|~
operator|(
name|B
argument_list|(
operator|-
literal|1
argument_list|)
operator||
literal|511
operator|)
expr_stmt|;
name|insn
operator||=
name|B
argument_list|(
name|ARC_REG_LIMM
argument_list|)
expr_stmt|;
name|ls_operand
index|[
name|LS_BASE
index|]
operator|=
name|OP_LIMM
expr_stmt|;
block|}
else|else
block|{
name|shimm
operator|>>=
literal|1
expr_stmt|;
name|insn
operator|=
name|insn
operator|&
operator|~
literal|511
expr_stmt|;
name|insn
operator||=
name|shimm
expr_stmt|;
name|ls_operand
index|[
name|LS_OFFSET
index|]
operator|=
name|OP_SHIMM
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ST_SYNTAX
argument_list|(
name|OP_SHIMM
argument_list|,
name|OP_LIMM
argument_list|,
name|OP_NONE
argument_list|)
condition|)
block|{
name|limm
operator|+=
name|arc_limm_fixup_adjust
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|ST_SYNTAX
argument_list|(
name|OP_REG
argument_list|,
name|OP_REG
argument_list|,
name|OP_NONE
argument_list|)
operator|||
name|ST_SYNTAX
argument_list|(
name|OP_REG
argument_list|,
name|OP_LIMM
argument_list|,
name|OP_NONE
argument_list|)
operator|||
name|ST_SYNTAX
argument_list|(
name|OP_REG
argument_list|,
name|OP_REG
argument_list|,
name|OP_SHIMM
argument_list|)
operator|||
name|ST_SYNTAX
argument_list|(
name|OP_REG
argument_list|,
name|OP_SHIMM
argument_list|,
name|OP_SHIMM
argument_list|)
operator|||
operator|(
name|ST_SYNTAX
argument_list|(
name|OP_SHIMM
argument_list|,
name|OP_SHIMM
argument_list|,
name|OP_NONE
argument_list|)
operator|&&
operator|(
name|shimm
operator|==
literal|0
operator|)
operator|)
operator|||
name|ST_SYNTAX
argument_list|(
name|OP_SHIMM
argument_list|,
name|OP_LIMM
argument_list|,
name|OP_NONE
argument_list|)
operator|||
name|ST_SYNTAX
argument_list|(
name|OP_SHIMM
argument_list|,
name|OP_REG
argument_list|,
name|OP_NONE
argument_list|)
operator|||
name|ST_SYNTAX
argument_list|(
name|OP_SHIMM
argument_list|,
name|OP_REG
argument_list|,
name|OP_SHIMM
argument_list|)
operator|||
name|ST_SYNTAX
argument_list|(
name|OP_SHIMM
argument_list|,
name|OP_SHIMM
argument_list|,
name|OP_SHIMM
argument_list|)
operator|||
name|ST_SYNTAX
argument_list|(
name|OP_LIMM
argument_list|,
name|OP_SHIMM
argument_list|,
name|OP_SHIMM
argument_list|)
operator|||
name|ST_SYNTAX
argument_list|(
name|OP_LIMM
argument_list|,
name|OP_REG
argument_list|,
name|OP_NONE
argument_list|)
operator|||
name|ST_SYNTAX
argument_list|(
name|OP_LIMM
argument_list|,
name|OP_REG
argument_list|,
name|OP_SHIMM
argument_list|)
operator|)
condition|)
operator|*
name|errmsg
operator|=
literal|"st operand error"
expr_stmt|;
if|if
condition|(
name|addrwb_p
condition|)
block|{
if|if
condition|(
name|ls_operand
index|[
name|LS_BASE
index|]
operator|!=
name|OP_REG
condition|)
operator|*
name|errmsg
operator|=
literal|"address writeback not allowed"
expr_stmt|;
name|insn
operator||=
name|addrwb_p
expr_stmt|;
block|}
if|if
condition|(
name|ST_SYNTAX
argument_list|(
name|OP_SHIMM
argument_list|,
name|OP_REG
argument_list|,
name|OP_NONE
argument_list|)
operator|&&
name|shimm
condition|)
operator|*
name|errmsg
operator|=
literal|"store value must be zero"
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Used in ld insns to do final syntax check.  */
end_comment

begin_function
specifier|static
name|arc_insn
name|insert_ld_syntax
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|mods
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|long
name|value
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
decl_stmt|;
block|{
define|#
directive|define
name|LD_SYNTAX
parameter_list|(
name|D
parameter_list|,
name|B
parameter_list|,
name|O
parameter_list|)
define|\
value|((ls_operand[LS_DEST]  == (D)&& \   ls_operand[LS_BASE]   == (B)&& \   ls_operand[LS_OFFSET] == (O)))
name|int
name|test
init|=
name|insn
operator|&
name|I
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|test
operator|==
name|I
argument_list|(
literal|1
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ls_operand
index|[
name|LS_DEST
index|]
operator|==
name|OP_SHIMM
operator|||
name|ls_operand
index|[
name|LS_BASE
index|]
operator|==
name|OP_SHIMM
operator|||
name|ls_operand
index|[
name|LS_OFFSET
index|]
operator|==
name|OP_SHIMM
operator|)
condition|)
operator|*
name|errmsg
operator|=
literal|"invalid load/shimm insn"
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|LD_SYNTAX
argument_list|(
name|OP_REG
argument_list|,
name|OP_REG
argument_list|,
name|OP_NONE
argument_list|)
operator|||
name|LD_SYNTAX
argument_list|(
name|OP_REG
argument_list|,
name|OP_REG
argument_list|,
name|OP_REG
argument_list|)
operator|||
name|LD_SYNTAX
argument_list|(
name|OP_REG
argument_list|,
name|OP_REG
argument_list|,
name|OP_SHIMM
argument_list|)
operator|||
operator|(
name|LD_SYNTAX
argument_list|(
name|OP_REG
argument_list|,
name|OP_LIMM
argument_list|,
name|OP_REG
argument_list|)
operator|&&
operator|!
operator|(
name|test
operator|==
name|I
argument_list|(
literal|1
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|LD_SYNTAX
argument_list|(
name|OP_REG
argument_list|,
name|OP_REG
argument_list|,
name|OP_LIMM
argument_list|)
operator|&&
operator|!
operator|(
name|test
operator|==
name|I
argument_list|(
literal|1
argument_list|)
operator|)
operator|)
operator|||
name|LD_SYNTAX
argument_list|(
name|OP_REG
argument_list|,
name|OP_SHIMM
argument_list|,
name|OP_SHIMM
argument_list|)
operator|||
operator|(
name|LD_SYNTAX
argument_list|(
name|OP_REG
argument_list|,
name|OP_LIMM
argument_list|,
name|OP_NONE
argument_list|)
operator|&&
operator|(
name|test
operator|==
name|I
argument_list|(
literal|1
argument_list|)
operator|)
operator|)
operator|)
condition|)
operator|*
name|errmsg
operator|=
literal|"ld operand error"
expr_stmt|;
if|if
condition|(
name|addrwb_p
condition|)
block|{
if|if
condition|(
name|ls_operand
index|[
name|LS_BASE
index|]
operator|!=
name|OP_REG
condition|)
operator|*
name|errmsg
operator|=
literal|"address writeback not allowed"
expr_stmt|;
name|insn
operator||=
name|addrwb_p
expr_stmt|;
block|}
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Used in ld insns to do final syntax check.  */
end_comment

begin_function
specifier|static
name|long
name|extract_ld_syntax
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|opval
parameter_list|,
name|invalid
parameter_list|)
name|arc_insn
modifier|*
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|mods
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
modifier|*
name|opval
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
modifier|*
name|invalid
decl_stmt|;
block|{
name|int
name|test
init|=
name|insn
index|[
literal|0
index|]
operator|&
name|I
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|test
operator|==
name|I
argument_list|(
literal|1
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|ls_operand
index|[
name|LS_DEST
index|]
operator|==
name|OP_SHIMM
operator|||
name|ls_operand
index|[
name|LS_BASE
index|]
operator|==
name|OP_SHIMM
operator|||
name|ls_operand
index|[
name|LS_OFFSET
index|]
operator|==
name|OP_SHIMM
operator|)
condition|)
operator|*
name|invalid
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
operator|(
name|LD_SYNTAX
argument_list|(
name|OP_REG
argument_list|,
name|OP_REG
argument_list|,
name|OP_NONE
argument_list|)
operator|&&
operator|(
name|test
operator|==
name|I
argument_list|(
literal|1
argument_list|)
operator|)
operator|)
operator|||
name|LD_SYNTAX
argument_list|(
name|OP_REG
argument_list|,
name|OP_REG
argument_list|,
name|OP_REG
argument_list|)
operator|||
name|LD_SYNTAX
argument_list|(
name|OP_REG
argument_list|,
name|OP_REG
argument_list|,
name|OP_SHIMM
argument_list|)
operator|||
operator|(
name|LD_SYNTAX
argument_list|(
name|OP_REG
argument_list|,
name|OP_REG
argument_list|,
name|OP_LIMM
argument_list|)
operator|&&
operator|!
operator|(
name|test
operator|==
name|I
argument_list|(
literal|1
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|LD_SYNTAX
argument_list|(
name|OP_REG
argument_list|,
name|OP_LIMM
argument_list|,
name|OP_REG
argument_list|)
operator|&&
operator|!
operator|(
name|test
operator|==
name|I
argument_list|(
literal|1
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|LD_SYNTAX
argument_list|(
name|OP_REG
argument_list|,
name|OP_SHIMM
argument_list|,
name|OP_NONE
argument_list|)
operator|&&
operator|(
name|shimm
operator|==
literal|0
operator|)
operator|)
operator|||
name|LD_SYNTAX
argument_list|(
name|OP_REG
argument_list|,
name|OP_SHIMM
argument_list|,
name|OP_SHIMM
argument_list|)
operator|||
operator|(
name|LD_SYNTAX
argument_list|(
name|OP_REG
argument_list|,
name|OP_LIMM
argument_list|,
name|OP_NONE
argument_list|)
operator|&&
operator|(
name|test
operator|==
name|I
argument_list|(
literal|1
argument_list|)
operator|)
operator|)
operator|)
condition|)
operator|*
name|invalid
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Called at the end of processing normal insns (eg: add) to insert a shimm    value (if present) into the insn.  */
end_comment

begin_function
specifier|static
name|arc_insn
name|insert_shimmfinish
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|long
name|value
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|shimm_p
condition|)
name|insn
operator||=
operator|(
name|shimm
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|operand
operator|->
name|shift
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Called at the end of processing normal insns (eg: add) to insert a limm    value (if present) into the insn.     Note that this function is only intended to handle instructions (with 4 byte    immediate operands).  It is not intended to handle data.  */
end_comment

begin_comment
comment|/* ??? Actually, there's nothing for us to do as we can't call frag_more, the    caller must do that.  The extract fns take a pointer to two words.  The    insert fns could be converted and then we could do something useful, but    then the reloc handlers would have to know to work on the second word of    a 2 word quantity.  That's too much so we don't handle them.  */
end_comment

begin_function
specifier|static
name|arc_insn
name|insert_limmfinish
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|mods
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|long
name|value
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|#
directive|if
literal|0
block|if (limm_p)     ;
comment|/* nothing to do, gas does it.  */
endif|#
directive|endif
return|return
name|insn
return|;
block|}
end_function

begin_function
specifier|static
name|arc_insn
name|insert_jumpflags
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|long
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|flag_p
condition|)
block|{
operator|*
name|errmsg
operator|=
literal|"jump flags, but no .f seen"
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|limm_p
condition|)
block|{
operator|*
name|errmsg
operator|=
literal|"jump flags, but no limm addr"
expr_stmt|;
block|}
if|if
condition|(
name|limm
operator|&
literal|0xfc000000
condition|)
block|{
operator|*
name|errmsg
operator|=
literal|"flag bits of jump address limm lost"
expr_stmt|;
block|}
if|if
condition|(
name|limm
operator|&
literal|0x03000000
condition|)
block|{
operator|*
name|errmsg
operator|=
literal|"attempt to set HR bits"
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|value
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
name|value
condition|)
block|{
operator|*
name|errmsg
operator|=
literal|"bad jump flags value"
expr_stmt|;
block|}
name|jumpflags_p
operator|=
literal|1
expr_stmt|;
name|limm
operator|=
operator|(
operator|(
name|limm
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|shift
operator|)
operator|-
literal|1
operator|)
operator|)
operator||
operator|(
operator|(
name|value
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|operand
operator|->
name|shift
operator|)
operator|)
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Called at the end of unary operand macros to copy the B field to C.  */
end_comment

begin_function
specifier|static
name|arc_insn
name|insert_unopmacro
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|long
name|value
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|insn
operator||=
operator|(
operator|(
name|insn
operator|>>
name|ARC_SHIFT_REGB
operator|)
operator|&
name|ARC_MASK_REG
operator|)
operator|<<
name|operand
operator|->
name|shift
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Insert a relative address for a branch insn (b, bl, or lp).  */
end_comment

begin_function
specifier|static
name|arc_insn
name|insert_reladdr
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|long
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
decl_stmt|;
block|{
if|if
condition|(
name|value
operator|&
literal|3
condition|)
operator|*
name|errmsg
operator|=
literal|"branch address not on 4 byte boundary"
expr_stmt|;
name|insn
operator||=
operator|(
operator|(
name|value
operator|>>
literal|2
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|operand
operator|->
name|shift
expr_stmt|;
return|return
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Insert a limm value as a 26 bit address right shifted 2 into the insn.     Note that this function is only intended to handle instructions (with 4 byte    immediate operands).  It is not intended to handle data.  */
end_comment

begin_comment
comment|/* ??? Actually, there's little for us to do as we can't call frag_more, the    caller must do that.  The extract fns take a pointer to two words.  The    insert fns could be converted and then we could do something useful, but    then the reloc handlers would have to know to work on the second word of    a 2 word quantity.  That's too much so we don't handle them.     We do check for correct usage of the nullify suffix, or we    set the default correctly, though.  */
end_comment

begin_function
specifier|static
name|arc_insn
name|insert_absaddr
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|reg
parameter_list|,
name|value
parameter_list|,
name|errmsg
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|mods
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|long
name|value
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|errmsg
decl_stmt|;
block|{
if|if
condition|(
name|limm_p
condition|)
block|{
comment|/* if it is a jump and link, .jd must be specified.  */
if|if
condition|(
name|insn
operator|&
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|9
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|nullify_p
condition|)
block|{
name|insn
operator||=
literal|0x02
operator|<<
literal|5
expr_stmt|;
comment|/* default nullify to .jd.  */
block|}
else|else
block|{
if|if
condition|(
name|nullify
operator|!=
literal|0x02
condition|)
block|{
operator|*
name|errmsg
operator|=
literal|"must specify .jd or no nullify suffix"
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|insn
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Extraction functions.     The suffix extraction functions' return value is redundant since it can be    obtained from (*OPVAL)->value.  However, the boolean suffixes don't have    a suffix table entry for the "false" case, so values of zero must be    obtained from the return value (*OPVAL == NULL).  */
end_comment

begin_function_decl
specifier|static
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|lookup_register
parameter_list|(
name|int
name|type
parameter_list|,
name|long
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Called by the disassembler before printing an instruction.  */
end_comment

begin_function
name|void
name|arc_opcode_init_extract
parameter_list|()
block|{
name|arc_opcode_init_insert
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* As we're extracting registers, keep an eye out for the 'f' indicator    (ARC_REG_SHIMM_UPDATE).  If we find a register (not a constant marker,    like ARC_REG_SHIMM), set OPVAL so our caller will know this is a register.     We must also handle auxiliary registers for lr/sr insns.  They are just    constants with special names.  */
end_comment

begin_function
specifier|static
name|long
name|extract_reg
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|opval
parameter_list|,
name|invalid
parameter_list|)
name|arc_insn
modifier|*
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
modifier|*
name|opval
decl_stmt|;
name|int
modifier|*
name|invalid
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
name|long
name|value
decl_stmt|;
name|enum
name|operand
name|op_type
decl_stmt|;
comment|/* Get the register number.  */
name|regno
operator|=
operator|(
operator|*
name|insn
operator|>>
name|operand
operator|->
name|shift
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Is it a constant marker?  */
if|if
condition|(
name|regno
operator|==
name|ARC_REG_SHIMM
condition|)
block|{
name|op_type
operator|=
name|OP_SHIMM
expr_stmt|;
comment|/* always return zero if dest is a shimm  mlm.  */
if|if
condition|(
literal|'a'
operator|!=
name|operand
operator|->
name|fmt
condition|)
block|{
name|value
operator|=
operator|*
name|insn
operator|&
literal|511
expr_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_SIGNED
operator|)
operator|&&
operator|(
name|value
operator|&
literal|256
operator|)
condition|)
name|value
operator|-=
literal|512
expr_stmt|;
if|if
condition|(
operator|!
name|flagshimm_handled_p
condition|)
name|flag_p
operator|=
literal|0
expr_stmt|;
name|flagshimm_handled_p
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
name|ARC_REG_SHIMM_UPDATE
condition|)
block|{
name|op_type
operator|=
name|OP_SHIMM
expr_stmt|;
comment|/* always return zero if dest is a shimm  mlm.  */
if|if
condition|(
literal|'a'
operator|!=
name|operand
operator|->
name|fmt
condition|)
block|{
name|value
operator|=
operator|*
name|insn
operator|&
literal|511
expr_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_SIGNED
operator|)
operator|&&
operator|(
name|value
operator|&
literal|256
operator|)
condition|)
name|value
operator|-=
literal|512
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
literal|0
expr_stmt|;
block|}
name|flag_p
operator|=
literal|1
expr_stmt|;
name|flagshimm_handled_p
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
name|ARC_REG_LIMM
condition|)
block|{
name|op_type
operator|=
name|OP_LIMM
expr_stmt|;
name|value
operator|=
name|insn
index|[
literal|1
index|]
expr_stmt|;
name|limm_p
operator|=
literal|1
expr_stmt|;
comment|/* if this is a jump instruction (j,jl), show new pc correctly.  */
if|if
condition|(
literal|0x07
operator|==
operator|(
operator|(
operator|*
name|insn
operator|&
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
operator|>>
literal|27
operator|)
condition|)
block|{
name|value
operator|=
operator|(
name|value
operator|&
literal|0xffffff
operator|)
expr_stmt|;
block|}
block|}
comment|/* It's a register, set OPVAL (that's the only way we distinguish registers      from constants here).  */
else|else
block|{
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
init|=
name|lookup_register
argument_list|(
name|REG
argument_list|,
name|regno
argument_list|)
decl_stmt|;
name|op_type
operator|=
name|OP_REG
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|opval
operator|!=
name|NULL
condition|)
operator|*
name|opval
operator|=
name|reg
expr_stmt|;
name|value
operator|=
name|regno
expr_stmt|;
block|}
comment|/* If this field takes an auxiliary register, see if it's a known one.  */
if|if
condition|(
operator|(
name|mods
operator|&
name|ARC_MOD_AUXREG
operator|)
operator|&&
name|ARC_REG_CONSTANT_P
argument_list|(
name|regno
argument_list|)
condition|)
block|{
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|reg
init|=
name|lookup_register
argument_list|(
name|AUXREG
argument_list|,
name|value
argument_list|)
decl_stmt|;
comment|/* This is really a constant, but tell the caller it has a special 	 name.  */
if|if
condition|(
name|reg
operator|!=
name|NULL
operator|&&
name|opval
operator|!=
name|NULL
condition|)
operator|*
name|opval
operator|=
name|reg
expr_stmt|;
block|}
switch|switch
condition|(
name|operand
operator|->
name|fmt
condition|)
block|{
case|case
literal|'a'
case|:
name|ls_operand
index|[
name|LS_DEST
index|]
operator|=
name|op_type
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|ls_operand
index|[
name|LS_BASE
index|]
operator|=
name|op_type
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
operator|(
name|insn
index|[
literal|0
index|]
operator|&
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
operator|==
name|I
argument_list|(
literal|2
argument_list|)
condition|)
name|ls_operand
index|[
name|LS_VALUE
index|]
operator|=
name|op_type
expr_stmt|;
else|else
name|ls_operand
index|[
name|LS_OFFSET
index|]
operator|=
name|op_type
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
case|case
literal|'O'
case|:
name|ls_operand
index|[
name|LS_OFFSET
index|]
operator|=
name|op_type
expr_stmt|;
break|break;
block|}
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Return the value of the "flag update" field for shimm insns.    This value is actually stored in the register field.  */
end_comment

begin_function
specifier|static
name|long
name|extract_flag
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|opval
parameter_list|,
name|invalid
parameter_list|)
name|arc_insn
modifier|*
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
modifier|*
name|opval
decl_stmt|;
name|int
modifier|*
name|invalid
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|f
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|val
decl_stmt|;
if|if
condition|(
name|flagshimm_handled_p
condition|)
name|f
operator|=
name|flag_p
operator|!=
literal|0
expr_stmt|;
else|else
name|f
operator|=
operator|(
operator|*
name|insn
operator|&
operator|(
literal|1
operator|<<
name|operand
operator|->
name|shift
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* There is no text for zero values.  */
if|if
condition|(
name|f
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|flag_p
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|arc_opcode_lookup_suffix
argument_list|(
name|operand
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|opval
operator|!=
name|NULL
operator|&&
name|val
operator|!=
name|NULL
condition|)
operator|*
name|opval
operator|=
name|val
expr_stmt|;
return|return
name|val
operator|->
name|value
return|;
block|}
end_function

begin_comment
comment|/* Extract the condition code (if it exists).    If we've seen a shimm value in this insn (meaning that the insn can't have    a condition code field), then we don't store anything in OPVAL and return    zero.  */
end_comment

begin_function
specifier|static
name|long
name|extract_cond
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|opval
parameter_list|,
name|invalid
parameter_list|)
name|arc_insn
modifier|*
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
modifier|*
name|opval
decl_stmt|;
name|int
modifier|*
name|invalid
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|long
name|cond
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|val
decl_stmt|;
if|if
condition|(
name|flagshimm_handled_p
condition|)
return|return
literal|0
return|;
name|cond
operator|=
operator|(
operator|*
name|insn
operator|>>
name|operand
operator|->
name|shift
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|val
operator|=
name|arc_opcode_lookup_suffix
argument_list|(
name|operand
argument_list|,
name|cond
argument_list|)
expr_stmt|;
comment|/* Ignore NULL values of `val'.  Several condition code values are      reserved for extensions.  */
if|if
condition|(
name|opval
operator|!=
name|NULL
operator|&&
name|val
operator|!=
name|NULL
condition|)
operator|*
name|opval
operator|=
name|val
expr_stmt|;
return|return
name|cond
return|;
block|}
end_function

begin_comment
comment|/* Extract a branch address.    We return the value as a real address (not right shifted by 2).  */
end_comment

begin_function
specifier|static
name|long
name|extract_reladdr
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|opval
parameter_list|,
name|invalid
parameter_list|)
name|arc_insn
modifier|*
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
modifier|*
name|opval
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
modifier|*
name|invalid
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|long
name|addr
decl_stmt|;
name|addr
operator|=
operator|(
operator|*
name|insn
operator|>>
name|operand
operator|->
name|shift
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_SIGNED
operator|)
operator|&&
operator|(
name|addr
operator|&
operator|(
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|addr
operator|-=
literal|1
operator|<<
name|operand
operator|->
name|bits
expr_stmt|;
return|return
name|addr
operator|<<
literal|2
return|;
block|}
end_function

begin_comment
comment|/* extract the flags bits from a j or jl long immediate.  */
end_comment

begin_function
specifier|static
name|long
name|extract_jumpflags
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|opval
parameter_list|,
name|invalid
parameter_list|)
name|arc_insn
modifier|*
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
modifier|*
name|opval
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
modifier|*
name|invalid
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|flag_p
operator|||
operator|!
name|limm_p
condition|)
operator|*
name|invalid
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|(
name|flag_p
operator|&&
name|limm_p
operator|)
condition|?
operator|(
name|insn
index|[
literal|1
index|]
operator|>>
name|operand
operator|->
name|shift
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* extract st insn's offset.  */
end_comment

begin_function
specifier|static
name|long
name|extract_st_offset
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|opval
parameter_list|,
name|invalid
parameter_list|)
name|arc_insn
modifier|*
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
modifier|*
name|opval
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
modifier|*
name|invalid
decl_stmt|;
block|{
name|int
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ls_operand
index|[
name|LS_VALUE
index|]
operator|!=
name|OP_SHIMM
operator|||
name|ls_operand
index|[
name|LS_BASE
index|]
operator|!=
name|OP_LIMM
condition|)
block|{
name|value
operator|=
name|insn
index|[
literal|0
index|]
operator|&
literal|511
expr_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_SIGNED
operator|)
operator|&&
operator|(
name|value
operator|&
literal|256
operator|)
condition|)
name|value
operator|-=
literal|512
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|ls_operand
index|[
name|LS_OFFSET
index|]
operator|=
name|OP_SHIMM
expr_stmt|;
block|}
else|else
block|{
operator|*
name|invalid
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* extract ld insn's offset.  */
end_comment

begin_function
specifier|static
name|long
name|extract_ld_offset
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|opval
parameter_list|,
name|invalid
parameter_list|)
name|arc_insn
modifier|*
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
decl_stmt|;
name|int
name|mods
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
modifier|*
name|opval
decl_stmt|;
name|int
modifier|*
name|invalid
decl_stmt|;
block|{
name|int
name|test
init|=
name|insn
index|[
literal|0
index|]
operator|&
name|I
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
name|int
name|value
decl_stmt|;
if|if
condition|(
name|test
condition|)
block|{
name|value
operator|=
name|insn
index|[
literal|0
index|]
operator|&
literal|511
expr_stmt|;
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|ARC_OPERAND_SIGNED
operator|)
operator|&&
operator|(
name|value
operator|&
literal|256
operator|)
condition|)
name|value
operator|-=
literal|512
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|ls_operand
index|[
name|LS_OFFSET
index|]
operator|=
name|OP_SHIMM
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
comment|/* if it isn't in the insn, it's concealed behind reg 'c'.  */
return|return
name|extract_reg
argument_list|(
name|insn
argument_list|,
operator|&
name|arc_operands
index|[
name|arc_operand_map
index|[
literal|'c'
index|]
index|]
argument_list|,
name|mods
argument_list|,
name|opval
argument_list|,
name|invalid
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The only thing this does is set the `invalid' flag if B != C.    This is needed because the "mov" macro appears before it's real insn "and"    and we don't want the disassembler to confuse them.  */
end_comment

begin_function
specifier|static
name|long
name|extract_unopmacro
parameter_list|(
name|insn
parameter_list|,
name|operand
parameter_list|,
name|mods
parameter_list|,
name|opval
parameter_list|,
name|invalid
parameter_list|)
name|arc_insn
modifier|*
name|insn
decl_stmt|;
specifier|const
name|struct
name|arc_operand
modifier|*
name|operand
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|mods
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|struct
name|arc_operand_value
modifier|*
modifier|*
name|opval
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
modifier|*
name|invalid
decl_stmt|;
block|{
comment|/* This misses the case where B == ARC_REG_SHIMM_UPDATE&&      C == ARC_REG_SHIMM (or vice versa).  No big deal.  Those insns will get      printed as "and"s.  */
if|if
condition|(
operator|(
operator|(
operator|*
name|insn
operator|>>
name|ARC_SHIFT_REGB
operator|)
operator|&
name|ARC_MASK_REG
operator|)
operator|!=
operator|(
operator|(
operator|*
name|insn
operator|>>
name|ARC_SHIFT_REGC
operator|)
operator|&
name|ARC_MASK_REG
operator|)
condition|)
if|if
condition|(
name|invalid
operator|!=
name|NULL
condition|)
operator|*
name|invalid
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Utility for the extraction functions to return the index into    `arc_suffixes'.  */
end_comment

begin_function
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|arc_opcode_lookup_suffix
parameter_list|(
name|type
parameter_list|,
name|value
parameter_list|)
specifier|const
name|struct
name|arc_operand
modifier|*
name|type
decl_stmt|;
name|int
name|value
decl_stmt|;
block|{
specifier|register
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|v
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|struct
name|arc_ext_operand_value
modifier|*
name|ext_oper
init|=
name|arc_ext_operands
decl_stmt|;
while|while
condition|(
name|ext_oper
condition|)
block|{
if|if
condition|(
name|type
operator|==
operator|&
name|arc_operands
index|[
name|ext_oper
operator|->
name|operand
operator|.
name|type
index|]
operator|&&
name|value
operator|==
name|ext_oper
operator|->
name|operand
operator|.
name|value
condition|)
return|return
operator|(
operator|&
name|ext_oper
operator|->
name|operand
operator|)
return|;
name|ext_oper
operator|=
name|ext_oper
operator|->
name|next
expr_stmt|;
block|}
comment|/* ??? This is a little slow and can be speeded up.  */
for|for
control|(
name|v
operator|=
name|arc_suffixes
operator|,
name|end
operator|=
name|arc_suffixes
operator|+
name|arc_suffixes_count
init|;
name|v
operator|<
name|end
condition|;
operator|++
name|v
control|)
if|if
condition|(
name|type
operator|==
operator|&
name|arc_operands
index|[
name|v
operator|->
name|type
index|]
operator|&&
name|value
operator|==
name|v
operator|->
name|value
condition|)
return|return
name|v
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|lookup_register
parameter_list|(
name|type
parameter_list|,
name|regno
parameter_list|)
name|int
name|type
decl_stmt|;
name|long
name|regno
decl_stmt|;
block|{
specifier|register
specifier|const
name|struct
name|arc_operand_value
modifier|*
name|r
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|struct
name|arc_ext_operand_value
modifier|*
name|ext_oper
init|=
name|arc_ext_operands
decl_stmt|;
while|while
condition|(
name|ext_oper
condition|)
block|{
if|if
condition|(
name|ext_oper
operator|->
name|operand
operator|.
name|type
operator|==
name|type
operator|&&
name|ext_oper
operator|->
name|operand
operator|.
name|value
operator|==
name|regno
condition|)
return|return
operator|(
operator|&
name|ext_oper
operator|->
name|operand
operator|)
return|;
name|ext_oper
operator|=
name|ext_oper
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|REG
condition|)
return|return
operator|&
name|arc_reg_names
index|[
name|regno
index|]
return|;
comment|/* ??? This is a little slow and can be speeded up.  */
for|for
control|(
name|r
operator|=
name|arc_reg_names
operator|,
name|end
operator|=
name|arc_reg_names
operator|+
name|arc_reg_names_count
init|;
name|r
operator|<
name|end
condition|;
operator|++
name|r
control|)
if|if
condition|(
name|type
operator|==
name|r
operator|->
name|type
operator|&&
name|regno
operator|==
name|r
operator|->
name|value
condition|)
return|return
name|r
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|arc_insn_is_j
parameter_list|(
name|insn
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
block|{
return|return
operator|(
name|insn
operator|&
operator|(
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
operator|)
operator|==
name|I
argument_list|(
literal|0x7
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|arc_insn_not_jl
parameter_list|(
name|insn
parameter_list|)
name|arc_insn
name|insn
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|insn
operator|&
operator|(
name|I
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|A
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|C
argument_list|(
operator|-
literal|1
argument_list|)
operator||
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|)
operator||
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|9
argument_list|,
literal|1
argument_list|)
operator|)
operator|)
operator|!=
operator|(
name|I
argument_list|(
literal|0x7
argument_list|)
operator||
name|R
argument_list|(
operator|-
literal|1
argument_list|,
literal|9
argument_list|,
literal|1
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|arc_operand_type
parameter_list|(
name|int
name|opertype
parameter_list|)
block|{
switch|switch
condition|(
name|opertype
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|(
name|COND
operator|)
return|;
break|break;
case|case
literal|1
case|:
return|return
operator|(
name|REG
operator|)
return|;
break|break;
case|case
literal|2
case|:
return|return
operator|(
name|AUXREG
operator|)
return|;
break|break;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|struct
name|arc_operand_value
modifier|*
name|get_ext_suffix
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|arc_ext_operand_value
modifier|*
name|suffix
init|=
name|arc_ext_operands
decl_stmt|;
while|while
condition|(
name|suffix
condition|)
block|{
if|if
condition|(
operator|(
name|COND
operator|==
name|suffix
operator|->
name|operand
operator|.
name|type
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|s
argument_list|,
name|suffix
operator|->
name|operand
operator|.
name|name
argument_list|)
condition|)
return|return
operator|(
operator|&
name|suffix
operator|->
name|operand
operator|)
return|;
name|suffix
operator|=
name|suffix
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|arc_get_noshortcut_flag
parameter_list|()
block|{
return|return
name|ARC_REGISTER_NOSHORT_CUT
return|;
block|}
end_function

end_unit

