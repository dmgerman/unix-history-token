begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print SPARC instructions.    Copyright 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000 Free Software Foundation, Inc.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"opcode/sparc.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"opintl.h"
end_include

begin_comment
comment|/* Bitmask of v9 architectures.  */
end_comment

begin_define
define|#
directive|define
name|MASK_V9
value|((1<< SPARC_OPCODE_ARCH_V9) \ 		 | (1<< SPARC_OPCODE_ARCH_V9A) \ 		 | (1<< SPARC_OPCODE_ARCH_V9B))
end_define

begin_comment
comment|/* 1 if INSN is for v9 only.  */
end_comment

begin_define
define|#
directive|define
name|V9_ONLY_P
parameter_list|(
name|insn
parameter_list|)
value|(! ((insn)->architecture& ~MASK_V9))
end_define

begin_comment
comment|/* 1 if INSN is for v9.  */
end_comment

begin_define
define|#
directive|define
name|V9_P
parameter_list|(
name|insn
parameter_list|)
value|(((insn)->architecture& MASK_V9) != 0)
end_define

begin_comment
comment|/* The sorted opcode table.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sparc_opcode
modifier|*
modifier|*
name|sorted_opcodes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For faster lookup, after insns are sorted they are hashed.  */
end_comment

begin_comment
comment|/* ??? I think there is room for even more improvement.  */
end_comment

begin_define
define|#
directive|define
name|HASH_SIZE
value|256
end_define

begin_comment
comment|/* It is important that we only look at insn code bits as that is how the    opcode table is hashed.  OPCODE_BITS is a table of valid bits for each    of the main types (0,1,2,3).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|opcode_bits
index|[
literal|4
index|]
init|=
block|{
literal|0x01c00000
block|,
literal|0x0
block|,
literal|0x01f80000
block|,
literal|0x01f80000
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HASH_INSN
parameter_list|(
name|INSN
parameter_list|)
define|\
value|((((INSN)>> 24)& 0xc0) | (((INSN)& opcode_bits[((INSN)>> 30)& 3])>> 19))
end_define

begin_struct
struct|struct
name|opcode_hash
block|{
name|struct
name|opcode_hash
modifier|*
name|next
decl_stmt|;
specifier|const
name|struct
name|sparc_opcode
modifier|*
name|opcode
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|opcode_hash
modifier|*
name|opcode_hash_table
index|[
name|HASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_hash_table
name|PARAMS
argument_list|(
operator|(
specifier|const
expr|struct
name|sparc_opcode
operator|*
operator|*
operator|,
expr|struct
name|opcode_hash
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_delayed_branch
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_opcodes
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compute_arch_mask
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sign-extend a value which is N bits long.  */
end_comment

begin_define
define|#
directive|define
name|SEX
parameter_list|(
name|value
parameter_list|,
name|bits
parameter_list|)
define|\
value|((((int)(value))<< ((8 * sizeof (int)) - bits))	\>> ((8 * sizeof (int)) - bits) )
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reg_names
index|[]
init|=
block|{
literal|"g0"
block|,
literal|"g1"
block|,
literal|"g2"
block|,
literal|"g3"
block|,
literal|"g4"
block|,
literal|"g5"
block|,
literal|"g6"
block|,
literal|"g7"
block|,
literal|"o0"
block|,
literal|"o1"
block|,
literal|"o2"
block|,
literal|"o3"
block|,
literal|"o4"
block|,
literal|"o5"
block|,
literal|"sp"
block|,
literal|"o7"
block|,
literal|"l0"
block|,
literal|"l1"
block|,
literal|"l2"
block|,
literal|"l3"
block|,
literal|"l4"
block|,
literal|"l5"
block|,
literal|"l6"
block|,
literal|"l7"
block|,
literal|"i0"
block|,
literal|"i1"
block|,
literal|"i2"
block|,
literal|"i3"
block|,
literal|"i4"
block|,
literal|"i5"
block|,
literal|"fp"
block|,
literal|"i7"
block|,
literal|"f0"
block|,
literal|"f1"
block|,
literal|"f2"
block|,
literal|"f3"
block|,
literal|"f4"
block|,
literal|"f5"
block|,
literal|"f6"
block|,
literal|"f7"
block|,
literal|"f8"
block|,
literal|"f9"
block|,
literal|"f10"
block|,
literal|"f11"
block|,
literal|"f12"
block|,
literal|"f13"
block|,
literal|"f14"
block|,
literal|"f15"
block|,
literal|"f16"
block|,
literal|"f17"
block|,
literal|"f18"
block|,
literal|"f19"
block|,
literal|"f20"
block|,
literal|"f21"
block|,
literal|"f22"
block|,
literal|"f23"
block|,
literal|"f24"
block|,
literal|"f25"
block|,
literal|"f26"
block|,
literal|"f27"
block|,
literal|"f28"
block|,
literal|"f29"
block|,
literal|"f30"
block|,
literal|"f31"
block|,
literal|"f32"
block|,
literal|"f33"
block|,
literal|"f34"
block|,
literal|"f35"
block|,
literal|"f36"
block|,
literal|"f37"
block|,
literal|"f38"
block|,
literal|"f39"
block|,
literal|"f40"
block|,
literal|"f41"
block|,
literal|"f42"
block|,
literal|"f43"
block|,
literal|"f44"
block|,
literal|"f45"
block|,
literal|"f46"
block|,
literal|"f47"
block|,
literal|"f48"
block|,
literal|"f49"
block|,
literal|"f50"
block|,
literal|"f51"
block|,
literal|"f52"
block|,
literal|"f53"
block|,
literal|"f54"
block|,
literal|"f55"
block|,
literal|"f56"
block|,
literal|"f57"
block|,
literal|"f58"
block|,
literal|"f59"
block|,
literal|"f60"
block|,
literal|"f61"
block|,
literal|"f62"
block|,
literal|"f63"
block|,
comment|/* psr, wim, tbr, fpsr, cpsr are v8 only.  */
literal|"y"
block|,
literal|"psr"
block|,
literal|"wim"
block|,
literal|"tbr"
block|,
literal|"pc"
block|,
literal|"npc"
block|,
literal|"fpsr"
block|,
literal|"cpsr"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|freg_names
value|(&reg_names[4 * 8])
end_define

begin_comment
comment|/* These are ordered according to there register number in    rdpr and wrpr insns.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|v9_priv_reg_names
index|[]
init|=
block|{
literal|"tpc"
block|,
literal|"tnpc"
block|,
literal|"tstate"
block|,
literal|"tt"
block|,
literal|"tick"
block|,
literal|"tba"
block|,
literal|"pstate"
block|,
literal|"tl"
block|,
literal|"pil"
block|,
literal|"cwp"
block|,
literal|"cansave"
block|,
literal|"canrestore"
block|,
literal|"cleanwin"
block|,
literal|"otherwin"
block|,
literal|"wstate"
block|,
literal|"fq"
comment|/* "ver" - special cased */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are ordered according to there register number in    rd and wr insns (-16).  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|v9a_asr_reg_names
index|[]
init|=
block|{
literal|"pcr"
block|,
literal|"pic"
block|,
literal|"dcr"
block|,
literal|"gsr"
block|,
literal|"set_softint"
block|,
literal|"clear_softint"
block|,
literal|"softint"
block|,
literal|"tick_cmpr"
block|,
literal|"sys_tick"
block|,
literal|"sys_tick_cmpr"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macros used to extract instruction fields.  Not all fields have    macros defined here, only those which are actually used.  */
end_comment

begin_define
define|#
directive|define
name|X_RD
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 25)& 0x1f)
end_define

begin_define
define|#
directive|define
name|X_RS1
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 14)& 0x1f)
end_define

begin_define
define|#
directive|define
name|X_LDST_I
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 13)& 1)
end_define

begin_define
define|#
directive|define
name|X_ASI
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 5)& 0xff)
end_define

begin_define
define|#
directive|define
name|X_RS2
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 0)& 0x1f)
end_define

begin_define
define|#
directive|define
name|X_IMM
parameter_list|(
name|i
parameter_list|,
name|n
parameter_list|)
value|(((i)>> 0)& ((1<< (n)) - 1))
end_define

begin_define
define|#
directive|define
name|X_SIMM
parameter_list|(
name|i
parameter_list|,
name|n
parameter_list|)
value|SEX (X_IMM ((i), (n)), (n))
end_define

begin_define
define|#
directive|define
name|X_DISP22
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 0)& 0x3fffff)
end_define

begin_define
define|#
directive|define
name|X_IMM22
parameter_list|(
name|i
parameter_list|)
value|X_DISP22 (i)
end_define

begin_define
define|#
directive|define
name|X_DISP30
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 0)& 0x3fffffff)
end_define

begin_comment
comment|/* These are for v9.  */
end_comment

begin_define
define|#
directive|define
name|X_DISP16
parameter_list|(
name|i
parameter_list|)
value|(((((i)>> 20)& 3)<< 14) | (((i)>> 0)& 0x3fff))
end_define

begin_define
define|#
directive|define
name|X_DISP19
parameter_list|(
name|i
parameter_list|)
value|(((i)>> 0)& 0x7ffff)
end_define

begin_define
define|#
directive|define
name|X_MEMBAR
parameter_list|(
name|i
parameter_list|)
value|((i)& 0x7f)
end_define

begin_comment
comment|/* Here is the union which was used to extract instruction fields    before the shift and mask macros were written.     union sparc_insn      {        unsigned long int code;        struct 	 { 	   unsigned int anop:2; 	   #define	op	ldst.anop 	   unsigned int anrd:5; 	   #define	rd	ldst.anrd 	   unsigned int op3:6; 	   unsigned int anrs1:5; 	   #define	rs1	ldst.anrs1 	   unsigned int i:1; 	   unsigned int anasi:8; 	   #define	asi	ldst.anasi 	   unsigned int anrs2:5; 	   #define	rs2	ldst.anrs2 	   #define	shcnt	rs2 	 } ldst;        struct 	 { 	   unsigned int anop:2, anrd:5, op3:6, anrs1:5, i:1; 	   unsigned int IMM13:13; 	   #define	imm13	IMM13.IMM13 	 } IMM13;        struct 	 { 	   unsigned int anop:2; 	   unsigned int a:1; 	   unsigned int cond:4; 	   unsigned int op2:3; 	   unsigned int DISP22:22; 	   #define	disp22	branch.DISP22 	   #define	imm22	disp22 	 } branch;        struct 	 { 	   unsigned int anop:2; 	   unsigned int a:1; 	   unsigned int z:1; 	   unsigned int rcond:3; 	   unsigned int op2:3; 	   unsigned int DISP16HI:2; 	   unsigned int p:1; 	   unsigned int _rs1:5; 	   unsigned int DISP16LO:14; 	 } branch16;        struct 	 { 	   unsigned int anop:2; 	   unsigned int adisp30:30; 	   #define	disp30	call.adisp30 	 } call;      };     */
end_comment

begin_comment
comment|/* Nonzero if INSN is the opcode for a delayed branch.  */
end_comment

begin_function
specifier|static
name|int
name|is_delayed_branch
parameter_list|(
name|insn
parameter_list|)
name|unsigned
name|long
name|insn
decl_stmt|;
block|{
name|struct
name|opcode_hash
modifier|*
name|op
decl_stmt|;
for|for
control|(
name|op
operator|=
name|opcode_hash_table
index|[
name|HASH_INSN
argument_list|(
name|insn
argument_list|)
index|]
init|;
name|op
condition|;
name|op
operator|=
name|op
operator|->
name|next
control|)
block|{
name|CONST
name|struct
name|sparc_opcode
modifier|*
name|opcode
init|=
name|op
operator|->
name|opcode
decl_stmt|;
if|if
condition|(
operator|(
name|opcode
operator|->
name|match
operator|&
name|insn
operator|)
operator|==
name|opcode
operator|->
name|match
operator|&&
operator|(
name|opcode
operator|->
name|lose
operator|&
name|insn
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|opcode
operator|->
name|flags
operator|&
name|F_DELAYED
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* extern void qsort (); */
end_comment

begin_comment
comment|/* Records current mask of SPARC_OPCODE_ARCH_FOO values, used to pass value    to compare_opcodes.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|current_arch_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print one instruction from MEMADDR on INFO->STREAM.     We suffix the instruction with a comment that gives the absolute    address involved, as well as its symbolic form, if the instruction    is preceded by a findable `sethi' and it either adds an immediate    displacement to that register, or it is an `add' or `or' instruction    on that register.  */
end_comment

begin_function
name|int
name|print_insn_sparc
parameter_list|(
name|memaddr
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|memaddr
decl_stmt|;
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
name|FILE
modifier|*
name|stream
init|=
name|info
operator|->
name|stream
decl_stmt|;
name|bfd_byte
name|buffer
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|long
name|insn
decl_stmt|;
specifier|register
name|struct
name|opcode_hash
modifier|*
name|op
decl_stmt|;
comment|/* Nonzero of opcode table has been initialized.  */
specifier|static
name|int
name|opcodes_initialized
init|=
literal|0
decl_stmt|;
comment|/* bfd mach number of last call.  */
specifier|static
name|unsigned
name|long
name|current_mach
init|=
literal|0
decl_stmt|;
name|bfd_vma
argument_list|(
argument|*getword
argument_list|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opcodes_initialized
operator|||
name|info
operator|->
name|mach
operator|!=
name|current_mach
condition|)
block|{
name|int
name|i
decl_stmt|;
name|current_arch_mask
operator|=
name|compute_arch_mask
argument_list|(
name|info
operator|->
name|mach
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opcodes_initialized
condition|)
name|sorted_opcodes
operator|=
operator|(
specifier|const
expr|struct
name|sparc_opcode
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|sparc_num_opcodes
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sparc_opcode
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Reset the sorted table so we can resort it.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sparc_num_opcodes
condition|;
operator|++
name|i
control|)
name|sorted_opcodes
index|[
name|i
index|]
operator|=
operator|&
name|sparc_opcodes
index|[
name|i
index|]
expr_stmt|;
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sorted_opcodes
argument_list|,
name|sparc_num_opcodes
argument_list|,
sizeof|sizeof
argument_list|(
name|sorted_opcodes
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|compare_opcodes
argument_list|)
expr_stmt|;
name|build_hash_table
argument_list|(
name|sorted_opcodes
argument_list|,
name|opcode_hash_table
argument_list|,
name|sparc_num_opcodes
argument_list|)
expr_stmt|;
name|current_mach
operator|=
name|info
operator|->
name|mach
expr_stmt|;
name|opcodes_initialized
operator|=
literal|1
expr_stmt|;
block|}
block|{
name|int
name|status
init|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|memaddr
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|memory_error_func
call|)
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* On SPARClite variants such as DANlite (sparc86x), instructions      are always big-endian even when the machine is in little-endian mode. */
if|if
condition|(
name|info
operator|->
name|endian
operator|==
name|BFD_ENDIAN_BIG
operator|||
name|info
operator|->
name|mach
operator|==
name|bfd_mach_sparc_sparclite
condition|)
name|getword
operator|=
name|bfd_getb32
expr_stmt|;
else|else
name|getword
operator|=
name|bfd_getl32
expr_stmt|;
name|insn
operator|=
name|getword
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|info
operator|->
name|insn_info_valid
operator|=
literal|1
expr_stmt|;
comment|/* We do return this info */
name|info
operator|->
name|insn_type
operator|=
name|dis_nonbranch
expr_stmt|;
comment|/* Assume non branch insn */
name|info
operator|->
name|branch_delay_insns
operator|=
literal|0
expr_stmt|;
comment|/* Assume no delay */
name|info
operator|->
name|target
operator|=
literal|0
expr_stmt|;
comment|/* Assume no target known */
for|for
control|(
name|op
operator|=
name|opcode_hash_table
index|[
name|HASH_INSN
argument_list|(
name|insn
argument_list|)
index|]
init|;
name|op
condition|;
name|op
operator|=
name|op
operator|->
name|next
control|)
block|{
name|CONST
name|struct
name|sparc_opcode
modifier|*
name|opcode
init|=
name|op
operator|->
name|opcode
decl_stmt|;
comment|/* If the insn isn't supported by the current architecture, skip it.  */
if|if
condition|(
operator|!
operator|(
name|opcode
operator|->
name|architecture
operator|&
name|current_arch_mask
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|opcode
operator|->
name|match
operator|&
name|insn
operator|)
operator|==
name|opcode
operator|->
name|match
operator|&&
operator|(
name|opcode
operator|->
name|lose
operator|&
name|insn
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Nonzero means that we have found an instruction which has 	     the effect of adding or or'ing the imm13 field to rs1.  */
name|int
name|imm_added_to_rs1
init|=
literal|0
decl_stmt|;
name|int
name|imm_ored_to_rs1
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means that we have found a plus sign in the args 	     field of the opcode table.  */
name|int
name|found_plus
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means we have an annulled branch.  */
name|int
name|is_annulled
init|=
literal|0
decl_stmt|;
comment|/* Do we have an `add' or `or' instruction combining an              immediate with rs1?  */
if|if
condition|(
name|opcode
operator|->
name|match
operator|==
literal|0x80102000
condition|)
comment|/* or */
name|imm_ored_to_rs1
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|match
operator|==
literal|0x80002000
condition|)
comment|/* add */
name|imm_added_to_rs1
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|X_RS1
argument_list|(
name|insn
argument_list|)
operator|!=
name|X_RD
argument_list|(
name|insn
argument_list|)
operator|&&
name|strchr
argument_list|(
name|opcode
operator|->
name|args
argument_list|,
literal|'r'
argument_list|)
operator|!=
literal|0
condition|)
comment|/* Can't do simple format if source and dest are different.  */
continue|continue;
if|if
condition|(
name|X_RS2
argument_list|(
name|insn
argument_list|)
operator|!=
name|X_RD
argument_list|(
name|insn
argument_list|)
operator|&&
name|strchr
argument_list|(
name|opcode
operator|->
name|args
argument_list|,
literal|'O'
argument_list|)
operator|!=
literal|0
condition|)
comment|/* Can't do simple format if source and dest are different.  */
continue|continue;
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
expr_stmt|;
block|{
specifier|register
name|CONST
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|opcode
operator|->
name|args
index|[
literal|0
index|]
operator|!=
literal|','
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|opcode
operator|->
name|args
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
operator|++
name|s
control|)
block|{
while|while
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|","
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'a'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|is_annulled
operator|=
literal|1
expr_stmt|;
operator|++
name|s
expr_stmt|;
continue|continue;
case|case
literal|'N'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"pn"
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
continue|continue;
case|case
literal|'T'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"pt"
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
comment|/* switch on arg */
block|}
comment|/* while there are comma started args */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'+'
case|:
name|found_plus
operator|=
literal|1
expr_stmt|;
comment|/* note fall-through */
default|default:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
break|break;
define|#
directive|define
name|reg
parameter_list|(
name|n
parameter_list|)
value|(*info->fprintf_func) (stream, "%%%s", reg_names[n])
case|case
literal|'1'
case|:
case|case
literal|'r'
case|:
name|reg
argument_list|(
name|X_RS1
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
case|case
literal|'O'
case|:
name|reg
argument_list|(
name|X_RS2
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|reg
argument_list|(
name|X_RD
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|reg
define|#
directive|define
name|freg
parameter_list|(
name|n
parameter_list|)
value|(*info->fprintf_func) (stream, "%%%s", freg_names[n])
define|#
directive|define
name|fregx
parameter_list|(
name|n
parameter_list|)
value|(*info->fprintf_func) (stream, "%%%s", freg_names[((n)& ~1) | (((n)& 1)<< 5)])
case|case
literal|'e'
case|:
name|freg
argument_list|(
name|X_RS1
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* double/even */
case|case
literal|'V'
case|:
comment|/* quad/multiple of 4 */
name|fregx
argument_list|(
name|X_RS1
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|freg
argument_list|(
name|X_RS2
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* double/even */
case|case
literal|'R'
case|:
comment|/* quad/multiple of 4 */
name|fregx
argument_list|(
name|X_RS2
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|freg
argument_list|(
name|X_RD
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* double/even */
case|case
literal|'J'
case|:
comment|/* quad/multiple of 4 */
name|fregx
argument_list|(
name|X_RD
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|freg
undef|#
directive|undef
name|fregx
define|#
directive|define
name|creg
parameter_list|(
name|n
parameter_list|)
value|(*info->fprintf_func) (stream, "%%c%u", (unsigned int) (n))
case|case
literal|'b'
case|:
name|creg
argument_list|(
name|X_RS1
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|creg
argument_list|(
name|X_RS2
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|creg
argument_list|(
name|X_RD
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
undef|#
directive|undef
name|creg
case|case
literal|'h'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%hi(%#x)"
argument_list|,
operator|(
operator|(
name|unsigned
operator|)
literal|0xFFFFFFFF
operator|&
operator|(
operator|(
name|int
operator|)
name|X_IMM22
argument_list|(
name|insn
argument_list|)
operator|<<
literal|10
operator|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* 13 bit immediate */
case|case
literal|'I'
case|:
comment|/* 11 bit immediate */
case|case
literal|'j'
case|:
comment|/* 10 bit immediate */
block|{
name|int
name|imm
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'i'
condition|)
name|imm
operator|=
name|X_SIMM
argument_list|(
name|insn
argument_list|,
literal|13
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'I'
condition|)
name|imm
operator|=
name|X_SIMM
argument_list|(
name|insn
argument_list|,
literal|11
argument_list|)
expr_stmt|;
else|else
name|imm
operator|=
name|X_SIMM
argument_list|(
name|insn
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* Check to see whether we have a 1+i, and take 			 note of that fact.  			 Note: because of the way we sort the table, 			 we will be matching 1+i rather than i+1, 			 so it is OK to assume that i is after +, 			 not before it.  */
if|if
condition|(
name|found_plus
condition|)
name|imm_added_to_rs1
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|imm
operator|<=
literal|9
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|imm
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%#x"
argument_list|,
name|imm
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'X'
case|:
comment|/* 5 bit unsigned immediate */
case|case
literal|'Y'
case|:
comment|/* 6 bit unsigned immediate */
block|{
name|int
name|imm
init|=
name|X_IMM
argument_list|(
name|insn
argument_list|,
operator|*
name|s
operator|==
literal|'X'
condition|?
literal|5
else|:
literal|6
argument_list|)
decl_stmt|;
if|if
condition|(
name|imm
operator|<=
literal|9
condition|)
call|(
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|imm
argument_list|)
expr_stmt|;
else|else
call|(
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%#x"
argument_list|,
operator|(
name|unsigned
operator|)
name|imm
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'3'
case|:
call|(
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|X_IMM
argument_list|(
name|insn
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
block|{
name|int
name|mask
init|=
name|X_MEMBAR
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|bit
init|=
literal|0x40
decl_stmt|,
name|printed_one
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
call|(
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
name|bit
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|bit
condition|)
block|{
if|if
condition|(
name|printed_one
condition|)
call|(
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"|"
argument_list|)
expr_stmt|;
name|name
operator|=
name|sparc_decode_membar
argument_list|(
name|bit
argument_list|)
expr_stmt|;
call|(
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|printed_one
operator|=
literal|1
expr_stmt|;
block|}
name|bit
operator|>>=
literal|1
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'k'
case|:
name|info
operator|->
name|target
operator|=
name|memaddr
operator|+
name|SEX
argument_list|(
name|X_DISP16
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|16
argument_list|)
operator|*
literal|4
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|info
operator|->
name|target
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|info
operator|->
name|target
operator|=
name|memaddr
operator|+
name|SEX
argument_list|(
name|X_DISP19
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|19
argument_list|)
operator|*
literal|4
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|info
operator|->
name|target
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%fcc%c"
argument_list|,
operator|*
name|s
operator|-
literal|'6'
operator|+
literal|'0'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%icc"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%xcc"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%ccr"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%fprs"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%asi"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%tick"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%pc"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
if|if
condition|(
name|X_RS1
argument_list|(
name|insn
argument_list|)
operator|==
literal|31
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%ver"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|unsigned
operator|)
name|X_RS1
argument_list|(
name|insn
argument_list|)
operator|<
literal|16
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%%s"
argument_list|,
name|v9_priv_reg_names
index|[
name|X_RS1
argument_list|(
name|insn
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%reserved"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
if|if
condition|(
operator|(
name|unsigned
operator|)
name|X_RD
argument_list|(
name|insn
argument_list|)
operator|<
literal|15
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%%s"
argument_list|,
name|v9_priv_reg_names
index|[
name|X_RD
argument_list|(
name|insn
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%reserved"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|X_RS1
argument_list|(
name|insn
argument_list|)
operator|<
literal|16
operator|||
name|X_RS1
argument_list|(
name|insn
argument_list|)
operator|>
literal|25
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%reserved"
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%%s"
argument_list|,
name|v9a_asr_reg_names
index|[
name|X_RS1
argument_list|(
name|insn
argument_list|)
operator|-
literal|16
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
if|if
condition|(
name|X_RD
argument_list|(
name|insn
argument_list|)
operator|<
literal|16
operator|||
name|X_RD
argument_list|(
name|insn
argument_list|)
operator|>
literal|25
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%reserved"
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%%s"
argument_list|,
name|v9a_asr_reg_names
index|[
name|X_RD
argument_list|(
name|insn
argument_list|)
operator|-
literal|16
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|sparc_decode_prefetch
argument_list|(
name|X_RD
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|X_RD
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'M'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%asr%d"
argument_list|,
name|X_RS1
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%asr%d"
argument_list|,
name|X_RD
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|info
operator|->
name|target
operator|=
name|memaddr
operator|+
name|SEX
argument_list|(
name|X_DISP30
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|30
argument_list|)
operator|*
literal|4
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|info
operator|->
name|target
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%#x"
argument_list|,
name|SEX
argument_list|(
name|X_DISP22
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|22
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|info
operator|->
name|target
operator|=
name|memaddr
operator|+
name|SEX
argument_list|(
name|X_DISP22
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|22
argument_list|)
operator|*
literal|4
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|info
operator|->
name|target
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|sparc_decode_asi
argument_list|(
name|X_ASI
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"(%d)"
argument_list|,
name|X_ASI
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'C'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%csr"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%fsr"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%psr"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%fq"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%cq"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%tbr"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%wim"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
operator|(
operator|(
name|X_LDST_I
argument_list|(
name|insn
argument_list|)
operator|<<
literal|8
operator|)
operator|+
name|X_ASI
argument_list|(
name|insn
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%y"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
block|{
name|int
name|val
init|=
operator|*
name|s
operator|==
literal|'U'
condition|?
name|X_RS1
argument_list|(
name|insn
argument_list|)
else|:
name|X_RD
argument_list|(
name|insn
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|sparc_decode_sparclet_cpreg
argument_list|(
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"%%cpreg(%d)"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* If we are adding or or'ing something to rs1, then 	     check to see whether the previous instruction was 	     a sethi to the same register as in the sethi. 	     If so, attempt to print the result of the add or 	     or (in this context add and or do the same thing) 	     and its symbolic value.  */
if|if
condition|(
name|imm_ored_to_rs1
operator|||
name|imm_added_to_rs1
condition|)
block|{
name|unsigned
name|long
name|prev_insn
decl_stmt|;
name|int
name|errcode
decl_stmt|;
name|errcode
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|memaddr
operator|-
literal|4
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|prev_insn
operator|=
name|getword
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|==
literal|0
condition|)
block|{
comment|/* If it is a delayed branch, we need to look at the 		     instruction before the delayed branch.  This handles 		     sequences such as  		     sethi %o1, %hi(_foo), %o1 		     call _printf 		     or %o1, %lo(_foo), %o1 		     */
if|if
condition|(
name|is_delayed_branch
argument_list|(
name|prev_insn
argument_list|)
condition|)
block|{
name|errcode
operator|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|memaddr
operator|-
literal|8
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|prev_insn
operator|=
name|getword
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If there was a problem reading memory, then assume 		 the previous instruction was not sethi.  */
if|if
condition|(
name|errcode
operator|==
literal|0
condition|)
block|{
comment|/* Is it sethi to the same register?  */
if|if
condition|(
operator|(
name|prev_insn
operator|&
literal|0xc1c00000
operator|)
operator|==
literal|0x01000000
operator|&&
name|X_RD
argument_list|(
name|prev_insn
argument_list|)
operator|==
name|X_RS1
argument_list|(
name|insn
argument_list|)
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
literal|"\t! "
argument_list|)
expr_stmt|;
name|info
operator|->
name|target
operator|=
operator|(
operator|(
name|unsigned
operator|)
literal|0xFFFFFFFF
operator|&
operator|(
operator|(
name|int
operator|)
name|X_IMM22
argument_list|(
name|prev_insn
argument_list|)
operator|<<
literal|10
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|imm_added_to_rs1
condition|)
name|info
operator|->
name|target
operator|+=
name|X_SIMM
argument_list|(
name|insn
argument_list|,
literal|13
argument_list|)
expr_stmt|;
else|else
name|info
operator|->
name|target
operator||=
name|X_SIMM
argument_list|(
name|insn
argument_list|,
literal|13
argument_list|)
expr_stmt|;
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|info
operator|->
name|target
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|info
operator|->
name|insn_type
operator|=
name|dis_dref
expr_stmt|;
name|info
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
comment|/* FIXME!!! */
block|}
block|}
block|}
if|if
condition|(
name|opcode
operator|->
name|flags
operator|&
operator|(
name|F_UNBR
operator||
name|F_CONDBR
operator||
name|F_JSR
operator|)
condition|)
block|{
comment|/* FIXME -- check is_annulled flag */
if|if
condition|(
name|opcode
operator|->
name|flags
operator|&
name|F_UNBR
condition|)
name|info
operator|->
name|insn_type
operator|=
name|dis_branch
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|flags
operator|&
name|F_CONDBR
condition|)
name|info
operator|->
name|insn_type
operator|=
name|dis_condbranch
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|flags
operator|&
name|F_JSR
condition|)
name|info
operator|->
name|insn_type
operator|=
name|dis_jsr
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|flags
operator|&
name|F_DELAYED
condition|)
name|info
operator|->
name|branch_delay_insns
operator|=
literal|1
expr_stmt|;
block|}
return|return
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
return|;
block|}
block|}
name|info
operator|->
name|insn_type
operator|=
name|dis_noninsn
expr_stmt|;
comment|/* Mark as non-valid instruction */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|stream
argument_list|,
name|_
argument_list|(
literal|"unknown"
argument_list|)
argument_list|)
expr_stmt|;
return|return
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given BFD mach number, return a mask of SPARC_OPCODE_ARCH_FOO values.  */
end_comment

begin_function
specifier|static
name|int
name|compute_arch_mask
parameter_list|(
name|mach
parameter_list|)
name|unsigned
name|long
name|mach
decl_stmt|;
block|{
switch|switch
condition|(
name|mach
condition|)
block|{
case|case
literal|0
case|:
case|case
name|bfd_mach_sparc
case|:
return|return
name|SPARC_OPCODE_ARCH_MASK
argument_list|(
name|SPARC_OPCODE_ARCH_V8
argument_list|)
return|;
case|case
name|bfd_mach_sparc_sparclet
case|:
return|return
name|SPARC_OPCODE_ARCH_MASK
argument_list|(
name|SPARC_OPCODE_ARCH_SPARCLET
argument_list|)
return|;
case|case
name|bfd_mach_sparc_sparclite
case|:
case|case
name|bfd_mach_sparc_sparclite_le
case|:
comment|/* sparclites insns are recognized by default (because that's how 	 they've always been treated, for better or worse).  Kludge this by 	 indicating generic v8 is also selected.  */
return|return
operator|(
name|SPARC_OPCODE_ARCH_MASK
argument_list|(
name|SPARC_OPCODE_ARCH_SPARCLITE
argument_list|)
operator||
name|SPARC_OPCODE_ARCH_MASK
argument_list|(
name|SPARC_OPCODE_ARCH_V8
argument_list|)
operator|)
return|;
case|case
name|bfd_mach_sparc_v8plus
case|:
case|case
name|bfd_mach_sparc_v9
case|:
return|return
name|SPARC_OPCODE_ARCH_MASK
argument_list|(
name|SPARC_OPCODE_ARCH_V9
argument_list|)
return|;
case|case
name|bfd_mach_sparc_v8plusa
case|:
case|case
name|bfd_mach_sparc_v9a
case|:
return|return
name|SPARC_OPCODE_ARCH_MASK
argument_list|(
name|SPARC_OPCODE_ARCH_V9A
argument_list|)
return|;
case|case
name|bfd_mach_sparc_v8plusb
case|:
case|case
name|bfd_mach_sparc_v9b
case|:
return|return
name|SPARC_OPCODE_ARCH_MASK
argument_list|(
name|SPARC_OPCODE_ARCH_V9B
argument_list|)
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compare opcodes A and B.  */
end_comment

begin_function
specifier|static
name|int
name|compare_opcodes
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|const
name|PTR
name|a
decl_stmt|;
specifier|const
name|PTR
name|b
decl_stmt|;
block|{
name|struct
name|sparc_opcode
modifier|*
name|op0
init|=
operator|*
operator|(
expr|struct
name|sparc_opcode
operator|*
operator|*
operator|)
name|a
decl_stmt|;
name|struct
name|sparc_opcode
modifier|*
name|op1
init|=
operator|*
operator|(
expr|struct
name|sparc_opcode
operator|*
operator|*
operator|)
name|b
decl_stmt|;
name|unsigned
name|long
name|int
name|match0
init|=
name|op0
operator|->
name|match
decl_stmt|,
name|match1
init|=
name|op1
operator|->
name|match
decl_stmt|;
name|unsigned
name|long
name|int
name|lose0
init|=
name|op0
operator|->
name|lose
decl_stmt|,
name|lose1
init|=
name|op1
operator|->
name|lose
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* If one (and only one) insn isn't supported by the current architecture,      prefer the one that is.  If neither are supported, but they're both for      the same architecture, continue processing.  Otherwise (both unsupported      and for different architectures), prefer lower numbered arch's (fudged      by comparing the bitmasks).  */
if|if
condition|(
name|op0
operator|->
name|architecture
operator|&
name|current_arch_mask
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|op1
operator|->
name|architecture
operator|&
name|current_arch_mask
operator|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|op1
operator|->
name|architecture
operator|&
name|current_arch_mask
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|op0
operator|->
name|architecture
operator|!=
name|op1
operator|->
name|architecture
condition|)
return|return
name|op0
operator|->
name|architecture
operator|-
name|op1
operator|->
name|architecture
return|;
block|}
comment|/* If a bit is set in both match and lose, there is something      wrong with the opcode table.  */
if|if
condition|(
name|match0
operator|&
name|lose0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
comment|/* xgettext:c-format */
name|_
argument_list|(
literal|"Internal error:  bad sparc-opcode.h: \"%s\", %#.8lx, %#.8lx\n"
argument_list|)
argument_list|,
name|op0
operator|->
name|name
argument_list|,
name|match0
argument_list|,
name|lose0
argument_list|)
expr_stmt|;
name|op0
operator|->
name|lose
operator|&=
operator|~
name|op0
operator|->
name|match
expr_stmt|;
name|lose0
operator|=
name|op0
operator|->
name|lose
expr_stmt|;
block|}
if|if
condition|(
name|match1
operator|&
name|lose1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
comment|/* xgettext:c-format */
name|_
argument_list|(
literal|"Internal error: bad sparc-opcode.h: \"%s\", %#.8lx, %#.8lx\n"
argument_list|)
argument_list|,
name|op1
operator|->
name|name
argument_list|,
name|match1
argument_list|,
name|lose1
argument_list|)
expr_stmt|;
name|op1
operator|->
name|lose
operator|&=
operator|~
name|op1
operator|->
name|match
expr_stmt|;
name|lose1
operator|=
name|op1
operator|->
name|lose
expr_stmt|;
block|}
comment|/* Because the bits that are variable in one opcode are constant in      another, it is important to order the opcodes in the right order.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|long
name|int
name|x
init|=
literal|1
operator|<<
name|i
decl_stmt|;
name|int
name|x0
init|=
operator|(
name|match0
operator|&
name|x
operator|)
operator|!=
literal|0
decl_stmt|;
name|int
name|x1
init|=
operator|(
name|match1
operator|&
name|x
operator|)
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|x0
operator|!=
name|x1
condition|)
return|return
name|x1
operator|-
name|x0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|long
name|int
name|x
init|=
literal|1
operator|<<
name|i
decl_stmt|;
name|int
name|x0
init|=
operator|(
name|lose0
operator|&
name|x
operator|)
operator|!=
literal|0
decl_stmt|;
name|int
name|x1
init|=
operator|(
name|lose1
operator|&
name|x
operator|)
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|x0
operator|!=
name|x1
condition|)
return|return
name|x1
operator|-
name|x0
return|;
block|}
comment|/* They are functionally equal.  So as long as the opcode table is      valid, we can put whichever one first we want, on aesthetic grounds.  */
comment|/* Our first aesthetic ground is that aliases defer to real insns.  */
block|{
name|int
name|alias_diff
init|=
operator|(
name|op0
operator|->
name|flags
operator|&
name|F_ALIAS
operator|)
operator|-
operator|(
name|op1
operator|->
name|flags
operator|&
name|F_ALIAS
operator|)
decl_stmt|;
if|if
condition|(
name|alias_diff
operator|!=
literal|0
condition|)
comment|/* Put the one that isn't an alias first.  */
return|return
name|alias_diff
return|;
block|}
comment|/* Except for aliases, two "identical" instructions had      better have the same opcode.  This is a sanity check on the table.  */
name|i
operator|=
name|strcmp
argument_list|(
name|op0
operator|->
name|name
argument_list|,
name|op1
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
if|if
condition|(
name|op0
operator|->
name|flags
operator|&
name|F_ALIAS
condition|)
comment|/* If they're both aliases, be arbitrary. */
return|return
name|i
return|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
comment|/* xgettext:c-format */
name|_
argument_list|(
literal|"Internal error: bad sparc-opcode.h: \"%s\" == \"%s\"\n"
argument_list|)
argument_list|,
name|op0
operator|->
name|name
argument_list|,
name|op1
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Fewer arguments are preferred.  */
block|{
name|int
name|length_diff
init|=
name|strlen
argument_list|(
name|op0
operator|->
name|args
argument_list|)
operator|-
name|strlen
argument_list|(
name|op1
operator|->
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|length_diff
operator|!=
literal|0
condition|)
comment|/* Put the one with fewer arguments first.  */
return|return
name|length_diff
return|;
block|}
comment|/* Put 1+i before i+1.  */
block|{
name|char
modifier|*
name|p0
init|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|op0
operator|->
name|args
argument_list|,
literal|'+'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p1
init|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|op1
operator|->
name|args
argument_list|,
literal|'+'
argument_list|)
decl_stmt|;
if|if
condition|(
name|p0
operator|&&
name|p1
condition|)
block|{
comment|/* There is a plus in both operands.  Note that a plus 	   sign cannot be the first character in args, 	   so the following [-1]'s are valid.  */
if|if
condition|(
name|p0
index|[
operator|-
literal|1
index|]
operator|==
literal|'i'
operator|&&
name|p1
index|[
literal|1
index|]
operator|==
literal|'i'
condition|)
comment|/* op0 is i+1 and op1 is 1+i, so op1 goes first.  */
return|return
literal|1
return|;
if|if
condition|(
name|p0
index|[
literal|1
index|]
operator|==
literal|'i'
operator|&&
name|p1
index|[
operator|-
literal|1
index|]
operator|==
literal|'i'
condition|)
comment|/* op0 is 1+i and op1 is i+1, so op0 goes first.  */
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Put 1,i before i,1.  */
block|{
name|int
name|i0
init|=
name|strncmp
argument_list|(
name|op0
operator|->
name|args
argument_list|,
literal|"i,1"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
decl_stmt|;
name|int
name|i1
init|=
name|strncmp
argument_list|(
name|op1
operator|->
name|args
argument_list|,
literal|"i,1"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
decl_stmt|;
if|if
condition|(
name|i0
operator|^
name|i1
condition|)
return|return
name|i0
operator|-
name|i1
return|;
block|}
comment|/* They are, as far as we can tell, identical.      Since qsort may have rearranged the table partially, there is      no way to tell which one was first in the opcode table as      written, so just say there are equal.  */
comment|/* ??? This is no longer true now that we sort a vector of pointers,      not the table itself.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Build a hash table from the opcode table.    OPCODE_TABLE is a sorted list of pointers into the opcode table.  */
end_comment

begin_function
specifier|static
name|void
name|build_hash_table
parameter_list|(
name|opcode_table
parameter_list|,
name|hash_table
parameter_list|,
name|num_opcodes
parameter_list|)
specifier|const
name|struct
name|sparc_opcode
modifier|*
modifier|*
name|opcode_table
decl_stmt|;
name|struct
name|opcode_hash
modifier|*
modifier|*
name|hash_table
decl_stmt|;
name|int
name|num_opcodes
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|hash_count
index|[
name|HASH_SIZE
index|]
decl_stmt|;
specifier|static
name|struct
name|opcode_hash
modifier|*
name|hash_buf
init|=
name|NULL
decl_stmt|;
comment|/* Start at the end of the table and work backwards so that each      chain is sorted.  */
name|memset
argument_list|(
name|hash_table
argument_list|,
literal|0
argument_list|,
name|HASH_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|hash_table
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|hash_count
argument_list|,
literal|0
argument_list|,
name|HASH_SIZE
operator|*
sizeof|sizeof
argument_list|(
name|hash_count
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|hash_buf
argument_list|)
expr_stmt|;
name|hash_buf
operator|=
operator|(
expr|struct
name|opcode_hash
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|opcode_hash
argument_list|)
operator|*
name|num_opcodes
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|num_opcodes
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
specifier|register
name|int
name|hash
init|=
name|HASH_INSN
argument_list|(
name|opcode_table
index|[
name|i
index|]
operator|->
name|match
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|opcode_hash
modifier|*
name|h
init|=
operator|&
name|hash_buf
index|[
name|i
index|]
decl_stmt|;
name|h
operator|->
name|next
operator|=
name|hash_table
index|[
name|hash
index|]
expr_stmt|;
name|h
operator|->
name|opcode
operator|=
name|opcode_table
index|[
name|i
index|]
expr_stmt|;
name|hash_table
index|[
name|hash
index|]
operator|=
name|h
expr_stmt|;
operator|++
name|hash_count
index|[
name|hash
index|]
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* for debugging */
block|{     int min_count = num_opcodes, max_count = 0;     int total;      for (i = 0; i< HASH_SIZE; ++i)       {         if (hash_count[i]< min_count) 	  min_count = hash_count[i]; 	if (hash_count[i]> max_count) 	  max_count = hash_count[i]; 	total += hash_count[i];       }      printf ("Opcode hash table stats: min %d, max %d, ave %f\n", 	    min_count, max_count, (double) total / HASH_SIZE);   }
endif|#
directive|endif
block|}
end_function

end_unit

