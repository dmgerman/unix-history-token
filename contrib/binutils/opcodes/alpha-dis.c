begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* alpha-dis.c -- Disassemble Alpha AXP instructions    Copyright 1996, 1998, 1999, 2000 Free Software Foundation, Inc.    Contributed by Richard Henderson<rth@tamu.edu>,    patterned after the PPC opcode handling written by Ian Lance Taylor.  This file is part of GDB, GAS, and the GNU binutils.  GDB, GAS, and the GNU binutils are free software; you can redistribute them and/or modify them under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GDB, GAS, and the GNU binutils are distributed in the hope that they will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this file; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"opcode/alpha.h"
end_include

begin_comment
comment|/* OSF register names.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|osf_regnames
index|[
literal|64
index|]
init|=
block|{
literal|"v0"
block|,
literal|"t0"
block|,
literal|"t1"
block|,
literal|"t2"
block|,
literal|"t3"
block|,
literal|"t4"
block|,
literal|"t5"
block|,
literal|"t6"
block|,
literal|"t7"
block|,
literal|"s0"
block|,
literal|"s1"
block|,
literal|"s2"
block|,
literal|"s3"
block|,
literal|"s4"
block|,
literal|"s5"
block|,
literal|"fp"
block|,
literal|"a0"
block|,
literal|"a1"
block|,
literal|"a2"
block|,
literal|"a3"
block|,
literal|"a4"
block|,
literal|"a5"
block|,
literal|"t8"
block|,
literal|"t9"
block|,
literal|"t10"
block|,
literal|"t11"
block|,
literal|"ra"
block|,
literal|"t12"
block|,
literal|"at"
block|,
literal|"gp"
block|,
literal|"sp"
block|,
literal|"zero"
block|,
literal|"$f0"
block|,
literal|"$f1"
block|,
literal|"$f2"
block|,
literal|"$f3"
block|,
literal|"$f4"
block|,
literal|"$f5"
block|,
literal|"$f6"
block|,
literal|"$f7"
block|,
literal|"$f8"
block|,
literal|"$f9"
block|,
literal|"$f10"
block|,
literal|"$f11"
block|,
literal|"$f12"
block|,
literal|"$f13"
block|,
literal|"$f14"
block|,
literal|"$f15"
block|,
literal|"$f16"
block|,
literal|"$f17"
block|,
literal|"$f18"
block|,
literal|"$f19"
block|,
literal|"$f20"
block|,
literal|"$f21"
block|,
literal|"$f22"
block|,
literal|"$f23"
block|,
literal|"$f24"
block|,
literal|"$f25"
block|,
literal|"$f26"
block|,
literal|"$f27"
block|,
literal|"$f28"
block|,
literal|"$f29"
block|,
literal|"$f30"
block|,
literal|"$f31"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VMS register names.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|vms_regnames
index|[
literal|64
index|]
init|=
block|{
literal|"R0"
block|,
literal|"R1"
block|,
literal|"R2"
block|,
literal|"R3"
block|,
literal|"R4"
block|,
literal|"R5"
block|,
literal|"R6"
block|,
literal|"R7"
block|,
literal|"R8"
block|,
literal|"R9"
block|,
literal|"R10"
block|,
literal|"R11"
block|,
literal|"R12"
block|,
literal|"R13"
block|,
literal|"R14"
block|,
literal|"R15"
block|,
literal|"R16"
block|,
literal|"R17"
block|,
literal|"R18"
block|,
literal|"R19"
block|,
literal|"R20"
block|,
literal|"R21"
block|,
literal|"R22"
block|,
literal|"R23"
block|,
literal|"R24"
block|,
literal|"AI"
block|,
literal|"RA"
block|,
literal|"PV"
block|,
literal|"AT"
block|,
literal|"FP"
block|,
literal|"SP"
block|,
literal|"RZ"
block|,
literal|"F0"
block|,
literal|"F1"
block|,
literal|"F2"
block|,
literal|"F3"
block|,
literal|"F4"
block|,
literal|"F5"
block|,
literal|"F6"
block|,
literal|"F7"
block|,
literal|"F8"
block|,
literal|"F9"
block|,
literal|"F10"
block|,
literal|"F11"
block|,
literal|"F12"
block|,
literal|"F13"
block|,
literal|"F14"
block|,
literal|"F15"
block|,
literal|"F16"
block|,
literal|"F17"
block|,
literal|"F18"
block|,
literal|"F19"
block|,
literal|"F20"
block|,
literal|"F21"
block|,
literal|"F22"
block|,
literal|"F23"
block|,
literal|"F24"
block|,
literal|"F25"
block|,
literal|"F26"
block|,
literal|"F27"
block|,
literal|"F28"
block|,
literal|"F29"
block|,
literal|"F30"
block|,
literal|"FZ"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Disassemble Alpha instructions.  */
end_comment

begin_function
name|int
name|print_insn_alpha
parameter_list|(
name|memaddr
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|memaddr
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
specifier|static
specifier|const
name|struct
name|alpha_opcode
modifier|*
name|opcode_index
index|[
name|AXP_NOPS
operator|+
literal|1
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|regnames
decl_stmt|;
specifier|const
name|struct
name|alpha_opcode
modifier|*
name|opcode
decl_stmt|,
modifier|*
name|opcode_end
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|opindex
decl_stmt|;
name|unsigned
name|insn
decl_stmt|,
name|op
decl_stmt|,
name|isa_mask
decl_stmt|;
name|int
name|need_comma
decl_stmt|;
comment|/* Initialize the majorop table the first time through */
if|if
condition|(
operator|!
name|opcode_index
index|[
literal|0
index|]
condition|)
block|{
name|opcode
operator|=
name|alpha_opcodes
expr_stmt|;
name|opcode_end
operator|=
name|opcode
operator|+
name|alpha_num_opcodes
expr_stmt|;
for|for
control|(
name|op
operator|=
literal|0
init|;
name|op
operator|<
name|AXP_NOPS
condition|;
operator|++
name|op
control|)
block|{
name|opcode_index
index|[
name|op
index|]
operator|=
name|opcode
expr_stmt|;
while|while
condition|(
name|opcode
operator|<
name|opcode_end
operator|&&
name|op
operator|==
name|AXP_OP
argument_list|(
name|opcode
operator|->
name|opcode
argument_list|)
condition|)
operator|++
name|opcode
expr_stmt|;
block|}
name|opcode_index
index|[
name|op
index|]
operator|=
name|opcode
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|flavour
operator|==
name|bfd_target_evax_flavour
condition|)
name|regnames
operator|=
name|vms_regnames
expr_stmt|;
else|else
name|regnames
operator|=
name|osf_regnames
expr_stmt|;
name|isa_mask
operator|=
name|AXP_OPCODE_NOPAL
expr_stmt|;
switch|switch
condition|(
name|info
operator|->
name|mach
condition|)
block|{
case|case
name|bfd_mach_alpha_ev4
case|:
name|isa_mask
operator||=
name|AXP_OPCODE_EV4
expr_stmt|;
break|break;
case|case
name|bfd_mach_alpha_ev5
case|:
name|isa_mask
operator||=
name|AXP_OPCODE_EV5
expr_stmt|;
break|break;
case|case
name|bfd_mach_alpha_ev6
case|:
name|isa_mask
operator||=
name|AXP_OPCODE_EV6
expr_stmt|;
break|break;
block|}
comment|/* Read the insn into a host word */
block|{
name|bfd_byte
name|buffer
index|[
literal|4
index|]
decl_stmt|;
name|int
name|status
init|=
call|(
modifier|*
name|info
operator|->
name|read_memory_func
call|)
argument_list|(
name|memaddr
argument_list|,
name|buffer
argument_list|,
literal|4
argument_list|,
name|info
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|memory_error_func
call|)
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|insn
operator|=
name|bfd_getl32
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
comment|/* Get the major opcode of the instruction.  */
name|op
operator|=
name|AXP_OP
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Find the first match in the opcode table.  */
name|opcode_end
operator|=
name|opcode_index
index|[
name|op
operator|+
literal|1
index|]
expr_stmt|;
for|for
control|(
name|opcode
operator|=
name|opcode_index
index|[
name|op
index|]
init|;
name|opcode
operator|<
name|opcode_end
condition|;
operator|++
name|opcode
control|)
block|{
if|if
condition|(
operator|(
name|insn
operator|&
name|opcode
operator|->
name|mask
operator|)
operator|!=
name|opcode
operator|->
name|opcode
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|opcode
operator|->
name|flags
operator|&
name|isa_mask
operator|)
condition|)
continue|continue;
comment|/* Make two passes over the operands.  First see if any of them 	 have extraction functions, and, if they do, make sure the 	 instruction is valid.  */
block|{
name|int
name|invalid
init|=
literal|0
decl_stmt|;
for|for
control|(
name|opindex
operator|=
name|opcode
operator|->
name|operands
init|;
operator|*
name|opindex
operator|!=
literal|0
condition|;
name|opindex
operator|++
control|)
block|{
specifier|const
name|struct
name|alpha_operand
modifier|*
name|operand
init|=
name|alpha_operands
operator|+
operator|*
name|opindex
decl_stmt|;
if|if
condition|(
name|operand
operator|->
name|extract
condition|)
call|(
modifier|*
name|operand
operator|->
name|extract
call|)
argument_list|(
name|insn
argument_list|,
operator|&
name|invalid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|invalid
condition|)
continue|continue;
block|}
comment|/* The instruction is valid.  */
goto|goto
name|found
goto|;
block|}
comment|/* No instruction found */
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|".long %#08x"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
literal|4
return|;
name|found
label|:
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|opcode
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|->
name|operands
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
comment|/* Now extract and print the operands.  */
name|need_comma
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|opindex
operator|=
name|opcode
operator|->
name|operands
init|;
operator|*
name|opindex
operator|!=
literal|0
condition|;
name|opindex
operator|++
control|)
block|{
specifier|const
name|struct
name|alpha_operand
modifier|*
name|operand
init|=
name|alpha_operands
operator|+
operator|*
name|opindex
decl_stmt|;
name|int
name|value
decl_stmt|;
comment|/* Operands that are marked FAKE are simply ignored.  We 	 already made sure that the extract function considered 	 the instruction to be valid.  */
if|if
condition|(
operator|(
name|operand
operator|->
name|flags
operator|&
name|AXP_OPERAND_FAKE
operator|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* Extract the value from the instruction.  */
if|if
condition|(
name|operand
operator|->
name|extract
condition|)
name|value
operator|=
call|(
modifier|*
name|operand
operator|->
name|extract
call|)
argument_list|(
name|insn
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|value
operator|=
operator|(
name|insn
operator|>>
name|operand
operator|->
name|shift
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|operand
operator|->
name|bits
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|AXP_OPERAND_SIGNED
condition|)
block|{
name|int
name|signbit
init|=
literal|1
operator|<<
operator|(
name|operand
operator|->
name|bits
operator|-
literal|1
operator|)
decl_stmt|;
name|value
operator|=
operator|(
name|value
operator|^
name|signbit
operator|)
operator|-
name|signbit
expr_stmt|;
block|}
block|}
if|if
condition|(
name|need_comma
operator|&&
operator|(
operator|(
name|operand
operator|->
name|flags
operator|&
operator|(
name|AXP_OPERAND_PARENS
operator||
name|AXP_OPERAND_COMMA
operator|)
operator|)
operator|!=
name|AXP_OPERAND_PARENS
operator|)
condition|)
block|{
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|AXP_OPERAND_PARENS
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
comment|/* Print the operand as directed by the flags.  */
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|AXP_OPERAND_IR
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|regnames
index|[
name|value
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|AXP_OPERAND_FPR
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|regnames
index|[
name|value
operator|+
literal|32
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|AXP_OPERAND_RELATIVE
condition|)
call|(
modifier|*
name|info
operator|->
name|print_address_func
call|)
argument_list|(
name|memaddr
operator|+
literal|4
operator|+
name|value
argument_list|,
name|info
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|AXP_OPERAND_SIGNED
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|"%#x"
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|flags
operator|&
name|AXP_OPERAND_PARENS
condition|)
call|(
modifier|*
name|info
operator|->
name|fprintf_func
call|)
argument_list|(
name|info
operator|->
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|4
return|;
block|}
end_function

end_unit

