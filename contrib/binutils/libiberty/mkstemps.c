begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1991, 1992, 1996, 1998 Free Software Foundation, Inc.    This file is derived from mkstemp.c from the GNU C Library.     The GNU C Library is free software; you can redistribute it and/or    modify it under the terms of the GNU Library General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Library General Public License for more details.     You should have received a copy of the GNU Library General Public    License along with the GNU C Library; see the file COPYING.LIB.  If not,    write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_comment
comment|/* We need to provide a type for gcc_uint64_t.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_macro
name|__extension__
end_macro

begin_typedef
typedef|typedef
name|unsigned
name|long
name|long
name|gcc_uint64_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|unsigned
name|long
name|gcc_uint64_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TMP_MAX
end_ifndef

begin_define
define|#
directive|define
name|TMP_MAX
value|16384
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Generate a unique temporary file name from TEMPLATE.     TEMPLATE has the form:<path>/ccXXXXXX<suffix>     SUFFIX_LEN tells us how long<suffix> is (it can be zero length).     The last six characters of TEMPLATE before<suffix> must be "XXXXXX";    they are replaced with a string that makes the filename unique.     Returns a file descriptor open on the file for reading and writing.  */
end_comment

begin_function
name|int
name|mkstemps
parameter_list|(
name|template
parameter_list|,
name|suffix_len
parameter_list|)
name|char
modifier|*
name|template
decl_stmt|;
name|int
name|suffix_len
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
name|letters
index|[]
init|=
literal|"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
decl_stmt|;
specifier|static
name|gcc_uint64_t
name|value
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GETTIMEOFDAY
name|struct
name|timeval
name|tv
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|XXXXXX
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|count
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|template
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|len
operator|<
literal|6
operator|+
name|suffix_len
operator|||
name|strncmp
argument_list|(
operator|&
name|template
index|[
name|len
operator|-
literal|6
operator|-
name|suffix_len
index|]
argument_list|,
literal|"XXXXXX"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|XXXXXX
operator|=
operator|&
name|template
index|[
name|len
operator|-
literal|6
operator|-
name|suffix_len
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_GETTIMEOFDAY
comment|/* Get some more or less random data.  */
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|value
operator|+=
operator|(
operator|(
name|gcc_uint64_t
operator|)
name|tv
operator|.
name|tv_usec
operator|<<
literal|16
operator|)
operator|^
name|tv
operator|.
name|tv_sec
operator|^
name|getpid
argument_list|()
expr_stmt|;
else|#
directive|else
name|value
operator|+=
name|getpid
argument_list|()
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|TMP_MAX
condition|;
operator|++
name|count
control|)
block|{
name|gcc_uint64_t
name|v
init|=
name|value
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/* Fill in the random bits.  */
name|XXXXXX
index|[
literal|0
index|]
operator|=
name|letters
index|[
name|v
operator|%
literal|62
index|]
expr_stmt|;
name|v
operator|/=
literal|62
expr_stmt|;
name|XXXXXX
index|[
literal|1
index|]
operator|=
name|letters
index|[
name|v
operator|%
literal|62
index|]
expr_stmt|;
name|v
operator|/=
literal|62
expr_stmt|;
name|XXXXXX
index|[
literal|2
index|]
operator|=
name|letters
index|[
name|v
operator|%
literal|62
index|]
expr_stmt|;
name|v
operator|/=
literal|62
expr_stmt|;
name|XXXXXX
index|[
literal|3
index|]
operator|=
name|letters
index|[
name|v
operator|%
literal|62
index|]
expr_stmt|;
name|v
operator|/=
literal|62
expr_stmt|;
name|XXXXXX
index|[
literal|4
index|]
operator|=
name|letters
index|[
name|v
operator|%
literal|62
index|]
expr_stmt|;
name|v
operator|/=
literal|62
expr_stmt|;
name|XXXXXX
index|[
literal|5
index|]
operator|=
name|letters
index|[
name|v
operator|%
literal|62
index|]
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|template
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
comment|/* The file does not exist.  */
return|return
name|fd
return|;
comment|/* This is a random value.  It is only necessary that the next 	 TMP_MAX values generated by adding 7777 to VALUE are different 	 with (module 2^32).  */
name|value
operator|+=
literal|7777
expr_stmt|;
block|}
comment|/* We return the null string if we can't find a unique file name.  */
name|template
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

end_unit

