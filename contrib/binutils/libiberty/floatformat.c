begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* IEEE floating point support routines, for GDB, the GNU Debugger.    Copyright 1991, 1994, 1999, 2000, 2003, 2005, 2006    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This is needed to pick up the NAN macro on some systems.  */
end_comment

begin_define
define|#
directive|define
name|_GNU_SOURCE
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* On some platforms,<float.h> provides DBL_QNAN.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STDC_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|<float.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|INFINITY
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|HUGE_VAL
end_ifdef

begin_define
define|#
directive|define
name|INFINITY
value|HUGE_VAL
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INFINITY
value|(1.0 / 0.0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NAN
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|DBL_QNAN
end_ifdef

begin_define
define|#
directive|define
name|NAN
value|DBL_QNAN
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NAN
value|(0.0 / 0.0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|unsigned
name|long
name|get_field
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|,
name|enum
name|floatformat_byteorders
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|floatformat_always_valid
parameter_list|(
specifier|const
name|struct
name|floatformat
modifier|*
name|fmt
parameter_list|,
specifier|const
name|void
modifier|*
name|from
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|floatformat_always_valid
parameter_list|(
specifier|const
name|struct
name|floatformat
modifier|*
name|fmt
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|void
modifier|*
name|from
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The odds that CHAR_BIT will be anything but 8 are low enough that I'm not    going to bother with trying to muck around with whether it is defined in    a system header, what we do if not, etc.  */
end_comment

begin_define
define|#
directive|define
name|FLOATFORMAT_CHAR_BIT
value|8
end_define

begin_comment
comment|/* floatformats for IEEE single and double, big and little endian.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_ieee_single_big
init|=
block|{
name|floatformat_big
block|,
literal|32
block|,
literal|0
block|,
literal|1
block|,
literal|8
block|,
literal|127
block|,
literal|255
block|,
literal|9
block|,
literal|23
block|,
name|floatformat_intbit_no
block|,
literal|"floatformat_ieee_single_big"
block|,
name|floatformat_always_valid
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_ieee_single_little
init|=
block|{
name|floatformat_little
block|,
literal|32
block|,
literal|0
block|,
literal|1
block|,
literal|8
block|,
literal|127
block|,
literal|255
block|,
literal|9
block|,
literal|23
block|,
name|floatformat_intbit_no
block|,
literal|"floatformat_ieee_single_little"
block|,
name|floatformat_always_valid
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_ieee_double_big
init|=
block|{
name|floatformat_big
block|,
literal|64
block|,
literal|0
block|,
literal|1
block|,
literal|11
block|,
literal|1023
block|,
literal|2047
block|,
literal|12
block|,
literal|52
block|,
name|floatformat_intbit_no
block|,
literal|"floatformat_ieee_double_big"
block|,
name|floatformat_always_valid
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_ieee_double_little
init|=
block|{
name|floatformat_little
block|,
literal|64
block|,
literal|0
block|,
literal|1
block|,
literal|11
block|,
literal|1023
block|,
literal|2047
block|,
literal|12
block|,
literal|52
block|,
name|floatformat_intbit_no
block|,
literal|"floatformat_ieee_double_little"
block|,
name|floatformat_always_valid
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* floatformat for IEEE double, little endian byte order, with big endian word    ordering, as on the ARM.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_ieee_double_littlebyte_bigword
init|=
block|{
name|floatformat_littlebyte_bigword
block|,
literal|64
block|,
literal|0
block|,
literal|1
block|,
literal|11
block|,
literal|1023
block|,
literal|2047
block|,
literal|12
block|,
literal|52
block|,
name|floatformat_intbit_no
block|,
literal|"floatformat_ieee_double_littlebyte_bigword"
block|,
name|floatformat_always_valid
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* floatformat for VAX.  Not quite IEEE, but close enough.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_vax_f
init|=
block|{
name|floatformat_vax
block|,
literal|32
block|,
literal|0
block|,
literal|1
block|,
literal|8
block|,
literal|129
block|,
literal|0
block|,
literal|9
block|,
literal|23
block|,
name|floatformat_intbit_no
block|,
literal|"floatformat_vax_f"
block|,
name|floatformat_always_valid
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_vax_d
init|=
block|{
name|floatformat_vax
block|,
literal|64
block|,
literal|0
block|,
literal|1
block|,
literal|8
block|,
literal|129
block|,
literal|0
block|,
literal|9
block|,
literal|55
block|,
name|floatformat_intbit_no
block|,
literal|"floatformat_vax_d"
block|,
name|floatformat_always_valid
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_vax_g
init|=
block|{
name|floatformat_vax
block|,
literal|64
block|,
literal|0
block|,
literal|1
block|,
literal|11
block|,
literal|1025
block|,
literal|0
block|,
literal|12
block|,
literal|52
block|,
name|floatformat_intbit_no
block|,
literal|"floatformat_vax_g"
block|,
name|floatformat_always_valid
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|floatformat_i387_ext_is_valid
parameter_list|(
specifier|const
name|struct
name|floatformat
modifier|*
name|fmt
parameter_list|,
specifier|const
name|void
modifier|*
name|from
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|floatformat_i387_ext_is_valid
parameter_list|(
specifier|const
name|struct
name|floatformat
modifier|*
name|fmt
parameter_list|,
specifier|const
name|void
modifier|*
name|from
parameter_list|)
block|{
comment|/* In the i387 double-extended format, if the exponent is all ones,      then the integer bit must be set.  If the exponent is neither 0      nor ~0, the intbit must also be set.  Only if the exponent is      zero can it be zero, and then it must be zero.  */
name|unsigned
name|long
name|exponent
decl_stmt|,
name|int_bit
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|ufrom
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|from
decl_stmt|;
name|exponent
operator|=
name|get_field
argument_list|(
name|ufrom
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|exp_start
argument_list|,
name|fmt
operator|->
name|exp_len
argument_list|)
expr_stmt|;
name|int_bit
operator|=
name|get_field
argument_list|(
name|ufrom
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|man_start
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|exponent
operator|==
literal|0
operator|)
operator|!=
operator|(
name|int_bit
operator|==
literal|0
operator|)
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_i387_ext
init|=
block|{
name|floatformat_little
block|,
literal|80
block|,
literal|0
block|,
literal|1
block|,
literal|15
block|,
literal|0x3fff
block|,
literal|0x7fff
block|,
literal|16
block|,
literal|64
block|,
name|floatformat_intbit_yes
block|,
literal|"floatformat_i387_ext"
block|,
name|floatformat_i387_ext_is_valid
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_m68881_ext
init|=
block|{
comment|/* Note that the bits from 16 to 31 are unused.  */
name|floatformat_big
block|,
literal|96
block|,
literal|0
block|,
literal|1
block|,
literal|15
block|,
literal|0x3fff
block|,
literal|0x7fff
block|,
literal|32
block|,
literal|64
block|,
name|floatformat_intbit_yes
block|,
literal|"floatformat_m68881_ext"
block|,
name|floatformat_always_valid
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_i960_ext
init|=
block|{
comment|/* Note that the bits from 0 to 15 are unused.  */
name|floatformat_little
block|,
literal|96
block|,
literal|16
block|,
literal|17
block|,
literal|15
block|,
literal|0x3fff
block|,
literal|0x7fff
block|,
literal|32
block|,
literal|64
block|,
name|floatformat_intbit_yes
block|,
literal|"floatformat_i960_ext"
block|,
name|floatformat_always_valid
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_m88110_ext
init|=
block|{
name|floatformat_big
block|,
literal|80
block|,
literal|0
block|,
literal|1
block|,
literal|15
block|,
literal|0x3fff
block|,
literal|0x7fff
block|,
literal|16
block|,
literal|64
block|,
name|floatformat_intbit_yes
block|,
literal|"floatformat_m88110_ext"
block|,
name|floatformat_always_valid
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_m88110_harris_ext
init|=
block|{
comment|/* Harris uses raw format 128 bytes long, but the number is just an ieee      double, and the last 64 bits are wasted. */
name|floatformat_big
block|,
literal|128
block|,
literal|0
block|,
literal|1
block|,
literal|11
block|,
literal|0x3ff
block|,
literal|0x7ff
block|,
literal|12
block|,
literal|52
block|,
name|floatformat_intbit_no
block|,
literal|"floatformat_m88110_ext_harris"
block|,
name|floatformat_always_valid
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_arm_ext_big
init|=
block|{
comment|/* Bits 1 to 16 are unused.  */
name|floatformat_big
block|,
literal|96
block|,
literal|0
block|,
literal|17
block|,
literal|15
block|,
literal|0x3fff
block|,
literal|0x7fff
block|,
literal|32
block|,
literal|64
block|,
name|floatformat_intbit_yes
block|,
literal|"floatformat_arm_ext_big"
block|,
name|floatformat_always_valid
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_arm_ext_littlebyte_bigword
init|=
block|{
comment|/* Bits 1 to 16 are unused.  */
name|floatformat_littlebyte_bigword
block|,
literal|96
block|,
literal|0
block|,
literal|17
block|,
literal|15
block|,
literal|0x3fff
block|,
literal|0x7fff
block|,
literal|32
block|,
literal|64
block|,
name|floatformat_intbit_yes
block|,
literal|"floatformat_arm_ext_littlebyte_bigword"
block|,
name|floatformat_always_valid
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_ia64_spill_big
init|=
block|{
name|floatformat_big
block|,
literal|128
block|,
literal|0
block|,
literal|1
block|,
literal|17
block|,
literal|65535
block|,
literal|0x1ffff
block|,
literal|18
block|,
literal|64
block|,
name|floatformat_intbit_yes
block|,
literal|"floatformat_ia64_spill_big"
block|,
name|floatformat_always_valid
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_ia64_spill_little
init|=
block|{
name|floatformat_little
block|,
literal|128
block|,
literal|0
block|,
literal|1
block|,
literal|17
block|,
literal|65535
block|,
literal|0x1ffff
block|,
literal|18
block|,
literal|64
block|,
name|floatformat_intbit_yes
block|,
literal|"floatformat_ia64_spill_little"
block|,
name|floatformat_always_valid
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_ia64_quad_big
init|=
block|{
name|floatformat_big
block|,
literal|128
block|,
literal|0
block|,
literal|1
block|,
literal|15
block|,
literal|16383
block|,
literal|0x7fff
block|,
literal|16
block|,
literal|112
block|,
name|floatformat_intbit_no
block|,
literal|"floatformat_ia64_quad_big"
block|,
name|floatformat_always_valid
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_ia64_quad_little
init|=
block|{
name|floatformat_little
block|,
literal|128
block|,
literal|0
block|,
literal|1
block|,
literal|15
block|,
literal|16383
block|,
literal|0x7fff
block|,
literal|16
block|,
literal|112
block|,
name|floatformat_intbit_no
block|,
literal|"floatformat_ia64_quad_little"
block|,
name|floatformat_always_valid
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|min
end_ifndef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Extract a field which starts at START and is LEN bits long.  DATA and    TOTAL_LEN are the thing we are extracting it from, in byteorder ORDER.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|get_field
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|enum
name|floatformat_byteorders
name|order
parameter_list|,
name|unsigned
name|int
name|total_len
parameter_list|,
name|unsigned
name|int
name|start
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|long
name|result
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|cur_byte
decl_stmt|;
name|int
name|lo_bit
decl_stmt|,
name|hi_bit
decl_stmt|,
name|cur_bitshift
init|=
literal|0
decl_stmt|;
name|int
name|nextbyte
init|=
operator|(
name|order
operator|==
name|floatformat_little
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
decl_stmt|;
comment|/* Start is in big-endian bit order!  Fix that first.  */
name|start
operator|=
name|total_len
operator|-
operator|(
name|start
operator|+
name|len
operator|)
expr_stmt|;
comment|/* Start at the least significant part of the field.  */
if|if
condition|(
name|order
operator|==
name|floatformat_little
condition|)
name|cur_byte
operator|=
name|start
operator|/
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
else|else
name|cur_byte
operator|=
operator|(
name|total_len
operator|-
name|start
operator|-
literal|1
operator|)
operator|/
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
name|lo_bit
operator|=
name|start
operator|%
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
name|hi_bit
operator|=
name|min
argument_list|(
name|lo_bit
operator|+
name|len
argument_list|,
name|FLOATFORMAT_CHAR_BIT
argument_list|)
expr_stmt|;
do|do
block|{
name|unsigned
name|int
name|shifted
init|=
operator|*
operator|(
name|data
operator|+
name|cur_byte
operator|)
operator|>>
name|lo_bit
decl_stmt|;
name|unsigned
name|int
name|bits
init|=
name|hi_bit
operator|-
name|lo_bit
decl_stmt|;
name|unsigned
name|int
name|mask
init|=
operator|(
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
decl_stmt|;
name|result
operator||=
operator|(
name|shifted
operator|&
name|mask
operator|)
operator|<<
name|cur_bitshift
expr_stmt|;
name|len
operator|-=
name|bits
expr_stmt|;
name|cur_bitshift
operator|+=
name|bits
expr_stmt|;
name|cur_byte
operator|+=
name|nextbyte
expr_stmt|;
name|lo_bit
operator|=
literal|0
expr_stmt|;
name|hi_bit
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|FLOATFORMAT_CHAR_BIT
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|len
operator|!=
literal|0
condition|)
do|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Convert from FMT to a double.    FROM is the address of the extended float.    Store the double in *TO.  */
end_comment

begin_function
name|void
name|floatformat_to_double
parameter_list|(
specifier|const
name|struct
name|floatformat
modifier|*
name|fmt
parameter_list|,
specifier|const
name|void
modifier|*
name|from
parameter_list|,
name|double
modifier|*
name|to
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|ufrom
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|from
decl_stmt|;
name|double
name|dto
decl_stmt|;
name|long
name|exponent
decl_stmt|;
name|unsigned
name|long
name|mant
decl_stmt|;
name|unsigned
name|int
name|mant_bits
decl_stmt|,
name|mant_off
decl_stmt|;
name|int
name|mant_bits_left
decl_stmt|;
name|int
name|special_exponent
decl_stmt|;
comment|/* It's a NaN, denorm or zero */
name|exponent
operator|=
name|get_field
argument_list|(
name|ufrom
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|exp_start
argument_list|,
name|fmt
operator|->
name|exp_len
argument_list|)
expr_stmt|;
comment|/* If the exponent indicates a NaN, we don't have information to      decide what to do.  So we handle it like IEEE, except that we      don't try to preserve the type of NaN.  FIXME.  */
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|exponent
operator|==
name|fmt
operator|->
name|exp_nan
condition|)
block|{
name|int
name|nan
decl_stmt|;
name|mant_off
operator|=
name|fmt
operator|->
name|man_start
expr_stmt|;
name|mant_bits_left
operator|=
name|fmt
operator|->
name|man_len
expr_stmt|;
name|nan
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|mant_bits_left
operator|>
literal|0
condition|)
block|{
name|mant_bits
operator|=
name|min
argument_list|(
name|mant_bits_left
argument_list|,
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_field
argument_list|(
name|ufrom
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|mant_off
argument_list|,
name|mant_bits
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* This is a NaN.  */
name|nan
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|mant_off
operator|+=
name|mant_bits
expr_stmt|;
name|mant_bits_left
operator|-=
name|mant_bits
expr_stmt|;
block|}
comment|/* On certain systems (such as GNU/Linux), the use of the 	 INFINITY macro below may generate a warning that can not be 	 silenced due to a bug in GCC (PR preprocessor/11931).  The 	 preprocessor fails to recognise the __extension__ keyword in 	 conjunction with the GNU/C99 extension for hexadecimal 	 floating point constants and will issue a warning when 	 compiling with -pedantic.  */
if|if
condition|(
name|nan
condition|)
name|dto
operator|=
name|NAN
expr_stmt|;
else|else
name|dto
operator|=
name|INFINITY
expr_stmt|;
if|if
condition|(
name|get_field
argument_list|(
name|ufrom
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|sign_start
argument_list|,
literal|1
argument_list|)
condition|)
name|dto
operator|=
operator|-
name|dto
expr_stmt|;
operator|*
name|to
operator|=
name|dto
expr_stmt|;
return|return;
block|}
name|mant_bits_left
operator|=
name|fmt
operator|->
name|man_len
expr_stmt|;
name|mant_off
operator|=
name|fmt
operator|->
name|man_start
expr_stmt|;
name|dto
operator|=
literal|0.0
expr_stmt|;
name|special_exponent
operator|=
name|exponent
operator|==
literal|0
operator|||
operator|(
name|unsigned
name|long
operator|)
name|exponent
operator|==
name|fmt
operator|->
name|exp_nan
expr_stmt|;
comment|/* Don't bias zero's, denorms or NaNs.  */
if|if
condition|(
operator|!
name|special_exponent
condition|)
name|exponent
operator|-=
name|fmt
operator|->
name|exp_bias
expr_stmt|;
comment|/* Build the result algebraically.  Might go infinite, underflow, etc;      who cares. */
comment|/* If this format uses a hidden bit, explicitly add it in now.  Otherwise,      increment the exponent by one to account for the integer bit.  */
if|if
condition|(
operator|!
name|special_exponent
condition|)
block|{
if|if
condition|(
name|fmt
operator|->
name|intbit
operator|==
name|floatformat_intbit_no
condition|)
name|dto
operator|=
name|ldexp
argument_list|(
literal|1.0
argument_list|,
name|exponent
argument_list|)
expr_stmt|;
else|else
name|exponent
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|mant_bits_left
operator|>
literal|0
condition|)
block|{
name|mant_bits
operator|=
name|min
argument_list|(
name|mant_bits_left
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|mant
operator|=
name|get_field
argument_list|(
name|ufrom
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|mant_off
argument_list|,
name|mant_bits
argument_list|)
expr_stmt|;
comment|/* Handle denormalized numbers.  FIXME: What should we do for 	 non-IEEE formats?  */
if|if
condition|(
name|special_exponent
operator|&&
name|exponent
operator|==
literal|0
operator|&&
name|mant
operator|!=
literal|0
condition|)
name|dto
operator|+=
name|ldexp
argument_list|(
operator|(
name|double
operator|)
name|mant
argument_list|,
operator|(
operator|-
name|fmt
operator|->
name|exp_bias
operator|-
name|mant_bits
operator|-
operator|(
name|mant_off
operator|-
name|fmt
operator|->
name|man_start
operator|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
else|else
name|dto
operator|+=
name|ldexp
argument_list|(
operator|(
name|double
operator|)
name|mant
argument_list|,
name|exponent
operator|-
name|mant_bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|exponent
operator|!=
literal|0
condition|)
name|exponent
operator|-=
name|mant_bits
expr_stmt|;
name|mant_off
operator|+=
name|mant_bits
expr_stmt|;
name|mant_bits_left
operator|-=
name|mant_bits
expr_stmt|;
block|}
comment|/* Negate it if negative.  */
if|if
condition|(
name|get_field
argument_list|(
name|ufrom
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|sign_start
argument_list|,
literal|1
argument_list|)
condition|)
name|dto
operator|=
operator|-
name|dto
expr_stmt|;
operator|*
name|to
operator|=
name|dto
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function_decl
specifier|static
name|void
name|put_field
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|enum
name|floatformat_byteorders
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Set a field which starts at START and is LEN bits long.  DATA and    TOTAL_LEN are the thing we are extracting it from, in byteorder ORDER.  */
end_comment

begin_function
specifier|static
name|void
name|put_field
parameter_list|(
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|enum
name|floatformat_byteorders
name|order
parameter_list|,
name|unsigned
name|int
name|total_len
parameter_list|,
name|unsigned
name|int
name|start
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|,
name|unsigned
name|long
name|stuff_to_put
parameter_list|)
block|{
name|unsigned
name|int
name|cur_byte
decl_stmt|;
name|int
name|lo_bit
decl_stmt|,
name|hi_bit
decl_stmt|;
name|int
name|nextbyte
init|=
operator|(
name|order
operator|==
name|floatformat_little
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
decl_stmt|;
comment|/* Start is in big-endian bit order!  Fix that first.  */
name|start
operator|=
name|total_len
operator|-
operator|(
name|start
operator|+
name|len
operator|)
expr_stmt|;
comment|/* Start at the least significant part of the field.  */
if|if
condition|(
name|order
operator|==
name|floatformat_little
condition|)
name|cur_byte
operator|=
name|start
operator|/
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
else|else
name|cur_byte
operator|=
operator|(
name|total_len
operator|-
name|start
operator|-
literal|1
operator|)
operator|/
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
name|lo_bit
operator|=
name|start
operator|%
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
name|hi_bit
operator|=
name|min
argument_list|(
name|lo_bit
operator|+
name|len
argument_list|,
name|FLOATFORMAT_CHAR_BIT
argument_list|)
expr_stmt|;
do|do
block|{
name|unsigned
name|char
modifier|*
name|byte_ptr
init|=
name|data
operator|+
name|cur_byte
decl_stmt|;
name|unsigned
name|int
name|bits
init|=
name|hi_bit
operator|-
name|lo_bit
decl_stmt|;
name|unsigned
name|int
name|mask
init|=
operator|(
operator|(
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
operator|)
operator|<<
name|lo_bit
decl_stmt|;
operator|*
name|byte_ptr
operator|=
operator|(
operator|*
name|byte_ptr
operator|&
operator|~
name|mask
operator|)
operator||
operator|(
operator|(
name|stuff_to_put
operator|<<
name|lo_bit
operator|)
operator|&
name|mask
operator|)
expr_stmt|;
name|stuff_to_put
operator|>>=
name|bits
expr_stmt|;
name|len
operator|-=
name|bits
expr_stmt|;
name|cur_byte
operator|+=
name|nextbyte
expr_stmt|;
name|lo_bit
operator|=
literal|0
expr_stmt|;
name|hi_bit
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|FLOATFORMAT_CHAR_BIT
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|len
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|/* The converse: convert the double *FROM to an extended float    and store where TO points.  Neither FROM nor TO have any alignment    restrictions.  */
end_comment

begin_function
name|void
name|floatformat_from_double
parameter_list|(
specifier|const
name|struct
name|floatformat
modifier|*
name|fmt
parameter_list|,
specifier|const
name|double
modifier|*
name|from
parameter_list|,
name|void
modifier|*
name|to
parameter_list|)
block|{
name|double
name|dfrom
decl_stmt|;
name|int
name|exponent
decl_stmt|;
name|double
name|mant
decl_stmt|;
name|unsigned
name|int
name|mant_bits
decl_stmt|,
name|mant_off
decl_stmt|;
name|int
name|mant_bits_left
decl_stmt|;
name|unsigned
name|char
modifier|*
name|uto
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|to
decl_stmt|;
name|dfrom
operator|=
operator|*
name|from
expr_stmt|;
name|memset
argument_list|(
name|uto
argument_list|,
literal|0
argument_list|,
name|fmt
operator|->
name|totalsize
operator|/
name|FLOATFORMAT_CHAR_BIT
argument_list|)
expr_stmt|;
comment|/* If negative, set the sign bit.  */
if|if
condition|(
name|dfrom
operator|<
literal|0
condition|)
block|{
name|put_field
argument_list|(
name|uto
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|sign_start
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dfrom
operator|=
operator|-
name|dfrom
expr_stmt|;
block|}
if|if
condition|(
name|dfrom
operator|==
literal|0
condition|)
block|{
comment|/* 0.0.  */
return|return;
block|}
if|if
condition|(
name|dfrom
operator|!=
name|dfrom
condition|)
block|{
comment|/* NaN.  */
name|put_field
argument_list|(
name|uto
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|exp_start
argument_list|,
name|fmt
operator|->
name|exp_len
argument_list|,
name|fmt
operator|->
name|exp_nan
argument_list|)
expr_stmt|;
comment|/* Be sure it's not infinity, but NaN value is irrelevant.  */
name|put_field
argument_list|(
name|uto
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|man_start
argument_list|,
literal|32
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dfrom
operator|+
name|dfrom
operator|==
name|dfrom
condition|)
block|{
comment|/* This can only happen for an infinite value (or zero, which we 	 already handled above).  */
name|put_field
argument_list|(
name|uto
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|exp_start
argument_list|,
name|fmt
operator|->
name|exp_len
argument_list|,
name|fmt
operator|->
name|exp_nan
argument_list|)
expr_stmt|;
return|return;
block|}
name|mant
operator|=
name|frexp
argument_list|(
name|dfrom
argument_list|,
operator|&
name|exponent
argument_list|)
expr_stmt|;
if|if
condition|(
name|exponent
operator|+
name|fmt
operator|->
name|exp_bias
operator|-
literal|1
operator|>
literal|0
condition|)
name|put_field
argument_list|(
name|uto
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|exp_start
argument_list|,
name|fmt
operator|->
name|exp_len
argument_list|,
name|exponent
operator|+
name|fmt
operator|->
name|exp_bias
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Handle a denormalized number.  FIXME: What should we do for 	 non-IEEE formats?  */
name|put_field
argument_list|(
name|uto
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|exp_start
argument_list|,
name|fmt
operator|->
name|exp_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mant
operator|=
name|ldexp
argument_list|(
name|mant
argument_list|,
name|exponent
operator|+
name|fmt
operator|->
name|exp_bias
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|mant_bits_left
operator|=
name|fmt
operator|->
name|man_len
expr_stmt|;
name|mant_off
operator|=
name|fmt
operator|->
name|man_start
expr_stmt|;
while|while
condition|(
name|mant_bits_left
operator|>
literal|0
condition|)
block|{
name|unsigned
name|long
name|mant_long
decl_stmt|;
name|mant_bits
operator|=
name|mant_bits_left
operator|<
literal|32
condition|?
name|mant_bits_left
else|:
literal|32
expr_stmt|;
name|mant
operator|*=
literal|4294967296.0
expr_stmt|;
name|mant_long
operator|=
operator|(
name|unsigned
name|long
operator|)
name|mant
expr_stmt|;
name|mant
operator|-=
name|mant_long
expr_stmt|;
comment|/* If the integer bit is implicit, and we are not creating a 	 denormalized number, then we need to discard it.  */
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|mant_bits_left
operator|==
name|fmt
operator|->
name|man_len
operator|&&
name|fmt
operator|->
name|intbit
operator|==
name|floatformat_intbit_no
operator|&&
name|exponent
operator|+
name|fmt
operator|->
name|exp_bias
operator|-
literal|1
operator|>
literal|0
condition|)
block|{
name|mant_long
operator|&=
literal|0x7fffffff
expr_stmt|;
name|mant_bits
operator|-=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mant_bits
operator|<
literal|32
condition|)
block|{
comment|/* The bits we want are in the most significant MANT_BITS bits of 	     mant_long.  Move them to the least significant.  */
name|mant_long
operator|>>=
literal|32
operator|-
name|mant_bits
expr_stmt|;
block|}
name|put_field
argument_list|(
name|uto
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|mant_off
argument_list|,
name|mant_bits
argument_list|,
name|mant_long
argument_list|)
expr_stmt|;
name|mant_off
operator|+=
name|mant_bits
expr_stmt|;
name|mant_bits_left
operator|-=
name|mant_bits
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return non-zero iff the data at FROM is a valid number in format FMT.  */
end_comment

begin_function
name|int
name|floatformat_is_valid
parameter_list|(
specifier|const
name|struct
name|floatformat
modifier|*
name|fmt
parameter_list|,
specifier|const
name|void
modifier|*
name|from
parameter_list|)
block|{
return|return
name|fmt
operator|->
name|is_valid
argument_list|(
name|fmt
argument_list|,
name|from
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE_DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* This is to be run on a host which uses IEEE floating point.  */
end_comment

begin_function
name|void
name|ieee_test
parameter_list|(
name|double
name|n
parameter_list|)
block|{
name|double
name|result
decl_stmt|;
name|floatformat_to_double
argument_list|(
operator|&
name|floatformat_ieee_double_little
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|!=
name|result
operator|&&
operator|(
operator|!
name|isnan
argument_list|(
name|n
argument_list|)
operator|||
operator|!
name|isnan
argument_list|(
name|result
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|n
operator|<
literal|0
operator|&&
name|result
operator|>=
literal|0
operator|)
operator|||
operator|(
name|n
operator|>=
literal|0
operator|&&
name|result
operator|<
literal|0
operator|)
condition|)
name|printf
argument_list|(
literal|"Differ(to): %.20g -> %.20g\n"
argument_list|,
name|n
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|floatformat_from_double
argument_list|(
operator|&
name|floatformat_ieee_double_little
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|!=
name|result
operator|&&
operator|(
operator|!
name|isnan
argument_list|(
name|n
argument_list|)
operator|||
operator|!
name|isnan
argument_list|(
name|result
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|n
operator|<
literal|0
operator|&&
name|result
operator|>=
literal|0
operator|)
operator|||
operator|(
name|n
operator|>=
literal|0
operator|&&
name|result
operator|<
literal|0
operator|)
condition|)
name|printf
argument_list|(
literal|"Differ(from): %.20g -> %.20g\n"
argument_list|,
name|n
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|{     char exten[16];      floatformat_from_double (&floatformat_m68881_ext,&n, exten);     floatformat_to_double (&floatformat_m68881_ext, exten,&result);     if (n != result)       printf ("Differ(to+from): %.20g -> %.20g\n", n, result);   }
endif|#
directive|endif
if|#
directive|if
name|IEEE_DEBUG
operator|>
literal|1
comment|/* This is to be run on a host which uses 68881 format.  */
block|{
name|long
name|double
name|ex
init|=
operator|*
operator|(
name|long
name|double
operator|*
operator|)
name|exten
decl_stmt|;
if|if
condition|(
name|ex
operator|!=
name|n
condition|)
name|printf
argument_list|(
literal|"Differ(from vs. extended): %.20g\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|ieee_test
argument_list|(
literal|0.0
argument_list|)
expr_stmt|;
name|ieee_test
argument_list|(
literal|0.5
argument_list|)
expr_stmt|;
name|ieee_test
argument_list|(
literal|256.0
argument_list|)
expr_stmt|;
name|ieee_test
argument_list|(
literal|0.12345
argument_list|)
expr_stmt|;
name|ieee_test
argument_list|(
literal|234235.78907234
argument_list|)
expr_stmt|;
name|ieee_test
argument_list|(
operator|-
literal|512.0
argument_list|)
expr_stmt|;
name|ieee_test
argument_list|(
operator|-
literal|0.004321
argument_list|)
expr_stmt|;
name|ieee_test
argument_list|(
literal|1.2E
operator|-
literal|70
argument_list|)
expr_stmt|;
name|ieee_test
argument_list|(
literal|1.2E
operator|-
literal|316
argument_list|)
expr_stmt|;
name|ieee_test
argument_list|(
literal|4.9406564584124654E
operator|-
literal|324
argument_list|)
expr_stmt|;
name|ieee_test
argument_list|(
operator|-
literal|4.9406564584124654E
operator|-
literal|324
argument_list|)
expr_stmt|;
name|ieee_test
argument_list|(
operator|-
literal|0.0
argument_list|)
expr_stmt|;
name|ieee_test
argument_list|(
operator|-
name|INFINITY
argument_list|)
expr_stmt|;
name|ieee_test
argument_list|(
operator|-
name|NAN
argument_list|)
expr_stmt|;
name|ieee_test
argument_list|(
name|INFINITY
argument_list|)
expr_stmt|;
name|ieee_test
argument_list|(
name|NAN
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

