begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* IEEE floating point support routines, for GDB, the GNU Debugger.    Copyright (C) 1991, 1994 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_comment
comment|/* ldexp */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_function_decl
specifier|extern
name|void
modifier|*
name|memcpy
parameter_list|(
name|void
modifier|*
name|s1
parameter_list|,
specifier|const
name|void
modifier|*
name|s2
parameter_list|,
name|size_t
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
modifier|*
name|memset
parameter_list|(
name|void
modifier|*
name|s
parameter_list|,
name|int
name|c
parameter_list|,
name|size_t
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|char
modifier|*
name|memcpy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|memset
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The odds that CHAR_BIT will be anything but 8 are low enough that I'm not    going to bother with trying to muck around with whether it is defined in    a system header, what we do if not, etc.  */
end_comment

begin_define
define|#
directive|define
name|FLOATFORMAT_CHAR_BIT
value|8
end_define

begin_comment
comment|/* floatformats for IEEE single and double, big and little endian.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_ieee_single_big
init|=
block|{
name|floatformat_big
block|,
literal|32
block|,
literal|0
block|,
literal|1
block|,
literal|8
block|,
literal|127
block|,
literal|255
block|,
literal|9
block|,
literal|23
block|,
name|floatformat_intbit_no
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_ieee_single_little
init|=
block|{
name|floatformat_little
block|,
literal|32
block|,
literal|0
block|,
literal|1
block|,
literal|8
block|,
literal|127
block|,
literal|255
block|,
literal|9
block|,
literal|23
block|,
name|floatformat_intbit_no
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_ieee_double_big
init|=
block|{
name|floatformat_big
block|,
literal|64
block|,
literal|0
block|,
literal|1
block|,
literal|11
block|,
literal|1023
block|,
literal|2047
block|,
literal|12
block|,
literal|52
block|,
name|floatformat_intbit_no
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_ieee_double_little
init|=
block|{
name|floatformat_little
block|,
literal|64
block|,
literal|0
block|,
literal|1
block|,
literal|11
block|,
literal|1023
block|,
literal|2047
block|,
literal|12
block|,
literal|52
block|,
name|floatformat_intbit_no
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* floatformat for IEEE double, little endian byte order, with big endian word    ordering, as on the ARM.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_ieee_double_littlebyte_bigword
init|=
block|{
name|floatformat_littlebyte_bigword
block|,
literal|64
block|,
literal|0
block|,
literal|1
block|,
literal|11
block|,
literal|1023
block|,
literal|2047
block|,
literal|12
block|,
literal|52
block|,
name|floatformat_intbit_no
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_i387_ext
init|=
block|{
name|floatformat_little
block|,
literal|80
block|,
literal|0
block|,
literal|1
block|,
literal|15
block|,
literal|0x3fff
block|,
literal|0x7fff
block|,
literal|16
block|,
literal|64
block|,
name|floatformat_intbit_yes
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_m68881_ext
init|=
block|{
comment|/* Note that the bits from 16 to 31 are unused.  */
name|floatformat_big
block|,
literal|96
block|,
literal|0
block|,
literal|1
block|,
literal|15
block|,
literal|0x3fff
block|,
literal|0x7fff
block|,
literal|32
block|,
literal|64
block|,
name|floatformat_intbit_yes
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_i960_ext
init|=
block|{
comment|/* Note that the bits from 0 to 15 are unused.  */
name|floatformat_little
block|,
literal|96
block|,
literal|16
block|,
literal|17
block|,
literal|15
block|,
literal|0x3fff
block|,
literal|0x7fff
block|,
literal|32
block|,
literal|64
block|,
name|floatformat_intbit_yes
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_m88110_ext
init|=
block|{
ifdef|#
directive|ifdef
name|HARRIS_FLOAT_FORMAT
comment|/* Harris uses raw format 128 bytes long, but the number is just an ieee      double, and the last 64 bits are wasted. */
name|floatformat_big
block|,
literal|128
block|,
literal|0
block|,
literal|1
block|,
literal|11
block|,
literal|0x3ff
block|,
literal|0x7ff
block|,
literal|12
block|,
literal|52
block|,
name|floatformat_intbit_no
else|#
directive|else
name|floatformat_big
block|,
literal|80
block|,
literal|0
block|,
literal|1
block|,
literal|15
block|,
literal|0x3fff
block|,
literal|0x7fff
block|,
literal|16
block|,
literal|64
block|,
name|floatformat_intbit_yes
endif|#
directive|endif
comment|/* HARRIS_FLOAT_FORMAT */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|floatformat
name|floatformat_arm_ext
init|=
block|{
comment|/* Bits 1 to 16 are unused.  */
name|floatformat_big
block|,
literal|96
block|,
literal|0
block|,
literal|17
block|,
literal|15
block|,
literal|0x3fff
block|,
literal|0x7fff
block|,
literal|32
block|,
literal|64
block|,
name|floatformat_intbit_yes
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|get_field
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
expr|enum
name|floatformat_byteorders
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Extract a field which starts at START and is LEN bytes long.  DATA and    TOTAL_LEN are the thing we are extracting it from, in byteorder ORDER.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|get_field
parameter_list|(
name|data
parameter_list|,
name|order
parameter_list|,
name|total_len
parameter_list|,
name|start
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|enum
name|floatformat_byteorders
name|order
decl_stmt|;
name|unsigned
name|int
name|total_len
decl_stmt|;
name|unsigned
name|int
name|start
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
block|{
name|unsigned
name|long
name|result
decl_stmt|;
name|unsigned
name|int
name|cur_byte
decl_stmt|;
name|int
name|cur_bitshift
decl_stmt|;
comment|/* Start at the least significant part of the field.  */
name|cur_byte
operator|=
operator|(
name|start
operator|+
name|len
operator|)
operator|/
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
if|if
condition|(
name|order
operator|==
name|floatformat_little
condition|)
name|cur_byte
operator|=
operator|(
name|total_len
operator|/
name|FLOATFORMAT_CHAR_BIT
operator|)
operator|-
name|cur_byte
operator|-
literal|1
expr_stmt|;
name|cur_bitshift
operator|=
operator|(
operator|(
name|start
operator|+
name|len
operator|)
operator|%
name|FLOATFORMAT_CHAR_BIT
operator|)
operator|-
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
name|result
operator|=
operator|*
operator|(
name|data
operator|+
name|cur_byte
operator|)
operator|>>
operator|(
operator|-
name|cur_bitshift
operator|)
expr_stmt|;
name|cur_bitshift
operator|+=
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
if|if
condition|(
name|order
operator|==
name|floatformat_little
condition|)
operator|++
name|cur_byte
expr_stmt|;
else|else
operator|--
name|cur_byte
expr_stmt|;
comment|/* Move towards the most significant part of the field.  */
while|while
condition|(
name|cur_bitshift
operator|<
name|len
condition|)
block|{
if|if
condition|(
name|len
operator|-
name|cur_bitshift
operator|<
name|FLOATFORMAT_CHAR_BIT
condition|)
comment|/* This is the last byte; zero out the bits which are not part of 	   this field.  */
name|result
operator||=
operator|(
operator|*
operator|(
name|data
operator|+
name|cur_byte
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|len
operator|-
name|cur_bitshift
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|cur_bitshift
expr_stmt|;
else|else
name|result
operator||=
operator|*
operator|(
name|data
operator|+
name|cur_byte
operator|)
operator|<<
name|cur_bitshift
expr_stmt|;
name|cur_bitshift
operator|+=
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
if|if
condition|(
name|order
operator|==
name|floatformat_little
condition|)
operator|++
name|cur_byte
expr_stmt|;
else|else
operator|--
name|cur_byte
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|min
end_ifndef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Convert from FMT to a double.    FROM is the address of the extended float.    Store the double in *TO.  */
end_comment

begin_function
name|void
name|floatformat_to_double
parameter_list|(
name|fmt
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|)
specifier|const
name|struct
name|floatformat
modifier|*
name|fmt
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
name|double
modifier|*
name|to
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|ufrom
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|from
decl_stmt|;
name|double
name|dto
decl_stmt|;
name|long
name|exponent
decl_stmt|;
name|unsigned
name|long
name|mant
decl_stmt|;
name|unsigned
name|int
name|mant_bits
decl_stmt|,
name|mant_off
decl_stmt|;
name|int
name|mant_bits_left
decl_stmt|;
name|int
name|special_exponent
decl_stmt|;
comment|/* It's a NaN, denorm or zero */
name|exponent
operator|=
name|get_field
argument_list|(
name|ufrom
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|exp_start
argument_list|,
name|fmt
operator|->
name|exp_len
argument_list|)
expr_stmt|;
comment|/* Note that if exponent indicates a NaN, we can't really do anything useful      (not knowing if the host has NaN's, or how to build one).  So it will      end up as an infinity or something close; that is OK.  */
name|mant_bits_left
operator|=
name|fmt
operator|->
name|man_len
expr_stmt|;
name|mant_off
operator|=
name|fmt
operator|->
name|man_start
expr_stmt|;
name|dto
operator|=
literal|0.0
expr_stmt|;
name|special_exponent
operator|=
name|exponent
operator|==
literal|0
operator|||
name|exponent
operator|==
name|fmt
operator|->
name|exp_nan
expr_stmt|;
comment|/* Don't bias zero's, denorms or NaNs.  */
if|if
condition|(
operator|!
name|special_exponent
condition|)
name|exponent
operator|-=
name|fmt
operator|->
name|exp_bias
expr_stmt|;
comment|/* Build the result algebraically.  Might go infinite, underflow, etc;      who cares. */
comment|/* If this format uses a hidden bit, explicitly add it in now.  Otherwise,      increment the exponent by one to account for the integer bit.  */
if|if
condition|(
operator|!
name|special_exponent
condition|)
if|if
condition|(
name|fmt
operator|->
name|intbit
operator|==
name|floatformat_intbit_no
condition|)
name|dto
operator|=
name|ldexp
argument_list|(
literal|1.0
argument_list|,
name|exponent
argument_list|)
expr_stmt|;
else|else
name|exponent
operator|++
expr_stmt|;
while|while
condition|(
name|mant_bits_left
operator|>
literal|0
condition|)
block|{
name|mant_bits
operator|=
name|min
argument_list|(
name|mant_bits_left
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|mant
operator|=
name|get_field
argument_list|(
name|ufrom
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|mant_off
argument_list|,
name|mant_bits
argument_list|)
expr_stmt|;
name|dto
operator|+=
name|ldexp
argument_list|(
operator|(
name|double
operator|)
name|mant
argument_list|,
name|exponent
operator|-
name|mant_bits
argument_list|)
expr_stmt|;
name|exponent
operator|-=
name|mant_bits
expr_stmt|;
name|mant_off
operator|+=
name|mant_bits
expr_stmt|;
name|mant_bits_left
operator|-=
name|mant_bits
expr_stmt|;
block|}
comment|/* Negate it if negative.  */
if|if
condition|(
name|get_field
argument_list|(
name|ufrom
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|sign_start
argument_list|,
literal|1
argument_list|)
condition|)
name|dto
operator|=
operator|-
name|dto
expr_stmt|;
operator|*
name|to
operator|=
name|dto
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|put_field
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
expr|enum
name|floatformat_byteorders
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set a field which starts at START and is LEN bytes long.  DATA and    TOTAL_LEN are the thing we are extracting it from, in byteorder ORDER.  */
end_comment

begin_function
specifier|static
name|void
name|put_field
parameter_list|(
name|data
parameter_list|,
name|order
parameter_list|,
name|total_len
parameter_list|,
name|start
parameter_list|,
name|len
parameter_list|,
name|stuff_to_put
parameter_list|)
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|enum
name|floatformat_byteorders
name|order
decl_stmt|;
name|unsigned
name|int
name|total_len
decl_stmt|;
name|unsigned
name|int
name|start
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|unsigned
name|long
name|stuff_to_put
decl_stmt|;
block|{
name|unsigned
name|int
name|cur_byte
decl_stmt|;
name|int
name|cur_bitshift
decl_stmt|;
comment|/* Start at the least significant part of the field.  */
name|cur_byte
operator|=
operator|(
name|start
operator|+
name|len
operator|)
operator|/
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
if|if
condition|(
name|order
operator|==
name|floatformat_little
condition|)
name|cur_byte
operator|=
operator|(
name|total_len
operator|/
name|FLOATFORMAT_CHAR_BIT
operator|)
operator|-
name|cur_byte
operator|-
literal|1
expr_stmt|;
name|cur_bitshift
operator|=
operator|(
operator|(
name|start
operator|+
name|len
operator|)
operator|%
name|FLOATFORMAT_CHAR_BIT
operator|)
operator|-
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
operator|*
operator|(
name|data
operator|+
name|cur_byte
operator|)
operator|&=
operator|~
operator|(
operator|(
operator|(
literal|1
operator|<<
operator|(
operator|(
name|start
operator|+
name|len
operator|)
operator|%
name|FLOATFORMAT_CHAR_BIT
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
operator|(
operator|-
name|cur_bitshift
operator|)
operator|)
expr_stmt|;
operator|*
operator|(
name|data
operator|+
name|cur_byte
operator|)
operator||=
operator|(
name|stuff_to_put
operator|&
operator|(
operator|(
literal|1
operator|<<
name|FLOATFORMAT_CHAR_BIT
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
operator|-
name|cur_bitshift
operator|)
expr_stmt|;
name|cur_bitshift
operator|+=
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
if|if
condition|(
name|order
operator|==
name|floatformat_little
condition|)
operator|++
name|cur_byte
expr_stmt|;
else|else
operator|--
name|cur_byte
expr_stmt|;
comment|/* Move towards the most significant part of the field.  */
while|while
condition|(
name|cur_bitshift
operator|<
name|len
condition|)
block|{
if|if
condition|(
name|len
operator|-
name|cur_bitshift
operator|<
name|FLOATFORMAT_CHAR_BIT
condition|)
block|{
comment|/* This is the last byte.  */
operator|*
operator|(
name|data
operator|+
name|cur_byte
operator|)
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|len
operator|-
name|cur_bitshift
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
name|data
operator|+
name|cur_byte
operator|)
operator||=
operator|(
name|stuff_to_put
operator|>>
name|cur_bitshift
operator|)
expr_stmt|;
block|}
else|else
operator|*
operator|(
name|data
operator|+
name|cur_byte
operator|)
operator|=
operator|(
operator|(
name|stuff_to_put
operator|>>
name|cur_bitshift
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|FLOATFORMAT_CHAR_BIT
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|cur_bitshift
operator|+=
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
if|if
condition|(
name|order
operator|==
name|floatformat_little
condition|)
operator|++
name|cur_byte
expr_stmt|;
else|else
operator|--
name|cur_byte
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The converse: convert the double *FROM to an extended float    and store where TO points.  Neither FROM nor TO have any alignment    restrictions.  */
end_comment

begin_function
name|void
name|floatformat_from_double
parameter_list|(
name|fmt
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|)
name|CONST
name|struct
name|floatformat
modifier|*
name|fmt
decl_stmt|;
name|double
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
block|{
name|double
name|dfrom
decl_stmt|;
name|int
name|exponent
decl_stmt|;
name|double
name|mant
decl_stmt|;
name|unsigned
name|int
name|mant_bits
decl_stmt|,
name|mant_off
decl_stmt|;
name|int
name|mant_bits_left
decl_stmt|;
name|unsigned
name|char
modifier|*
name|uto
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|to
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|dfrom
argument_list|,
name|from
argument_list|,
sizeof|sizeof
argument_list|(
name|dfrom
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|uto
argument_list|,
literal|0
argument_list|,
name|fmt
operator|->
name|totalsize
operator|/
name|FLOATFORMAT_CHAR_BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfrom
operator|==
literal|0
condition|)
return|return;
comment|/* Result is zero */
if|if
condition|(
name|dfrom
operator|!=
name|dfrom
condition|)
block|{
comment|/* From is NaN */
name|put_field
argument_list|(
name|uto
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|exp_start
argument_list|,
name|fmt
operator|->
name|exp_len
argument_list|,
name|fmt
operator|->
name|exp_nan
argument_list|)
expr_stmt|;
comment|/* Be sure it's not infinity, but NaN value is irrel */
name|put_field
argument_list|(
name|uto
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|man_start
argument_list|,
literal|32
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If negative, set the sign bit.  */
if|if
condition|(
name|dfrom
operator|<
literal|0
condition|)
block|{
name|put_field
argument_list|(
name|uto
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|sign_start
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dfrom
operator|=
operator|-
name|dfrom
expr_stmt|;
block|}
comment|/* How to tell an infinity from an ordinary number?  FIXME-someday */
name|mant
operator|=
name|frexp
argument_list|(
name|dfrom
argument_list|,
operator|&
name|exponent
argument_list|)
expr_stmt|;
name|put_field
argument_list|(
name|uto
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|exp_start
argument_list|,
name|fmt
operator|->
name|exp_len
argument_list|,
name|exponent
operator|+
name|fmt
operator|->
name|exp_bias
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mant_bits_left
operator|=
name|fmt
operator|->
name|man_len
expr_stmt|;
name|mant_off
operator|=
name|fmt
operator|->
name|man_start
expr_stmt|;
while|while
condition|(
name|mant_bits_left
operator|>
literal|0
condition|)
block|{
name|unsigned
name|long
name|mant_long
decl_stmt|;
name|mant_bits
operator|=
name|mant_bits_left
operator|<
literal|32
condition|?
name|mant_bits_left
else|:
literal|32
expr_stmt|;
name|mant
operator|*=
literal|4294967296.0
expr_stmt|;
name|mant_long
operator|=
operator|(
name|unsigned
name|long
operator|)
name|mant
expr_stmt|;
name|mant
operator|-=
name|mant_long
expr_stmt|;
comment|/* If the integer bit is implicit, then we need to discard it. 	 If we are discarding a zero, we should be (but are not) creating 	 a denormalized	number which means adjusting the exponent 	 (I think).  */
if|if
condition|(
name|mant_bits_left
operator|==
name|fmt
operator|->
name|man_len
operator|&&
name|fmt
operator|->
name|intbit
operator|==
name|floatformat_intbit_no
condition|)
block|{
name|mant_long
operator|&=
literal|0x7fffffff
expr_stmt|;
name|mant_bits
operator|-=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mant_bits
operator|<
literal|32
condition|)
block|{
comment|/* The bits we want are in the most significant MANT_BITS bits of 	     mant_long.  Move them to the least significant.  */
name|mant_long
operator|>>=
literal|32
operator|-
name|mant_bits
expr_stmt|;
block|}
name|put_field
argument_list|(
name|uto
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|mant_off
argument_list|,
name|mant_bits
argument_list|,
name|mant_long
argument_list|)
expr_stmt|;
name|mant_off
operator|+=
name|mant_bits
expr_stmt|;
name|mant_bits_left
operator|-=
name|mant_bits
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE_DEBUG
end_ifdef

begin_comment
comment|/* This is to be run on a host which uses IEEE floating point.  */
end_comment

begin_function
name|void
name|ieee_test
parameter_list|(
name|n
parameter_list|)
name|double
name|n
decl_stmt|;
block|{
name|double
name|result
decl_stmt|;
name|char
name|exten
index|[
literal|16
index|]
decl_stmt|;
name|floatformat_to_double
argument_list|(
operator|&
name|floatformat_ieee_double_big
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|result
condition|)
name|printf
argument_list|(
literal|"Differ(to): %.20g -> %.20g\n"
argument_list|,
name|n
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|floatformat_from_double
argument_list|(
operator|&
name|floatformat_ieee_double_big
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|result
condition|)
name|printf
argument_list|(
literal|"Differ(from): %.20g -> %.20g\n"
argument_list|,
name|n
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|floatformat_from_double
argument_list|(
operator|&
name|floatformat_m68881_ext
argument_list|,
operator|&
name|n
argument_list|,
name|exten
argument_list|)
expr_stmt|;
name|floatformat_to_double
argument_list|(
operator|&
name|floatformat_m68881_ext
argument_list|,
name|exten
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|result
condition|)
name|printf
argument_list|(
literal|"Differ(to+from): %.20g -> %.20g\n"
argument_list|,
name|n
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|#
directive|if
name|IEEE_DEBUG
operator|>
literal|1
comment|/* This is to be run on a host which uses 68881 format.  */
block|{
name|long
name|double
name|ex
init|=
operator|*
operator|(
name|long
name|double
operator|*
operator|)
name|exten
decl_stmt|;
if|if
condition|(
name|ex
operator|!=
name|n
condition|)
name|printf
argument_list|(
literal|"Differ(from vs. extended): %.20g\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|main
parameter_list|()
block|{
name|ieee_test
argument_list|(
literal|0.5
argument_list|)
expr_stmt|;
name|ieee_test
argument_list|(
literal|256.0
argument_list|)
expr_stmt|;
name|ieee_test
argument_list|(
literal|0.12345
argument_list|)
expr_stmt|;
name|ieee_test
argument_list|(
literal|234235.78907234
argument_list|)
expr_stmt|;
name|ieee_test
argument_list|(
operator|-
literal|512.0
argument_list|)
expr_stmt|;
name|ieee_test
argument_list|(
operator|-
literal|0.004321
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

