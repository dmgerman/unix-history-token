begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. [rescinded 22 July 1999]  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * This is derived from the Berkeley source:  *	@(#)random.c	5.5 (Berkeley) 7/6/88  * It was reworked for the GNU C Library by Roland McGrath.  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_include
include|#
directive|include
file|<ansidecl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ULONG_MAX
value|((unsigned long)(~0L))
end_define

begin_comment
comment|/* 0xFFFFFFFF for 32-bits */
end_comment

begin_define
define|#
directive|define
name|LONG_MAX
value|((long)(ULONG_MAX>> 1))
end_define

begin_comment
comment|/* 0x7FFFFFFF for 32-bits*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|PTR
value|void *
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|(void *) 0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PTR
value|char *
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|(void *) 0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|long
name|int
name|random
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* An improved random number generation package.  In addition to the standard    rand()/srand() like interface, this package also has a special state info    interface.  The initstate() routine is called with a seed, an array of    bytes, and a count of how many bytes are being passed in; this array is    then initialized to contain information for random number generation with    that much state information.  Good sizes for the amount of state    information are 32, 64, 128, and 256 bytes.  The state can be switched by    calling the setstate() function with the same array as was initiallized    with initstate().  By default, the package runs with 128 bytes of state    information and generates far better random numbers than a linear    congruential generator.  If the amount of state information is less than    32 bytes, a simple linear congruential R.N.G. is used.  Internally, the    state information is treated as an array of longs; the zeroeth element of    the array is the type of R.N.G. being used (small integer); the remainder    of the array is the state information for the R.N.G.  Thus, 32 bytes of    state information will give 7 longs worth of state information, which will    allow a degree seven polynomial.  (Note: The zeroeth word of state    information also has some other information stored in it; see setstate    for details).  The random number generation technique is a linear feedback    shift register approach, employing trinomials (since there are fewer terms    to sum up that way).  In this approach, the least significant bit of all    the numbers in the state table will act as a linear feedback shift register,    and will have period 2^deg - 1 (where deg is the degree of the polynomial    being used, assuming that the polynomial is irreducible and primitive).    The higher order bits will have longer periods, since their values are    also influenced by pseudo-random carries out of the lower bits.  The    total period of the generator is approximately deg*(2**deg - 1); thus    doubling the amount of state information has a vast influence on the    period of the generator.  Note: The deg*(2**deg - 1) is an approximation    only good for large deg, when the period of the shift register is the    dominant factor.  With deg equal to seven, the period is actually much    longer than the 7*(2**7 - 1) predicted by this formula.  */
end_comment

begin_comment
comment|/* For each of the currently supported random number generators, we have a    break value on the amount of state information (you need at least thi    bytes of state info to support this random number generator), a degree for    the polynomial (actually a trinomial) that the R.N.G. is based on, and    separation between the two lower order coefficients of the trinomial.  */
end_comment

begin_comment
comment|/* Linear congruential.  */
end_comment

begin_define
define|#
directive|define
name|TYPE_0
value|0
end_define

begin_define
define|#
directive|define
name|BREAK_0
value|8
end_define

begin_define
define|#
directive|define
name|DEG_0
value|0
end_define

begin_define
define|#
directive|define
name|SEP_0
value|0
end_define

begin_comment
comment|/* x**7 + x**3 + 1.  */
end_comment

begin_define
define|#
directive|define
name|TYPE_1
value|1
end_define

begin_define
define|#
directive|define
name|BREAK_1
value|32
end_define

begin_define
define|#
directive|define
name|DEG_1
value|7
end_define

begin_define
define|#
directive|define
name|SEP_1
value|3
end_define

begin_comment
comment|/* x**15 + x + 1.  */
end_comment

begin_define
define|#
directive|define
name|TYPE_2
value|2
end_define

begin_define
define|#
directive|define
name|BREAK_2
value|64
end_define

begin_define
define|#
directive|define
name|DEG_2
value|15
end_define

begin_define
define|#
directive|define
name|SEP_2
value|1
end_define

begin_comment
comment|/* x**31 + x**3 + 1.  */
end_comment

begin_define
define|#
directive|define
name|TYPE_3
value|3
end_define

begin_define
define|#
directive|define
name|BREAK_3
value|128
end_define

begin_define
define|#
directive|define
name|DEG_3
value|31
end_define

begin_define
define|#
directive|define
name|SEP_3
value|3
end_define

begin_comment
comment|/* x**63 + x + 1.  */
end_comment

begin_define
define|#
directive|define
name|TYPE_4
value|4
end_define

begin_define
define|#
directive|define
name|BREAK_4
value|256
end_define

begin_define
define|#
directive|define
name|DEG_4
value|63
end_define

begin_define
define|#
directive|define
name|SEP_4
value|1
end_define

begin_comment
comment|/* Array versions of the above information to make code run faster.    Relies on fact that TYPE_i == i.  */
end_comment

begin_define
define|#
directive|define
name|MAX_TYPES
value|5
end_define

begin_comment
comment|/* Max number of types above.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|degrees
index|[
name|MAX_TYPES
index|]
init|=
block|{
name|DEG_0
block|,
name|DEG_1
block|,
name|DEG_2
block|,
name|DEG_3
block|,
name|DEG_4
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|seps
index|[
name|MAX_TYPES
index|]
init|=
block|{
name|SEP_0
block|,
name|SEP_1
block|,
name|SEP_2
block|,
name|SEP_3
block|,
name|SEP_4
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initially, everything is set up as if from: 	initstate(1, randtbl, 128);    Note that this initialization takes advantage of the fact that srandom    advances the front and rear pointers 10*rand_deg times, and hence the    rear pointer which starts at 0 will also end up at zero; thus the zeroeth    element of the state information, which contains info about the current    position of the rear pointer is just 	(MAX_TYPES * (rptr - state)) + TYPE_3 == TYPE_3.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|int
name|randtbl
index|[
name|DEG_3
operator|+
literal|1
index|]
init|=
block|{
name|TYPE_3
block|,
literal|0x9a319039
block|,
literal|0x32d9c024
block|,
literal|0x9b663182
block|,
literal|0x5da1f342
block|,
literal|0xde3b81e0
block|,
literal|0xdf0a6fb5
block|,
literal|0xf103bc02
block|,
literal|0x48f340fb
block|,
literal|0x7449e56b
block|,
literal|0xbeb1dbb0
block|,
literal|0xab5c5918
block|,
literal|0x946554fd
block|,
literal|0x8c2e680f
block|,
literal|0xeb3d799f
block|,
literal|0xb11ee0b7
block|,
literal|0x2d436b86
block|,
literal|0xda672e2a
block|,
literal|0x1588ca88
block|,
literal|0xe369735d
block|,
literal|0x904f35f7
block|,
literal|0xd7158fd6
block|,
literal|0x6fa6f051
block|,
literal|0x616e6b96
block|,
literal|0xac94efdc
block|,
literal|0x36413f93
block|,
literal|0xc622c298
block|,
literal|0xf5a42ab8
block|,
literal|0x8a88d77b
block|,
literal|0xf5ad9d0e
block|,
literal|0x8999220b
block|,
literal|0x27fb47b9
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FPTR and RPTR are two pointers into the state info, a front and a rear    pointer.  These two pointers are always rand_sep places aparts, as they    cycle through the state information.  (Yes, this does mean we could get    away with just one pointer, but the code for random is more efficient    this way).  The pointers are left positioned as they would be from the call: 	initstate(1, randtbl, 128);    (The position of the rear pointer, rptr, is really 0 (as explained above    in the initialization of randtbl) because the state table pointer is set    to point to randtbl[1] (as explained below).)  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|int
modifier|*
name|fptr
init|=
operator|&
name|randtbl
index|[
name|SEP_3
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|int
modifier|*
name|rptr
init|=
operator|&
name|randtbl
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following things are the pointer to the state information table,    the type of the current generator, the degree of the current polynomial    being used, and the separation between the two pointers.    Note that for efficiency of random, we remember the first location of    the state information, not the zeroeth.  Hence it is valid to access    state[-1], which is used to store the type of the R.N.G.    Also, we remember the last location, since this is more efficient than    indexing every time to find the address of the last element to see if    the front and rear pointers have wrapped.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|int
modifier|*
name|state
init|=
operator|&
name|randtbl
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rand_type
init|=
name|TYPE_3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rand_deg
init|=
name|DEG_3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rand_sep
init|=
name|SEP_3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|int
modifier|*
name|end_ptr
init|=
operator|&
name|randtbl
index|[
sizeof|sizeof
argument_list|(
name|randtbl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|randtbl
index|[
literal|0
index|]
argument_list|)
index|]
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize the random number generator based on the given seed.  If the    type is the trivial no-state-information type, just remember the seed.    Otherwise, initializes state[] based on the given "seed" via a linear    congruential generator.  Then, the pointers are set to known locations    that are exactly rand_sep places apart.  Lastly, it cycles the state    information a given number of times to get rid of any initial dependencies    introduced by the L.C.R.N.G.  Note that the initialization of randtbl[]    for default usage relies on values produced by this routine.  */
end_comment

begin_function
name|void
name|srandom
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|int
name|x
decl_stmt|;
block|{
name|state
index|[
literal|0
index|]
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|rand_type
operator|!=
name|TYPE_0
condition|)
block|{
specifier|register
name|long
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|rand_deg
condition|;
operator|++
name|i
control|)
name|state
index|[
name|i
index|]
operator|=
operator|(
literal|1103515145
operator|*
name|state
index|[
name|i
operator|-
literal|1
index|]
operator|)
operator|+
literal|12345
expr_stmt|;
name|fptr
operator|=
operator|&
name|state
index|[
name|rand_sep
index|]
expr_stmt|;
name|rptr
operator|=
operator|&
name|state
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
operator|*
name|rand_deg
condition|;
operator|++
name|i
control|)
name|random
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize the state information in the given array of N bytes for    future random number generation.  Based on the number of bytes we    are given, and the break values for the different R.N.G.'s, we choose    the best (largest) one we can and set things up for it.  srandom is    then called to initialize the state information.  Note that on return    from srandom, we set state[-1] to be the type multiplexed with the current    value of the rear pointer; this is so successive calls to initstate won't    lose this information and will be able to restart with setstate.    Note: The first thing we do is save the current state, if any, just like    setstate so that it doesn't matter when initstate is called.    Returns a pointer to the old state.  */
end_comment

begin_function
name|PTR
name|initstate
parameter_list|(
name|seed
parameter_list|,
name|arg_state
parameter_list|,
name|n
parameter_list|)
name|unsigned
name|int
name|seed
decl_stmt|;
name|PTR
name|arg_state
decl_stmt|;
name|unsigned
name|long
name|n
decl_stmt|;
block|{
name|PTR
name|ostate
init|=
operator|(
name|PTR
operator|)
operator|&
name|state
index|[
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|rand_type
operator|==
name|TYPE_0
condition|)
name|state
index|[
operator|-
literal|1
index|]
operator|=
name|rand_type
expr_stmt|;
else|else
name|state
index|[
operator|-
literal|1
index|]
operator|=
operator|(
name|MAX_TYPES
operator|*
operator|(
name|rptr
operator|-
name|state
operator|)
operator|)
operator|+
name|rand_type
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|BREAK_1
condition|)
block|{
if|if
condition|(
name|n
operator|<
name|BREAK_0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|rand_type
operator|=
name|TYPE_0
expr_stmt|;
name|rand_deg
operator|=
name|DEG_0
expr_stmt|;
name|rand_sep
operator|=
name|SEP_0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|<
name|BREAK_2
condition|)
block|{
name|rand_type
operator|=
name|TYPE_1
expr_stmt|;
name|rand_deg
operator|=
name|DEG_1
expr_stmt|;
name|rand_sep
operator|=
name|SEP_1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|<
name|BREAK_3
condition|)
block|{
name|rand_type
operator|=
name|TYPE_2
expr_stmt|;
name|rand_deg
operator|=
name|DEG_2
expr_stmt|;
name|rand_sep
operator|=
name|SEP_2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|<
name|BREAK_4
condition|)
block|{
name|rand_type
operator|=
name|TYPE_3
expr_stmt|;
name|rand_deg
operator|=
name|DEG_3
expr_stmt|;
name|rand_sep
operator|=
name|SEP_3
expr_stmt|;
block|}
else|else
block|{
name|rand_type
operator|=
name|TYPE_4
expr_stmt|;
name|rand_deg
operator|=
name|DEG_4
expr_stmt|;
name|rand_sep
operator|=
name|SEP_4
expr_stmt|;
block|}
name|state
operator|=
operator|&
operator|(
operator|(
name|long
name|int
operator|*
operator|)
name|arg_state
operator|)
index|[
literal|1
index|]
expr_stmt|;
comment|/* First location.  */
comment|/* Must set END_PTR before srandom.  */
name|end_ptr
operator|=
operator|&
name|state
index|[
name|rand_deg
index|]
expr_stmt|;
name|srandom
argument_list|(
name|seed
argument_list|)
expr_stmt|;
if|if
condition|(
name|rand_type
operator|==
name|TYPE_0
condition|)
name|state
index|[
operator|-
literal|1
index|]
operator|=
name|rand_type
expr_stmt|;
else|else
name|state
index|[
operator|-
literal|1
index|]
operator|=
operator|(
name|MAX_TYPES
operator|*
operator|(
name|rptr
operator|-
name|state
operator|)
operator|)
operator|+
name|rand_type
expr_stmt|;
return|return
name|ostate
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Restore the state from the given state array.    Note: It is important that we also remember the locations of the pointers    in the current state information, and restore the locations of the pointers    from the old state information.  This is done by multiplexing the pointer    location into the zeroeth word of the state information. Note that due    to the order in which things are done, it is OK to call setstate with the    same state as the current state    Returns a pointer to the old state information.  */
end_comment

begin_function
name|PTR
name|setstate
parameter_list|(
name|arg_state
parameter_list|)
name|PTR
name|arg_state
decl_stmt|;
block|{
specifier|register
name|long
name|int
modifier|*
name|new_state
init|=
operator|(
name|long
name|int
operator|*
operator|)
name|arg_state
decl_stmt|;
specifier|register
name|int
name|type
init|=
name|new_state
index|[
literal|0
index|]
operator|%
name|MAX_TYPES
decl_stmt|;
specifier|register
name|int
name|rear
init|=
name|new_state
index|[
literal|0
index|]
operator|/
name|MAX_TYPES
decl_stmt|;
name|PTR
name|ostate
init|=
operator|(
name|PTR
operator|)
operator|&
name|state
index|[
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|rand_type
operator|==
name|TYPE_0
condition|)
name|state
index|[
operator|-
literal|1
index|]
operator|=
name|rand_type
expr_stmt|;
else|else
name|state
index|[
operator|-
literal|1
index|]
operator|=
operator|(
name|MAX_TYPES
operator|*
operator|(
name|rptr
operator|-
name|state
operator|)
operator|)
operator|+
name|rand_type
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYPE_0
case|:
case|case
name|TYPE_1
case|:
case|case
name|TYPE_2
case|:
case|case
name|TYPE_3
case|:
case|case
name|TYPE_4
case|:
name|rand_type
operator|=
name|type
expr_stmt|;
name|rand_deg
operator|=
name|degrees
index|[
name|type
index|]
expr_stmt|;
name|rand_sep
operator|=
name|seps
index|[
name|type
index|]
expr_stmt|;
break|break;
default|default:
comment|/* State info munged.  */
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|state
operator|=
operator|&
name|new_state
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|rand_type
operator|!=
name|TYPE_0
condition|)
block|{
name|rptr
operator|=
operator|&
name|state
index|[
name|rear
index|]
expr_stmt|;
name|fptr
operator|=
operator|&
name|state
index|[
operator|(
name|rear
operator|+
name|rand_sep
operator|)
operator|%
name|rand_deg
index|]
expr_stmt|;
block|}
comment|/* Set end_ptr too.  */
name|end_ptr
operator|=
operator|&
name|state
index|[
name|rand_deg
index|]
expr_stmt|;
return|return
name|ostate
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If we are using the trivial TYPE_0 R.N.G., just do the old linear    congruential bit.  Otherwise, we do our fancy trinomial stuff, which is the    same in all ther other cases due to all the global variables that have been    set up.  The basic operation is to add the number at the rear pointer into    the one at the front pointer.  Then both pointers are advanced to the next    location cyclically in the table.  The value returned is the sum generated,    reduced to 31 bits by throwing away the "least random" low bit.    Note: The code takes advantage of the fact that both the front and    rear pointers can't wrap on the same call by not testing the rear    pointer if the front one has wrapped.  Returns a 31-bit random number.  */
end_comment

begin_function
name|long
name|int
name|random
parameter_list|()
block|{
if|if
condition|(
name|rand_type
operator|==
name|TYPE_0
condition|)
block|{
name|state
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|state
index|[
literal|0
index|]
operator|*
literal|1103515245
operator|)
operator|+
literal|12345
operator|)
operator|&
name|LONG_MAX
expr_stmt|;
return|return
name|state
index|[
literal|0
index|]
return|;
block|}
else|else
block|{
name|long
name|int
name|i
decl_stmt|;
operator|*
name|fptr
operator|+=
operator|*
name|rptr
expr_stmt|;
comment|/* Chucking least random bit.  */
name|i
operator|=
operator|(
operator|*
name|fptr
operator|>>
literal|1
operator|)
operator|&
name|LONG_MAX
expr_stmt|;
operator|++
name|fptr
expr_stmt|;
if|if
condition|(
name|fptr
operator|>=
name|end_ptr
condition|)
block|{
name|fptr
operator|=
name|state
expr_stmt|;
operator|++
name|rptr
expr_stmt|;
block|}
else|else
block|{
operator|++
name|rptr
expr_stmt|;
if|if
condition|(
name|rptr
operator|>=
name|end_ptr
condition|)
name|rptr
operator|=
name|state
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
block|}
end_function

end_unit

