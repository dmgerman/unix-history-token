begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Concatenate variable number of strings.    Copyright (C) 1991, 1994, 2001 Free Software Foundation, Inc.    Written by Fred Fish @ Cygnus Support  This file is part of the libiberty library. Libiberty is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  Libiberty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with libiberty; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*  @deftypefn Extension char* concat (const char *@var{s1}, const char *@var{s2}, @dots{}, @code{NULL})  Concatenate zero or more of strings and return the result in freshly @code{xmalloc}ed memory.  Returns @code{NULL} if insufficient memory is available.  The argument list is terminated by the first @code{NULL} pointer encountered.  Pointers to empty strings are ignored.  @end deftypefn  NOTES  	This function uses xmalloc() which is expected to be a front end 	function to malloc() that deals with low memory situations.  In 	typical use, if malloc() returns NULL then xmalloc() diverts to an 	error handler routine which never returns, and thus xmalloc will 	never return a NULL pointer.  If the client application wishes to 	deal with low memory situations itself, it should supply an xmalloc 	that just directly invokes malloc and blindly returns whatever 	malloc returns.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* size_t */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_STRING_H
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HAVE_STRINGS_H
end_if

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_STDLIB_H
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|inline
name|unsigned
name|long
name|vconcat_length
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
name|vconcat_length
parameter_list|(
name|first
parameter_list|,
name|args
parameter_list|)
specifier|const
name|char
modifier|*
name|first
decl_stmt|;
name|va_list
name|args
decl_stmt|;
block|{
name|unsigned
name|long
name|length
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
for|for
control|(
name|arg
operator|=
name|first
init|;
name|arg
condition|;
name|arg
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
control|)
name|length
operator|+=
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|inline
name|char
modifier|*
name|vconcat_copy
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|char
modifier|*
name|vconcat_copy
parameter_list|(
name|dst
parameter_list|,
name|first
parameter_list|,
name|args
parameter_list|)
name|char
modifier|*
name|dst
decl_stmt|;
specifier|const
name|char
modifier|*
name|first
decl_stmt|;
name|va_list
name|args
decl_stmt|;
block|{
name|char
modifier|*
name|end
init|=
name|dst
decl_stmt|;
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
for|for
control|(
name|arg
operator|=
name|first
init|;
name|arg
condition|;
name|arg
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
control|)
block|{
name|unsigned
name|long
name|length
init|=
name|strlen
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|end
argument_list|,
name|arg
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|end
operator|+=
name|length
expr_stmt|;
block|}
operator|*
name|end
operator|=
literal|'\000'
expr_stmt|;
return|return
name|dst
return|;
block|}
end_function

begin_comment
comment|/* @undocumented concat_length */
end_comment

begin_decl_stmt
name|unsigned
name|long
name|concat_length
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|first
operator|,
operator|...
operator|)
argument_list|)
block|{
name|unsigned
name|long
name|length
decl_stmt|;
name|VA_OPEN
argument_list|(
name|args
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|length
operator|=
name|vconcat_length
argument_list|(
name|first
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|length
return|;
block|}
end_decl_stmt

begin_comment
comment|/* @undocumented concat_copy */
end_comment

begin_decl_stmt
name|char
modifier|*
name|concat_copy
name|VPARAMS
argument_list|(
operator|(
name|char
operator|*
name|dst
operator|,
specifier|const
name|char
operator|*
name|first
operator|,
operator|...
operator|)
argument_list|)
block|{
name|char
modifier|*
name|save_dst
decl_stmt|;
name|VA_OPEN
argument_list|(
name|args
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|vconcat_copy
argument_list|(
name|dst
argument_list|,
name|first
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|save_dst
operator|=
name|dst
expr_stmt|;
comment|/* With K&R C, dst goes out of scope here.  */
name|VA_CLOSE
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|save_dst
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|libiberty_concat_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* @undocumented concat_copy2 */
end_comment

begin_decl_stmt
name|char
modifier|*
name|concat_copy2
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|first
operator|,
operator|...
operator|)
argument_list|)
block|{
name|VA_OPEN
argument_list|(
name|args
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|vconcat_copy
argument_list|(
name|libiberty_concat_ptr
argument_list|,
name|first
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|libiberty_concat_ptr
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|concat
name|VPARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|first
operator|,
operator|...
operator|)
argument_list|)
block|{
name|char
modifier|*
name|newstr
decl_stmt|;
comment|/* First compute the size of the result and get sufficient memory.  */
name|VA_OPEN
argument_list|(
name|args
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|newstr
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|vconcat_length
argument_list|(
name|first
argument_list|,
name|args
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|args
argument_list|)
expr_stmt|;
comment|/* Now copy the individual pieces to the result string. */
name|VA_OPEN
argument_list|(
name|args
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|vconcat_copy
argument_list|(
name|newstr
argument_list|,
name|first
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|newstr
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  @deftypefn Extension char* reconcat (char *@var{optr}, const char *@var{s1}, @dots{}, @code{NULL})  Same as @code{concat}, except that if @var{optr} is not @code{NULL} it is freed after the string is created.  This is intended to be useful when you're extending an existing string or building up a string in a loop:  @example   str = reconcat (str, "pre-", str, NULL); @end example  @end deftypefn  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|reconcat
name|VPARAMS
argument_list|(
operator|(
name|char
operator|*
name|optr
operator|,
specifier|const
name|char
operator|*
name|first
operator|,
operator|...
operator|)
argument_list|)
block|{
name|char
modifier|*
name|newstr
decl_stmt|;
comment|/* First compute the size of the result and get sufficient memory.  */
name|VA_OPEN
argument_list|(
name|args
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|,
name|optr
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|newstr
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|vconcat_length
argument_list|(
name|first
argument_list|,
name|args
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|args
argument_list|)
expr_stmt|;
comment|/* Now copy the individual pieces to the result string. */
name|VA_OPEN
argument_list|(
name|args
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|,
name|optr
argument_list|)
expr_stmt|;
name|VA_FIXEDARG
argument_list|(
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|vconcat_copy
argument_list|(
name|newstr
argument_list|,
name|first
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|optr
condition|)
comment|/* Done before VA_CLOSE so optr stays in scope for K&R C.  */
name|free
argument_list|(
name|optr
argument_list|)
expr_stmt|;
name|VA_CLOSE
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|newstr
return|;
block|}
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MAIN
end_ifdef

begin_define
define|#
directive|define
name|NULLP
value|(char *)0
end_define

begin_comment
comment|/* Simple little test driver. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function
name|int
name|main
parameter_list|()
block|{
name|printf
argument_list|(
literal|"\"\" = \"%s\"\n"
argument_list|,
name|concat
argument_list|(
name|NULLP
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"a\" = \"%s\"\n"
argument_list|,
name|concat
argument_list|(
literal|"a"
argument_list|,
name|NULLP
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"ab\" = \"%s\"\n"
argument_list|,
name|concat
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
name|NULLP
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"abc\" = \"%s\"\n"
argument_list|,
name|concat
argument_list|(
literal|"a"
argument_list|,
literal|"b"
argument_list|,
literal|"c"
argument_list|,
name|NULLP
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"abcd\" = \"%s\"\n"
argument_list|,
name|concat
argument_list|(
literal|"ab"
argument_list|,
literal|"cd"
argument_list|,
name|NULLP
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"abcde\" = \"%s\"\n"
argument_list|,
name|concat
argument_list|(
literal|"ab"
argument_list|,
literal|"c"
argument_list|,
literal|"de"
argument_list|,
name|NULLP
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"abcdef\" = \"%s\"\n"
argument_list|,
name|concat
argument_list|(
literal|""
argument_list|,
literal|"a"
argument_list|,
literal|""
argument_list|,
literal|"bcd"
argument_list|,
literal|"ef"
argument_list|,
name|NULLP
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

