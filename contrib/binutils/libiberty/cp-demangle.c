begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Demangler for IA64 / g++ V3 ABI.    Copyright (C) 2000, 2001 Free Software Foundation, Inc.    Written by Alex Samuel<samuel@codesourcery.com>.      This file is part of GNU CC.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file implements demangling of C++ names mangled according to    the IA64 / g++ V3 ABI.  Use the cp_demangle function to    demangle a mangled name, or compile with the preprocessor macro    STANDALONE_DEMANGLER defined to create a demangling filter    executable (functionally similar to c++filt, but includes this    demangler only).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"dyn-string.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_comment
comment|/* If CP_DEMANGLE_DEBUG is defined, a trace of the grammar evaluation,    and other debugging output, will be generated. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CP_DEMANGLE_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DEMANGLE_TRACE
parameter_list|(
name|PRODUCTION
parameter_list|,
name|DM
parameter_list|)
define|\
value|fprintf (stderr, " -> %-24s at position %3d\n",                       \            (PRODUCTION), current_position (DM));
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEMANGLE_TRACE
parameter_list|(
name|PRODUCTION
parameter_list|,
name|DM
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Don't include<ctype.h>, to prevent additional unresolved symbols    from being dragged into the C++ runtime library.  */
end_comment

begin_define
define|#
directive|define
name|IS_DIGIT
parameter_list|(
name|CHAR
parameter_list|)
value|((CHAR)>= '0'&& (CHAR)<= '9')
end_define

begin_define
define|#
directive|define
name|IS_ALPHA
parameter_list|(
name|CHAR
parameter_list|)
define|\
value|(((CHAR)>= 'a'&& (CHAR)<= 'z')                                     \    || ((CHAR)>= 'A'&& (CHAR)<= 'Z'))
end_define

begin_comment
comment|/* The prefix prepended by GCC to an identifier represnting the    anonymous namespace.  */
end_comment

begin_define
define|#
directive|define
name|ANONYMOUS_NAMESPACE_PREFIX
value|"_GLOBAL_"
end_define

begin_comment
comment|/* Character(s) to use for namespace separation in demangled output */
end_comment

begin_define
define|#
directive|define
name|NAMESPACE_SEPARATOR
value|(dm->style == DMGL_JAVA ? "." : "::")
end_define

begin_comment
comment|/* If flag_verbose is zero, some simplifications will be made to the    output to make it easier to read and supress details that are    generally not of interest to the average C++ programmer.    Otherwise, the demangled representation will attempt to convey as    much information as the mangled form.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If flag_strict is non-zero, demangle strictly according to the    specification -- don't demangle special g++ manglings.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_strict
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String_list_t is an extended form of dyn_string_t which provides a    link field and a caret position for additions to the string.  A    string_list_t may safely be cast to and used as a dyn_string_t.  */
end_comment

begin_struct
struct|struct
name|string_list_def
block|{
comment|/* The dyn_string; must be first.  */
name|struct
name|dyn_string
name|string
decl_stmt|;
comment|/* The position at which additional text is added to this string      (using the result_add* macros).  This value is an offset from the      end of the string, not the beginning (and should be      non-positive).  */
name|int
name|caret_position
decl_stmt|;
comment|/* The next string in the list.  */
name|struct
name|string_list_def
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|string_list_def
modifier|*
name|string_list_t
typedef|;
end_typedef

begin_comment
comment|/* Data structure representing a potential substitution.  */
end_comment

begin_struct
struct|struct
name|substitution_def
block|{
comment|/* The demangled text of the substitution.  */
name|dyn_string_t
name|text
decl_stmt|;
comment|/* Whether this substitution represents a template item.  */
name|int
name|template_p
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Data structure representing a template argument list.  */
end_comment

begin_struct
struct|struct
name|template_arg_list_def
block|{
comment|/* The next (lower) template argument list in the stack of currently      active template arguments.  */
name|struct
name|template_arg_list_def
modifier|*
name|next
decl_stmt|;
comment|/* The first element in the list of template arguments in      left-to-right order.  */
name|string_list_t
name|first_argument
decl_stmt|;
comment|/* The last element in the arguments lists.  */
name|string_list_t
name|last_argument
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|template_arg_list_def
modifier|*
name|template_arg_list_t
typedef|;
end_typedef

begin_comment
comment|/* Data structure to maintain the state of the current demangling.  */
end_comment

begin_struct
struct|struct
name|demangling_def
block|{
comment|/* The full mangled name being mangled.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Pointer into name at the current position.  */
specifier|const
name|char
modifier|*
name|next
decl_stmt|;
comment|/* Stack for strings containing demangled result generated so far.      Text is emitted to the topmost (first) string.  */
name|string_list_t
name|result
decl_stmt|;
comment|/* The number of presently available substitutions.  */
name|int
name|num_substitutions
decl_stmt|;
comment|/* The allocated size of the substitutions array.  */
name|int
name|substitutions_allocated
decl_stmt|;
comment|/* An array of available substitutions.  The number of elements in      the array is given by num_substitions, and the allocated array      size in substitutions_size.         The most recent substition is at the end, so         - `S_'  corresponds to substititutions[num_substitutions - 1]         - `S0_' corresponds to substititutions[num_substitutions - 2]       etc. */
name|struct
name|substitution_def
modifier|*
name|substitutions
decl_stmt|;
comment|/* The stack of template argument lists.  */
name|template_arg_list_t
name|template_arg_lists
decl_stmt|;
comment|/* The most recently demangled source-name.  */
name|dyn_string_t
name|last_source_name
decl_stmt|;
comment|/* Language style to use for demangled output. */
name|int
name|style
decl_stmt|;
comment|/* Set to non-zero iff this name is a constructor.  The actual value      indicates what sort of constructor this is; see demangle.h.  */
name|enum
name|gnu_v3_ctor_kinds
name|is_constructor
decl_stmt|;
comment|/* Set to non-zero iff this name is a destructor.  The actual value      indicates what sort of destructor this is; see demangle.h.  */
name|enum
name|gnu_v3_dtor_kinds
name|is_destructor
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|demangling_def
modifier|*
name|demangling_t
typedef|;
end_typedef

begin_comment
comment|/* This type is the standard return code from most functions.  Values    other than STATUS_OK contain descriptive messages.  */
end_comment

begin_typedef
typedef|typedef
specifier|const
name|char
modifier|*
name|status_t
typedef|;
end_typedef

begin_comment
comment|/* Special values that can be used as a status_t.  */
end_comment

begin_define
define|#
directive|define
name|STATUS_OK
value|NULL
end_define

begin_define
define|#
directive|define
name|STATUS_ERROR
value|"Error."
end_define

begin_define
define|#
directive|define
name|STATUS_UNIMPLEMENTED
value|"Unimplemented."
end_define

begin_define
define|#
directive|define
name|STATUS_INTERNAL_ERROR
value|"Internal error."
end_define

begin_comment
comment|/* This status code indicates a failure in malloc or realloc.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|status_allocation_failed
init|=
literal|"Allocation failed."
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|STATUS_ALLOCATION_FAILED
value|status_allocation_failed
end_define

begin_comment
comment|/* Non-zero if STATUS indicates that no error has occurred.  */
end_comment

begin_define
define|#
directive|define
name|STATUS_NO_ERROR
parameter_list|(
name|STATUS
parameter_list|)
value|((STATUS) == STATUS_OK)
end_define

begin_comment
comment|/* Evaluate EXPR, which must produce a status_t.  If the status code    indicates an error, return from the current function with that    status code.  */
end_comment

begin_define
define|#
directive|define
name|RETURN_IF_ERROR
parameter_list|(
name|EXPR
parameter_list|)
define|\
value|do                                                                    \     {                                                                   \       status_t s = EXPR;                                                \       if (!STATUS_NO_ERROR (s))                                         \ 	return s;                                                       \     }                                                                   \   while (0)
end_define

begin_decl_stmt
specifier|static
name|status_t
name|int_to_dyn_string
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|dyn_string_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|string_list_t
name|string_list_new
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_list_delete
name|PARAMS
argument_list|(
operator|(
name|string_list_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|result_add_separated_char
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|result_push
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|string_list_t
name|result_pop
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|substitution_start
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|substitution_add
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dyn_string_t
name|substitution_get
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CP_DEMANGLE_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|substitutions_print
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|template_arg_list_t
name|template_arg_list_new
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|template_arg_list_delete
name|PARAMS
argument_list|(
operator|(
name|template_arg_list_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|template_arg_list_add_arg
name|PARAMS
argument_list|(
operator|(
name|template_arg_list_t
operator|,
name|string_list_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|string_list_t
name|template_arg_list_get_arg
name|PARAMS
argument_list|(
operator|(
name|template_arg_list_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_template_arg_list
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|,
name|template_arg_list_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pop_to_template_arg_list
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|,
name|template_arg_list_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CP_DEMANGLE_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|template_arg_list_print
name|PARAMS
argument_list|(
operator|(
name|template_arg_list_t
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|template_arg_list_t
name|current_template_arg_list
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|demangling_t
name|demangling_new
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|demangling_delete
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last character of DS.  Warning: DS is evaluated twice.  */
end_comment

begin_define
define|#
directive|define
name|dyn_string_last_char
parameter_list|(
name|DS
parameter_list|)
define|\
value|(dyn_string_buf (DS)[dyn_string_length (DS) - 1])
end_define

begin_comment
comment|/* Append a space character (` ') to DS if it does not already end    with one.  Evaluates to 1 on success, or 0 on allocation failure.  */
end_comment

begin_define
define|#
directive|define
name|dyn_string_append_space
parameter_list|(
name|DS
parameter_list|)
define|\
value|((dyn_string_length (DS)> 0                                      \&& dyn_string_last_char (DS) != ' ')                            \        ? dyn_string_append_char ((DS), ' ')                             \        : 1)
end_define

begin_comment
comment|/* Returns the index of the current position in the mangled name.  */
end_comment

begin_define
define|#
directive|define
name|current_position
parameter_list|(
name|DM
parameter_list|)
value|((DM)->next - (DM)->name)
end_define

begin_comment
comment|/* Returns the character at the current position of the mangled name.  */
end_comment

begin_define
define|#
directive|define
name|peek_char
parameter_list|(
name|DM
parameter_list|)
value|(*((DM)->next))
end_define

begin_comment
comment|/* Returns the character one past the current position of the mangled    name.  */
end_comment

begin_define
define|#
directive|define
name|peek_char_next
parameter_list|(
name|DM
parameter_list|)
define|\
value|(peek_char (DM) == '\0' ? '\0' : (*((DM)->next + 1)))
end_define

begin_comment
comment|/* Returns the character at the current position, and advances the    current position to the next character.  */
end_comment

begin_define
define|#
directive|define
name|next_char
parameter_list|(
name|DM
parameter_list|)
value|(*((DM)->next)++)
end_define

begin_comment
comment|/* Returns non-zero if the current position is the end of the mangled    name, i.e. one past the last character.  */
end_comment

begin_define
define|#
directive|define
name|end_of_name_p
parameter_list|(
name|DM
parameter_list|)
value|(peek_char (DM) == '\0')
end_define

begin_comment
comment|/* Advances the current position by one character.  */
end_comment

begin_define
define|#
directive|define
name|advance_char
parameter_list|(
name|DM
parameter_list|)
value|(++(DM)->next)
end_define

begin_comment
comment|/* Returns the string containing the current demangled result.  */
end_comment

begin_define
define|#
directive|define
name|result_string
parameter_list|(
name|DM
parameter_list|)
value|(&(DM)->result->string)
end_define

begin_comment
comment|/* Returns the position at which new text is inserted into the    demangled result.  */
end_comment

begin_define
define|#
directive|define
name|result_caret_pos
parameter_list|(
name|DM
parameter_list|)
define|\
value|(result_length (DM) +                                                 \    ((string_list_t) result_string (DM))->caret_position)
end_define

begin_comment
comment|/* Adds a dyn_string_t to the demangled result.  */
end_comment

begin_define
define|#
directive|define
name|result_add_string
parameter_list|(
name|DM
parameter_list|,
name|STRING
parameter_list|)
define|\
value|(dyn_string_insert (&(DM)->result->string,                            \ 		      result_caret_pos (DM), (STRING))                  \    ? STATUS_OK : STATUS_ALLOCATION_FAILED)
end_define

begin_comment
comment|/* Adds NUL-terminated string CSTR to the demangled result.    */
end_comment

begin_define
define|#
directive|define
name|result_add
parameter_list|(
name|DM
parameter_list|,
name|CSTR
parameter_list|)
define|\
value|(dyn_string_insert_cstr (&(DM)->result->string,                       \ 			   result_caret_pos (DM), (CSTR))               \    ? STATUS_OK : STATUS_ALLOCATION_FAILED)
end_define

begin_comment
comment|/* Adds character CHAR to the demangled result.  */
end_comment

begin_define
define|#
directive|define
name|result_add_char
parameter_list|(
name|DM
parameter_list|,
name|CHAR
parameter_list|)
define|\
value|(dyn_string_insert_char (&(DM)->result->string,                       \ 			   result_caret_pos (DM), (CHAR))               \    ? STATUS_OK : STATUS_ALLOCATION_FAILED)
end_define

begin_comment
comment|/* Inserts a dyn_string_t to the demangled result at position POS.  */
end_comment

begin_define
define|#
directive|define
name|result_insert_string
parameter_list|(
name|DM
parameter_list|,
name|POS
parameter_list|,
name|STRING
parameter_list|)
define|\
value|(dyn_string_insert (&(DM)->result->string, (POS), (STRING))           \    ? STATUS_OK : STATUS_ALLOCATION_FAILED)
end_define

begin_comment
comment|/* Inserts NUL-terminated string CSTR to the demangled result at    position POS.  */
end_comment

begin_define
define|#
directive|define
name|result_insert
parameter_list|(
name|DM
parameter_list|,
name|POS
parameter_list|,
name|CSTR
parameter_list|)
define|\
value|(dyn_string_insert_cstr (&(DM)->result->string, (POS), (CSTR))        \    ? STATUS_OK : STATUS_ALLOCATION_FAILED)
end_define

begin_comment
comment|/* Inserts character CHAR to the demangled result at position POS.  */
end_comment

begin_define
define|#
directive|define
name|result_insert_char
parameter_list|(
name|DM
parameter_list|,
name|POS
parameter_list|,
name|CHAR
parameter_list|)
define|\
value|(dyn_string_insert_char (&(DM)->result->string, (POS), (CHAR))        \    ? STATUS_OK : STATUS_ALLOCATION_FAILED)
end_define

begin_comment
comment|/* The length of the current demangled result.  */
end_comment

begin_define
define|#
directive|define
name|result_length
parameter_list|(
name|DM
parameter_list|)
define|\
value|dyn_string_length (&(DM)->result->string)
end_define

begin_comment
comment|/* Appends a (less-than, greater-than) character to the result in DM    to (open, close) a template argument or parameter list.  Appends a    space first if necessary to prevent spurious elision of angle    brackets with the previous character.  */
end_comment

begin_define
define|#
directive|define
name|result_open_template_list
parameter_list|(
name|DM
parameter_list|)
value|result_add_separated_char(DM, '<')
end_define

begin_define
define|#
directive|define
name|result_close_template_list
parameter_list|(
name|DM
parameter_list|)
value|result_add_separated_char(DM, '>')
end_define

begin_comment
comment|/* Appends a base 10 representation of VALUE to DS.  STATUS_OK on    success.  On failure, deletes DS and returns an error code.  */
end_comment

begin_function
specifier|static
name|status_t
name|int_to_dyn_string
parameter_list|(
name|value
parameter_list|,
name|ds
parameter_list|)
name|int
name|value
decl_stmt|;
name|dyn_string_t
name|ds
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|mask
init|=
literal|1
decl_stmt|;
comment|/* Handle zero up front.  */
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|dyn_string_append_char
argument_list|(
name|ds
argument_list|,
literal|'0'
argument_list|)
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
return|return
name|STATUS_OK
return|;
block|}
comment|/* For negative numbers, emit a minus sign.  */
if|if
condition|(
name|value
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|dyn_string_append_char
argument_list|(
name|ds
argument_list|,
literal|'-'
argument_list|)
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
name|value
operator|=
operator|-
name|value
expr_stmt|;
block|}
comment|/* Find the power of 10 of the first digit.  */
name|i
operator|=
name|value
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|9
condition|)
block|{
name|mask
operator|*=
literal|10
expr_stmt|;
name|i
operator|/=
literal|10
expr_stmt|;
block|}
comment|/* Write the digits.  */
while|while
condition|(
name|mask
operator|>
literal|0
condition|)
block|{
name|int
name|digit
init|=
name|value
operator|/
name|mask
decl_stmt|;
if|if
condition|(
operator|!
name|dyn_string_append_char
argument_list|(
name|ds
argument_list|,
literal|'0'
operator|+
name|digit
argument_list|)
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
name|value
operator|-=
name|digit
operator|*
name|mask
expr_stmt|;
name|mask
operator|/=
literal|10
expr_stmt|;
block|}
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Creates a new string list node.  The contents of the string are    empty, but the initial buffer allocation is LENGTH.  The string    list node should be deleted with string_list_delete.  Returns NULL    if allocation fails.  */
end_comment

begin_function
specifier|static
name|string_list_t
name|string_list_new
parameter_list|(
name|length
parameter_list|)
name|int
name|length
decl_stmt|;
block|{
name|string_list_t
name|s
init|=
operator|(
name|string_list_t
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|string_list_def
argument_list|)
argument_list|)
decl_stmt|;
name|s
operator|->
name|caret_position
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|dyn_string_init
argument_list|(
operator|(
name|dyn_string_t
operator|)
name|s
argument_list|,
name|length
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Deletes the entire string list starting at NODE.  */
end_comment

begin_function
specifier|static
name|void
name|string_list_delete
parameter_list|(
name|node
parameter_list|)
name|string_list_t
name|node
decl_stmt|;
block|{
while|while
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|string_list_t
name|next
init|=
name|node
operator|->
name|next
decl_stmt|;
name|dyn_string_delete
argument_list|(
operator|(
name|dyn_string_t
operator|)
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Appends CHARACTER to the demangled result.  If the current trailing    character of the result is CHARACTER, a space is inserted first.  */
end_comment

begin_function
specifier|static
name|status_t
name|result_add_separated_char
parameter_list|(
name|dm
parameter_list|,
name|character
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
name|int
name|character
decl_stmt|;
block|{
name|char
modifier|*
name|result
init|=
name|dyn_string_buf
argument_list|(
name|result_string
argument_list|(
name|dm
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|caret_pos
init|=
name|result_caret_pos
argument_list|(
name|dm
argument_list|)
decl_stmt|;
comment|/* Add a space if the last character is already the character we      want to add.  */
if|if
condition|(
name|caret_pos
operator|>
literal|0
operator|&&
name|result
index|[
name|caret_pos
operator|-
literal|1
index|]
operator|==
name|character
condition|)
name|RETURN_IF_ERROR
argument_list|(
name|result_add_char
argument_list|(
name|dm
argument_list|,
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add the character.  */
name|RETURN_IF_ERROR
argument_list|(
name|result_add_char
argument_list|(
name|dm
argument_list|,
name|character
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Allocates and pushes a new string onto the demangled results stack    for DM.  Subsequent demangling with DM will emit to the new string.    Returns STATUS_OK on success, STATUS_ALLOCATION_FAILED on    allocation failure.  */
end_comment

begin_function
specifier|static
name|status_t
name|result_push
parameter_list|(
name|dm
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
block|{
name|string_list_t
name|new_string
init|=
name|string_list_new
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_string
operator|==
name|NULL
condition|)
comment|/* Allocation failed.  */
return|return
name|STATUS_ALLOCATION_FAILED
return|;
comment|/* Link the new string to the front of the list of result strings.  */
name|new_string
operator|->
name|next
operator|=
operator|(
name|string_list_t
operator|)
name|dm
operator|->
name|result
expr_stmt|;
name|dm
operator|->
name|result
operator|=
name|new_string
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Removes and returns the topmost element on the demangled results    stack for DM.  The caller assumes ownership for the returned    string.  */
end_comment

begin_function
specifier|static
name|string_list_t
name|result_pop
parameter_list|(
name|dm
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
block|{
name|string_list_t
name|top
init|=
name|dm
operator|->
name|result
decl_stmt|;
name|dm
operator|->
name|result
operator|=
name|top
operator|->
name|next
expr_stmt|;
return|return
name|top
return|;
block|}
end_function

begin_comment
comment|/* Returns the current value of the caret for the result string.  The    value is an offet from the end of the result string.  */
end_comment

begin_function
specifier|static
name|int
name|result_get_caret
parameter_list|(
name|dm
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|string_list_t
operator|)
name|result_string
argument_list|(
name|dm
argument_list|)
operator|)
operator|->
name|caret_position
return|;
block|}
end_function

begin_comment
comment|/* Sets the value of the caret for the result string, counted as an    offet from the end of the result string.  */
end_comment

begin_function
specifier|static
name|void
name|result_set_caret
parameter_list|(
name|dm
parameter_list|,
name|position
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
name|int
name|position
decl_stmt|;
block|{
operator|(
operator|(
name|string_list_t
operator|)
name|result_string
argument_list|(
name|dm
argument_list|)
operator|)
operator|->
name|caret_position
operator|=
name|position
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Shifts the position of the next addition to the result by    POSITION_OFFSET.  A negative value shifts the caret to the left.  */
end_comment

begin_function
specifier|static
name|void
name|result_shift_caret
parameter_list|(
name|dm
parameter_list|,
name|position_offset
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
name|int
name|position_offset
decl_stmt|;
block|{
operator|(
operator|(
name|string_list_t
operator|)
name|result_string
argument_list|(
name|dm
argument_list|)
operator|)
operator|->
name|caret_position
operator|+=
name|position_offset
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if the character that comes right before the place    where text will be added to the result is a space.  In this case,    the caller should supress adding another space.  */
end_comment

begin_function
specifier|static
name|int
name|result_previous_char_is_space
parameter_list|(
name|dm
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
block|{
name|char
modifier|*
name|result
init|=
name|dyn_string_buf
argument_list|(
name|result_string
argument_list|(
name|dm
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|result_caret_pos
argument_list|(
name|dm
argument_list|)
decl_stmt|;
return|return
name|pos
operator|>
literal|0
operator|&&
name|result
index|[
name|pos
operator|-
literal|1
index|]
operator|==
literal|' '
return|;
block|}
end_function

begin_comment
comment|/* Returns the start position of a fragment of the demangled result    that will be a substitution candidate.  Should be called at the    start of productions that can add substitutions.  */
end_comment

begin_function
specifier|static
name|int
name|substitution_start
parameter_list|(
name|dm
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
block|{
return|return
name|result_caret_pos
argument_list|(
name|dm
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Adds the suffix of the current demangled result of DM starting at    START_POSITION as a potential substitution.  If TEMPLATE_P is    non-zero, this potential substitution is a template-id.  */
end_comment

begin_function
specifier|static
name|status_t
name|substitution_add
parameter_list|(
name|dm
parameter_list|,
name|start_position
parameter_list|,
name|template_p
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
name|int
name|start_position
decl_stmt|;
name|int
name|template_p
decl_stmt|;
block|{
name|dyn_string_t
name|result
init|=
name|result_string
argument_list|(
name|dm
argument_list|)
decl_stmt|;
name|dyn_string_t
name|substitution
init|=
name|dyn_string_new
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|substitution
operator|==
name|NULL
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
comment|/* Extract the substring of the current demangling result that      represents the subsitution candidate.  */
if|if
condition|(
operator|!
name|dyn_string_substring
argument_list|(
name|substitution
argument_list|,
name|result
argument_list|,
name|start_position
argument_list|,
name|result_caret_pos
argument_list|(
name|dm
argument_list|)
argument_list|)
condition|)
block|{
name|dyn_string_delete
argument_list|(
name|substitution
argument_list|)
expr_stmt|;
return|return
name|STATUS_ALLOCATION_FAILED
return|;
block|}
comment|/* If there's no room for the new entry, grow the array.  */
if|if
condition|(
name|dm
operator|->
name|substitutions_allocated
operator|==
name|dm
operator|->
name|num_substitutions
condition|)
block|{
name|size_t
name|new_array_size
decl_stmt|;
if|if
condition|(
name|dm
operator|->
name|substitutions_allocated
operator|>
literal|0
condition|)
name|dm
operator|->
name|substitutions_allocated
operator|*=
literal|2
expr_stmt|;
else|else
name|dm
operator|->
name|substitutions_allocated
operator|=
literal|2
expr_stmt|;
name|new_array_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|substitution_def
argument_list|)
operator|*
name|dm
operator|->
name|substitutions_allocated
expr_stmt|;
name|dm
operator|->
name|substitutions
operator|=
operator|(
expr|struct
name|substitution_def
operator|*
operator|)
name|realloc
argument_list|(
name|dm
operator|->
name|substitutions
argument_list|,
name|new_array_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|dm
operator|->
name|substitutions
operator|==
name|NULL
condition|)
comment|/* Realloc failed.  */
block|{
name|dyn_string_delete
argument_list|(
name|substitution
argument_list|)
expr_stmt|;
return|return
name|STATUS_ALLOCATION_FAILED
return|;
block|}
block|}
comment|/* Add the substitution to the array.  */
name|i
operator|=
name|dm
operator|->
name|num_substitutions
operator|++
expr_stmt|;
name|dm
operator|->
name|substitutions
index|[
name|i
index|]
operator|.
name|text
operator|=
name|substitution
expr_stmt|;
name|dm
operator|->
name|substitutions
index|[
name|i
index|]
operator|.
name|template_p
operator|=
name|template_p
expr_stmt|;
ifdef|#
directive|ifdef
name|CP_DEMANGLE_DEBUG
name|substitutions_print
argument_list|(
name|dm
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Returns the Nth-most-recent substitution.  Sets *TEMPLATE_P to    non-zero if the substitution is a template-id, zero otherwise.      N is numbered from zero.  DM retains ownership of the returned    string.  If N is negative, or equal to or greater than the current    number of substitution candidates, returns NULL.  */
end_comment

begin_function
specifier|static
name|dyn_string_t
name|substitution_get
parameter_list|(
name|dm
parameter_list|,
name|n
parameter_list|,
name|template_p
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
modifier|*
name|template_p
decl_stmt|;
block|{
name|struct
name|substitution_def
modifier|*
name|sub
decl_stmt|;
comment|/* Make sure N is in the valid range.  */
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>=
name|dm
operator|->
name|num_substitutions
condition|)
return|return
name|NULL
return|;
name|sub
operator|=
operator|&
operator|(
name|dm
operator|->
name|substitutions
index|[
name|n
index|]
operator|)
expr_stmt|;
operator|*
name|template_p
operator|=
name|sub
operator|->
name|template_p
expr_stmt|;
return|return
name|sub
operator|->
name|text
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CP_DEMANGLE_DEBUG
end_ifdef

begin_comment
comment|/* Debugging routine to print the current substitutions to FP.  */
end_comment

begin_function
specifier|static
name|void
name|substitutions_print
parameter_list|(
name|dm
parameter_list|,
name|fp
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|int
name|seq_id
decl_stmt|;
name|int
name|num
init|=
name|dm
operator|->
name|num_substitutions
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"SUBSTITUTIONS:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|seq_id
operator|=
operator|-
literal|1
init|;
name|seq_id
operator|<
name|num
operator|-
literal|1
condition|;
operator|++
name|seq_id
control|)
block|{
name|int
name|template_p
decl_stmt|;
name|dyn_string_t
name|text
init|=
name|substitution_get
argument_list|(
name|dm
argument_list|,
name|seq_id
operator|+
literal|1
argument_list|,
operator|&
name|template_p
argument_list|)
decl_stmt|;
if|if
condition|(
name|seq_id
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" S_ "
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" S%d_"
argument_list|,
name|seq_id
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %c: %s\n"
argument_list|,
name|template_p
condition|?
literal|'*'
else|:
literal|' '
argument_list|,
name|dyn_string_buf
argument_list|(
name|text
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CP_DEMANGLE_DEBUG */
end_comment

begin_comment
comment|/* Creates a new template argument list.  Returns NULL if allocation    fails.  */
end_comment

begin_function
specifier|static
name|template_arg_list_t
name|template_arg_list_new
parameter_list|()
block|{
name|template_arg_list_t
name|new_list
init|=
operator|(
name|template_arg_list_t
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|template_arg_list_def
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_list
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Initialize the new list to have no arguments.  */
name|new_list
operator|->
name|first_argument
operator|=
name|NULL
expr_stmt|;
name|new_list
operator|->
name|last_argument
operator|=
name|NULL
expr_stmt|;
comment|/* Return the new list.  */
return|return
name|new_list
return|;
block|}
end_function

begin_comment
comment|/* Deletes a template argument list and the template arguments it    contains.  */
end_comment

begin_function
specifier|static
name|void
name|template_arg_list_delete
parameter_list|(
name|list
parameter_list|)
name|template_arg_list_t
name|list
decl_stmt|;
block|{
comment|/* If there are any arguments on LIST, delete them.  */
if|if
condition|(
name|list
operator|->
name|first_argument
operator|!=
name|NULL
condition|)
name|string_list_delete
argument_list|(
name|list
operator|->
name|first_argument
argument_list|)
expr_stmt|;
comment|/* Delete LIST.  */
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adds ARG to the template argument list ARG_LIST.  */
end_comment

begin_function
specifier|static
name|void
name|template_arg_list_add_arg
parameter_list|(
name|arg_list
parameter_list|,
name|arg
parameter_list|)
name|template_arg_list_t
name|arg_list
decl_stmt|;
name|string_list_t
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg_list
operator|->
name|first_argument
operator|==
name|NULL
condition|)
comment|/* If there were no arguments before, ARG is the first one.  */
name|arg_list
operator|->
name|first_argument
operator|=
name|arg
expr_stmt|;
else|else
comment|/* Make ARG the last argument on the list.  */
name|arg_list
operator|->
name|last_argument
operator|->
name|next
operator|=
name|arg
expr_stmt|;
comment|/* Make ARG the last on the list.  */
name|arg_list
operator|->
name|last_argument
operator|=
name|arg
expr_stmt|;
name|arg
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the template arugment at position INDEX in template    argument list ARG_LIST.  */
end_comment

begin_function
specifier|static
name|string_list_t
name|template_arg_list_get_arg
parameter_list|(
name|arg_list
parameter_list|,
name|index
parameter_list|)
name|template_arg_list_t
name|arg_list
decl_stmt|;
name|int
name|index
decl_stmt|;
block|{
name|string_list_t
name|arg
init|=
name|arg_list
operator|->
name|first_argument
decl_stmt|;
comment|/* Scan down the list of arguments to find the one at position      INDEX.  */
while|while
condition|(
name|index
operator|--
condition|)
block|{
name|arg
operator|=
name|arg
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
comment|/* Ran out of arguments before INDEX hit zero.  That's an 	   error.  */
return|return
name|NULL
return|;
block|}
comment|/* Return the argument at position INDEX.  */
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* Pushes ARG_LIST onto the top of the template argument list stack.  */
end_comment

begin_function
specifier|static
name|void
name|push_template_arg_list
parameter_list|(
name|dm
parameter_list|,
name|arg_list
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
name|template_arg_list_t
name|arg_list
decl_stmt|;
block|{
name|arg_list
operator|->
name|next
operator|=
name|dm
operator|->
name|template_arg_lists
expr_stmt|;
name|dm
operator|->
name|template_arg_lists
operator|=
name|arg_list
expr_stmt|;
ifdef|#
directive|ifdef
name|CP_DEMANGLE_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" ** pushing template arg list\n"
argument_list|)
expr_stmt|;
name|template_arg_list_print
argument_list|(
name|arg_list
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Pops and deletes elements on the template argument list stack until    arg_list is the topmost element.  If arg_list is NULL, all elements    are popped and deleted.  */
end_comment

begin_function
specifier|static
name|void
name|pop_to_template_arg_list
parameter_list|(
name|dm
parameter_list|,
name|arg_list
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
name|template_arg_list_t
name|arg_list
decl_stmt|;
block|{
while|while
condition|(
name|dm
operator|->
name|template_arg_lists
operator|!=
name|arg_list
condition|)
block|{
name|template_arg_list_t
name|top
init|=
name|dm
operator|->
name|template_arg_lists
decl_stmt|;
comment|/* Disconnect the topmost element from the list.  */
name|dm
operator|->
name|template_arg_lists
operator|=
name|top
operator|->
name|next
expr_stmt|;
comment|/* Delete the popped element.  */
name|template_arg_list_delete
argument_list|(
name|top
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CP_DEMANGLE_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" ** removing template arg list\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CP_DEMANGLE_DEBUG
end_ifdef

begin_comment
comment|/* Prints the contents of ARG_LIST to FP.  */
end_comment

begin_function
specifier|static
name|void
name|template_arg_list_print
parameter_list|(
name|arg_list
parameter_list|,
name|fp
parameter_list|)
name|template_arg_list_t
name|arg_list
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|string_list_t
name|arg
decl_stmt|;
name|int
name|index
init|=
operator|-
literal|1
decl_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"TEMPLATE ARGUMENT LIST:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|arg_list
operator|->
name|first_argument
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|next
control|)
block|{
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" T_  : "
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" T%d_ : "
argument_list|,
name|index
argument_list|)
expr_stmt|;
operator|++
name|index
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|dyn_string_buf
argument_list|(
operator|(
name|dyn_string_t
operator|)
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CP_DEMANGLE_DEBUG */
end_comment

begin_comment
comment|/* Returns the topmost element on the stack of template argument    lists.  If there is no list of template arguments, returns NULL.  */
end_comment

begin_function
specifier|static
name|template_arg_list_t
name|current_template_arg_list
parameter_list|(
name|dm
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
block|{
return|return
name|dm
operator|->
name|template_arg_lists
return|;
block|}
end_function

begin_comment
comment|/* Allocates a demangling_t object for demangling mangled NAME.  A new    result must be pushed before the returned object can be used.    Returns NULL if allocation fails.  */
end_comment

begin_function
specifier|static
name|demangling_t
name|demangling_new
parameter_list|(
name|name
parameter_list|,
name|style
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|style
decl_stmt|;
block|{
name|demangling_t
name|dm
decl_stmt|;
name|dm
operator|=
operator|(
name|demangling_t
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|demangling_def
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dm
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|dm
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|dm
operator|->
name|next
operator|=
name|name
expr_stmt|;
name|dm
operator|->
name|result
operator|=
name|NULL
expr_stmt|;
name|dm
operator|->
name|num_substitutions
operator|=
literal|0
expr_stmt|;
name|dm
operator|->
name|substitutions_allocated
operator|=
literal|10
expr_stmt|;
name|dm
operator|->
name|template_arg_lists
operator|=
name|NULL
expr_stmt|;
name|dm
operator|->
name|last_source_name
operator|=
name|dyn_string_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dm
operator|->
name|last_source_name
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|dm
operator|->
name|substitutions
operator|=
operator|(
expr|struct
name|substitution_def
operator|*
operator|)
name|malloc
argument_list|(
name|dm
operator|->
name|substitutions_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|substitution_def
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dm
operator|->
name|substitutions
operator|==
name|NULL
condition|)
block|{
name|dyn_string_delete
argument_list|(
name|dm
operator|->
name|last_source_name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|dm
operator|->
name|style
operator|=
name|style
expr_stmt|;
name|dm
operator|->
name|is_constructor
operator|=
literal|0
expr_stmt|;
name|dm
operator|->
name|is_destructor
operator|=
literal|0
expr_stmt|;
return|return
name|dm
return|;
block|}
end_function

begin_comment
comment|/* Deallocates a demangling_t object and all memory associated with    it.  */
end_comment

begin_function
specifier|static
name|void
name|demangling_delete
parameter_list|(
name|dm
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|template_arg_list_t
name|arg_list
init|=
name|dm
operator|->
name|template_arg_lists
decl_stmt|;
comment|/* Delete the stack of template argument lists.  */
while|while
condition|(
name|arg_list
operator|!=
name|NULL
condition|)
block|{
name|template_arg_list_t
name|next
init|=
name|arg_list
operator|->
name|next
decl_stmt|;
name|template_arg_list_delete
argument_list|(
name|arg_list
argument_list|)
expr_stmt|;
name|arg_list
operator|=
name|next
expr_stmt|;
block|}
comment|/* Delete the list of substitutions.  */
for|for
control|(
name|i
operator|=
name|dm
operator|->
name|num_substitutions
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|dyn_string_delete
argument_list|(
name|dm
operator|->
name|substitutions
index|[
name|i
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dm
operator|->
name|substitutions
argument_list|)
expr_stmt|;
comment|/* Delete the demangled result.  */
name|string_list_delete
argument_list|(
name|dm
operator|->
name|result
argument_list|)
expr_stmt|;
comment|/* Delete the stored identifier name.  */
name|dyn_string_delete
argument_list|(
name|dm
operator|->
name|last_source_name
argument_list|)
expr_stmt|;
comment|/* Delete the context object itself.  */
name|free
argument_list|(
name|dm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* These functions demangle an alternative of the corresponding    production in the mangling spec.  The first argument of each is a    demangling context structure for the current demangling    operation.  Most emit demangled text directly to the topmost result    string on the result string stack in the demangling context    structure.  */
end_comment

begin_decl_stmt
specifier|static
name|status_t
name|demangle_char
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_mangled_name
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_encoding
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_name
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_nested_name
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_prefix
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_unqualified_name
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_source_name
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_number
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|,
name|int
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_number_literally
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|,
name|dyn_string_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_identifier
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|,
name|int
operator|,
name|dyn_string_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_operator_name
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_nv_offset
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_v_offset
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_call_offset
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_special_name
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_ctor_dtor_name
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_type_ptr
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|,
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_type
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_CV_qualifiers
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|,
name|dyn_string_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_builtin_type
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_function_type
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_bare_function_type
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_class_enum_type
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_array_type
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_template_param
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_template_args
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_literal
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_template_arg
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_expression
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_scope_expression
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_expr_primary
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_substitution
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_local_name
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|demangle_discriminator
name|PARAMS
argument_list|(
operator|(
name|demangling_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|cp_demangle
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|dyn_string_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|status_t
name|cp_demangle_type
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|dyn_string_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When passed to demangle_bare_function_type, indicates that the    function's return type is not encoded before its parameter types.  */
end_comment

begin_define
define|#
directive|define
name|BFT_NO_RETURN_TYPE
value|NULL
end_define

begin_comment
comment|/* Check that the next character is C.  If so, consume it.  If not,    return an error.  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_char
parameter_list|(
name|dm
parameter_list|,
name|c
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|error_message
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|peek_char
argument_list|(
name|dm
argument_list|)
operator|==
name|c
condition|)
block|{
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
else|else
block|{
if|if
condition|(
name|error_message
operator|==
name|NULL
condition|)
name|error_message
operator|=
name|strdup
argument_list|(
literal|"Expected ?"
argument_list|)
expr_stmt|;
name|error_message
index|[
literal|9
index|]
operator|=
name|c
expr_stmt|;
return|return
name|error_message
return|;
block|}
block|}
end_function

begin_comment
comment|/* Demangles and emits a<mangled-name>.<mangled-name>      ::= _Z<encoding>  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_mangled_name
parameter_list|(
name|dm
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
block|{
name|DEMANGLE_TRACE
argument_list|(
literal|"mangled-name"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_char
argument_list|(
name|dm
argument_list|,
literal|'_'
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_char
argument_list|(
name|dm
argument_list|,
literal|'Z'
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_encoding
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Demangles and emits an<encoding>.<encoding>		::=<function name><bare-function-type> 			::=<data name> 			::=<special-name>  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_encoding
parameter_list|(
name|dm
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
block|{
name|int
name|encode_return_type
decl_stmt|;
name|int
name|start_position
decl_stmt|;
name|template_arg_list_t
name|old_arg_list
init|=
name|current_template_arg_list
argument_list|(
name|dm
argument_list|)
decl_stmt|;
name|char
name|peek
init|=
name|peek_char
argument_list|(
name|dm
argument_list|)
decl_stmt|;
name|DEMANGLE_TRACE
argument_list|(
literal|"encoding"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
comment|/* Remember where the name starts.  If it turns out to be a template      function, we'll have to insert the return type here.  */
name|start_position
operator|=
name|result_caret_pos
argument_list|(
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek
operator|==
literal|'G'
operator|||
name|peek
operator|==
literal|'T'
condition|)
name|RETURN_IF_ERROR
argument_list|(
name|demangle_special_name
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Now demangle the name.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_name
argument_list|(
name|dm
argument_list|,
operator|&
name|encode_return_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there's anything left, the name was a function name, with 	 maybe its return type, and its parameter types, following.  */
if|if
condition|(
operator|!
name|end_of_name_p
argument_list|(
name|dm
argument_list|)
operator|&&
name|peek_char
argument_list|(
name|dm
argument_list|)
operator|!=
literal|'E'
condition|)
block|{
if|if
condition|(
name|encode_return_type
condition|)
comment|/* Template functions have their return type encoded.  The 	       return type should be inserted at start_position.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_bare_function_type
argument_list|(
name|dm
argument_list|,
operator|&
name|start_position
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Non-template functions don't have their return type 	       encoded.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_bare_function_type
argument_list|(
name|dm
argument_list|,
name|BFT_NO_RETURN_TYPE
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Pop off template argument lists that were built during the      mangling of this name, to restore the old template context.  */
name|pop_to_template_arg_list
argument_list|(
name|dm
argument_list|,
name|old_arg_list
argument_list|)
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Demangles and emits a<name>.<name>              ::=<unscoped-name>                         ::=<unscoped-template-name><template-args> 			::=<nested-name>                         ::=<local-name><unscoped-name>     ::=<unqualified-name> 			::= St<unqualified-name>   # ::std::<unscoped-template-name>                             ::=<unscoped-name>                         ::=<substitution>  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_name
parameter_list|(
name|dm
parameter_list|,
name|encode_return_type
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
name|int
modifier|*
name|encode_return_type
decl_stmt|;
block|{
name|int
name|start
init|=
name|substitution_start
argument_list|(
name|dm
argument_list|)
decl_stmt|;
name|char
name|peek
init|=
name|peek_char
argument_list|(
name|dm
argument_list|)
decl_stmt|;
name|int
name|is_std_substitution
init|=
literal|0
decl_stmt|;
comment|/* Generally, the return type is encoded if the function is a      template-id, and suppressed otherwise.  There are a few cases,      though, in which the return type is not encoded even for a      templated function.  In these cases, this flag is set.  */
name|int
name|suppress_return_type
init|=
literal|0
decl_stmt|;
name|DEMANGLE_TRACE
argument_list|(
literal|"name"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|peek
condition|)
block|{
case|case
literal|'N'
case|:
comment|/* This is a<nested-name>.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_nested_name
argument_list|(
name|dm
argument_list|,
name|encode_return_type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|RETURN_IF_ERROR
argument_list|(
name|demangle_local_name
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|encode_return_type
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* The `St' substitution allows a name nested in std:: to appear 	 without being enclosed in a nested name.  */
if|if
condition|(
name|peek_char_next
argument_list|(
name|dm
argument_list|)
operator|==
literal|'t'
condition|)
block|{
operator|(
name|void
operator|)
name|next_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|next_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"std::"
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_unqualified_name
argument_list|(
name|dm
argument_list|,
operator|&
name|suppress_return_type
argument_list|)
argument_list|)
expr_stmt|;
name|is_std_substitution
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|RETURN_IF_ERROR
argument_list|(
name|demangle_substitution
argument_list|(
name|dm
argument_list|,
name|encode_return_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check if a template argument list immediately follows. 	 If so, then we just demangled an<unqualified-template-name>.  */
if|if
condition|(
name|peek_char
argument_list|(
name|dm
argument_list|)
operator|==
literal|'I'
condition|)
block|{
comment|/* A template name of the form std::<unqualified-name> is a              substitution candidate.  */
if|if
condition|(
name|is_std_substitution
condition|)
name|RETURN_IF_ERROR
argument_list|(
name|substitution_add
argument_list|(
name|dm
argument_list|,
name|start
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Demangle the<template-args> here.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_template_args
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|encode_return_type
operator|=
operator|!
name|suppress_return_type
expr_stmt|;
block|}
else|else
operator|*
name|encode_return_type
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* This is an<unscoped-name> or<unscoped-template-name>.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_unqualified_name
argument_list|(
name|dm
argument_list|,
operator|&
name|suppress_return_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the<unqualified-name> is followed by template args, this 	 is an<unscoped-template-name>.  */
if|if
condition|(
name|peek_char
argument_list|(
name|dm
argument_list|)
operator|==
literal|'I'
condition|)
block|{
comment|/* Add a substitution for the unqualified template name.  */
name|RETURN_IF_ERROR
argument_list|(
name|substitution_add
argument_list|(
name|dm
argument_list|,
name|start
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_template_args
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|encode_return_type
operator|=
operator|!
name|suppress_return_type
expr_stmt|;
block|}
else|else
operator|*
name|encode_return_type
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Demangles and emits a<nested-name>.<nested-name>     ::= N [<CV-qualifiers>]<prefix><unqulified-name> E  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_nested_name
parameter_list|(
name|dm
parameter_list|,
name|encode_return_type
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
name|int
modifier|*
name|encode_return_type
decl_stmt|;
block|{
name|char
name|peek
decl_stmt|;
name|DEMANGLE_TRACE
argument_list|(
literal|"nested-name"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_char
argument_list|(
name|dm
argument_list|,
literal|'N'
argument_list|)
argument_list|)
expr_stmt|;
name|peek
operator|=
name|peek_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek
operator|==
literal|'r'
operator|||
name|peek
operator|==
literal|'V'
operator|||
name|peek
operator|==
literal|'K'
condition|)
block|{
name|dyn_string_t
name|cv_qualifiers
decl_stmt|;
name|status_t
name|status
decl_stmt|;
comment|/* Snarf up CV qualifiers.  */
name|cv_qualifiers
operator|=
name|dyn_string_new
argument_list|(
literal|24
argument_list|)
expr_stmt|;
if|if
condition|(
name|cv_qualifiers
operator|==
name|NULL
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
name|demangle_CV_qualifiers
argument_list|(
name|dm
argument_list|,
name|cv_qualifiers
argument_list|)
expr_stmt|;
comment|/* Emit them, preceded by a space.  */
name|status
operator|=
name|result_add_char
argument_list|(
name|dm
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
name|status
operator|=
name|result_add_string
argument_list|(
name|dm
argument_list|,
name|cv_qualifiers
argument_list|)
expr_stmt|;
comment|/* The CV qualifiers that occur in a<nested-name> will be 	 qualifiers for member functions.  These are placed at the end 	 of the function.  Therefore, shift the caret to the left by 	 the length of the qualifiers, so other text is inserted 	 before them and they stay at the end.  */
name|result_shift_caret
argument_list|(
name|dm
argument_list|,
operator|-
name|dyn_string_length
argument_list|(
name|cv_qualifiers
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Clean up.  */
name|dyn_string_delete
argument_list|(
name|cv_qualifiers
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
name|RETURN_IF_ERROR
argument_list|(
name|demangle_prefix
argument_list|(
name|dm
argument_list|,
name|encode_return_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No need to demangle the final<unqualified-name>; demangle_prefix      will handle it.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_char
argument_list|(
name|dm
argument_list|,
literal|'E'
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Demangles and emits a<prefix>.<prefix>            ::=<prefix><unqualified-name>                         ::=<template-prefix><template-args> 			::= # empty 			::=<substitution><template-prefix>   ::=<prefix>                         ::=<substitution>  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_prefix
parameter_list|(
name|dm
parameter_list|,
name|encode_return_type
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
name|int
modifier|*
name|encode_return_type
decl_stmt|;
block|{
name|int
name|start
init|=
name|substitution_start
argument_list|(
name|dm
argument_list|)
decl_stmt|;
name|int
name|nested
init|=
literal|0
decl_stmt|;
comment|/* ENCODE_RETURN_TYPE is updated as we decend the nesting chain.      After<template-args>, it is set to non-zero; after everything      else it is set to zero.  */
comment|/* Generally, the return type is encoded if the function is a      template-id, and suppressed otherwise.  There are a few cases,      though, in which the return type is not encoded even for a      templated function.  In these cases, this flag is set.  */
name|int
name|suppress_return_type
init|=
literal|0
decl_stmt|;
name|DEMANGLE_TRACE
argument_list|(
literal|"prefix"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
name|peek
decl_stmt|;
if|if
condition|(
name|end_of_name_p
argument_list|(
name|dm
argument_list|)
condition|)
return|return
literal|"Unexpected end of name in<compound-name>."
return|;
name|peek
operator|=
name|peek_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
comment|/* We'll initialize suppress_return_type to false, and set it to true 	 if we end up demangling a constructor name.  However, make 	 sure we're not actually about to demangle template arguments 	 -- if so, this is the<template-args> following a<template-prefix>, so we'll want the previous flag value 	 around.  */
if|if
condition|(
name|peek
operator|!=
literal|'I'
condition|)
name|suppress_return_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IS_DIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|peek
argument_list|)
operator|||
operator|(
name|peek
operator|>=
literal|'a'
operator|&&
name|peek
operator|<=
literal|'z'
operator|)
operator|||
name|peek
operator|==
literal|'C'
operator|||
name|peek
operator|==
literal|'D'
operator|||
name|peek
operator|==
literal|'S'
condition|)
block|{
comment|/* We have another level of scope qualification.  */
if|if
condition|(
name|nested
condition|)
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
name|NAMESPACE_SEPARATOR
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|nested
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|peek
operator|==
literal|'S'
condition|)
comment|/* The substitution determines whether this is a 	       template-id.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_substitution
argument_list|(
name|dm
argument_list|,
name|encode_return_type
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* It's just a name.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_unqualified_name
argument_list|(
name|dm
argument_list|,
operator|&
name|suppress_return_type
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|encode_return_type
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|peek
operator|==
literal|'Z'
condition|)
name|RETURN_IF_ERROR
argument_list|(
name|demangle_local_name
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|peek
operator|==
literal|'I'
condition|)
block|{
name|RETURN_IF_ERROR
argument_list|(
name|demangle_template_args
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now we want to indicate to the caller that we've 	     demangled template arguments, thus the prefix was a<template-prefix>.  That's so that the caller knows to 	     demangle the function's return type, if this turns out to 	     be a function name.  But, if it's a member template 	     constructor or a templated conversion operator, report it 	     as untemplated.  Those never get encoded return types.  */
operator|*
name|encode_return_type
operator|=
operator|!
name|suppress_return_type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peek
operator|==
literal|'E'
condition|)
comment|/* All done.  */
return|return
name|STATUS_OK
return|;
else|else
return|return
literal|"Unexpected character in<compound-name>."
return|;
if|if
condition|(
name|peek
operator|!=
literal|'S'
operator|&&
name|peek_char
argument_list|(
name|dm
argument_list|)
operator|!=
literal|'E'
condition|)
comment|/* Add a new substitution for the prefix thus far.  */
name|RETURN_IF_ERROR
argument_list|(
name|substitution_add
argument_list|(
name|dm
argument_list|,
name|start
argument_list|,
operator|*
name|encode_return_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Demangles and emits an<unqualified-name>.  If this<unqualified-name> is for a special function type that should never    have its return type encoded (particularly, a constructor or    conversion operator), *SUPPRESS_RETURN_TYPE is set to 1; otherwise,    it is set to zero.<unqualified-name>  ::=<operator-name> 			::=<special-name>   			::=<source-name>  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_unqualified_name
parameter_list|(
name|dm
parameter_list|,
name|suppress_return_type
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
name|int
modifier|*
name|suppress_return_type
decl_stmt|;
block|{
name|char
name|peek
init|=
name|peek_char
argument_list|(
name|dm
argument_list|)
decl_stmt|;
name|DEMANGLE_TRACE
argument_list|(
literal|"unqualified-name"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
comment|/* By default, don't force suppression of the return type (though      non-template functions still don't get a return type encoded).  */
operator|*
name|suppress_return_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IS_DIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|peek
argument_list|)
condition|)
name|RETURN_IF_ERROR
argument_list|(
name|demangle_source_name
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|peek
operator|>=
literal|'a'
operator|&&
name|peek
operator|<=
literal|'z'
condition|)
block|{
name|int
name|num_args
decl_stmt|;
comment|/* Conversion operators never have a return type encoded.  */
if|if
condition|(
name|peek
operator|==
literal|'c'
operator|&&
name|peek_char_next
argument_list|(
name|dm
argument_list|)
operator|==
literal|'v'
condition|)
operator|*
name|suppress_return_type
operator|=
literal|1
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_operator_name
argument_list|(
name|dm
argument_list|,
literal|0
argument_list|,
operator|&
name|num_args
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peek
operator|==
literal|'C'
operator|||
name|peek
operator|==
literal|'D'
condition|)
block|{
comment|/* Constructors never have a return type encoded.  */
if|if
condition|(
name|peek
operator|==
literal|'C'
condition|)
operator|*
name|suppress_return_type
operator|=
literal|1
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_ctor_dtor_name
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|"Unexpected character in<unqualified-name>."
return|;
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Demangles and emits<source-name>.<source-name> ::=<length number><identifier>  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_source_name
parameter_list|(
name|dm
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
block|{
name|int
name|length
decl_stmt|;
name|DEMANGLE_TRACE
argument_list|(
literal|"source-name"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
comment|/* Decode the length of the identifier.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_number
argument_list|(
name|dm
argument_list|,
operator|&
name|length
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
return|return
literal|"Zero length in<source-name>."
return|;
comment|/* Now the identifier itself.  It's placed into last_source_name,      where it can be used to build a constructor or destructor name.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_identifier
argument_list|(
name|dm
argument_list|,
name|length
argument_list|,
name|dm
operator|->
name|last_source_name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Emit it.  */
name|RETURN_IF_ERROR
argument_list|(
name|result_add_string
argument_list|(
name|dm
argument_list|,
name|dm
operator|->
name|last_source_name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Demangles a number, either a<number> or a<positive-number> at the    current position, consuming all consecutive digit characters.  Sets    *VALUE to the resulting numberand returns STATUS_OK.  The number is    interpreted as BASE, which must be either 10 or 36.  If IS_SIGNED    is non-zero, negative numbers -- prefixed with `n' -- are accepted.<number> ::= [n]<positive-number><positive-number> ::=<decimal integer>  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_number
parameter_list|(
name|dm
parameter_list|,
name|value
parameter_list|,
name|base
parameter_list|,
name|is_signed
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
name|int
modifier|*
name|value
decl_stmt|;
name|int
name|base
decl_stmt|;
name|int
name|is_signed
decl_stmt|;
block|{
name|dyn_string_t
name|number
init|=
name|dyn_string_new
argument_list|(
literal|10
argument_list|)
decl_stmt|;
name|DEMANGLE_TRACE
argument_list|(
literal|"number"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|number
operator|==
name|NULL
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
name|demangle_number_literally
argument_list|(
name|dm
argument_list|,
name|number
argument_list|,
name|base
argument_list|,
name|is_signed
argument_list|)
expr_stmt|;
operator|*
name|value
operator|=
name|strtol
argument_list|(
name|dyn_string_buf
argument_list|(
name|number
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|dyn_string_delete
argument_list|(
name|number
argument_list|)
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Demangles a number at the current position.  The digits (and minus    sign, if present) that make up the number are appended to STR.    Only base-BASE digits are accepted; BASE must be either 10 or 36.    If IS_SIGNED, negative numbers -- prefixed with `n' -- are    accepted.  Does not consume a trailing underscore or other    terminating character.  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_number_literally
parameter_list|(
name|dm
parameter_list|,
name|str
parameter_list|,
name|base
parameter_list|,
name|is_signed
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
name|dyn_string_t
name|str
decl_stmt|;
name|int
name|base
decl_stmt|;
name|int
name|is_signed
decl_stmt|;
block|{
name|DEMANGLE_TRACE
argument_list|(
literal|"number*"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|!=
literal|10
operator|&&
name|base
operator|!=
literal|36
condition|)
return|return
name|STATUS_INTERNAL_ERROR
return|;
comment|/* An `n' denotes a negative number.  */
if|if
condition|(
name|is_signed
operator|&&
name|peek_char
argument_list|(
name|dm
argument_list|)
operator|==
literal|'n'
condition|)
block|{
comment|/* Skip past the n.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
comment|/* The normal way to write a negative number is with a minus 	 sign.  */
if|if
condition|(
operator|!
name|dyn_string_append_char
argument_list|(
name|str
argument_list|,
literal|'-'
argument_list|)
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
block|}
comment|/* Loop until we hit a non-digit.  */
while|while
condition|(
literal|1
condition|)
block|{
name|char
name|peek
init|=
name|peek_char
argument_list|(
name|dm
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_DIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|peek
argument_list|)
operator|||
operator|(
name|base
operator|==
literal|36
operator|&&
name|peek
operator|>=
literal|'A'
operator|&&
name|peek
operator|<=
literal|'Z'
operator|)
condition|)
block|{
comment|/* Accumulate digits.  */
if|if
condition|(
operator|!
name|dyn_string_append_char
argument_list|(
name|str
argument_list|,
name|next_char
argument_list|(
name|dm
argument_list|)
argument_list|)
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
block|}
else|else
comment|/* Not a digit?  All done.  */
break|break;
block|}
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Demangles an identifier at the current position of LENGTH    characters and places it in IDENTIFIER.  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_identifier
parameter_list|(
name|dm
parameter_list|,
name|length
parameter_list|,
name|identifier
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
name|int
name|length
decl_stmt|;
name|dyn_string_t
name|identifier
decl_stmt|;
block|{
name|DEMANGLE_TRACE
argument_list|(
literal|"identifier"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
name|dyn_string_clear
argument_list|(
name|identifier
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dyn_string_resize
argument_list|(
name|identifier
argument_list|,
name|length
argument_list|)
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|end_of_name_p
argument_list|(
name|dm
argument_list|)
condition|)
return|return
literal|"Unexpected end of name in<identifier>."
return|;
if|if
condition|(
operator|!
name|dyn_string_append_char
argument_list|(
name|identifier
argument_list|,
name|next_char
argument_list|(
name|dm
argument_list|)
argument_list|)
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
block|}
comment|/* GCC encodes anonymous namespaces using a `_GLOBAL_[_.$]N.'      followed by the source file name and some random characters.      Unless we're in strict mode, decipher these names appropriately.  */
if|if
condition|(
operator|!
name|flag_strict
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|dyn_string_buf
argument_list|(
name|identifier
argument_list|)
decl_stmt|;
name|int
name|prefix_length
init|=
name|strlen
argument_list|(
name|ANONYMOUS_NAMESPACE_PREFIX
argument_list|)
decl_stmt|;
comment|/* Compare the first, fixed part.  */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|ANONYMOUS_NAMESPACE_PREFIX
argument_list|,
name|prefix_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|name
operator|+=
name|prefix_length
expr_stmt|;
comment|/* The next character might be a period, an underscore, or 	     dollar sign, depending on the target architecture's 	     assembler's capabilities.  After that comes an `N'.  */
if|if
condition|(
operator|(
operator|*
name|name
operator|==
literal|'.'
operator|||
operator|*
name|name
operator|==
literal|'_'
operator|||
operator|*
name|name
operator|==
literal|'$'
operator|)
operator|&&
operator|*
operator|(
name|name
operator|+
literal|1
operator|)
operator|==
literal|'N'
condition|)
comment|/* This looks like the anonymous namespace identifier. 	       Replace it with something comprehensible.  */
name|dyn_string_copy_cstr
argument_list|(
name|identifier
argument_list|,
literal|"(anonymous namespace)"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Demangles and emits an<operator-name>.  If SHORT_NAME is non-zero,    the short form is emitted; otherwise the full source form    (`operator +' etc.) is emitted.  *NUM_ARGS is set to the number of    operands that the operator takes.<operator-name>                   ::= nw        # new                              ::= na        # new[]                   ::= dl        # delete                           ::= da        # delete[]       		  ::= ps        # + (unary)                   ::= ng        # - (unary)                        ::= ad        #& (unary)                        ::= de        # * (unary)                        ::= co        # ~                                ::= pl        # +                                ::= mi        # -                                ::= ml        # *                                ::= dv        # /                                ::= rm        # %                                ::= an        #&                                ::= or        # |                                ::= eo        # ^                                ::= aS        # =                                ::= pL        # +=                               ::= mI        # -=                               ::= mL        # *=                               ::= dV        # /=                               ::= rM        # %=                               ::= aN        #&=                               ::= oR        # |=                               ::= eO        # ^=                               ::= ls        #<<                               ::= rs        #>>                               ::= lS        #<<=                              ::= rS        #>>=                              ::= eq        # ==                               ::= ne        # !=                               ::= lt        #<                                ::= gt        #>                                ::= le        #<=                               ::= ge        #>=                               ::= nt        # !                                ::= aa        #&&                               ::= oo        # ||                               ::= pp        # ++                               ::= mm        # --                               ::= cm        # ,                                ::= pm        # ->*                              ::= pt        # ->                               ::= cl        # ()                               ::= ix        # []                               ::= qu        # ?                   ::= sz        # sizeof                    ::= cv<type> # cast         		  ::= v [0-9]<source-name>  # vendor extended operator  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_operator_name
parameter_list|(
name|dm
parameter_list|,
name|short_name
parameter_list|,
name|num_args
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
name|int
name|short_name
decl_stmt|;
name|int
modifier|*
name|num_args
decl_stmt|;
block|{
struct|struct
name|operator_code
block|{
comment|/* The mangled code for this operator.  */
specifier|const
name|char
modifier|*
specifier|const
name|code
decl_stmt|;
comment|/* The source name of this operator.  */
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* The number of arguments this operator takes.  */
specifier|const
name|int
name|num_args
decl_stmt|;
block|}
struct|;
specifier|static
specifier|const
name|struct
name|operator_code
name|operators
index|[]
init|=
block|{
block|{
literal|"aN"
block|,
literal|"&="
block|,
literal|2
block|}
block|,
block|{
literal|"aS"
block|,
literal|"="
block|,
literal|2
block|}
block|,
block|{
literal|"aa"
block|,
literal|"&&"
block|,
literal|2
block|}
block|,
block|{
literal|"ad"
block|,
literal|"&"
block|,
literal|1
block|}
block|,
block|{
literal|"an"
block|,
literal|"&"
block|,
literal|2
block|}
block|,
block|{
literal|"cl"
block|,
literal|"()"
block|,
literal|0
block|}
block|,
block|{
literal|"cm"
block|,
literal|","
block|,
literal|2
block|}
block|,
block|{
literal|"co"
block|,
literal|"~"
block|,
literal|1
block|}
block|,
block|{
literal|"dV"
block|,
literal|"/="
block|,
literal|2
block|}
block|,
block|{
literal|"da"
block|,
literal|" delete[]"
block|,
literal|1
block|}
block|,
block|{
literal|"de"
block|,
literal|"*"
block|,
literal|1
block|}
block|,
block|{
literal|"dl"
block|,
literal|" delete"
block|,
literal|1
block|}
block|,
block|{
literal|"dv"
block|,
literal|"/"
block|,
literal|2
block|}
block|,
block|{
literal|"eO"
block|,
literal|"^="
block|,
literal|2
block|}
block|,
block|{
literal|"eo"
block|,
literal|"^"
block|,
literal|2
block|}
block|,
block|{
literal|"eq"
block|,
literal|"=="
block|,
literal|2
block|}
block|,
block|{
literal|"ge"
block|,
literal|">="
block|,
literal|2
block|}
block|,
block|{
literal|"gt"
block|,
literal|">"
block|,
literal|2
block|}
block|,
block|{
literal|"ix"
block|,
literal|"[]"
block|,
literal|2
block|}
block|,
block|{
literal|"lS"
block|,
literal|"<<="
block|,
literal|2
block|}
block|,
block|{
literal|"le"
block|,
literal|"<="
block|,
literal|2
block|}
block|,
block|{
literal|"ls"
block|,
literal|"<<"
block|,
literal|2
block|}
block|,
block|{
literal|"lt"
block|,
literal|"<"
block|,
literal|2
block|}
block|,
block|{
literal|"mI"
block|,
literal|"-="
block|,
literal|2
block|}
block|,
block|{
literal|"mL"
block|,
literal|"*="
block|,
literal|2
block|}
block|,
block|{
literal|"mi"
block|,
literal|"-"
block|,
literal|2
block|}
block|,
block|{
literal|"ml"
block|,
literal|"*"
block|,
literal|2
block|}
block|,
block|{
literal|"mm"
block|,
literal|"--"
block|,
literal|1
block|}
block|,
block|{
literal|"na"
block|,
literal|" new[]"
block|,
literal|1
block|}
block|,
block|{
literal|"ne"
block|,
literal|"!="
block|,
literal|2
block|}
block|,
block|{
literal|"ng"
block|,
literal|"-"
block|,
literal|1
block|}
block|,
block|{
literal|"nt"
block|,
literal|"!"
block|,
literal|1
block|}
block|,
block|{
literal|"nw"
block|,
literal|" new"
block|,
literal|1
block|}
block|,
block|{
literal|"oR"
block|,
literal|"|="
block|,
literal|2
block|}
block|,
block|{
literal|"oo"
block|,
literal|"||"
block|,
literal|2
block|}
block|,
block|{
literal|"or"
block|,
literal|"|"
block|,
literal|2
block|}
block|,
block|{
literal|"pL"
block|,
literal|"+="
block|,
literal|2
block|}
block|,
block|{
literal|"pl"
block|,
literal|"+"
block|,
literal|2
block|}
block|,
block|{
literal|"pm"
block|,
literal|"->*"
block|,
literal|2
block|}
block|,
block|{
literal|"pp"
block|,
literal|"++"
block|,
literal|1
block|}
block|,
block|{
literal|"ps"
block|,
literal|"+"
block|,
literal|1
block|}
block|,
block|{
literal|"pt"
block|,
literal|"->"
block|,
literal|2
block|}
block|,
block|{
literal|"qu"
block|,
literal|"?"
block|,
literal|3
block|}
block|,
block|{
literal|"rM"
block|,
literal|"%="
block|,
literal|2
block|}
block|,
block|{
literal|"rS"
block|,
literal|">>="
block|,
literal|2
block|}
block|,
block|{
literal|"rm"
block|,
literal|"%"
block|,
literal|2
block|}
block|,
block|{
literal|"rs"
block|,
literal|">>"
block|,
literal|2
block|}
block|,
block|{
literal|"sz"
block|,
literal|" sizeof"
block|,
literal|1
block|}
block|}
decl_stmt|;
specifier|const
name|int
name|num_operators
init|=
sizeof|sizeof
argument_list|(
name|operators
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|operator_code
argument_list|)
decl_stmt|;
name|int
name|c0
init|=
name|next_char
argument_list|(
name|dm
argument_list|)
decl_stmt|;
name|int
name|c1
init|=
name|next_char
argument_list|(
name|dm
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|operator_code
modifier|*
name|p1
init|=
name|operators
decl_stmt|;
specifier|const
name|struct
name|operator_code
modifier|*
name|p2
init|=
name|operators
operator|+
name|num_operators
decl_stmt|;
name|DEMANGLE_TRACE
argument_list|(
literal|"operator-name"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
comment|/* Is this a vendor-extended operator?  */
if|if
condition|(
name|c0
operator|==
literal|'v'
operator|&&
name|IS_DIGIT
argument_list|(
name|c1
argument_list|)
condition|)
block|{
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"operator "
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_source_name
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|num_args
operator|=
literal|0
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
comment|/* Is this a conversion operator?  */
if|if
condition|(
name|c0
operator|==
literal|'c'
operator|&&
name|c1
operator|==
literal|'v'
condition|)
block|{
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"operator "
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Demangle the converted-to type.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_type
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|num_args
operator|=
literal|0
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
comment|/* Perform a binary search for the operator code.  */
while|while
condition|(
literal|1
condition|)
block|{
specifier|const
name|struct
name|operator_code
modifier|*
name|p
init|=
name|p1
operator|+
operator|(
name|p2
operator|-
name|p1
operator|)
operator|/
literal|2
decl_stmt|;
name|char
name|match0
init|=
name|p
operator|->
name|code
index|[
literal|0
index|]
decl_stmt|;
name|char
name|match1
init|=
name|p
operator|->
name|code
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|c0
operator|==
name|match0
operator|&&
name|c1
operator|==
name|match1
condition|)
comment|/* Found it.  */
block|{
if|if
condition|(
operator|!
name|short_name
condition|)
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"operator"
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
name|p
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|num_args
operator|=
name|p
operator|->
name|num_args
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
if|if
condition|(
name|p
operator|==
name|p1
condition|)
comment|/* Couldn't find it.  */
return|return
literal|"Unknown code in<operator-name>."
return|;
comment|/* Try again.  */
if|if
condition|(
name|c0
operator|<
name|match0
operator|||
operator|(
name|c0
operator|==
name|match0
operator|&&
name|c1
operator|<
name|match1
operator|)
condition|)
name|p2
operator|=
name|p
expr_stmt|;
else|else
name|p1
operator|=
name|p
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Demangles and omits an<nv-offset>.<nv-offset> ::=<offset number>   # non-virtual base override  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_nv_offset
parameter_list|(
name|dm
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
block|{
name|dyn_string_t
name|number
decl_stmt|;
name|status_t
name|status
init|=
name|STATUS_OK
decl_stmt|;
name|DEMANGLE_TRACE
argument_list|(
literal|"h-offset"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
comment|/* Demangle the offset.  */
name|number
operator|=
name|dyn_string_new
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|number
operator|==
name|NULL
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
name|demangle_number_literally
argument_list|(
name|dm
argument_list|,
name|number
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Don't display the offset unless in verbose mode.  */
if|if
condition|(
name|flag_verbose
condition|)
block|{
name|status
operator|=
name|result_add
argument_list|(
name|dm
argument_list|,
literal|" [nv:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
name|status
operator|=
name|result_add_string
argument_list|(
name|dm
argument_list|,
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
name|status
operator|=
name|result_add_char
argument_list|(
name|dm
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up.  */
name|dyn_string_delete
argument_list|(
name|number
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|status
argument_list|)
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Demangles and emits a<v-offset>.<v-offset>  ::=<offset number> _<virtual offset number> 			# virtual base override, with vcall offset  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_v_offset
parameter_list|(
name|dm
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
block|{
name|dyn_string_t
name|number
decl_stmt|;
name|status_t
name|status
init|=
name|STATUS_OK
decl_stmt|;
name|DEMANGLE_TRACE
argument_list|(
literal|"v-offset"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
comment|/* Demangle the offset.  */
name|number
operator|=
name|dyn_string_new
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|number
operator|==
name|NULL
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
name|demangle_number_literally
argument_list|(
name|dm
argument_list|,
name|number
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Don't display the offset unless in verbose mode.  */
if|if
condition|(
name|flag_verbose
condition|)
block|{
name|status
operator|=
name|result_add
argument_list|(
name|dm
argument_list|,
literal|" [v:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
name|status
operator|=
name|result_add_string
argument_list|(
name|dm
argument_list|,
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
name|result_add_char
argument_list|(
name|dm
argument_list|,
literal|','
argument_list|)
expr_stmt|;
block|}
name|dyn_string_delete
argument_list|(
name|number
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|/* Demangle the separator.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_char
argument_list|(
name|dm
argument_list|,
literal|'_'
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Demangle the vcall offset.  */
name|number
operator|=
name|dyn_string_new
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|number
operator|==
name|NULL
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
name|demangle_number_literally
argument_list|(
name|dm
argument_list|,
name|number
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Don't display the vcall offset unless in verbose mode.  */
if|if
condition|(
name|flag_verbose
condition|)
block|{
name|status
operator|=
name|result_add_string
argument_list|(
name|dm
argument_list|,
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
name|status
operator|=
name|result_add_char
argument_list|(
name|dm
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
block|}
name|dyn_string_delete
argument_list|(
name|number
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|status
argument_list|)
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Demangles and emits a<call-offset>.<call-offset> ::= h<nv-offset> _ 		  ::= v<v-offset> _  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_call_offset
parameter_list|(
name|dm
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
block|{
name|DEMANGLE_TRACE
argument_list|(
literal|"call-offset"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|peek_char
argument_list|(
name|dm
argument_list|)
condition|)
block|{
case|case
literal|'h'
case|:
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
comment|/* Demangle the offset.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_nv_offset
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Demangle the separator.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_char
argument_list|(
name|dm
argument_list|,
literal|'_'
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
comment|/* Demangle the offset.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_v_offset
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Demangle the separator.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_char
argument_list|(
name|dm
argument_list|,
literal|'_'
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|"Unrecognized<call-offset>."
return|;
block|}
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Demangles and emits a<special-name>.<special-name> ::= GV<object name>   # Guard variable                    ::= TV<type>          # virtual table                    ::= TT<type>          # VTT                    ::= TI<type>          # typeinfo structure 		   ::= TS<type>          # typeinfo name       Other relevant productions include thunks:<special-name> ::= T<call-offset><base encoding>  			 # base is the nominal target function of thunk<special-name> ::= Tc<call-offset><call-offset><base encoding> 			 # base is the nominal target function of thunk 			 # first call-offset is 'this' adjustment 			 # second call-offset is result adjustment     where<call-offset>  ::= h<nv-offset> _ 		   ::= v<v-offset> _     Also demangles the special g++ manglings,<special-name> ::= TC<type><offset number> _<base type>                                           # construction vtable 		   ::= TF<type>	  # typeinfo function (old ABI only) 		   ::= TJ<type>	  # java Class structure  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_special_name
parameter_list|(
name|dm
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
block|{
name|dyn_string_t
name|number
decl_stmt|;
name|int
name|unused
decl_stmt|;
name|char
name|peek
init|=
name|peek_char
argument_list|(
name|dm
argument_list|)
decl_stmt|;
name|DEMANGLE_TRACE
argument_list|(
literal|"special-name"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek
operator|==
literal|'G'
condition|)
block|{
comment|/* Consume the G.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|peek_char
argument_list|(
name|dm
argument_list|)
condition|)
block|{
case|case
literal|'V'
case|:
comment|/* A guard variable name.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"guard variable for "
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_name
argument_list|(
name|dm
argument_list|,
operator|&
name|unused
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* A reference temporary.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"reference temporary for "
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_name
argument_list|(
name|dm
argument_list|,
operator|&
name|unused
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|"Unrecognized<special-name>."
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|peek
operator|==
literal|'T'
condition|)
block|{
name|status_t
name|status
init|=
name|STATUS_OK
decl_stmt|;
comment|/* Other C++ implementation miscellania.  Consume the T.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|peek_char
argument_list|(
name|dm
argument_list|)
condition|)
block|{
case|case
literal|'V'
case|:
comment|/* Virtual table.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"vtable for "
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_type
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* VTT structure.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"VTT for "
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_type
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* Typeinfo structure.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"typeinfo for "
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_type
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* Typeinfo function.  Used only in old ABI with new mangling.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"typeinfo fn for "
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_type
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Character string containing type name, used in typeinfo. */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"typeinfo name for "
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_type
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
comment|/* The java Class variable corresponding to a C++ class.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"java Class for "
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_type
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* Non-virtual thunk.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"non-virtual thunk"
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_nv_offset
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Demangle the separator.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_char
argument_list|(
name|dm
argument_list|,
literal|'_'
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Demangle and emit the target name and function type.  */
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|" to "
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_encoding
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* Virtual thunk.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"virtual thunk"
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_v_offset
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Demangle the separator.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_char
argument_list|(
name|dm
argument_list|,
literal|'_'
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Demangle and emit the target function.  */
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|" to "
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_encoding
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* Covariant return thunk.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"covariant return thunk"
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_call_offset
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_call_offset
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Demangle and emit the target function.  */
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|" to "
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_encoding
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* TC is a special g++ mangling for a construction vtable. */
if|if
condition|(
operator|!
name|flag_strict
condition|)
block|{
name|dyn_string_t
name|derived_type
decl_stmt|;
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"construction vtable for "
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Demangle the derived type off to the side.  */
name|RETURN_IF_ERROR
argument_list|(
name|result_push
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_type
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
name|derived_type
operator|=
operator|(
name|dyn_string_t
operator|)
name|result_pop
argument_list|(
name|dm
argument_list|)
expr_stmt|;
comment|/* Demangle the offset.  */
name|number
operator|=
name|dyn_string_new
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|number
operator|==
name|NULL
condition|)
block|{
name|dyn_string_delete
argument_list|(
name|derived_type
argument_list|)
expr_stmt|;
return|return
name|STATUS_ALLOCATION_FAILED
return|;
block|}
name|demangle_number_literally
argument_list|(
name|dm
argument_list|,
name|number
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Demangle the underscore separator.  */
name|status
operator|=
name|demangle_char
argument_list|(
name|dm
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
comment|/* Demangle the base type.  */
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
name|status
operator|=
name|demangle_type
argument_list|(
name|dm
argument_list|)
expr_stmt|;
comment|/* Emit the derived type.  */
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
name|status
operator|=
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"-in-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
name|status
operator|=
name|result_add_string
argument_list|(
name|dm
argument_list|,
name|derived_type
argument_list|)
expr_stmt|;
name|dyn_string_delete
argument_list|(
name|derived_type
argument_list|)
expr_stmt|;
comment|/* Don't display the offset unless in verbose mode.  */
if|if
condition|(
name|flag_verbose
condition|)
block|{
name|status
operator|=
name|result_add_char
argument_list|(
name|dm
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
name|result_add_string
argument_list|(
name|dm
argument_list|,
name|number
argument_list|)
expr_stmt|;
block|}
name|dyn_string_delete
argument_list|(
name|number
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|status
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If flag_strict, fall through.  */
default|default:
return|return
literal|"Unrecognized<special-name>."
return|;
block|}
block|}
else|else
return|return
name|STATUS_ERROR
return|;
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Demangles and emits a<ctor-dtor-name>.<ctor-dtor-name>                    ::= C1  # complete object (in-charge) ctor                    ::= C2  # base object (not-in-charge) ctor                    ::= C3  # complete object (in-charge) allocating ctor                    ::= D0  # deleting (in-charge) dtor                    ::= D1  # complete object (in-charge) dtor                    ::= D2  # base object (not-in-charge) dtor  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_ctor_dtor_name
parameter_list|(
name|dm
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ctor_flavors
index|[]
init|=
block|{
literal|"in-charge"
block|,
literal|"not-in-charge"
block|,
literal|"allocating"
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|dtor_flavors
index|[]
init|=
block|{
literal|"in-charge deleting"
block|,
literal|"in-charge"
block|,
literal|"not-in-charge"
block|}
decl_stmt|;
name|int
name|flavor
decl_stmt|;
name|char
name|peek
init|=
name|peek_char
argument_list|(
name|dm
argument_list|)
decl_stmt|;
name|DEMANGLE_TRACE
argument_list|(
literal|"ctor-dtor-name"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek
operator|==
literal|'C'
condition|)
block|{
comment|/* A constructor name.  Consume the C.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
name|flavor
operator|=
name|next_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|flavor
operator|<
literal|'1'
operator|||
name|flavor
operator|>
literal|'3'
condition|)
return|return
literal|"Unrecognized constructor."
return|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add_string
argument_list|(
name|dm
argument_list|,
name|dm
operator|->
name|last_source_name
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|flavor
condition|)
block|{
case|case
literal|'1'
case|:
name|dm
operator|->
name|is_constructor
operator|=
name|gnu_v3_complete_object_ctor
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|dm
operator|->
name|is_constructor
operator|=
name|gnu_v3_base_object_ctor
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
name|dm
operator|->
name|is_constructor
operator|=
name|gnu_v3_complete_object_allocating_ctor
expr_stmt|;
break|break;
block|}
comment|/* Print the flavor of the constructor if in verbose mode.  */
if|if
condition|(
name|flag_verbose
condition|)
block|{
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"["
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
name|ctor_flavors
index|[
name|flavor
operator|-
literal|'1'
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add_char
argument_list|(
name|dm
argument_list|,
literal|']'
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|peek
operator|==
literal|'D'
condition|)
block|{
comment|/* A destructor name.  Consume the D.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
name|flavor
operator|=
name|next_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|flavor
operator|<
literal|'0'
operator|||
name|flavor
operator|>
literal|'2'
condition|)
return|return
literal|"Unrecognized destructor."
return|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add_char
argument_list|(
name|dm
argument_list|,
literal|'~'
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add_string
argument_list|(
name|dm
argument_list|,
name|dm
operator|->
name|last_source_name
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|flavor
condition|)
block|{
case|case
literal|'0'
case|:
name|dm
operator|->
name|is_destructor
operator|=
name|gnu_v3_deleting_dtor
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|dm
operator|->
name|is_destructor
operator|=
name|gnu_v3_complete_object_dtor
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|dm
operator|->
name|is_destructor
operator|=
name|gnu_v3_base_object_dtor
expr_stmt|;
break|break;
block|}
comment|/* Print the flavor of the destructor if in verbose mode.  */
if|if
condition|(
name|flag_verbose
condition|)
block|{
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|" ["
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
name|dtor_flavors
index|[
name|flavor
operator|-
literal|'0'
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add_char
argument_list|(
name|dm
argument_list|,
literal|']'
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
return|return
name|STATUS_ERROR
return|;
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Handle pointer, reference, and pointer-to-member cases for    demangle_type.  All consecutive `P's, `R's, and 'M's are joined to    build a pointer/reference type.  We snarf all these, plus the    following<type>, all at once since we need to know whether we have    a pointer to data or pointer to function to construct the right    output syntax.  C++'s pointer syntax is hairy.       This function adds substitution candidates for every nested    pointer/reference type it processes, including the outermost, final    type, assuming the substitution starts at SUBSTITUTION_START in the    demangling result.  For example, if this function demangles    `PP3Foo', it will add a substitution for `Foo', `Foo*', and    `Foo**', in that order.     *INSERT_POS is a quantity used internally, when this function calls    itself recursively, to figure out where to insert pointer    punctuation on the way up.  On entry to this function, INSERT_POS    should point to a temporary value, but that value need not be    initialized.<type> ::= P<type>             ::= R<type>             ::=<pointer-to-member-type><pointer-to-member-type> ::= M</class/ type></member/ type>  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_type_ptr
parameter_list|(
name|dm
parameter_list|,
name|insert_pos
parameter_list|,
name|substitution_start
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
name|int
modifier|*
name|insert_pos
decl_stmt|;
name|int
name|substitution_start
decl_stmt|;
block|{
name|status_t
name|status
decl_stmt|;
name|int
name|is_substitution_candidate
init|=
literal|1
decl_stmt|;
name|DEMANGLE_TRACE
argument_list|(
literal|"type*"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
comment|/* Scan forward, collecting pointers and references into symbols,      until we hit something else.  Then emit the type.  */
switch|switch
condition|(
name|peek_char
argument_list|(
name|dm
argument_list|)
condition|)
block|{
case|case
literal|'P'
case|:
comment|/* A pointer.  Snarf the `P'.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
comment|/* Demangle the underlying type.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_type_ptr
argument_list|(
name|dm
argument_list|,
name|insert_pos
argument_list|,
name|substitution_start
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Insert an asterisk where we're told to; it doesn't 	 necessarily go at the end.  If we're doing Java style output,  	 there is no pointer symbol.  */
if|if
condition|(
name|dm
operator|->
name|style
operator|!=
name|DMGL_JAVA
condition|)
name|RETURN_IF_ERROR
argument_list|(
name|result_insert_char
argument_list|(
name|dm
argument_list|,
operator|*
name|insert_pos
argument_list|,
literal|'*'
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The next (outermost) pointer or reference character should go 	 after this one.  */
operator|++
operator|(
operator|*
name|insert_pos
operator|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* A reference.  Snarf the `R'.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
comment|/* Demangle the underlying type.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_type_ptr
argument_list|(
name|dm
argument_list|,
name|insert_pos
argument_list|,
name|substitution_start
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Insert an ampersand where we're told to; it doesn't 	 necessarily go at the end.  */
name|RETURN_IF_ERROR
argument_list|(
name|result_insert_char
argument_list|(
name|dm
argument_list|,
operator|*
name|insert_pos
argument_list|,
literal|'&'
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The next (outermost) pointer or reference character should go 	 after this one.  */
operator|++
operator|(
operator|*
name|insert_pos
operator|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
block|{
comment|/* A pointer-to-member.  */
name|dyn_string_t
name|class_type
decl_stmt|;
comment|/* Eat the 'M'.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
comment|/* Capture the type of which this is a pointer-to-member.  */
name|RETURN_IF_ERROR
argument_list|(
name|result_push
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_type
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
name|class_type
operator|=
operator|(
name|dyn_string_t
operator|)
name|result_pop
argument_list|(
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek_char
argument_list|(
name|dm
argument_list|)
operator|==
literal|'F'
condition|)
comment|/* A pointer-to-member function.  We want output along the 	   lines of `void (C::*) (int, int)'.  Demangle the function 	   type, which would in this case give `void () (int, int)' 	   and set *insert_pos to the spot between the first 	   parentheses.  */
name|status
operator|=
name|demangle_type_ptr
argument_list|(
name|dm
argument_list|,
name|insert_pos
argument_list|,
name|substitution_start
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|peek_char
argument_list|(
name|dm
argument_list|)
operator|==
literal|'A'
condition|)
comment|/* A pointer-to-member array variable.  We want output that 	   looks like `int (Klass::*) [10]'.  Demangle the array type 	   as `int () [10]', and set *insert_pos to the spot between 	   the parentheses.  */
name|status
operator|=
name|demangle_array_type
argument_list|(
name|dm
argument_list|,
name|insert_pos
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* A pointer-to-member variable.  Demangle the type of the              pointed-to member.  */
name|status
operator|=
name|demangle_type
argument_list|(
name|dm
argument_list|)
expr_stmt|;
comment|/* Make it pretty.  */
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
operator|&&
operator|!
name|result_previous_char_is_space
argument_list|(
name|dm
argument_list|)
condition|)
name|status
operator|=
name|result_add_char
argument_list|(
name|dm
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
comment|/* The pointer-to-member notation (e.g. `C::*') follows the              member's type.  */
operator|*
name|insert_pos
operator|=
name|result_caret_pos
argument_list|(
name|dm
argument_list|)
expr_stmt|;
block|}
comment|/* Build the pointer-to-member notation.  */
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
name|status
operator|=
name|result_insert
argument_list|(
name|dm
argument_list|,
operator|*
name|insert_pos
argument_list|,
literal|"::*"
argument_list|)
expr_stmt|;
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
name|status
operator|=
name|result_insert_string
argument_list|(
name|dm
argument_list|,
operator|*
name|insert_pos
argument_list|,
name|class_type
argument_list|)
expr_stmt|;
comment|/* There may be additional levels of (pointer or reference) 	 indirection in this type.  If so, the `*' and `&' should be 	 added after the pointer-to-member notation (e.g. `C::*&' for 	 a reference to a pointer-to-member of class C).  */
operator|*
name|insert_pos
operator|+=
name|dyn_string_length
argument_list|(
name|class_type
argument_list|)
operator|+
literal|3
expr_stmt|;
comment|/* Clean up. */
name|dyn_string_delete
argument_list|(
name|class_type
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'F'
case|:
comment|/* Ooh, tricky, a pointer-to-function.  When we demangle the 	 function type, the return type should go at the very 	 beginning.  */
operator|*
name|insert_pos
operator|=
name|result_caret_pos
argument_list|(
name|dm
argument_list|)
expr_stmt|;
comment|/* The parentheses indicate this is a function pointer or 	 reference type.  */
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"()"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now demangle the function type.  The return type will be 	 inserted before the `()', and the argument list will go after 	 it.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_function_type
argument_list|(
name|dm
argument_list|,
name|insert_pos
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We should now have something along the lines of  	 `void () (int, int)'.  The pointer or reference characters 	 have to inside the first set of parentheses.  *insert_pos has 	 already been updated to point past the end of the return 	 type.  Move it one character over so it points inside the 	 `()'.  */
operator|++
operator|(
operator|*
name|insert_pos
operator|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
comment|/* An array pointer or reference.  demangle_array_type will figure 	 out where the asterisks and ampersands go.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_array_type
argument_list|(
name|dm
argument_list|,
name|insert_pos
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* No more pointer or reference tokens; this is therefore a 	 pointer to data.  Finish up by demangling the underlying 	 type.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_type
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The pointer or reference characters follow the underlying 	 type, as in `int*&'.  */
operator|*
name|insert_pos
operator|=
name|result_caret_pos
argument_list|(
name|dm
argument_list|)
expr_stmt|;
comment|/* Because of the production<type> ::=<substitution>, 	 demangle_type will already have added the underlying type as 	 a substitution candidate.  Don't do it again.  */
name|is_substitution_candidate
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|is_substitution_candidate
condition|)
name|RETURN_IF_ERROR
argument_list|(
name|substitution_add
argument_list|(
name|dm
argument_list|,
name|substitution_start
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Demangles and emits a<type>.<type> ::=<builtin-type> 	   ::=<function-type> 	   ::=<class-enum-type> 	   ::=<array-type> 	   ::=<pointer-to-member-type> 	   ::=<template-param> 	   ::=<template-template-param><template-args>            ::=<CV-qualifiers><type> 	   ::= P<type>   # pointer-to 	   ::= R<type>   # reference-to 	   ::= C<type>   # complex pair (C 2000) 	   ::= G<type>   # imaginary (C 2000) 	   ::= U<source-name><type>     # vendor extended type qualifier 	   ::=<substitution>  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_type
parameter_list|(
name|dm
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
block|{
name|int
name|start
init|=
name|substitution_start
argument_list|(
name|dm
argument_list|)
decl_stmt|;
name|char
name|peek
init|=
name|peek_char
argument_list|(
name|dm
argument_list|)
decl_stmt|;
name|char
name|peek_next
decl_stmt|;
name|int
name|encode_return_type
init|=
literal|0
decl_stmt|;
name|template_arg_list_t
name|old_arg_list
init|=
name|current_template_arg_list
argument_list|(
name|dm
argument_list|)
decl_stmt|;
name|int
name|insert_pos
decl_stmt|;
comment|/* A<type> can be a<substitution>; therefore, this<type> is a      substitution candidate unless a special condition holds (see      below).  */
name|int
name|is_substitution_candidate
init|=
literal|1
decl_stmt|;
name|DEMANGLE_TRACE
argument_list|(
literal|"type"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
comment|/* A<class-enum-type> can start with a digit (a<source-name>), an      N (a<nested-name>), or a Z (a<local-name>).  */
if|if
condition|(
name|IS_DIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|peek
argument_list|)
operator|||
name|peek
operator|==
literal|'N'
operator|||
name|peek
operator|==
literal|'Z'
condition|)
name|RETURN_IF_ERROR
argument_list|(
name|demangle_class_enum_type
argument_list|(
name|dm
argument_list|,
operator|&
name|encode_return_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Lower-case letters begin<builtin-type>s, except for `r', which      denotes restrict.  */
elseif|else
if|if
condition|(
name|peek
operator|>=
literal|'a'
operator|&&
name|peek
operator|<=
literal|'z'
operator|&&
name|peek
operator|!=
literal|'r'
condition|)
block|{
name|RETURN_IF_ERROR
argument_list|(
name|demangle_builtin_type
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Built-in types are not substitution candidates.  */
name|is_substitution_candidate
operator|=
literal|0
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|peek
condition|)
block|{
case|case
literal|'r'
case|:
case|case
literal|'V'
case|:
case|case
literal|'K'
case|:
comment|/* CV-qualifiers (including restrict).  We have to demangle 	   them off to the side, since C++ syntax puts them in a funny 	   place for qualified pointer and reference types.  */
block|{
name|status_t
name|status
decl_stmt|;
name|dyn_string_t
name|cv_qualifiers
init|=
name|dyn_string_new
argument_list|(
literal|24
argument_list|)
decl_stmt|;
name|int
name|old_caret_position
init|=
name|result_get_caret
argument_list|(
name|dm
argument_list|)
decl_stmt|;
if|if
condition|(
name|cv_qualifiers
operator|==
name|NULL
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
comment|/* Decode all adjacent CV qualifiers.  */
name|demangle_CV_qualifiers
argument_list|(
name|dm
argument_list|,
name|cv_qualifiers
argument_list|)
expr_stmt|;
comment|/* Emit them, and shift the caret left so that the 	     underlying type will be emitted before the qualifiers.  */
name|status
operator|=
name|result_add_string
argument_list|(
name|dm
argument_list|,
name|cv_qualifiers
argument_list|)
expr_stmt|;
name|result_shift_caret
argument_list|(
name|dm
argument_list|,
operator|-
name|dyn_string_length
argument_list|(
name|cv_qualifiers
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Clean up.  */
name|dyn_string_delete
argument_list|(
name|cv_qualifiers
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|/* Also prepend a blank, if needed.  */
name|RETURN_IF_ERROR
argument_list|(
name|result_add_char
argument_list|(
name|dm
argument_list|,
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
name|result_shift_caret
argument_list|(
name|dm
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Demangle the underlying type.  It will be emitted before 	     the CV qualifiers, since we moved the caret.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_type
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Put the caret back where it was previously.  */
name|result_set_caret
argument_list|(
name|dm
argument_list|,
name|old_caret_position
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'F'
case|:
return|return
literal|"Non-pointer or -reference function type."
return|;
case|case
literal|'A'
case|:
name|RETURN_IF_ERROR
argument_list|(
name|demangle_array_type
argument_list|(
name|dm
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* It's either a<template-param> or a<template-template-param>.  In either case, demangle the 	   `T' token first.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_template_param
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for a template argument list; if one is found, it's a<template-template-param> ::=<template-param>                                        ::=<substitution>  */
if|if
condition|(
name|peek_char
argument_list|(
name|dm
argument_list|)
operator|==
literal|'I'
condition|)
block|{
comment|/* Add a substitution candidate.  The template parameter 	       `T' token is a substitution candidate by itself, 	       without the template argument list.  */
name|RETURN_IF_ERROR
argument_list|(
name|substitution_add
argument_list|(
name|dm
argument_list|,
name|start
argument_list|,
name|encode_return_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now demangle the template argument list.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_template_args
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The entire type, including the template template 	       parameter and its argument list, will be added as a 	       substitution candidate below.  */
block|}
break|break;
case|case
literal|'S'
case|:
comment|/* First check if this is a special substitution.  If it is, 	   this is a<class-enum-type>.  Special substitutions have a 	   letter following the `S'; other substitutions have a digit 	   or underscore.  */
name|peek_next
operator|=
name|peek_char_next
argument_list|(
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_DIGIT
argument_list|(
name|peek_next
argument_list|)
operator|||
name|peek_next
operator|==
literal|'_'
condition|)
block|{
name|RETURN_IF_ERROR
argument_list|(
name|demangle_substitution
argument_list|(
name|dm
argument_list|,
operator|&
name|encode_return_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The substituted name may have been a template name. 	       Check if template arguments follow, and if so, demangle 	       them.  */
if|if
condition|(
name|peek_char
argument_list|(
name|dm
argument_list|)
operator|==
literal|'I'
condition|)
name|RETURN_IF_ERROR
argument_list|(
name|demangle_template_args
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* A substitution token is not itself a substitution 		 candidate.  (However, if the substituted template is 		 instantiated, the resulting type is.)  */
name|is_substitution_candidate
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Now some trickiness.  We have a special substitution 	       here.  Often, the special substitution provides the 	       name of a template that's subsequently instantiated, 	       for instance `SaIcE' => std::allocator<char>.  In these 	       cases we need to add a substitution candidate for the 	       entire<class-enum-type> and thus don't want to clear 	       the is_substitution_candidate flag.  	       However, it's possible that what we have here is a 	       substitution token representing an entire type, such as 	       `Ss' => std::string.  In this case, we mustn't add a 	       new substitution candidate for this substitution token. 	       To detect this case, remember where the start of the 	       substitution token is.  */
specifier|const
name|char
modifier|*
name|next
init|=
name|dm
operator|->
name|next
decl_stmt|;
comment|/* Now demangle the<class-enum-type>.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_class_enum_type
argument_list|(
name|dm
argument_list|,
operator|&
name|encode_return_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If all that was just demangled is the two-character 	       special substitution token, supress the addition of a 	       new candidate for it.  */
if|if
condition|(
name|dm
operator|->
name|next
operator|==
name|next
operator|+
literal|2
condition|)
name|is_substitution_candidate
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'P'
case|:
case|case
literal|'R'
case|:
case|case
literal|'M'
case|:
name|RETURN_IF_ERROR
argument_list|(
name|demangle_type_ptr
argument_list|(
name|dm
argument_list|,
operator|&
name|insert_pos
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
comment|/* demangle_type_ptr adds all applicable substitution 	   candidates.  */
name|is_substitution_candidate
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* A C99 complex type.  */
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"complex "
argument_list|)
argument_list|)
expr_stmt|;
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_type
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
comment|/* A C99 imaginary type.  */
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"imaginary "
argument_list|)
argument_list|)
expr_stmt|;
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_type
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* Vendor-extended type qualifier.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_source_name
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add_char
argument_list|(
name|dm
argument_list|,
literal|' '
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_type
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|"Unexpected character in<type>."
return|;
block|}
if|if
condition|(
name|is_substitution_candidate
condition|)
comment|/* Add a new substitution for the type. If this type was a<template-param>, pass its index since from the point of        substitutions; a<template-param> token is a substitution        candidate distinct from the type that is substituted for it.  */
name|RETURN_IF_ERROR
argument_list|(
name|substitution_add
argument_list|(
name|dm
argument_list|,
name|start
argument_list|,
name|encode_return_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Pop off template argument lists added during mangling of this      type.  */
name|pop_to_template_arg_list
argument_list|(
name|dm
argument_list|,
name|old_arg_list
argument_list|)
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* C++ source names of builtin types, indexed by the mangled code    letter's position in the alphabet ('a' -> 0, 'b' -> 1, etc).  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|builtin_type_names
index|[
literal|26
index|]
init|=
block|{
literal|"signed char"
block|,
comment|/* a */
literal|"bool"
block|,
comment|/* b */
literal|"char"
block|,
comment|/* c */
literal|"double"
block|,
comment|/* d */
literal|"long double"
block|,
comment|/* e */
literal|"float"
block|,
comment|/* f */
literal|"__float128"
block|,
comment|/* g */
literal|"unsigned char"
block|,
comment|/* h */
literal|"int"
block|,
comment|/* i */
literal|"unsigned"
block|,
comment|/* j */
name|NULL
block|,
comment|/* k */
literal|"long"
block|,
comment|/* l */
literal|"unsigned long"
block|,
comment|/* m */
literal|"__int128"
block|,
comment|/* n */
literal|"unsigned __int128"
block|,
comment|/* o */
name|NULL
block|,
comment|/* p */
name|NULL
block|,
comment|/* q */
name|NULL
block|,
comment|/* r */
literal|"short"
block|,
comment|/* s */
literal|"unsigned short"
block|,
comment|/* t */
name|NULL
block|,
comment|/* u */
literal|"void"
block|,
comment|/* v */
literal|"wchar_t"
block|,
comment|/* w */
literal|"long long"
block|,
comment|/* x */
literal|"unsigned long long"
block|,
comment|/* y */
literal|"..."
comment|/* z */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Java source names of builtin types.  Types that arn't valid in Java    are also included here - we don't fail if someone attempts to demangle a     C++ symbol in Java style. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|java_builtin_type_names
index|[
literal|26
index|]
init|=
block|{
literal|"signed char"
block|,
comment|/* a */
literal|"boolean"
block|,
comment|/* C++ "bool" */
comment|/* b */
literal|"byte"
block|,
comment|/* C++ "char" */
comment|/* c */
literal|"double"
block|,
comment|/* d */
literal|"long double"
block|,
comment|/* e */
literal|"float"
block|,
comment|/* f */
literal|"__float128"
block|,
comment|/* g */
literal|"unsigned char"
block|,
comment|/* h */
literal|"int"
block|,
comment|/* i */
literal|"unsigned"
block|,
comment|/* j */
name|NULL
block|,
comment|/* k */
literal|"long"
block|,
comment|/* l */
literal|"unsigned long"
block|,
comment|/* m */
literal|"__int128"
block|,
comment|/* n */
literal|"unsigned __int128"
block|,
comment|/* o */
name|NULL
block|,
comment|/* p */
name|NULL
block|,
comment|/* q */
name|NULL
block|,
comment|/* r */
literal|"short"
block|,
comment|/* s */
literal|"unsigned short"
block|,
comment|/* t */
name|NULL
block|,
comment|/* u */
literal|"void"
block|,
comment|/* v */
literal|"char"
block|,
comment|/* C++ "wchar_t" */
comment|/* w */
literal|"long"
block|,
comment|/* C++ "long long" */
comment|/* x */
literal|"unsigned long long"
block|,
comment|/* y */
literal|"..."
comment|/* z */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Demangles and emits a<builtin-type>.<builtin-type> ::= v  # void 		   ::= w  # wchar_t 		   ::= b  # bool 		   ::= c  # char 		   ::= a  # signed char 		   ::= h  # unsigned char 		   ::= s  # short 		   ::= t  # unsigned short 		   ::= i  # int 		   ::= j  # unsigned int 		   ::= l  # long 		   ::= m  # unsigned long 		   ::= x  # long long, __int64 		   ::= y  # unsigned long long, __int64 		   ::= n  # __int128 		   ::= o  # unsigned __int128 		   ::= f  # float 		   ::= d  # double 		   ::= e  # long double, __float80 		   ::= g  # __float128 		   ::= z  # ellipsis 		   ::= u<source-name>    # vendor extended type  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_builtin_type
parameter_list|(
name|dm
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
block|{
name|char
name|code
init|=
name|peek_char
argument_list|(
name|dm
argument_list|)
decl_stmt|;
name|DEMANGLE_TRACE
argument_list|(
literal|"builtin-type"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|'u'
condition|)
block|{
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_source_name
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|>=
literal|'a'
operator|&&
name|code
operator|<=
literal|'z'
condition|)
block|{
specifier|const
name|char
modifier|*
name|type_name
decl_stmt|;
comment|/* Java uses different names for some built-in types. */
if|if
condition|(
name|dm
operator|->
name|style
operator|==
name|DMGL_JAVA
condition|)
name|type_name
operator|=
name|java_builtin_type_names
index|[
name|code
operator|-
literal|'a'
index|]
expr_stmt|;
else|else
name|type_name
operator|=
name|builtin_type_names
index|[
name|code
operator|-
literal|'a'
index|]
expr_stmt|;
if|if
condition|(
name|type_name
operator|==
name|NULL
condition|)
return|return
literal|"Unrecognized<builtin-type> code."
return|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
name|type_name
argument_list|)
argument_list|)
expr_stmt|;
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
else|else
return|return
literal|"Non-alphabetic<builtin-type> code."
return|;
block|}
end_function

begin_comment
comment|/* Demangles all consecutive CV-qualifiers (const, volatile, and    restrict) at the current position.  The qualifiers are appended to    QUALIFIERS.  Returns STATUS_OK.  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_CV_qualifiers
parameter_list|(
name|dm
parameter_list|,
name|qualifiers
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
name|dyn_string_t
name|qualifiers
decl_stmt|;
block|{
name|DEMANGLE_TRACE
argument_list|(
literal|"CV-qualifiers"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
name|peek_char
argument_list|(
name|dm
argument_list|)
condition|)
block|{
case|case
literal|'r'
case|:
if|if
condition|(
operator|!
name|dyn_string_append_space
argument_list|(
name|qualifiers
argument_list|)
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
if|if
condition|(
operator|!
name|dyn_string_append_cstr
argument_list|(
name|qualifiers
argument_list|,
literal|"restrict"
argument_list|)
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
break|break;
case|case
literal|'V'
case|:
if|if
condition|(
operator|!
name|dyn_string_append_space
argument_list|(
name|qualifiers
argument_list|)
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
if|if
condition|(
operator|!
name|dyn_string_append_cstr
argument_list|(
name|qualifiers
argument_list|,
literal|"volatile"
argument_list|)
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
break|break;
case|case
literal|'K'
case|:
if|if
condition|(
operator|!
name|dyn_string_append_space
argument_list|(
name|qualifiers
argument_list|)
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
if|if
condition|(
operator|!
name|dyn_string_append_cstr
argument_list|(
name|qualifiers
argument_list|,
literal|"const"
argument_list|)
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
break|break;
default|default:
return|return
name|STATUS_OK
return|;
block|}
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Demangles and emits a<function-type>.  *FUNCTION_NAME_POS is the    position in the result string of the start of the function    identifier, at which the function's return type will be inserted;    *FUNCTION_NAME_POS is updated to position past the end of the    function's return type.<function-type> ::= F [Y]<bare-function-type> E  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_function_type
parameter_list|(
name|dm
parameter_list|,
name|function_name_pos
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
name|int
modifier|*
name|function_name_pos
decl_stmt|;
block|{
name|DEMANGLE_TRACE
argument_list|(
literal|"function-type"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_char
argument_list|(
name|dm
argument_list|,
literal|'F'
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek_char
argument_list|(
name|dm
argument_list|)
operator|==
literal|'Y'
condition|)
block|{
comment|/* Indicate this function has C linkage if in verbose mode.  */
if|if
condition|(
name|flag_verbose
condition|)
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|" [extern \"C\"] "
argument_list|)
argument_list|)
expr_stmt|;
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
block|}
name|RETURN_IF_ERROR
argument_list|(
name|demangle_bare_function_type
argument_list|(
name|dm
argument_list|,
name|function_name_pos
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_char
argument_list|(
name|dm
argument_list|,
literal|'E'
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Demangles and emits a<bare-function-type>.  RETURN_TYPE_POS is the    position in the result string at which the function return type    should be inserted.  If RETURN_TYPE_POS is BFT_NO_RETURN_TYPE, the    function's return type is assumed not to be encoded.<bare-function-type> ::=<signature type>+  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_bare_function_type
parameter_list|(
name|dm
parameter_list|,
name|return_type_pos
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
name|int
modifier|*
name|return_type_pos
decl_stmt|;
block|{
comment|/* Sequence is the index of the current function parameter, counting      from zero.  The value -1 denotes the return type.  */
name|int
name|sequence
init|=
operator|(
name|return_type_pos
operator|==
name|BFT_NO_RETURN_TYPE
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
decl_stmt|;
name|DEMANGLE_TRACE
argument_list|(
literal|"bare-function-type"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add_char
argument_list|(
name|dm
argument_list|,
literal|'('
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|end_of_name_p
argument_list|(
name|dm
argument_list|)
operator|&&
name|peek_char
argument_list|(
name|dm
argument_list|)
operator|!=
literal|'E'
condition|)
block|{
if|if
condition|(
name|sequence
operator|==
operator|-
literal|1
condition|)
comment|/* We're decoding the function's return type.  */
block|{
name|dyn_string_t
name|return_type
decl_stmt|;
name|status_t
name|status
init|=
name|STATUS_OK
decl_stmt|;
comment|/* Decode the return type off to the side.  */
name|RETURN_IF_ERROR
argument_list|(
name|result_push
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_type
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
name|return_type
operator|=
operator|(
name|dyn_string_t
operator|)
name|result_pop
argument_list|(
name|dm
argument_list|)
expr_stmt|;
comment|/* Add a space to the end of the type.  Insert the return              type where we've been asked to. */
if|if
condition|(
operator|!
name|dyn_string_append_space
argument_list|(
name|return_type
argument_list|)
condition|)
name|status
operator|=
name|STATUS_ALLOCATION_FAILED
expr_stmt|;
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|dyn_string_insert
argument_list|(
name|result_string
argument_list|(
name|dm
argument_list|)
argument_list|,
operator|*
name|return_type_pos
argument_list|,
name|return_type
argument_list|)
condition|)
name|status
operator|=
name|STATUS_ALLOCATION_FAILED
expr_stmt|;
else|else
operator|*
name|return_type_pos
operator|+=
name|dyn_string_length
argument_list|(
name|return_type
argument_list|)
expr_stmt|;
block|}
name|dyn_string_delete
argument_list|(
name|return_type
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Skip `void' parameter types.  One should only occur as 	     the only type in a parameter list; in that case, we want 	     to print `foo ()' instead of `foo (void)'.  */
if|if
condition|(
name|peek_char
argument_list|(
name|dm
argument_list|)
operator|==
literal|'v'
condition|)
comment|/* Consume the v.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Separate parameter types by commas.  */
if|if
condition|(
name|sequence
operator|>
literal|0
condition|)
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|", "
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Demangle the type.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_type
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|sequence
expr_stmt|;
block|}
name|RETURN_IF_ERROR
argument_list|(
name|result_add_char
argument_list|(
name|dm
argument_list|,
literal|')'
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We should have demangled at least one parameter type (which would      be void, for a function that takes no parameters), plus the      return type, if we were supposed to demangle that.  */
if|if
condition|(
name|sequence
operator|==
operator|-
literal|1
condition|)
return|return
literal|"Missing function return type."
return|;
elseif|else
if|if
condition|(
name|sequence
operator|==
literal|0
condition|)
return|return
literal|"Missing function parameter."
return|;
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Demangles and emits a<class-enum-type>.  *ENCODE_RETURN_TYPE is set to    non-zero if the type is a template-id, zero otherwise.<class-enum-type> ::=<name>  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_class_enum_type
parameter_list|(
name|dm
parameter_list|,
name|encode_return_type
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
name|int
modifier|*
name|encode_return_type
decl_stmt|;
block|{
name|DEMANGLE_TRACE
argument_list|(
literal|"class-enum-type"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_name
argument_list|(
name|dm
argument_list|,
name|encode_return_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Demangles and emits an<array-type>.       If PTR_INSERT_POS is not NULL, the array type is formatted as a    pointer or reference to an array, except that asterisk and    ampersand punctuation is omitted (since it's not know at this    point).  *PTR_INSERT_POS is set to the position in the demangled    name at which this punctuation should be inserted.  For example,    `A10_i' is demangled to `int () [10]' and *PTR_INSERT_POS points    between the parentheses.     If PTR_INSERT_POS is NULL, the array type is assumed not to be    pointer- or reference-qualified.  Then, for example, `A10_i' is    demangled simply as `int[10]'.<array-type> ::= A [<dimension number>] _<element type>                    ::= A<dimension expression> _<element type>  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_array_type
parameter_list|(
name|dm
parameter_list|,
name|ptr_insert_pos
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
name|int
modifier|*
name|ptr_insert_pos
decl_stmt|;
block|{
name|status_t
name|status
init|=
name|STATUS_OK
decl_stmt|;
name|dyn_string_t
name|array_size
init|=
name|NULL
decl_stmt|;
name|char
name|peek
decl_stmt|;
name|DEMANGLE_TRACE
argument_list|(
literal|"array-type"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_char
argument_list|(
name|dm
argument_list|,
literal|'A'
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Demangle the array size into array_size.  */
name|peek
operator|=
name|peek_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek
operator|==
literal|'_'
condition|)
comment|/* Array bound is omitted.  This is a C99-style VLA.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|IS_DIGIT
argument_list|(
name|peek_char
argument_list|(
name|dm
argument_list|)
argument_list|)
condition|)
block|{
comment|/* It looks like a constant array bound.  */
name|array_size
operator|=
name|dyn_string_new
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|array_size
operator|==
name|NULL
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
name|status
operator|=
name|demangle_number_literally
argument_list|(
name|dm
argument_list|,
name|array_size
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Anything is must be an expression for a nont-constant array 	 bound.  This happens if the array type occurs in a template 	 and the array bound references a template parameter.  */
name|RETURN_IF_ERROR
argument_list|(
name|result_push
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_expression
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
name|array_size
operator|=
operator|(
name|dyn_string_t
operator|)
name|result_pop
argument_list|(
name|dm
argument_list|)
expr_stmt|;
block|}
comment|/* array_size may have been allocated by now, so we can't use      RETURN_IF_ERROR until it's been deallocated.  */
comment|/* Demangle the base type of the array.  */
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
name|status
operator|=
name|demangle_char
argument_list|(
name|dm
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
name|status
operator|=
name|demangle_type
argument_list|(
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr_insert_pos
operator|!=
name|NULL
condition|)
block|{
comment|/* This array is actually part of an pointer- or 	 reference-to-array type.  Format appropriately, except we 	 don't know which and how much punctuation to use.  */
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
name|status
operator|=
name|result_add
argument_list|(
name|dm
argument_list|,
literal|" () "
argument_list|)
expr_stmt|;
comment|/* Let the caller know where to insert the punctuation.  */
operator|*
name|ptr_insert_pos
operator|=
name|result_caret_pos
argument_list|(
name|dm
argument_list|)
operator|-
literal|2
expr_stmt|;
block|}
comment|/* Emit the array dimension syntax.  */
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
name|status
operator|=
name|result_add_char
argument_list|(
name|dm
argument_list|,
literal|'['
argument_list|)
expr_stmt|;
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
operator|&&
name|array_size
operator|!=
name|NULL
condition|)
name|status
operator|=
name|result_add_string
argument_list|(
name|dm
argument_list|,
name|array_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
name|status
operator|=
name|result_add_char
argument_list|(
name|dm
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|array_size
operator|!=
name|NULL
condition|)
name|dyn_string_delete
argument_list|(
name|array_size
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|status
argument_list|)
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Demangles and emits a<template-param>.<template-param> ::= T_       # first template parameter                      ::= T<parameter-2 number> _  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_template_param
parameter_list|(
name|dm
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
block|{
name|int
name|parm_number
decl_stmt|;
name|template_arg_list_t
name|current_arg_list
init|=
name|current_template_arg_list
argument_list|(
name|dm
argument_list|)
decl_stmt|;
name|string_list_t
name|arg
decl_stmt|;
name|DEMANGLE_TRACE
argument_list|(
literal|"template-param"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
comment|/* Make sure there is a template argmust list in which to look up      this parameter reference.  */
if|if
condition|(
name|current_arg_list
operator|==
name|NULL
condition|)
return|return
literal|"Template parameter outside of template."
return|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_char
argument_list|(
name|dm
argument_list|,
literal|'T'
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek_char
argument_list|(
name|dm
argument_list|)
operator|==
literal|'_'
condition|)
name|parm_number
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|RETURN_IF_ERROR
argument_list|(
name|demangle_number
argument_list|(
name|dm
argument_list|,
operator|&
name|parm_number
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|parm_number
expr_stmt|;
block|}
name|RETURN_IF_ERROR
argument_list|(
name|demangle_char
argument_list|(
name|dm
argument_list|,
literal|'_'
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|=
name|template_arg_list_get_arg
argument_list|(
name|current_arg_list
argument_list|,
name|parm_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
comment|/* parm_number exceeded the number of arguments in the current        template argument list.  */
return|return
literal|"Template parameter number out of bounds."
return|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add_string
argument_list|(
name|dm
argument_list|,
operator|(
name|dyn_string_t
operator|)
name|arg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Demangles and emits a<template-args>.<template-args> ::= I<template-arg>+ E  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_template_args
parameter_list|(
name|dm
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
block|{
name|int
name|first
init|=
literal|1
decl_stmt|;
name|dyn_string_t
name|old_last_source_name
decl_stmt|;
name|template_arg_list_t
name|arg_list
init|=
name|template_arg_list_new
argument_list|()
decl_stmt|;
if|if
condition|(
name|arg_list
operator|==
name|NULL
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
comment|/* Preserve the most recently demangled source name.  */
name|old_last_source_name
operator|=
name|dm
operator|->
name|last_source_name
expr_stmt|;
name|dm
operator|->
name|last_source_name
operator|=
name|dyn_string_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|DEMANGLE_TRACE
argument_list|(
literal|"template-args"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|dm
operator|->
name|last_source_name
operator|==
name|NULL
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_char
argument_list|(
name|dm
argument_list|,
literal|'I'
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_open_template_list
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|string_list_t
name|arg
decl_stmt|;
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|0
expr_stmt|;
else|else
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|", "
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Capture the template arg.  */
name|RETURN_IF_ERROR
argument_list|(
name|result_push
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_template_arg
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|=
name|result_pop
argument_list|(
name|dm
argument_list|)
expr_stmt|;
comment|/* Emit it in the demangled name.  */
name|RETURN_IF_ERROR
argument_list|(
name|result_add_string
argument_list|(
name|dm
argument_list|,
operator|(
name|dyn_string_t
operator|)
name|arg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Save it for use in expanding<template-param>s.  */
name|template_arg_list_add_arg
argument_list|(
name|arg_list
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|peek_char
argument_list|(
name|dm
argument_list|)
operator|!=
literal|'E'
condition|)
do|;
comment|/* Append the '>'.  */
name|RETURN_IF_ERROR
argument_list|(
name|result_close_template_list
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Consume the 'E'.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
comment|/* Restore the most recent demangled source name.  */
name|dyn_string_delete
argument_list|(
name|dm
operator|->
name|last_source_name
argument_list|)
expr_stmt|;
name|dm
operator|->
name|last_source_name
operator|=
name|old_last_source_name
expr_stmt|;
comment|/* Push the list onto the top of the stack of template argument      lists, so that arguments from it are used from now on when      expanding<template-param>s.  */
name|push_template_arg_list
argument_list|(
name|dm
argument_list|,
name|arg_list
argument_list|)
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* This function, which does not correspond to a production in the    mangling spec, handles the `literal' production for both<template-arg> and<expr-primary>.  It does not expect or consume    the initial `L' or final `E'.  The demangling is given by:<literal> ::=<type></value/ number>     and the emitted output is `(type)number'.  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_literal
parameter_list|(
name|dm
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
block|{
name|char
name|peek
init|=
name|peek_char
argument_list|(
name|dm
argument_list|)
decl_stmt|;
name|dyn_string_t
name|value_string
decl_stmt|;
name|status_t
name|status
decl_stmt|;
name|DEMANGLE_TRACE
argument_list|(
literal|"literal"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_verbose
operator|&&
name|peek
operator|>=
literal|'a'
operator|&&
name|peek
operator|<=
literal|'z'
condition|)
block|{
comment|/* If not in verbose mode and this is a builtin type, see if we 	 can produce simpler numerical output.  In particular, for 	 integer types shorter than `long', just write the number 	 without type information; for bools, write `true' or `false'. 	 Other refinements could be made here too.  */
comment|/* This constant string is used to map from<builtin-type> codes 	 (26 letters of the alphabet) to codes that determine how the  	 value will be displayed.  The codes are: 	   b: display as bool 	   i: display as int            l: display as long 	 A space means the value will be represented using cast 	 notation. */
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|code_map
init|=
literal|"ibi    iii ll     ii  i  "
decl_stmt|;
name|char
name|code
init|=
name|code_map
index|[
name|peek
operator|-
literal|'a'
index|]
decl_stmt|;
comment|/* FIXME: Implement demangling of floats and doubles.  */
if|if
condition|(
name|code
operator|==
literal|'u'
condition|)
return|return
name|STATUS_UNIMPLEMENTED
return|;
if|if
condition|(
name|code
operator|==
literal|'b'
condition|)
block|{
comment|/* It's a boolean.  */
name|char
name|value
decl_stmt|;
comment|/* Consume the b.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
comment|/* Look at the next character.  It should be 0 or 1, 	     corresponding to false or true, respectively.  */
name|value
operator|=
name|peek_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|'0'
condition|)
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"false"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|==
literal|'1'
condition|)
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"true"
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
literal|"Unrecognized bool constant."
return|;
comment|/* Consume the 0 or 1.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
literal|'i'
operator|||
name|code
operator|==
literal|'l'
condition|)
block|{
comment|/* It's an integer or long.  */
comment|/* Consume the type character.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
comment|/* Demangle the number and write it out.  */
name|value_string
operator|=
name|dyn_string_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|status
operator|=
name|demangle_number_literally
argument_list|(
name|dm
argument_list|,
name|value_string
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
name|status
operator|=
name|result_add_string
argument_list|(
name|dm
argument_list|,
name|value_string
argument_list|)
expr_stmt|;
comment|/* For long integers, append an l.  */
if|if
condition|(
name|code
operator|==
literal|'l'
operator|&&
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
name|status
operator|=
name|result_add_char
argument_list|(
name|dm
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|dyn_string_delete
argument_list|(
name|value_string
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|status
argument_list|)
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
comment|/* ...else code == ' ', so fall through to represent this 	 literal's type explicitly using cast syntax.  */
block|}
name|RETURN_IF_ERROR
argument_list|(
name|result_add_char
argument_list|(
name|dm
argument_list|,
literal|'('
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_type
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add_char
argument_list|(
name|dm
argument_list|,
literal|')'
argument_list|)
argument_list|)
expr_stmt|;
name|value_string
operator|=
name|dyn_string_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_string
operator|==
name|NULL
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
name|status
operator|=
name|demangle_number_literally
argument_list|(
name|dm
argument_list|,
name|value_string
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
name|status
operator|=
name|result_add_string
argument_list|(
name|dm
argument_list|,
name|value_string
argument_list|)
expr_stmt|;
name|dyn_string_delete
argument_list|(
name|value_string
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|status
argument_list|)
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Demangles and emits a<template-arg>.<template-arg> ::=<type>                     # type                    ::= L<type><value number> E  # literal                    ::= LZ<encoding> E            # external name                    ::= X<expression> E           # expression  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_template_arg
parameter_list|(
name|dm
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
block|{
name|DEMANGLE_TRACE
argument_list|(
literal|"template-arg"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|peek_char
argument_list|(
name|dm
argument_list|)
condition|)
block|{
case|case
literal|'L'
case|:
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek_char
argument_list|(
name|dm
argument_list|)
operator|==
literal|'Z'
condition|)
block|{
comment|/* External name.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
comment|/* FIXME: Standard is contradictory here.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_encoding
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|RETURN_IF_ERROR
argument_list|(
name|demangle_literal
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_char
argument_list|(
name|dm
argument_list|,
literal|'E'
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* Expression.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_expression
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_char
argument_list|(
name|dm
argument_list|,
literal|'E'
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_IF_ERROR
argument_list|(
name|demangle_type
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Demangles and emits an<expression>.<expression> ::=<unary operator-name><expression> 		 ::=<binary operator-name><expression><expression> 		 ::=<expr-primary>                    ::=<scope-expression>  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_expression
parameter_list|(
name|dm
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
block|{
name|char
name|peek
init|=
name|peek_char
argument_list|(
name|dm
argument_list|)
decl_stmt|;
name|DEMANGLE_TRACE
argument_list|(
literal|"expression"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek
operator|==
literal|'L'
operator|||
name|peek
operator|==
literal|'T'
condition|)
name|RETURN_IF_ERROR
argument_list|(
name|demangle_expr_primary
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|peek
operator|==
literal|'s'
operator|&&
name|peek_char_next
argument_list|(
name|dm
argument_list|)
operator|==
literal|'r'
condition|)
name|RETURN_IF_ERROR
argument_list|(
name|demangle_scope_expression
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* An operator expression.  */
block|{
name|int
name|num_args
decl_stmt|;
name|status_t
name|status
init|=
name|STATUS_OK
decl_stmt|;
name|dyn_string_t
name|operator_name
decl_stmt|;
comment|/* We have an operator name.  Since we want to output binary 	 operations in infix notation, capture the operator name 	 first.  */
name|RETURN_IF_ERROR
argument_list|(
name|result_push
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_operator_name
argument_list|(
name|dm
argument_list|,
literal|1
argument_list|,
operator|&
name|num_args
argument_list|)
argument_list|)
expr_stmt|;
name|operator_name
operator|=
operator|(
name|dyn_string_t
operator|)
name|result_pop
argument_list|(
name|dm
argument_list|)
expr_stmt|;
comment|/* If it's binary, do an operand first.  */
if|if
condition|(
name|num_args
operator|>
literal|1
condition|)
block|{
name|status
operator|=
name|result_add_char
argument_list|(
name|dm
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
name|status
operator|=
name|demangle_expression
argument_list|(
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
name|status
operator|=
name|result_add_char
argument_list|(
name|dm
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
comment|/* Emit the operator.  */
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
name|status
operator|=
name|result_add_string
argument_list|(
name|dm
argument_list|,
name|operator_name
argument_list|)
expr_stmt|;
name|dyn_string_delete
argument_list|(
name|operator_name
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|/* Emit its second (if binary) or only (if unary) operand.  */
name|RETURN_IF_ERROR
argument_list|(
name|result_add_char
argument_list|(
name|dm
argument_list|,
literal|'('
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_expression
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add_char
argument_list|(
name|dm
argument_list|,
literal|')'
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The ternary operator takes a third operand.  */
if|if
condition|(
name|num_args
operator|==
literal|3
condition|)
block|{
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|":("
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_expression
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add_char
argument_list|(
name|dm
argument_list|,
literal|')'
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Demangles and emits a<scope-expression>.<scope-expression> ::= sr<qualifying type><source-name>                        ::= sr<qualifying type><encoding>  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_scope_expression
parameter_list|(
name|dm
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
block|{
name|RETURN_IF_ERROR
argument_list|(
name|demangle_char
argument_list|(
name|dm
argument_list|,
literal|'s'
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_char
argument_list|(
name|dm
argument_list|,
literal|'r'
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_type
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"::"
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_encoding
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Demangles and emits an<expr-primary>.<expr-primary> ::=<template-param> 		   ::= L<type><value number> E  # literal 		   ::= L<mangled-name> E         # external name  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_expr_primary
parameter_list|(
name|dm
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
block|{
name|char
name|peek
init|=
name|peek_char
argument_list|(
name|dm
argument_list|)
decl_stmt|;
name|DEMANGLE_TRACE
argument_list|(
literal|"expr-primary"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek
operator|==
literal|'T'
condition|)
name|RETURN_IF_ERROR
argument_list|(
name|demangle_template_param
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|peek
operator|==
literal|'L'
condition|)
block|{
comment|/* Consume the `L'.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
name|peek
operator|=
name|peek_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek
operator|==
literal|'_'
condition|)
name|RETURN_IF_ERROR
argument_list|(
name|demangle_mangled_name
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|RETURN_IF_ERROR
argument_list|(
name|demangle_literal
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_char
argument_list|(
name|dm
argument_list|,
literal|'E'
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|STATUS_ERROR
return|;
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Demangles and emits a<substitution>.  Sets *TEMPLATE_P to non-zero    if the substitution is the name of a template, zero otherwise.<substitution> ::= S<seq-id> _                     ::= S_                      ::= St   # ::std::                     ::= Sa   # ::std::allocator                     ::= Sb   # ::std::basic_string                     ::= Ss   # ::std::basic_string<char, 				    		   ::std::char_traits<char>, 						   ::std::allocator<char>>                     ::= Si   # ::std::basic_istream<char,                                                       std::char_traits<char>>                     ::= So   # ::std::basic_ostream<char,                                                       std::char_traits<char>>                     ::= Sd   # ::std::basic_iostream<char,                                                      std::char_traits<char>> */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_substitution
parameter_list|(
name|dm
parameter_list|,
name|template_p
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
name|int
modifier|*
name|template_p
decl_stmt|;
block|{
name|int
name|seq_id
decl_stmt|;
name|int
name|peek
decl_stmt|;
name|dyn_string_t
name|text
decl_stmt|;
name|DEMANGLE_TRACE
argument_list|(
literal|"substitution"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_char
argument_list|(
name|dm
argument_list|,
literal|'S'
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Scan the substitution sequence index.  A missing number denotes      the first index.  */
name|peek
operator|=
name|peek_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek
operator|==
literal|'_'
condition|)
name|seq_id
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If the following character is 0-9 or a capital letter, interpret      the sequence up to the next underscore as a base-36 substitution      index.  */
elseif|else
if|if
condition|(
name|IS_DIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|peek
argument_list|)
operator|||
operator|(
name|peek
operator|>=
literal|'A'
operator|&&
name|peek
operator|<=
literal|'Z'
operator|)
condition|)
name|RETURN_IF_ERROR
argument_list|(
name|demangle_number
argument_list|(
name|dm
argument_list|,
operator|&
name|seq_id
argument_list|,
literal|36
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|new_last_source_name
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|peek
condition|)
block|{
case|case
literal|'t'
case|:
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"std"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"std::allocator"
argument_list|)
argument_list|)
expr_stmt|;
name|new_last_source_name
operator|=
literal|"allocator"
expr_stmt|;
operator|*
name|template_p
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"std::basic_string"
argument_list|)
argument_list|)
expr_stmt|;
name|new_last_source_name
operator|=
literal|"basic_string"
expr_stmt|;
operator|*
name|template_p
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
operator|!
name|flag_verbose
condition|)
block|{
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"std::string"
argument_list|)
argument_list|)
expr_stmt|;
name|new_last_source_name
operator|=
literal|"string"
expr_stmt|;
block|}
else|else
block|{
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"std::basic_string<char, std::char_traits<char>, std::allocator<char>>"
argument_list|)
argument_list|)
expr_stmt|;
name|new_last_source_name
operator|=
literal|"basic_string"
expr_stmt|;
block|}
operator|*
name|template_p
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
operator|!
name|flag_verbose
condition|)
block|{
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"std::istream"
argument_list|)
argument_list|)
expr_stmt|;
name|new_last_source_name
operator|=
literal|"istream"
expr_stmt|;
block|}
else|else
block|{
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"std::basic_istream<char, std::char_traints<char>>"
argument_list|)
argument_list|)
expr_stmt|;
name|new_last_source_name
operator|=
literal|"basic_istream"
expr_stmt|;
block|}
operator|*
name|template_p
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
operator|!
name|flag_verbose
condition|)
block|{
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"std::ostream"
argument_list|)
argument_list|)
expr_stmt|;
name|new_last_source_name
operator|=
literal|"ostream"
expr_stmt|;
block|}
else|else
block|{
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"std::basic_ostream<char, std::char_traits<char>>"
argument_list|)
argument_list|)
expr_stmt|;
name|new_last_source_name
operator|=
literal|"basic_ostream"
expr_stmt|;
block|}
operator|*
name|template_p
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
operator|!
name|flag_verbose
condition|)
block|{
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"std::iostream"
argument_list|)
argument_list|)
expr_stmt|;
name|new_last_source_name
operator|=
literal|"iostream"
expr_stmt|;
block|}
else|else
block|{
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"std::basic_iostream<char, std::char_traits<char>>"
argument_list|)
argument_list|)
expr_stmt|;
name|new_last_source_name
operator|=
literal|"basic_iostream"
expr_stmt|;
block|}
operator|*
name|template_p
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
literal|"Unrecognized<substitution>."
return|;
block|}
comment|/* Consume the character we just processed.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_last_source_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|dyn_string_copy_cstr
argument_list|(
name|dm
operator|->
name|last_source_name
argument_list|,
name|new_last_source_name
argument_list|)
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
block|}
return|return
name|STATUS_OK
return|;
block|}
comment|/* Look up the substitution text.  Since `S_' is the most recent      substitution, `S0_' is the second-most-recent, etc., shift the      numbering by one.  */
name|text
operator|=
name|substitution_get
argument_list|(
name|dm
argument_list|,
name|seq_id
operator|+
literal|1
argument_list|,
name|template_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|==
name|NULL
condition|)
return|return
literal|"Substitution number out of range."
return|;
comment|/* Emit the substitution text.  */
name|RETURN_IF_ERROR
argument_list|(
name|result_add_string
argument_list|(
name|dm
argument_list|,
name|text
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_char
argument_list|(
name|dm
argument_list|,
literal|'_'
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Demangles and emits a<local-name>.<local-name> := Z<function encoding> E<entity name> [<discriminator>]                  := Z<function encoding> E s [<discriminator>]  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_local_name
parameter_list|(
name|dm
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
block|{
name|DEMANGLE_TRACE
argument_list|(
literal|"local-name"
argument_list|,
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_char
argument_list|(
name|dm
argument_list|,
literal|'Z'
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_encoding
argument_list|(
name|dm
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_char
argument_list|(
name|dm
argument_list|,
literal|'E'
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"::"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|peek_char
argument_list|(
name|dm
argument_list|)
operator|==
literal|'s'
condition|)
block|{
comment|/* Local character string literal.  */
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|"string literal"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Consume the s.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_discriminator
argument_list|(
name|dm
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|unused
decl_stmt|;
comment|/* Local name for some other entity.  Demangle its name.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_name
argument_list|(
name|dm
argument_list|,
operator|&
name|unused
argument_list|)
argument_list|)
expr_stmt|;
name|RETURN_IF_ERROR
argument_list|(
name|demangle_discriminator
argument_list|(
name|dm
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Optimonally demangles and emits a<discriminator>.  If there is no<discriminator> at the current position in the mangled string, the     descriminator is assumed to be zero.  Emit the discriminator number     in parentheses, unless SUPPRESS_FIRST is non-zero and the     discriminator is zero.<discriminator> ::= _<number>  */
end_comment

begin_function
specifier|static
name|status_t
name|demangle_discriminator
parameter_list|(
name|dm
parameter_list|,
name|suppress_first
parameter_list|)
name|demangling_t
name|dm
decl_stmt|;
name|int
name|suppress_first
decl_stmt|;
block|{
comment|/* Output for<discriminator>s to the demangled name is completely      suppressed if not in verbose mode.  */
if|if
condition|(
name|peek_char
argument_list|(
name|dm
argument_list|)
operator|==
literal|'_'
condition|)
block|{
comment|/* Consume the underscore.  */
name|advance_char
argument_list|(
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_verbose
condition|)
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|" [#"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check if there's a number following the underscore.  */
if|if
condition|(
name|IS_DIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|peek_char
argument_list|(
name|dm
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|discriminator
decl_stmt|;
comment|/* Demangle the number.  */
name|RETURN_IF_ERROR
argument_list|(
name|demangle_number
argument_list|(
name|dm
argument_list|,
operator|&
name|discriminator
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_verbose
condition|)
comment|/* Write the discriminator.  The mangled number is two 	       less than the discriminator ordinal, counting from 	       zero.  */
name|RETURN_IF_ERROR
argument_list|(
name|int_to_dyn_string
argument_list|(
name|discriminator
operator|+
literal|1
argument_list|,
operator|(
name|dyn_string_t
operator|)
name|dm
operator|->
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|STATUS_ERROR
return|;
if|if
condition|(
name|flag_verbose
condition|)
name|RETURN_IF_ERROR
argument_list|(
name|result_add_char
argument_list|(
name|dm
argument_list|,
literal|']'
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|suppress_first
condition|)
block|{
if|if
condition|(
name|flag_verbose
condition|)
name|RETURN_IF_ERROR
argument_list|(
name|result_add
argument_list|(
name|dm
argument_list|,
literal|" [#0]"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|STATUS_OK
return|;
block|}
end_function

begin_comment
comment|/* Demangle NAME into RESULT, which must be an initialized    dyn_string_t.  On success, returns STATUS_OK.  On failure, returns    an error message, and the contents of RESULT are unchanged.  */
end_comment

begin_function
specifier|static
name|status_t
name|cp_demangle
parameter_list|(
name|name
parameter_list|,
name|result
parameter_list|,
name|style
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|dyn_string_t
name|result
decl_stmt|;
name|int
name|style
decl_stmt|;
block|{
name|status_t
name|status
decl_stmt|;
name|int
name|length
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|2
operator|&&
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'Z'
condition|)
block|{
name|demangling_t
name|dm
init|=
name|demangling_new
argument_list|(
name|name
argument_list|,
name|style
argument_list|)
decl_stmt|;
if|if
condition|(
name|dm
operator|==
name|NULL
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
name|status
operator|=
name|result_push
argument_list|(
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|STATUS_OK
condition|)
block|{
name|demangling_delete
argument_list|(
name|dm
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|status
operator|=
name|demangle_mangled_name
argument_list|(
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|dyn_string_t
name|demangled
init|=
operator|(
name|dyn_string_t
operator|)
name|result_pop
argument_list|(
name|dm
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dyn_string_copy
argument_list|(
name|result
argument_list|,
name|demangled
argument_list|)
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
name|dyn_string_delete
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
block|}
name|demangling_delete
argument_list|(
name|dm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It's evidently not a mangled C++ name.  It could be the name 	 of something with C linkage, though, so just copy NAME into 	 RESULT.  */
if|if
condition|(
operator|!
name|dyn_string_copy_cstr
argument_list|(
name|result
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
name|status
operator|=
name|STATUS_OK
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* Demangle TYPE_NAME into RESULT, which must be an initialized    dyn_string_t.  On success, returns STATUS_OK.  On failiure, returns    an error message, and the contents of RESULT are unchanged.  */
end_comment

begin_function
specifier|static
name|status_t
name|cp_demangle_type
parameter_list|(
name|type_name
parameter_list|,
name|result
parameter_list|)
specifier|const
name|char
modifier|*
name|type_name
decl_stmt|;
name|dyn_string_t
name|result
decl_stmt|;
block|{
name|status_t
name|status
decl_stmt|;
name|demangling_t
name|dm
init|=
name|demangling_new
argument_list|(
name|type_name
argument_list|,
name|DMGL_GNU_V3
argument_list|)
decl_stmt|;
if|if
condition|(
name|dm
operator|==
name|NULL
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
comment|/* Demangle the type name.  The demangled name is stored in dm.  */
name|status
operator|=
name|result_push
argument_list|(
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|STATUS_OK
condition|)
block|{
name|demangling_delete
argument_list|(
name|dm
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|status
operator|=
name|demangle_type
argument_list|(
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
block|{
comment|/* The demangling succeeded.  Pop the result out of dm and copy 	 it into RESULT.  */
name|dyn_string_t
name|demangled
init|=
operator|(
name|dyn_string_t
operator|)
name|result_pop
argument_list|(
name|dm
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dyn_string_copy
argument_list|(
name|result
argument_list|,
name|demangled
argument_list|)
condition|)
return|return
name|STATUS_ALLOCATION_FAILED
return|;
name|dyn_string_delete
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up.  */
name|demangling_delete
argument_list|(
name|dm
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IN_LIBGCC2
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|__cxa_demangle
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|size_t
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ia64 ABI-mandated entry point in the C++ runtime library for performing    demangling.  MANGLED_NAME is a NUL-terminated character string    containing the name to be demangled.       OUTPUT_BUFFER is a region of memory, allocated with malloc, of    *LENGTH bytes, into which the demangled name is stored.  If    OUTPUT_BUFFER is not long enough, it is expanded using realloc.    OUTPUT_BUFFER may instead be NULL; in that case, the demangled name    is placed in a region of memory allocated with malloc.       If LENGTH is non-NULL, the length of the buffer conaining the    demangled name, is placed in *LENGTH.       The return value is a pointer to the start of the NUL-terminated    demangled name, or NULL if the demangling fails.  The caller is    responsible for deallocating this memory using free.       *STATUS is set to one of the following values:       0: The demangling operation succeeded.      -1: A memory allocation failiure occurred.      -2: MANGLED_NAME is not a valid name under the C++ ABI mangling rules.      -3: One of the arguments is invalid.     The demagling is performed using the C++ ABI mangling rules, with    GNU extensions.  */
end_comment

begin_function
name|char
modifier|*
name|__cxa_demangle
parameter_list|(
name|mangled_name
parameter_list|,
name|output_buffer
parameter_list|,
name|length
parameter_list|,
name|status
parameter_list|)
specifier|const
name|char
modifier|*
name|mangled_name
decl_stmt|;
name|char
modifier|*
name|output_buffer
decl_stmt|;
name|size_t
modifier|*
name|length
decl_stmt|;
name|int
modifier|*
name|status
decl_stmt|;
block|{
name|struct
name|dyn_string
name|demangled_name
decl_stmt|;
name|status_t
name|result
decl_stmt|;
if|if
condition|(
name|status
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|mangled_name
operator|==
name|NULL
condition|)
block|{
operator|*
name|status
operator|=
operator|-
literal|3
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Did the caller provide a buffer for the demangled name?  */
if|if
condition|(
name|output_buffer
operator|==
name|NULL
condition|)
block|{
comment|/* No; dyn_string will malloc a buffer for us.  */
if|if
condition|(
operator|!
name|dyn_string_init
argument_list|(
operator|&
name|demangled_name
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|status
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
comment|/* Yes.  Check that the length was provided.  */
if|if
condition|(
name|length
operator|==
name|NULL
condition|)
block|{
operator|*
name|status
operator|=
operator|-
literal|3
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Install the buffer into a dyn_string.  */
name|demangled_name
operator|.
name|allocated
operator|=
operator|*
name|length
expr_stmt|;
name|demangled_name
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|demangled_name
operator|.
name|s
operator|=
name|output_buffer
expr_stmt|;
block|}
if|if
condition|(
name|mangled_name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|mangled_name
index|[
literal|1
index|]
operator|==
literal|'Z'
condition|)
comment|/* MANGLED_NAME apprears to be a function or variable name.        Demangle it accordingly.  */
name|result
operator|=
name|cp_demangle
argument_list|(
name|mangled_name
argument_list|,
operator|&
name|demangled_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/* Try to demangled MANGLED_NAME as the name of a type.  */
name|result
operator|=
name|cp_demangle_type
argument_list|(
name|mangled_name
argument_list|,
operator|&
name|demangled_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|STATUS_OK
condition|)
comment|/* The demangling succeeded.  */
block|{
comment|/* If LENGTH isn't NULL, store the allocated buffer length 	 there; the buffer may have been realloced by dyn_string 	 functions.  */
if|if
condition|(
name|length
operator|!=
name|NULL
condition|)
operator|*
name|length
operator|=
name|demangled_name
operator|.
name|allocated
expr_stmt|;
comment|/* The operation was a success.  */
operator|*
name|status
operator|=
literal|0
expr_stmt|;
return|return
name|dyn_string_buf
argument_list|(
operator|&
name|demangled_name
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|result
operator|==
name|STATUS_ALLOCATION_FAILED
condition|)
comment|/* A call to malloc or realloc failed during the demangling        operation.  */
block|{
operator|*
name|status
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
comment|/* The demangling failed for another reason, most probably because        MANGLED_NAME isn't a valid mangled name.  */
block|{
comment|/* If the buffer containing the demangled name wasn't provided 	 by the caller, free it.  */
if|if
condition|(
name|output_buffer
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|dyn_string_buf
argument_list|(
operator|&
name|demangled_name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
operator|-
literal|2
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !IN_LIBGCC2 */
end_comment

begin_comment
comment|/* Variant entry point for integration with the existing cplus-dem    demangler.  Attempts to demangle MANGLED.  If the demangling    succeeds, returns a buffer, allocated with malloc, containing the    demangled name.  The caller must deallocate the buffer using free.    If the demangling failes, returns NULL.  */
end_comment

begin_function
name|char
modifier|*
name|cplus_demangle_v3
parameter_list|(
name|mangled
parameter_list|,
name|options
parameter_list|)
specifier|const
name|char
modifier|*
name|mangled
decl_stmt|;
name|int
name|options
decl_stmt|;
block|{
name|dyn_string_t
name|demangled
decl_stmt|;
name|status_t
name|status
decl_stmt|;
name|int
name|type
init|=
operator|!
operator|!
operator|(
name|options
operator|&
name|DMGL_TYPES
operator|)
decl_stmt|;
if|if
condition|(
name|mangled
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|mangled
index|[
literal|1
index|]
operator|==
literal|'Z'
condition|)
comment|/* It is not a type.  */
name|type
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* It is a type. Stop if we don't want to demangle types. */
if|if
condition|(
operator|!
name|type
condition|)
return|return
name|NULL
return|;
block|}
name|flag_verbose
operator|=
operator|!
operator|!
operator|(
name|options
operator|&
name|DMGL_VERBOSE
operator|)
expr_stmt|;
comment|/* Create a dyn_string to hold the demangled name.  */
name|demangled
operator|=
name|dyn_string_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Attempt the demangling.  */
if|if
condition|(
operator|!
name|type
condition|)
comment|/* Appears to be a function or variable name.  */
name|status
operator|=
name|cp_demangle
argument_list|(
name|mangled
argument_list|,
name|demangled
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/* Try to demangle it as the name of a type.  */
name|status
operator|=
name|cp_demangle_type
argument_list|(
name|mangled
argument_list|,
name|demangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
comment|/* Demangling succeeded.  */
block|{
comment|/* Grab the demangled result from the dyn_string.  It was 	 allocated with malloc, so we can return it directly.  */
name|char
modifier|*
name|return_value
init|=
name|dyn_string_release
argument_list|(
name|demangled
argument_list|)
decl_stmt|;
comment|/* Hand back the demangled name.  */
return|return
name|return_value
return|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|STATUS_ALLOCATION_FAILED
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Memory allocation failed.\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
comment|/* Demangling failed.  */
block|{
name|dyn_string_delete
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/* Demangle a Java symbol.  Java uses a subset of the V3 ABI C++ mangling     conventions, but the output formatting is a little different.    This instructs the C++ demangler not to emit pointer characters ("*"), and     to use Java's namespace separator symbol ("." instead of "::").  It then     does an additional pass over the demangled output to replace instances     of JArray<TYPE> with TYPE[].  */
end_comment

begin_function
name|char
modifier|*
name|java_demangle_v3
parameter_list|(
name|mangled
parameter_list|)
specifier|const
name|char
modifier|*
name|mangled
decl_stmt|;
block|{
name|dyn_string_t
name|demangled
decl_stmt|;
name|char
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|len
decl_stmt|;
name|status_t
name|status
decl_stmt|;
name|int
name|nesting
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cplus_demangled
decl_stmt|;
name|char
modifier|*
name|return_value
decl_stmt|;
comment|/* Create a dyn_string to hold the demangled name.  */
name|demangled
operator|=
name|dyn_string_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Attempt the demangling.  */
name|status
operator|=
name|cp_demangle
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mangled
argument_list|,
name|demangled
argument_list|,
name|DMGL_JAVA
argument_list|)
expr_stmt|;
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
comment|/* Demangling succeeded.  */
block|{
comment|/* Grab the demangled result from the dyn_string. */
name|cplus_demangled
operator|=
name|dyn_string_release
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|STATUS_ALLOCATION_FAILED
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Memory allocation failed.\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
comment|/* Demangling failed.  */
block|{
name|dyn_string_delete
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|cplus_demangled
argument_list|)
expr_stmt|;
name|next
operator|=
name|cplus_demangled
expr_stmt|;
name|end
operator|=
name|next
operator|+
name|len
expr_stmt|;
name|demangled
operator|=
name|NULL
expr_stmt|;
comment|/* Replace occurances of JArray<TYPE> with TYPE[]. */
while|while
condition|(
name|next
operator|<
name|end
condition|)
block|{
name|char
modifier|*
name|open_str
init|=
name|strstr
argument_list|(
name|next
argument_list|,
literal|"JArray<"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|close_str
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|nesting
operator|>
literal|0
condition|)
name|close_str
operator|=
name|strchr
argument_list|(
name|next
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|open_str
operator|!=
name|NULL
operator|&&
operator|(
name|close_str
operator|==
name|NULL
operator|||
name|close_str
operator|>
name|open_str
operator|)
condition|)
block|{
operator|++
name|nesting
expr_stmt|;
if|if
condition|(
operator|!
name|demangled
condition|)
name|demangled
operator|=
name|dyn_string_new
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* Copy prepending symbols, if any. */
if|if
condition|(
name|open_str
operator|>
name|next
condition|)
block|{
name|open_str
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|dyn_string_append_cstr
argument_list|(
name|demangled
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
name|next
operator|=
name|open_str
operator|+
literal|7
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|close_str
operator|!=
name|NULL
condition|)
block|{
operator|--
name|nesting
expr_stmt|;
comment|/* Copy prepending type symbol, if any. Squash any spurious  	     whitespace. */
if|if
condition|(
name|close_str
operator|>
name|next
operator|&&
name|next
index|[
literal|0
index|]
operator|!=
literal|' '
condition|)
block|{
name|close_str
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|dyn_string_append_cstr
argument_list|(
name|demangled
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
name|dyn_string_append_cstr
argument_list|(
name|demangled
argument_list|,
literal|"[]"
argument_list|)
expr_stmt|;
name|next
operator|=
name|close_str
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* There are no more arrays. Copy the rest of the symbol, or 	     simply return the original symbol if no changes were made. */
if|if
condition|(
name|next
operator|==
name|cplus_demangled
condition|)
return|return
name|cplus_demangled
return|;
name|dyn_string_append_cstr
argument_list|(
name|demangled
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
name|end
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|cplus_demangled
argument_list|)
expr_stmt|;
name|return_value
operator|=
name|dyn_string_release
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
return|return
name|return_value
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IN_LIBGCC2 */
end_comment

begin_comment
comment|/* Demangle NAME in the G++ V3 ABI demangling style, and return either    zero, indicating that some error occurred, or a demangling_t    holding the results.  */
end_comment

begin_function
specifier|static
name|demangling_t
name|demangle_v3_with_details
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|demangling_t
name|dm
decl_stmt|;
name|status_t
name|status
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_Z"
argument_list|,
literal|2
argument_list|)
condition|)
return|return
literal|0
return|;
name|dm
operator|=
name|demangling_new
argument_list|(
name|name
argument_list|,
name|DMGL_GNU_V3
argument_list|)
expr_stmt|;
if|if
condition|(
name|dm
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Memory allocation failed.\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|status
operator|=
name|result_push
argument_list|(
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|demangling_delete
argument_list|(
name|dm
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|status
operator|=
name|demangle_mangled_name
argument_list|(
name|dm
argument_list|)
expr_stmt|;
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
return|return
name|dm
return|;
name|demangling_delete
argument_list|(
name|dm
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero iff NAME is the mangled form of a constructor name    in the G++ V3 ABI demangling style.  Specifically, return:    - '1' if NAME is a complete object constructor,    - '2' if NAME is a base object constructor, or    - '3' if NAME is a complete object allocating constructor.  */
end_comment

begin_function
name|enum
name|gnu_v3_ctor_kinds
name|is_gnu_v3_mangled_ctor
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|demangling_t
name|dm
init|=
name|demangle_v3_with_details
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|dm
condition|)
block|{
name|enum
name|gnu_v3_ctor_kinds
name|result
init|=
name|dm
operator|->
name|is_constructor
decl_stmt|;
name|demangling_delete
argument_list|(
name|dm
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero iff NAME is the mangled form of a destructor name    in the G++ V3 ABI demangling style.  Specifically, return:    - '0' if NAME is a deleting destructor,    - '1' if NAME is a complete object destructor, or    - '2' if NAME is a base object destructor.  */
end_comment

begin_function
name|enum
name|gnu_v3_dtor_kinds
name|is_gnu_v3_mangled_dtor
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|demangling_t
name|dm
init|=
name|demangle_v3_with_details
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|dm
condition|)
block|{
name|enum
name|gnu_v3_dtor_kinds
name|result
init|=
name|dm
operator|->
name|is_destructor
decl_stmt|;
name|demangling_delete
argument_list|(
name|dm
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|STANDALONE_DEMANGLER
end_ifdef

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|print_usage
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
name|fp
operator|,
name|int
name|exit_value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if CHAR is a character than can occur in a mangled name.  */
end_comment

begin_define
define|#
directive|define
name|is_mangled_char
parameter_list|(
name|CHAR
parameter_list|)
define|\
value|(IS_ALPHA (CHAR) || IS_DIGIT (CHAR)                                   \    || (CHAR) == '_' || (CHAR) == '.' || (CHAR) == '$')
end_define

begin_comment
comment|/* The name of this program, as invoked.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prints usage summary to FP and then exits with EXIT_VALUE.  */
end_comment

begin_function
specifier|static
name|void
name|print_usage
parameter_list|(
name|fp
parameter_list|,
name|exit_value
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|exit_value
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Usage: %s [options] [names ...]\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"Options:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -h,--help       Display this message.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -s,--strict     Demangle standard names only.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  -v,--verbose    Produce verbose demanglings.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"If names are provided, they are demangled.  Otherwise filters standard input.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Option specification for getopt_long.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"strict"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"verbose"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'v'
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Main entry for a demangling filter executable.  It will demangle    its command line arguments, if any.  If none are provided, it will    filter stdin to stdout, replacing any recognized mangled C++ names    with their demangled equivalents.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|status_t
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|opt_char
decl_stmt|;
comment|/* Use the program name of this program, as invoked.  */
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* Parse options.  */
do|do
block|{
name|opt_char
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"hsv"
argument_list|,
name|long_options
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opt_char
condition|)
block|{
case|case
literal|'?'
case|:
comment|/* Unrecognized option.  */
name|print_usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|print_usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|flag_strict
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|flag_verbose
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|opt_char
operator|!=
operator|-
literal|1
condition|)
do|;
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
comment|/* No command line arguments were provided.  Filter stdin.  */
block|{
name|dyn_string_t
name|mangled
init|=
name|dyn_string_new
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|dyn_string_t
name|demangled
init|=
name|dyn_string_new
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|status_t
name|status
decl_stmt|;
comment|/* Read all of input.  */
while|while
condition|(
operator|!
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
name|char
name|c
init|=
name|getchar
argument_list|()
decl_stmt|;
comment|/* The first character of a mangled name is an underscore.  */
if|if
condition|(
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
break|break;
if|if
condition|(
name|c
operator|!=
literal|'_'
condition|)
block|{
comment|/* It's not a mangled name.  Print the character and go 		 on.  */
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/* The second character of a mangled name is a capital `Z'.  */
if|if
condition|(
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
break|break;
if|if
condition|(
name|c
operator|!=
literal|'Z'
condition|)
block|{
comment|/* It's not a mangled name.  Print the previous 		 underscore, the `Z', and go on.  */
name|putchar
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Start keeping track of the candidate mangled name.  */
name|dyn_string_append_char
argument_list|(
name|mangled
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
name|dyn_string_append_char
argument_list|(
name|mangled
argument_list|,
literal|'Z'
argument_list|)
expr_stmt|;
comment|/* Pile characters into mangled until we hit one that can't 	     occur in a mangled name.  */
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|stdin
argument_list|)
operator|&&
name|is_mangled_char
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|dyn_string_append_char
argument_list|(
name|mangled
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
break|break;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
comment|/* Attempt to demangle the name.  */
name|status
operator|=
name|cp_demangle
argument_list|(
name|dyn_string_buf
argument_list|(
name|mangled
argument_list|)
argument_list|,
name|demangled
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the demangling succeeded, great!  Print out the 	     demangled version.  */
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
name|fputs
argument_list|(
name|dyn_string_buf
argument_list|(
name|demangled
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* Abort on allocation failures.  */
elseif|else
if|if
condition|(
name|status
operator|==
name|STATUS_ALLOCATION_FAILED
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Memory allocation failed.\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Otherwise, it might not have been a mangled name.  Just 	     print out the original text.  */
else|else
name|fputs
argument_list|(
name|dyn_string_buf
argument_list|(
name|mangled
argument_list|)
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* If we haven't hit EOF yet, we've read one character that 	     can't occur in a mangled name, so print it out.  */
if|if
condition|(
operator|!
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Clear the candidate mangled name, to start afresh next 	     time we hit a `_Z'.  */
name|dyn_string_clear
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
block|}
name|dyn_string_delete
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
name|dyn_string_delete
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Demangle command line arguments.  */
block|{
name|dyn_string_t
name|result
init|=
name|dyn_string_new
argument_list|(
literal|0
argument_list|)
decl_stmt|;
comment|/* Loop over command line arguments.  */
for|for
control|(
name|i
operator|=
name|optind
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
comment|/* Attempt to demangle.  */
name|status
operator|=
name|cp_demangle
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If it worked, print the demangled name.  */
if|if
condition|(
name|STATUS_NO_ERROR
argument_list|(
name|status
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|dyn_string_buf
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Abort on allocaiton failures.  */
elseif|else
if|if
condition|(
name|status
operator|==
name|STATUS_ALLOCATION_FAILED
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Memory allocation failed.\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If not, print the error message to stderr instead.  */
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
name|dyn_string_delete
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STANDALONE_DEMANGLER */
end_comment

end_unit

