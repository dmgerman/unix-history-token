begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* A Fibonacci heap datatype.    Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.    Contributed by Daniel Berlin (dan@cgsoftware.com).     This file is part of GNU CC.     GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIMITS_H
end_ifdef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"fibheap.h"
end_include

begin_define
define|#
directive|define
name|FIBHEAPKEY_MIN
value|LONG_MIN
end_define

begin_decl_stmt
specifier|static
name|void
name|fibheap_ins_root
name|PARAMS
argument_list|(
operator|(
name|fibheap_t
operator|,
name|fibnode_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fibheap_rem_root
name|PARAMS
argument_list|(
operator|(
name|fibheap_t
operator|,
name|fibnode_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fibheap_consolidate
name|PARAMS
argument_list|(
operator|(
name|fibheap_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fibheap_link
name|PARAMS
argument_list|(
operator|(
name|fibheap_t
operator|,
name|fibnode_t
operator|,
name|fibnode_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fibheap_cut
name|PARAMS
argument_list|(
operator|(
name|fibheap_t
operator|,
name|fibnode_t
operator|,
name|fibnode_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fibheap_cascading_cut
name|PARAMS
argument_list|(
operator|(
name|fibheap_t
operator|,
name|fibnode_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fibnode_t
name|fibheap_extr_min_node
name|PARAMS
argument_list|(
operator|(
name|fibheap_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fibheap_compare
name|PARAMS
argument_list|(
operator|(
name|fibheap_t
operator|,
name|fibnode_t
operator|,
name|fibnode_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fibheap_comp_data
name|PARAMS
argument_list|(
operator|(
name|fibheap_t
operator|,
name|fibheapkey_t
operator|,
name|void
operator|*
operator|,
name|fibnode_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fibnode_t
name|fibnode_new
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fibnode_insert_after
name|PARAMS
argument_list|(
operator|(
name|fibnode_t
operator|,
name|fibnode_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|fibnode_insert_before
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|fibnode_insert_after (a->left, b)
end_define

begin_decl_stmt
specifier|static
name|fibnode_t
name|fibnode_remove
name|PARAMS
argument_list|(
operator|(
name|fibnode_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Create a new fibonacci heap.  */
end_comment

begin_function
name|fibheap_t
name|fibheap_new
parameter_list|()
block|{
return|return
operator|(
name|fibheap_t
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fibheap
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a new fibonacci heap node.  */
end_comment

begin_function
specifier|static
name|fibnode_t
name|fibnode_new
parameter_list|()
block|{
name|fibnode_t
name|node
decl_stmt|;
name|node
operator|=
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|left
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|right
operator|=
name|node
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|fibheap_compare
parameter_list|(
name|heap
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
name|fibheap_t
name|heap
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fibnode_t
name|a
decl_stmt|;
name|fibnode_t
name|b
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|->
name|key
operator|<
name|b
operator|->
name|key
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|key
operator|>
name|b
operator|->
name|key
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|fibheap_comp_data
parameter_list|(
name|heap
parameter_list|,
name|key
parameter_list|,
name|data
parameter_list|,
name|b
parameter_list|)
name|fibheap_t
name|heap
decl_stmt|;
name|fibheapkey_t
name|key
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|fibnode_t
name|b
decl_stmt|;
block|{
name|struct
name|fibnode
name|a
decl_stmt|;
name|a
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|a
operator|.
name|data
operator|=
name|data
expr_stmt|;
return|return
name|fibheap_compare
argument_list|(
name|heap
argument_list|,
operator|&
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Insert DATA, with priority KEY, into HEAP.  */
end_comment

begin_function
name|fibnode_t
name|fibheap_insert
parameter_list|(
name|heap
parameter_list|,
name|key
parameter_list|,
name|data
parameter_list|)
name|fibheap_t
name|heap
decl_stmt|;
name|fibheapkey_t
name|key
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|fibnode_t
name|node
decl_stmt|;
comment|/* Create the new node.  */
name|node
operator|=
name|fibnode_new
argument_list|()
expr_stmt|;
comment|/* Set the node's data.  */
name|node
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|node
operator|->
name|key
operator|=
name|key
expr_stmt|;
comment|/* Insert it into the root list.  */
name|fibheap_ins_root
argument_list|(
name|heap
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|/* If their was no minimum, or this key is less than the min,      it's the new min.  */
if|if
condition|(
name|heap
operator|->
name|min
operator|==
name|NULL
operator|||
name|node
operator|->
name|key
operator|<
name|heap
operator|->
name|min
operator|->
name|key
condition|)
name|heap
operator|->
name|min
operator|=
name|node
expr_stmt|;
name|heap
operator|->
name|nodes
operator|++
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Return the data of the minimum node (if we know it).  */
end_comment

begin_function
name|void
modifier|*
name|fibheap_min
parameter_list|(
name|heap
parameter_list|)
name|fibheap_t
name|heap
decl_stmt|;
block|{
comment|/* If there is no min, we can't easily return it.  */
if|if
condition|(
name|heap
operator|->
name|min
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|heap
operator|->
name|min
operator|->
name|data
return|;
block|}
end_function

begin_comment
comment|/* Return the key of the minimum node (if we know it).  */
end_comment

begin_function
name|fibheapkey_t
name|fibheap_min_key
parameter_list|(
name|heap
parameter_list|)
name|fibheap_t
name|heap
decl_stmt|;
block|{
comment|/* If there is no min, we can't easily return it.  */
if|if
condition|(
name|heap
operator|->
name|min
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
name|heap
operator|->
name|min
operator|->
name|key
return|;
block|}
end_function

begin_comment
comment|/* Union HEAPA and HEAPB into a new heap.  */
end_comment

begin_function
name|fibheap_t
name|fibheap_union
parameter_list|(
name|heapa
parameter_list|,
name|heapb
parameter_list|)
name|fibheap_t
name|heapa
decl_stmt|;
name|fibheap_t
name|heapb
decl_stmt|;
block|{
name|fibnode_t
name|a_root
decl_stmt|,
name|b_root
decl_stmt|,
name|temp
decl_stmt|;
comment|/* If one of the heaps is empty, the union is just the other heap.  */
if|if
condition|(
operator|(
name|a_root
operator|=
name|heapa
operator|->
name|root
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|heapa
argument_list|)
expr_stmt|;
return|return
name|heapb
return|;
block|}
if|if
condition|(
operator|(
name|b_root
operator|=
name|heapb
operator|->
name|root
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|heapb
argument_list|)
expr_stmt|;
return|return
name|heapa
return|;
block|}
comment|/* Merge them to the next nodes on the opposite chain.  */
name|a_root
operator|->
name|left
operator|->
name|right
operator|=
name|b_root
expr_stmt|;
name|b_root
operator|->
name|left
operator|->
name|right
operator|=
name|a_root
expr_stmt|;
name|temp
operator|=
name|a_root
operator|->
name|left
expr_stmt|;
name|a_root
operator|->
name|left
operator|=
name|b_root
operator|->
name|left
expr_stmt|;
name|b_root
operator|->
name|left
operator|=
name|temp
expr_stmt|;
name|heapa
operator|->
name|nodes
operator|+=
name|heapb
operator|->
name|nodes
expr_stmt|;
comment|/* And set the new minimum, if it's changed.  */
if|if
condition|(
name|fibheap_compare
argument_list|(
name|heapa
argument_list|,
name|heapb
operator|->
name|min
argument_list|,
name|heapa
operator|->
name|min
argument_list|)
operator|<
literal|0
condition|)
name|heapa
operator|->
name|min
operator|=
name|heapb
operator|->
name|min
expr_stmt|;
name|free
argument_list|(
name|heapb
argument_list|)
expr_stmt|;
return|return
name|heapa
return|;
block|}
end_function

begin_comment
comment|/* Extract the data of the minimum node from HEAP.  */
end_comment

begin_function
name|void
modifier|*
name|fibheap_extract_min
parameter_list|(
name|heap
parameter_list|)
name|fibheap_t
name|heap
decl_stmt|;
block|{
name|fibnode_t
name|z
decl_stmt|;
name|void
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
comment|/* If we don't have a min set, it means we have no nodes.  */
if|if
condition|(
name|heap
operator|->
name|min
operator|!=
name|NULL
condition|)
block|{
comment|/* Otherwise, extract the min node, free the node, and return the          node's data.  */
name|z
operator|=
name|fibheap_extr_min_node
argument_list|(
name|heap
argument_list|)
expr_stmt|;
name|ret
operator|=
name|z
operator|->
name|data
expr_stmt|;
name|free
argument_list|(
name|z
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Replace both the KEY and the DATA associated with NODE.  */
end_comment

begin_function
name|void
modifier|*
name|fibheap_replace_key_data
parameter_list|(
name|heap
parameter_list|,
name|node
parameter_list|,
name|key
parameter_list|,
name|data
parameter_list|)
name|fibheap_t
name|heap
decl_stmt|;
name|fibnode_t
name|node
decl_stmt|;
name|fibheapkey_t
name|key
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|void
modifier|*
name|odata
decl_stmt|;
name|int
name|okey
decl_stmt|;
name|fibnode_t
name|y
decl_stmt|;
comment|/* If we wanted to, we could actually do a real increase by redeleting and      inserting. However, this would require O (log n) time. So just bail out      for now.  */
if|if
condition|(
name|fibheap_comp_data
argument_list|(
name|heap
argument_list|,
name|key
argument_list|,
name|data
argument_list|,
name|node
argument_list|)
operator|>
literal|0
condition|)
return|return
name|NULL
return|;
name|odata
operator|=
name|node
operator|->
name|data
expr_stmt|;
name|okey
operator|=
name|node
operator|->
name|key
expr_stmt|;
name|node
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|node
operator|->
name|key
operator|=
name|key
expr_stmt|;
name|y
operator|=
name|node
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|okey
operator|==
name|key
condition|)
return|return
name|odata
return|;
comment|/* These two compares are specifically<= 0 to make sure that in the case      of equality, a node we replaced the data on, becomes the new min.  This      is needed so that delete's call to extractmin gets the right node.  */
if|if
condition|(
name|y
operator|!=
name|NULL
operator|&&
name|fibheap_compare
argument_list|(
name|heap
argument_list|,
name|node
argument_list|,
name|y
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|fibheap_cut
argument_list|(
name|heap
argument_list|,
name|node
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|fibheap_cascading_cut
argument_list|(
name|heap
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fibheap_compare
argument_list|(
name|heap
argument_list|,
name|node
argument_list|,
name|heap
operator|->
name|min
argument_list|)
operator|<=
literal|0
condition|)
name|heap
operator|->
name|min
operator|=
name|node
expr_stmt|;
return|return
name|odata
return|;
block|}
end_function

begin_comment
comment|/* Replace the DATA associated with NODE.  */
end_comment

begin_function
name|void
modifier|*
name|fibheap_replace_data
parameter_list|(
name|heap
parameter_list|,
name|node
parameter_list|,
name|data
parameter_list|)
name|fibheap_t
name|heap
decl_stmt|;
name|fibnode_t
name|node
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
return|return
name|fibheap_replace_key_data
argument_list|(
name|heap
argument_list|,
name|node
argument_list|,
name|node
operator|->
name|key
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Replace the KEY associated with NODE.  */
end_comment

begin_function
name|fibheapkey_t
name|fibheap_replace_key
parameter_list|(
name|heap
parameter_list|,
name|node
parameter_list|,
name|key
parameter_list|)
name|fibheap_t
name|heap
decl_stmt|;
name|fibnode_t
name|node
decl_stmt|;
name|fibheapkey_t
name|key
decl_stmt|;
block|{
name|int
name|okey
init|=
name|node
operator|->
name|key
decl_stmt|;
name|fibheap_replace_key_data
argument_list|(
name|heap
argument_list|,
name|node
argument_list|,
name|key
argument_list|,
name|node
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
name|okey
return|;
block|}
end_function

begin_comment
comment|/* Delete NODE from HEAP.  */
end_comment

begin_function
name|void
modifier|*
name|fibheap_delete_node
parameter_list|(
name|heap
parameter_list|,
name|node
parameter_list|)
name|fibheap_t
name|heap
decl_stmt|;
name|fibnode_t
name|node
decl_stmt|;
block|{
name|void
modifier|*
name|ret
init|=
name|node
operator|->
name|data
decl_stmt|;
comment|/* To perform delete, we just make it the min key, and extract.  */
name|fibheap_replace_key
argument_list|(
name|heap
argument_list|,
name|node
argument_list|,
name|FIBHEAPKEY_MIN
argument_list|)
expr_stmt|;
name|fibheap_extract_min
argument_list|(
name|heap
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Delete HEAP.  */
end_comment

begin_function
name|void
name|fibheap_delete
parameter_list|(
name|heap
parameter_list|)
name|fibheap_t
name|heap
decl_stmt|;
block|{
while|while
condition|(
name|heap
operator|->
name|min
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|fibheap_extr_min_node
argument_list|(
name|heap
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|heap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine if HEAP is empty.  */
end_comment

begin_function
name|int
name|fibheap_empty
parameter_list|(
name|heap
parameter_list|)
name|fibheap_t
name|heap
decl_stmt|;
block|{
return|return
name|heap
operator|->
name|nodes
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Extract the minimum node of the heap.  */
end_comment

begin_function
specifier|static
name|fibnode_t
name|fibheap_extr_min_node
parameter_list|(
name|heap
parameter_list|)
name|fibheap_t
name|heap
decl_stmt|;
block|{
name|fibnode_t
name|ret
init|=
name|heap
operator|->
name|min
decl_stmt|;
name|fibnode_t
name|x
decl_stmt|,
name|y
decl_stmt|,
name|orig
decl_stmt|;
comment|/* Attach the child list of the minimum node to the root list of the heap.      If there is no child list, we don't do squat.  */
for|for
control|(
name|x
operator|=
name|ret
operator|->
name|child
operator|,
name|orig
operator|=
name|NULL
init|;
name|x
operator|!=
name|orig
operator|&&
name|x
operator|!=
name|NULL
condition|;
name|x
operator|=
name|y
control|)
block|{
if|if
condition|(
name|orig
operator|==
name|NULL
condition|)
name|orig
operator|=
name|x
expr_stmt|;
name|y
operator|=
name|x
operator|->
name|right
expr_stmt|;
name|x
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|fibheap_ins_root
argument_list|(
name|heap
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the old root.  */
name|fibheap_rem_root
argument_list|(
name|heap
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|heap
operator|->
name|nodes
operator|--
expr_stmt|;
comment|/* If we are left with no nodes, then the min is NULL.  */
if|if
condition|(
name|heap
operator|->
name|nodes
operator|==
literal|0
condition|)
name|heap
operator|->
name|min
operator|=
name|NULL
expr_stmt|;
else|else
block|{
comment|/* Otherwise, consolidate to find new minimum, as well as do the reorg          work that needs to be done.  */
name|heap
operator|->
name|min
operator|=
name|ret
operator|->
name|right
expr_stmt|;
name|fibheap_consolidate
argument_list|(
name|heap
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Insert NODE into the root list of HEAP.  */
end_comment

begin_function
specifier|static
name|void
name|fibheap_ins_root
parameter_list|(
name|heap
parameter_list|,
name|node
parameter_list|)
name|fibheap_t
name|heap
decl_stmt|;
name|fibnode_t
name|node
decl_stmt|;
block|{
comment|/* If the heap is currently empty, the new node becomes the singleton      circular root list.  */
if|if
condition|(
name|heap
operator|->
name|root
operator|==
name|NULL
condition|)
block|{
name|heap
operator|->
name|root
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|left
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|right
operator|=
name|node
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, insert it in the circular root list between the root      and it's right node.  */
name|fibnode_insert_after
argument_list|(
name|heap
operator|->
name|root
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove NODE from the rootlist of HEAP.  */
end_comment

begin_function
specifier|static
name|void
name|fibheap_rem_root
parameter_list|(
name|heap
parameter_list|,
name|node
parameter_list|)
name|fibheap_t
name|heap
decl_stmt|;
name|fibnode_t
name|node
decl_stmt|;
block|{
if|if
condition|(
name|node
operator|->
name|left
operator|==
name|node
condition|)
name|heap
operator|->
name|root
operator|=
name|NULL
expr_stmt|;
else|else
name|heap
operator|->
name|root
operator|=
name|fibnode_remove
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Consolidate the heap.  */
end_comment

begin_function
specifier|static
name|void
name|fibheap_consolidate
parameter_list|(
name|heap
parameter_list|)
name|fibheap_t
name|heap
decl_stmt|;
block|{
name|fibnode_t
name|a
index|[
literal|1
operator|+
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
index|]
decl_stmt|;
name|fibnode_t
name|w
decl_stmt|;
name|fibnode_t
name|y
decl_stmt|;
name|fibnode_t
name|x
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|d
decl_stmt|;
name|int
name|D
decl_stmt|;
name|D
operator|=
literal|1
operator|+
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|a
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|fibnode_t
argument_list|)
operator|*
name|D
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|w
operator|=
name|heap
operator|->
name|root
operator|)
operator|!=
name|NULL
condition|)
block|{
name|x
operator|=
name|w
expr_stmt|;
name|fibheap_rem_root
argument_list|(
name|heap
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|d
operator|=
name|x
operator|->
name|degree
expr_stmt|;
while|while
condition|(
name|a
index|[
name|d
index|]
operator|!=
name|NULL
condition|)
block|{
name|y
operator|=
name|a
index|[
name|d
index|]
expr_stmt|;
if|if
condition|(
name|fibheap_compare
argument_list|(
name|heap
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
operator|>
literal|0
condition|)
block|{
name|fibnode_t
name|temp
decl_stmt|;
name|temp
operator|=
name|x
expr_stmt|;
name|x
operator|=
name|y
expr_stmt|;
name|y
operator|=
name|temp
expr_stmt|;
block|}
name|fibheap_link
argument_list|(
name|heap
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|a
index|[
name|d
index|]
operator|=
name|NULL
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
name|a
index|[
name|d
index|]
operator|=
name|x
expr_stmt|;
block|}
name|heap
operator|->
name|min
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|D
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|a
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|fibheap_ins_root
argument_list|(
name|heap
argument_list|,
name|a
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|heap
operator|->
name|min
operator|==
name|NULL
operator|||
name|fibheap_compare
argument_list|(
name|heap
argument_list|,
name|a
index|[
name|i
index|]
argument_list|,
name|heap
operator|->
name|min
argument_list|)
operator|<
literal|0
condition|)
name|heap
operator|->
name|min
operator|=
name|a
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make NODE a child of PARENT.  */
end_comment

begin_function
specifier|static
name|void
name|fibheap_link
parameter_list|(
name|heap
parameter_list|,
name|node
parameter_list|,
name|parent
parameter_list|)
name|fibheap_t
name|heap
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|fibnode_t
name|node
decl_stmt|;
name|fibnode_t
name|parent
decl_stmt|;
block|{
if|if
condition|(
name|parent
operator|->
name|child
operator|==
name|NULL
condition|)
name|parent
operator|->
name|child
operator|=
name|node
expr_stmt|;
else|else
name|fibnode_insert_before
argument_list|(
name|parent
operator|->
name|child
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|parent
operator|->
name|degree
operator|++
expr_stmt|;
name|node
operator|->
name|mark
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove NODE from PARENT's child list.  */
end_comment

begin_function
specifier|static
name|void
name|fibheap_cut
parameter_list|(
name|heap
parameter_list|,
name|node
parameter_list|,
name|parent
parameter_list|)
name|fibheap_t
name|heap
decl_stmt|;
name|fibnode_t
name|node
decl_stmt|;
name|fibnode_t
name|parent
decl_stmt|;
block|{
name|fibnode_remove
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|parent
operator|->
name|degree
operator|--
expr_stmt|;
name|fibheap_ins_root
argument_list|(
name|heap
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|mark
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fibheap_cascading_cut
parameter_list|(
name|heap
parameter_list|,
name|y
parameter_list|)
name|fibheap_t
name|heap
decl_stmt|;
name|fibnode_t
name|y
decl_stmt|;
block|{
name|fibnode_t
name|z
decl_stmt|;
while|while
condition|(
operator|(
name|z
operator|=
name|y
operator|->
name|parent
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|y
operator|->
name|mark
operator|==
literal|0
condition|)
block|{
name|y
operator|->
name|mark
operator|=
literal|1
expr_stmt|;
return|return;
block|}
else|else
block|{
name|fibheap_cut
argument_list|(
name|heap
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|y
operator|=
name|z
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fibnode_insert_after
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|fibnode_t
name|a
decl_stmt|;
name|fibnode_t
name|b
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|==
name|a
operator|->
name|right
condition|)
block|{
name|a
operator|->
name|right
operator|=
name|b
expr_stmt|;
name|a
operator|->
name|left
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|right
operator|=
name|a
expr_stmt|;
name|b
operator|->
name|left
operator|=
name|a
expr_stmt|;
block|}
else|else
block|{
name|b
operator|->
name|right
operator|=
name|a
operator|->
name|right
expr_stmt|;
name|a
operator|->
name|right
operator|->
name|left
operator|=
name|b
expr_stmt|;
name|a
operator|->
name|right
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|left
operator|=
name|a
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|fibnode_t
name|fibnode_remove
parameter_list|(
name|node
parameter_list|)
name|fibnode_t
name|node
decl_stmt|;
block|{
name|fibnode_t
name|ret
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|node
operator|->
name|left
condition|)
name|ret
operator|=
name|NULL
expr_stmt|;
else|else
name|ret
operator|=
name|node
operator|->
name|left
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|parent
operator|!=
name|NULL
operator|&&
name|node
operator|->
name|parent
operator|->
name|child
operator|==
name|node
condition|)
name|node
operator|->
name|parent
operator|->
name|child
operator|=
name|ret
expr_stmt|;
name|node
operator|->
name|right
operator|->
name|left
operator|=
name|node
operator|->
name|left
expr_stmt|;
name|node
operator|->
name|left
operator|->
name|right
operator|=
name|node
operator|->
name|right
expr_stmt|;
name|node
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|left
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|right
operator|=
name|node
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

