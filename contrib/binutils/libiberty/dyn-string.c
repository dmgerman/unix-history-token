begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* An abstract string datatype.    Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.    Contributed by Mark Mitchell (mark@markmitchell.com).  This file is part of GNU CC.     GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"dyn-string.h"
end_include

begin_comment
comment|/* If this file is being compiled for inclusion in the C++ runtime    library, as part of the demangler implementation, we don't want to    abort if an allocation fails.  Instead, percolate an error code up    through the call chain.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IN_LIBGCC2
end_ifdef

begin_define
define|#
directive|define
name|RETURN_ON_ALLOCATION_FAILURE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Performs in-place initialization of a dyn_string struct.  This    function can be used with a dyn_string struct on the stack or    embedded in another object.  The contents of of the string itself    are still dynamically allocated.  The string initially is capable    of holding at least SPACE characeters, including the terminating    NUL.  If SPACE is 0, it will silently be increated to 1.       If RETURN_ON_ALLOCATION_FAILURE is defined and memory allocation    fails, returns 0.  Otherwise returns 1.  */
end_comment

begin_function
name|int
name|dyn_string_init
parameter_list|(
name|ds_struct_ptr
parameter_list|,
name|space
parameter_list|)
name|struct
name|dyn_string
modifier|*
name|ds_struct_ptr
decl_stmt|;
name|int
name|space
decl_stmt|;
block|{
comment|/* We need at least one byte in which to store the terminating NUL.  */
if|if
condition|(
name|space
operator|==
literal|0
condition|)
name|space
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|RETURN_ON_ALLOCATION_FAILURE
name|ds_struct_ptr
operator|->
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|space
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds_struct_ptr
operator|->
name|s
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
else|#
directive|else
name|ds_struct_ptr
operator|->
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|space
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ds_struct_ptr
operator|->
name|allocated
operator|=
name|space
expr_stmt|;
name|ds_struct_ptr
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|ds_struct_ptr
operator|->
name|s
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Create a new dynamic string capable of holding at least SPACE    characters, including the terminating NUL.  If SPACE is 0, it will    be silently increased to 1.  If RETURN_ON_ALLOCATION_FAILURE is    defined and memory allocation fails, returns NULL.  Otherwise    returns the newly allocated string.  */
end_comment

begin_function
name|dyn_string_t
name|dyn_string_new
parameter_list|(
name|space
parameter_list|)
name|int
name|space
decl_stmt|;
block|{
name|dyn_string_t
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|RETURN_ON_ALLOCATION_FAILURE
name|result
operator|=
operator|(
name|dyn_string_t
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dyn_string
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|dyn_string_init
argument_list|(
name|result
argument_list|,
name|space
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|#
directive|else
name|result
operator|=
operator|(
name|dyn_string_t
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dyn_string
argument_list|)
argument_list|)
expr_stmt|;
name|dyn_string_init
argument_list|(
name|result
argument_list|,
name|space
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Free the memory used by DS.  */
end_comment

begin_function
name|void
name|dyn_string_delete
parameter_list|(
name|ds
parameter_list|)
name|dyn_string_t
name|ds
decl_stmt|;
block|{
name|free
argument_list|(
name|ds
operator|->
name|s
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ds
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns the contents of DS in a buffer allocated with malloc.  It    is the caller's responsibility to deallocate the buffer using free.    DS is then set to the empty string.  Deletes DS itself.  */
end_comment

begin_function
name|char
modifier|*
name|dyn_string_release
parameter_list|(
name|ds
parameter_list|)
name|dyn_string_t
name|ds
decl_stmt|;
block|{
comment|/* Store the old buffer.  */
name|char
modifier|*
name|result
init|=
name|ds
operator|->
name|s
decl_stmt|;
comment|/* The buffer is no longer owned by DS.  */
name|ds
operator|->
name|s
operator|=
name|NULL
expr_stmt|;
comment|/* Delete DS.  */
name|free
argument_list|(
name|ds
argument_list|)
expr_stmt|;
comment|/* Return the old buffer.  */
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Increase the capacity of DS so it can hold at least SPACE    characters, plus the terminating NUL.  This function will not (at    present) reduce the capacity of DS.  Returns DS on success.      If RETURN_ON_ALLOCATION_FAILURE is defined and a memory allocation    operation fails, deletes DS and returns NULL.  */
end_comment

begin_function
name|dyn_string_t
name|dyn_string_resize
parameter_list|(
name|ds
parameter_list|,
name|space
parameter_list|)
name|dyn_string_t
name|ds
decl_stmt|;
name|int
name|space
decl_stmt|;
block|{
name|int
name|new_allocated
init|=
name|ds
operator|->
name|allocated
decl_stmt|;
comment|/* Increase SPACE to hold the NUL termination.  */
operator|++
name|space
expr_stmt|;
comment|/* Increase allocation by factors of two.  */
while|while
condition|(
name|space
operator|>
name|new_allocated
condition|)
name|new_allocated
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|new_allocated
operator|!=
name|ds
operator|->
name|allocated
condition|)
block|{
name|ds
operator|->
name|allocated
operator|=
name|new_allocated
expr_stmt|;
comment|/* We actually need more space.  */
ifdef|#
directive|ifdef
name|RETURN_ON_ALLOCATION_FAILURE
name|ds
operator|->
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|ds
operator|->
name|s
argument_list|,
name|ds
operator|->
name|allocated
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|s
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ds
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|#
directive|else
name|ds
operator|->
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|ds
operator|->
name|s
argument_list|,
name|ds
operator|->
name|allocated
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|ds
return|;
block|}
end_function

begin_comment
comment|/* Sets the contents of DS to the empty string.  */
end_comment

begin_function
name|void
name|dyn_string_clear
parameter_list|(
name|ds
parameter_list|)
name|dyn_string_t
name|ds
decl_stmt|;
block|{
comment|/* A dyn_string always has room for at least the NUL terminator.  */
name|ds
operator|->
name|s
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ds
operator|->
name|length
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Makes the contents of DEST the same as the contents of SRC.  DEST    and SRC must be distinct.  Returns 1 on success.  On failure, if    RETURN_ON_ALLOCATION_FAILURE, deletes DEST and returns 0.  */
end_comment

begin_function
name|int
name|dyn_string_copy
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|dyn_string_t
name|dest
decl_stmt|;
name|dyn_string_t
name|src
decl_stmt|;
block|{
if|if
condition|(
name|dest
operator|==
name|src
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Make room in DEST.  */
if|if
condition|(
name|dyn_string_resize
argument_list|(
name|dest
argument_list|,
name|src
operator|->
name|length
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Copy DEST into SRC.  */
name|strcpy
argument_list|(
name|dest
operator|->
name|s
argument_list|,
name|src
operator|->
name|s
argument_list|)
expr_stmt|;
comment|/* Update the size of DEST.  */
name|dest
operator|->
name|length
operator|=
name|src
operator|->
name|length
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Copies SRC, a NUL-terminated string, into DEST.  Returns 1 on    success.  On failure, if RETURN_ON_ALLOCATION_FAILURE, deletes DEST    and returns 0.  */
end_comment

begin_function
name|int
name|dyn_string_copy_cstr
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|dyn_string_t
name|dest
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
block|{
name|int
name|length
init|=
name|strlen
argument_list|(
name|src
argument_list|)
decl_stmt|;
comment|/* Make room in DEST.  */
if|if
condition|(
name|dyn_string_resize
argument_list|(
name|dest
argument_list|,
name|length
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Copy DEST into SRC.  */
name|strcpy
argument_list|(
name|dest
operator|->
name|s
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|/* Update the size of DEST.  */
name|dest
operator|->
name|length
operator|=
name|length
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Inserts SRC at the beginning of DEST.  DEST is expanded as    necessary.  SRC and DEST must be distinct.  Returns 1 on success.    On failure, if RETURN_ON_ALLOCATION_FAILURE, deletes DEST and    returns 0.  */
end_comment

begin_function
name|int
name|dyn_string_prepend
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|dyn_string_t
name|dest
decl_stmt|;
name|dyn_string_t
name|src
decl_stmt|;
block|{
return|return
name|dyn_string_insert
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
name|src
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Inserts SRC, a NUL-terminated string, at the beginning of DEST.    DEST is expanded as necessary.  Returns 1 on success.  On failure,    if RETURN_ON_ALLOCATION_FAILURE, deletes DEST and returns 0. */
end_comment

begin_function
name|int
name|dyn_string_prepend_cstr
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|dyn_string_t
name|dest
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
block|{
return|return
name|dyn_string_insert_cstr
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
name|src
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Inserts SRC into DEST starting at position POS.  DEST is expanded    as necessary.  SRC and DEST must be distinct.  Returns 1 on    success.  On failure, if RETURN_ON_ALLOCATION_FAILURE, deletes DEST    and returns 0.  */
end_comment

begin_function
name|int
name|dyn_string_insert
parameter_list|(
name|dest
parameter_list|,
name|pos
parameter_list|,
name|src
parameter_list|)
name|dyn_string_t
name|dest
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|dyn_string_t
name|src
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|src
operator|==
name|dest
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|dyn_string_resize
argument_list|(
name|dest
argument_list|,
name|dest
operator|->
name|length
operator|+
name|src
operator|->
name|length
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Make room for the insertion.  Be sure to copy the NUL.  */
for|for
control|(
name|i
operator|=
name|dest
operator|->
name|length
init|;
name|i
operator|>=
name|pos
condition|;
operator|--
name|i
control|)
name|dest
operator|->
name|s
index|[
name|i
operator|+
name|src
operator|->
name|length
index|]
operator|=
name|dest
operator|->
name|s
index|[
name|i
index|]
expr_stmt|;
comment|/* Splice in the new stuff.  */
name|strncpy
argument_list|(
name|dest
operator|->
name|s
operator|+
name|pos
argument_list|,
name|src
operator|->
name|s
argument_list|,
name|src
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* Compute the new length.  */
name|dest
operator|->
name|length
operator|+=
name|src
operator|->
name|length
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Inserts SRC, a NUL-terminated string, into DEST starting at    position POS.  DEST is expanded as necessary.  Returns 1 on    success.  On failure, RETURN_ON_ALLOCATION_FAILURE, deletes DEST    and returns 0.  */
end_comment

begin_function
name|int
name|dyn_string_insert_cstr
parameter_list|(
name|dest
parameter_list|,
name|pos
parameter_list|,
name|src
parameter_list|)
name|dyn_string_t
name|dest
decl_stmt|;
name|int
name|pos
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|length
init|=
name|strlen
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|dyn_string_resize
argument_list|(
name|dest
argument_list|,
name|dest
operator|->
name|length
operator|+
name|length
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Make room for the insertion.  Be sure to copy the NUL.  */
for|for
control|(
name|i
operator|=
name|dest
operator|->
name|length
init|;
name|i
operator|>=
name|pos
condition|;
operator|--
name|i
control|)
name|dest
operator|->
name|s
index|[
name|i
operator|+
name|length
index|]
operator|=
name|dest
operator|->
name|s
index|[
name|i
index|]
expr_stmt|;
comment|/* Splice in the new stuff.  */
name|strncpy
argument_list|(
name|dest
operator|->
name|s
operator|+
name|pos
argument_list|,
name|src
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* Compute the new length.  */
name|dest
operator|->
name|length
operator|+=
name|length
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Inserts character C into DEST starting at position POS.  DEST is    expanded as necessary.  Returns 1 on success.  On failure,    RETURN_ON_ALLOCATION_FAILURE, deletes DEST and returns 0.  */
end_comment

begin_function
name|int
name|dyn_string_insert_char
parameter_list|(
name|dest
parameter_list|,
name|pos
parameter_list|,
name|c
parameter_list|)
name|dyn_string_t
name|dest
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dyn_string_resize
argument_list|(
name|dest
argument_list|,
name|dest
operator|->
name|length
operator|+
literal|1
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Make room for the insertion.  Be sure to copy the NUL.  */
for|for
control|(
name|i
operator|=
name|dest
operator|->
name|length
init|;
name|i
operator|>=
name|pos
condition|;
operator|--
name|i
control|)
name|dest
operator|->
name|s
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|dest
operator|->
name|s
index|[
name|i
index|]
expr_stmt|;
comment|/* Add the new character.  */
name|dest
operator|->
name|s
index|[
name|pos
index|]
operator|=
name|c
expr_stmt|;
comment|/* Compute the new length.  */
operator|++
name|dest
operator|->
name|length
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Append S to DS, resizing DS if necessary.  Returns 1 on success.    On failure, if RETURN_ON_ALLOCATION_FAILURE, deletes DEST and    returns 0.  */
end_comment

begin_function
name|int
name|dyn_string_append
parameter_list|(
name|dest
parameter_list|,
name|s
parameter_list|)
name|dyn_string_t
name|dest
decl_stmt|;
name|dyn_string_t
name|s
decl_stmt|;
block|{
if|if
condition|(
name|dyn_string_resize
argument_list|(
name|dest
argument_list|,
name|dest
operator|->
name|length
operator|+
name|s
operator|->
name|length
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|strcpy
argument_list|(
name|dest
operator|->
name|s
operator|+
name|dest
operator|->
name|length
argument_list|,
name|s
operator|->
name|s
argument_list|)
expr_stmt|;
name|dest
operator|->
name|length
operator|+=
name|s
operator|->
name|length
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Append the NUL-terminated string S to DS, resizing DS if necessary.    Returns 1 on success.  On failure, if RETURN_ON_ALLOCATION_FAILURE,    deletes DEST and returns 0.  */
end_comment

begin_function
name|int
name|dyn_string_append_cstr
parameter_list|(
name|dest
parameter_list|,
name|s
parameter_list|)
name|dyn_string_t
name|dest
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
comment|/* The new length is the old length plus the size of our string, plus      one for the null at the end.  */
if|if
condition|(
name|dyn_string_resize
argument_list|(
name|dest
argument_list|,
name|dest
operator|->
name|length
operator|+
name|len
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|strcpy
argument_list|(
name|dest
operator|->
name|s
operator|+
name|dest
operator|->
name|length
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|dest
operator|->
name|length
operator|+=
name|len
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Appends C to the end of DEST.  Returns 1 on success.  On failiure,    if RETURN_ON_ALLOCATION_FAILURE, deletes DEST and returns 0.  */
end_comment

begin_function
name|int
name|dyn_string_append_char
parameter_list|(
name|dest
parameter_list|,
name|c
parameter_list|)
name|dyn_string_t
name|dest
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
comment|/* Make room for the extra character.  */
if|if
condition|(
name|dyn_string_resize
argument_list|(
name|dest
argument_list|,
name|dest
operator|->
name|length
operator|+
literal|1
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Append the character; it will overwrite the old NUL.  */
name|dest
operator|->
name|s
index|[
name|dest
operator|->
name|length
index|]
operator|=
name|c
expr_stmt|;
comment|/* Add a new NUL at the end.  */
name|dest
operator|->
name|s
index|[
name|dest
operator|->
name|length
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Update the length.  */
operator|++
operator|(
name|dest
operator|->
name|length
operator|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Sets the contents of DEST to the substring of SRC starting at START    and ending before END.  START must be less than or equal to END,    and both must be between zero and the length of SRC, inclusive.    Returns 1 on success.  On failure, if RETURN_ON_ALLOCATION_FAILURE,    deletes DEST and returns 0.  */
end_comment

begin_function
name|int
name|dyn_string_substring
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|dyn_string_t
name|dest
decl_stmt|;
name|dyn_string_t
name|src
decl_stmt|;
name|int
name|start
decl_stmt|;
name|int
name|end
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|length
init|=
name|end
operator|-
name|start
decl_stmt|;
if|if
condition|(
name|start
operator|>
name|end
operator|||
name|start
operator|>
name|src
operator|->
name|length
operator|||
name|end
operator|>
name|src
operator|->
name|length
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Make room for the substring.  */
if|if
condition|(
name|dyn_string_resize
argument_list|(
name|dest
argument_list|,
name|length
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Copy the characters in the substring,  */
for|for
control|(
name|i
operator|=
name|length
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|dest
operator|->
name|s
index|[
name|i
index|]
operator|=
name|src
operator|->
name|s
index|[
name|start
operator|+
name|i
index|]
expr_stmt|;
comment|/* NUL-terimate the result.  */
name|dest
operator|->
name|s
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Record the length of the substring.  */
name|dest
operator|->
name|length
operator|=
name|length
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if DS1 and DS2 have the same contents.  */
end_comment

begin_function
name|int
name|dyn_string_eq
parameter_list|(
name|ds1
parameter_list|,
name|ds2
parameter_list|)
name|dyn_string_t
name|ds1
decl_stmt|;
name|dyn_string_t
name|ds2
decl_stmt|;
block|{
comment|/* If DS1 and DS2 have different lengths, they must not be the same.  */
if|if
condition|(
name|ds1
operator|->
name|length
operator|!=
name|ds2
operator|->
name|length
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|!
name|strcmp
argument_list|(
name|ds1
operator|->
name|s
argument_list|,
name|ds2
operator|->
name|s
argument_list|)
return|;
block|}
end_function

end_unit

