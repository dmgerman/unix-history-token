begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Demangler for GNU C++    Copyright 1989, 1991, 1994, 1995, 1996, 1997, 1998, 1999,    2000 Free Software Foundation, Inc.    Written by James Clark (jjc@jclark.uucp)    Rewritten by Fred Fish (fnf@cygnus.com) for ARM and Lucid demangling    Modified by Satish Pai (pai@apollo.hp.com) for HP demangling  This file is part of the libiberty library. Libiberty is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  Libiberty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with libiberty; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file exports two functions; cplus_mangle_opname and cplus_demangle.     This file imports xmalloc and xrealloc, which are like malloc and    realloc except that they generate a fatal error if there is no    available memory.  */
end_comment

begin_comment
comment|/* This file lives in both GCC and libiberty.  When making changes, please    try not to break either.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"safe-ctype.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|realloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<demangle.h>
end_include

begin_undef
undef|#
directive|undef
name|CURRENT_DEMANGLING_STYLE
end_undef

begin_define
define|#
directive|define
name|CURRENT_DEMANGLING_STYLE
value|work->options
end_define

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ada_demangle
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|min
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|(((X)< (Y)) ? (X) : (Y))
end_define

begin_comment
comment|/* A value at least one greater than the maximum number of characters    that will be output when using the `%d' format with `printf'.  */
end_comment

begin_define
define|#
directive|define
name|INTBUF_SIZE
value|32
end_define

begin_decl_stmt
specifier|extern
name|void
name|fancy_abort
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mystrstr
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|mystrstr
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
specifier|const
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
specifier|const
name|char
modifier|*
name|p
init|=
name|s1
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|s2
argument_list|)
decl_stmt|;
for|for
control|(
init|;
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
operator|*
name|s2
argument_list|)
operator|)
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
name|s2
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|p
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* In order to allow a single demangler executable to demangle strings    using various common values of CPLUS_MARKER, as well as any specific    one set at compile time, we maintain a string containing all the    commonly used ones, and check to see if the marker we are looking for    is in that string.  CPLUS_MARKER is usually '$' on systems where the    assembler can deal with that.  Where the assembler can't, it's usually    '.' (but on many systems '.' is used for other things).  We put the    current defined CPLUS_MARKER first (which defaults to '$'), followed    by the next most common value, followed by an explicit '$' in case    the value of CPLUS_MARKER is not '$'.     We could avoid this if we could just get g++ to tell us what the actual    cplus marker character is as part of the debug information, perhaps by    ensuring that it is the character that terminates the gcc<n>_compiled    marker symbol (FIXME).  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CPLUS_MARKER
argument_list|)
end_if

begin_define
define|#
directive|define
name|CPLUS_MARKER
value|'$'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|enum
name|demangling_styles
name|current_demangling_style
init|=
name|auto_demangling
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|cplus_markers
index|[]
init|=
block|{
name|CPLUS_MARKER
block|,
literal|'.'
block|,
literal|'$'
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|char_str
index|[
literal|2
index|]
init|=
block|{
literal|'\000'
block|,
literal|'\000'
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|set_cplus_marker_for_demangling
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
name|cplus_markers
index|[
literal|0
index|]
operator|=
name|ch
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|string
comment|/* Beware: these aren't required to be */
block|{
comment|/*  '\0' terminated.  */
name|char
modifier|*
name|b
decl_stmt|;
comment|/* pointer to start of string */
name|char
modifier|*
name|p
decl_stmt|;
comment|/* pointer after last character */
name|char
modifier|*
name|e
decl_stmt|;
comment|/* pointer after end of allocated space */
block|}
name|string
typedef|;
end_typedef

begin_comment
comment|/* Stuff that is shared between sub-routines.    Using a shared structure allows cplus_demangle to be reentrant.  */
end_comment

begin_struct
struct|struct
name|work_stuff
block|{
name|int
name|options
decl_stmt|;
name|char
modifier|*
modifier|*
name|typevec
decl_stmt|;
name|char
modifier|*
modifier|*
name|ktypevec
decl_stmt|;
name|char
modifier|*
modifier|*
name|btypevec
decl_stmt|;
name|int
name|numk
decl_stmt|;
name|int
name|numb
decl_stmt|;
name|int
name|ksize
decl_stmt|;
name|int
name|bsize
decl_stmt|;
name|int
name|ntypes
decl_stmt|;
name|int
name|typevec_size
decl_stmt|;
name|int
name|constructor
decl_stmt|;
name|int
name|destructor
decl_stmt|;
name|int
name|static_type
decl_stmt|;
comment|/* A static member function */
name|int
name|temp_start
decl_stmt|;
comment|/* index in demangled to start of template args */
name|int
name|type_quals
decl_stmt|;
comment|/* The type qualifiers.  */
name|int
name|dllimported
decl_stmt|;
comment|/* Symbol imported from a PE DLL */
name|char
modifier|*
modifier|*
name|tmpl_argvec
decl_stmt|;
comment|/* Template function arguments. */
name|int
name|ntmpl_args
decl_stmt|;
comment|/* The number of template function arguments. */
name|int
name|forgetting_types
decl_stmt|;
comment|/* Nonzero if we are not remembering the types 			   we see.  */
name|string
modifier|*
name|previous_argument
decl_stmt|;
comment|/* The last function argument demangled.  */
name|int
name|nrepeats
decl_stmt|;
comment|/* The number of times to repeat the previous 			   argument.  */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PRINT_ANSI_QUALIFIERS
value|(work -> options& DMGL_ANSI)
end_define

begin_define
define|#
directive|define
name|PRINT_ARG_TYPES
value|(work -> options& DMGL_PARAMS)
end_define

begin_struct
specifier|static
specifier|const
struct|struct
name|optable
block|{
specifier|const
name|char
modifier|*
name|in
decl_stmt|;
specifier|const
name|char
modifier|*
name|out
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|}
name|optable
index|[]
init|=
block|{
block|{
literal|"nw"
block|,
literal|" new"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* new (1.92,	 ansi) */
block|{
literal|"dl"
block|,
literal|" delete"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* new (1.92,	 ansi) */
block|{
literal|"new"
block|,
literal|" new"
block|,
literal|0
block|}
block|,
comment|/* old (1.91,	 and 1.x) */
block|{
literal|"delete"
block|,
literal|" delete"
block|,
literal|0
block|}
block|,
comment|/* old (1.91,	 and 1.x) */
block|{
literal|"vn"
block|,
literal|" new []"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* GNU, pending ansi */
block|{
literal|"vd"
block|,
literal|" delete []"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* GNU, pending ansi */
block|{
literal|"as"
block|,
literal|"="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"ne"
block|,
literal|"!="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* old, ansi */
block|{
literal|"eq"
block|,
literal|"=="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* old,	ansi */
block|{
literal|"ge"
block|,
literal|">="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* old,	ansi */
block|{
literal|"gt"
block|,
literal|">"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* old,	ansi */
block|{
literal|"le"
block|,
literal|"<="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* old,	ansi */
block|{
literal|"lt"
block|,
literal|"<"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* old,	ansi */
block|{
literal|"plus"
block|,
literal|"+"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"pl"
block|,
literal|"+"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"apl"
block|,
literal|"+="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"minus"
block|,
literal|"-"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"mi"
block|,
literal|"-"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"ami"
block|,
literal|"-="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"mult"
block|,
literal|"*"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"ml"
block|,
literal|"*"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"amu"
block|,
literal|"*="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi (ARM/Lucid) */
block|{
literal|"aml"
block|,
literal|"*="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi (GNU/g++) */
block|{
literal|"convert"
block|,
literal|"+"
block|,
literal|0
block|}
block|,
comment|/* old (unary +) */
block|{
literal|"negate"
block|,
literal|"-"
block|,
literal|0
block|}
block|,
comment|/* old (unary -) */
block|{
literal|"trunc_mod"
block|,
literal|"%"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"md"
block|,
literal|"%"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"amd"
block|,
literal|"%="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"trunc_div"
block|,
literal|"/"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"dv"
block|,
literal|"/"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"adv"
block|,
literal|"/="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"truth_andif"
block|,
literal|"&&"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"aa"
block|,
literal|"&&"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"truth_orif"
block|,
literal|"||"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"oo"
block|,
literal|"||"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"truth_not"
block|,
literal|"!"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"nt"
block|,
literal|"!"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"postincrement"
block|,
literal|"++"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"pp"
block|,
literal|"++"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"postdecrement"
block|,
literal|"--"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"mm"
block|,
literal|"--"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"bit_ior"
block|,
literal|"|"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"or"
block|,
literal|"|"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"aor"
block|,
literal|"|="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"bit_xor"
block|,
literal|"^"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"er"
block|,
literal|"^"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"aer"
block|,
literal|"^="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"bit_and"
block|,
literal|"&"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"ad"
block|,
literal|"&"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"aad"
block|,
literal|"&="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"bit_not"
block|,
literal|"~"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"co"
block|,
literal|"~"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"call"
block|,
literal|"()"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"cl"
block|,
literal|"()"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"alshift"
block|,
literal|"<<"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"ls"
block|,
literal|"<<"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"als"
block|,
literal|"<<="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"arshift"
block|,
literal|">>"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"rs"
block|,
literal|">>"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"ars"
block|,
literal|">>="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"component"
block|,
literal|"->"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"pt"
block|,
literal|"->"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi; Lucid C++ form */
block|{
literal|"rf"
block|,
literal|"->"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi; ARM/GNU form */
block|{
literal|"indirect"
block|,
literal|"*"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"method_call"
block|,
literal|"->()"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"addr"
block|,
literal|"&"
block|,
literal|0
block|}
block|,
comment|/* old (unary&) */
block|{
literal|"array"
block|,
literal|"[]"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"vc"
block|,
literal|"[]"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"compound"
block|,
literal|", "
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"cm"
block|,
literal|", "
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"cond"
block|,
literal|"?:"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"cn"
block|,
literal|"?:"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* pseudo-ansi */
block|{
literal|"max"
block|,
literal|">?"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"mx"
block|,
literal|">?"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* pseudo-ansi */
block|{
literal|"min"
block|,
literal|"<?"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"mn"
block|,
literal|"<?"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* pseudo-ansi */
block|{
literal|"nop"
block|,
literal|""
block|,
literal|0
block|}
block|,
comment|/* old (for operator=) */
block|{
literal|"rm"
block|,
literal|"->*"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"sz"
block|,
literal|"sizeof "
block|,
name|DMGL_ANSI
block|}
comment|/* pseudo-ansi */
block|}
struct|;
end_struct

begin_comment
comment|/* These values are used to indicate the various type varieties.    They are all non-zero so that they can be used as `success'    values.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|type_kind_t
block|{
name|tk_none
block|,
name|tk_pointer
block|,
name|tk_reference
block|,
name|tk_integral
block|,
name|tk_bool
block|,
name|tk_char
block|,
name|tk_real
block|}
name|type_kind_t
typedef|;
end_typedef

begin_decl_stmt
name|struct
name|demangler_engine
name|libiberty_demanglers
index|[]
init|=
block|{
block|{
name|AUTO_DEMANGLING_STYLE_STRING
block|,
name|auto_demangling
block|,
literal|"Automatic selection based on executable"
block|}
block|,
block|{
name|GNU_DEMANGLING_STYLE_STRING
block|,
name|gnu_demangling
block|,
literal|"GNU (g++) style demangling"
block|}
block|,
block|{
name|LUCID_DEMANGLING_STYLE_STRING
block|,
name|lucid_demangling
block|,
literal|"Lucid (lcc) style demangling"
block|}
block|,
block|{
name|ARM_DEMANGLING_STYLE_STRING
block|,
name|arm_demangling
block|,
literal|"ARM style demangling"
block|}
block|,
block|{
name|HP_DEMANGLING_STYLE_STRING
block|,
name|hp_demangling
block|,
literal|"HP (aCC) style demangling"
block|}
block|,
block|{
name|EDG_DEMANGLING_STYLE_STRING
block|,
name|edg_demangling
block|,
literal|"EDG style demangling"
block|}
block|,
block|{
name|GNU_V3_DEMANGLING_STYLE_STRING
block|,
name|gnu_v3_demangling
block|,
literal|"GNU (g++) V3 ABI-style demangling"
block|}
block|,
block|{
name|JAVA_DEMANGLING_STYLE_STRING
block|,
name|java_demangling
block|,
literal|"Java style demangling"
block|}
block|,
block|{
name|GNAT_DEMANGLING_STYLE_STRING
block|,
name|gnat_demangling
block|,
literal|"GNAT style demangling"
block|}
block|,
block|{
name|NULL
block|,
name|unknown_demangling
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|STRING_EMPTY
parameter_list|(
name|str
parameter_list|)
value|((str) -> b == (str) -> p)
end_define

begin_define
define|#
directive|define
name|PREPEND_BLANK
parameter_list|(
name|str
parameter_list|)
value|{if (!STRING_EMPTY(str)) \     string_prepend(str, " ");}
end_define

begin_define
define|#
directive|define
name|APPEND_BLANK
parameter_list|(
name|str
parameter_list|)
value|{if (!STRING_EMPTY(str)) \     string_append(str, " ");}
end_define

begin_define
define|#
directive|define
name|LEN_STRING
parameter_list|(
name|str
parameter_list|)
value|( (STRING_EMPTY(str))?0:((str)->p - (str)->b))
end_define

begin_comment
comment|/* The scope separator appropriate for the language being demangled.  */
end_comment

begin_define
define|#
directive|define
name|SCOPE_STRING
parameter_list|(
name|work
parameter_list|)
value|((work->options& DMGL_JAVA) ? "." : "::")
end_define

begin_define
define|#
directive|define
name|ARM_VTABLE_STRING
value|"__vtbl__"
end_define

begin_comment
comment|/* Lucid/ARM virtual table prefix */
end_comment

begin_define
define|#
directive|define
name|ARM_VTABLE_STRLEN
value|8
end_define

begin_comment
comment|/* strlen (ARM_VTABLE_STRING) */
end_comment

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|delete_work_stuff
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_non_B_K_work_stuff
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mop_up
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
name|string
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|squangle_mop_up
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|work_stuff_copy_to_from
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
expr|struct
name|work_stuff
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int demangle_method_args PARAMS ((struct work_stuff *, const char **, string *));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|internal_cplus_demangle
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_template_template_parm
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
name|work
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_template
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
name|work
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|,
name|string
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|arm_pt
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_class_name
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_qualified
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_class
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_fund_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_signature
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_prefix
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gnu_special
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|arm_special
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_need
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_delete
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_init
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_clear
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int string_empty PARAMS ((string *));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|string_append
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_appends
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_appendn
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_prepend
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_prependn
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_append_template_idx
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_count
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|consume_count
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|consume_count_with_underscores
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_args
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_nested_args
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_arg
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|demangle_function_name
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iterate_demangle_function
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remember_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remember_Btype
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|register_Btype
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remember_Ktype
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|forget_types
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|forget_B_and_K_types
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_prepends
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_template_value_parm
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|,
name|type_kind_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_hpacc_template_const_value
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_hpacc_template_literal
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|snarf_numeric_literal
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* There is a TYPE_QUAL value for each type qualifier.  They can be    combined by bitwise-or to form the complete set of qualifiers for a    type.  */
end_comment

begin_define
define|#
directive|define
name|TYPE_UNQUALIFIED
value|0x0
end_define

begin_define
define|#
directive|define
name|TYPE_QUAL_CONST
value|0x1
end_define

begin_define
define|#
directive|define
name|TYPE_QUAL_VOLATILE
value|0x2
end_define

begin_define
define|#
directive|define
name|TYPE_QUAL_RESTRICT
value|0x4
end_define

begin_decl_stmt
specifier|static
name|int
name|code_for_qualifier
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|qualifier_string
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|demangle_qualifier
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_expression
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|,
name|type_kind_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_integral_value
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_real_value
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|demangle_arm_hp_template
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|recursively_demangle
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|grow_vect
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|,
name|size_t
operator|*
operator|,
name|size_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Translate count to integer, consuming tokens in the process.    Conversion terminates on the first non-digit character.     Trying to consume something that isn't a count results in no    consumption of input and a return of -1.     Overflow consumes the rest of the digits, and returns -1.  */
end_comment

begin_function
specifier|static
name|int
name|consume_count
parameter_list|(
name|type
parameter_list|)
specifier|const
name|char
modifier|*
modifier|*
name|type
decl_stmt|;
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|type
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|type
argument_list|)
condition|)
block|{
name|count
operator|*=
literal|10
expr_stmt|;
comment|/* Check for overflow. 	 We assume that count is represented using two's-complement; 	 no power of two is divisible by ten, so if an overflow occurs 	 when multiplying by ten, the result will not be a multiple of 	 ten.  */
if|if
condition|(
operator|(
name|count
operator|%
literal|10
operator|)
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|type
argument_list|)
condition|)
operator|(
operator|*
name|type
operator|)
operator|++
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|count
operator|+=
operator|*
operator|*
name|type
operator|-
literal|'0'
expr_stmt|;
operator|(
operator|*
name|type
operator|)
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like consume_count, but for counts that are preceded and followed    by '_' if they are greater than 10.  Also, -1 is returned for    failure, since 0 can be a valid value.  */
end_comment

begin_function
specifier|static
name|int
name|consume_count_with_underscores
parameter_list|(
name|mangled
parameter_list|)
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
block|{
name|int
name|idx
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'_'
condition|)
block|{
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|mangled
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|idx
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|mangled
operator|!=
literal|'_'
condition|)
comment|/* The trailing underscore was missing. */
return|return
operator|-
literal|1
return|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
operator|*
name|mangled
operator|<
literal|'0'
operator|||
operator|*
operator|*
name|mangled
operator|>
literal|'9'
condition|)
return|return
operator|-
literal|1
return|;
name|idx
operator|=
operator|*
operator|*
name|mangled
operator|-
literal|'0'
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* C is the code for a type-qualifier.  Return the TYPE_QUAL    corresponding to this qualifier.  */
end_comment

begin_function
specifier|static
name|int
name|code_for_qualifier
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'C'
case|:
return|return
name|TYPE_QUAL_CONST
return|;
case|case
literal|'V'
case|:
return|return
name|TYPE_QUAL_VOLATILE
return|;
case|case
literal|'u'
case|:
return|return
name|TYPE_QUAL_RESTRICT
return|;
default|default:
break|break;
block|}
comment|/* C was an invalid qualifier.  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the string corresponding to the qualifiers given by    TYPE_QUALS.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|qualifier_string
parameter_list|(
name|type_quals
parameter_list|)
name|int
name|type_quals
decl_stmt|;
block|{
switch|switch
condition|(
name|type_quals
condition|)
block|{
case|case
name|TYPE_UNQUALIFIED
case|:
return|return
literal|""
return|;
case|case
name|TYPE_QUAL_CONST
case|:
return|return
literal|"const"
return|;
case|case
name|TYPE_QUAL_VOLATILE
case|:
return|return
literal|"volatile"
return|;
case|case
name|TYPE_QUAL_RESTRICT
case|:
return|return
literal|"__restrict"
return|;
case|case
name|TYPE_QUAL_CONST
operator||
name|TYPE_QUAL_VOLATILE
case|:
return|return
literal|"const volatile"
return|;
case|case
name|TYPE_QUAL_CONST
operator||
name|TYPE_QUAL_RESTRICT
case|:
return|return
literal|"const __restrict"
return|;
case|case
name|TYPE_QUAL_VOLATILE
operator||
name|TYPE_QUAL_RESTRICT
case|:
return|return
literal|"volatile __restrict"
return|;
case|case
name|TYPE_QUAL_CONST
operator||
name|TYPE_QUAL_VOLATILE
operator||
name|TYPE_QUAL_RESTRICT
case|:
return|return
literal|"const volatile __restrict"
return|;
default|default:
break|break;
block|}
comment|/* TYPE_QUALS was an invalid qualifier set.  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* C is the code for a type-qualifier.  Return the string    corresponding to this qualifier.  This function should only be    called with a valid qualifier code.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|demangle_qualifier
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
return|return
name|qualifier_string
argument_list|(
name|code_for_qualifier
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|cplus_demangle_opname
parameter_list|(
name|opname
parameter_list|,
name|result
parameter_list|,
name|options
parameter_list|)
specifier|const
name|char
modifier|*
name|opname
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|options
decl_stmt|;
block|{
name|int
name|len
decl_stmt|,
name|len1
decl_stmt|,
name|ret
decl_stmt|;
name|string
name|type
decl_stmt|;
name|struct
name|work_stuff
name|work
index|[
literal|1
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|tem
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|opname
argument_list|)
expr_stmt|;
name|result
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
name|work
operator|->
name|options
operator|=
name|options
expr_stmt|;
if|if
condition|(
name|opname
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|opname
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|opname
index|[
literal|2
index|]
operator|==
literal|'o'
operator|&&
name|opname
index|[
literal|3
index|]
operator|==
literal|'p'
condition|)
block|{
comment|/* ANSI.  */
comment|/* type conversion operator.  */
name|tem
operator|=
name|opname
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|do_type
argument_list|(
name|work
argument_list|,
operator|&
name|tem
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
name|strcat
argument_list|(
name|result
argument_list|,
literal|"operator "
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|result
argument_list|,
name|type
operator|.
name|b
argument_list|,
name|type
operator|.
name|p
operator|-
name|type
operator|.
name|b
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|type
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|opname
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|opname
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|ISLOWER
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|opname
index|[
literal|2
index|]
argument_list|)
operator|&&
name|ISLOWER
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|opname
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|opname
index|[
literal|4
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Operator.  */
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|optable
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|)
operator|==
literal|2
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|opname
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|result
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|result
argument_list|,
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|opname
index|[
literal|2
index|]
operator|==
literal|'a'
operator|&&
name|opname
index|[
literal|5
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Assignment.  */
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|optable
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|)
operator|==
literal|3
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|opname
operator|+
literal|2
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|result
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|result
argument_list|,
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|len
operator|>=
literal|3
operator|&&
name|opname
index|[
literal|0
index|]
operator|==
literal|'o'
operator|&&
name|opname
index|[
literal|1
index|]
operator|==
literal|'p'
operator|&&
name|strchr
argument_list|(
name|cplus_markers
argument_list|,
name|opname
index|[
literal|2
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* see if it's an assignment expression */
if|if
condition|(
name|len
operator|>=
literal|10
comment|/* op$assign_ */
operator|&&
name|memcmp
argument_list|(
name|opname
operator|+
literal|3
argument_list|,
literal|"assign_"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|optable
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|len1
operator|=
name|len
operator|-
literal|10
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|)
operator|==
name|len1
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|opname
operator|+
literal|10
argument_list|,
name|len1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|result
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|result
argument_list|,
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|result
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|optable
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|len1
operator|=
name|len
operator|-
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|)
operator|==
name|len1
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|opname
operator|+
literal|3
argument_list|,
name|len1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|result
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|result
argument_list|,
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|len
operator|>=
literal|5
operator|&&
name|memcmp
argument_list|(
name|opname
argument_list|,
literal|"type"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|&&
name|strchr
argument_list|(
name|cplus_markers
argument_list|,
name|opname
index|[
literal|4
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* type conversion operator */
name|tem
operator|=
name|opname
operator|+
literal|5
expr_stmt|;
if|if
condition|(
name|do_type
argument_list|(
name|work
argument_list|,
operator|&
name|tem
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
name|strcat
argument_list|(
name|result
argument_list|,
literal|"operator "
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|result
argument_list|,
name|type
operator|.
name|b
argument_list|,
name|type
operator|.
name|p
operator|-
name|type
operator|.
name|b
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|type
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|squangle_mop_up
argument_list|(
name|work
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Takes operator name as e.g. "++" and returns mangled    operator name (e.g. "postincrement_expr"), or NULL if not found.     If OPTIONS& DMGL_ANSI == 1, return the ANSI name;    if OPTIONS& DMGL_ANSI == 0, return the old GNU name.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cplus_mangle_opname
parameter_list|(
name|opname
parameter_list|,
name|options
parameter_list|)
specifier|const
name|char
modifier|*
name|opname
decl_stmt|;
name|int
name|options
decl_stmt|;
block|{
name|size_t
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|opname
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|optable
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
operator|==
name|len
operator|&&
operator|(
name|options
operator|&
name|DMGL_ANSI
operator|)
operator|==
operator|(
name|optable
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|DMGL_ANSI
operator|)
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|,
name|opname
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|optable
index|[
name|i
index|]
operator|.
name|in
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add a routine to set the demangling style to be sure it is valid and    allow for any demangler initialization that maybe necessary. */
end_comment

begin_function
name|enum
name|demangling_styles
name|cplus_demangle_set_style
parameter_list|(
name|style
parameter_list|)
name|enum
name|demangling_styles
name|style
decl_stmt|;
block|{
name|struct
name|demangler_engine
modifier|*
name|demangler
init|=
name|libiberty_demanglers
decl_stmt|;
for|for
control|(
init|;
name|demangler
operator|->
name|demangling_style
operator|!=
name|unknown_demangling
condition|;
operator|++
name|demangler
control|)
if|if
condition|(
name|style
operator|==
name|demangler
operator|->
name|demangling_style
condition|)
block|{
name|current_demangling_style
operator|=
name|style
expr_stmt|;
return|return
name|current_demangling_style
return|;
block|}
return|return
name|unknown_demangling
return|;
block|}
end_function

begin_comment
comment|/* Do string name to style translation */
end_comment

begin_function
name|enum
name|demangling_styles
name|cplus_demangle_name_to_style
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|demangler_engine
modifier|*
name|demangler
init|=
name|libiberty_demanglers
decl_stmt|;
for|for
control|(
init|;
name|demangler
operator|->
name|demangling_style
operator|!=
name|unknown_demangling
condition|;
operator|++
name|demangler
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|demangler
operator|->
name|demangling_style_name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|demangler
operator|->
name|demangling_style
return|;
return|return
name|unknown_demangling
return|;
block|}
end_function

begin_comment
comment|/* char *cplus_demangle (const char *mangled, int options)     If MANGLED is a mangled function name produced by GNU C++, then    a pointer to a malloced string giving a C++ representation    of the name will be returned; otherwise NULL will be returned.    It is the caller's responsibility to free the string which    is returned.     The OPTIONS arg may contain one or more of the following bits:     	DMGL_ANSI	ANSI qualifiers such as `const' and `void' are 			included. 	DMGL_PARAMS	Function parameters are included.     For example,     cplus_demangle ("foo__1Ai", DMGL_PARAMS)		=> "A::foo(int)"    cplus_demangle ("foo__1Ai", DMGL_PARAMS | DMGL_ANSI)	=> "A::foo(int)"    cplus_demangle ("foo__1Ai", 0)			=> "A::foo"     cplus_demangle ("foo__1Afe", DMGL_PARAMS)		=> "A::foo(float,...)"    cplus_demangle ("foo__1Afe", DMGL_PARAMS | DMGL_ANSI)=> "A::foo(float,...)"    cplus_demangle ("foo__1Afe", 0)			=> "A::foo"     Note that any leading underscores, or other such characters prepended by    the compilation system, are presumed to have already been stripped from    MANGLED.  */
end_comment

begin_function
name|char
modifier|*
name|cplus_demangle
parameter_list|(
name|mangled
parameter_list|,
name|options
parameter_list|)
specifier|const
name|char
modifier|*
name|mangled
decl_stmt|;
name|int
name|options
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|struct
name|work_stuff
name|work
index|[
literal|1
index|]
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
name|work
operator|->
name|options
operator|=
name|options
expr_stmt|;
if|if
condition|(
operator|(
name|work
operator|->
name|options
operator|&
name|DMGL_STYLE_MASK
operator|)
operator|==
literal|0
condition|)
name|work
operator|->
name|options
operator||=
operator|(
name|int
operator|)
name|current_demangling_style
operator|&
name|DMGL_STYLE_MASK
expr_stmt|;
comment|/* The V3 ABI demangling is implemented elsewhere.  */
if|if
condition|(
name|GNU_V3_DEMANGLING
operator|||
name|AUTO_DEMANGLING
condition|)
block|{
name|ret
operator|=
name|cplus_demangle_v3
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|||
name|GNU_V3_DEMANGLING
condition|)
return|return
name|ret
return|;
block|}
if|if
condition|(
name|GNAT_DEMANGLING
condition|)
return|return
name|ada_demangle
argument_list|(
name|mangled
argument_list|,
name|options
argument_list|)
return|;
name|ret
operator|=
name|internal_cplus_demangle
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|)
expr_stmt|;
name|squangle_mop_up
argument_list|(
name|work
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Assuming *OLD_VECT points to an array of *SIZE objects of size    ELEMENT_SIZE, grow it to contain at least MIN_SIZE objects,    updating *OLD_VECT and *SIZE as necessary.  */
end_comment

begin_function
specifier|static
name|void
name|grow_vect
parameter_list|(
name|old_vect
parameter_list|,
name|size
parameter_list|,
name|min_size
parameter_list|,
name|element_size
parameter_list|)
name|void
modifier|*
modifier|*
name|old_vect
decl_stmt|;
name|size_t
modifier|*
name|size
decl_stmt|;
name|size_t
name|min_size
decl_stmt|;
name|int
name|element_size
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|size
operator|<
name|min_size
condition|)
block|{
operator|*
name|size
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|size
operator|<
name|min_size
condition|)
operator|*
name|size
operator|=
name|min_size
expr_stmt|;
operator|*
name|old_vect
operator|=
name|xrealloc
argument_list|(
operator|*
name|old_vect
argument_list|,
operator|*
name|size
operator|*
name|element_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Demangle ada names:    1. Discard final __{DIGIT}+ or ${DIGIT}+    2. Convert other instances of embedded "__" to `.'.    3. Discard leading _ada_.    4. Remove everything after first ___ if it is followed by 'X'.    5. Put symbols that should be suppressed in<...> brackets.    The resulting string is valid until the next call of ada_demangle.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ada_demangle
parameter_list|(
name|mangled
parameter_list|,
name|option
parameter_list|)
specifier|const
name|char
modifier|*
name|mangled
decl_stmt|;
name|int
name|option
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|len0
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|demangled
init|=
name|NULL
decl_stmt|;
name|int
name|at_start_name
decl_stmt|;
name|int
name|changed
decl_stmt|;
name|char
modifier|*
name|demangling_buffer
init|=
name|NULL
decl_stmt|;
name|size_t
name|demangling_buffer_size
init|=
literal|0
decl_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|mangled
argument_list|,
literal|"_ada_"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mangled
operator|+=
literal|5
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mangled
index|[
literal|0
index|]
operator|==
literal|'_'
operator|||
name|mangled
index|[
literal|0
index|]
operator|==
literal|'<'
condition|)
goto|goto
name|Suppress
goto|;
name|p
operator|=
name|strstr
argument_list|(
name|mangled
argument_list|,
literal|"___"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|len0
operator|=
name|strlen
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|==
literal|'X'
condition|)
block|{
name|len0
operator|=
name|p
operator|-
name|mangled
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
else|else
goto|goto
name|Suppress
goto|;
block|}
comment|/* Make demangled big enough for possible expansion by operator name.  */
name|grow_vect
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
operator|(
name|demangling_buffer
operator|)
argument_list|,
operator|&
name|demangling_buffer_size
argument_list|,
literal|2
operator|*
name|len0
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|demangled
operator|=
name|demangling_buffer
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|mangled
index|[
name|len0
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|len0
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
operator|&&
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|mangled
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|-=
literal|1
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
operator|&&
name|mangled
index|[
name|i
index|]
operator|==
literal|'_'
operator|&&
name|mangled
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'_'
condition|)
block|{
name|len0
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mangled
index|[
name|i
index|]
operator|==
literal|'$'
condition|)
block|{
name|len0
operator|=
name|i
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|len0
operator|&&
operator|!
name|ISALPHA
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|mangled
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|+=
literal|1
operator|,
name|j
operator|+=
literal|1
control|)
name|demangled
index|[
name|j
index|]
operator|=
name|mangled
index|[
name|i
index|]
expr_stmt|;
name|at_start_name
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|len0
condition|)
block|{
name|at_start_name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|len0
operator|-
literal|2
operator|&&
name|mangled
index|[
name|i
index|]
operator|==
literal|'_'
operator|&&
name|mangled
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'_'
condition|)
block|{
name|demangled
index|[
name|j
index|]
operator|=
literal|'.'
expr_stmt|;
name|changed
operator|=
name|at_start_name
operator|=
literal|1
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
name|j
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|demangled
index|[
name|j
index|]
operator|=
name|mangled
index|[
name|i
index|]
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
name|j
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|demangled
index|[
name|j
index|]
operator|=
literal|'\000'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|demangled
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|+=
literal|1
control|)
if|if
condition|(
name|ISUPPER
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|demangled
index|[
name|i
index|]
argument_list|)
operator|||
name|demangled
index|[
name|i
index|]
operator|==
literal|' '
condition|)
goto|goto
name|Suppress
goto|;
if|if
condition|(
operator|!
name|changed
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|demangled
return|;
name|Suppress
label|:
name|grow_vect
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
operator|(
name|demangling_buffer
operator|)
argument_list|,
operator|&
name|demangling_buffer_size
argument_list|,
name|strlen
argument_list|(
name|mangled
argument_list|)
operator|+
literal|3
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|demangled
operator|=
name|demangling_buffer
expr_stmt|;
if|if
condition|(
name|mangled
index|[
literal|0
index|]
operator|==
literal|'<'
condition|)
name|strcpy
argument_list|(
name|demangled
argument_list|,
name|mangled
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|demangled
argument_list|,
literal|"<%s>"
argument_list|,
name|mangled
argument_list|)
expr_stmt|;
return|return
name|demangled
return|;
block|}
end_function

begin_comment
comment|/* This function performs most of what cplus_demangle use to do, but    to be able to demangle a name with a B, K or n code, we need to    have a longer term memory of what types have been seen. The original    now intializes and cleans up the squangle code info, while internal    calls go directly to this routine to avoid resetting that info. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|internal_cplus_demangle
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
name|mangled
decl_stmt|;
block|{
name|string
name|decl
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|demangled
init|=
name|NULL
decl_stmt|;
name|int
name|s1
decl_stmt|,
name|s2
decl_stmt|,
name|s3
decl_stmt|,
name|s4
decl_stmt|;
name|s1
operator|=
name|work
operator|->
name|constructor
expr_stmt|;
name|s2
operator|=
name|work
operator|->
name|destructor
expr_stmt|;
name|s3
operator|=
name|work
operator|->
name|static_type
expr_stmt|;
name|s4
operator|=
name|work
operator|->
name|type_quals
expr_stmt|;
name|work
operator|->
name|constructor
operator|=
name|work
operator|->
name|destructor
operator|=
literal|0
expr_stmt|;
name|work
operator|->
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
name|work
operator|->
name|dllimported
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|mangled
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|mangled
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|string_init
argument_list|(
operator|&
name|decl
argument_list|)
expr_stmt|;
comment|/* First check to see if gnu style demangling is active and if the 	 string to be demangled contains a CPLUS_MARKER.  If so, attempt to 	 recognize one of the gnu special forms rather than looking for a 	 standard prefix.  In particular, don't worry about whether there 	 is a "__" string in the mangled string.  Consider "_$_5__foo" for 	 example.  */
if|if
condition|(
operator|(
name|AUTO_DEMANGLING
operator|||
name|GNU_DEMANGLING
operator|)
condition|)
block|{
name|success
operator|=
name|gnu_special
argument_list|(
name|work
argument_list|,
operator|&
name|mangled
argument_list|,
operator|&
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|success
operator|=
name|demangle_prefix
argument_list|(
name|work
argument_list|,
operator|&
name|mangled
argument_list|,
operator|&
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|success
operator|&&
operator|(
operator|*
name|mangled
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|success
operator|=
name|demangle_signature
argument_list|(
name|work
argument_list|,
operator|&
name|mangled
argument_list|,
operator|&
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|work
operator|->
name|constructor
operator|==
literal|2
condition|)
block|{
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"global constructors keyed to "
argument_list|)
expr_stmt|;
name|work
operator|->
name|constructor
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|work
operator|->
name|destructor
operator|==
literal|2
condition|)
block|{
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"global destructors keyed to "
argument_list|)
expr_stmt|;
name|work
operator|->
name|destructor
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|work
operator|->
name|dllimported
operator|==
literal|1
condition|)
block|{
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"import stub for "
argument_list|)
expr_stmt|;
name|work
operator|->
name|dllimported
operator|=
literal|0
expr_stmt|;
block|}
name|demangled
operator|=
name|mop_up
argument_list|(
name|work
argument_list|,
operator|&
name|decl
argument_list|,
name|success
argument_list|)
expr_stmt|;
block|}
name|work
operator|->
name|constructor
operator|=
name|s1
expr_stmt|;
name|work
operator|->
name|destructor
operator|=
name|s2
expr_stmt|;
name|work
operator|->
name|static_type
operator|=
name|s3
expr_stmt|;
name|work
operator|->
name|type_quals
operator|=
name|s4
expr_stmt|;
return|return
name|demangled
return|;
block|}
end_function

begin_comment
comment|/* Clear out and squangling related storage */
end_comment

begin_function
specifier|static
name|void
name|squangle_mop_up
parameter_list|(
name|work
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
block|{
comment|/* clean up the B and K type mangling types. */
name|forget_B_and_K_types
argument_list|(
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|btypevec
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
operator|->
name|btypevec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|work
operator|->
name|ktypevec
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
operator|->
name|ktypevec
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Copy the work state and storage.  */
end_comment

begin_function
specifier|static
name|void
name|work_stuff_copy_to_from
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|to
decl_stmt|;
name|struct
name|work_stuff
modifier|*
name|from
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|delete_work_stuff
argument_list|(
name|to
argument_list|)
expr_stmt|;
comment|/* Shallow-copy scalars.  */
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|to
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Deep-copy dynamic storage.  */
if|if
condition|(
name|from
operator|->
name|typevec_size
condition|)
name|to
operator|->
name|typevec
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|from
operator|->
name|typevec_size
operator|*
sizeof|sizeof
argument_list|(
name|to
operator|->
name|typevec
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|from
operator|->
name|ntypes
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|from
operator|->
name|typevec
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
decl_stmt|;
name|to
operator|->
name|typevec
index|[
name|i
index|]
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|to
operator|->
name|typevec
index|[
name|i
index|]
argument_list|,
name|from
operator|->
name|typevec
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|from
operator|->
name|ksize
condition|)
name|to
operator|->
name|ktypevec
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|from
operator|->
name|ksize
operator|*
sizeof|sizeof
argument_list|(
name|to
operator|->
name|ktypevec
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|from
operator|->
name|numk
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|from
operator|->
name|ktypevec
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
decl_stmt|;
name|to
operator|->
name|ktypevec
index|[
name|i
index|]
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|to
operator|->
name|ktypevec
index|[
name|i
index|]
argument_list|,
name|from
operator|->
name|ktypevec
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|from
operator|->
name|bsize
condition|)
name|to
operator|->
name|btypevec
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|from
operator|->
name|bsize
operator|*
sizeof|sizeof
argument_list|(
name|to
operator|->
name|btypevec
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|from
operator|->
name|numb
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|from
operator|->
name|btypevec
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
decl_stmt|;
name|to
operator|->
name|btypevec
index|[
name|i
index|]
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|to
operator|->
name|btypevec
index|[
name|i
index|]
argument_list|,
name|from
operator|->
name|btypevec
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|from
operator|->
name|ntmpl_args
condition|)
name|to
operator|->
name|tmpl_argvec
operator|=
name|xmalloc
argument_list|(
name|from
operator|->
name|ntmpl_args
operator|*
sizeof|sizeof
argument_list|(
name|to
operator|->
name|tmpl_argvec
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|from
operator|->
name|ntmpl_args
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|from
operator|->
name|tmpl_argvec
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
decl_stmt|;
name|to
operator|->
name|tmpl_argvec
index|[
name|i
index|]
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|to
operator|->
name|tmpl_argvec
index|[
name|i
index|]
argument_list|,
name|from
operator|->
name|tmpl_argvec
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|from
operator|->
name|previous_argument
condition|)
block|{
name|to
operator|->
name|previous_argument
operator|=
operator|(
name|string
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|string_init
argument_list|(
name|to
operator|->
name|previous_argument
argument_list|)
expr_stmt|;
name|string_appends
argument_list|(
name|to
operator|->
name|previous_argument
argument_list|,
name|from
operator|->
name|previous_argument
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete dynamic stuff in work_stuff that is not to be re-used.  */
end_comment

begin_function
specifier|static
name|void
name|delete_non_B_K_work_stuff
parameter_list|(
name|work
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
block|{
comment|/* Discard the remembered types, if any.  */
name|forget_types
argument_list|(
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|typevec
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
operator|->
name|typevec
argument_list|)
expr_stmt|;
name|work
operator|->
name|typevec
operator|=
name|NULL
expr_stmt|;
name|work
operator|->
name|typevec_size
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|work
operator|->
name|tmpl_argvec
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|work
operator|->
name|ntmpl_args
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|work
operator|->
name|tmpl_argvec
index|[
name|i
index|]
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
operator|->
name|tmpl_argvec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
operator|->
name|tmpl_argvec
argument_list|)
expr_stmt|;
name|work
operator|->
name|tmpl_argvec
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|work
operator|->
name|previous_argument
condition|)
block|{
name|string_delete
argument_list|(
name|work
operator|->
name|previous_argument
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
operator|->
name|previous_argument
argument_list|)
expr_stmt|;
name|work
operator|->
name|previous_argument
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete all dynamic storage in work_stuff.  */
end_comment

begin_function
specifier|static
name|void
name|delete_work_stuff
parameter_list|(
name|work
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
block|{
name|delete_non_B_K_work_stuff
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|squangle_mop_up
argument_list|(
name|work
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear out any mangled storage */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|mop_up
parameter_list|(
name|work
parameter_list|,
name|declp
parameter_list|,
name|success
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
name|int
name|success
decl_stmt|;
block|{
name|char
modifier|*
name|demangled
init|=
name|NULL
decl_stmt|;
name|delete_non_B_K_work_stuff
argument_list|(
name|work
argument_list|)
expr_stmt|;
comment|/* If demangling was successful, ensure that the demangled string is null      terminated and return it.  Otherwise, free the demangling decl.  */
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|string_delete
argument_list|(
name|declp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|string_appendn
argument_list|(
name|declp
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|demangled
operator|=
name|declp
operator|->
name|b
expr_stmt|;
block|}
return|return
operator|(
name|demangled
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	demangle_signature -- demangle the signature part of a mangled name  SYNOPSIS  	static int 	demangle_signature (struct work_stuff *work, const char **mangled, 			    string *declp);  DESCRIPTION  	Consume and demangle the signature portion of the mangled name.  	DECLP is the string where demangled output is being built.  At 	entry it contains the demangled root name from the mangled name 	prefix.  I.E. either a demangled operator name or the root function 	name.  In some special cases, it may contain nothing.  	*MANGLED points to the current unconsumed location in the mangled 	name.  As tokens are consumed and demangling is performed, the 	pointer is updated to continuously point at the next token to 	be consumed.  	Demangling GNU style mangled names is nasty because there is no 	explicit token that marks the start of the outermost function 	argument list.  */
end_comment

begin_function
specifier|static
name|int
name|demangle_signature
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|declp
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
block|{
name|int
name|success
init|=
literal|1
decl_stmt|;
name|int
name|func_done
init|=
literal|0
decl_stmt|;
name|int
name|expect_func
init|=
literal|0
decl_stmt|;
name|int
name|expect_return_type
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|oldmangled
init|=
name|NULL
decl_stmt|;
name|string
name|trawname
decl_stmt|;
name|string
name|tname
decl_stmt|;
while|while
condition|(
name|success
operator|&&
operator|(
operator|*
operator|*
name|mangled
operator|!=
literal|'\0'
operator|)
condition|)
block|{
switch|switch
condition|(
operator|*
operator|*
name|mangled
condition|)
block|{
case|case
literal|'Q'
case|:
name|oldmangled
operator|=
operator|*
name|mangled
expr_stmt|;
name|success
operator|=
name|demangle_qualified
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|remember_type
argument_list|(
name|work
argument_list|,
name|oldmangled
argument_list|,
operator|*
name|mangled
operator|-
name|oldmangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|AUTO_DEMANGLING
operator|||
name|GNU_DEMANGLING
condition|)
name|expect_func
operator|=
literal|1
expr_stmt|;
name|oldmangled
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|oldmangled
operator|=
operator|*
name|mangled
expr_stmt|;
name|success
operator|=
name|demangle_qualified
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|AUTO_DEMANGLING
operator|||
name|GNU_DEMANGLING
condition|)
block|{
name|expect_func
operator|=
literal|1
expr_stmt|;
block|}
name|oldmangled
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Static member function */
if|if
condition|(
name|oldmangled
operator|==
name|NULL
condition|)
block|{
name|oldmangled
operator|=
operator|*
name|mangled
expr_stmt|;
block|}
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|work
operator|->
name|static_type
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
case|case
literal|'V'
case|:
case|case
literal|'u'
case|:
name|work
operator|->
name|type_quals
operator||=
name|code_for_qualifier
argument_list|(
operator|*
operator|*
name|mangled
argument_list|)
expr_stmt|;
comment|/* a qualified member function */
if|if
condition|(
name|oldmangled
operator|==
name|NULL
condition|)
name|oldmangled
operator|=
operator|*
name|mangled
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Local class name follows after "Lnnn_" */
if|if
condition|(
name|HP_DEMANGLING
condition|)
block|{
while|while
condition|(
operator|*
operator|*
name|mangled
operator|&&
operator|(
operator|*
operator|*
name|mangled
operator|!=
literal|'_'
operator|)
condition|)
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
operator|*
name|mangled
condition|)
name|success
operator|=
literal|0
expr_stmt|;
else|else
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
else|else
name|success
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|oldmangled
operator|==
name|NULL
condition|)
block|{
name|oldmangled
operator|=
operator|*
name|mangled
expr_stmt|;
block|}
name|work
operator|->
name|temp_start
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* uppermost call to demangle_class */
name|success
operator|=
name|demangle_class
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|remember_type
argument_list|(
name|work
argument_list|,
name|oldmangled
argument_list|,
operator|*
name|mangled
operator|-
name|oldmangled
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AUTO_DEMANGLING
operator|||
name|GNU_DEMANGLING
operator|||
name|EDG_DEMANGLING
condition|)
block|{
comment|/* EDG and others will have the "F", so we let the loop cycle                  if we are looking at one. */
if|if
condition|(
operator|*
operator|*
name|mangled
operator|!=
literal|'F'
condition|)
name|expect_func
operator|=
literal|1
expr_stmt|;
block|}
name|oldmangled
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
block|{
name|string
name|s
decl_stmt|;
name|success
operator|=
name|do_type
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|string_append
argument_list|(
operator|&
name|s
argument_list|,
name|SCOPE_STRING
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
name|string_prepends
argument_list|(
name|declp
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
name|oldmangled
operator|=
name|NULL
expr_stmt|;
name|expect_func
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'F'
case|:
comment|/* Function */
comment|/* ARM/HP style demangling includes a specific 'F' character after 	     the class name.  For GNU style, it is just implied.  So we can 	     safely just consume any 'F' at this point and be compatible 	     with either style.  */
name|oldmangled
operator|=
name|NULL
expr_stmt|;
name|func_done
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
comment|/* For lucid/ARM/HP style we have to forget any types we might 	     have remembered up to this point, since they were not argument 	     types.  GNU style considers all types seen as available for 	     back references.  See comment in demangle_args() */
if|if
condition|(
name|LUCID_DEMANGLING
operator|||
name|ARM_DEMANGLING
operator|||
name|HP_DEMANGLING
operator|||
name|EDG_DEMANGLING
condition|)
block|{
name|forget_types
argument_list|(
name|work
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
name|demangle_args
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|)
expr_stmt|;
comment|/* After picking off the function args, we expect to either 	     find the function return type (preceded by an '_') or the 	     end of the string. */
if|if
condition|(
name|success
operator|&&
operator|(
name|AUTO_DEMANGLING
operator|||
name|EDG_DEMANGLING
operator|)
operator|&&
operator|*
operator|*
name|mangled
operator|==
literal|'_'
condition|)
block|{
operator|++
operator|(
operator|*
name|mangled
operator|)
expr_stmt|;
comment|/* At this level, we do not care about the return type. */
name|success
operator|=
name|do_type
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|tname
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
comment|/* G++ Template */
name|string_init
argument_list|(
operator|&
name|trawname
argument_list|)
expr_stmt|;
name|string_init
argument_list|(
operator|&
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldmangled
operator|==
name|NULL
condition|)
block|{
name|oldmangled
operator|=
operator|*
name|mangled
expr_stmt|;
block|}
name|success
operator|=
name|demangle_template
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|tname
argument_list|,
operator|&
name|trawname
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|remember_type
argument_list|(
name|work
argument_list|,
name|oldmangled
argument_list|,
operator|*
name|mangled
operator|-
name|oldmangled
argument_list|)
expr_stmt|;
block|}
name|string_append
argument_list|(
operator|&
name|tname
argument_list|,
name|SCOPE_STRING
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
name|string_prepends
argument_list|(
name|declp
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|destructor
operator|&
literal|1
condition|)
block|{
name|string_prepend
argument_list|(
operator|&
name|trawname
argument_list|,
literal|"~"
argument_list|)
expr_stmt|;
name|string_appends
argument_list|(
name|declp
argument_list|,
operator|&
name|trawname
argument_list|)
expr_stmt|;
name|work
operator|->
name|destructor
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|work
operator|->
name|constructor
operator|&
literal|1
operator|)
operator|||
operator|(
name|work
operator|->
name|destructor
operator|&
literal|1
operator|)
condition|)
block|{
name|string_appends
argument_list|(
name|declp
argument_list|,
operator|&
name|trawname
argument_list|)
expr_stmt|;
name|work
operator|->
name|constructor
operator|-=
literal|1
expr_stmt|;
block|}
name|string_delete
argument_list|(
operator|&
name|trawname
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|tname
argument_list|)
expr_stmt|;
name|oldmangled
operator|=
name|NULL
expr_stmt|;
name|expect_func
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
if|if
condition|(
operator|(
name|AUTO_DEMANGLING
operator|||
name|GNU_DEMANGLING
operator|)
operator|&&
name|expect_return_type
condition|)
block|{
comment|/* Read the return type. */
name|string
name|return_type
decl_stmt|;
name|string_init
argument_list|(
operator|&
name|return_type
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|success
operator|=
name|do_type
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|return_type
argument_list|)
expr_stmt|;
name|APPEND_BLANK
argument_list|(
operator|&
name|return_type
argument_list|)
expr_stmt|;
name|string_prepends
argument_list|(
name|declp
argument_list|,
operator|&
name|return_type
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|return_type
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
comment|/* At the outermost level, we cannot have a return type specified, 	       so if we run into another '_' at this point we are dealing with 	       a mangled name that is either bogus, or has been mangled by 	       some algorithm we don't know how to deal with.  So just 	       reject the entire demangling.  */
comment|/* However, "_nnn" is an expected suffix for alternate entry point                numbered nnn for a function, with HP aCC, so skip over that                without reporting failure. pai/1997-09-04 */
if|if
condition|(
name|HP_DEMANGLING
condition|)
block|{
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|mangled
operator|&&
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|mangled
argument_list|)
condition|)
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
else|else
name|success
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
if|if
condition|(
name|AUTO_DEMANGLING
operator|||
name|GNU_DEMANGLING
condition|)
block|{
comment|/* A G++ template function.  Read the template arguments. */
name|success
operator|=
name|demangle_template
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|work
operator|->
name|constructor
operator|&
literal|1
operator|)
condition|)
name|expect_return_type
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
break|break;
block|}
else|else
comment|/* fall through */
block|{
empty_stmt|;
block|}
default|default:
if|if
condition|(
name|AUTO_DEMANGLING
operator|||
name|GNU_DEMANGLING
condition|)
block|{
comment|/* Assume we have stumbled onto the first outermost function 		 argument token, and start processing args.  */
name|func_done
operator|=
literal|1
expr_stmt|;
name|success
operator|=
name|demangle_args
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Non-GNU demanglers use a specific token to mark the start 		 of the outermost function argument tokens.  Typically 'F', 		 for ARM/HP-demangling, for example.  So if we find something 		 we are not prepared for, it must be an error.  */
name|success
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
comment|/* 	if (AUTO_DEMANGLING || GNU_DEMANGLING) 	*/
block|{
if|if
condition|(
name|success
operator|&&
name|expect_func
condition|)
block|{
name|func_done
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|LUCID_DEMANGLING
operator|||
name|ARM_DEMANGLING
operator|||
name|EDG_DEMANGLING
condition|)
block|{
name|forget_types
argument_list|(
name|work
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
name|demangle_args
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|)
expr_stmt|;
comment|/* Since template include the mangling of their return types, 	       we must set expect_func to 0 so that we don't try do 	       demangle more arguments the next time we get here.  */
name|expect_func
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|success
operator|&&
operator|!
name|func_done
condition|)
block|{
if|if
condition|(
name|AUTO_DEMANGLING
operator|||
name|GNU_DEMANGLING
condition|)
block|{
comment|/* With GNU style demangling, bar__3foo is 'foo::bar(void)', and 	     bar__3fooi is 'foo::bar(int)'.  We get here when we find the 	     first case, and need to ensure that the '(void)' gets added to 	     the current declp.  Note that with ARM/HP, the first case 	     represents the name of a static data member 'foo::bar', 	     which is in the current declp, so we leave it alone.  */
name|success
operator|=
name|demangle_args
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|success
operator|&&
name|PRINT_ARG_TYPES
condition|)
block|{
if|if
condition|(
name|work
operator|->
name|static_type
condition|)
name|string_append
argument_list|(
name|declp
argument_list|,
literal|" static"
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|type_quals
operator|!=
name|TYPE_UNQUALIFIED
condition|)
block|{
name|APPEND_BLANK
argument_list|(
name|declp
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
name|qualifier_string
argument_list|(
name|work
operator|->
name|type_quals
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int demangle_method_args (work, mangled, declp)      struct work_stuff *work;      const char **mangled;      string *declp; {   int success = 0;    if (work -> static_type)     {       string_append (declp, *mangled + 1);       *mangled += strlen (*mangled);       success = 1;     }   else     {       success = demangle_args (work, mangled, declp);     }   return (success); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|demangle_template_template_parm
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|tname
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|tname
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
name|int
name|success
init|=
literal|1
decl_stmt|;
name|string
name|temp
decl_stmt|;
name|string_append
argument_list|(
name|tname
argument_list|,
literal|"template<"
argument_list|)
expr_stmt|;
comment|/* get size of template parameter list */
if|if
condition|(
name|get_count
argument_list|(
name|mangled
argument_list|,
operator|&
name|r
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|need_comma
condition|)
block|{
name|string_append
argument_list|(
name|tname
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
comment|/* Z for type parameters */
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'Z'
condition|)
block|{
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|string_append
argument_list|(
name|tname
argument_list|,
literal|"class"
argument_list|)
expr_stmt|;
block|}
comment|/* z for template parameters */
elseif|else
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'z'
condition|)
block|{
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|success
operator|=
name|demangle_template_template_parm
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
comment|/* temp is initialized in do_type */
name|success
operator|=
name|do_type
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|string_appends
argument_list|(
name|tname
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
name|string_delete
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
break|break;
block|}
block|}
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tname
operator|->
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'>'
condition|)
name|string_append
argument_list|(
name|tname
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|tname
argument_list|,
literal|"> class"
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|demangle_expression
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|s
parameter_list|,
name|tk
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|s
decl_stmt|;
name|type_kind_t
name|tk
decl_stmt|;
block|{
name|int
name|need_operator
init|=
literal|0
decl_stmt|;
name|int
name|success
decl_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|"("
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
while|while
condition|(
name|success
operator|&&
operator|*
operator|*
name|mangled
operator|!=
literal|'W'
operator|&&
operator|*
operator|*
name|mangled
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|need_operator
condition|)
block|{
name|size_t
name|i
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|success
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|optable
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|size_t
name|l
init|=
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|<=
name|len
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|,
operator|*
name|mangled
argument_list|,
name|l
argument_list|)
operator|==
literal|0
condition|)
block|{
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|s
argument_list|,
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|+=
name|l
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|success
condition|)
break|break;
block|}
else|else
name|need_operator
operator|=
literal|1
expr_stmt|;
name|success
operator|=
name|demangle_template_value_parm
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|s
argument_list|,
name|tk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|mangled
operator|!=
literal|'W'
condition|)
name|success
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|")"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|demangle_integral_value
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|s
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|success
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'E'
condition|)
name|success
operator|=
name|demangle_expression
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|s
argument_list|,
name|tk_integral
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'Q'
operator|||
operator|*
operator|*
name|mangled
operator|==
literal|'K'
condition|)
name|success
operator|=
name|demangle_qualified
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|s
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|value
decl_stmt|;
comment|/* By default, we let the number decide whether we shall consume an 	 underscore.  */
name|int
name|consume_following_underscore
init|=
literal|0
decl_stmt|;
name|int
name|leave_following_underscore
init|=
literal|0
decl_stmt|;
name|success
operator|=
literal|0
expr_stmt|;
comment|/* Negative numbers are indicated with a leading `m'.  */
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'m'
condition|)
block|{
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mangled
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|mangled
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|'m'
condition|)
block|{
comment|/* Since consume_count_with_underscores does not handle the 	     `m'-prefix we must do it here, using consume_count and 	     adjusting underscores: we have to consume the underscore 	     matching the prepended one.  */
name|consume_following_underscore
operator|=
literal|1
expr_stmt|;
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'_'
condition|)
block|{
comment|/* Do not consume a following underscore; 	     consume_following_underscore will consume what should be 	     consumed.  */
name|leave_following_underscore
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We must call consume_count if we expect to remove a trailing 	 underscore, since consume_count_with_underscores expects 	 the leading underscore (that we consumed) if it is to handle 	 multi-digit numbers.  */
if|if
condition|(
name|consume_following_underscore
condition|)
name|value
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|consume_count_with_underscores
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
operator|-
literal|1
condition|)
block|{
name|char
name|buf
index|[
name|INTBUF_SIZE
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|s
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Numbers not otherwise delimited, might have an underscore 	     appended as a delimeter, which we should skip.  	     ??? This used to always remove a following underscore, which 	     is wrong.  If other (arbitrary) cases are followed by an 	     underscore, we need to do something more radical.  */
if|if
condition|(
operator|(
name|value
operator|>
literal|9
operator|||
name|consume_following_underscore
operator|)
operator|&&
operator|!
name|leave_following_underscore
operator|&&
operator|*
operator|*
name|mangled
operator|==
literal|'_'
condition|)
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
comment|/* All is well.  */
name|success
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/* Demangle the real value in MANGLED.  */
end_comment

begin_function
specifier|static
name|int
name|demangle_real_value
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|s
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'E'
condition|)
return|return
name|demangle_expression
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|s
argument_list|,
name|tk_real
argument_list|)
return|;
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'m'
condition|)
block|{
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|mangled
argument_list|)
condition|)
block|{
name|string_appendn
argument_list|(
name|s
argument_list|,
operator|*
name|mangled
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'.'
condition|)
comment|/* fraction */
block|{
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|"."
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|mangled
argument_list|)
condition|)
block|{
name|string_appendn
argument_list|(
name|s
argument_list|,
operator|*
name|mangled
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'e'
condition|)
comment|/* exponent */
block|{
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|"e"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|mangled
argument_list|)
condition|)
block|{
name|string_appendn
argument_list|(
name|s
argument_list|,
operator|*
name|mangled
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|demangle_template_value_parm
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|s
parameter_list|,
name|tk
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|s
decl_stmt|;
name|type_kind_t
name|tk
decl_stmt|;
block|{
name|int
name|success
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'Y'
condition|)
block|{
comment|/* The next argument is a template parameter. */
name|int
name|idx
decl_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|idx
operator|=
name|consume_count_with_underscores
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
operator|||
operator|(
name|work
operator|->
name|tmpl_argvec
operator|&&
name|idx
operator|>=
name|work
operator|->
name|ntmpl_args
operator|)
operator|||
name|consume_count_with_underscores
argument_list|(
name|mangled
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|work
operator|->
name|tmpl_argvec
condition|)
name|string_append
argument_list|(
name|s
argument_list|,
name|work
operator|->
name|tmpl_argvec
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
else|else
name|string_append_template_idx
argument_list|(
name|s
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tk
operator|==
name|tk_integral
condition|)
name|success
operator|=
name|demangle_integral_value
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tk
operator|==
name|tk_char
condition|)
block|{
name|char
name|tmp
index|[
literal|2
index|]
decl_stmt|;
name|int
name|val
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'m'
condition|)
block|{
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|"'"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|val
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<=
literal|0
condition|)
name|success
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|tmp
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|val
expr_stmt|;
name|tmp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|string_appendn
argument_list|(
name|s
argument_list|,
operator|&
name|tmp
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|"'"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tk
operator|==
name|tk_bool
condition|)
block|{
name|int
name|val
init|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|"false"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|==
literal|1
condition|)
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|"true"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tk
operator|==
name|tk_real
condition|)
name|success
operator|=
name|demangle_real_value
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tk
operator|==
name|tk_pointer
operator|||
name|tk
operator|==
name|tk_reference
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'Q'
condition|)
name|success
operator|=
name|demangle_qualified
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|s
argument_list|,
comment|/*isfuncname=*/
literal|0
argument_list|,
comment|/*append=*/
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|symbol_len
init|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
decl_stmt|;
if|if
condition|(
name|symbol_len
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|symbol_len
operator|==
literal|0
condition|)
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|"0"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|p
init|=
name|xmalloc
argument_list|(
name|symbol_len
operator|+
literal|1
argument_list|)
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|strncpy
argument_list|(
name|p
argument_list|,
operator|*
name|mangled
argument_list|,
name|symbol_len
argument_list|)
expr_stmt|;
name|p
index|[
name|symbol_len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* We use cplus_demangle here, rather than 		 internal_cplus_demangle, because the name of the entity 		 mangled here does not make use of any of the squangling 		 or type-code information we have built up thus far; it is 		 mangled independently.  */
name|q
operator|=
name|cplus_demangle
argument_list|(
name|p
argument_list|,
name|work
operator|->
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|tk
operator|==
name|tk_pointer
condition|)
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|"&"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* FIXME: Pointer-to-member constants should get a 		 qualifying class name here.  */
if|if
condition|(
name|q
condition|)
block|{
name|string_append
argument_list|(
name|s
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
else|else
name|string_append
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
operator|*
name|mangled
operator|+=
name|symbol_len
expr_stmt|;
block|}
block|}
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/* Demangle the template name in MANGLED.  The full name of the    template (e.g., S<int>) is placed in TNAME.  The name without the    template parameters (e.g. S) is placed in TRAWNAME if TRAWNAME is    non-NULL.  If IS_TYPE is nonzero, this template is a type template,    not a function template.  If both IS_TYPE and REMEMBER are nonzero,    the template is remembered in the list of back-referenceable    types.  */
end_comment

begin_function
specifier|static
name|int
name|demangle_template
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|tname
parameter_list|,
name|trawname
parameter_list|,
name|is_type
parameter_list|,
name|remember
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|tname
decl_stmt|;
name|string
modifier|*
name|trawname
decl_stmt|;
name|int
name|is_type
decl_stmt|;
name|int
name|remember
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|is_java_array
init|=
literal|0
decl_stmt|;
name|string
name|temp
decl_stmt|;
name|int
name|bindex
init|=
literal|0
decl_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|is_type
condition|)
block|{
if|if
condition|(
name|remember
condition|)
name|bindex
operator|=
name|register_Btype
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|start
operator|=
operator|*
name|mangled
expr_stmt|;
comment|/* get template name */
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'z'
condition|)
block|{
name|int
name|idx
decl_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|idx
operator|=
name|consume_count_with_underscores
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
operator|||
operator|(
name|work
operator|->
name|tmpl_argvec
operator|&&
name|idx
operator|>=
name|work
operator|->
name|ntmpl_args
operator|)
operator|||
name|consume_count_with_underscores
argument_list|(
name|mangled
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|work
operator|->
name|tmpl_argvec
condition|)
block|{
name|string_append
argument_list|(
name|tname
argument_list|,
name|work
operator|->
name|tmpl_argvec
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|trawname
condition|)
name|string_append
argument_list|(
name|trawname
argument_list|,
name|work
operator|->
name|tmpl_argvec
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|string_append_template_idx
argument_list|(
name|tname
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|trawname
condition|)
name|string_append_template_idx
argument_list|(
name|trawname
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
operator|)
operator|<=
literal|0
operator|||
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
operator|<
name|r
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|is_java_array
operator|=
operator|(
name|work
operator|->
name|options
operator|&
name|DMGL_JAVA
operator|)
operator|&&
name|strncmp
argument_list|(
operator|*
name|mangled
argument_list|,
literal|"JArray1Z"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|is_java_array
condition|)
block|{
name|string_appendn
argument_list|(
name|tname
argument_list|,
operator|*
name|mangled
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trawname
condition|)
name|string_appendn
argument_list|(
name|trawname
argument_list|,
operator|*
name|mangled
argument_list|,
name|r
argument_list|)
expr_stmt|;
operator|*
name|mangled
operator|+=
name|r
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|is_java_array
condition|)
name|string_append
argument_list|(
name|tname
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
comment|/* get size of template parameter list */
if|if
condition|(
operator|!
name|get_count
argument_list|(
name|mangled
argument_list|,
operator|&
name|r
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|is_type
condition|)
block|{
comment|/* Create an array for saving the template argument values. */
name|work
operator|->
name|tmpl_argvec
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|r
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|work
operator|->
name|ntmpl_args
operator|=
name|r
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r
condition|;
name|i
operator|++
control|)
name|work
operator|->
name|tmpl_argvec
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|need_comma
condition|)
block|{
name|string_append
argument_list|(
name|tname
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
comment|/* Z for type parameters */
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'Z'
condition|)
block|{
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
comment|/* temp is initialized in do_type */
name|success
operator|=
name|do_type
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|string_appends
argument_list|(
name|tname
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_type
condition|)
block|{
comment|/* Save the template argument. */
name|int
name|len
init|=
name|temp
operator|.
name|p
operator|-
name|temp
operator|.
name|b
decl_stmt|;
name|work
operator|->
name|tmpl_argvec
index|[
name|i
index|]
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|work
operator|->
name|tmpl_argvec
index|[
name|i
index|]
argument_list|,
name|temp
operator|.
name|b
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|work
operator|->
name|tmpl_argvec
index|[
name|i
index|]
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|string_delete
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
break|break;
block|}
block|}
comment|/* z for template parameters */
elseif|else
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'z'
condition|)
block|{
name|int
name|r2
decl_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|success
operator|=
name|demangle_template_template_parm
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
operator|&&
operator|(
name|r2
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
operator|)
operator|>
literal|0
operator|&&
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
operator|>=
name|r2
condition|)
block|{
name|string_append
argument_list|(
name|tname
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|string_appendn
argument_list|(
name|tname
argument_list|,
operator|*
name|mangled
argument_list|,
name|r2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_type
condition|)
block|{
comment|/* Save the template argument. */
name|int
name|len
init|=
name|r2
decl_stmt|;
name|work
operator|->
name|tmpl_argvec
index|[
name|i
index|]
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|work
operator|->
name|tmpl_argvec
index|[
name|i
index|]
argument_list|,
operator|*
name|mangled
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|work
operator|->
name|tmpl_argvec
index|[
name|i
index|]
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|*
name|mangled
operator|+=
name|r2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
name|string
name|param
decl_stmt|;
name|string
modifier|*
name|s
decl_stmt|;
comment|/* otherwise, value parameter */
comment|/* temp is initialized in do_type */
name|success
operator|=
name|do_type
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
break|break;
if|if
condition|(
operator|!
name|is_type
condition|)
block|{
name|s
operator|=
operator|&
name|param
expr_stmt|;
name|string_init
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|s
operator|=
name|tname
expr_stmt|;
name|success
operator|=
name|demangle_template_value_parm
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|s
argument_list|,
operator|(
name|type_kind_t
operator|)
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
operator|!
name|is_type
condition|)
name|string_delete
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|is_type
condition|)
block|{
name|int
name|len
init|=
name|s
operator|->
name|p
operator|-
name|s
operator|->
name|b
decl_stmt|;
name|work
operator|->
name|tmpl_argvec
index|[
name|i
index|]
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|work
operator|->
name|tmpl_argvec
index|[
name|i
index|]
argument_list|,
name|s
operator|->
name|b
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|work
operator|->
name|tmpl_argvec
index|[
name|i
index|]
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|string_appends
argument_list|(
name|tname
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|is_java_array
condition|)
block|{
name|string_append
argument_list|(
name|tname
argument_list|,
literal|"[]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tname
operator|->
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'>'
condition|)
name|string_append
argument_list|(
name|tname
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|tname
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_type
operator|&&
name|remember
condition|)
name|remember_Btype
argument_list|(
name|work
argument_list|,
name|tname
operator|->
name|b
argument_list|,
name|LEN_STRING
argument_list|(
name|tname
argument_list|)
argument_list|,
name|bindex
argument_list|)
expr_stmt|;
comment|/*     if (work -> static_type)     {     string_append (declp, *mangled + 1);     *mangled += strlen (*mangled);     success = 1;     }     else     {     success = demangle_args (work, mangled, declp);     }     }     */
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_pt
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|n
parameter_list|,
name|anchor
parameter_list|,
name|args
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
name|mangled
decl_stmt|;
name|int
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|anchor
decl_stmt|,
decl|*
modifier|*
name|args
decl_stmt|;
end_function

begin_block
block|{
comment|/* Check if ARM template with "__pt__" in it ("parameterized type") */
comment|/* Allow HP also here, because HP's cfront compiler follows ARM to some extent */
if|if
condition|(
operator|(
name|ARM_DEMANGLING
operator|||
name|HP_DEMANGLING
operator|)
operator|&&
operator|(
operator|*
name|anchor
operator|=
name|mystrstr
argument_list|(
name|mangled
argument_list|,
literal|"__pt__"
argument_list|)
operator|)
condition|)
block|{
name|int
name|len
decl_stmt|;
operator|*
name|args
operator|=
operator|*
name|anchor
operator|+
literal|6
expr_stmt|;
name|len
operator|=
name|consume_count
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
name|args
operator|+
name|len
operator|==
name|mangled
operator|+
name|n
operator|&&
operator|*
operator|*
name|args
operator|==
literal|'_'
condition|)
block|{
operator|++
operator|*
name|args
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|AUTO_DEMANGLING
operator|||
name|EDG_DEMANGLING
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|anchor
operator|=
name|mystrstr
argument_list|(
name|mangled
argument_list|,
literal|"__tm__"
argument_list|)
operator|)
operator|||
operator|(
operator|*
name|anchor
operator|=
name|mystrstr
argument_list|(
name|mangled
argument_list|,
literal|"__ps__"
argument_list|)
operator|)
operator|||
operator|(
operator|*
name|anchor
operator|=
name|mystrstr
argument_list|(
name|mangled
argument_list|,
literal|"__pt__"
argument_list|)
operator|)
condition|)
block|{
name|int
name|len
decl_stmt|;
operator|*
name|args
operator|=
operator|*
name|anchor
operator|+
literal|6
expr_stmt|;
name|len
operator|=
name|consume_count
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
name|args
operator|+
name|len
operator|==
name|mangled
operator|+
name|n
operator|&&
operator|*
operator|*
name|args
operator|==
literal|'_'
condition|)
block|{
operator|++
operator|*
name|args
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|anchor
operator|=
name|mystrstr
argument_list|(
name|mangled
argument_list|,
literal|"__S"
argument_list|)
operator|)
condition|)
block|{
name|int
name|len
decl_stmt|;
operator|*
name|args
operator|=
operator|*
name|anchor
operator|+
literal|3
expr_stmt|;
name|len
operator|=
name|consume_count
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
name|args
operator|+
name|len
operator|==
name|mangled
operator|+
name|n
operator|&&
operator|*
operator|*
name|args
operator|==
literal|'_'
condition|)
block|{
operator|++
operator|*
name|args
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|demangle_arm_hp_template
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|n
parameter_list|,
name|declp
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|int
name|n
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
specifier|const
name|char
modifier|*
name|e
init|=
operator|*
name|mangled
operator|+
name|n
decl_stmt|;
name|string
name|arg
decl_stmt|;
comment|/* Check for HP aCC template spec: classXt1t2 where t1, t2 are      template args */
if|if
condition|(
name|HP_DEMANGLING
operator|&&
operator|(
operator|(
operator|*
name|mangled
operator|)
index|[
name|n
index|]
operator|==
literal|'X'
operator|)
condition|)
block|{
name|char
modifier|*
name|start_spec_args
init|=
name|NULL
decl_stmt|;
comment|/* First check for and omit template specialization pseudo-arguments,          such as in "Spec<#1,#1.*>" */
name|start_spec_args
operator|=
name|strchr
argument_list|(
operator|*
name|mangled
argument_list|,
literal|'<'
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_spec_args
operator|&&
operator|(
name|start_spec_args
operator|-
operator|*
name|mangled
operator|<
name|n
operator|)
condition|)
name|string_appendn
argument_list|(
name|declp
argument_list|,
operator|*
name|mangled
argument_list|,
name|start_spec_args
operator|-
operator|*
name|mangled
argument_list|)
expr_stmt|;
else|else
name|string_appendn
argument_list|(
name|declp
argument_list|,
operator|*
name|mangled
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|+=
name|n
operator|+
literal|1
expr_stmt|;
name|string_init
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|temp_start
operator|==
operator|-
literal|1
condition|)
comment|/* non-recursive call */
name|work
operator|->
name|temp_start
operator|=
name|declp
operator|->
name|p
operator|-
name|declp
operator|->
name|b
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|string_clear
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|mangled
condition|)
block|{
case|case
literal|'T'
case|:
comment|/* 'T' signals a type parameter */
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|do_type
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|arg
argument_list|)
condition|)
goto|goto
name|hpacc_template_args_done
goto|;
break|break;
case|case
literal|'U'
case|:
case|case
literal|'S'
case|:
comment|/* 'U' or 'S' signals an integral value */
if|if
condition|(
operator|!
name|do_hpacc_template_const_value
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|arg
argument_list|)
condition|)
goto|goto
name|hpacc_template_args_done
goto|;
break|break;
case|case
literal|'A'
case|:
comment|/* 'A' signals a named constant expression (literal) */
if|if
condition|(
operator|!
name|do_hpacc_template_literal
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|arg
argument_list|)
condition|)
goto|goto
name|hpacc_template_args_done
goto|;
break|break;
default|default:
comment|/* Today, 1997-09-03, we have only the above types                    of template parameters */
comment|/* FIXME: maybe this should fail and return null */
goto|goto
name|hpacc_template_args_done
goto|;
block|}
name|string_appends
argument_list|(
name|declp
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
comment|/* Check if we're at the end of template args.              0 if at end of static member of template class,              _ if done with template args for a function */
if|if
condition|(
operator|(
operator|*
operator|*
name|mangled
operator|==
literal|'\000'
operator|)
operator|||
operator|(
operator|*
operator|*
name|mangled
operator|==
literal|'_'
operator|)
condition|)
break|break;
else|else
name|string_append
argument_list|(
name|declp
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|hpacc_template_args_done
label|:
name|string_append
argument_list|(
name|declp
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'_'
condition|)
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
return|return;
block|}
comment|/* ARM template? (Also handles HP cfront extensions) */
elseif|else
if|if
condition|(
name|arm_pt
argument_list|(
name|work
argument_list|,
operator|*
name|mangled
argument_list|,
name|n
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|args
argument_list|)
condition|)
block|{
name|string
name|type_str
decl_stmt|;
name|string_init
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
name|string_appendn
argument_list|(
name|declp
argument_list|,
operator|*
name|mangled
argument_list|,
name|p
operator|-
operator|*
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|temp_start
operator|==
operator|-
literal|1
condition|)
comment|/* non-recursive call */
name|work
operator|->
name|temp_start
operator|=
name|declp
operator|->
name|p
operator|-
name|declp
operator|->
name|b
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
comment|/* should do error checking here */
while|while
condition|(
name|args
operator|<
name|e
condition|)
block|{
name|string_clear
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
comment|/* Check for type or literal here */
switch|switch
condition|(
operator|*
name|args
condition|)
block|{
comment|/* HP cfront extensions to ARM for template args */
comment|/* spec: Xt1Lv1 where t1 is a type, v1 is a literal value */
comment|/* FIXME: We handle only numeric literals for HP cfront */
case|case
literal|'X'
case|:
comment|/* A typed constant value follows */
name|args
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|do_type
argument_list|(
name|work
argument_list|,
operator|&
name|args
argument_list|,
operator|&
name|type_str
argument_list|)
condition|)
goto|goto
name|cfront_template_args_done
goto|;
name|string_append
argument_list|(
operator|&
name|arg
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|string_appends
argument_list|(
operator|&
name|arg
argument_list|,
operator|&
name|type_str
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
operator|&
name|arg
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|args
operator|!=
literal|'L'
condition|)
goto|goto
name|cfront_template_args_done
goto|;
name|args
operator|++
expr_stmt|;
comment|/* Now snarf a literal value following 'L' */
if|if
condition|(
operator|!
name|snarf_numeric_literal
argument_list|(
operator|&
name|args
argument_list|,
operator|&
name|arg
argument_list|)
condition|)
goto|goto
name|cfront_template_args_done
goto|;
break|break;
case|case
literal|'L'
case|:
comment|/* Snarf a literal following 'L' */
name|args
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|snarf_numeric_literal
argument_list|(
operator|&
name|args
argument_list|,
operator|&
name|arg
argument_list|)
condition|)
goto|goto
name|cfront_template_args_done
goto|;
break|break;
default|default:
comment|/* Not handling other HP cfront stuff */
if|if
condition|(
operator|!
name|do_type
argument_list|(
name|work
argument_list|,
operator|&
name|args
argument_list|,
operator|&
name|arg
argument_list|)
condition|)
goto|goto
name|cfront_template_args_done
goto|;
block|}
name|string_appends
argument_list|(
name|declp
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|cfront_template_args_done
label|:
name|string_delete
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|>=
name|e
condition|)
operator|--
name|declp
operator|->
name|p
expr_stmt|;
comment|/* remove extra comma */
name|string_append
argument_list|(
name|declp
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>
literal|10
operator|&&
name|strncmp
argument_list|(
operator|*
name|mangled
argument_list|,
literal|"_GLOBAL_"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|*
name|mangled
operator|)
index|[
literal|9
index|]
operator|==
literal|'N'
operator|&&
operator|(
operator|*
name|mangled
operator|)
index|[
literal|8
index|]
operator|==
operator|(
operator|*
name|mangled
operator|)
index|[
literal|10
index|]
operator|&&
name|strchr
argument_list|(
name|cplus_markers
argument_list|,
operator|(
operator|*
name|mangled
operator|)
index|[
literal|8
index|]
argument_list|)
condition|)
block|{
comment|/* A member of the anonymous namespace.  */
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"{anonymous}"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|work
operator|->
name|temp_start
operator|==
operator|-
literal|1
condition|)
comment|/* non-recursive call only */
name|work
operator|->
name|temp_start
operator|=
literal|0
expr_stmt|;
comment|/* disable in recursive calls */
name|string_appendn
argument_list|(
name|declp
argument_list|,
operator|*
name|mangled
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
operator|*
name|mangled
operator|+=
name|n
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extract a class name, possibly a template with arguments, from the    mangled string; qualifiers, local class indicators, etc. have    already been dealt with */
end_comment

begin_function
specifier|static
name|int
name|demangle_class_name
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|declp
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|;
name|n
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
operator|>=
name|n
condition|)
block|{
name|demangle_arm_hp_template
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|n
argument_list|,
name|declp
argument_list|)
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	demangle_class -- demangle a mangled class sequence  SYNOPSIS  	static int 	demangle_class (struct work_stuff *work, const char **mangled, 			strint *declp)  DESCRIPTION  	DECLP points to the buffer into which demangling is being done.  	*MANGLED points to the current token to be demangled.  On input, 	it points to a mangled class (I.E. "3foo", "13verylongclass", etc.) 	On exit, it points to the next token after the mangled class on 	success, or the first unconsumed token on failure.  	If the CONSTRUCTOR or DESTRUCTOR flags are set in WORK, then 	we are demangling a constructor or destructor.  In this case 	we prepend "class::class" or "class::~class" to DECLP.  	Otherwise, we prepend "class::" to the current DECLP.  	Reset the constructor/destructor flags once they have been 	"consumed".  This allows demangle_class to be called later during 	the same demangling, to do normal class demangling.  	Returns 1 if demangling is successful, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|demangle_class
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|declp
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
block|{
name|int
name|success
init|=
literal|0
decl_stmt|;
name|int
name|btype
decl_stmt|;
name|string
name|class_name
decl_stmt|;
name|char
modifier|*
name|save_class_name_end
init|=
literal|0
decl_stmt|;
name|string_init
argument_list|(
operator|&
name|class_name
argument_list|)
expr_stmt|;
name|btype
operator|=
name|register_Btype
argument_list|(
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangle_class_name
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|class_name
argument_list|)
condition|)
block|{
name|save_class_name_end
operator|=
name|class_name
operator|.
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|work
operator|->
name|constructor
operator|&
literal|1
operator|)
operator|||
operator|(
name|work
operator|->
name|destructor
operator|&
literal|1
operator|)
condition|)
block|{
comment|/* adjust so we don't include template args */
if|if
condition|(
name|work
operator|->
name|temp_start
operator|&&
operator|(
name|work
operator|->
name|temp_start
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
name|class_name
operator|.
name|p
operator|=
name|class_name
operator|.
name|b
operator|+
name|work
operator|->
name|temp_start
expr_stmt|;
block|}
name|string_prepends
argument_list|(
name|declp
argument_list|,
operator|&
name|class_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|destructor
operator|&
literal|1
condition|)
block|{
name|string_prepend
argument_list|(
name|declp
argument_list|,
literal|"~"
argument_list|)
expr_stmt|;
name|work
operator|->
name|destructor
operator|-=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|work
operator|->
name|constructor
operator|-=
literal|1
expr_stmt|;
block|}
block|}
name|class_name
operator|.
name|p
operator|=
name|save_class_name_end
expr_stmt|;
name|remember_Ktype
argument_list|(
name|work
argument_list|,
name|class_name
operator|.
name|b
argument_list|,
name|LEN_STRING
argument_list|(
operator|&
name|class_name
argument_list|)
argument_list|)
expr_stmt|;
name|remember_Btype
argument_list|(
name|work
argument_list|,
name|class_name
operator|.
name|b
argument_list|,
name|LEN_STRING
argument_list|(
operator|&
name|class_name
argument_list|)
argument_list|,
name|btype
argument_list|)
expr_stmt|;
name|string_prepend
argument_list|(
name|declp
argument_list|,
name|SCOPE_STRING
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
name|string_prepends
argument_list|(
name|declp
argument_list|,
operator|&
name|class_name
argument_list|)
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
block|}
name|string_delete
argument_list|(
operator|&
name|class_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Called when there's a "__" in the mangled name, with `scan' pointing to    the rightmost guess.     Find the correct "__"-sequence where the function name ends and the    signature starts, which is ambiguous with GNU mangling.    Call demangle_signature here, so we can make sure we found the right    one; *mangled will be consumed so caller will not make further calls to    demangle_signature.  */
end_comment

begin_function
specifier|static
name|int
name|iterate_demangle_function
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|declp
parameter_list|,
name|scan
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
specifier|const
name|char
modifier|*
name|scan
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|mangle_init
init|=
operator|*
name|mangled
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|;
name|string
name|decl_init
decl_stmt|;
name|struct
name|work_stuff
name|work_init
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|scan
operator|+
literal|2
operator|)
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
comment|/* Do not iterate for some demangling modes, or if there's only one      "__"-sequence.  This is the normal case.  */
if|if
condition|(
name|ARM_DEMANGLING
operator|||
name|LUCID_DEMANGLING
operator|||
name|HP_DEMANGLING
operator|||
name|EDG_DEMANGLING
operator|||
name|mystrstr
argument_list|(
name|scan
operator|+
literal|2
argument_list|,
literal|"__"
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|demangle_function_name
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
name|scan
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Save state so we can restart if the guess at the correct "__" was      wrong.  */
name|string_init
argument_list|(
operator|&
name|decl_init
argument_list|)
expr_stmt|;
name|string_appends
argument_list|(
operator|&
name|decl_init
argument_list|,
name|declp
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|work_init
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|work_init
argument_list|)
expr_stmt|;
name|work_stuff_copy_to_from
argument_list|(
operator|&
name|work_init
argument_list|,
name|work
argument_list|)
expr_stmt|;
comment|/* Iterate over occurrences of __, allowing names and types to have a      "__" sequence in them.  We must start with the first (not the last)      occurrence, since "__" most often occur between independent mangled      parts, hence starting at the last occurence inside a signature      might get us a "successful" demangling of the signature.  */
while|while
condition|(
name|scan
index|[
literal|2
index|]
condition|)
block|{
name|demangle_function_name
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
name|scan
argument_list|)
expr_stmt|;
name|success
operator|=
name|demangle_signature
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
break|break;
comment|/* Reset demangle state for the next round.  */
operator|*
name|mangled
operator|=
name|mangle_init
expr_stmt|;
name|string_clear
argument_list|(
name|declp
argument_list|)
expr_stmt|;
name|string_appends
argument_list|(
name|declp
argument_list|,
operator|&
name|decl_init
argument_list|)
expr_stmt|;
name|work_stuff_copy_to_from
argument_list|(
name|work
argument_list|,
operator|&
name|work_init
argument_list|)
expr_stmt|;
comment|/* Leave this underscore-sequence.  */
name|scan
operator|+=
literal|2
expr_stmt|;
comment|/* Scan for the next "__" sequence.  */
while|while
condition|(
operator|*
name|scan
operator|&&
operator|(
name|scan
index|[
literal|0
index|]
operator|!=
literal|'_'
operator|||
name|scan
index|[
literal|1
index|]
operator|!=
literal|'_'
operator|)
condition|)
name|scan
operator|++
expr_stmt|;
comment|/* Move to last "__" in this sequence.  */
while|while
condition|(
operator|*
name|scan
operator|&&
operator|*
name|scan
operator|==
literal|'_'
condition|)
name|scan
operator|++
expr_stmt|;
name|scan
operator|-=
literal|2
expr_stmt|;
block|}
comment|/* Delete saved state.  */
name|delete_work_stuff
argument_list|(
operator|&
name|work_init
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|decl_init
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	demangle_prefix -- consume the mangled name prefix and find signature  SYNOPSIS  	static int 	demangle_prefix (struct work_stuff *work, const char **mangled, 			 string *declp);  DESCRIPTION  	Consume and demangle the prefix of the mangled name. 	While processing the function name root, arrange to call 	demangle_signature if the root is ambiguous.  	DECLP points to the string buffer into which demangled output is 	placed.  On entry, the buffer is empty.  On exit it contains 	the root function name, the demangled operator name, or in some 	special cases either nothing or the completely demangled result.  	MANGLED points to the current pointer into the mangled name.  As each 	token of the mangled name is consumed, it is updated.  Upon entry 	the current mangled name pointer points to the first character of 	the mangled name.  Upon exit, it should point to the first character 	of the signature if demangling was successful, or to the first 	unconsumed character if demangling of the prefix was unsuccessful.  	Returns 1 on success, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|demangle_prefix
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|declp
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
block|{
name|int
name|success
init|=
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|scan
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
operator|>
literal|6
operator|&&
operator|(
name|strncmp
argument_list|(
operator|*
name|mangled
argument_list|,
literal|"_imp__"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
operator|*
name|mangled
argument_list|,
literal|"__imp_"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* it's a symbol imported from a PE dynamic library. Check for both          new style prefix _imp__ and legacy __imp_ used by older versions 	 of dlltool. */
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|6
expr_stmt|;
name|work
operator|->
name|dllimported
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
operator|>=
literal|11
operator|&&
name|strncmp
argument_list|(
operator|*
name|mangled
argument_list|,
literal|"_GLOBAL_"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|marker
init|=
name|strchr
argument_list|(
name|cplus_markers
argument_list|,
operator|(
operator|*
name|mangled
operator|)
index|[
literal|8
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|marker
operator|!=
name|NULL
operator|&&
operator|*
name|marker
operator|==
operator|(
operator|*
name|mangled
operator|)
index|[
literal|10
index|]
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|9
index|]
operator|==
literal|'D'
condition|)
block|{
comment|/* it's a GNU global destructor to be executed at program exit */
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|11
expr_stmt|;
name|work
operator|->
name|destructor
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|gnu_special
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|)
condition|)
return|return
name|success
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|9
index|]
operator|==
literal|'I'
condition|)
block|{
comment|/* it's a GNU global constructor to be executed at program init */
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|11
expr_stmt|;
name|work
operator|->
name|constructor
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|gnu_special
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|)
condition|)
return|return
name|success
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ARM_DEMANGLING
operator|||
name|HP_DEMANGLING
operator|||
name|EDG_DEMANGLING
operator|)
operator|&&
name|strncmp
argument_list|(
operator|*
name|mangled
argument_list|,
literal|"__std__"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* it's a ARM global destructor to be executed at program exit */
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|7
expr_stmt|;
name|work
operator|->
name|destructor
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ARM_DEMANGLING
operator|||
name|HP_DEMANGLING
operator|||
name|EDG_DEMANGLING
operator|)
operator|&&
name|strncmp
argument_list|(
operator|*
name|mangled
argument_list|,
literal|"__sti__"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* it's a ARM global constructor to be executed at program initial */
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|7
expr_stmt|;
name|work
operator|->
name|constructor
operator|=
literal|2
expr_stmt|;
block|}
comment|/*  This block of code is a reduction in strength time optimization       of:       scan = mystrstr (*mangled, "__"); */
block|{
name|scan
operator|=
operator|*
name|mangled
expr_stmt|;
do|do
block|{
name|scan
operator|=
name|strchr
argument_list|(
name|scan
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|scan
operator|!=
name|NULL
operator|&&
operator|*
operator|++
name|scan
operator|!=
literal|'_'
condition|)
do|;
if|if
condition|(
name|scan
operator|!=
name|NULL
condition|)
operator|--
name|scan
expr_stmt|;
block|}
if|if
condition|(
name|scan
operator|!=
name|NULL
condition|)
block|{
comment|/* We found a sequence of two or more '_', ensure that we start at 	 the last pair in the sequence.  */
name|i
operator|=
name|strspn
argument_list|(
name|scan
argument_list|,
literal|"_"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|2
condition|)
block|{
name|scan
operator|+=
operator|(
name|i
operator|-
literal|2
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|scan
operator|==
name|NULL
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|work
operator|->
name|static_type
condition|)
block|{
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|scan
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|(
name|scan
index|[
literal|0
index|]
operator|!=
literal|'t'
operator|)
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|scan
operator|==
operator|*
name|mangled
operator|)
operator|&&
operator|(
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|scan
index|[
literal|2
index|]
argument_list|)
operator|||
operator|(
name|scan
index|[
literal|2
index|]
operator|==
literal|'Q'
operator|)
operator|||
operator|(
name|scan
index|[
literal|2
index|]
operator|==
literal|'t'
operator|)
operator|||
operator|(
name|scan
index|[
literal|2
index|]
operator|==
literal|'K'
operator|)
operator|||
operator|(
name|scan
index|[
literal|2
index|]
operator|==
literal|'H'
operator|)
operator|)
condition|)
block|{
comment|/* The ARM says nothing about the mangling of local variables. 	 But cfront mangles local variables by prepending __<nesting_level> 	 to them. As an extension to ARM demangling we handle this case.  */
if|if
condition|(
operator|(
name|LUCID_DEMANGLING
operator|||
name|ARM_DEMANGLING
operator|||
name|HP_DEMANGLING
operator|)
operator|&&
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|scan
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
operator|*
name|mangled
operator|=
name|scan
operator|+
literal|2
expr_stmt|;
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
operator|*
name|mangled
argument_list|)
expr_stmt|;
operator|*
name|mangled
operator|+=
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* A GNU style constructor starts with __[0-9Qt].  But cfront uses 	     names like __Q2_3foo3bar for nested type names.  So don't accept 	     this style of constructor for cfront demangling.  A GNU 	     style member-template constructor starts with 'H'. */
if|if
condition|(
operator|!
operator|(
name|LUCID_DEMANGLING
operator|||
name|ARM_DEMANGLING
operator|||
name|HP_DEMANGLING
operator|||
name|EDG_DEMANGLING
operator|)
condition|)
name|work
operator|->
name|constructor
operator|+=
literal|1
expr_stmt|;
operator|*
name|mangled
operator|=
name|scan
operator|+
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ARM_DEMANGLING
operator|&&
name|scan
index|[
literal|2
index|]
operator|==
literal|'p'
operator|&&
name|scan
index|[
literal|3
index|]
operator|==
literal|'t'
condition|)
block|{
comment|/* Cfront-style parameterized type.  Handled later as a signature. */
name|success
operator|=
literal|1
expr_stmt|;
comment|/* ARM template? */
name|demangle_arm_hp_template
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
argument_list|,
name|declp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|EDG_DEMANGLING
operator|&&
operator|(
operator|(
name|scan
index|[
literal|2
index|]
operator|==
literal|'t'
operator|&&
name|scan
index|[
literal|3
index|]
operator|==
literal|'m'
operator|)
operator|||
operator|(
name|scan
index|[
literal|2
index|]
operator|==
literal|'p'
operator|&&
name|scan
index|[
literal|3
index|]
operator|==
literal|'s'
operator|)
operator|||
operator|(
name|scan
index|[
literal|2
index|]
operator|==
literal|'p'
operator|&&
name|scan
index|[
literal|3
index|]
operator|==
literal|'t'
operator|)
operator|)
condition|)
block|{
comment|/* EDG-style parameterized type.  Handled later as a signature. */
name|success
operator|=
literal|1
expr_stmt|;
comment|/* EDG template? */
name|demangle_arm_hp_template
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
argument_list|,
name|declp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|scan
operator|==
operator|*
name|mangled
operator|)
operator|&&
operator|!
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|scan
index|[
literal|2
index|]
argument_list|)
operator|&&
operator|(
name|scan
index|[
literal|2
index|]
operator|!=
literal|'t'
operator|)
condition|)
block|{
comment|/* Mangled name starts with "__".  Skip over any leading '_' characters, 	 then find the next "__" that separates the prefix from the signature. 	 */
if|if
condition|(
operator|!
operator|(
name|ARM_DEMANGLING
operator|||
name|LUCID_DEMANGLING
operator|||
name|HP_DEMANGLING
operator|||
name|EDG_DEMANGLING
operator|)
operator|||
operator|(
name|arm_special
argument_list|(
name|mangled
argument_list|,
name|declp
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
while|while
condition|(
operator|*
name|scan
operator|==
literal|'_'
condition|)
block|{
name|scan
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|scan
operator|=
name|mystrstr
argument_list|(
name|scan
argument_list|,
literal|"__"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
operator|*
operator|(
name|scan
operator|+
literal|2
operator|)
operator|==
literal|'\0'
operator|)
condition|)
block|{
comment|/* No separator (I.E. "__not_mangled"), or empty signature 		 (I.E. "__not_mangled_either__") */
name|success
operator|=
literal|0
expr_stmt|;
block|}
else|else
return|return
name|iterate_demangle_function
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
name|scan
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|scan
operator|+
literal|2
operator|)
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Mangled name does not start with "__" but does have one somewhere 	 in there with non empty stuff after it.  Looks like a global 	 function name.  Iterate over all "__":s until the right 	 one is found.  */
return|return
name|iterate_demangle_function
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
name|scan
argument_list|)
return|;
block|}
else|else
block|{
comment|/* Doesn't look like a mangled name */
name|success
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|success
operator|&&
operator|(
name|work
operator|->
name|constructor
operator|==
literal|2
operator|||
name|work
operator|->
name|destructor
operator|==
literal|2
operator|)
condition|)
block|{
name|string_append
argument_list|(
name|declp
argument_list|,
operator|*
name|mangled
argument_list|)
expr_stmt|;
operator|*
name|mangled
operator|+=
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	gnu_special -- special handling of gnu mangled strings  SYNOPSIS  	static int 	gnu_special (struct work_stuff *work, const char **mangled, 		     string *declp);   DESCRIPTION  	Process some special GNU style mangling forms that don't fit 	the normal pattern.  For example:  		_$_3foo		(destructor for class foo) 		_vt$foo		(foo virtual table) 		_vt$foo$bar	(foo::bar virtual table) 		__vt_foo	(foo virtual table, new style with thunks) 		_3foo$varname	(static data member) 		_Q22rs2tu$vw	(static data member) 		__t6vector1Zii	(constructor with template) 		__thunk_4__$_7ostream (virtual function thunk)  */
end_comment

begin_function
specifier|static
name|int
name|gnu_special
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|declp
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|success
init|=
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|strchr
argument_list|(
name|cplus_markers
argument_list|,
operator|(
operator|*
name|mangled
operator|)
index|[
literal|1
index|]
argument_list|)
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|mangled
operator|)
index|[
literal|2
index|]
operator|==
literal|'_'
condition|)
block|{
comment|/* Found a GNU style destructor, get past "_<CPLUS_MARKER>_" */
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|3
expr_stmt|;
name|work
operator|->
name|destructor
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
operator|(
operator|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
operator|(
operator|*
name|mangled
operator|)
index|[
literal|2
index|]
operator|==
literal|'v'
operator|&&
operator|(
operator|*
name|mangled
operator|)
index|[
literal|3
index|]
operator|==
literal|'t'
operator|&&
operator|(
operator|*
name|mangled
operator|)
index|[
literal|4
index|]
operator|==
literal|'_'
operator|)
operator|||
operator|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|1
index|]
operator|==
literal|'v'
operator|&&
operator|(
operator|*
name|mangled
operator|)
index|[
literal|2
index|]
operator|==
literal|'t'
operator|&&
name|strchr
argument_list|(
name|cplus_markers
argument_list|,
operator|(
operator|*
name|mangled
operator|)
index|[
literal|3
index|]
argument_list|)
operator|!=
name|NULL
operator|)
operator|)
condition|)
block|{
comment|/* Found a GNU style virtual table, get past "_vt<CPLUS_MARKER>"          and create the decl.  Note that we consume the entire mangled 	 input string, which means that demangle_signature has no work 	 to do.  */
if|if
condition|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|2
index|]
operator|==
literal|'v'
condition|)
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|5
expr_stmt|;
comment|/* New style, with thunks: "__vt_" */
else|else
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|4
expr_stmt|;
comment|/* Old style, no thunks: "_vt<CPLUS_MARKER>" */
while|while
condition|(
operator|*
operator|*
name|mangled
operator|!=
literal|'\0'
condition|)
block|{
switch|switch
condition|(
operator|*
operator|*
name|mangled
condition|)
block|{
case|case
literal|'Q'
case|:
case|case
literal|'K'
case|:
name|success
operator|=
name|demangle_qualified
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|success
operator|=
name|demangle_template
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|mangled
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|n
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
comment|/* We may be seeing a too-large size, or else a 		     ".<digits>" indicating a static local symbol.  In 		     any case, declare victory and move on; *don't* try 		     to use n to allocate.  */
if|if
condition|(
name|n
operator|>
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
condition|)
block|{
name|success
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|n
operator|=
name|strcspn
argument_list|(
operator|*
name|mangled
argument_list|,
name|cplus_markers
argument_list|)
expr_stmt|;
block|}
name|string_appendn
argument_list|(
name|declp
argument_list|,
operator|*
name|mangled
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|+=
name|n
expr_stmt|;
block|}
name|p
operator|=
name|strpbrk
argument_list|(
operator|*
name|mangled
argument_list|,
name|cplus_markers
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
operator|&&
operator|(
operator|(
name|p
operator|==
name|NULL
operator|)
operator|||
operator|(
name|p
operator|==
operator|*
name|mangled
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|string_append
argument_list|(
name|declp
argument_list|,
name|SCOPE_STRING
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|success
condition|)
name|string_append
argument_list|(
name|declp
argument_list|,
literal|" virtual table"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
operator|(
name|strchr
argument_list|(
literal|"0123456789Qt"
argument_list|,
operator|(
operator|*
name|mangled
operator|)
index|[
literal|1
index|]
argument_list|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|p
operator|=
name|strpbrk
argument_list|(
operator|*
name|mangled
argument_list|,
name|cplus_markers
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* static data member, "_3foo$varname" for example */
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|mangled
condition|)
block|{
case|case
literal|'Q'
case|:
case|case
literal|'K'
case|:
name|success
operator|=
name|demangle_qualified
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|success
operator|=
name|demangle_template
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|n
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
operator|(
name|long
operator|)
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|n
operator|>
literal|10
operator|&&
name|strncmp
argument_list|(
operator|*
name|mangled
argument_list|,
literal|"_GLOBAL_"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|*
name|mangled
operator|)
index|[
literal|9
index|]
operator|==
literal|'N'
operator|&&
operator|(
operator|*
name|mangled
operator|)
index|[
literal|8
index|]
operator|==
operator|(
operator|*
name|mangled
operator|)
index|[
literal|10
index|]
operator|&&
name|strchr
argument_list|(
name|cplus_markers
argument_list|,
operator|(
operator|*
name|mangled
operator|)
index|[
literal|8
index|]
argument_list|)
condition|)
block|{
comment|/* A member of the anonymous namespace.  There's information 		 about what identifier or filename it was keyed to, but 		 it's just there to make the mangled name unique; we just 		 step over it.  */
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"{anonymous}"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|+=
name|n
expr_stmt|;
comment|/* Now p points to the marker before the N, so we need to 		 update it to the first marker after what we consumed.  */
name|p
operator|=
name|strpbrk
argument_list|(
operator|*
name|mangled
argument_list|,
name|cplus_markers
argument_list|)
expr_stmt|;
break|break;
block|}
name|string_appendn
argument_list|(
name|declp
argument_list|,
operator|*
name|mangled
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|success
operator|&&
operator|(
name|p
operator|==
operator|*
name|mangled
operator|)
condition|)
block|{
comment|/* Consumed everything up to the cplus_marker, append the 	     variable name.  */
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
name|SCOPE_STRING
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
expr_stmt|;
name|string_appendn
argument_list|(
name|declp
argument_list|,
operator|*
name|mangled
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|+=
name|n
expr_stmt|;
block|}
else|else
block|{
name|success
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|mangled
argument_list|,
literal|"__thunk_"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|delta
decl_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|8
expr_stmt|;
name|delta
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|==
operator|-
literal|1
condition|)
name|success
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|method
init|=
name|internal_cplus_demangle
argument_list|(
name|work
argument_list|,
operator|++
operator|*
name|mangled
argument_list|)
decl_stmt|;
if|if
condition|(
name|method
condition|)
block|{
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"virtual function thunk (delta:%d) for "
argument_list|,
operator|-
name|delta
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
name|method
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|method
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|+=
name|n
expr_stmt|;
block|}
else|else
block|{
name|success
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|mangled
argument_list|,
literal|"__t"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|3
index|]
operator|==
literal|'i'
operator|||
operator|(
operator|*
name|mangled
operator|)
index|[
literal|3
index|]
operator|==
literal|'f'
operator|)
condition|)
block|{
name|p
operator|=
operator|(
operator|*
name|mangled
operator|)
index|[
literal|3
index|]
operator|==
literal|'i'
condition|?
literal|" type_info node"
else|:
literal|" type_info function"
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|4
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|mangled
condition|)
block|{
case|case
literal|'Q'
case|:
case|case
literal|'K'
case|:
name|success
operator|=
name|demangle_qualified
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|success
operator|=
name|demangle_template
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|success
operator|=
name|do_type
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|success
operator|&&
operator|*
operator|*
name|mangled
operator|!=
literal|'\0'
condition|)
name|success
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|string_append
argument_list|(
name|declp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|success
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|recursively_demangle
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|result
parameter_list|,
name|namelength
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|result
decl_stmt|;
name|int
name|namelength
decl_stmt|;
block|{
name|char
modifier|*
name|recurse
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|char
modifier|*
name|recurse_dem
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|recurse
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|namelength
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|recurse
argument_list|,
operator|*
name|mangled
argument_list|,
name|namelength
argument_list|)
expr_stmt|;
name|recurse
index|[
name|namelength
index|]
operator|=
literal|'\000'
expr_stmt|;
name|recurse_dem
operator|=
name|cplus_demangle
argument_list|(
name|recurse
argument_list|,
name|work
operator|->
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|recurse_dem
condition|)
block|{
name|string_append
argument_list|(
name|result
argument_list|,
name|recurse_dem
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|recurse_dem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|string_appendn
argument_list|(
name|result
argument_list|,
operator|*
name|mangled
argument_list|,
name|namelength
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|recurse
argument_list|)
expr_stmt|;
operator|*
name|mangled
operator|+=
name|namelength
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	arm_special -- special handling of ARM/lucid mangled strings  SYNOPSIS  	static int 	arm_special (const char **mangled, 		     string *declp);   DESCRIPTION  	Process some special ARM style mangling forms that don't fit 	the normal pattern.  For example:  		__vtbl__3foo		(foo virtual table) 		__vtbl__3foo__3bar	(bar::foo virtual table)   */
end_comment

begin_function
specifier|static
name|int
name|arm_special
parameter_list|(
name|mangled
parameter_list|,
name|declp
parameter_list|)
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|success
init|=
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|scan
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|mangled
argument_list|,
name|ARM_VTABLE_STRING
argument_list|,
name|ARM_VTABLE_STRLEN
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Found a ARM style virtual table, get past ARM_VTABLE_STRING          and create the decl.  Note that we consume the entire mangled 	 input string, which means that demangle_signature has no work 	 to do.  */
name|scan
operator|=
operator|*
name|mangled
operator|+
name|ARM_VTABLE_STRLEN
expr_stmt|;
while|while
condition|(
operator|*
name|scan
operator|!=
literal|'\0'
condition|)
comment|/* first check it can be demangled */
block|{
name|n
operator|=
name|consume_count
argument_list|(
operator|&
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* no good */
block|}
name|scan
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|scan
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|scan
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
block|{
name|scan
operator|+=
literal|2
expr_stmt|;
block|}
block|}
operator|(
operator|*
name|mangled
operator|)
operator|+=
name|ARM_VTABLE_STRLEN
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|mangled
operator|!=
literal|'\0'
condition|)
block|{
name|n
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
operator|||
name|n
operator|>
operator|(
name|long
operator|)
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
condition|)
return|return
literal|0
return|;
name|string_prependn
argument_list|(
name|declp
argument_list|,
operator|*
name|mangled
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|+=
name|n
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
operator|(
operator|*
name|mangled
operator|)
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
block|{
name|string_prepend
argument_list|(
name|declp
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|string_append
argument_list|(
name|declp
argument_list|,
literal|" virtual table"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|success
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	demangle_qualified -- demangle 'Q' qualified name strings  SYNOPSIS  	static int 	demangle_qualified (struct work_stuff *, const char *mangled, 			    string *result, int isfuncname, int append);  DESCRIPTION  	Demangle a qualified name, such as "Q25Outer5Inner" which is 	the mangled form of "Outer::Inner".  The demangled output is 	prepended or appended to the result string according to the 	state of the append flag.  	If isfuncname is nonzero, then the qualified name we are building 	is going to be used as a member function name, so if it is a 	constructor or destructor function, append an appropriate 	constructor or destructor name.  I.E. for the above example, 	the result for use as a constructor is "Outer::Inner::Inner" 	and the result for use as a destructor is "Outer::Inner::~Inner".  BUGS  	Numeric conversion is ASCII dependent (FIXME).   */
end_comment

begin_function
specifier|static
name|int
name|demangle_qualified
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|result
parameter_list|,
name|isfuncname
parameter_list|,
name|append
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|result
decl_stmt|;
name|int
name|isfuncname
decl_stmt|;
name|int
name|append
decl_stmt|;
block|{
name|int
name|qualifiers
init|=
literal|0
decl_stmt|;
name|int
name|success
init|=
literal|1
decl_stmt|;
name|char
name|num
index|[
literal|2
index|]
decl_stmt|;
name|string
name|temp
decl_stmt|;
name|string
name|last_name
decl_stmt|;
name|int
name|bindex
init|=
name|register_Btype
argument_list|(
name|work
argument_list|)
decl_stmt|;
comment|/* We only make use of ISFUNCNAME if the entity is a constructor or      destructor.  */
name|isfuncname
operator|=
operator|(
name|isfuncname
operator|&&
operator|(
operator|(
name|work
operator|->
name|constructor
operator|&
literal|1
operator|)
operator|||
operator|(
name|work
operator|->
name|destructor
operator|&
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
name|string_init
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
name|string_init
argument_list|(
operator|&
name|last_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|0
index|]
operator|==
literal|'K'
condition|)
block|{
comment|/* Squangling qualified name reuse */
name|int
name|idx
decl_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|idx
operator|=
name|consume_count_with_underscores
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
operator|||
name|idx
operator|>=
name|work
operator|->
name|numk
condition|)
name|success
operator|=
literal|0
expr_stmt|;
else|else
name|string_append
argument_list|(
operator|&
name|temp
argument_list|,
name|work
operator|->
name|ktypevec
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'_'
case|:
comment|/* GNU mangled name with more than 9 classes.  The count is preceded 	 by an underscore (to distinguish it from the<= 9 case) and followed 	 by an underscore.  */
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|qualifiers
operator|=
name|consume_count_with_underscores
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|qualifiers
operator|==
operator|-
literal|1
condition|)
name|success
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* The count is in a single digit.  */
name|num
index|[
literal|0
index|]
operator|=
operator|(
operator|*
name|mangled
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|num
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|qualifiers
operator|=
name|atoi
argument_list|(
name|num
argument_list|)
expr_stmt|;
comment|/* If there is an underscore after the digit, skip it.  This is 	 said to be for ARM-qualified names, but the ARM makes no 	 mention of such an underscore.  Perhaps cfront uses one.  */
if|if
condition|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|2
index|]
operator|==
literal|'_'
condition|)
block|{
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
default|default:
name|success
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|success
condition|)
return|return
name|success
return|;
comment|/* Pick off the names and collect them in the temp buffer in the order      in which they are found, separated by '::'.  */
while|while
condition|(
name|qualifiers
operator|--
operator|>
literal|0
condition|)
block|{
name|int
name|remember_K
init|=
literal|1
decl_stmt|;
name|string_clear
argument_list|(
operator|&
name|last_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mangled
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|mangled
index|[
literal|0
index|]
operator|==
literal|'t'
condition|)
block|{
comment|/* Here we always append to TEMP since we will want to use 	     the template name without the template parameters as a 	     constructor or destructor name.  The appropriate 	     (parameter-less) value is returned by demangle_template 	     in LAST_NAME.  We do not remember the template type here, 	     in order to match the G++ mangling algorithm.  */
name|success
operator|=
name|demangle_template
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|temp
argument_list|,
operator|&
name|last_name
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|mangled
index|[
literal|0
index|]
operator|==
literal|'K'
condition|)
block|{
name|int
name|idx
decl_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|idx
operator|=
name|consume_count_with_underscores
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
operator|||
name|idx
operator|>=
name|work
operator|->
name|numk
condition|)
name|success
operator|=
literal|0
expr_stmt|;
else|else
name|string_append
argument_list|(
operator|&
name|temp
argument_list|,
name|work
operator|->
name|ktypevec
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|remember_K
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
name|EDG_DEMANGLING
condition|)
block|{
name|int
name|namelength
decl_stmt|;
comment|/* Now recursively demangle the qualifier  	       * This is necessary to deal with templates in  	       * mangling styles like EDG */
name|namelength
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|namelength
operator|==
operator|-
literal|1
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|recursively_demangle
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|temp
argument_list|,
name|namelength
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|success
operator|=
name|do_type
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|last_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
break|break;
name|string_appends
argument_list|(
operator|&
name|temp
argument_list|,
operator|&
name|last_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|remember_K
condition|)
name|remember_Ktype
argument_list|(
name|work
argument_list|,
name|temp
operator|.
name|b
argument_list|,
name|LEN_STRING
argument_list|(
operator|&
name|temp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qualifiers
operator|>
literal|0
condition|)
name|string_append
argument_list|(
operator|&
name|temp
argument_list|,
name|SCOPE_STRING
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|remember_Btype
argument_list|(
name|work
argument_list|,
name|temp
operator|.
name|b
argument_list|,
name|LEN_STRING
argument_list|(
operator|&
name|temp
argument_list|)
argument_list|,
name|bindex
argument_list|)
expr_stmt|;
comment|/* If we are using the result as a function name, we need to append      the appropriate '::' separated constructor or destructor name.      We do this here because this is the most convenient place, where      we already have a pointer to the name and the length of the name.  */
if|if
condition|(
name|isfuncname
condition|)
block|{
name|string_append
argument_list|(
operator|&
name|temp
argument_list|,
name|SCOPE_STRING
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|destructor
operator|&
literal|1
condition|)
name|string_append
argument_list|(
operator|&
name|temp
argument_list|,
literal|"~"
argument_list|)
expr_stmt|;
name|string_appends
argument_list|(
operator|&
name|temp
argument_list|,
operator|&
name|last_name
argument_list|)
expr_stmt|;
block|}
comment|/* Now either prepend the temp buffer to the result, or append it,      depending upon the state of the append flag.  */
if|if
condition|(
name|append
condition|)
name|string_appends
argument_list|(
name|result
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|STRING_EMPTY
argument_list|(
name|result
argument_list|)
condition|)
name|string_append
argument_list|(
operator|&
name|temp
argument_list|,
name|SCOPE_STRING
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
name|string_prepends
argument_list|(
name|result
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
name|string_delete
argument_list|(
operator|&
name|last_name
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	get_count -- convert an ascii count to integer, consuming tokens  SYNOPSIS  	static int 	get_count (const char **type, int *count)  DESCRIPTION  	Assume that *type points at a count in a mangled name; set 	*count to its value, and set *type to the next character after 	the count.  There are some weird rules in effect here.  	If *type does not point at a string of digits, return zero.  	If *type points at a string of digits followed by an 	underscore, set *count to their value as an integer, advance 	*type to point *after the underscore, and return 1.  	If *type points at a string of digits not followed by an 	underscore, consume only the first digit.  Set *count to its 	value as an integer, leave *type pointing after that digit, 	and return 1.          The excuse for this odd behavior: in the ARM and HP demangling         styles, a type can be followed by a repeat count of the form         `Nxy', where:          `x' is a single digit specifying how many additional copies             of the type to append to the argument list, and          `y' is one or more digits, specifying the zero-based index of             the first repeated argument in the list.  Yes, as you're             unmangling the name you can figure this out yourself, but             it's there anyway.          So, for example, in `bar__3fooFPiN51', the first argument is a         pointer to an integer (`Pi'), and then the next five arguments         are the same (`N5'), and the first repeat is the function's         second argument (`1'). */
end_comment

begin_function
specifier|static
name|int
name|get_count
parameter_list|(
name|type
parameter_list|,
name|count
parameter_list|)
specifier|const
name|char
modifier|*
modifier|*
name|type
decl_stmt|;
name|int
modifier|*
name|count
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|type
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
block|{
operator|*
name|count
operator|=
operator|*
operator|*
name|type
operator|-
literal|'0'
expr_stmt|;
operator|(
operator|*
name|type
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|type
argument_list|)
condition|)
block|{
name|p
operator|=
operator|*
name|type
expr_stmt|;
name|n
operator|=
operator|*
name|count
expr_stmt|;
do|do
block|{
name|n
operator|*=
literal|10
expr_stmt|;
name|n
operator|+=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|)
do|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'_'
condition|)
block|{
operator|*
name|type
operator|=
name|p
operator|+
literal|1
expr_stmt|;
operator|*
name|count
operator|=
name|n
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* RESULT will be initialised here; it will be freed on failure.  The    value returned is really a type_kind_t.  */
end_comment

begin_function
specifier|static
name|int
name|do_type
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|result
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|result
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|done
decl_stmt|;
name|int
name|success
decl_stmt|;
name|string
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|remembered_type
decl_stmt|;
name|int
name|type_quals
decl_stmt|;
name|string
name|btype
decl_stmt|;
name|type_kind_t
name|tk
init|=
name|tk_none
decl_stmt|;
name|string_init
argument_list|(
operator|&
name|btype
argument_list|)
expr_stmt|;
name|string_init
argument_list|(
operator|&
name|decl
argument_list|)
expr_stmt|;
name|string_init
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|success
operator|&&
operator|!
name|done
condition|)
block|{
name|int
name|member
decl_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|mangled
condition|)
block|{
comment|/* A pointer type */
case|case
literal|'P'
case|:
case|case
literal|'p'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|work
operator|->
name|options
operator|&
name|DMGL_JAVA
operator|)
condition|)
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tk
operator|==
name|tk_none
condition|)
name|tk
operator|=
name|tk_pointer
expr_stmt|;
break|break;
comment|/* A reference type */
case|case
literal|'R'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tk
operator|==
name|tk_none
condition|)
name|tk
operator|=
name|tk_reference
expr_stmt|;
break|break;
comment|/* An array */
case|case
literal|'A'
case|:
block|{
operator|++
operator|(
operator|*
name|mangled
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|STRING_EMPTY
argument_list|(
operator|&
name|decl
argument_list|)
operator|&&
operator|(
name|decl
operator|.
name|b
index|[
literal|0
index|]
operator|==
literal|'*'
operator|||
name|decl
operator|.
name|b
index|[
literal|0
index|]
operator|==
literal|'&'
operator|)
condition|)
block|{
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
operator|&
name|decl
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|string_append
argument_list|(
operator|&
name|decl
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|mangled
operator|!=
literal|'_'
condition|)
name|success
operator|=
name|demangle_template_value_parm
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|decl
argument_list|,
name|tk_integral
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'_'
condition|)
operator|++
operator|(
operator|*
name|mangled
operator|)
expr_stmt|;
name|string_append
argument_list|(
operator|&
name|decl
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* A back reference to a previously seen type */
case|case
literal|'T'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|get_count
argument_list|(
name|mangled
argument_list|,
operator|&
name|n
argument_list|)
operator|||
name|n
operator|>=
name|work
operator|->
name|ntypes
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|remembered_type
operator|=
name|work
operator|->
name|typevec
index|[
name|n
index|]
expr_stmt|;
name|mangled
operator|=
operator|&
name|remembered_type
expr_stmt|;
block|}
break|break;
comment|/* A function */
case|case
literal|'F'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|STRING_EMPTY
argument_list|(
operator|&
name|decl
argument_list|)
operator|&&
operator|(
name|decl
operator|.
name|b
index|[
literal|0
index|]
operator|==
literal|'*'
operator|||
name|decl
operator|.
name|b
index|[
literal|0
index|]
operator|==
literal|'&'
operator|)
condition|)
block|{
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
operator|&
name|decl
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
comment|/* After picking off the function args, we expect to either find the 	     function return type (preceded by an '_') or the end of the 	     string.  */
if|if
condition|(
operator|!
name|demangle_nested_args
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|decl
argument_list|)
operator|||
operator|(
operator|*
operator|*
name|mangled
operator|!=
literal|'_'
operator|&&
operator|*
operator|*
name|mangled
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|success
operator|&&
operator|(
operator|*
operator|*
name|mangled
operator|==
literal|'_'
operator|)
condition|)
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
case|case
literal|'O'
case|:
block|{
name|type_quals
operator|=
name|TYPE_UNQUALIFIED
expr_stmt|;
name|member
operator|=
operator|*
operator|*
name|mangled
operator|==
literal|'M'
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|string_append
argument_list|(
operator|&
name|decl
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
comment|/* We don't need to prepend `::' for a qualified name; 	       demangle_qualified will do that for us.  */
if|if
condition|(
operator|*
operator|*
name|mangled
operator|!=
literal|'Q'
condition|)
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
name|SCOPE_STRING
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|mangled
argument_list|)
condition|)
block|{
name|n
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
operator|||
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
operator|<
name|n
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|string_prependn
argument_list|(
operator|&
name|decl
argument_list|,
operator|*
name|mangled
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|*
name|mangled
operator|+=
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'X'
operator|||
operator|*
operator|*
name|mangled
operator|==
literal|'Y'
condition|)
block|{
name|string
name|temp
decl_stmt|;
name|do_type
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|string_prepends
argument_list|(
operator|&
name|decl
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'t'
condition|)
block|{
name|string
name|temp
decl_stmt|;
name|string_init
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
name|success
operator|=
name|demangle_template
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|string_prependn
argument_list|(
operator|&
name|decl
argument_list|,
name|temp
operator|.
name|b
argument_list|,
name|temp
operator|.
name|p
operator|-
name|temp
operator|.
name|b
argument_list|)
expr_stmt|;
name|string_clear
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'Q'
condition|)
block|{
name|success
operator|=
name|demangle_qualified
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|decl
argument_list|,
comment|/*isfuncnam=*/
literal|0
argument_list|,
comment|/*append=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
break|break;
block|}
else|else
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
if|if
condition|(
name|member
condition|)
block|{
switch|switch
condition|(
operator|*
operator|*
name|mangled
condition|)
block|{
case|case
literal|'C'
case|:
case|case
literal|'V'
case|:
case|case
literal|'u'
case|:
name|type_quals
operator||=
name|code_for_qualifier
argument_list|(
operator|*
operator|*
name|mangled
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|*
operator|(
operator|*
name|mangled
operator|)
operator|++
operator|!=
literal|'F'
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|member
operator|&&
operator|!
name|demangle_nested_args
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|decl
argument_list|)
operator|)
operator|||
operator|*
operator|*
name|mangled
operator|!=
literal|'_'
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|PRINT_ANSI_QUALIFIERS
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|type_quals
operator|!=
name|TYPE_UNQUALIFIED
condition|)
block|{
name|APPEND_BLANK
argument_list|(
operator|&
name|decl
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
operator|&
name|decl
argument_list|,
name|qualifier_string
argument_list|(
name|type_quals
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'G'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
case|case
literal|'V'
case|:
case|case
literal|'u'
case|:
if|if
condition|(
name|PRINT_ANSI_QUALIFIERS
condition|)
block|{
if|if
condition|(
operator|!
name|STRING_EMPTY
argument_list|(
operator|&
name|decl
argument_list|)
condition|)
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
name|demangle_qualifier
argument_list|(
operator|*
operator|*
name|mangled
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
break|break;
comment|/* 	    } 	    */
comment|/* fall through */
default|default:
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|success
condition|)
switch|switch
condition|(
operator|*
operator|*
name|mangled
condition|)
block|{
comment|/* A qualified name, such as "Outer::Inner".  */
case|case
literal|'Q'
case|:
case|case
literal|'K'
case|:
block|{
name|success
operator|=
name|demangle_qualified
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* A back reference to a previously seen squangled type */
case|case
literal|'B'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|get_count
argument_list|(
name|mangled
argument_list|,
operator|&
name|n
argument_list|)
operator|||
name|n
operator|>=
name|work
operator|->
name|numb
condition|)
name|success
operator|=
literal|0
expr_stmt|;
else|else
name|string_append
argument_list|(
name|result
argument_list|,
name|work
operator|->
name|btypevec
index|[
name|n
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
comment|/* A template parm.  We substitute the corresponding argument. */
block|{
name|int
name|idx
decl_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|idx
operator|=
name|consume_count_with_underscores
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
operator|||
operator|(
name|work
operator|->
name|tmpl_argvec
operator|&&
name|idx
operator|>=
name|work
operator|->
name|ntmpl_args
operator|)
operator|||
name|consume_count_with_underscores
argument_list|(
name|mangled
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|work
operator|->
name|tmpl_argvec
condition|)
name|string_append
argument_list|(
name|result
argument_list|,
name|work
operator|->
name|tmpl_argvec
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
else|else
name|string_append_template_idx
argument_list|(
name|result
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
name|success
operator|=
name|demangle_fund_type
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|tk
operator|==
name|tk_none
condition|)
name|tk
operator|=
operator|(
name|type_kind_t
operator|)
name|success
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
operator|!
name|STRING_EMPTY
argument_list|(
operator|&
name|decl
argument_list|)
condition|)
block|{
name|string_append
argument_list|(
name|result
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|string_appends
argument_list|(
name|result
argument_list|,
operator|&
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|string_delete
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
comment|/* Assume an integral type, if we're not sure.  */
return|return
call|(
name|int
call|)
argument_list|(
operator|(
name|tk
operator|==
name|tk_none
operator|)
condition|?
name|tk_integral
else|:
name|tk
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a type string that represents a fundamental type    argument (int, long, unsigned int, etc) in TYPE, a pointer to the    string in which the demangled output is being built in RESULT, and    the WORK structure, decode the types and add them to the result.     For example:     	"Ci"	=>	"const int" 	"Sl"	=>	"signed long" 	"CUs"	=>	"const unsigned short"     The value returned is really a type_kind_t.  */
end_comment

begin_function
specifier|static
name|int
name|demangle_fund_type
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|result
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|result
decl_stmt|;
block|{
name|int
name|done
init|=
literal|0
decl_stmt|;
name|int
name|success
init|=
literal|1
decl_stmt|;
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|unsigned
name|int
name|dec
init|=
literal|0
decl_stmt|;
name|string
name|btype
decl_stmt|;
name|type_kind_t
name|tk
init|=
name|tk_integral
decl_stmt|;
name|string_init
argument_list|(
operator|&
name|btype
argument_list|)
expr_stmt|;
comment|/* First pick off any type qualifiers.  There can be more than one.  */
while|while
condition|(
operator|!
name|done
condition|)
block|{
switch|switch
condition|(
operator|*
operator|*
name|mangled
condition|)
block|{
case|case
literal|'C'
case|:
case|case
literal|'V'
case|:
case|case
literal|'u'
case|:
if|if
condition|(
name|PRINT_ANSI_QUALIFIERS
condition|)
block|{
if|if
condition|(
operator|!
name|STRING_EMPTY
argument_list|(
name|result
argument_list|)
condition|)
name|string_prepend
argument_list|(
name|result
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|string_prepend
argument_list|(
name|result
argument_list|,
name|demangle_qualifier
argument_list|(
operator|*
operator|*
name|mangled
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"unsigned"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* signed char only */
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"signed"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"__complex"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Now pick off the fundamental type.  There can be only one.  */
switch|switch
condition|(
operator|*
operator|*
name|mangled
condition|)
block|{
case|case
literal|'\0'
case|:
case|case
literal|'_'
case|:
break|break;
case|case
literal|'v'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"long long"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"long"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"int"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"short"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"bool"
argument_list|)
expr_stmt|;
name|tk
operator|=
name|tk_bool
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"char"
argument_list|)
expr_stmt|;
name|tk
operator|=
name|tk_char
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"wchar_t"
argument_list|)
expr_stmt|;
name|tk
operator|=
name|tk_char
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"long double"
argument_list|)
expr_stmt|;
name|tk
operator|=
name|tk_real
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"double"
argument_list|)
expr_stmt|;
name|tk
operator|=
name|tk_real
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"float"
argument_list|)
expr_stmt|;
name|tk
operator|=
name|tk_real
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|mangled
argument_list|)
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
literal|'I'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'_'
condition|)
block|{
name|int
name|i
decl_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
operator|&&
operator|*
operator|*
name|mangled
operator|&&
operator|*
operator|*
name|mangled
operator|!=
literal|'_'
condition|;
operator|(
operator|*
name|mangled
operator|)
operator|++
operator|,
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
operator|*
operator|*
name|mangled
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|mangled
operator|!=
literal|'_'
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
operator|*
name|mangled
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|mangled
operator|+=
name|min
argument_list|(
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%x"
argument_list|,
operator|&
name|dec
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"int%u_t"
argument_list|,
name|dec
argument_list|)
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
comment|/* fall through */
comment|/* An explicit type, such as "6mytype" or "7integer" */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
block|{
name|int
name|bindex
init|=
name|register_Btype
argument_list|(
name|work
argument_list|)
decl_stmt|;
name|string
name|btype
decl_stmt|;
name|string_init
argument_list|(
operator|&
name|btype
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangle_class_name
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|btype
argument_list|)
condition|)
block|{
name|remember_Btype
argument_list|(
name|work
argument_list|,
name|btype
operator|.
name|b
argument_list|,
name|LEN_STRING
argument_list|(
operator|&
name|btype
argument_list|)
argument_list|,
name|bindex
argument_list|)
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_appends
argument_list|(
name|result
argument_list|,
operator|&
name|btype
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
literal|0
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|btype
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'t'
case|:
block|{
name|success
operator|=
name|demangle_template
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|btype
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|string_appends
argument_list|(
name|result
argument_list|,
operator|&
name|btype
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|success
condition|?
operator|(
operator|(
name|int
operator|)
name|tk
operator|)
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Handle a template's value parameter for HP aCC (extension from ARM)    **mangled points to 'S' or 'U' */
end_comment

begin_function
specifier|static
name|int
name|do_hpacc_template_const_value
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|result
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|result
decl_stmt|;
block|{
name|int
name|unsigned_const
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|mangled
operator|!=
literal|'U'
operator|&&
operator|*
operator|*
name|mangled
operator|!=
literal|'S'
condition|)
return|return
literal|0
return|;
name|unsigned_const
operator|=
operator|(
operator|*
operator|*
name|mangled
operator|==
literal|'U'
operator|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|mangled
condition|)
block|{
case|case
literal|'N'
case|:
name|string_append
argument_list|(
name|result
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
literal|'P'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* special case for -2^31 */
name|string_append
argument_list|(
name|result
argument_list|,
literal|"-2147483648"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
comment|/* We have to be looking at an integer now */
if|if
condition|(
operator|!
operator|(
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|mangled
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* We only deal with integral values for template      parameters -- so it's OK to look only for digits */
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|mangled
argument_list|)
condition|)
block|{
name|char_str
index|[
literal|0
index|]
operator|=
operator|*
operator|*
name|mangled
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
name|char_str
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|unsigned_const
condition|)
name|string_append
argument_list|(
name|result
argument_list|,
literal|"U"
argument_list|)
expr_stmt|;
comment|/* FIXME? Some day we may have 64-bit (or larger :-) ) constants      with L or LL suffixes. pai/1997-09-03 */
return|return
literal|1
return|;
comment|/* success */
block|}
end_function

begin_comment
comment|/* Handle a template's literal parameter for HP aCC (extension from ARM)    **mangled is pointing to the 'A' */
end_comment

begin_function
specifier|static
name|int
name|do_hpacc_template_literal
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|result
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|result
decl_stmt|;
block|{
name|int
name|literal_len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|recurse
decl_stmt|;
name|char
modifier|*
name|recurse_dem
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|mangled
operator|!=
literal|'A'
condition|)
return|return
literal|0
return|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|literal_len
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|literal_len
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Literal parameters are names of arrays, functions, etc.  and the      canonical representation uses the address operator */
name|string_append
argument_list|(
name|result
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
comment|/* Now recursively demangle the literal name */
name|recurse
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|literal_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|recurse
argument_list|,
operator|*
name|mangled
argument_list|,
name|literal_len
argument_list|)
expr_stmt|;
name|recurse
index|[
name|literal_len
index|]
operator|=
literal|'\000'
expr_stmt|;
name|recurse_dem
operator|=
name|cplus_demangle
argument_list|(
name|recurse
argument_list|,
name|work
operator|->
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|recurse_dem
condition|)
block|{
name|string_append
argument_list|(
name|result
argument_list|,
name|recurse_dem
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|recurse_dem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|string_appendn
argument_list|(
name|result
argument_list|,
operator|*
name|mangled
argument_list|,
name|literal_len
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|mangled
operator|)
operator|+=
name|literal_len
expr_stmt|;
name|free
argument_list|(
name|recurse
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|snarf_numeric_literal
parameter_list|(
name|args
parameter_list|,
name|arg
parameter_list|)
specifier|const
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
name|string
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
operator|*
operator|*
name|args
operator|==
literal|'-'
condition|)
block|{
name|char_str
index|[
literal|0
index|]
operator|=
literal|'-'
expr_stmt|;
name|string_append
argument_list|(
name|arg
argument_list|,
name|char_str
argument_list|)
expr_stmt|;
operator|(
operator|*
name|args
operator|)
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|args
operator|==
literal|'+'
condition|)
operator|(
operator|*
name|args
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|args
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|*
name|args
argument_list|)
condition|)
block|{
name|char_str
index|[
literal|0
index|]
operator|=
operator|*
operator|*
name|args
expr_stmt|;
name|string_append
argument_list|(
name|arg
argument_list|,
name|char_str
argument_list|)
expr_stmt|;
operator|(
operator|*
name|args
operator|)
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Demangle the next argument, given by MANGLED into RESULT, which    *should be an uninitialized* string.  It will be initialized here,    and free'd should anything go wrong.  */
end_comment

begin_function
specifier|static
name|int
name|do_arg
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|result
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|result
decl_stmt|;
block|{
comment|/* Remember where we started so that we can record the type, for      non-squangling type remembering.  */
specifier|const
name|char
modifier|*
name|start
init|=
operator|*
name|mangled
decl_stmt|;
name|string_init
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|nrepeats
operator|>
literal|0
condition|)
block|{
operator|--
name|work
operator|->
name|nrepeats
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|previous_argument
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* We want to reissue the previous type in this argument list.  */
name|string_appends
argument_list|(
name|result
argument_list|,
name|work
operator|->
name|previous_argument
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'n'
condition|)
block|{
comment|/* A squangling-style repeat.  */
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|work
operator|->
name|nrepeats
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|nrepeats
operator|<=
literal|0
condition|)
comment|/* This was not a repeat count after all.  */
return|return
literal|0
return|;
if|if
condition|(
name|work
operator|->
name|nrepeats
operator|>
literal|9
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|mangled
operator|!=
literal|'_'
condition|)
comment|/* The repeat count should be followed by an '_' in this 	       case.  */
return|return
literal|0
return|;
else|else
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
comment|/* Now, the repeat is all set up.  */
return|return
name|do_arg
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|result
argument_list|)
return|;
block|}
comment|/* Save the result in WORK->previous_argument so that we can find it      if it's repeated.  Note that saving START is not good enough: we      do not want to add additional types to the back-referenceable      type vector when processing a repeated type.  */
if|if
condition|(
name|work
operator|->
name|previous_argument
condition|)
name|string_clear
argument_list|(
name|work
operator|->
name|previous_argument
argument_list|)
expr_stmt|;
else|else
block|{
name|work
operator|->
name|previous_argument
operator|=
operator|(
name|string
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|string_init
argument_list|(
name|work
operator|->
name|previous_argument
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|do_type
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|work
operator|->
name|previous_argument
argument_list|)
condition|)
return|return
literal|0
return|;
name|string_appends
argument_list|(
name|result
argument_list|,
name|work
operator|->
name|previous_argument
argument_list|)
expr_stmt|;
name|remember_type
argument_list|(
name|work
argument_list|,
name|start
argument_list|,
operator|*
name|mangled
operator|-
name|start
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|remember_type
parameter_list|(
name|work
parameter_list|,
name|start
parameter_list|,
name|len
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|tem
decl_stmt|;
if|if
condition|(
name|work
operator|->
name|forgetting_types
condition|)
return|return;
if|if
condition|(
name|work
operator|->
name|ntypes
operator|>=
name|work
operator|->
name|typevec_size
condition|)
block|{
if|if
condition|(
name|work
operator|->
name|typevec_size
operator|==
literal|0
condition|)
block|{
name|work
operator|->
name|typevec_size
operator|=
literal|3
expr_stmt|;
name|work
operator|->
name|typevec
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|work
operator|->
name|typevec_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|work
operator|->
name|typevec_size
operator|*=
literal|2
expr_stmt|;
name|work
operator|->
name|typevec
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
operator|->
name|typevec
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|work
operator|->
name|typevec_size
argument_list|)
expr_stmt|;
block|}
block|}
name|tem
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tem
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tem
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|work
operator|->
name|typevec
index|[
name|work
operator|->
name|ntypes
operator|++
index|]
operator|=
name|tem
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remember a K type class qualifier. */
end_comment

begin_function
specifier|static
name|void
name|remember_Ktype
parameter_list|(
name|work
parameter_list|,
name|start
parameter_list|,
name|len
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|tem
decl_stmt|;
if|if
condition|(
name|work
operator|->
name|numk
operator|>=
name|work
operator|->
name|ksize
condition|)
block|{
if|if
condition|(
name|work
operator|->
name|ksize
operator|==
literal|0
condition|)
block|{
name|work
operator|->
name|ksize
operator|=
literal|5
expr_stmt|;
name|work
operator|->
name|ktypevec
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|work
operator|->
name|ksize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|work
operator|->
name|ksize
operator|*=
literal|2
expr_stmt|;
name|work
operator|->
name|ktypevec
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
operator|->
name|ktypevec
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|work
operator|->
name|ksize
argument_list|)
expr_stmt|;
block|}
block|}
name|tem
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tem
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tem
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|work
operator|->
name|ktypevec
index|[
name|work
operator|->
name|numk
operator|++
index|]
operator|=
name|tem
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Register a B code, and get an index for it. B codes are registered    as they are seen, rather than as they are completed, so map<temp<char>>    registers map<temp<char>> as B0, and temp<char> as B1 */
end_comment

begin_function
specifier|static
name|int
name|register_Btype
parameter_list|(
name|work
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|work
operator|->
name|numb
operator|>=
name|work
operator|->
name|bsize
condition|)
block|{
if|if
condition|(
name|work
operator|->
name|bsize
operator|==
literal|0
condition|)
block|{
name|work
operator|->
name|bsize
operator|=
literal|5
expr_stmt|;
name|work
operator|->
name|btypevec
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|work
operator|->
name|bsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|work
operator|->
name|bsize
operator|*=
literal|2
expr_stmt|;
name|work
operator|->
name|btypevec
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
operator|->
name|btypevec
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|work
operator|->
name|bsize
argument_list|)
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|work
operator|->
name|numb
operator|++
expr_stmt|;
name|work
operator|->
name|btypevec
index|[
name|ret
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Store a value into a previously registered B code type. */
end_comment

begin_function
specifier|static
name|void
name|remember_Btype
parameter_list|(
name|work
parameter_list|,
name|start
parameter_list|,
name|len
parameter_list|,
name|index
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|len
decl_stmt|,
name|index
decl_stmt|;
block|{
name|char
modifier|*
name|tem
decl_stmt|;
name|tem
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tem
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tem
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|work
operator|->
name|btypevec
index|[
name|index
index|]
operator|=
name|tem
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lose all the info related to B and K type codes. */
end_comment

begin_function
specifier|static
name|void
name|forget_B_and_K_types
parameter_list|(
name|work
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
while|while
condition|(
name|work
operator|->
name|numk
operator|>
literal|0
condition|)
block|{
name|i
operator|=
operator|--
operator|(
name|work
operator|->
name|numk
operator|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|ktypevec
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|work
operator|->
name|ktypevec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|work
operator|->
name|ktypevec
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
while|while
condition|(
name|work
operator|->
name|numb
operator|>
literal|0
condition|)
block|{
name|i
operator|=
operator|--
operator|(
name|work
operator|->
name|numb
operator|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|btypevec
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|work
operator|->
name|btypevec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|work
operator|->
name|btypevec
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Forget the remembered types, but not the type vector itself.  */
end_comment

begin_function
specifier|static
name|void
name|forget_types
parameter_list|(
name|work
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
while|while
condition|(
name|work
operator|->
name|ntypes
operator|>
literal|0
condition|)
block|{
name|i
operator|=
operator|--
operator|(
name|work
operator|->
name|ntypes
operator|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|typevec
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|work
operator|->
name|typevec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|work
operator|->
name|typevec
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Process the argument list part of the signature, after any class spec    has been consumed, as well as the first 'F' character (if any).  For    example:     "__als__3fooRT0"		=>	process "RT0"    "complexfunc5__FPFPc_PFl_i"	=>	process "PFPc_PFl_i"     DECLP must be already initialised, usually non-empty.  It won't be freed    on failure.     Note that g++ differs significantly from ARM and lucid style mangling    with regards to references to previously seen types.  For example, given    the source fragment:       class foo {        public:        foo::foo (int, foo&ia, int, foo&ib, int, foo&ic);      };       foo::foo (int, foo&ia, int, foo&ib, int, foo&ic) { ia = ib = ic; }      void foo (int, foo&ia, int, foo&ib, int, foo&ic) { ia = ib = ic; }     g++ produces the names:       __3fooiRT0iT2iT2      foo__FiR3fooiT1iT1     while lcc (and presumably other ARM style compilers as well) produces:       foo__FiR3fooT1T2T1T2      __ct__3fooFiR3fooT1T2T1T2     Note that g++ bases its type numbers starting at zero and counts all    previously seen types, while lucid/ARM bases its type numbers starting    at one and only considers types after it has seen the 'F' character    indicating the start of the function args.  For lucid/ARM style, we    account for this difference by discarding any previously seen types when    we see the 'F' character, and subtracting one from the type number    reference.   */
end_comment

begin_function
specifier|static
name|int
name|demangle_args
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|declp
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
block|{
name|string
name|arg
decl_stmt|;
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
name|tem
decl_stmt|;
name|char
name|temptype
decl_stmt|;
if|if
condition|(
name|PRINT_ARG_TYPES
condition|)
block|{
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'\0'
condition|)
block|{
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|(
operator|*
operator|*
name|mangled
operator|!=
literal|'_'
operator|&&
operator|*
operator|*
name|mangled
operator|!=
literal|'\0'
operator|&&
operator|*
operator|*
name|mangled
operator|!=
literal|'e'
operator|)
operator|||
name|work
operator|->
name|nrepeats
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|*
operator|*
name|mangled
operator|==
literal|'N'
operator|)
operator|||
operator|(
operator|*
operator|*
name|mangled
operator|==
literal|'T'
operator|)
condition|)
block|{
name|temptype
operator|=
operator|*
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|temptype
operator|==
literal|'N'
condition|)
block|{
if|if
condition|(
operator|!
name|get_count
argument_list|(
name|mangled
argument_list|,
operator|&
name|r
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
name|r
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|HP_DEMANGLING
operator|||
name|ARM_DEMANGLING
operator|||
name|EDG_DEMANGLING
operator|)
operator|&&
name|work
operator|->
name|ntypes
operator|>=
literal|10
condition|)
block|{
comment|/* If we have 10 or more types we might have more than a 1 digit                  index so we'll have to consume the whole count here. This                  will lose if the next thing is a type name preceded by a                  count but it's impossible to demangle that case properly                  anyway. Eg if we already have 12 types is T12Pc "(..., type1,                  Pc, ...)"  or "(..., type12, char *, ...)" */
if|if
condition|(
operator|(
name|t
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|get_count
argument_list|(
name|mangled
argument_list|,
operator|&
name|t
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|LUCID_DEMANGLING
operator|||
name|ARM_DEMANGLING
operator|||
name|HP_DEMANGLING
operator|||
name|EDG_DEMANGLING
condition|)
block|{
name|t
operator|--
expr_stmt|;
block|}
comment|/* Validate the type index.  Protect against illegal indices from 	     malformed type strings.  */
if|if
condition|(
operator|(
name|t
operator|<
literal|0
operator|)
operator|||
operator|(
name|t
operator|>=
name|work
operator|->
name|ntypes
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
name|work
operator|->
name|nrepeats
operator|>
literal|0
operator|||
operator|--
name|r
operator|>=
literal|0
condition|)
block|{
name|tem
operator|=
name|work
operator|->
name|typevec
index|[
name|t
index|]
expr_stmt|;
if|if
condition|(
name|need_comma
operator|&&
name|PRINT_ARG_TYPES
condition|)
block|{
name|string_append
argument_list|(
name|declp
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|do_arg
argument_list|(
name|work
argument_list|,
operator|&
name|tem
argument_list|,
operator|&
name|arg
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|PRINT_ARG_TYPES
condition|)
block|{
name|string_appends
argument_list|(
name|declp
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
name|string_delete
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|need_comma
operator|&&
name|PRINT_ARG_TYPES
condition|)
name|string_append
argument_list|(
name|declp
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_arg
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|arg
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|PRINT_ARG_TYPES
condition|)
name|string_appends
argument_list|(
name|declp
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'e'
condition|)
block|{
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|PRINT_ARG_TYPES
condition|)
block|{
if|if
condition|(
name|need_comma
condition|)
block|{
name|string_append
argument_list|(
name|declp
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|PRINT_ARG_TYPES
condition|)
block|{
name|string_append
argument_list|(
name|declp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like demangle_args, but for demangling the argument lists of function    and method pointers or references, not top-level declarations.  */
end_comment

begin_function
specifier|static
name|int
name|demangle_nested_args
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|declp
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
block|{
name|string
modifier|*
name|saved_previous_argument
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|saved_nrepeats
decl_stmt|;
comment|/* The G++ name-mangling algorithm does not remember types on nested      argument lists, unless -fsquangling is used, and in that case the      type vector updated by remember_type is not used.  So, we turn      off remembering of types here.  */
operator|++
name|work
operator|->
name|forgetting_types
expr_stmt|;
comment|/* For the repeat codes used with -fsquangling, we must keep track of      the last argument.  */
name|saved_previous_argument
operator|=
name|work
operator|->
name|previous_argument
expr_stmt|;
name|saved_nrepeats
operator|=
name|work
operator|->
name|nrepeats
expr_stmt|;
name|work
operator|->
name|previous_argument
operator|=
literal|0
expr_stmt|;
name|work
operator|->
name|nrepeats
operator|=
literal|0
expr_stmt|;
comment|/* Actually demangle the arguments.  */
name|result
operator|=
name|demangle_args
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|)
expr_stmt|;
comment|/* Restore the previous_argument field.  */
if|if
condition|(
name|work
operator|->
name|previous_argument
condition|)
name|string_delete
argument_list|(
name|work
operator|->
name|previous_argument
argument_list|)
expr_stmt|;
name|work
operator|->
name|previous_argument
operator|=
name|saved_previous_argument
expr_stmt|;
operator|--
name|work
operator|->
name|forgetting_types
expr_stmt|;
name|work
operator|->
name|nrepeats
operator|=
name|saved_nrepeats
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|demangle_function_name
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|declp
parameter_list|,
name|scan
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
specifier|const
name|char
modifier|*
name|scan
decl_stmt|;
block|{
name|size_t
name|i
decl_stmt|;
name|string
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|tem
decl_stmt|;
name|string_appendn
argument_list|(
name|declp
argument_list|,
operator|(
operator|*
name|mangled
operator|)
argument_list|,
name|scan
operator|-
operator|(
operator|*
name|mangled
operator|)
argument_list|)
expr_stmt|;
name|string_need
argument_list|(
name|declp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
operator|(
name|declp
operator|->
name|p
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* Consume the function name, including the "__" separating the name      from the signature.  We are guaranteed that SCAN points to the      separator.  */
operator|(
operator|*
name|mangled
operator|)
operator|=
name|scan
operator|+
literal|2
expr_stmt|;
comment|/* We may be looking at an instantiation of a template function:      foo__Xt1t2_Ft3t4, where t1, t2, ... are template arguments and a      following _F marks the start of the function arguments.  Handle      the template arguments first. */
if|if
condition|(
name|HP_DEMANGLING
operator|&&
operator|(
operator|*
operator|*
name|mangled
operator|==
literal|'X'
operator|)
condition|)
block|{
name|demangle_arm_hp_template
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
literal|0
argument_list|,
name|declp
argument_list|)
expr_stmt|;
comment|/* This leaves MANGLED pointing to the 'F' marking func args */
block|}
if|if
condition|(
name|LUCID_DEMANGLING
operator|||
name|ARM_DEMANGLING
operator|||
name|HP_DEMANGLING
operator|||
name|EDG_DEMANGLING
condition|)
block|{
comment|/* See if we have an ARM style constructor or destructor operator. 	 If so, then just record it, clear the decl, and return. 	 We can't build the actual constructor/destructor decl until later, 	 when we recover the class name from the signature.  */
if|if
condition|(
name|strcmp
argument_list|(
name|declp
operator|->
name|b
argument_list|,
literal|"__ct"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|work
operator|->
name|constructor
operator|+=
literal|1
expr_stmt|;
name|string_clear
argument_list|(
name|declp
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|declp
operator|->
name|b
argument_list|,
literal|"__dt"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|work
operator|->
name|destructor
operator|+=
literal|1
expr_stmt|;
name|string_clear
argument_list|(
name|declp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|declp
operator|->
name|p
operator|-
name|declp
operator|->
name|b
operator|>=
literal|3
operator|&&
name|declp
operator|->
name|b
index|[
literal|0
index|]
operator|==
literal|'o'
operator|&&
name|declp
operator|->
name|b
index|[
literal|1
index|]
operator|==
literal|'p'
operator|&&
name|strchr
argument_list|(
name|cplus_markers
argument_list|,
name|declp
operator|->
name|b
index|[
literal|2
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* see if it's an assignment expression */
if|if
condition|(
name|declp
operator|->
name|p
operator|-
name|declp
operator|->
name|b
operator|>=
literal|10
comment|/* op$assign_ */
operator|&&
name|memcmp
argument_list|(
name|declp
operator|->
name|b
operator|+
literal|3
argument_list|,
literal|"assign_"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|optable
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|declp
operator|->
name|p
operator|-
name|declp
operator|->
name|b
operator|-
literal|10
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|)
operator|==
name|len
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|declp
operator|->
name|b
operator|+
literal|10
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|string_clear
argument_list|(
name|declp
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|optable
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|declp
operator|->
name|p
operator|-
name|declp
operator|->
name|b
operator|-
literal|3
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|)
operator|==
name|len
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|declp
operator|->
name|b
operator|+
literal|3
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|string_clear
argument_list|(
name|declp
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|declp
operator|->
name|p
operator|-
name|declp
operator|->
name|b
operator|>=
literal|5
operator|&&
name|memcmp
argument_list|(
name|declp
operator|->
name|b
argument_list|,
literal|"type"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|&&
name|strchr
argument_list|(
name|cplus_markers
argument_list|,
name|declp
operator|->
name|b
index|[
literal|4
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* type conversion operator */
name|tem
operator|=
name|declp
operator|->
name|b
operator|+
literal|5
expr_stmt|;
if|if
condition|(
name|do_type
argument_list|(
name|work
argument_list|,
operator|&
name|tem
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
name|string_clear
argument_list|(
name|declp
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"operator "
argument_list|)
expr_stmt|;
name|string_appends
argument_list|(
name|declp
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|declp
operator|->
name|b
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|declp
operator|->
name|b
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|declp
operator|->
name|b
index|[
literal|2
index|]
operator|==
literal|'o'
operator|&&
name|declp
operator|->
name|b
index|[
literal|3
index|]
operator|==
literal|'p'
condition|)
block|{
comment|/* ANSI.  */
comment|/* type conversion operator.  */
name|tem
operator|=
name|declp
operator|->
name|b
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|do_type
argument_list|(
name|work
argument_list|,
operator|&
name|tem
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
name|string_clear
argument_list|(
name|declp
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"operator "
argument_list|)
expr_stmt|;
name|string_appends
argument_list|(
name|declp
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|declp
operator|->
name|b
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|declp
operator|->
name|b
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|ISLOWER
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|declp
operator|->
name|b
index|[
literal|2
index|]
argument_list|)
operator|&&
name|ISLOWER
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|declp
operator|->
name|b
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|declp
operator|->
name|b
index|[
literal|4
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Operator.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|optable
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|)
operator|==
literal|2
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|declp
operator|->
name|b
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|string_clear
argument_list|(
name|declp
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|declp
operator|->
name|b
index|[
literal|2
index|]
operator|==
literal|'a'
operator|&&
name|declp
operator|->
name|b
index|[
literal|5
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Assignment.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|optable
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|)
operator|==
literal|3
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|declp
operator|->
name|b
operator|+
literal|2
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|string_clear
argument_list|(
name|declp
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* a mini string-handling package */
end_comment

begin_function
specifier|static
name|void
name|string_need
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
name|string
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|int
name|tem
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|b
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|32
condition|)
block|{
name|n
operator|=
literal|32
expr_stmt|;
block|}
name|s
operator|->
name|p
operator|=
name|s
operator|->
name|b
operator|=
name|xmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|s
operator|->
name|e
operator|=
name|s
operator|->
name|b
operator|+
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|e
operator|-
name|s
operator|->
name|p
operator|<
name|n
condition|)
block|{
name|tem
operator|=
name|s
operator|->
name|p
operator|-
name|s
operator|->
name|b
expr_stmt|;
name|n
operator|+=
name|tem
expr_stmt|;
name|n
operator|*=
literal|2
expr_stmt|;
name|s
operator|->
name|b
operator|=
name|xrealloc
argument_list|(
name|s
operator|->
name|b
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|s
operator|->
name|p
operator|=
name|s
operator|->
name|b
operator|+
name|tem
expr_stmt|;
name|s
operator|->
name|e
operator|=
name|s
operator|->
name|b
operator|+
name|n
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|string_delete
parameter_list|(
name|s
parameter_list|)
name|string
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|->
name|b
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|s
operator|->
name|b
argument_list|)
expr_stmt|;
name|s
operator|->
name|b
operator|=
name|s
operator|->
name|e
operator|=
name|s
operator|->
name|p
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|string_init
parameter_list|(
name|s
parameter_list|)
name|string
modifier|*
name|s
decl_stmt|;
block|{
name|s
operator|->
name|b
operator|=
name|s
operator|->
name|p
operator|=
name|s
operator|->
name|e
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|string_clear
parameter_list|(
name|s
parameter_list|)
name|string
modifier|*
name|s
decl_stmt|;
block|{
name|s
operator|->
name|p
operator|=
name|s
operator|->
name|b
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int string_empty (s)      string *s; {   return (s->b == s->p); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|string_append
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
name|string
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return;
name|n
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|string_need
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|p
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
operator|->
name|p
operator|+=
name|n
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|string_appends
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
name|string
modifier|*
name|p
decl_stmt|,
decl|*
name|s
decl_stmt|;
end_function

begin_block
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|b
operator|!=
name|s
operator|->
name|p
condition|)
block|{
name|n
operator|=
name|s
operator|->
name|p
operator|-
name|s
operator|->
name|b
expr_stmt|;
name|string_need
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|p
argument_list|,
name|s
operator|->
name|b
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
operator|->
name|p
operator|+=
name|n
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|void
name|string_appendn
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
name|string
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
name|string_need
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|p
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
operator|->
name|p
operator|+=
name|n
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|string_prepend
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
name|string
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
name|string_prependn
argument_list|(
name|p
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|string_prepends
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
name|string
modifier|*
name|p
decl_stmt|,
decl|*
name|s
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|s
operator|->
name|b
operator|!=
name|s
operator|->
name|p
condition|)
block|{
name|string_prependn
argument_list|(
name|p
argument_list|,
name|s
operator|->
name|b
argument_list|,
name|s
operator|->
name|p
operator|-
name|s
operator|->
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|void
name|string_prependn
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
name|string
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|char
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
name|string_need
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|p
operator|->
name|p
operator|-
literal|1
init|;
name|q
operator|>=
name|p
operator|->
name|b
condition|;
name|q
operator|--
control|)
block|{
name|q
index|[
name|n
index|]
operator|=
name|q
index|[
literal|0
index|]
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|p
operator|->
name|b
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
operator|->
name|p
operator|+=
name|n
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|string_append_template_idx
parameter_list|(
name|s
parameter_list|,
name|idx
parameter_list|)
name|string
modifier|*
name|s
decl_stmt|;
name|int
name|idx
decl_stmt|;
block|{
name|char
name|buf
index|[
name|INTBUF_SIZE
operator|+
literal|1
comment|/* 'T' */
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"T%d"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|s
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* To generate a standalone demangler program for testing purposes,    just compile and link this file with -DMAIN and libiberty.a.  When    run, it demangles each command line arg, or each stdin string, and    prints the result on stdout.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAIN
end_ifdef

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|program_version
init|=
name|VERSION
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flags
init|=
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|demangle_it
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usage
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fatal
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_demangler_list
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|demangle_it
parameter_list|(
name|mangled_name
parameter_list|)
name|char
modifier|*
name|mangled_name
decl_stmt|;
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|cplus_demangle
argument_list|(
name|mangled_name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|mangled_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_demangler_list
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|struct
name|demangler_engine
modifier|*
name|demangler
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"{%s"
argument_list|,
name|libiberty_demanglers
operator|->
name|demangling_style_name
argument_list|)
expr_stmt|;
for|for
control|(
name|demangler
operator|=
name|libiberty_demanglers
operator|+
literal|1
init|;
name|demangler
operator|->
name|demangling_style
operator|!=
name|unknown_demangling
condition|;
operator|++
name|demangler
control|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|",%s"
argument_list|,
name|demangler
operator|->
name|demangling_style_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|stream
parameter_list|,
name|status
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\ Usage: %s [-_] [-n] [--strip-underscores] [--no-strip-underscores] \n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\        [-s "
argument_list|)
expr_stmt|;
name|print_demangler_list
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\        [--format "
argument_list|)
expr_stmt|;
name|print_demangler_list
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\        [--help] [--version] [arg...]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MBUF_SIZE
value|32767
end_define

begin_decl_stmt
name|char
name|mbuffer
index|[
name|MBUF_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Defined in the automatically-generated underscore.c.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|prepends_underscore
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|strip_underscore
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"strip-underscores"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'_'
block|}
block|,
block|{
literal|"format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'h'
block|}
block|,
block|{
literal|"java"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'j'
block|}
block|,
block|{
literal|"no-strip-underscores"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'n'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|0
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Internal gcc abort."
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|standard_symbol_characters
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|hp_symbol_characters
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|gnu_v3_symbol_characters
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the string of non-alnum characters that may occur     as a valid symbol component, in the standard assembler symbol    syntax.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|standard_symbol_characters
parameter_list|()
block|{
return|return
literal|"_$."
return|;
block|}
end_function

begin_comment
comment|/* Return the string of non-alnum characters that may occur    as a valid symbol name component in an HP object file.     Note that, since HP's compiler generates object code straight from    C++ source, without going through an assembler, its mangled    identifiers can use all sorts of characters that no assembler would    tolerate, so the alphabet this function creates is a little odd.    Here are some sample mangled identifiers offered by HP:  	typeid*__XT24AddressIndExpClassMember_ 	[Vftptr]key:__dt__32OrdinaryCompareIndExpClassMemberFv 	__ct__Q2_9Elf64_Dyn18{unnamed.union.#1}Fv     This still seems really weird to me, since nowhere else in this    file is there anything to recognize curly brackets, parens, etc.    I've talked with Srikanth<srikanth@cup.hp.com>, and he assures me    this is right, but I still strongly suspect that there's a    misunderstanding here.     If we decide it's better for c++filt to use HP's assembler syntax    to scrape identifiers out of its input, here's the definition of    the symbol name syntax from the HP assembler manual:         Symbols are composed of uppercase and lowercase letters, decimal        digits, dollar symbol, period (.), ampersand (&), pound sign(#) and        underscore (_). A symbol can begin with a letter, digit underscore or        dollar sign. If a symbol begins with a digit, it must contain a        non-digit character.     So have fun.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hp_symbol_characters
parameter_list|()
block|{
return|return
literal|"_$.<>#,*&[]:(){}"
return|;
block|}
end_function

begin_comment
comment|/* Return the string of non-alnum characters that may occur     as a valid symbol component in the GNU C++ V3 ABI mangling    scheme.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|gnu_v3_symbol_characters
parameter_list|()
block|{
return|return
literal|"_$."
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
decl|main
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|valid_symbols
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|strip_underscore
operator|=
name|prepends_underscore
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"_ns:j"
argument_list|,
name|long_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'?'
case|:
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'n'
case|:
name|strip_underscore
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|printf
argument_list|(
literal|"GNU %s (C++ demangler), version %s\n"
argument_list|,
name|program_name
argument_list|,
name|program_version
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'_'
case|:
name|strip_underscore
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|flags
operator||=
name|DMGL_JAVA
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
block|{
name|enum
name|demangling_styles
name|style
decl_stmt|;
name|style
operator|=
name|cplus_demangle_name_to_style
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|style
operator|==
name|unknown_demangling
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown demangling style `%s'\n"
argument_list|,
name|program_name
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
name|cplus_demangle_set_style
argument_list|(
name|style
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
block|{
name|demangle_it
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|current_demangling_style
condition|)
block|{
case|case
name|gnu_demangling
case|:
case|case
name|lucid_demangling
case|:
case|case
name|arm_demangling
case|:
case|case
name|java_demangling
case|:
case|case
name|edg_demangling
case|:
case|case
name|gnat_demangling
case|:
case|case
name|auto_demangling
case|:
name|valid_symbols
operator|=
name|standard_symbol_characters
argument_list|()
expr_stmt|;
break|break;
case|case
name|hp_demangling
case|:
name|valid_symbols
operator|=
name|hp_symbol_characters
argument_list|()
expr_stmt|;
break|break;
case|case
name|gnu_v3_demangling
case|:
name|valid_symbols
operator|=
name|gnu_v3_symbol_characters
argument_list|()
expr_stmt|;
break|break;
default|default:
comment|/* Folks should explicitly indicate the appropriate alphabet for 	     each demangling.  Providing a default would allow the 	     question to go unconsidered.  */
name|abort
argument_list|()
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/* Try to read a label.  */
while|while
condition|(
name|c
operator|!=
name|EOF
operator|&&
operator|(
name|ISALNUM
argument_list|(
name|c
argument_list|)
operator|||
name|strchr
argument_list|(
name|valid_symbols
argument_list|,
name|c
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|MBUF_SIZE
operator|-
literal|1
condition|)
break|break;
name|mbuffer
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|int
name|skip_first
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mbuffer
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
operator|++
name|skip_first
expr_stmt|;
if|if
condition|(
name|strip_underscore
operator|&&
name|mbuffer
index|[
name|skip_first
index|]
operator|==
literal|'_'
condition|)
operator|++
name|skip_first
expr_stmt|;
if|if
condition|(
name|skip_first
operator|>
name|i
condition|)
name|skip_first
operator|=
name|i
expr_stmt|;
name|mbuffer
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|cplus_demangle
argument_list|(
name|mbuffer
operator|+
name|skip_first
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
if|if
condition|(
name|mbuffer
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
name|putc
argument_list|(
literal|'.'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|result
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
name|mbuffer
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fatal
parameter_list|(
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|program_name
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|PTR
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
specifier|register
name|PTR
name|value
init|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_function
name|PTR
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|PTR
name|ptr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
specifier|register
name|PTR
name|value
init|=
operator|(
name|PTR
operator|)
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* main */
end_comment

end_unit

