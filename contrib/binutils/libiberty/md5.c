begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* md5.c - Functions to compute MD5 message digest of files or memory blocks    according to the definition of MD5 in RFC 1321 from April 1992.    Copyright (C) 1995, 1996 Free Software Foundation, Inc.     NOTE: This source is derived from an old version taken from the GNU C    Library (glibc).     This program is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any    later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Written by Ulrich Drepper<drepper@gnu.ai.mit.edu>, 1995.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|STDC_HEADERS
operator|||
name|defined
name|_LIBC
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_MEMCPY
end_ifndef

begin_define
define|#
directive|define
name|memcpy
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
value|bcopy ((s), (d), (n))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"md5.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_include
include|#
directive|include
file|<endian.h>
end_include

begin_if
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
end_if

begin_define
define|#
directive|define
name|WORDS_BIGENDIAN
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|WORDS_BIGENDIAN
end_ifdef

begin_define
define|#
directive|define
name|SWAP
parameter_list|(
name|n
parameter_list|)
define|\
value|(((n)<< 24) | (((n)& 0xff00)<< 8) | (((n)>> 8)& 0xff00) | ((n)>> 24))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SWAP
parameter_list|(
name|n
parameter_list|)
value|(n)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This array contains the bytes used to pad the buffer to the next    64-byte boundary.  (RFC 1321, 3.1: Step 1)  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|fillbuf
index|[
literal|64
index|]
init|=
block|{
literal|0x80
block|,
literal|0
comment|/* , 0, 0, ...  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize structure containing state of computation.    (RFC 1321, 3.3: Step 3)  */
end_comment

begin_function
name|void
name|md5_init_ctx
parameter_list|(
name|ctx
parameter_list|)
name|struct
name|md5_ctx
modifier|*
name|ctx
decl_stmt|;
block|{
name|ctx
operator|->
name|A
operator|=
literal|0x67452301
expr_stmt|;
name|ctx
operator|->
name|B
operator|=
literal|0xefcdab89
expr_stmt|;
name|ctx
operator|->
name|C
operator|=
literal|0x98badcfe
expr_stmt|;
name|ctx
operator|->
name|D
operator|=
literal|0x10325476
expr_stmt|;
name|ctx
operator|->
name|total
index|[
literal|0
index|]
operator|=
name|ctx
operator|->
name|total
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|buflen
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put result from CTX in first 16 bytes following RESBUF.  The result    must be in little endian byte order.     IMPORTANT: On some systems it is required that RESBUF is correctly    aligned for a 32 bits value.  */
end_comment

begin_function
name|void
modifier|*
name|md5_read_ctx
parameter_list|(
name|ctx
parameter_list|,
name|resbuf
parameter_list|)
specifier|const
name|struct
name|md5_ctx
modifier|*
name|ctx
decl_stmt|;
name|void
modifier|*
name|resbuf
decl_stmt|;
block|{
operator|(
operator|(
name|md5_uint32
operator|*
operator|)
name|resbuf
operator|)
index|[
literal|0
index|]
operator|=
name|SWAP
argument_list|(
name|ctx
operator|->
name|A
argument_list|)
expr_stmt|;
operator|(
operator|(
name|md5_uint32
operator|*
operator|)
name|resbuf
operator|)
index|[
literal|1
index|]
operator|=
name|SWAP
argument_list|(
name|ctx
operator|->
name|B
argument_list|)
expr_stmt|;
operator|(
operator|(
name|md5_uint32
operator|*
operator|)
name|resbuf
operator|)
index|[
literal|2
index|]
operator|=
name|SWAP
argument_list|(
name|ctx
operator|->
name|C
argument_list|)
expr_stmt|;
operator|(
operator|(
name|md5_uint32
operator|*
operator|)
name|resbuf
operator|)
index|[
literal|3
index|]
operator|=
name|SWAP
argument_list|(
name|ctx
operator|->
name|D
argument_list|)
expr_stmt|;
return|return
name|resbuf
return|;
block|}
end_function

begin_comment
comment|/* Process the remaining bytes in the internal buffer and the usual    prolog according to the standard and write the result to RESBUF.     IMPORTANT: On some systems it is required that RESBUF is correctly    aligned for a 32 bits value.  */
end_comment

begin_function
name|void
modifier|*
name|md5_finish_ctx
parameter_list|(
name|ctx
parameter_list|,
name|resbuf
parameter_list|)
name|struct
name|md5_ctx
modifier|*
name|ctx
decl_stmt|;
name|void
modifier|*
name|resbuf
decl_stmt|;
block|{
comment|/* Take yet unprocessed bytes into account.  */
name|md5_uint32
name|bytes
init|=
name|ctx
operator|->
name|buflen
decl_stmt|;
name|size_t
name|pad
decl_stmt|;
comment|/* Now count remaining bytes.  */
name|ctx
operator|->
name|total
index|[
literal|0
index|]
operator|+=
name|bytes
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|total
index|[
literal|0
index|]
operator|<
name|bytes
condition|)
operator|++
name|ctx
operator|->
name|total
index|[
literal|1
index|]
expr_stmt|;
name|pad
operator|=
name|bytes
operator|>=
literal|56
condition|?
literal|64
operator|+
literal|56
operator|-
name|bytes
else|:
literal|56
operator|-
name|bytes
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ctx
operator|->
name|buffer
index|[
name|bytes
index|]
argument_list|,
name|fillbuf
argument_list|,
name|pad
argument_list|)
expr_stmt|;
comment|/* Put the 64-bit file length in *bits* at the end of the buffer.  */
operator|*
operator|(
name|md5_uint32
operator|*
operator|)
operator|&
name|ctx
operator|->
name|buffer
index|[
name|bytes
operator|+
name|pad
index|]
operator|=
name|SWAP
argument_list|(
name|ctx
operator|->
name|total
index|[
literal|0
index|]
operator|<<
literal|3
argument_list|)
expr_stmt|;
operator|*
operator|(
name|md5_uint32
operator|*
operator|)
operator|&
name|ctx
operator|->
name|buffer
index|[
name|bytes
operator|+
name|pad
operator|+
literal|4
index|]
operator|=
name|SWAP
argument_list|(
operator|(
name|ctx
operator|->
name|total
index|[
literal|1
index|]
operator|<<
literal|3
operator|)
operator||
operator|(
name|ctx
operator|->
name|total
index|[
literal|0
index|]
operator|>>
literal|29
operator|)
argument_list|)
expr_stmt|;
comment|/* Process last bytes.  */
name|md5_process_block
argument_list|(
name|ctx
operator|->
name|buffer
argument_list|,
name|bytes
operator|+
name|pad
operator|+
literal|8
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
return|return
name|md5_read_ctx
argument_list|(
name|ctx
argument_list|,
name|resbuf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compute MD5 message digest for bytes read from STREAM.  The    resulting message digest number will be written into the 16 bytes    beginning at RESBLOCK.  */
end_comment

begin_function
name|int
name|md5_stream
parameter_list|(
name|stream
parameter_list|,
name|resblock
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|void
modifier|*
name|resblock
decl_stmt|;
block|{
comment|/* Important: BLOCKSIZE must be a multiple of 64.  */
define|#
directive|define
name|BLOCKSIZE
value|4096
name|struct
name|md5_ctx
name|ctx
decl_stmt|;
name|char
name|buffer
index|[
name|BLOCKSIZE
operator|+
literal|72
index|]
decl_stmt|;
name|size_t
name|sum
decl_stmt|;
comment|/* Initialize the computation context.  */
name|md5_init_ctx
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
comment|/* Iterate over full file contents.  */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* We read the file in blocks of BLOCKSIZE bytes.  One call of the 	 computation function processes the whole buffer so that with the 	 next round of the loop another block can be read.  */
name|size_t
name|n
decl_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
comment|/* Read block.  Take care for partial reads.  */
do|do
block|{
name|n
operator|=
name|fread
argument_list|(
name|buffer
operator|+
name|sum
argument_list|,
literal|1
argument_list|,
name|BLOCKSIZE
operator|-
name|sum
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|sum
operator|+=
name|n
expr_stmt|;
block|}
do|while
condition|(
name|sum
operator|<
name|BLOCKSIZE
operator|&&
name|n
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|n
operator|==
literal|0
operator|&&
name|ferror
argument_list|(
name|stream
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* If end of file is reached, end the loop.  */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
break|break;
comment|/* Process buffer with BLOCKSIZE bytes.  Note that 			BLOCKSIZE % 64 == 0        */
name|md5_process_block
argument_list|(
name|buffer
argument_list|,
name|BLOCKSIZE
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
block|}
comment|/* Add the last bytes if necessary.  */
if|if
condition|(
name|sum
operator|>
literal|0
condition|)
name|md5_process_bytes
argument_list|(
name|buffer
argument_list|,
name|sum
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
comment|/* Construct result in desired memory.  */
name|md5_finish_ctx
argument_list|(
operator|&
name|ctx
argument_list|,
name|resblock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compute MD5 message digest for LEN bytes beginning at BUFFER.  The    result is always in little endian byte order, so that a byte-wise    output yields to the wanted ASCII representation of the message    digest.  */
end_comment

begin_function
name|void
modifier|*
name|md5_buffer
parameter_list|(
name|buffer
parameter_list|,
name|len
parameter_list|,
name|resblock
parameter_list|)
specifier|const
name|char
modifier|*
name|buffer
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|void
modifier|*
name|resblock
decl_stmt|;
block|{
name|struct
name|md5_ctx
name|ctx
decl_stmt|;
comment|/* Initialize the computation context.  */
name|md5_init_ctx
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
comment|/* Process whole buffer but last len % 64 bytes.  */
name|md5_process_bytes
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
comment|/* Put result in desired memory area.  */
return|return
name|md5_finish_ctx
argument_list|(
operator|&
name|ctx
argument_list|,
name|resblock
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|md5_process_bytes
parameter_list|(
name|buffer
parameter_list|,
name|len
parameter_list|,
name|ctx
parameter_list|)
specifier|const
name|void
modifier|*
name|buffer
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|md5_ctx
modifier|*
name|ctx
decl_stmt|;
block|{
comment|/* When we already have some bits in our internal buffer concatenate      both inputs first.  */
if|if
condition|(
name|ctx
operator|->
name|buflen
operator|!=
literal|0
condition|)
block|{
name|size_t
name|left_over
init|=
name|ctx
operator|->
name|buflen
decl_stmt|;
name|size_t
name|add
init|=
literal|128
operator|-
name|left_over
operator|>
name|len
condition|?
name|len
else|:
literal|128
operator|-
name|left_over
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|ctx
operator|->
name|buffer
index|[
name|left_over
index|]
argument_list|,
name|buffer
argument_list|,
name|add
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|buflen
operator|+=
name|add
expr_stmt|;
if|if
condition|(
name|left_over
operator|+
name|add
operator|>
literal|64
condition|)
block|{
name|md5_process_block
argument_list|(
name|ctx
operator|->
name|buffer
argument_list|,
operator|(
name|left_over
operator|+
name|add
operator|)
operator|&
operator|~
literal|63
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* The regions in the following copy operation cannot overlap.  */
name|memcpy
argument_list|(
name|ctx
operator|->
name|buffer
argument_list|,
operator|&
name|ctx
operator|->
name|buffer
index|[
operator|(
name|left_over
operator|+
name|add
operator|)
operator|&
operator|~
literal|63
index|]
argument_list|,
operator|(
name|left_over
operator|+
name|add
operator|)
operator|&
literal|63
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|buflen
operator|=
operator|(
name|left_over
operator|+
name|add
operator|)
operator|&
literal|63
expr_stmt|;
block|}
name|buffer
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|buffer
operator|+
name|add
expr_stmt|;
name|len
operator|-=
name|add
expr_stmt|;
block|}
comment|/* Process available complete blocks.  */
if|if
condition|(
name|len
operator|>
literal|64
condition|)
block|{
name|md5_process_block
argument_list|(
name|buffer
argument_list|,
name|len
operator|&
operator|~
literal|63
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|buffer
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|len
operator|&
operator|~
literal|63
operator|)
expr_stmt|;
name|len
operator|&=
literal|63
expr_stmt|;
block|}
comment|/* Move remaining bytes in internal buffer.  */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|ctx
operator|->
name|buffer
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|buflen
operator|=
name|len
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* These are the four functions used in the four steps of the MD5 algorithm    and defined in the RFC 1321.  The first function is a little bit optimized    (as found in Colin Plumbs public domain implementation).  */
end_comment

begin_comment
comment|/* #define FF(b, c, d) ((b& c) | (~b& d)) */
end_comment

begin_define
define|#
directive|define
name|FF
parameter_list|(
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|(d ^ (b& (c ^ d)))
end_define

begin_define
define|#
directive|define
name|FG
parameter_list|(
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|FF (d, b, c)
end_define

begin_define
define|#
directive|define
name|FH
parameter_list|(
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|(b ^ c ^ d)
end_define

begin_define
define|#
directive|define
name|FI
parameter_list|(
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|(c ^ (b | ~d))
end_define

begin_comment
comment|/* Process LEN bytes of BUFFER, accumulating context into CTX.    It is assumed that LEN % 64 == 0.  */
end_comment

begin_function
name|void
name|md5_process_block
parameter_list|(
name|buffer
parameter_list|,
name|len
parameter_list|,
name|ctx
parameter_list|)
specifier|const
name|void
modifier|*
name|buffer
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|md5_ctx
modifier|*
name|ctx
decl_stmt|;
block|{
name|md5_uint32
name|correct_words
index|[
literal|16
index|]
decl_stmt|;
specifier|const
name|md5_uint32
modifier|*
name|words
init|=
name|buffer
decl_stmt|;
name|size_t
name|nwords
init|=
name|len
operator|/
sizeof|sizeof
argument_list|(
name|md5_uint32
argument_list|)
decl_stmt|;
specifier|const
name|md5_uint32
modifier|*
name|endp
init|=
name|words
operator|+
name|nwords
decl_stmt|;
name|md5_uint32
name|A
init|=
name|ctx
operator|->
name|A
decl_stmt|;
name|md5_uint32
name|B
init|=
name|ctx
operator|->
name|B
decl_stmt|;
name|md5_uint32
name|C
init|=
name|ctx
operator|->
name|C
decl_stmt|;
name|md5_uint32
name|D
init|=
name|ctx
operator|->
name|D
decl_stmt|;
comment|/* First increment the byte count.  RFC 1321 specifies the possible      length of the file up to 2^64 bits.  Here we only compute the      number of bytes.  Do a double word increment.  */
name|ctx
operator|->
name|total
index|[
literal|0
index|]
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|total
index|[
literal|0
index|]
operator|<
name|len
condition|)
operator|++
name|ctx
operator|->
name|total
index|[
literal|1
index|]
expr_stmt|;
comment|/* Process all bytes in the buffer with 64 bytes in each round of      the loop.  */
while|while
condition|(
name|words
operator|<
name|endp
condition|)
block|{
name|md5_uint32
modifier|*
name|cwp
init|=
name|correct_words
decl_stmt|;
name|md5_uint32
name|A_save
init|=
name|A
decl_stmt|;
name|md5_uint32
name|B_save
init|=
name|B
decl_stmt|;
name|md5_uint32
name|C_save
init|=
name|C
decl_stmt|;
name|md5_uint32
name|D_save
init|=
name|D
decl_stmt|;
comment|/* First round: using the given function, the context and a constant 	 the next context is computed.  Because the algorithms processing 	 unit is a 32-bit word and it is determined to work on words in 	 little endian byte order we perhaps have to change the byte order 	 before the computation.  To reduce the work for the next steps 	 we store the swapped words in the array CORRECT_WORDS.  */
define|#
directive|define
name|OP
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|s
parameter_list|,
name|T
parameter_list|)
define|\
value|do								\         {								\ 	  a += FF (b, c, d) + (*cwp++ = SWAP (*words)) + T;		\ 	  ++words;							\ 	  CYCLIC (a, s);						\ 	  a += b;							\         }								\       while (0)
comment|/* It is unfortunate that C does not provide an operator for 	 cyclic rotation.  Hope the C compiler is smart enough.  */
define|#
directive|define
name|CYCLIC
parameter_list|(
name|w
parameter_list|,
name|s
parameter_list|)
value|(w = (w<< s) | (w>> (32 - s)))
comment|/* Before we start, one word to the strange constants. 	 They are defined in RFC 1321 as  	 T[i] = (int) (4294967296.0 * fabs (sin (i))), i=1..64        */
comment|/* Round 1.  */
name|OP
argument_list|(
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|7
argument_list|,
literal|0xd76aa478
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|12
argument_list|,
literal|0xe8c7b756
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|17
argument_list|,
literal|0x242070db
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|22
argument_list|,
literal|0xc1bdceee
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|7
argument_list|,
literal|0xf57c0faf
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|12
argument_list|,
literal|0x4787c62a
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|17
argument_list|,
literal|0xa8304613
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|22
argument_list|,
literal|0xfd469501
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|7
argument_list|,
literal|0x698098d8
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|12
argument_list|,
literal|0x8b44f7af
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|17
argument_list|,
literal|0xffff5bb1
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|22
argument_list|,
literal|0x895cd7be
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|7
argument_list|,
literal|0x6b901122
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|12
argument_list|,
literal|0xfd987193
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|17
argument_list|,
literal|0xa679438e
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|22
argument_list|,
literal|0x49b40821
argument_list|)
expr_stmt|;
comment|/* For the second to fourth round we have the possibly swapped words 	 in CORRECT_WORDS.  Redefine the macro to take an additional first 	 argument specifying the function to use.  */
undef|#
directive|undef
name|OP
define|#
directive|define
name|OP
parameter_list|(
name|f
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|,
name|k
parameter_list|,
name|s
parameter_list|,
name|T
parameter_list|)
define|\
value|do 								\ 	{								\ 	  a += f (b, c, d) + correct_words[k] + T;			\ 	  CYCLIC (a, s);						\ 	  a += b;							\ 	}								\       while (0)
comment|/* Round 2.  */
name|OP
argument_list|(
name|FG
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|0xf61e2562
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FG
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|6
argument_list|,
literal|9
argument_list|,
literal|0xc040b340
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FG
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|11
argument_list|,
literal|14
argument_list|,
literal|0x265e5a51
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FG
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|0
argument_list|,
literal|20
argument_list|,
literal|0xe9b6c7aa
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FG
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
literal|0xd62f105d
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FG
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|10
argument_list|,
literal|9
argument_list|,
literal|0x02441453
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FG
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|15
argument_list|,
literal|14
argument_list|,
literal|0xd8a1e681
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FG
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|4
argument_list|,
literal|20
argument_list|,
literal|0xe7d3fbc8
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FG
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|9
argument_list|,
literal|5
argument_list|,
literal|0x21e1cde6
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FG
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|14
argument_list|,
literal|9
argument_list|,
literal|0xc33707d6
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FG
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|3
argument_list|,
literal|14
argument_list|,
literal|0xf4d50d87
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FG
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|8
argument_list|,
literal|20
argument_list|,
literal|0x455a14ed
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FG
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|13
argument_list|,
literal|5
argument_list|,
literal|0xa9e3e905
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FG
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|2
argument_list|,
literal|9
argument_list|,
literal|0xfcefa3f8
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FG
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|7
argument_list|,
literal|14
argument_list|,
literal|0x676f02d9
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FG
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|12
argument_list|,
literal|20
argument_list|,
literal|0x8d2a4c8a
argument_list|)
expr_stmt|;
comment|/* Round 3.  */
name|OP
argument_list|(
name|FH
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|5
argument_list|,
literal|4
argument_list|,
literal|0xfffa3942
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FH
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|8
argument_list|,
literal|11
argument_list|,
literal|0x8771f681
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FH
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|11
argument_list|,
literal|16
argument_list|,
literal|0x6d9d6122
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FH
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|14
argument_list|,
literal|23
argument_list|,
literal|0xfde5380c
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FH
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0xa4beea44
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FH
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|4
argument_list|,
literal|11
argument_list|,
literal|0x4bdecfa9
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FH
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|7
argument_list|,
literal|16
argument_list|,
literal|0xf6bb4b60
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FH
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|10
argument_list|,
literal|23
argument_list|,
literal|0xbebfbc70
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FH
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|13
argument_list|,
literal|4
argument_list|,
literal|0x289b7ec6
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FH
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|0
argument_list|,
literal|11
argument_list|,
literal|0xeaa127fa
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FH
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|3
argument_list|,
literal|16
argument_list|,
literal|0xd4ef3085
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FH
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|6
argument_list|,
literal|23
argument_list|,
literal|0x04881d05
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FH
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|9
argument_list|,
literal|4
argument_list|,
literal|0xd9d4d039
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FH
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|12
argument_list|,
literal|11
argument_list|,
literal|0xe6db99e5
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FH
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|15
argument_list|,
literal|16
argument_list|,
literal|0x1fa27cf8
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FH
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|2
argument_list|,
literal|23
argument_list|,
literal|0xc4ac5665
argument_list|)
expr_stmt|;
comment|/* Round 4.  */
name|OP
argument_list|(
name|FI
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|0
argument_list|,
literal|6
argument_list|,
literal|0xf4292244
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FI
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|7
argument_list|,
literal|10
argument_list|,
literal|0x432aff97
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FI
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|14
argument_list|,
literal|15
argument_list|,
literal|0xab9423a7
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FI
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|5
argument_list|,
literal|21
argument_list|,
literal|0xfc93a039
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FI
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|12
argument_list|,
literal|6
argument_list|,
literal|0x655b59c3
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FI
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|3
argument_list|,
literal|10
argument_list|,
literal|0x8f0ccc92
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FI
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|10
argument_list|,
literal|15
argument_list|,
literal|0xffeff47d
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FI
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|1
argument_list|,
literal|21
argument_list|,
literal|0x85845dd1
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FI
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|8
argument_list|,
literal|6
argument_list|,
literal|0x6fa87e4f
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FI
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|15
argument_list|,
literal|10
argument_list|,
literal|0xfe2ce6e0
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FI
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|6
argument_list|,
literal|15
argument_list|,
literal|0xa3014314
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FI
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|13
argument_list|,
literal|21
argument_list|,
literal|0x4e0811a1
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FI
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|4
argument_list|,
literal|6
argument_list|,
literal|0xf7537e82
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FI
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|11
argument_list|,
literal|10
argument_list|,
literal|0xbd3af235
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FI
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|2
argument_list|,
literal|15
argument_list|,
literal|0x2ad7d2bb
argument_list|)
expr_stmt|;
name|OP
argument_list|(
name|FI
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|9
argument_list|,
literal|21
argument_list|,
literal|0xeb86d391
argument_list|)
expr_stmt|;
comment|/* Add the starting values of the context.  */
name|A
operator|+=
name|A_save
expr_stmt|;
name|B
operator|+=
name|B_save
expr_stmt|;
name|C
operator|+=
name|C_save
expr_stmt|;
name|D
operator|+=
name|D_save
expr_stmt|;
block|}
comment|/* Put checksum in context given as argument.  */
name|ctx
operator|->
name|A
operator|=
name|A
expr_stmt|;
name|ctx
operator|->
name|B
operator|=
name|B
expr_stmt|;
name|ctx
operator|->
name|C
operator|=
name|C
expr_stmt|;
name|ctx
operator|->
name|D
operator|=
name|D
expr_stmt|;
block|}
end_function

end_unit

