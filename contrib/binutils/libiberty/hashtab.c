begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* An expandable hash tables datatype.      Copyright (C) 1999 Free Software Foundation, Inc.    Contributed by Vladimir Makarov (vmakarov@cygnus.com).  This file is part of the libiberty library. Libiberty is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  Libiberty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with libiberty; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This package implements basic hash table functionality.  It is possible    to search for an entry, create an entry and destroy an entry.     Elements in the table are generic pointers.     The size of the table is not fixed; if the occupancy of the table    grows too high the hash table will be expanded.     The abstract data implementation is based on generalized Algorithm D    from Knuth's book "The art of computer programming".  Hash table is    expanded by creation of new hash table and transferring elements from    the old table to the new table. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_comment
comment|/* This macro defines reserved value for empty table entry. */
end_comment

begin_define
define|#
directive|define
name|EMPTY_ENTRY
value|((void *) 0)
end_define

begin_comment
comment|/* This macro defines reserved value for table entry which contained    a deleted element. */
end_comment

begin_define
define|#
directive|define
name|DELETED_ENTRY
value|((void *) 1)
end_define

begin_comment
comment|/* The following function returns the nearest prime number which is    greater than given source number. */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|higher_prime_number
parameter_list|(
name|n
parameter_list|)
name|unsigned
name|long
name|n
decl_stmt|;
block|{
name|unsigned
name|long
name|i
decl_stmt|;
name|n
operator||=
literal|0x01
expr_stmt|;
comment|/* Force N to be odd.  */
if|if
condition|(
name|n
operator|<
literal|9
condition|)
return|return
name|n
return|;
comment|/* All odd numbers< 9 are prime.  */
name|next
label|:
name|n
operator|+=
literal|2
expr_stmt|;
name|i
operator|=
literal|3
expr_stmt|;
do|do
block|{
if|if
condition|(
name|n
operator|%
name|i
operator|==
literal|0
condition|)
goto|goto
name|next
goto|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|i
operator|*
name|i
operator|)
operator|<=
name|n
condition|)
do|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* This function creates table with length slightly longer than given    source length.  Created hash table is initiated as empty (all the    hash table entries are EMPTY_ENTRY).  The function returns the    created hash table. */
end_comment

begin_function
name|htab_t
name|htab_create
parameter_list|(
name|size
parameter_list|,
name|hash_f
parameter_list|,
name|eq_f
parameter_list|,
name|del_f
parameter_list|)
name|size_t
name|size
decl_stmt|;
name|htab_hash
name|hash_f
decl_stmt|;
name|htab_eq
name|eq_f
decl_stmt|;
name|htab_del
name|del_f
decl_stmt|;
block|{
name|htab_t
name|result
decl_stmt|;
name|size
operator|=
name|higher_prime_number
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|htab_t
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|htab
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|entries
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|result
operator|->
name|hash_f
operator|=
name|hash_f
expr_stmt|;
name|result
operator|->
name|eq_f
operator|=
name|eq_f
expr_stmt|;
name|result
operator|->
name|del_f
operator|=
name|del_f
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* This function frees all memory allocated for given hash table.    Naturally the hash table must already exist. */
end_comment

begin_function
name|void
name|htab_delete
parameter_list|(
name|htab
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|htab
operator|->
name|del_f
condition|)
for|for
control|(
name|i
operator|=
name|htab
operator|->
name|size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|htab
operator|->
name|entries
index|[
name|i
index|]
operator|!=
name|EMPTY_ENTRY
operator|&&
name|htab
operator|->
name|entries
index|[
name|i
index|]
operator|!=
name|DELETED_ENTRY
condition|)
call|(
modifier|*
name|htab
operator|->
name|del_f
call|)
argument_list|(
name|htab
operator|->
name|entries
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|htab
operator|->
name|entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|htab
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function clears all entries in the given hash table.  */
end_comment

begin_function
name|void
name|htab_empty
parameter_list|(
name|htab
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|htab
operator|->
name|del_f
condition|)
for|for
control|(
name|i
operator|=
name|htab
operator|->
name|size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|htab
operator|->
name|entries
index|[
name|i
index|]
operator|!=
name|EMPTY_ENTRY
operator|&&
name|htab
operator|->
name|entries
index|[
name|i
index|]
operator|!=
name|DELETED_ENTRY
condition|)
call|(
modifier|*
name|htab
operator|->
name|del_f
call|)
argument_list|(
name|htab
operator|->
name|entries
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|htab
operator|->
name|entries
argument_list|,
literal|0
argument_list|,
name|htab
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar to htab_find_slot, but without several unwanted side effects:     - Does not call htab->eq_f when it finds an existing entry.     - Does not change the count of elements/searches/collisions in the       hash table.    This function also assumes there are no deleted entries in the table.    HASH is the hash value for the element to be inserted.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
modifier|*
name|find_empty_slot_for_expand
parameter_list|(
name|htab
parameter_list|,
name|hash
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|;
block|{
name|size_t
name|size
init|=
name|htab
operator|->
name|size
decl_stmt|;
name|unsigned
name|int
name|hash2
init|=
literal|1
operator|+
name|hash
operator|%
operator|(
name|size
operator|-
literal|2
operator|)
decl_stmt|;
name|unsigned
name|int
name|index
init|=
name|hash
operator|%
name|size
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|void
modifier|*
modifier|*
name|slot
init|=
name|htab
operator|->
name|entries
operator|+
name|index
decl_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
name|EMPTY_ENTRY
condition|)
return|return
name|slot
return|;
if|if
condition|(
operator|*
name|slot
operator|==
name|DELETED_ENTRY
condition|)
name|abort
argument_list|()
expr_stmt|;
name|index
operator|+=
name|hash2
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|size
condition|)
name|index
operator|-=
name|size
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The following function changes size of memory allocated for the    entries and repeatedly inserts the table elements.  The occupancy    of the table after the call will be about 50%.  Naturally the hash    table must already exist.  Remember also that the place of the    table entries is changed. */
end_comment

begin_function
specifier|static
name|void
name|htab_expand
parameter_list|(
name|htab
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
block|{
name|void
modifier|*
modifier|*
name|oentries
decl_stmt|;
name|void
modifier|*
modifier|*
name|olimit
decl_stmt|;
name|void
modifier|*
modifier|*
name|p
decl_stmt|;
name|oentries
operator|=
name|htab
operator|->
name|entries
expr_stmt|;
name|olimit
operator|=
name|oentries
operator|+
name|htab
operator|->
name|size
expr_stmt|;
name|htab
operator|->
name|size
operator|=
name|higher_prime_number
argument_list|(
name|htab
operator|->
name|size
operator|*
literal|2
argument_list|)
expr_stmt|;
name|htab
operator|->
name|entries
operator|=
name|xcalloc
argument_list|(
name|htab
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|htab
operator|->
name|n_elements
operator|-=
name|htab
operator|->
name|n_deleted
expr_stmt|;
name|htab
operator|->
name|n_deleted
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|oentries
expr_stmt|;
do|do
block|{
name|void
modifier|*
name|x
init|=
operator|*
name|p
decl_stmt|;
if|if
condition|(
name|x
operator|!=
name|EMPTY_ENTRY
operator|&&
name|x
operator|!=
name|DELETED_ENTRY
condition|)
block|{
name|void
modifier|*
modifier|*
name|q
init|=
name|find_empty_slot_for_expand
argument_list|(
name|htab
argument_list|,
call|(
modifier|*
name|htab
operator|->
name|hash_f
call|)
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|q
operator|=
name|x
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|<
name|olimit
condition|)
do|;
name|free
argument_list|(
name|oentries
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function searches for a hash table entry equal to the given    element.  It cannot be used to insert or delete an element.  */
end_comment

begin_function
name|void
modifier|*
name|htab_find_with_hash
parameter_list|(
name|htab
parameter_list|,
name|element
parameter_list|,
name|hash
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
specifier|const
name|void
modifier|*
name|element
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|;
block|{
name|unsigned
name|int
name|index
decl_stmt|,
name|hash2
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|htab
operator|->
name|searches
operator|++
expr_stmt|;
name|size
operator|=
name|htab
operator|->
name|size
expr_stmt|;
name|hash2
operator|=
literal|1
operator|+
name|hash
operator|%
operator|(
name|size
operator|-
literal|2
operator|)
expr_stmt|;
name|index
operator|=
name|hash
operator|%
name|size
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|void
modifier|*
name|entry
init|=
name|htab
operator|->
name|entries
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
name|entry
operator|==
name|EMPTY_ENTRY
condition|)
return|return
name|NULL
return|;
elseif|else
if|if
condition|(
name|entry
operator|!=
name|DELETED_ENTRY
operator|&&
call|(
modifier|*
name|htab
operator|->
name|eq_f
call|)
argument_list|(
name|entry
argument_list|,
name|element
argument_list|)
condition|)
return|return
name|entry
return|;
name|htab
operator|->
name|collisions
operator|++
expr_stmt|;
name|index
operator|+=
name|hash2
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|size
condition|)
name|index
operator|-=
name|size
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Like htab_find_slot_with_hash, but compute the hash value from the    element.  */
end_comment

begin_function
name|void
modifier|*
name|htab_find
parameter_list|(
name|htab
parameter_list|,
name|element
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
specifier|const
name|void
modifier|*
name|element
decl_stmt|;
block|{
return|return
name|htab_find_with_hash
argument_list|(
name|htab
argument_list|,
name|element
argument_list|,
call|(
modifier|*
name|htab
operator|->
name|hash_f
call|)
argument_list|(
name|element
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This function searches for a hash table slot containing an entry    equal to the given element.  To delete an entry, call this with    INSERT = 0, then call htab_clear_slot on the slot returned (possibly    after doing some checks).  To insert an entry, call this with    INSERT = 1, then write the value you want into the returned slot.  */
end_comment

begin_function
name|void
modifier|*
modifier|*
name|htab_find_slot_with_hash
parameter_list|(
name|htab
parameter_list|,
name|element
parameter_list|,
name|hash
parameter_list|,
name|insert
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
specifier|const
name|void
modifier|*
name|element
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|;
name|int
name|insert
decl_stmt|;
block|{
name|void
modifier|*
modifier|*
name|first_deleted_slot
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|,
name|hash2
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|insert
operator|&&
name|htab
operator|->
name|size
operator|*
literal|3
operator|<=
name|htab
operator|->
name|n_elements
operator|*
literal|4
condition|)
name|htab_expand
argument_list|(
name|htab
argument_list|)
expr_stmt|;
name|size
operator|=
name|htab
operator|->
name|size
expr_stmt|;
name|hash2
operator|=
literal|1
operator|+
name|hash
operator|%
operator|(
name|size
operator|-
literal|2
operator|)
expr_stmt|;
name|index
operator|=
name|hash
operator|%
name|size
expr_stmt|;
name|htab
operator|->
name|searches
operator|++
expr_stmt|;
name|first_deleted_slot
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|void
modifier|*
name|entry
init|=
name|htab
operator|->
name|entries
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
name|entry
operator|==
name|EMPTY_ENTRY
condition|)
block|{
if|if
condition|(
operator|!
name|insert
condition|)
return|return
name|NULL
return|;
name|htab
operator|->
name|n_elements
operator|++
expr_stmt|;
if|if
condition|(
name|first_deleted_slot
condition|)
block|{
operator|*
name|first_deleted_slot
operator|=
name|EMPTY_ENTRY
expr_stmt|;
return|return
name|first_deleted_slot
return|;
block|}
return|return
operator|&
name|htab
operator|->
name|entries
index|[
name|index
index|]
return|;
block|}
if|if
condition|(
name|entry
operator|==
name|DELETED_ENTRY
condition|)
block|{
if|if
condition|(
operator|!
name|first_deleted_slot
condition|)
name|first_deleted_slot
operator|=
operator|&
name|htab
operator|->
name|entries
index|[
name|index
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
call|(
modifier|*
name|htab
operator|->
name|eq_f
call|)
argument_list|(
name|entry
argument_list|,
name|element
argument_list|)
condition|)
return|return
operator|&
name|htab
operator|->
name|entries
index|[
name|index
index|]
return|;
block|}
name|htab
operator|->
name|collisions
operator|++
expr_stmt|;
name|index
operator|+=
name|hash2
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|size
condition|)
name|index
operator|-=
name|size
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Like htab_find_slot_with_hash, but compute the hash value from the    element.  */
end_comment

begin_function
name|void
modifier|*
modifier|*
name|htab_find_slot
parameter_list|(
name|htab
parameter_list|,
name|element
parameter_list|,
name|insert
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
specifier|const
name|void
modifier|*
name|element
decl_stmt|;
name|int
name|insert
decl_stmt|;
block|{
return|return
name|htab_find_slot_with_hash
argument_list|(
name|htab
argument_list|,
name|element
argument_list|,
call|(
modifier|*
name|htab
operator|->
name|hash_f
call|)
argument_list|(
name|element
argument_list|)
argument_list|,
name|insert
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This function deletes an element with the given value from hash    table.  If there is no matching element in the hash table, this    function does nothing.  */
end_comment

begin_function
name|void
name|htab_remove_elt
parameter_list|(
name|htab
parameter_list|,
name|element
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
name|void
modifier|*
name|element
decl_stmt|;
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|htab
argument_list|,
name|element
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
name|EMPTY_ENTRY
condition|)
return|return;
if|if
condition|(
name|htab
operator|->
name|del_f
condition|)
call|(
modifier|*
name|htab
operator|->
name|del_f
call|)
argument_list|(
operator|*
name|slot
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|DELETED_ENTRY
expr_stmt|;
name|htab
operator|->
name|n_deleted
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function clears a specified slot in a hash table.  It is    useful when you've already done the lookup and don't want to do it    again.  */
end_comment

begin_function
name|void
name|htab_clear_slot
parameter_list|(
name|htab
parameter_list|,
name|slot
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
block|{
if|if
condition|(
name|slot
operator|<
name|htab
operator|->
name|entries
operator|||
name|slot
operator|>=
name|htab
operator|->
name|entries
operator|+
name|htab
operator|->
name|size
operator|||
operator|*
name|slot
operator|==
name|EMPTY_ENTRY
operator|||
operator|*
name|slot
operator|==
name|DELETED_ENTRY
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|del_f
condition|)
call|(
modifier|*
name|htab
operator|->
name|del_f
call|)
argument_list|(
operator|*
name|slot
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|DELETED_ENTRY
expr_stmt|;
name|htab
operator|->
name|n_deleted
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function scans over the entire hash table calling    CALLBACK for each live entry.  If CALLBACK returns false,    the iteration stops.  INFO is passed as CALLBACK's second    argument.  */
end_comment

begin_function
name|void
name|htab_traverse
parameter_list|(
name|htab
parameter_list|,
name|callback
parameter_list|,
name|info
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
name|htab_trav
name|callback
decl_stmt|;
name|void
modifier|*
name|info
decl_stmt|;
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|,
modifier|*
modifier|*
name|limit
decl_stmt|;
name|slot
operator|=
name|htab
operator|->
name|entries
expr_stmt|;
name|limit
operator|=
name|slot
operator|+
name|htab
operator|->
name|size
expr_stmt|;
do|do
block|{
name|void
modifier|*
name|x
init|=
operator|*
name|slot
decl_stmt|;
if|if
condition|(
name|x
operator|!=
name|EMPTY_ENTRY
operator|&&
name|x
operator|!=
name|DELETED_ENTRY
condition|)
if|if
condition|(
operator|!
call|(
modifier|*
name|callback
call|)
argument_list|(
name|slot
argument_list|,
name|info
argument_list|)
condition|)
break|break;
block|}
do|while
condition|(
operator|++
name|slot
operator|<
name|limit
condition|)
do|;
block|}
end_function

begin_comment
comment|/* The following function returns current size of given hash table. */
end_comment

begin_function
name|size_t
name|htab_size
parameter_list|(
name|htab
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
block|{
return|return
name|htab
operator|->
name|size
return|;
block|}
end_function

begin_comment
comment|/* The following function returns current number of elements in given    hash table. */
end_comment

begin_function
name|size_t
name|htab_elements
parameter_list|(
name|htab
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
block|{
return|return
name|htab
operator|->
name|n_elements
operator|-
name|htab
operator|->
name|n_deleted
return|;
block|}
end_function

begin_comment
comment|/* The following function returns number of percents of fixed    collisions during all work with given hash table. */
end_comment

begin_function
name|double
name|htab_collisions
parameter_list|(
name|htab
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
block|{
name|int
name|searches
decl_stmt|;
name|searches
operator|=
name|htab
operator|->
name|searches
expr_stmt|;
if|if
condition|(
name|searches
operator|==
literal|0
condition|)
return|return
literal|0.0
return|;
return|return
operator|(
name|double
operator|)
name|htab
operator|->
name|collisions
operator|/
operator|(
name|double
operator|)
name|searches
return|;
block|}
end_function

end_unit

