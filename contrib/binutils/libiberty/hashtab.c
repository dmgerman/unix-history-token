begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* An expandable hash tables datatype.      Copyright (C) 1999, 2000 Free Software Foundation, Inc.    Contributed by Vladimir Makarov (vmakarov@cygnus.com).  This file is part of the libiberty library. Libiberty is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  Libiberty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with libiberty; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This package implements basic hash table functionality.  It is possible    to search for an entry, create an entry and destroy an entry.     Elements in the table are generic pointers.     The size of the table is not fixed; if the occupancy of the table    grows too high the hash table will be expanded.     The abstract data implementation is based on generalized Algorithm D    from Knuth's book "The art of computer programming".  Hash table is    expanded by creation of new hash table and transferring elements from    the old table to the new table. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_comment
comment|/* This macro defines reserved value for empty table entry. */
end_comment

begin_define
define|#
directive|define
name|EMPTY_ENTRY
value|((PTR) 0)
end_define

begin_comment
comment|/* This macro defines reserved value for table entry which contained    a deleted element. */
end_comment

begin_define
define|#
directive|define
name|DELETED_ENTRY
value|((PTR) 1)
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|higher_prime_number
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hashval_t
name|hash_pointer
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eq_pointer
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|htab_expand
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|PTR
modifier|*
name|find_empty_slot_for_expand
name|PARAMS
argument_list|(
operator|(
name|htab_t
operator|,
name|hashval_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* At some point, we could make these be NULL, and modify the    hash-table routines to handle NULL specially; that would avoid    function-call overhead for the common case of hashing pointers.  */
end_comment

begin_decl_stmt
name|htab_hash
name|htab_hash_pointer
init|=
name|hash_pointer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|htab_eq
name|htab_eq_pointer
init|=
name|eq_pointer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following function returns a nearest prime number which is    greater than N, and near a power of two. */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|higher_prime_number
parameter_list|(
name|n
parameter_list|)
name|unsigned
name|long
name|n
decl_stmt|;
block|{
comment|/* These are primes that are near, but slightly smaller than, a      power of two.  */
specifier|static
name|unsigned
name|long
name|primes
index|[]
init|=
block|{
literal|2
block|,
literal|7
block|,
literal|13
block|,
literal|31
block|,
literal|61
block|,
literal|127
block|,
literal|251
block|,
literal|509
block|,
literal|1021
block|,
literal|2039
block|,
literal|4093
block|,
literal|8191
block|,
literal|16381
block|,
literal|32749
block|,
literal|65521
block|,
literal|131071
block|,
literal|262139
block|,
literal|524287
block|,
literal|1048573
block|,
literal|2097143
block|,
literal|4194301
block|,
literal|8388593
block|,
literal|16777213
block|,
literal|33554393
block|,
literal|67108859
block|,
literal|134217689
block|,
literal|268435399
block|,
literal|536870909
block|,
literal|1073741789
block|,
literal|2147483647
block|,
literal|4294967291
block|}
decl_stmt|;
name|unsigned
name|long
modifier|*
name|low
init|=
operator|&
name|primes
index|[
literal|0
index|]
decl_stmt|;
name|unsigned
name|long
modifier|*
name|high
init|=
operator|&
name|primes
index|[
sizeof|sizeof
argument_list|(
name|primes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|primes
index|[
literal|0
index|]
argument_list|)
index|]
decl_stmt|;
while|while
condition|(
name|low
operator|!=
name|high
condition|)
block|{
name|unsigned
name|long
modifier|*
name|mid
init|=
name|low
operator|+
operator|(
name|high
operator|-
name|low
operator|)
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|n
operator|>
operator|*
name|mid
condition|)
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
name|high
operator|=
name|mid
expr_stmt|;
block|}
comment|/* If we've run out of primes, abort.  */
if|if
condition|(
name|n
operator|>
operator|*
name|low
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot find prime bigger than %lu\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|*
name|low
return|;
block|}
end_function

begin_comment
comment|/* Returns a hash code for P.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|hash_pointer
parameter_list|(
name|p
parameter_list|)
specifier|const
name|PTR
name|p
decl_stmt|;
block|{
return|return
call|(
name|hashval_t
call|)
argument_list|(
operator|(
name|long
operator|)
name|p
operator|>>
literal|3
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if P1 and P2 are equal.  */
end_comment

begin_function
specifier|static
name|int
name|eq_pointer
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
specifier|const
name|PTR
name|p1
decl_stmt|;
specifier|const
name|PTR
name|p2
decl_stmt|;
block|{
return|return
name|p1
operator|==
name|p2
return|;
block|}
end_function

begin_comment
comment|/* This function creates table with length slightly longer than given    source length.  Created hash table is initiated as empty (all the    hash table entries are EMPTY_ENTRY).  The function returns the    created hash table.  Memory allocation must not fail.  */
end_comment

begin_function
name|htab_t
name|htab_create
parameter_list|(
name|size
parameter_list|,
name|hash_f
parameter_list|,
name|eq_f
parameter_list|,
name|del_f
parameter_list|)
name|size_t
name|size
decl_stmt|;
name|htab_hash
name|hash_f
decl_stmt|;
name|htab_eq
name|eq_f
decl_stmt|;
name|htab_del
name|del_f
decl_stmt|;
block|{
name|htab_t
name|result
decl_stmt|;
name|size
operator|=
name|higher_prime_number
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|htab_t
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|htab
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|entries
operator|=
operator|(
name|PTR
operator|*
operator|)
name|xcalloc
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|PTR
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|result
operator|->
name|hash_f
operator|=
name|hash_f
expr_stmt|;
name|result
operator|->
name|eq_f
operator|=
name|eq_f
expr_stmt|;
name|result
operator|->
name|del_f
operator|=
name|del_f
expr_stmt|;
name|result
operator|->
name|return_allocation_failure
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* This function creates table with length slightly longer than given    source length.  The created hash table is initiated as empty (all the    hash table entries are EMPTY_ENTRY).  The function returns the created    hash table.  Memory allocation may fail; it may return NULL.  */
end_comment

begin_function
name|htab_t
name|htab_try_create
parameter_list|(
name|size
parameter_list|,
name|hash_f
parameter_list|,
name|eq_f
parameter_list|,
name|del_f
parameter_list|)
name|size_t
name|size
decl_stmt|;
name|htab_hash
name|hash_f
decl_stmt|;
name|htab_eq
name|eq_f
decl_stmt|;
name|htab_del
name|del_f
decl_stmt|;
block|{
name|htab_t
name|result
decl_stmt|;
name|size
operator|=
name|higher_prime_number
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|htab_t
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|htab
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|result
operator|->
name|entries
operator|=
operator|(
name|PTR
operator|*
operator|)
name|calloc
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|PTR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|entries
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|result
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|result
operator|->
name|hash_f
operator|=
name|hash_f
expr_stmt|;
name|result
operator|->
name|eq_f
operator|=
name|eq_f
expr_stmt|;
name|result
operator|->
name|del_f
operator|=
name|del_f
expr_stmt|;
name|result
operator|->
name|return_allocation_failure
operator|=
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* This function frees all memory allocated for given hash table.    Naturally the hash table must already exist. */
end_comment

begin_function
name|void
name|htab_delete
parameter_list|(
name|htab
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|htab
operator|->
name|del_f
condition|)
for|for
control|(
name|i
operator|=
name|htab
operator|->
name|size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|htab
operator|->
name|entries
index|[
name|i
index|]
operator|!=
name|EMPTY_ENTRY
operator|&&
name|htab
operator|->
name|entries
index|[
name|i
index|]
operator|!=
name|DELETED_ENTRY
condition|)
call|(
modifier|*
name|htab
operator|->
name|del_f
call|)
argument_list|(
name|htab
operator|->
name|entries
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|htab
operator|->
name|entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|htab
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function clears all entries in the given hash table.  */
end_comment

begin_function
name|void
name|htab_empty
parameter_list|(
name|htab
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|htab
operator|->
name|del_f
condition|)
for|for
control|(
name|i
operator|=
name|htab
operator|->
name|size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|htab
operator|->
name|entries
index|[
name|i
index|]
operator|!=
name|EMPTY_ENTRY
operator|&&
name|htab
operator|->
name|entries
index|[
name|i
index|]
operator|!=
name|DELETED_ENTRY
condition|)
call|(
modifier|*
name|htab
operator|->
name|del_f
call|)
argument_list|(
name|htab
operator|->
name|entries
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|htab
operator|->
name|entries
argument_list|,
literal|0
argument_list|,
name|htab
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|PTR
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar to htab_find_slot, but without several unwanted side effects:     - Does not call htab->eq_f when it finds an existing entry.     - Does not change the count of elements/searches/collisions in the       hash table.    This function also assumes there are no deleted entries in the table.    HASH is the hash value for the element to be inserted.  */
end_comment

begin_function
specifier|static
name|PTR
modifier|*
name|find_empty_slot_for_expand
parameter_list|(
name|htab
parameter_list|,
name|hash
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
name|hashval_t
name|hash
decl_stmt|;
block|{
name|size_t
name|size
init|=
name|htab
operator|->
name|size
decl_stmt|;
name|hashval_t
name|hash2
init|=
literal|1
operator|+
name|hash
operator|%
operator|(
name|size
operator|-
literal|2
operator|)
decl_stmt|;
name|unsigned
name|int
name|index
init|=
name|hash
operator|%
name|size
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|PTR
modifier|*
name|slot
init|=
name|htab
operator|->
name|entries
operator|+
name|index
decl_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
name|EMPTY_ENTRY
condition|)
return|return
name|slot
return|;
elseif|else
if|if
condition|(
operator|*
name|slot
operator|==
name|DELETED_ENTRY
condition|)
name|abort
argument_list|()
expr_stmt|;
name|index
operator|+=
name|hash2
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|size
condition|)
name|index
operator|-=
name|size
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The following function changes size of memory allocated for the    entries and repeatedly inserts the table elements.  The occupancy    of the table after the call will be about 50%.  Naturally the hash    table must already exist.  Remember also that the place of the    table entries is changed.  If memory allocation failures are allowed,    this function will return zero, indicating that the table could not be    expanded.  If all goes well, it will return a non-zero value.  */
end_comment

begin_function
specifier|static
name|int
name|htab_expand
parameter_list|(
name|htab
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
block|{
name|PTR
modifier|*
name|oentries
decl_stmt|;
name|PTR
modifier|*
name|olimit
decl_stmt|;
name|PTR
modifier|*
name|p
decl_stmt|;
name|oentries
operator|=
name|htab
operator|->
name|entries
expr_stmt|;
name|olimit
operator|=
name|oentries
operator|+
name|htab
operator|->
name|size
expr_stmt|;
name|htab
operator|->
name|size
operator|=
name|higher_prime_number
argument_list|(
name|htab
operator|->
name|size
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|return_allocation_failure
condition|)
block|{
name|PTR
modifier|*
name|nentries
init|=
operator|(
name|PTR
operator|*
operator|)
name|calloc
argument_list|(
name|htab
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|PTR
operator|*
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|nentries
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|htab
operator|->
name|entries
operator|=
name|nentries
expr_stmt|;
block|}
else|else
name|htab
operator|->
name|entries
operator|=
operator|(
name|PTR
operator|*
operator|)
name|xcalloc
argument_list|(
name|htab
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|PTR
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|htab
operator|->
name|n_elements
operator|-=
name|htab
operator|->
name|n_deleted
expr_stmt|;
name|htab
operator|->
name|n_deleted
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|oentries
expr_stmt|;
do|do
block|{
name|PTR
name|x
init|=
operator|*
name|p
decl_stmt|;
if|if
condition|(
name|x
operator|!=
name|EMPTY_ENTRY
operator|&&
name|x
operator|!=
name|DELETED_ENTRY
condition|)
block|{
name|PTR
modifier|*
name|q
init|=
name|find_empty_slot_for_expand
argument_list|(
name|htab
argument_list|,
call|(
modifier|*
name|htab
operator|->
name|hash_f
call|)
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|q
operator|=
name|x
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|<
name|olimit
condition|)
do|;
name|free
argument_list|(
name|oentries
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This function searches for a hash table entry equal to the given    element.  It cannot be used to insert or delete an element.  */
end_comment

begin_function
name|PTR
name|htab_find_with_hash
parameter_list|(
name|htab
parameter_list|,
name|element
parameter_list|,
name|hash
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
specifier|const
name|PTR
name|element
decl_stmt|;
name|hashval_t
name|hash
decl_stmt|;
block|{
name|unsigned
name|int
name|index
decl_stmt|;
name|hashval_t
name|hash2
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|PTR
name|entry
decl_stmt|;
name|htab
operator|->
name|searches
operator|++
expr_stmt|;
name|size
operator|=
name|htab
operator|->
name|size
expr_stmt|;
name|index
operator|=
name|hash
operator|%
name|size
expr_stmt|;
name|entry
operator|=
name|htab
operator|->
name|entries
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|EMPTY_ENTRY
operator|||
operator|(
name|entry
operator|!=
name|DELETED_ENTRY
operator|&&
call|(
modifier|*
name|htab
operator|->
name|eq_f
call|)
argument_list|(
name|entry
argument_list|,
name|element
argument_list|)
operator|)
condition|)
return|return
name|entry
return|;
name|hash2
operator|=
literal|1
operator|+
name|hash
operator|%
operator|(
name|size
operator|-
literal|2
operator|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|htab
operator|->
name|collisions
operator|++
expr_stmt|;
name|index
operator|+=
name|hash2
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|size
condition|)
name|index
operator|-=
name|size
expr_stmt|;
name|entry
operator|=
name|htab
operator|->
name|entries
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|EMPTY_ENTRY
operator|||
operator|(
name|entry
operator|!=
name|DELETED_ENTRY
operator|&&
call|(
modifier|*
name|htab
operator|->
name|eq_f
call|)
argument_list|(
name|entry
argument_list|,
name|element
argument_list|)
operator|)
condition|)
return|return
name|entry
return|;
block|}
block|}
end_function

begin_comment
comment|/* Like htab_find_slot_with_hash, but compute the hash value from the    element.  */
end_comment

begin_function
name|PTR
name|htab_find
parameter_list|(
name|htab
parameter_list|,
name|element
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
specifier|const
name|PTR
name|element
decl_stmt|;
block|{
return|return
name|htab_find_with_hash
argument_list|(
name|htab
argument_list|,
name|element
argument_list|,
call|(
modifier|*
name|htab
operator|->
name|hash_f
call|)
argument_list|(
name|element
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This function searches for a hash table slot containing an entry    equal to the given element.  To delete an entry, call this with    INSERT = 0, then call htab_clear_slot on the slot returned (possibly    after doing some checks).  To insert an entry, call this with    INSERT = 1, then write the value you want into the returned slot.    When inserting an entry, NULL may be returned if memory allocation    fails.  */
end_comment

begin_function
name|PTR
modifier|*
name|htab_find_slot_with_hash
parameter_list|(
name|htab
parameter_list|,
name|element
parameter_list|,
name|hash
parameter_list|,
name|insert
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
specifier|const
name|PTR
name|element
decl_stmt|;
name|hashval_t
name|hash
decl_stmt|;
name|enum
name|insert_option
name|insert
decl_stmt|;
block|{
name|PTR
modifier|*
name|first_deleted_slot
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
name|hashval_t
name|hash2
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|insert
operator|==
name|INSERT
operator|&&
name|htab
operator|->
name|size
operator|*
literal|3
operator|<=
name|htab
operator|->
name|n_elements
operator|*
literal|4
operator|&&
name|htab_expand
argument_list|(
name|htab
argument_list|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|size
operator|=
name|htab
operator|->
name|size
expr_stmt|;
name|hash2
operator|=
literal|1
operator|+
name|hash
operator|%
operator|(
name|size
operator|-
literal|2
operator|)
expr_stmt|;
name|index
operator|=
name|hash
operator|%
name|size
expr_stmt|;
name|htab
operator|->
name|searches
operator|++
expr_stmt|;
name|first_deleted_slot
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|PTR
name|entry
init|=
name|htab
operator|->
name|entries
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
name|entry
operator|==
name|EMPTY_ENTRY
condition|)
block|{
if|if
condition|(
name|insert
operator|==
name|NO_INSERT
condition|)
return|return
name|NULL
return|;
name|htab
operator|->
name|n_elements
operator|++
expr_stmt|;
if|if
condition|(
name|first_deleted_slot
condition|)
block|{
operator|*
name|first_deleted_slot
operator|=
name|EMPTY_ENTRY
expr_stmt|;
return|return
name|first_deleted_slot
return|;
block|}
return|return
operator|&
name|htab
operator|->
name|entries
index|[
name|index
index|]
return|;
block|}
if|if
condition|(
name|entry
operator|==
name|DELETED_ENTRY
condition|)
block|{
if|if
condition|(
operator|!
name|first_deleted_slot
condition|)
name|first_deleted_slot
operator|=
operator|&
name|htab
operator|->
name|entries
index|[
name|index
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
call|(
modifier|*
name|htab
operator|->
name|eq_f
call|)
argument_list|(
name|entry
argument_list|,
name|element
argument_list|)
condition|)
return|return
operator|&
name|htab
operator|->
name|entries
index|[
name|index
index|]
return|;
name|htab
operator|->
name|collisions
operator|++
expr_stmt|;
name|index
operator|+=
name|hash2
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|size
condition|)
name|index
operator|-=
name|size
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Like htab_find_slot_with_hash, but compute the hash value from the    element.  */
end_comment

begin_function
name|PTR
modifier|*
name|htab_find_slot
parameter_list|(
name|htab
parameter_list|,
name|element
parameter_list|,
name|insert
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
specifier|const
name|PTR
name|element
decl_stmt|;
name|enum
name|insert_option
name|insert
decl_stmt|;
block|{
return|return
name|htab_find_slot_with_hash
argument_list|(
name|htab
argument_list|,
name|element
argument_list|,
call|(
modifier|*
name|htab
operator|->
name|hash_f
call|)
argument_list|(
name|element
argument_list|)
argument_list|,
name|insert
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This function deletes an element with the given value from hash    table.  If there is no matching element in the hash table, this    function does nothing.  */
end_comment

begin_function
name|void
name|htab_remove_elt
parameter_list|(
name|htab
parameter_list|,
name|element
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
name|PTR
name|element
decl_stmt|;
block|{
name|PTR
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|htab
argument_list|,
name|element
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
name|EMPTY_ENTRY
condition|)
return|return;
if|if
condition|(
name|htab
operator|->
name|del_f
condition|)
call|(
modifier|*
name|htab
operator|->
name|del_f
call|)
argument_list|(
operator|*
name|slot
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|DELETED_ENTRY
expr_stmt|;
name|htab
operator|->
name|n_deleted
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function clears a specified slot in a hash table.  It is    useful when you've already done the lookup and don't want to do it    again.  */
end_comment

begin_function
name|void
name|htab_clear_slot
parameter_list|(
name|htab
parameter_list|,
name|slot
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
name|PTR
modifier|*
name|slot
decl_stmt|;
block|{
if|if
condition|(
name|slot
operator|<
name|htab
operator|->
name|entries
operator|||
name|slot
operator|>=
name|htab
operator|->
name|entries
operator|+
name|htab
operator|->
name|size
operator|||
operator|*
name|slot
operator|==
name|EMPTY_ENTRY
operator|||
operator|*
name|slot
operator|==
name|DELETED_ENTRY
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|del_f
condition|)
call|(
modifier|*
name|htab
operator|->
name|del_f
call|)
argument_list|(
operator|*
name|slot
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|DELETED_ENTRY
expr_stmt|;
name|htab
operator|->
name|n_deleted
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function scans over the entire hash table calling    CALLBACK for each live entry.  If CALLBACK returns false,    the iteration stops.  INFO is passed as CALLBACK's second    argument.  */
end_comment

begin_function
name|void
name|htab_traverse
parameter_list|(
name|htab
parameter_list|,
name|callback
parameter_list|,
name|info
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
name|htab_trav
name|callback
decl_stmt|;
name|PTR
name|info
decl_stmt|;
block|{
name|PTR
modifier|*
name|slot
init|=
name|htab
operator|->
name|entries
decl_stmt|;
name|PTR
modifier|*
name|limit
init|=
name|slot
operator|+
name|htab
operator|->
name|size
decl_stmt|;
do|do
block|{
name|PTR
name|x
init|=
operator|*
name|slot
decl_stmt|;
if|if
condition|(
name|x
operator|!=
name|EMPTY_ENTRY
operator|&&
name|x
operator|!=
name|DELETED_ENTRY
condition|)
if|if
condition|(
operator|!
call|(
modifier|*
name|callback
call|)
argument_list|(
name|slot
argument_list|,
name|info
argument_list|)
condition|)
break|break;
block|}
do|while
condition|(
operator|++
name|slot
operator|<
name|limit
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Return the current size of given hash table. */
end_comment

begin_function
name|size_t
name|htab_size
parameter_list|(
name|htab
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
block|{
return|return
name|htab
operator|->
name|size
return|;
block|}
end_function

begin_comment
comment|/* Return the current number of elements in given hash table. */
end_comment

begin_function
name|size_t
name|htab_elements
parameter_list|(
name|htab
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
block|{
return|return
name|htab
operator|->
name|n_elements
operator|-
name|htab
operator|->
name|n_deleted
return|;
block|}
end_function

begin_comment
comment|/* Return the fraction of fixed collisions during all work with given    hash table. */
end_comment

begin_function
name|double
name|htab_collisions
parameter_list|(
name|htab
parameter_list|)
name|htab_t
name|htab
decl_stmt|;
block|{
if|if
condition|(
name|htab
operator|->
name|searches
operator|==
literal|0
condition|)
return|return
literal|0.0
return|;
return|return
operator|(
name|double
operator|)
name|htab
operator|->
name|collisions
operator|/
operator|(
name|double
operator|)
name|htab
operator|->
name|searches
return|;
block|}
end_function

end_unit

