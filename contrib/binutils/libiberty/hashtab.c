begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* An expandable hash tables datatype.      Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.    Contributed by Vladimir Makarov (vmakarov@cygnus.com).  This file is part of the libiberty library. Libiberty is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  Libiberty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with libiberty; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* This package implements basic hash table functionality.  It is possible    to search for an entry, create an entry and destroy an entry.     Elements in the table are generic pointers.     The size of the table is not fixed; if the occupancy of the table    grows too high the hash table will be expanded.     The abstract data implementation is based on generalized Algorithm D    from Knuth's book "The art of computer programming".  Hash table is    expanded by creation of new hash table and transferring elements from    the old table to the new table. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MALLOC_H
end_ifdef

begin_include
include|#
directive|include
file|<malloc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIMITS_H
end_ifdef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDINT_H
end_ifdef

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_BIT
end_ifndef

begin_define
define|#
directive|define
name|CHAR_BIT
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|unsigned
name|int
name|higher_prime_index
parameter_list|(
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|htab_mod_1
parameter_list|(
name|hashval_t
parameter_list|,
name|hashval_t
parameter_list|,
name|hashval_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|htab_mod
parameter_list|(
name|hashval_t
parameter_list|,
name|htab_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|htab_mod_m2
parameter_list|(
name|hashval_t
parameter_list|,
name|htab_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|hash_pointer
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|eq_pointer
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|htab_expand
parameter_list|(
name|htab_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|PTR
modifier|*
name|find_empty_slot_for_expand
parameter_list|(
name|htab_t
parameter_list|,
name|hashval_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* At some point, we could make these be NULL, and modify the    hash-table routines to handle NULL specially; that would avoid    function-call overhead for the common case of hashing pointers.  */
end_comment

begin_decl_stmt
name|htab_hash
name|htab_hash_pointer
init|=
name|hash_pointer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|htab_eq
name|htab_eq_pointer
init|=
name|eq_pointer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of primes and multiplicative inverses.     Note that these are not minimally reduced inverses.  Unlike when generating    code to divide by a constant, we want to be able to use the same algorithm    all the time.  All of these inverses (are implied to) have bit 32 set.     For the record, here's the function that computed the table; it's a     vastly simplified version of the function of the same name from gcc.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|unsigned int ceil_log2 (unsigned int x) {   int i;   for (i = 31; i>= 0 ; --i)     if (x> (1u<< i))       return i+1;   abort (); }  unsigned int choose_multiplier (unsigned int d, unsigned int *mlp, unsigned char *shiftp) {   unsigned long long mhigh;   double nx;   int lgup, post_shift;   int pow, pow2;   int n = 32, precision = 32;    lgup = ceil_log2 (d);   pow = n + lgup;   pow2 = n + lgup - precision;    nx = ldexp (1.0, pow) + ldexp (1.0, pow2);   mhigh = nx / d;    *shiftp = lgup - 1;   *mlp = mhigh;   return mhigh>> 32; }
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|prime_ent
block|{
name|hashval_t
name|prime
decl_stmt|;
name|hashval_t
name|inv
decl_stmt|;
name|hashval_t
name|inv_m2
decl_stmt|;
comment|/* inverse of prime-2 */
name|hashval_t
name|shift
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|prime_ent
specifier|const
name|prime_tab
index|[]
init|=
block|{
block|{
literal|7
block|,
literal|0x24924925
block|,
literal|0x9999999b
block|,
literal|2
block|}
block|,
block|{
literal|13
block|,
literal|0x3b13b13c
block|,
literal|0x745d1747
block|,
literal|3
block|}
block|,
block|{
literal|31
block|,
literal|0x08421085
block|,
literal|0x1a7b9612
block|,
literal|4
block|}
block|,
block|{
literal|61
block|,
literal|0x0c9714fc
block|,
literal|0x15b1e5f8
block|,
literal|5
block|}
block|,
block|{
literal|127
block|,
literal|0x02040811
block|,
literal|0x0624dd30
block|,
literal|6
block|}
block|,
block|{
literal|251
block|,
literal|0x05197f7e
block|,
literal|0x073260a5
block|,
literal|7
block|}
block|,
block|{
literal|509
block|,
literal|0x01824366
block|,
literal|0x02864fc8
block|,
literal|8
block|}
block|,
block|{
literal|1021
block|,
literal|0x00c0906d
block|,
literal|0x014191f7
block|,
literal|9
block|}
block|,
block|{
literal|2039
block|,
literal|0x0121456f
block|,
literal|0x0161e69e
block|,
literal|10
block|}
block|,
block|{
literal|4093
block|,
literal|0x00300902
block|,
literal|0x00501908
block|,
literal|11
block|}
block|,
block|{
literal|8191
block|,
literal|0x00080041
block|,
literal|0x00180241
block|,
literal|12
block|}
block|,
block|{
literal|16381
block|,
literal|0x000c0091
block|,
literal|0x00140191
block|,
literal|13
block|}
block|,
block|{
literal|32749
block|,
literal|0x002605a5
block|,
literal|0x002a06e6
block|,
literal|14
block|}
block|,
block|{
literal|65521
block|,
literal|0x000f00e2
block|,
literal|0x00110122
block|,
literal|15
block|}
block|,
block|{
literal|131071
block|,
literal|0x00008001
block|,
literal|0x00018003
block|,
literal|16
block|}
block|,
block|{
literal|262139
block|,
literal|0x00014002
block|,
literal|0x0001c004
block|,
literal|17
block|}
block|,
block|{
literal|524287
block|,
literal|0x00002001
block|,
literal|0x00006001
block|,
literal|18
block|}
block|,
block|{
literal|1048573
block|,
literal|0x00003001
block|,
literal|0x00005001
block|,
literal|19
block|}
block|,
block|{
literal|2097143
block|,
literal|0x00004801
block|,
literal|0x00005801
block|,
literal|20
block|}
block|,
block|{
literal|4194301
block|,
literal|0x00000c01
block|,
literal|0x00001401
block|,
literal|21
block|}
block|,
block|{
literal|8388593
block|,
literal|0x00001e01
block|,
literal|0x00002201
block|,
literal|22
block|}
block|,
block|{
literal|16777213
block|,
literal|0x00000301
block|,
literal|0x00000501
block|,
literal|23
block|}
block|,
block|{
literal|33554393
block|,
literal|0x00001381
block|,
literal|0x00001481
block|,
literal|24
block|}
block|,
block|{
literal|67108859
block|,
literal|0x00000141
block|,
literal|0x000001c1
block|,
literal|25
block|}
block|,
block|{
literal|134217689
block|,
literal|0x000004e1
block|,
literal|0x00000521
block|,
literal|26
block|}
block|,
block|{
literal|268435399
block|,
literal|0x00000391
block|,
literal|0x000003b1
block|,
literal|27
block|}
block|,
block|{
literal|536870909
block|,
literal|0x00000019
block|,
literal|0x00000029
block|,
literal|28
block|}
block|,
block|{
literal|1073741789
block|,
literal|0x0000008d
block|,
literal|0x00000095
block|,
literal|29
block|}
block|,
block|{
literal|2147483647
block|,
literal|0x00000003
block|,
literal|0x00000007
block|,
literal|30
block|}
block|,
comment|/* Avoid "decimal constant so large it is unsigned" for 4294967291.  */
block|{
literal|0xfffffffb
block|,
literal|0x00000006
block|,
literal|0x00000008
block|,
literal|31
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following function returns an index into the above table of the    nearest prime number which is greater than N, and near a power of two. */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|higher_prime_index
parameter_list|(
name|unsigned
name|long
name|n
parameter_list|)
block|{
name|unsigned
name|int
name|low
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|high
init|=
sizeof|sizeof
argument_list|(
name|prime_tab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|prime_tab
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
while|while
condition|(
name|low
operator|!=
name|high
condition|)
block|{
name|unsigned
name|int
name|mid
init|=
name|low
operator|+
operator|(
name|high
operator|-
name|low
operator|)
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|prime_tab
index|[
name|mid
index|]
operator|.
name|prime
condition|)
name|low
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
name|high
operator|=
name|mid
expr_stmt|;
block|}
comment|/* If we've run out of primes, abort.  */
if|if
condition|(
name|n
operator|>
name|prime_tab
index|[
name|low
index|]
operator|.
name|prime
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot find prime bigger than %lu\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|low
return|;
block|}
end_function

begin_comment
comment|/* Returns a hash code for P.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|hash_pointer
parameter_list|(
specifier|const
name|PTR
name|p
parameter_list|)
block|{
return|return
call|(
name|hashval_t
call|)
argument_list|(
operator|(
name|long
operator|)
name|p
operator|>>
literal|3
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if P1 and P2 are equal.  */
end_comment

begin_function
specifier|static
name|int
name|eq_pointer
parameter_list|(
specifier|const
name|PTR
name|p1
parameter_list|,
specifier|const
name|PTR
name|p2
parameter_list|)
block|{
return|return
name|p1
operator|==
name|p2
return|;
block|}
end_function

begin_comment
comment|/* The parens around the function names in the next two definitions    are essential in order to prevent macro expansions of the name.    The bodies, however, are expanded as expected, so they are not    recursive definitions.  */
end_comment

begin_comment
comment|/* Return the current size of given hash table.  */
end_comment

begin_define
define|#
directive|define
name|htab_size
parameter_list|(
name|htab
parameter_list|)
value|((htab)->size)
end_define

begin_function
name|size_t
function|(
name|htab_size
function|)
parameter_list|(
name|htab_t
name|htab
parameter_list|)
block|{
return|return
name|htab_size
argument_list|(
name|htab
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the current number of elements in given hash table. */
end_comment

begin_define
define|#
directive|define
name|htab_elements
parameter_list|(
name|htab
parameter_list|)
value|((htab)->n_elements - (htab)->n_deleted)
end_define

begin_function
name|size_t
function|(
name|htab_elements
function|)
parameter_list|(
name|htab_t
name|htab
parameter_list|)
block|{
return|return
name|htab_elements
argument_list|(
name|htab
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return X % Y.  */
end_comment

begin_function
specifier|static
specifier|inline
name|hashval_t
name|htab_mod_1
parameter_list|(
name|hashval_t
name|x
parameter_list|,
name|hashval_t
name|y
parameter_list|,
name|hashval_t
name|inv
parameter_list|,
name|int
name|shift
parameter_list|)
block|{
comment|/* The multiplicative inverses computed above are for 32-bit types, and      requires that we be able to compute a highpart multiply.  */
ifdef|#
directive|ifdef
name|UNSIGNED_64BIT_TYPE
name|__extension__
typedef|typedef
name|UNSIGNED_64BIT_TYPE
name|ull
typedef|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|hashval_t
argument_list|)
operator|*
name|CHAR_BIT
operator|<=
literal|32
condition|)
block|{
name|hashval_t
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|,
name|t4
decl_stmt|,
name|q
decl_stmt|,
name|r
decl_stmt|;
name|t1
operator|=
operator|(
operator|(
name|ull
operator|)
name|x
operator|*
name|inv
operator|)
operator|>>
literal|32
expr_stmt|;
name|t2
operator|=
name|x
operator|-
name|t1
expr_stmt|;
name|t3
operator|=
name|t2
operator|>>
literal|1
expr_stmt|;
name|t4
operator|=
name|t1
operator|+
name|t3
expr_stmt|;
name|q
operator|=
name|t4
operator|>>
name|shift
expr_stmt|;
name|r
operator|=
name|x
operator|-
operator|(
name|q
operator|*
name|y
operator|)
expr_stmt|;
return|return
name|r
return|;
block|}
endif|#
directive|endif
comment|/* Otherwise just use the native division routines.  */
return|return
name|x
operator|%
name|y
return|;
block|}
end_function

begin_comment
comment|/* Compute the primary hash for HASH given HTAB's current size.  */
end_comment

begin_function
specifier|static
specifier|inline
name|hashval_t
name|htab_mod
parameter_list|(
name|hashval_t
name|hash
parameter_list|,
name|htab_t
name|htab
parameter_list|)
block|{
specifier|const
name|struct
name|prime_ent
modifier|*
name|p
init|=
operator|&
name|prime_tab
index|[
name|htab
operator|->
name|size_prime_index
index|]
decl_stmt|;
return|return
name|htab_mod_1
argument_list|(
name|hash
argument_list|,
name|p
operator|->
name|prime
argument_list|,
name|p
operator|->
name|inv
argument_list|,
name|p
operator|->
name|shift
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compute the secondary hash for HASH given HTAB's current size.  */
end_comment

begin_function
specifier|static
specifier|inline
name|hashval_t
name|htab_mod_m2
parameter_list|(
name|hashval_t
name|hash
parameter_list|,
name|htab_t
name|htab
parameter_list|)
block|{
specifier|const
name|struct
name|prime_ent
modifier|*
name|p
init|=
operator|&
name|prime_tab
index|[
name|htab
operator|->
name|size_prime_index
index|]
decl_stmt|;
return|return
literal|1
operator|+
name|htab_mod_1
argument_list|(
name|hash
argument_list|,
name|p
operator|->
name|prime
operator|-
literal|2
argument_list|,
name|p
operator|->
name|inv_m2
argument_list|,
name|p
operator|->
name|shift
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This function creates table with length slightly longer than given    source length.  Created hash table is initiated as empty (all the    hash table entries are HTAB_EMPTY_ENTRY).  The function returns the    created hash table, or NULL if memory allocation fails.  */
end_comment

begin_function
name|htab_t
name|htab_create_alloc
parameter_list|(
name|size_t
name|size
parameter_list|,
name|htab_hash
name|hash_f
parameter_list|,
name|htab_eq
name|eq_f
parameter_list|,
name|htab_del
name|del_f
parameter_list|,
name|htab_alloc
name|alloc_f
parameter_list|,
name|htab_free
name|free_f
parameter_list|)
block|{
name|htab_t
name|result
decl_stmt|;
name|unsigned
name|int
name|size_prime_index
decl_stmt|;
name|size_prime_index
operator|=
name|higher_prime_index
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
name|prime_tab
index|[
name|size_prime_index
index|]
operator|.
name|prime
expr_stmt|;
name|result
operator|=
call|(
name|htab_t
call|)
argument_list|(
operator|*
name|alloc_f
argument_list|)
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|htab
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|result
operator|->
name|entries
operator|=
operator|(
name|PTR
operator|*
operator|)
call|(
modifier|*
name|alloc_f
call|)
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|PTR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|entries
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|free_f
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|free_f
call|)
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|result
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|result
operator|->
name|size_prime_index
operator|=
name|size_prime_index
expr_stmt|;
name|result
operator|->
name|hash_f
operator|=
name|hash_f
expr_stmt|;
name|result
operator|->
name|eq_f
operator|=
name|eq_f
expr_stmt|;
name|result
operator|->
name|del_f
operator|=
name|del_f
expr_stmt|;
name|result
operator|->
name|alloc_f
operator|=
name|alloc_f
expr_stmt|;
name|result
operator|->
name|free_f
operator|=
name|free_f
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* As above, but use the variants of alloc_f and free_f which accept    an extra argument.  */
end_comment

begin_function
name|htab_t
name|htab_create_alloc_ex
parameter_list|(
name|size_t
name|size
parameter_list|,
name|htab_hash
name|hash_f
parameter_list|,
name|htab_eq
name|eq_f
parameter_list|,
name|htab_del
name|del_f
parameter_list|,
name|void
modifier|*
name|alloc_arg
parameter_list|,
name|htab_alloc_with_arg
name|alloc_f
parameter_list|,
name|htab_free_with_arg
name|free_f
parameter_list|)
block|{
name|htab_t
name|result
decl_stmt|;
name|unsigned
name|int
name|size_prime_index
decl_stmt|;
name|size_prime_index
operator|=
name|higher_prime_index
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
name|prime_tab
index|[
name|size_prime_index
index|]
operator|.
name|prime
expr_stmt|;
name|result
operator|=
call|(
name|htab_t
call|)
argument_list|(
operator|*
name|alloc_f
argument_list|)
argument_list|(
name|alloc_arg
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|htab
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|result
operator|->
name|entries
operator|=
operator|(
name|PTR
operator|*
operator|)
call|(
modifier|*
name|alloc_f
call|)
argument_list|(
name|alloc_arg
argument_list|,
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|PTR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|entries
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|free_f
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|free_f
call|)
argument_list|(
name|alloc_arg
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|result
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|result
operator|->
name|size_prime_index
operator|=
name|size_prime_index
expr_stmt|;
name|result
operator|->
name|hash_f
operator|=
name|hash_f
expr_stmt|;
name|result
operator|->
name|eq_f
operator|=
name|eq_f
expr_stmt|;
name|result
operator|->
name|del_f
operator|=
name|del_f
expr_stmt|;
name|result
operator|->
name|alloc_arg
operator|=
name|alloc_arg
expr_stmt|;
name|result
operator|->
name|alloc_with_arg_f
operator|=
name|alloc_f
expr_stmt|;
name|result
operator|->
name|free_with_arg_f
operator|=
name|free_f
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Update the function pointers and allocation parameter in the htab_t.  */
end_comment

begin_function
name|void
name|htab_set_functions_ex
parameter_list|(
name|htab_t
name|htab
parameter_list|,
name|htab_hash
name|hash_f
parameter_list|,
name|htab_eq
name|eq_f
parameter_list|,
name|htab_del
name|del_f
parameter_list|,
name|PTR
name|alloc_arg
parameter_list|,
name|htab_alloc_with_arg
name|alloc_f
parameter_list|,
name|htab_free_with_arg
name|free_f
parameter_list|)
block|{
name|htab
operator|->
name|hash_f
operator|=
name|hash_f
expr_stmt|;
name|htab
operator|->
name|eq_f
operator|=
name|eq_f
expr_stmt|;
name|htab
operator|->
name|del_f
operator|=
name|del_f
expr_stmt|;
name|htab
operator|->
name|alloc_arg
operator|=
name|alloc_arg
expr_stmt|;
name|htab
operator|->
name|alloc_with_arg_f
operator|=
name|alloc_f
expr_stmt|;
name|htab
operator|->
name|free_with_arg_f
operator|=
name|free_f
expr_stmt|;
block|}
end_function

begin_comment
comment|/* These functions exist solely for backward compatibility.  */
end_comment

begin_undef
undef|#
directive|undef
name|htab_create
end_undef

begin_function
name|htab_t
name|htab_create
parameter_list|(
name|size_t
name|size
parameter_list|,
name|htab_hash
name|hash_f
parameter_list|,
name|htab_eq
name|eq_f
parameter_list|,
name|htab_del
name|del_f
parameter_list|)
block|{
return|return
name|htab_create_alloc
argument_list|(
name|size
argument_list|,
name|hash_f
argument_list|,
name|eq_f
argument_list|,
name|del_f
argument_list|,
name|xcalloc
argument_list|,
name|free
argument_list|)
return|;
block|}
end_function

begin_function
name|htab_t
name|htab_try_create
parameter_list|(
name|size_t
name|size
parameter_list|,
name|htab_hash
name|hash_f
parameter_list|,
name|htab_eq
name|eq_f
parameter_list|,
name|htab_del
name|del_f
parameter_list|)
block|{
return|return
name|htab_create_alloc
argument_list|(
name|size
argument_list|,
name|hash_f
argument_list|,
name|eq_f
argument_list|,
name|del_f
argument_list|,
name|calloc
argument_list|,
name|free
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This function frees all memory allocated for given hash table.    Naturally the hash table must already exist. */
end_comment

begin_function
name|void
name|htab_delete
parameter_list|(
name|htab_t
name|htab
parameter_list|)
block|{
name|size_t
name|size
init|=
name|htab_size
argument_list|(
name|htab
argument_list|)
decl_stmt|;
name|PTR
modifier|*
name|entries
init|=
name|htab
operator|->
name|entries
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|htab
operator|->
name|del_f
condition|)
for|for
control|(
name|i
operator|=
name|size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|entries
index|[
name|i
index|]
operator|!=
name|HTAB_EMPTY_ENTRY
operator|&&
name|entries
index|[
name|i
index|]
operator|!=
name|HTAB_DELETED_ENTRY
condition|)
call|(
modifier|*
name|htab
operator|->
name|del_f
call|)
argument_list|(
name|entries
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|free_f
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|htab
operator|->
name|free_f
call|)
argument_list|(
name|entries
argument_list|)
expr_stmt|;
call|(
modifier|*
name|htab
operator|->
name|free_f
call|)
argument_list|(
name|htab
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|htab
operator|->
name|free_with_arg_f
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|htab
operator|->
name|free_with_arg_f
call|)
argument_list|(
name|htab
operator|->
name|alloc_arg
argument_list|,
name|entries
argument_list|)
expr_stmt|;
call|(
modifier|*
name|htab
operator|->
name|free_with_arg_f
call|)
argument_list|(
name|htab
operator|->
name|alloc_arg
argument_list|,
name|htab
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function clears all entries in the given hash table.  */
end_comment

begin_function
name|void
name|htab_empty
parameter_list|(
name|htab_t
name|htab
parameter_list|)
block|{
name|size_t
name|size
init|=
name|htab_size
argument_list|(
name|htab
argument_list|)
decl_stmt|;
name|PTR
modifier|*
name|entries
init|=
name|htab
operator|->
name|entries
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|htab
operator|->
name|del_f
condition|)
for|for
control|(
name|i
operator|=
name|size
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|entries
index|[
name|i
index|]
operator|!=
name|HTAB_EMPTY_ENTRY
operator|&&
name|entries
index|[
name|i
index|]
operator|!=
name|HTAB_DELETED_ENTRY
condition|)
call|(
modifier|*
name|htab
operator|->
name|del_f
call|)
argument_list|(
name|entries
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Instead of clearing megabyte, downsize the table.  */
if|if
condition|(
name|size
operator|>
literal|1024
operator|*
literal|1024
operator|/
sizeof|sizeof
argument_list|(
name|PTR
argument_list|)
condition|)
block|{
name|int
name|nindex
init|=
name|higher_prime_index
argument_list|(
literal|1024
operator|/
sizeof|sizeof
argument_list|(
name|PTR
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|nsize
init|=
name|prime_tab
index|[
name|nindex
index|]
operator|.
name|prime
decl_stmt|;
if|if
condition|(
name|htab
operator|->
name|free_f
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|htab
operator|->
name|free_f
call|)
argument_list|(
name|htab
operator|->
name|entries
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|htab
operator|->
name|free_with_arg_f
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|htab
operator|->
name|free_with_arg_f
call|)
argument_list|(
name|htab
operator|->
name|alloc_arg
argument_list|,
name|htab
operator|->
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|alloc_with_arg_f
operator|!=
name|NULL
condition|)
name|htab
operator|->
name|entries
operator|=
operator|(
name|PTR
operator|*
operator|)
call|(
modifier|*
name|htab
operator|->
name|alloc_with_arg_f
call|)
argument_list|(
name|htab
operator|->
name|alloc_arg
argument_list|,
name|nsize
argument_list|,
sizeof|sizeof
argument_list|(
name|PTR
operator|*
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|htab
operator|->
name|entries
operator|=
operator|(
name|PTR
operator|*
operator|)
call|(
modifier|*
name|htab
operator|->
name|alloc_f
call|)
argument_list|(
name|nsize
argument_list|,
sizeof|sizeof
argument_list|(
name|PTR
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|htab
operator|->
name|size
operator|=
name|nsize
expr_stmt|;
name|htab
operator|->
name|size_prime_index
operator|=
name|nindex
expr_stmt|;
block|}
else|else
name|memset
argument_list|(
name|entries
argument_list|,
literal|0
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|PTR
argument_list|)
argument_list|)
expr_stmt|;
name|htab
operator|->
name|n_deleted
operator|=
literal|0
expr_stmt|;
name|htab
operator|->
name|n_elements
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar to htab_find_slot, but without several unwanted side effects:     - Does not call htab->eq_f when it finds an existing entry.     - Does not change the count of elements/searches/collisions in the       hash table.    This function also assumes there are no deleted entries in the table.    HASH is the hash value for the element to be inserted.  */
end_comment

begin_function
specifier|static
name|PTR
modifier|*
name|find_empty_slot_for_expand
parameter_list|(
name|htab_t
name|htab
parameter_list|,
name|hashval_t
name|hash
parameter_list|)
block|{
name|hashval_t
name|index
init|=
name|htab_mod
argument_list|(
name|hash
argument_list|,
name|htab
argument_list|)
decl_stmt|;
name|size_t
name|size
init|=
name|htab_size
argument_list|(
name|htab
argument_list|)
decl_stmt|;
name|PTR
modifier|*
name|slot
init|=
name|htab
operator|->
name|entries
operator|+
name|index
decl_stmt|;
name|hashval_t
name|hash2
decl_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
name|HTAB_EMPTY_ENTRY
condition|)
return|return
name|slot
return|;
elseif|else
if|if
condition|(
operator|*
name|slot
operator|==
name|HTAB_DELETED_ENTRY
condition|)
name|abort
argument_list|()
expr_stmt|;
name|hash2
operator|=
name|htab_mod_m2
argument_list|(
name|hash
argument_list|,
name|htab
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|index
operator|+=
name|hash2
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|size
condition|)
name|index
operator|-=
name|size
expr_stmt|;
name|slot
operator|=
name|htab
operator|->
name|entries
operator|+
name|index
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
name|HTAB_EMPTY_ENTRY
condition|)
return|return
name|slot
return|;
elseif|else
if|if
condition|(
operator|*
name|slot
operator|==
name|HTAB_DELETED_ENTRY
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The following function changes size of memory allocated for the    entries and repeatedly inserts the table elements.  The occupancy    of the table after the call will be about 50%.  Naturally the hash    table must already exist.  Remember also that the place of the    table entries is changed.  If memory allocation failures are allowed,    this function will return zero, indicating that the table could not be    expanded.  If all goes well, it will return a non-zero value.  */
end_comment

begin_function
specifier|static
name|int
name|htab_expand
parameter_list|(
name|htab_t
name|htab
parameter_list|)
block|{
name|PTR
modifier|*
name|oentries
decl_stmt|;
name|PTR
modifier|*
name|olimit
decl_stmt|;
name|PTR
modifier|*
name|p
decl_stmt|;
name|PTR
modifier|*
name|nentries
decl_stmt|;
name|size_t
name|nsize
decl_stmt|,
name|osize
decl_stmt|,
name|elts
decl_stmt|;
name|unsigned
name|int
name|oindex
decl_stmt|,
name|nindex
decl_stmt|;
name|oentries
operator|=
name|htab
operator|->
name|entries
expr_stmt|;
name|oindex
operator|=
name|htab
operator|->
name|size_prime_index
expr_stmt|;
name|osize
operator|=
name|htab
operator|->
name|size
expr_stmt|;
name|olimit
operator|=
name|oentries
operator|+
name|osize
expr_stmt|;
name|elts
operator|=
name|htab_elements
argument_list|(
name|htab
argument_list|)
expr_stmt|;
comment|/* Resize only when table after removal of unused elements is either      too full or too empty.  */
if|if
condition|(
name|elts
operator|*
literal|2
operator|>
name|osize
operator|||
operator|(
name|elts
operator|*
literal|8
operator|<
name|osize
operator|&&
name|osize
operator|>
literal|32
operator|)
condition|)
block|{
name|nindex
operator|=
name|higher_prime_index
argument_list|(
name|elts
operator|*
literal|2
argument_list|)
expr_stmt|;
name|nsize
operator|=
name|prime_tab
index|[
name|nindex
index|]
operator|.
name|prime
expr_stmt|;
block|}
else|else
block|{
name|nindex
operator|=
name|oindex
expr_stmt|;
name|nsize
operator|=
name|osize
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|alloc_with_arg_f
operator|!=
name|NULL
condition|)
name|nentries
operator|=
operator|(
name|PTR
operator|*
operator|)
call|(
modifier|*
name|htab
operator|->
name|alloc_with_arg_f
call|)
argument_list|(
name|htab
operator|->
name|alloc_arg
argument_list|,
name|nsize
argument_list|,
sizeof|sizeof
argument_list|(
name|PTR
operator|*
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|nentries
operator|=
operator|(
name|PTR
operator|*
operator|)
call|(
modifier|*
name|htab
operator|->
name|alloc_f
call|)
argument_list|(
name|nsize
argument_list|,
sizeof|sizeof
argument_list|(
name|PTR
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nentries
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|htab
operator|->
name|entries
operator|=
name|nentries
expr_stmt|;
name|htab
operator|->
name|size
operator|=
name|nsize
expr_stmt|;
name|htab
operator|->
name|size_prime_index
operator|=
name|nindex
expr_stmt|;
name|htab
operator|->
name|n_elements
operator|-=
name|htab
operator|->
name|n_deleted
expr_stmt|;
name|htab
operator|->
name|n_deleted
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|oentries
expr_stmt|;
do|do
block|{
name|PTR
name|x
init|=
operator|*
name|p
decl_stmt|;
if|if
condition|(
name|x
operator|!=
name|HTAB_EMPTY_ENTRY
operator|&&
name|x
operator|!=
name|HTAB_DELETED_ENTRY
condition|)
block|{
name|PTR
modifier|*
name|q
init|=
name|find_empty_slot_for_expand
argument_list|(
name|htab
argument_list|,
call|(
modifier|*
name|htab
operator|->
name|hash_f
call|)
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|q
operator|=
name|x
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|<
name|olimit
condition|)
do|;
if|if
condition|(
name|htab
operator|->
name|free_f
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|htab
operator|->
name|free_f
call|)
argument_list|(
name|oentries
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|htab
operator|->
name|free_with_arg_f
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|htab
operator|->
name|free_with_arg_f
call|)
argument_list|(
name|htab
operator|->
name|alloc_arg
argument_list|,
name|oentries
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This function searches for a hash table entry equal to the given    element.  It cannot be used to insert or delete an element.  */
end_comment

begin_function
name|PTR
name|htab_find_with_hash
parameter_list|(
name|htab_t
name|htab
parameter_list|,
specifier|const
name|PTR
name|element
parameter_list|,
name|hashval_t
name|hash
parameter_list|)
block|{
name|hashval_t
name|index
decl_stmt|,
name|hash2
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|PTR
name|entry
decl_stmt|;
name|htab
operator|->
name|searches
operator|++
expr_stmt|;
name|size
operator|=
name|htab_size
argument_list|(
name|htab
argument_list|)
expr_stmt|;
name|index
operator|=
name|htab_mod
argument_list|(
name|hash
argument_list|,
name|htab
argument_list|)
expr_stmt|;
name|entry
operator|=
name|htab
operator|->
name|entries
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|HTAB_EMPTY_ENTRY
operator|||
operator|(
name|entry
operator|!=
name|HTAB_DELETED_ENTRY
operator|&&
call|(
modifier|*
name|htab
operator|->
name|eq_f
call|)
argument_list|(
name|entry
argument_list|,
name|element
argument_list|)
operator|)
condition|)
return|return
name|entry
return|;
name|hash2
operator|=
name|htab_mod_m2
argument_list|(
name|hash
argument_list|,
name|htab
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|htab
operator|->
name|collisions
operator|++
expr_stmt|;
name|index
operator|+=
name|hash2
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|size
condition|)
name|index
operator|-=
name|size
expr_stmt|;
name|entry
operator|=
name|htab
operator|->
name|entries
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|HTAB_EMPTY_ENTRY
operator|||
operator|(
name|entry
operator|!=
name|HTAB_DELETED_ENTRY
operator|&&
call|(
modifier|*
name|htab
operator|->
name|eq_f
call|)
argument_list|(
name|entry
argument_list|,
name|element
argument_list|)
operator|)
condition|)
return|return
name|entry
return|;
block|}
block|}
end_function

begin_comment
comment|/* Like htab_find_slot_with_hash, but compute the hash value from the    element.  */
end_comment

begin_function
name|PTR
name|htab_find
parameter_list|(
name|htab_t
name|htab
parameter_list|,
specifier|const
name|PTR
name|element
parameter_list|)
block|{
return|return
name|htab_find_with_hash
argument_list|(
name|htab
argument_list|,
name|element
argument_list|,
call|(
modifier|*
name|htab
operator|->
name|hash_f
call|)
argument_list|(
name|element
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This function searches for a hash table slot containing an entry    equal to the given element.  To delete an entry, call this with    insert=NO_INSERT, then call htab_clear_slot on the slot returned    (possibly after doing some checks).  To insert an entry, call this    with insert=INSERT, then write the value you want into the returned    slot.  When inserting an entry, NULL may be returned if memory    allocation fails.  */
end_comment

begin_function
name|PTR
modifier|*
name|htab_find_slot_with_hash
parameter_list|(
name|htab_t
name|htab
parameter_list|,
specifier|const
name|PTR
name|element
parameter_list|,
name|hashval_t
name|hash
parameter_list|,
name|enum
name|insert_option
name|insert
parameter_list|)
block|{
name|PTR
modifier|*
name|first_deleted_slot
decl_stmt|;
name|hashval_t
name|index
decl_stmt|,
name|hash2
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|PTR
name|entry
decl_stmt|;
name|size
operator|=
name|htab_size
argument_list|(
name|htab
argument_list|)
expr_stmt|;
if|if
condition|(
name|insert
operator|==
name|INSERT
operator|&&
name|size
operator|*
literal|3
operator|<=
name|htab
operator|->
name|n_elements
operator|*
literal|4
condition|)
block|{
if|if
condition|(
name|htab_expand
argument_list|(
name|htab
argument_list|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|size
operator|=
name|htab_size
argument_list|(
name|htab
argument_list|)
expr_stmt|;
block|}
name|index
operator|=
name|htab_mod
argument_list|(
name|hash
argument_list|,
name|htab
argument_list|)
expr_stmt|;
name|htab
operator|->
name|searches
operator|++
expr_stmt|;
name|first_deleted_slot
operator|=
name|NULL
expr_stmt|;
name|entry
operator|=
name|htab
operator|->
name|entries
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|HTAB_EMPTY_ENTRY
condition|)
goto|goto
name|empty_entry
goto|;
elseif|else
if|if
condition|(
name|entry
operator|==
name|HTAB_DELETED_ENTRY
condition|)
name|first_deleted_slot
operator|=
operator|&
name|htab
operator|->
name|entries
index|[
name|index
index|]
expr_stmt|;
elseif|else
if|if
condition|(
call|(
modifier|*
name|htab
operator|->
name|eq_f
call|)
argument_list|(
name|entry
argument_list|,
name|element
argument_list|)
condition|)
return|return
operator|&
name|htab
operator|->
name|entries
index|[
name|index
index|]
return|;
name|hash2
operator|=
name|htab_mod_m2
argument_list|(
name|hash
argument_list|,
name|htab
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|htab
operator|->
name|collisions
operator|++
expr_stmt|;
name|index
operator|+=
name|hash2
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|size
condition|)
name|index
operator|-=
name|size
expr_stmt|;
name|entry
operator|=
name|htab
operator|->
name|entries
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|HTAB_EMPTY_ENTRY
condition|)
goto|goto
name|empty_entry
goto|;
elseif|else
if|if
condition|(
name|entry
operator|==
name|HTAB_DELETED_ENTRY
condition|)
block|{
if|if
condition|(
operator|!
name|first_deleted_slot
condition|)
name|first_deleted_slot
operator|=
operator|&
name|htab
operator|->
name|entries
index|[
name|index
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
call|(
modifier|*
name|htab
operator|->
name|eq_f
call|)
argument_list|(
name|entry
argument_list|,
name|element
argument_list|)
condition|)
return|return
operator|&
name|htab
operator|->
name|entries
index|[
name|index
index|]
return|;
block|}
name|empty_entry
label|:
if|if
condition|(
name|insert
operator|==
name|NO_INSERT
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|first_deleted_slot
condition|)
block|{
name|htab
operator|->
name|n_deleted
operator|--
expr_stmt|;
operator|*
name|first_deleted_slot
operator|=
name|HTAB_EMPTY_ENTRY
expr_stmt|;
return|return
name|first_deleted_slot
return|;
block|}
name|htab
operator|->
name|n_elements
operator|++
expr_stmt|;
return|return
operator|&
name|htab
operator|->
name|entries
index|[
name|index
index|]
return|;
block|}
end_function

begin_comment
comment|/* Like htab_find_slot_with_hash, but compute the hash value from the    element.  */
end_comment

begin_function
name|PTR
modifier|*
name|htab_find_slot
parameter_list|(
name|htab_t
name|htab
parameter_list|,
specifier|const
name|PTR
name|element
parameter_list|,
name|enum
name|insert_option
name|insert
parameter_list|)
block|{
return|return
name|htab_find_slot_with_hash
argument_list|(
name|htab
argument_list|,
name|element
argument_list|,
call|(
modifier|*
name|htab
operator|->
name|hash_f
call|)
argument_list|(
name|element
argument_list|)
argument_list|,
name|insert
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This function deletes an element with the given value from hash    table (the hash is computed from the element).  If there is no matching    element in the hash table, this function does nothing.  */
end_comment

begin_function
name|void
name|htab_remove_elt
parameter_list|(
name|htab_t
name|htab
parameter_list|,
name|PTR
name|element
parameter_list|)
block|{
name|htab_remove_elt_with_hash
argument_list|(
name|htab
argument_list|,
name|element
argument_list|,
call|(
modifier|*
name|htab
operator|->
name|hash_f
call|)
argument_list|(
name|element
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function deletes an element with the given value from hash    table.  If there is no matching element in the hash table, this    function does nothing.  */
end_comment

begin_function
name|void
name|htab_remove_elt_with_hash
parameter_list|(
name|htab_t
name|htab
parameter_list|,
name|PTR
name|element
parameter_list|,
name|hashval_t
name|hash
parameter_list|)
block|{
name|PTR
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|htab
argument_list|,
name|element
argument_list|,
name|hash
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
name|HTAB_EMPTY_ENTRY
condition|)
return|return;
if|if
condition|(
name|htab
operator|->
name|del_f
condition|)
call|(
modifier|*
name|htab
operator|->
name|del_f
call|)
argument_list|(
operator|*
name|slot
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|HTAB_DELETED_ENTRY
expr_stmt|;
name|htab
operator|->
name|n_deleted
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function clears a specified slot in a hash table.  It is    useful when you've already done the lookup and don't want to do it    again.  */
end_comment

begin_function
name|void
name|htab_clear_slot
parameter_list|(
name|htab_t
name|htab
parameter_list|,
name|PTR
modifier|*
name|slot
parameter_list|)
block|{
if|if
condition|(
name|slot
operator|<
name|htab
operator|->
name|entries
operator|||
name|slot
operator|>=
name|htab
operator|->
name|entries
operator|+
name|htab_size
argument_list|(
name|htab
argument_list|)
operator|||
operator|*
name|slot
operator|==
name|HTAB_EMPTY_ENTRY
operator|||
operator|*
name|slot
operator|==
name|HTAB_DELETED_ENTRY
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|del_f
condition|)
call|(
modifier|*
name|htab
operator|->
name|del_f
call|)
argument_list|(
operator|*
name|slot
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|HTAB_DELETED_ENTRY
expr_stmt|;
name|htab
operator|->
name|n_deleted
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function scans over the entire hash table calling    CALLBACK for each live entry.  If CALLBACK returns false,    the iteration stops.  INFO is passed as CALLBACK's second    argument.  */
end_comment

begin_function
name|void
name|htab_traverse_noresize
parameter_list|(
name|htab_t
name|htab
parameter_list|,
name|htab_trav
name|callback
parameter_list|,
name|PTR
name|info
parameter_list|)
block|{
name|PTR
modifier|*
name|slot
decl_stmt|;
name|PTR
modifier|*
name|limit
decl_stmt|;
name|slot
operator|=
name|htab
operator|->
name|entries
expr_stmt|;
name|limit
operator|=
name|slot
operator|+
name|htab_size
argument_list|(
name|htab
argument_list|)
expr_stmt|;
do|do
block|{
name|PTR
name|x
init|=
operator|*
name|slot
decl_stmt|;
if|if
condition|(
name|x
operator|!=
name|HTAB_EMPTY_ENTRY
operator|&&
name|x
operator|!=
name|HTAB_DELETED_ENTRY
condition|)
if|if
condition|(
operator|!
call|(
modifier|*
name|callback
call|)
argument_list|(
name|slot
argument_list|,
name|info
argument_list|)
condition|)
break|break;
block|}
do|while
condition|(
operator|++
name|slot
operator|<
name|limit
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Like htab_traverse_noresize, but does resize the table when it is    too empty to improve effectivity of subsequent calls.  */
end_comment

begin_function
name|void
name|htab_traverse
parameter_list|(
name|htab_t
name|htab
parameter_list|,
name|htab_trav
name|callback
parameter_list|,
name|PTR
name|info
parameter_list|)
block|{
if|if
condition|(
name|htab_elements
argument_list|(
name|htab
argument_list|)
operator|*
literal|8
operator|<
name|htab_size
argument_list|(
name|htab
argument_list|)
condition|)
name|htab_expand
argument_list|(
name|htab
argument_list|)
expr_stmt|;
name|htab_traverse_noresize
argument_list|(
name|htab
argument_list|,
name|callback
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the fraction of fixed collisions during all work with given    hash table. */
end_comment

begin_function
name|double
name|htab_collisions
parameter_list|(
name|htab_t
name|htab
parameter_list|)
block|{
if|if
condition|(
name|htab
operator|->
name|searches
operator|==
literal|0
condition|)
return|return
literal|0.0
return|;
return|return
operator|(
name|double
operator|)
name|htab
operator|->
name|collisions
operator|/
operator|(
name|double
operator|)
name|htab
operator|->
name|searches
return|;
block|}
end_function

begin_comment
comment|/* Hash P as a null-terminated string.     Copied from gcc/hashtable.c.  Zack had the following to say with respect    to applicability, though note that unlike hashtable.c, this hash table    implementation re-hashes rather than chain buckets.     http://gcc.gnu.org/ml/gcc-patches/2001-08/msg01021.html    From: Zack Weinberg<zackw@panix.com>    Date: Fri, 17 Aug 2001 02:15:56 -0400     I got it by extracting all the identifiers from all the source code    I had lying around in mid-1999, and testing many recurrences of    the form "H_n = H_{n-1} * K + c_n * L + M" where K, L, M were either    prime numbers or the appropriate identity.  This was the best one.    I don't remember exactly what constituted "best", except I was    looking at bucket-length distributions mostly.        So it should be very good at hashing identifiers, but might not be    as good at arbitrary strings.        I'll add that it thoroughly trounces the hash functions recommended    for this use at http://burtleburtle.net/bob/hash/index.html, both    on speed and bucket distribution.  I haven't tried it against the    function they just started using for Perl's hashes.  */
end_comment

begin_function
name|hashval_t
name|htab_hash_string
parameter_list|(
specifier|const
name|PTR
name|p
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|str
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p
decl_stmt|;
name|hashval_t
name|r
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|str
operator|++
operator|)
operator|!=
literal|0
condition|)
name|r
operator|=
name|r
operator|*
literal|67
operator|+
name|c
operator|-
literal|113
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* DERIVED FROM: -------------------------------------------------------------------- lookup2.c, by Bob Jenkins, December 1996, Public Domain. hash(), hash2(), hash3, and mix() are externally useful functions. Routines to test the hash are included if SELF_TEST is defined. You can use this free for any purpose.  It has no warranty. -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* -------------------------------------------------------------------- mix -- mix 3 32-bit values reversibly. For every delta with one or two bit set, and the deltas of all three   high bits or all three low bits, whether the original value of a,b,c   is almost all zero or is uniformly distributed, * If mix() is run forward or backward, at least 32 bits in a,b,c   have at least 1/4 probability of changing. * If mix() is run forward, every bit of c will change between 1/3 and   2/3 of the time.  (Well, 22/100 and 78/100 for some 2-bit deltas.) mix() was built out of 36 single-cycle latency instructions in a    structure that could supported 2x parallelism, like so:       a -= b;        a -= c; x = (c>>13);       b -= c; a ^= x;       b -= a; x = (a<<8);       c -= a; b ^= x;       c -= b; x = (b>>13);       ...   Unfortunately, superscalar Pentiums and Sparcs can't take advantage    of that parallelism.  They've also turned some of those single-cycle   latency instructions into multi-cycle latency instructions.  Still,   this is the fastest good hash I could find.  There were about 2^^68   to choose from.  I only looked at a billion or so. -------------------------------------------------------------------- */
end_comment

begin_comment
comment|/* same, but slower, works on systems that might have 8 byte hashval_t's */
end_comment

begin_define
define|#
directive|define
name|mix
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
define|\
value|{ \   a -= b; a -= c; a ^= (c>>13); \   b -= c; b -= a; b ^= (a<< 8); \   c -= a; c -= b; c ^= ((b&0xffffffff)>>13); \   a -= b; a -= c; a ^= ((c&0xffffffff)>>12); \   b -= c; b -= a; b = (b ^ (a<<16))& 0xffffffff; \   c -= a; c -= b; c = (c ^ (b>> 5))& 0xffffffff; \   a -= b; a -= c; a = (a ^ (c>> 3))& 0xffffffff; \   b -= c; b -= a; b = (b ^ (a<<10))& 0xffffffff; \   c -= a; c -= b; c = (c ^ (b>>15))& 0xffffffff; \ }
end_define

begin_comment
comment|/* -------------------------------------------------------------------- hash() -- hash a variable-length key into a 32-bit value   k     : the key (the unaligned variable-length array of bytes)   len   : the length of the key, counting by bytes   level : can be any 4-byte value Returns a 32-bit value.  Every bit of the key affects every bit of the return value.  Every 1-bit and 2-bit delta achieves avalanche. About 36+6len instructions.  The best hash table sizes are powers of 2.  There is no need to do mod a prime (mod is sooo slow!).  If you need less than 32 bits, use a bitmask.  For example, if you need only 10 bits, do   h = (h& hashmask(10)); In which case, the hash table should have hashsize(10) elements.  If you are hashing n strings (ub1 **)k, do it like this:   for (i=0, h=0; i<n; ++i) h = hash( k[i], len[i], h);  By Bob Jenkins, 1996.  bob_jenkins@burtleburtle.net.  You may use this code any way you wish, private, educational, or commercial.  It's free.  See http://burtleburtle.net/bob/hash/evahash.html Use for hash table lookup, or anything where one collision in 2^32 is acceptable.  Do NOT use for cryptographic purposes. -------------------------------------------------------------------- */
end_comment

begin_function
name|hashval_t
name|iterative_hash
parameter_list|(
specifier|const
name|PTR
name|k_in
comment|/* the key */
parameter_list|,
specifier|register
name|size_t
name|length
comment|/* the length of the key */
parameter_list|,
specifier|register
name|hashval_t
name|initval
comment|/* the previous hash, or                                               an arbitrary value */
parameter_list|)
block|{
specifier|register
specifier|const
name|unsigned
name|char
modifier|*
name|k
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|k_in
decl_stmt|;
specifier|register
name|hashval_t
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|len
decl_stmt|;
comment|/* Set up the internal state */
name|len
operator|=
name|length
expr_stmt|;
name|a
operator|=
name|b
operator|=
literal|0x9e3779b9
expr_stmt|;
comment|/* the golden ratio; an arbitrary value */
name|c
operator|=
name|initval
expr_stmt|;
comment|/* the previous hash value */
comment|/*---------------------------------------- handle most of the key */
ifndef|#
directive|ifndef
name|WORDS_BIGENDIAN
comment|/* On a little-endian machine, if the data is 4-byte aligned we can hash      by word for better speed.  This gives nondeterministic results on      big-endian machines.  */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|hashval_t
argument_list|)
operator|==
literal|4
operator|&&
operator|(
operator|(
operator|(
name|size_t
operator|)
name|k
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
while|while
condition|(
name|len
operator|>=
literal|12
condition|)
comment|/* aligned */
block|{
name|a
operator|+=
operator|*
operator|(
name|hashval_t
operator|*
operator|)
operator|(
name|k
operator|+
literal|0
operator|)
expr_stmt|;
name|b
operator|+=
operator|*
operator|(
name|hashval_t
operator|*
operator|)
operator|(
name|k
operator|+
literal|4
operator|)
expr_stmt|;
name|c
operator|+=
operator|*
operator|(
name|hashval_t
operator|*
operator|)
operator|(
name|k
operator|+
literal|8
operator|)
expr_stmt|;
name|mix
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|k
operator|+=
literal|12
expr_stmt|;
name|len
operator|-=
literal|12
expr_stmt|;
block|}
else|else
comment|/* unaligned */
endif|#
directive|endif
while|while
condition|(
name|len
operator|>=
literal|12
condition|)
block|{
name|a
operator|+=
operator|(
name|k
index|[
literal|0
index|]
operator|+
operator|(
operator|(
name|hashval_t
operator|)
name|k
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|hashval_t
operator|)
name|k
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|hashval_t
operator|)
name|k
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
name|b
operator|+=
operator|(
name|k
index|[
literal|4
index|]
operator|+
operator|(
operator|(
name|hashval_t
operator|)
name|k
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|hashval_t
operator|)
name|k
index|[
literal|6
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|hashval_t
operator|)
name|k
index|[
literal|7
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
name|c
operator|+=
operator|(
name|k
index|[
literal|8
index|]
operator|+
operator|(
operator|(
name|hashval_t
operator|)
name|k
index|[
literal|9
index|]
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|hashval_t
operator|)
name|k
index|[
literal|10
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|hashval_t
operator|)
name|k
index|[
literal|11
index|]
operator|<<
literal|24
operator|)
operator|)
expr_stmt|;
name|mix
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|k
operator|+=
literal|12
expr_stmt|;
name|len
operator|-=
literal|12
expr_stmt|;
block|}
comment|/*------------------------------------- handle the last 11 bytes */
name|c
operator|+=
name|length
expr_stmt|;
switch|switch
condition|(
name|len
condition|)
comment|/* all the case statements fall through */
block|{
case|case
literal|11
case|:
name|c
operator|+=
operator|(
operator|(
name|hashval_t
operator|)
name|k
index|[
literal|10
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
case|case
literal|10
case|:
name|c
operator|+=
operator|(
operator|(
name|hashval_t
operator|)
name|k
index|[
literal|9
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
case|case
literal|9
case|:
name|c
operator|+=
operator|(
operator|(
name|hashval_t
operator|)
name|k
index|[
literal|8
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* the first byte of c is reserved for the length */
case|case
literal|8
case|:
name|b
operator|+=
operator|(
operator|(
name|hashval_t
operator|)
name|k
index|[
literal|7
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
case|case
literal|7
case|:
name|b
operator|+=
operator|(
operator|(
name|hashval_t
operator|)
name|k
index|[
literal|6
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
case|case
literal|6
case|:
name|b
operator|+=
operator|(
operator|(
name|hashval_t
operator|)
name|k
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
case|case
literal|5
case|:
name|b
operator|+=
name|k
index|[
literal|4
index|]
expr_stmt|;
case|case
literal|4
case|:
name|a
operator|+=
operator|(
operator|(
name|hashval_t
operator|)
name|k
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
case|case
literal|3
case|:
name|a
operator|+=
operator|(
operator|(
name|hashval_t
operator|)
name|k
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
case|case
literal|2
case|:
name|a
operator|+=
operator|(
operator|(
name|hashval_t
operator|)
name|k
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
case|case
literal|1
case|:
name|a
operator|+=
name|k
index|[
literal|0
index|]
expr_stmt|;
comment|/* case 0: nothing left to add */
block|}
name|mix
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/*-------------------------------------------- report the result */
return|return
name|c
return|;
block|}
end_function

end_unit

