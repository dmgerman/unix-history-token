begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Extended support for using errno values.    Written by Fred Fish.  fnf@cygnus.com    This file is in the public domain.  --Per Bothner.  */
end_comment

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_ERRLIST
end_ifdef

begin_comment
comment|/* Note that errno.h (not sure what OS) or stdio.h (BSD 4.4, at least)    might declare sys_errlist in a way that the compiler might consider    incompatible with our later declaration, perhaps by using const    attributes.  So we hide the declaration in errno.h (if any) using a    macro. */
end_comment

begin_define
define|#
directive|define
name|sys_nerr
value|sys_nerr__
end_define

begin_define
define|#
directive|define
name|sys_errlist
value|sys_errlist__
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_ERRLIST
end_ifdef

begin_undef
undef|#
directive|undef
name|sys_nerr
end_undef

begin_undef
undef|#
directive|undef
name|sys_errlist
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  Routines imported from standard C runtime libraries. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|PTR
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|PTR
name|memset
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX
end_ifndef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|init_error_tables
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Translation table for errno values.  See intro(2) in most UNIX systems    Programmers Reference Manuals.     Note that this table is generally only accessed when it is used at runtime    to initialize errno name and message tables that are indexed by errno    value.     Not all of these errnos will exist on all systems.  This table is the only    thing that should have to be updated as new error numbers are introduced.    It's sort of ugly, but at least its portable. */
end_comment

begin_struct
struct|struct
name|error_info
block|{
specifier|const
name|int
name|value
decl_stmt|;
comment|/* The numeric value from<errno.h> */
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
comment|/* The equivalent symbolic value */
ifndef|#
directive|ifndef
name|HAVE_SYS_ERRLIST
specifier|const
name|char
modifier|*
specifier|const
name|msg
decl_stmt|;
comment|/* Short message about this value */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_SYS_ERRLIST
end_ifndef

begin_define
define|#
directive|define
name|ENTRY
parameter_list|(
name|value
parameter_list|,
name|name
parameter_list|,
name|msg
parameter_list|)
value|{value, name, msg}
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ENTRY
parameter_list|(
name|value
parameter_list|,
name|name
parameter_list|,
name|msg
parameter_list|)
value|{value, name}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|error_info
name|error_table
index|[]
init|=
block|{
if|#
directive|if
name|defined
argument_list|(
name|EPERM
argument_list|)
name|ENTRY
argument_list|(
name|EPERM
argument_list|,
literal|"EPERM"
argument_list|,
literal|"Not owner"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOENT
argument_list|)
name|ENTRY
argument_list|(
name|ENOENT
argument_list|,
literal|"ENOENT"
argument_list|,
literal|"No such file or directory"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ESRCH
argument_list|)
name|ENTRY
argument_list|(
name|ESRCH
argument_list|,
literal|"ESRCH"
argument_list|,
literal|"No such process"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EINTR
argument_list|)
name|ENTRY
argument_list|(
name|EINTR
argument_list|,
literal|"EINTR"
argument_list|,
literal|"Interrupted system call"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EIO
argument_list|)
name|ENTRY
argument_list|(
name|EIO
argument_list|,
literal|"EIO"
argument_list|,
literal|"I/O error"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENXIO
argument_list|)
name|ENTRY
argument_list|(
name|ENXIO
argument_list|,
literal|"ENXIO"
argument_list|,
literal|"No such device or address"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|E2BIG
argument_list|)
name|ENTRY
argument_list|(
name|E2BIG
argument_list|,
literal|"E2BIG"
argument_list|,
literal|"Arg list too long"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOEXEC
argument_list|)
name|ENTRY
argument_list|(
name|ENOEXEC
argument_list|,
literal|"ENOEXEC"
argument_list|,
literal|"Exec format error"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EBADF
argument_list|)
name|ENTRY
argument_list|(
name|EBADF
argument_list|,
literal|"EBADF"
argument_list|,
literal|"Bad file number"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ECHILD
argument_list|)
name|ENTRY
argument_list|(
name|ECHILD
argument_list|,
literal|"ECHILD"
argument_list|,
literal|"No child processes"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EWOULDBLOCK
argument_list|)
comment|/* Put before EAGAIN, sometimes aliased */
name|ENTRY
argument_list|(
name|EWOULDBLOCK
argument_list|,
literal|"EWOULDBLOCK"
argument_list|,
literal|"Operation would block"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EAGAIN
argument_list|)
name|ENTRY
argument_list|(
name|EAGAIN
argument_list|,
literal|"EAGAIN"
argument_list|,
literal|"No more processes"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOMEM
argument_list|)
name|ENTRY
argument_list|(
name|ENOMEM
argument_list|,
literal|"ENOMEM"
argument_list|,
literal|"Not enough space"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EACCES
argument_list|)
name|ENTRY
argument_list|(
name|EACCES
argument_list|,
literal|"EACCES"
argument_list|,
literal|"Permission denied"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EFAULT
argument_list|)
name|ENTRY
argument_list|(
name|EFAULT
argument_list|,
literal|"EFAULT"
argument_list|,
literal|"Bad address"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOTBLK
argument_list|)
name|ENTRY
argument_list|(
name|ENOTBLK
argument_list|,
literal|"ENOTBLK"
argument_list|,
literal|"Block device required"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EBUSY
argument_list|)
name|ENTRY
argument_list|(
name|EBUSY
argument_list|,
literal|"EBUSY"
argument_list|,
literal|"Device busy"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EEXIST
argument_list|)
name|ENTRY
argument_list|(
name|EEXIST
argument_list|,
literal|"EEXIST"
argument_list|,
literal|"File exists"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EXDEV
argument_list|)
name|ENTRY
argument_list|(
name|EXDEV
argument_list|,
literal|"EXDEV"
argument_list|,
literal|"Cross-device link"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENODEV
argument_list|)
name|ENTRY
argument_list|(
name|ENODEV
argument_list|,
literal|"ENODEV"
argument_list|,
literal|"No such device"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOTDIR
argument_list|)
name|ENTRY
argument_list|(
name|ENOTDIR
argument_list|,
literal|"ENOTDIR"
argument_list|,
literal|"Not a directory"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EISDIR
argument_list|)
name|ENTRY
argument_list|(
name|EISDIR
argument_list|,
literal|"EISDIR"
argument_list|,
literal|"Is a directory"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EINVAL
argument_list|)
name|ENTRY
argument_list|(
name|EINVAL
argument_list|,
literal|"EINVAL"
argument_list|,
literal|"Invalid argument"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENFILE
argument_list|)
name|ENTRY
argument_list|(
name|ENFILE
argument_list|,
literal|"ENFILE"
argument_list|,
literal|"File table overflow"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EMFILE
argument_list|)
name|ENTRY
argument_list|(
name|EMFILE
argument_list|,
literal|"EMFILE"
argument_list|,
literal|"Too many open files"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOTTY
argument_list|)
name|ENTRY
argument_list|(
name|ENOTTY
argument_list|,
literal|"ENOTTY"
argument_list|,
literal|"Not a typewriter"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ETXTBSY
argument_list|)
name|ENTRY
argument_list|(
name|ETXTBSY
argument_list|,
literal|"ETXTBSY"
argument_list|,
literal|"Text file busy"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EFBIG
argument_list|)
name|ENTRY
argument_list|(
name|EFBIG
argument_list|,
literal|"EFBIG"
argument_list|,
literal|"File too large"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOSPC
argument_list|)
name|ENTRY
argument_list|(
name|ENOSPC
argument_list|,
literal|"ENOSPC"
argument_list|,
literal|"No space left on device"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ESPIPE
argument_list|)
name|ENTRY
argument_list|(
name|ESPIPE
argument_list|,
literal|"ESPIPE"
argument_list|,
literal|"Illegal seek"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EROFS
argument_list|)
name|ENTRY
argument_list|(
name|EROFS
argument_list|,
literal|"EROFS"
argument_list|,
literal|"Read-only file system"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EMLINK
argument_list|)
name|ENTRY
argument_list|(
name|EMLINK
argument_list|,
literal|"EMLINK"
argument_list|,
literal|"Too many links"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EPIPE
argument_list|)
name|ENTRY
argument_list|(
name|EPIPE
argument_list|,
literal|"EPIPE"
argument_list|,
literal|"Broken pipe"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EDOM
argument_list|)
name|ENTRY
argument_list|(
name|EDOM
argument_list|,
literal|"EDOM"
argument_list|,
literal|"Math argument out of domain of func"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ERANGE
argument_list|)
name|ENTRY
argument_list|(
name|ERANGE
argument_list|,
literal|"ERANGE"
argument_list|,
literal|"Math result not representable"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOMSG
argument_list|)
name|ENTRY
argument_list|(
name|ENOMSG
argument_list|,
literal|"ENOMSG"
argument_list|,
literal|"No message of desired type"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EIDRM
argument_list|)
name|ENTRY
argument_list|(
name|EIDRM
argument_list|,
literal|"EIDRM"
argument_list|,
literal|"Identifier removed"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ECHRNG
argument_list|)
name|ENTRY
argument_list|(
name|ECHRNG
argument_list|,
literal|"ECHRNG"
argument_list|,
literal|"Channel number out of range"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EL2NSYNC
argument_list|)
name|ENTRY
argument_list|(
name|EL2NSYNC
argument_list|,
literal|"EL2NSYNC"
argument_list|,
literal|"Level 2 not synchronized"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EL3HLT
argument_list|)
name|ENTRY
argument_list|(
name|EL3HLT
argument_list|,
literal|"EL3HLT"
argument_list|,
literal|"Level 3 halted"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EL3RST
argument_list|)
name|ENTRY
argument_list|(
name|EL3RST
argument_list|,
literal|"EL3RST"
argument_list|,
literal|"Level 3 reset"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ELNRNG
argument_list|)
name|ENTRY
argument_list|(
name|ELNRNG
argument_list|,
literal|"ELNRNG"
argument_list|,
literal|"Link number out of range"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EUNATCH
argument_list|)
name|ENTRY
argument_list|(
name|EUNATCH
argument_list|,
literal|"EUNATCH"
argument_list|,
literal|"Protocol driver not attached"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOCSI
argument_list|)
name|ENTRY
argument_list|(
name|ENOCSI
argument_list|,
literal|"ENOCSI"
argument_list|,
literal|"No CSI structure available"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EL2HLT
argument_list|)
name|ENTRY
argument_list|(
name|EL2HLT
argument_list|,
literal|"EL2HLT"
argument_list|,
literal|"Level 2 halted"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EDEADLK
argument_list|)
name|ENTRY
argument_list|(
name|EDEADLK
argument_list|,
literal|"EDEADLK"
argument_list|,
literal|"Deadlock condition"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOLCK
argument_list|)
name|ENTRY
argument_list|(
name|ENOLCK
argument_list|,
literal|"ENOLCK"
argument_list|,
literal|"No record locks available"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EBADE
argument_list|)
name|ENTRY
argument_list|(
name|EBADE
argument_list|,
literal|"EBADE"
argument_list|,
literal|"Invalid exchange"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EBADR
argument_list|)
name|ENTRY
argument_list|(
name|EBADR
argument_list|,
literal|"EBADR"
argument_list|,
literal|"Invalid request descriptor"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EXFULL
argument_list|)
name|ENTRY
argument_list|(
name|EXFULL
argument_list|,
literal|"EXFULL"
argument_list|,
literal|"Exchange full"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOANO
argument_list|)
name|ENTRY
argument_list|(
name|ENOANO
argument_list|,
literal|"ENOANO"
argument_list|,
literal|"No anode"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EBADRQC
argument_list|)
name|ENTRY
argument_list|(
name|EBADRQC
argument_list|,
literal|"EBADRQC"
argument_list|,
literal|"Invalid request code"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EBADSLT
argument_list|)
name|ENTRY
argument_list|(
name|EBADSLT
argument_list|,
literal|"EBADSLT"
argument_list|,
literal|"Invalid slot"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EDEADLOCK
argument_list|)
name|ENTRY
argument_list|(
name|EDEADLOCK
argument_list|,
literal|"EDEADLOCK"
argument_list|,
literal|"File locking deadlock error"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EBFONT
argument_list|)
name|ENTRY
argument_list|(
name|EBFONT
argument_list|,
literal|"EBFONT"
argument_list|,
literal|"Bad font file format"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOSTR
argument_list|)
name|ENTRY
argument_list|(
name|ENOSTR
argument_list|,
literal|"ENOSTR"
argument_list|,
literal|"Device not a stream"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENODATA
argument_list|)
name|ENTRY
argument_list|(
name|ENODATA
argument_list|,
literal|"ENODATA"
argument_list|,
literal|"No data available"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ETIME
argument_list|)
name|ENTRY
argument_list|(
name|ETIME
argument_list|,
literal|"ETIME"
argument_list|,
literal|"Timer expired"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOSR
argument_list|)
name|ENTRY
argument_list|(
name|ENOSR
argument_list|,
literal|"ENOSR"
argument_list|,
literal|"Out of streams resources"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENONET
argument_list|)
name|ENTRY
argument_list|(
name|ENONET
argument_list|,
literal|"ENONET"
argument_list|,
literal|"Machine is not on the network"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOPKG
argument_list|)
name|ENTRY
argument_list|(
name|ENOPKG
argument_list|,
literal|"ENOPKG"
argument_list|,
literal|"Package not installed"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EREMOTE
argument_list|)
name|ENTRY
argument_list|(
name|EREMOTE
argument_list|,
literal|"EREMOTE"
argument_list|,
literal|"Object is remote"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOLINK
argument_list|)
name|ENTRY
argument_list|(
name|ENOLINK
argument_list|,
literal|"ENOLINK"
argument_list|,
literal|"Link has been severed"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EADV
argument_list|)
name|ENTRY
argument_list|(
name|EADV
argument_list|,
literal|"EADV"
argument_list|,
literal|"Advertise error"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ESRMNT
argument_list|)
name|ENTRY
argument_list|(
name|ESRMNT
argument_list|,
literal|"ESRMNT"
argument_list|,
literal|"Srmount error"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ECOMM
argument_list|)
name|ENTRY
argument_list|(
name|ECOMM
argument_list|,
literal|"ECOMM"
argument_list|,
literal|"Communication error on send"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EPROTO
argument_list|)
name|ENTRY
argument_list|(
name|EPROTO
argument_list|,
literal|"EPROTO"
argument_list|,
literal|"Protocol error"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EMULTIHOP
argument_list|)
name|ENTRY
argument_list|(
name|EMULTIHOP
argument_list|,
literal|"EMULTIHOP"
argument_list|,
literal|"Multihop attempted"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EDOTDOT
argument_list|)
name|ENTRY
argument_list|(
name|EDOTDOT
argument_list|,
literal|"EDOTDOT"
argument_list|,
literal|"RFS specific error"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EBADMSG
argument_list|)
name|ENTRY
argument_list|(
name|EBADMSG
argument_list|,
literal|"EBADMSG"
argument_list|,
literal|"Not a data message"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENAMETOOLONG
argument_list|)
name|ENTRY
argument_list|(
name|ENAMETOOLONG
argument_list|,
literal|"ENAMETOOLONG"
argument_list|,
literal|"File name too long"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EOVERFLOW
argument_list|)
name|ENTRY
argument_list|(
name|EOVERFLOW
argument_list|,
literal|"EOVERFLOW"
argument_list|,
literal|"Value too large for defined data type"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOTUNIQ
argument_list|)
name|ENTRY
argument_list|(
name|ENOTUNIQ
argument_list|,
literal|"ENOTUNIQ"
argument_list|,
literal|"Name not unique on network"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EBADFD
argument_list|)
name|ENTRY
argument_list|(
name|EBADFD
argument_list|,
literal|"EBADFD"
argument_list|,
literal|"File descriptor in bad state"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EREMCHG
argument_list|)
name|ENTRY
argument_list|(
name|EREMCHG
argument_list|,
literal|"EREMCHG"
argument_list|,
literal|"Remote address changed"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ELIBACC
argument_list|)
name|ENTRY
argument_list|(
name|ELIBACC
argument_list|,
literal|"ELIBACC"
argument_list|,
literal|"Can not access a needed shared library"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ELIBBAD
argument_list|)
name|ENTRY
argument_list|(
name|ELIBBAD
argument_list|,
literal|"ELIBBAD"
argument_list|,
literal|"Accessing a corrupted shared library"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ELIBSCN
argument_list|)
name|ENTRY
argument_list|(
name|ELIBSCN
argument_list|,
literal|"ELIBSCN"
argument_list|,
literal|".lib section in a.out corrupted"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ELIBMAX
argument_list|)
name|ENTRY
argument_list|(
name|ELIBMAX
argument_list|,
literal|"ELIBMAX"
argument_list|,
literal|"Attempting to link in too many shared libraries"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ELIBEXEC
argument_list|)
name|ENTRY
argument_list|(
name|ELIBEXEC
argument_list|,
literal|"ELIBEXEC"
argument_list|,
literal|"Cannot exec a shared library directly"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EILSEQ
argument_list|)
name|ENTRY
argument_list|(
name|EILSEQ
argument_list|,
literal|"EILSEQ"
argument_list|,
literal|"Illegal byte sequence"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOSYS
argument_list|)
name|ENTRY
argument_list|(
name|ENOSYS
argument_list|,
literal|"ENOSYS"
argument_list|,
literal|"Operation not applicable"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ELOOP
argument_list|)
name|ENTRY
argument_list|(
name|ELOOP
argument_list|,
literal|"ELOOP"
argument_list|,
literal|"Too many symbolic links encountered"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ERESTART
argument_list|)
name|ENTRY
argument_list|(
name|ERESTART
argument_list|,
literal|"ERESTART"
argument_list|,
literal|"Interrupted system call should be restarted"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ESTRPIPE
argument_list|)
name|ENTRY
argument_list|(
name|ESTRPIPE
argument_list|,
literal|"ESTRPIPE"
argument_list|,
literal|"Streams pipe error"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOTEMPTY
argument_list|)
name|ENTRY
argument_list|(
name|ENOTEMPTY
argument_list|,
literal|"ENOTEMPTY"
argument_list|,
literal|"Directory not empty"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EUSERS
argument_list|)
name|ENTRY
argument_list|(
name|EUSERS
argument_list|,
literal|"EUSERS"
argument_list|,
literal|"Too many users"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOTSOCK
argument_list|)
name|ENTRY
argument_list|(
name|ENOTSOCK
argument_list|,
literal|"ENOTSOCK"
argument_list|,
literal|"Socket operation on non-socket"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EDESTADDRREQ
argument_list|)
name|ENTRY
argument_list|(
name|EDESTADDRREQ
argument_list|,
literal|"EDESTADDRREQ"
argument_list|,
literal|"Destination address required"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EMSGSIZE
argument_list|)
name|ENTRY
argument_list|(
name|EMSGSIZE
argument_list|,
literal|"EMSGSIZE"
argument_list|,
literal|"Message too long"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EPROTOTYPE
argument_list|)
name|ENTRY
argument_list|(
name|EPROTOTYPE
argument_list|,
literal|"EPROTOTYPE"
argument_list|,
literal|"Protocol wrong type for socket"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOPROTOOPT
argument_list|)
name|ENTRY
argument_list|(
name|ENOPROTOOPT
argument_list|,
literal|"ENOPROTOOPT"
argument_list|,
literal|"Protocol not available"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EPROTONOSUPPORT
argument_list|)
name|ENTRY
argument_list|(
name|EPROTONOSUPPORT
argument_list|,
literal|"EPROTONOSUPPORT"
argument_list|,
literal|"Protocol not supported"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ESOCKTNOSUPPORT
argument_list|)
name|ENTRY
argument_list|(
name|ESOCKTNOSUPPORT
argument_list|,
literal|"ESOCKTNOSUPPORT"
argument_list|,
literal|"Socket type not supported"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EOPNOTSUPP
argument_list|)
name|ENTRY
argument_list|(
name|EOPNOTSUPP
argument_list|,
literal|"EOPNOTSUPP"
argument_list|,
literal|"Operation not supported on transport endpoint"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EPFNOSUPPORT
argument_list|)
name|ENTRY
argument_list|(
name|EPFNOSUPPORT
argument_list|,
literal|"EPFNOSUPPORT"
argument_list|,
literal|"Protocol family not supported"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EAFNOSUPPORT
argument_list|)
name|ENTRY
argument_list|(
name|EAFNOSUPPORT
argument_list|,
literal|"EAFNOSUPPORT"
argument_list|,
literal|"Address family not supported by protocol"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EADDRINUSE
argument_list|)
name|ENTRY
argument_list|(
name|EADDRINUSE
argument_list|,
literal|"EADDRINUSE"
argument_list|,
literal|"Address already in use"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EADDRNOTAVAIL
argument_list|)
name|ENTRY
argument_list|(
name|EADDRNOTAVAIL
argument_list|,
literal|"EADDRNOTAVAIL"
argument_list|,
literal|"Cannot assign requested address"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENETDOWN
argument_list|)
name|ENTRY
argument_list|(
name|ENETDOWN
argument_list|,
literal|"ENETDOWN"
argument_list|,
literal|"Network is down"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENETUNREACH
argument_list|)
name|ENTRY
argument_list|(
name|ENETUNREACH
argument_list|,
literal|"ENETUNREACH"
argument_list|,
literal|"Network is unreachable"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENETRESET
argument_list|)
name|ENTRY
argument_list|(
name|ENETRESET
argument_list|,
literal|"ENETRESET"
argument_list|,
literal|"Network dropped connection because of reset"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ECONNABORTED
argument_list|)
name|ENTRY
argument_list|(
name|ECONNABORTED
argument_list|,
literal|"ECONNABORTED"
argument_list|,
literal|"Software caused connection abort"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ECONNRESET
argument_list|)
name|ENTRY
argument_list|(
name|ECONNRESET
argument_list|,
literal|"ECONNRESET"
argument_list|,
literal|"Connection reset by peer"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOBUFS
argument_list|)
name|ENTRY
argument_list|(
name|ENOBUFS
argument_list|,
literal|"ENOBUFS"
argument_list|,
literal|"No buffer space available"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EISCONN
argument_list|)
name|ENTRY
argument_list|(
name|EISCONN
argument_list|,
literal|"EISCONN"
argument_list|,
literal|"Transport endpoint is already connected"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOTCONN
argument_list|)
name|ENTRY
argument_list|(
name|ENOTCONN
argument_list|,
literal|"ENOTCONN"
argument_list|,
literal|"Transport endpoint is not connected"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ESHUTDOWN
argument_list|)
name|ENTRY
argument_list|(
name|ESHUTDOWN
argument_list|,
literal|"ESHUTDOWN"
argument_list|,
literal|"Cannot send after transport endpoint shutdown"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ETOOMANYREFS
argument_list|)
name|ENTRY
argument_list|(
name|ETOOMANYREFS
argument_list|,
literal|"ETOOMANYREFS"
argument_list|,
literal|"Too many references: cannot splice"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ETIMEDOUT
argument_list|)
name|ENTRY
argument_list|(
name|ETIMEDOUT
argument_list|,
literal|"ETIMEDOUT"
argument_list|,
literal|"Connection timed out"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ECONNREFUSED
argument_list|)
name|ENTRY
argument_list|(
name|ECONNREFUSED
argument_list|,
literal|"ECONNREFUSED"
argument_list|,
literal|"Connection refused"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EHOSTDOWN
argument_list|)
name|ENTRY
argument_list|(
name|EHOSTDOWN
argument_list|,
literal|"EHOSTDOWN"
argument_list|,
literal|"Host is down"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EHOSTUNREACH
argument_list|)
name|ENTRY
argument_list|(
name|EHOSTUNREACH
argument_list|,
literal|"EHOSTUNREACH"
argument_list|,
literal|"No route to host"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EALREADY
argument_list|)
name|ENTRY
argument_list|(
name|EALREADY
argument_list|,
literal|"EALREADY"
argument_list|,
literal|"Operation already in progress"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EINPROGRESS
argument_list|)
name|ENTRY
argument_list|(
name|EINPROGRESS
argument_list|,
literal|"EINPROGRESS"
argument_list|,
literal|"Operation now in progress"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ESTALE
argument_list|)
name|ENTRY
argument_list|(
name|ESTALE
argument_list|,
literal|"ESTALE"
argument_list|,
literal|"Stale NFS file handle"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EUCLEAN
argument_list|)
name|ENTRY
argument_list|(
name|EUCLEAN
argument_list|,
literal|"EUCLEAN"
argument_list|,
literal|"Structure needs cleaning"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENOTNAM
argument_list|)
name|ENTRY
argument_list|(
name|ENOTNAM
argument_list|,
literal|"ENOTNAM"
argument_list|,
literal|"Not a XENIX named type file"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENAVAIL
argument_list|)
name|ENTRY
argument_list|(
name|ENAVAIL
argument_list|,
literal|"ENAVAIL"
argument_list|,
literal|"No XENIX semaphores available"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EISNAM
argument_list|)
name|ENTRY
argument_list|(
name|EISNAM
argument_list|,
literal|"EISNAM"
argument_list|,
literal|"Is a named type file"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EREMOTEIO
argument_list|)
name|ENTRY
argument_list|(
name|EREMOTEIO
argument_list|,
literal|"EREMOTEIO"
argument_list|,
literal|"Remote I/O error"
argument_list|)
block|,
endif|#
directive|endif
name|ENTRY
argument_list|(
literal|0
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|EVMSERR
end_ifdef

begin_comment
comment|/* This is not in the table, because the numeric value of EVMSERR (32767)    lies outside the range of sys_errlist[].  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|int
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|msg
decl_stmt|;
block|}
name|evmserr
init|=
block|{
name|EVMSERR
block|,
literal|"EVMSERR"
block|,
literal|"VMS-specific error"
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Translation table allocated and initialized at runtime.  Indexed by the    errno value to find the equivalent symbolic value. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|error_names
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_error_names
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Translation table allocated and initialized at runtime, if it does not    already exist in the host environment.  Indexed by the errno value to find    the descriptive string.     We don't export it for use in other modules because even though it has the    same name, it differs from other implementations in that it is dynamically    initialized rather than statically initialized. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_SYS_ERRLIST
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|sys_nerr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|sys_errlist
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  NAME  	init_error_tables -- initialize the name and message tables  SYNOPSIS  	static void init_error_tables ();  DESCRIPTION  	Using the error_table, which is initialized at compile time, generate 	the error_names and the sys_errlist (if needed) tables, which are 	indexed at runtime by a specific errno value.  BUGS  	The initialization of the tables may fail under low memory conditions, 	in which case we don't do anything particularly useful, but we don't 	bomb either.  Who knows, it might succeed at a later point if we free 	some memory in the meantime.  In any case, the other routines know 	how to deal with lack of a table after trying to initialize it.  This 	may or may not be considered to be a bug, that we don't specifically 	warn about this particular failure mode.  */
end_comment

begin_function
specifier|static
name|void
name|init_error_tables
parameter_list|()
block|{
specifier|const
name|struct
name|error_info
modifier|*
name|eip
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
comment|/* If we haven't already scanned the error_table once to find the maximum      errno value, then go find it now. */
if|if
condition|(
name|num_error_names
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|eip
operator|=
name|error_table
init|;
name|eip
operator|->
name|name
operator|!=
name|NULL
condition|;
name|eip
operator|++
control|)
block|{
if|if
condition|(
name|eip
operator|->
name|value
operator|>=
name|num_error_names
condition|)
block|{
name|num_error_names
operator|=
name|eip
operator|->
name|value
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Now attempt to allocate the error_names table, zero it out, and then      initialize it from the statically initialized error_table. */
if|if
condition|(
name|error_names
operator|==
name|NULL
condition|)
block|{
name|nbytes
operator|=
name|num_error_names
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error_names
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|nbytes
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|memset
argument_list|(
name|error_names
argument_list|,
literal|0
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
for|for
control|(
name|eip
operator|=
name|error_table
init|;
name|eip
operator|->
name|name
operator|!=
name|NULL
condition|;
name|eip
operator|++
control|)
block|{
name|error_names
index|[
name|eip
operator|->
name|value
index|]
operator|=
name|eip
operator|->
name|name
expr_stmt|;
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|HAVE_SYS_ERRLIST
comment|/* Now attempt to allocate the sys_errlist table, zero it out, and then      initialize it from the statically initialized error_table. */
if|if
condition|(
name|sys_errlist
operator|==
name|NULL
condition|)
block|{
name|nbytes
operator|=
name|num_error_names
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sys_errlist
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|nbytes
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|memset
argument_list|(
name|sys_errlist
argument_list|,
literal|0
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|sys_nerr
operator|=
name|num_error_names
expr_stmt|;
for|for
control|(
name|eip
operator|=
name|error_table
init|;
name|eip
operator|->
name|name
operator|!=
name|NULL
condition|;
name|eip
operator|++
control|)
block|{
name|sys_errlist
index|[
name|eip
operator|->
name|value
index|]
operator|=
name|eip
operator|->
name|msg
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*   @deftypefn Extension int errno_max (void)  Returns the maximum @code{errno} value for which a corresponding symbolic name or message is available.  Note that in the case where we use the @code{sys_errlist} supplied by the system, it is possible for there to be more symbolic names than messages, or vice versa.  In fact, the manual page for @code{perror(3C)} explicitly warns that one should check the size of the table (@code{sys_nerr}) before indexing it, since new error codes may be added to the system before they are added to the table.  Thus @code{sys_nerr} might be smaller than value implied by the largest @code{errno} value defined in @code{<errno.h>}.  We return the maximum value that can be used to obtain a meaningful symbolic name or message.  @end deftypefn  */
end_comment

begin_function
name|int
name|errno_max
parameter_list|()
block|{
name|int
name|maxsize
decl_stmt|;
if|if
condition|(
name|error_names
operator|==
name|NULL
condition|)
block|{
name|init_error_tables
argument_list|()
expr_stmt|;
block|}
name|maxsize
operator|=
name|MAX
argument_list|(
name|sys_nerr
argument_list|,
name|num_error_names
argument_list|)
expr_stmt|;
return|return
operator|(
name|maxsize
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STRERROR
end_ifndef

begin_comment
comment|/*  @deftypefn Supplemental char* strerror (int @var{errnoval})  Maps an @code{errno} number to an error message string, the contents of which are implementation defined.  On systems which have the external variables @code{sys_nerr} and @code{sys_errlist}, these strings will be the same as the ones used by @code{perror}.  If the supplied error number is within the valid range of indices for the @code{sys_errlist}, but no message is available for the particular error number, then returns the string @samp{Error @var{num}}, where @var{num} is the error number.  If the supplied error number is not a valid index into @code{sys_errlist}, returns @code{NULL}.  The returned string is only guaranteed to be valid only until the next call to @code{strerror}.  @end deftypefn  */
end_comment

begin_function
name|char
modifier|*
name|strerror
parameter_list|(
name|errnoval
parameter_list|)
name|int
name|errnoval
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|HAVE_SYS_ERRLIST
if|if
condition|(
name|error_names
operator|==
name|NULL
condition|)
block|{
name|init_error_tables
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|errnoval
operator|<
literal|0
operator|)
operator|||
operator|(
name|errnoval
operator|>=
name|sys_nerr
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|EVMSERR
if|if
condition|(
name|errnoval
operator|==
name|evmserr
operator|.
name|value
condition|)
name|msg
operator|=
name|evmserr
operator|.
name|msg
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* Out of range, just return NULL */
name|msg
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sys_errlist
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sys_errlist
index|[
name|errnoval
index|]
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* In range, but no sys_errlist or no entry at this index. */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Error %d"
argument_list|,
name|errnoval
argument_list|)
expr_stmt|;
name|msg
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
comment|/* In range, and a valid message.  Just return the message. */
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
name|sys_errlist
index|[
name|errnoval
index|]
expr_stmt|;
block|}
return|return
operator|(
name|msg
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_STRERROR */
end_comment

begin_comment
comment|/*  @deftypefn Replacement {const char*} strerrno (int @var{errnum})  Given an error number returned from a system call (typically returned in @code{errno}), returns a pointer to a string containing the symbolic name of that error number, as found in @code{<errno.h>}.  If the supplied error number is within the valid range of indices for symbolic names, but no name is available for the particular error number, then returns the string @samp{Error @var{num}}, where @var{num} is the error number.  If the supplied error number is not within the range of valid indices, then returns @code{NULL}.  The contents of the location pointed to are only guaranteed to be valid until the next call to @code{strerrno}.  @end deftypefn  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|strerrno
parameter_list|(
name|errnoval
parameter_list|)
name|int
name|errnoval
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
name|error_names
operator|==
name|NULL
condition|)
block|{
name|init_error_tables
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|errnoval
operator|<
literal|0
operator|)
operator|||
operator|(
name|errnoval
operator|>=
name|num_error_names
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|EVMSERR
if|if
condition|(
name|errnoval
operator|==
name|evmserr
operator|.
name|value
condition|)
name|name
operator|=
name|evmserr
operator|.
name|name
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* Out of range, just return NULL */
name|name
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error_names
operator|==
name|NULL
operator|)
operator|||
operator|(
name|error_names
index|[
name|errnoval
index|]
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* In range, but no error_names or no entry at this index. */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Error %d"
argument_list|,
name|errnoval
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
expr_stmt|;
block|}
else|else
block|{
comment|/* In range, and a valid name.  Just return the name. */
name|name
operator|=
name|error_names
index|[
name|errnoval
index|]
expr_stmt|;
block|}
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  @deftypefn Extension int strtoerrno (const char *@var{name})  Given the symbolic name of a error number (e.g., @code{EACCES}), map it to an errno value.  If no translation is found, returns 0.  @end deftypefn  */
end_comment

begin_function
name|int
name|strtoerrno
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|errnoval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|error_names
operator|==
name|NULL
condition|)
block|{
name|init_error_tables
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|errnoval
operator|=
literal|0
init|;
name|errnoval
operator|<
name|num_error_names
condition|;
name|errnoval
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error_names
index|[
name|errnoval
index|]
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|error_names
index|[
name|errnoval
index|]
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|errnoval
operator|==
name|num_error_names
condition|)
block|{
ifdef|#
directive|ifdef
name|EVMSERR
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|evmserr
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
name|errnoval
operator|=
name|evmserr
operator|.
name|value
expr_stmt|;
else|else
endif|#
directive|endif
name|errnoval
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|errnoval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A simple little main that does nothing but print all the errno translations    if MAIN is defined and this file is compiled and linked. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAIN
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function
name|int
name|main
parameter_list|()
block|{
name|int
name|errn
decl_stmt|;
name|int
name|errnmax
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|char
modifier|*
name|strerror
parameter_list|()
function_decl|;
name|errnmax
operator|=
name|errno_max
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%d entries in names table.\n"
argument_list|,
name|num_error_names
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d entries in messages table.\n"
argument_list|,
name|sys_nerr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d is max useful index.\n"
argument_list|,
name|errnmax
argument_list|)
expr_stmt|;
comment|/* Keep printing values until we get to the end of *both* tables, not      *either* table.  Note that knowing the maximum useful index does *not*      relieve us of the responsibility of testing the return pointer for      NULL. */
for|for
control|(
name|errn
operator|=
literal|0
init|;
name|errn
operator|<=
name|errnmax
condition|;
name|errn
operator|++
control|)
block|{
name|name
operator|=
name|strerrno
argument_list|(
name|errn
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|name
operator|==
name|NULL
operator|)
condition|?
literal|"<NULL>"
else|:
name|name
expr_stmt|;
name|msg
operator|=
name|strerror
argument_list|(
name|errn
argument_list|)
expr_stmt|;
name|msg
operator|=
operator|(
name|msg
operator|==
name|NULL
operator|)
condition|?
literal|"<NULL>"
else|:
name|msg
expr_stmt|;
name|printf
argument_list|(
literal|"%-4d%-18s%s\n"
argument_list|,
name|errn
argument_list|,
name|name
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

