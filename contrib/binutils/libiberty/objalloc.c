begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* objalloc.c -- routines to allocate memory for objects    Copyright 1997 Free Software Foundation, Inc.    Written by Ian Lance Taylor, Cygnus Solutions.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"objalloc.h"
end_include

begin_comment
comment|/* Get a definition for NULL.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
name|VMS
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unixlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
end_ifdef

begin_comment
comment|/* Get a definition for size_t.  */
end_comment

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For systems with larger pointers than ints, this must be declared.  */
end_comment

begin_decl_stmt
specifier|extern
name|PTR
name|malloc
name|PARAMS
argument_list|(
operator|(
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* These routines allocate space for an object.  Freeing allocated    space may or may not free all more recently allocated space.     We handle large and small allocation requests differently.  If we    don't have enough space in the current block, and the allocation    request is for more than 512 bytes, we simply pass it through to    malloc.  */
end_comment

begin_comment
comment|/* The objalloc structure is defined in objalloc.h.  */
end_comment

begin_comment
comment|/* This structure appears at the start of each chunk.  */
end_comment

begin_struct
struct|struct
name|objalloc_chunk
block|{
comment|/* Next chunk.  */
name|struct
name|objalloc_chunk
modifier|*
name|next
decl_stmt|;
comment|/* If this chunk contains large objects, this is the value of      current_ptr when this chunk was allocated.  If this chunk      contains small objects, this is NULL.  */
name|char
modifier|*
name|current_ptr
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The aligned size of objalloc_chunk.  */
end_comment

begin_define
define|#
directive|define
name|CHUNK_HEADER_SIZE
define|\
value|((sizeof (struct objalloc_chunk) + OBJALLOC_ALIGN - 1)	\&~ (OBJALLOC_ALIGN - 1))
end_define

begin_comment
comment|/* We ask for this much memory each time we create a chunk which is to    hold small objects.  */
end_comment

begin_define
define|#
directive|define
name|CHUNK_SIZE
value|(4096 - 32)
end_define

begin_comment
comment|/* A request for this amount or more is just passed through to malloc.  */
end_comment

begin_define
define|#
directive|define
name|BIG_REQUEST
value|(512)
end_define

begin_comment
comment|/* Create an objalloc structure.  */
end_comment

begin_function
name|struct
name|objalloc
modifier|*
name|objalloc_create
parameter_list|()
block|{
name|struct
name|objalloc
modifier|*
name|ret
decl_stmt|;
name|struct
name|objalloc_chunk
modifier|*
name|chunk
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|objalloc
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|ret
operator|->
name|chunks
operator|=
operator|(
name|PTR
operator|)
name|malloc
argument_list|(
name|CHUNK_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|->
name|chunks
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|chunk
operator|=
operator|(
expr|struct
name|objalloc_chunk
operator|*
operator|)
name|ret
operator|->
name|chunks
expr_stmt|;
name|chunk
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|chunk
operator|->
name|current_ptr
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|current_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|chunk
operator|+
name|CHUNK_HEADER_SIZE
expr_stmt|;
name|ret
operator|->
name|current_space
operator|=
name|CHUNK_SIZE
operator|-
name|CHUNK_HEADER_SIZE
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Allocate space from an objalloc structure.  */
end_comment

begin_function
name|PTR
name|_objalloc_alloc
parameter_list|(
name|o
parameter_list|,
name|len
parameter_list|)
name|struct
name|objalloc
modifier|*
name|o
decl_stmt|;
name|unsigned
name|long
name|len
decl_stmt|;
block|{
comment|/* We avoid confusion from zero sized objects by always allocating      at least 1 byte.  */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
literal|1
expr_stmt|;
name|len
operator|=
operator|(
name|len
operator|+
name|OBJALLOC_ALIGN
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|OBJALLOC_ALIGN
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
name|o
operator|->
name|current_space
condition|)
block|{
name|o
operator|->
name|current_ptr
operator|+=
name|len
expr_stmt|;
name|o
operator|->
name|current_space
operator|-=
name|len
expr_stmt|;
return|return
call|(
name|PTR
call|)
argument_list|(
name|o
operator|->
name|current_ptr
operator|-
name|len
argument_list|)
return|;
block|}
if|if
condition|(
name|len
operator|>=
name|BIG_REQUEST
condition|)
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|struct
name|objalloc_chunk
modifier|*
name|chunk
decl_stmt|;
name|ret
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|CHUNK_HEADER_SIZE
operator|+
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|chunk
operator|=
operator|(
expr|struct
name|objalloc_chunk
operator|*
operator|)
name|ret
expr_stmt|;
name|chunk
operator|->
name|next
operator|=
operator|(
expr|struct
name|objalloc_chunk
operator|*
operator|)
name|o
operator|->
name|chunks
expr_stmt|;
name|chunk
operator|->
name|current_ptr
operator|=
name|o
operator|->
name|current_ptr
expr_stmt|;
name|o
operator|->
name|chunks
operator|=
operator|(
name|PTR
operator|)
name|chunk
expr_stmt|;
return|return
call|(
name|PTR
call|)
argument_list|(
name|ret
operator|+
name|CHUNK_HEADER_SIZE
argument_list|)
return|;
block|}
else|else
block|{
name|struct
name|objalloc_chunk
modifier|*
name|chunk
decl_stmt|;
name|chunk
operator|=
operator|(
expr|struct
name|objalloc_chunk
operator|*
operator|)
name|malloc
argument_list|(
name|CHUNK_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|chunk
operator|->
name|next
operator|=
operator|(
expr|struct
name|objalloc_chunk
operator|*
operator|)
name|o
operator|->
name|chunks
expr_stmt|;
name|chunk
operator|->
name|current_ptr
operator|=
name|NULL
expr_stmt|;
name|o
operator|->
name|current_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|chunk
operator|+
name|CHUNK_HEADER_SIZE
expr_stmt|;
name|o
operator|->
name|current_space
operator|=
name|CHUNK_SIZE
operator|-
name|CHUNK_HEADER_SIZE
expr_stmt|;
name|o
operator|->
name|chunks
operator|=
operator|(
name|PTR
operator|)
name|chunk
expr_stmt|;
return|return
name|objalloc_alloc
argument_list|(
name|o
argument_list|,
name|len
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Free an entire objalloc structure.  */
end_comment

begin_function
name|void
name|objalloc_free
parameter_list|(
name|o
parameter_list|)
name|struct
name|objalloc
modifier|*
name|o
decl_stmt|;
block|{
name|struct
name|objalloc_chunk
modifier|*
name|l
decl_stmt|;
name|l
operator|=
operator|(
expr|struct
name|objalloc_chunk
operator|*
operator|)
name|o
operator|->
name|chunks
expr_stmt|;
while|while
condition|(
name|l
operator|!=
name|NULL
condition|)
block|{
name|struct
name|objalloc_chunk
modifier|*
name|next
decl_stmt|;
name|next
operator|=
name|l
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free a block from an objalloc structure.  This also frees all more    recently allocated blocks.  */
end_comment

begin_function
name|void
name|objalloc_free_block
parameter_list|(
name|o
parameter_list|,
name|block
parameter_list|)
name|struct
name|objalloc
modifier|*
name|o
decl_stmt|;
name|PTR
name|block
decl_stmt|;
block|{
name|struct
name|objalloc_chunk
modifier|*
name|p
decl_stmt|,
modifier|*
name|small
decl_stmt|;
name|char
modifier|*
name|b
init|=
operator|(
name|char
operator|*
operator|)
name|block
decl_stmt|;
comment|/* First set P to the chunk which contains the block we are freeing,      and set Q to the last small object chunk we see before P.  */
name|small
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|(
expr|struct
name|objalloc_chunk
operator|*
operator|)
name|o
operator|->
name|chunks
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|current_ptr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|b
operator|>
operator|(
name|char
operator|*
operator|)
name|p
operator|&&
name|b
operator|<
operator|(
name|char
operator|*
operator|)
name|p
operator|+
name|CHUNK_SIZE
condition|)
break|break;
name|small
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|b
operator|==
operator|(
name|char
operator|*
operator|)
name|p
operator|+
name|CHUNK_HEADER_SIZE
condition|)
break|break;
block|}
block|}
comment|/* If we can't find the chunk, the caller has made a mistake.  */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|current_ptr
operator|==
name|NULL
condition|)
block|{
name|struct
name|objalloc_chunk
modifier|*
name|q
decl_stmt|;
name|struct
name|objalloc_chunk
modifier|*
name|first
decl_stmt|;
comment|/* The block is in a chunk containing small objects.  We can 	 free every chunk through SMALL, because they have certainly 	 been allocated more recently.  After SMALL, we will not see 	 any chunks containing small objects; we can free any big 	 chunk if the current_ptr is greater than or equal to B.  We 	 can then reset the new current_ptr to B.  */
name|first
operator|=
name|NULL
expr_stmt|;
name|q
operator|=
operator|(
expr|struct
name|objalloc_chunk
operator|*
operator|)
name|o
operator|->
name|chunks
expr_stmt|;
while|while
condition|(
name|q
operator|!=
name|p
condition|)
block|{
name|struct
name|objalloc_chunk
modifier|*
name|next
decl_stmt|;
name|next
operator|=
name|q
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|small
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|small
operator|==
name|q
condition|)
name|small
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q
operator|->
name|current_ptr
operator|>
name|b
condition|)
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|first
operator|==
name|NULL
condition|)
name|first
operator|=
name|q
expr_stmt|;
name|q
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|first
operator|==
name|NULL
condition|)
name|first
operator|=
name|p
expr_stmt|;
name|o
operator|->
name|chunks
operator|=
operator|(
name|PTR
operator|)
name|first
expr_stmt|;
comment|/* Now start allocating from this small block again.  */
name|o
operator|->
name|current_ptr
operator|=
name|b
expr_stmt|;
name|o
operator|->
name|current_space
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|+
name|CHUNK_SIZE
operator|)
operator|-
name|b
expr_stmt|;
block|}
else|else
block|{
name|struct
name|objalloc_chunk
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|current_ptr
decl_stmt|;
comment|/* This block is in a large chunk by itself.  We can free          everything on the list up to and including this block.  We          then start allocating from the next chunk containing small          objects, setting current_ptr from the value stored with the          large chunk we are freeing.  */
name|current_ptr
operator|=
name|p
operator|->
name|current_ptr
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|q
operator|=
operator|(
expr|struct
name|objalloc_chunk
operator|*
operator|)
name|o
operator|->
name|chunks
expr_stmt|;
while|while
condition|(
name|q
operator|!=
name|p
condition|)
block|{
name|struct
name|objalloc_chunk
modifier|*
name|next
decl_stmt|;
name|next
operator|=
name|q
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|=
name|next
expr_stmt|;
block|}
name|o
operator|->
name|chunks
operator|=
operator|(
name|PTR
operator|)
name|p
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|current_ptr
operator|!=
name|NULL
condition|)
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|o
operator|->
name|current_ptr
operator|=
name|current_ptr
expr_stmt|;
name|o
operator|->
name|current_space
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|+
name|CHUNK_SIZE
operator|)
operator|-
name|current_ptr
expr_stmt|;
block|}
block|}
end_function

end_unit

