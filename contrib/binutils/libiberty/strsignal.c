begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Extended support for using signal values.    Written by Fred Fish.  fnf@cygnus.com    This file is in the public domain.  */
end_comment

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_comment
comment|/* We need to declare sys_siglist, because even if the system provides    it we can't assume that it is declared in<signal.h> (for example,    SunOS provides sys_siglist, but it does not declare it in any    header file).  fHowever, we can't declare sys_siglist portably,    because on some systems it is declared with const and on some    systems it is declared without const.  If we were using autoconf,    we could work out the right declaration.  Until, then we just    ignore any declaration in the system header files, and always    declare it ourselves.  With luck, this will always work.  */
end_comment

begin_define
define|#
directive|define
name|sys_siglist
value|no_such_symbol
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/*  Routines imported from standard C runtime libraries. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|PTR
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|PTR
name|memset
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Undefine the macro we used to hide the definition of sys_siglist    found in the system header files.  */
end_comment

begin_undef
undef|#
directive|undef
name|sys_siglist
end_undef

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|NULL
value|(void *) 0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX
end_ifndef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|init_signal_tables
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Translation table for signal values.     Note that this table is generally only accessed when it is used at runtime    to initialize signal name and message tables that are indexed by signal    value.     Not all of these signals will exist on all systems.  This table is the only    thing that should have to be updated as new signal numbers are introduced.    It's sort of ugly, but at least its portable. */
end_comment

begin_struct
struct|struct
name|signal_info
block|{
name|int
name|value
decl_stmt|;
comment|/* The numeric value from<signal.h> */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The equivalent symbolic value */
ifndef|#
directive|ifndef
name|HAVE_SYS_SIGLIST
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
comment|/* Short message about this value */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_SYS_SIGLIST
end_ifndef

begin_define
define|#
directive|define
name|ENTRY
parameter_list|(
name|value
parameter_list|,
name|name
parameter_list|,
name|msg
parameter_list|)
value|{value, name, msg}
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ENTRY
parameter_list|(
name|value
parameter_list|,
name|name
parameter_list|,
name|msg
parameter_list|)
value|{value, name}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|signal_info
name|signal_table
index|[]
init|=
block|{
if|#
directive|if
name|defined
argument_list|(
name|SIGHUP
argument_list|)
name|ENTRY
argument_list|(
name|SIGHUP
argument_list|,
literal|"SIGHUP"
argument_list|,
literal|"Hangup"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGINT
argument_list|)
name|ENTRY
argument_list|(
name|SIGINT
argument_list|,
literal|"SIGINT"
argument_list|,
literal|"Interrupt"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGQUIT
argument_list|)
name|ENTRY
argument_list|(
name|SIGQUIT
argument_list|,
literal|"SIGQUIT"
argument_list|,
literal|"Quit"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
name|ENTRY
argument_list|(
name|SIGILL
argument_list|,
literal|"SIGILL"
argument_list|,
literal|"Illegal instruction"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTRAP
argument_list|)
name|ENTRY
argument_list|(
name|SIGTRAP
argument_list|,
literal|"SIGTRAP"
argument_list|,
literal|"Trace/breakpoint trap"
argument_list|)
block|,
endif|#
directive|endif
comment|/* Put SIGIOT before SIGABRT, so that if SIGIOT==SIGABRT then SIGABRT    overrides SIGIOT.  SIGABRT is in ANSI and POSIX.1, and SIGIOT isn't. */
if|#
directive|if
name|defined
argument_list|(
name|SIGIOT
argument_list|)
name|ENTRY
argument_list|(
name|SIGIOT
argument_list|,
literal|"SIGIOT"
argument_list|,
literal|"IOT trap"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGABRT
argument_list|)
name|ENTRY
argument_list|(
name|SIGABRT
argument_list|,
literal|"SIGABRT"
argument_list|,
literal|"Aborted"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGEMT
argument_list|)
name|ENTRY
argument_list|(
name|SIGEMT
argument_list|,
literal|"SIGEMT"
argument_list|,
literal|"Emulation trap"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
name|ENTRY
argument_list|(
name|SIGFPE
argument_list|,
literal|"SIGFPE"
argument_list|,
literal|"Arithmetic exception"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGKILL
argument_list|)
name|ENTRY
argument_list|(
name|SIGKILL
argument_list|,
literal|"SIGKILL"
argument_list|,
literal|"Killed"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGBUS
argument_list|)
name|ENTRY
argument_list|(
name|SIGBUS
argument_list|,
literal|"SIGBUS"
argument_list|,
literal|"Bus error"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSEGV
argument_list|)
name|ENTRY
argument_list|(
name|SIGSEGV
argument_list|,
literal|"SIGSEGV"
argument_list|,
literal|"Segmentation fault"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSYS
argument_list|)
name|ENTRY
argument_list|(
name|SIGSYS
argument_list|,
literal|"SIGSYS"
argument_list|,
literal|"Bad system call"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPIPE
argument_list|)
name|ENTRY
argument_list|(
name|SIGPIPE
argument_list|,
literal|"SIGPIPE"
argument_list|,
literal|"Broken pipe"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGALRM
argument_list|)
name|ENTRY
argument_list|(
name|SIGALRM
argument_list|,
literal|"SIGALRM"
argument_list|,
literal|"Alarm clock"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTERM
argument_list|)
name|ENTRY
argument_list|(
name|SIGTERM
argument_list|,
literal|"SIGTERM"
argument_list|,
literal|"Terminated"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGUSR1
argument_list|)
name|ENTRY
argument_list|(
name|SIGUSR1
argument_list|,
literal|"SIGUSR1"
argument_list|,
literal|"User defined signal 1"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGUSR2
argument_list|)
name|ENTRY
argument_list|(
name|SIGUSR2
argument_list|,
literal|"SIGUSR2"
argument_list|,
literal|"User defined signal 2"
argument_list|)
block|,
endif|#
directive|endif
comment|/* Put SIGCLD before SIGCHLD, so that if SIGCLD==SIGCHLD then SIGCHLD    overrides SIGCLD.  SIGCHLD is in POXIX.1 */
if|#
directive|if
name|defined
argument_list|(
name|SIGCLD
argument_list|)
name|ENTRY
argument_list|(
name|SIGCLD
argument_list|,
literal|"SIGCLD"
argument_list|,
literal|"Child status changed"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCHLD
argument_list|)
name|ENTRY
argument_list|(
name|SIGCHLD
argument_list|,
literal|"SIGCHLD"
argument_list|,
literal|"Child status changed"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPWR
argument_list|)
name|ENTRY
argument_list|(
name|SIGPWR
argument_list|,
literal|"SIGPWR"
argument_list|,
literal|"Power fail/restart"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
name|ENTRY
argument_list|(
name|SIGWINCH
argument_list|,
literal|"SIGWINCH"
argument_list|,
literal|"Window size changed"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGURG
argument_list|)
name|ENTRY
argument_list|(
name|SIGURG
argument_list|,
literal|"SIGURG"
argument_list|,
literal|"Urgent I/O condition"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGIO
argument_list|)
comment|/* "I/O pending" has also been suggested, but is misleading since the      signal only happens when the process has asked for it, not everytime      I/O is pending. */
name|ENTRY
argument_list|(
name|SIGIO
argument_list|,
literal|"SIGIO"
argument_list|,
literal|"I/O possible"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPOLL
argument_list|)
name|ENTRY
argument_list|(
name|SIGPOLL
argument_list|,
literal|"SIGPOLL"
argument_list|,
literal|"Pollable event occurred"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSTOP
argument_list|)
name|ENTRY
argument_list|(
name|SIGSTOP
argument_list|,
literal|"SIGSTOP"
argument_list|,
literal|"Stopped (signal)"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTSTP
argument_list|)
name|ENTRY
argument_list|(
name|SIGTSTP
argument_list|,
literal|"SIGTSTP"
argument_list|,
literal|"Stopped (user)"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCONT
argument_list|)
name|ENTRY
argument_list|(
name|SIGCONT
argument_list|,
literal|"SIGCONT"
argument_list|,
literal|"Continued"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTTIN
argument_list|)
name|ENTRY
argument_list|(
name|SIGTTIN
argument_list|,
literal|"SIGTTIN"
argument_list|,
literal|"Stopped (tty input)"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTTOU
argument_list|)
name|ENTRY
argument_list|(
name|SIGTTOU
argument_list|,
literal|"SIGTTOU"
argument_list|,
literal|"Stopped (tty output)"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGVTALRM
argument_list|)
name|ENTRY
argument_list|(
name|SIGVTALRM
argument_list|,
literal|"SIGVTALRM"
argument_list|,
literal|"Virtual timer expired"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPROF
argument_list|)
name|ENTRY
argument_list|(
name|SIGPROF
argument_list|,
literal|"SIGPROF"
argument_list|,
literal|"Profiling timer expired"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGXCPU
argument_list|)
name|ENTRY
argument_list|(
name|SIGXCPU
argument_list|,
literal|"SIGXCPU"
argument_list|,
literal|"CPU time limit exceeded"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGXFSZ
argument_list|)
name|ENTRY
argument_list|(
name|SIGXFSZ
argument_list|,
literal|"SIGXFSZ"
argument_list|,
literal|"File size limit exceeded"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGWIND
argument_list|)
name|ENTRY
argument_list|(
name|SIGWIND
argument_list|,
literal|"SIGWIND"
argument_list|,
literal|"SIGWIND"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPHONE
argument_list|)
name|ENTRY
argument_list|(
name|SIGPHONE
argument_list|,
literal|"SIGPHONE"
argument_list|,
literal|"SIGPHONE"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGLOST
argument_list|)
name|ENTRY
argument_list|(
name|SIGLOST
argument_list|,
literal|"SIGLOST"
argument_list|,
literal|"Resource lost"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGWAITING
argument_list|)
name|ENTRY
argument_list|(
name|SIGWAITING
argument_list|,
literal|"SIGWAITING"
argument_list|,
literal|"Process's LWPs are blocked"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGLWP
argument_list|)
name|ENTRY
argument_list|(
name|SIGLWP
argument_list|,
literal|"SIGLWP"
argument_list|,
literal|"Signal LWP"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGDANGER
argument_list|)
name|ENTRY
argument_list|(
name|SIGDANGER
argument_list|,
literal|"SIGDANGER"
argument_list|,
literal|"Swap space dangerously low"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGGRANT
argument_list|)
name|ENTRY
argument_list|(
name|SIGGRANT
argument_list|,
literal|"SIGGRANT"
argument_list|,
literal|"Monitor mode granted"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGRETRACT
argument_list|)
name|ENTRY
argument_list|(
name|SIGRETRACT
argument_list|,
literal|"SIGRETRACT"
argument_list|,
literal|"Need to relinguish monitor mode"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGMSG
argument_list|)
name|ENTRY
argument_list|(
name|SIGMSG
argument_list|,
literal|"SIGMSG"
argument_list|,
literal|"Monitor mode data available"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSOUND
argument_list|)
name|ENTRY
argument_list|(
name|SIGSOUND
argument_list|,
literal|"SIGSOUND"
argument_list|,
literal|"Sound completed"
argument_list|)
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSAK
argument_list|)
name|ENTRY
argument_list|(
name|SIGSAK
argument_list|,
literal|"SIGSAK"
argument_list|,
literal|"Secure attention"
argument_list|)
block|,
endif|#
directive|endif
name|ENTRY
argument_list|(
literal|0
argument_list|,
argument|NULL
argument_list|,
argument|NULL
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Translation table allocated and initialized at runtime.  Indexed by the    signal value to find the equivalent symbolic value. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|signal_names
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|num_signal_names
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Translation table allocated and initialized at runtime, if it does not    already exist in the host environment.  Indexed by the signal value to find    the descriptive string.     We don't export it for use in other modules because even though it has the    same name, it differs from other implementations in that it is dynamically    initialized rather than statically initialized. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_SYS_SIGLIST
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|sys_nsig
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|sys_siglist
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|NSIG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|sys_nsig
init|=
name|NSIG
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|_NSIG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|sys_nsig
init|=
name|_NSIG
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
specifier|const
name|sys_siglist
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  NAME  	init_signal_tables -- initialize the name and message tables  SYNOPSIS  	static void init_signal_tables ();  DESCRIPTION  	Using the signal_table, which is initialized at compile time, generate 	the signal_names and the sys_siglist (if needed) tables, which are 	indexed at runtime by a specific signal value.  BUGS  	The initialization of the tables may fail under low memory conditions, 	in which case we don't do anything particularly useful, but we don't 	bomb either.  Who knows, it might succeed at a later point if we free 	some memory in the meantime.  In any case, the other routines know 	how to deal with lack of a table after trying to initialize it.  This 	may or may not be considered to be a bug, that we don't specifically 	warn about this particular failure mode.  */
end_comment

begin_function
specifier|static
name|void
name|init_signal_tables
parameter_list|()
block|{
specifier|const
name|struct
name|signal_info
modifier|*
name|eip
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
comment|/* If we haven't already scanned the signal_table once to find the maximum      signal value, then go find it now. */
if|if
condition|(
name|num_signal_names
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|eip
operator|=
name|signal_table
init|;
name|eip
operator|->
name|name
operator|!=
name|NULL
condition|;
name|eip
operator|++
control|)
block|{
if|if
condition|(
name|eip
operator|->
name|value
operator|>=
name|num_signal_names
condition|)
block|{
name|num_signal_names
operator|=
name|eip
operator|->
name|value
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Now attempt to allocate the signal_names table, zero it out, and then      initialize it from the statically initialized signal_table. */
if|if
condition|(
name|signal_names
operator|==
name|NULL
condition|)
block|{
name|nbytes
operator|=
name|num_signal_names
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|signal_names
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|nbytes
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|memset
argument_list|(
name|signal_names
argument_list|,
literal|0
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
for|for
control|(
name|eip
operator|=
name|signal_table
init|;
name|eip
operator|->
name|name
operator|!=
name|NULL
condition|;
name|eip
operator|++
control|)
block|{
name|signal_names
index|[
name|eip
operator|->
name|value
index|]
operator|=
name|eip
operator|->
name|name
expr_stmt|;
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|HAVE_SYS_SIGLIST
comment|/* Now attempt to allocate the sys_siglist table, zero it out, and then      initialize it from the statically initialized signal_table. */
if|if
condition|(
name|sys_siglist
operator|==
name|NULL
condition|)
block|{
name|nbytes
operator|=
name|num_signal_names
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sys_siglist
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|nbytes
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|memset
argument_list|(
name|sys_siglist
argument_list|,
literal|0
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|sys_nsig
operator|=
name|num_signal_names
expr_stmt|;
for|for
control|(
name|eip
operator|=
name|signal_table
init|;
name|eip
operator|->
name|name
operator|!=
name|NULL
condition|;
name|eip
operator|++
control|)
block|{
name|sys_siglist
index|[
name|eip
operator|->
name|value
index|]
operator|=
name|eip
operator|->
name|msg
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  NAME  	signo_max -- return the max signo value  SYNOPSIS  	int signo_max ();  DESCRIPTION  	Returns the maximum signo value for which a corresponding symbolic 	name or message is available.  Note that in the case where 	we use the sys_siglist supplied by the system, it is possible for 	there to be more symbolic names than messages, or vice versa. 	In fact, the manual page for psignal(3b) explicitly warns that one 	should check the size of the table (NSIG) before indexing it, 	since new signal codes may be added to the system before they are 	added to the table.  Thus NSIG might be smaller than value 	implied by the largest signo value defined in<signal.h>.  	We return the maximum value that can be used to obtain a meaningful 	symbolic name or message.  */
end_comment

begin_function
name|int
name|signo_max
parameter_list|()
block|{
name|int
name|maxsize
decl_stmt|;
if|if
condition|(
name|signal_names
operator|==
name|NULL
condition|)
block|{
name|init_signal_tables
argument_list|()
expr_stmt|;
block|}
name|maxsize
operator|=
name|MAX
argument_list|(
name|sys_nsig
argument_list|,
name|num_signal_names
argument_list|)
expr_stmt|;
return|return
operator|(
name|maxsize
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  NAME  	strsignal -- map a signal number to a signal message string  SYNOPSIS  	const char *strsignal (int signo)  DESCRIPTION  	Maps an signal number to an signal message string, the contents of 	which are implementation defined.  On systems which have the external 	variable sys_siglist, these strings will be the same as the ones used 	by psignal().  	If the supplied signal number is within the valid range of indices 	for the sys_siglist, but no message is available for the particular 	signal number, then returns the string "Signal NUM", where NUM is the 	signal number.  	If the supplied signal number is not a valid index into sys_siglist, 	returns NULL.  	The returned string is only guaranteed to be valid only until the 	next call to strsignal.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STRSIGNAL
end_ifndef

begin_function
specifier|const
name|char
modifier|*
name|strsignal
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|HAVE_SYS_SIGLIST
if|if
condition|(
name|signal_names
operator|==
name|NULL
condition|)
block|{
name|init_signal_tables
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|signo
operator|<
literal|0
operator|)
operator|||
operator|(
name|signo
operator|>=
name|sys_nsig
operator|)
condition|)
block|{
comment|/* Out of range, just return NULL */
name|msg
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sys_siglist
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sys_siglist
index|[
name|signo
index|]
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* In range, but no sys_siglist or no entry at this index. */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Signal %d"
argument_list|,
name|signo
argument_list|)
expr_stmt|;
name|msg
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
expr_stmt|;
block|}
else|else
block|{
comment|/* In range, and a valid message.  Just return the message. */
name|msg
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|sys_siglist
index|[
name|signo
index|]
expr_stmt|;
block|}
return|return
operator|(
name|msg
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_STRSIGNAL */
end_comment

begin_comment
comment|/*  NAME  	strsigno -- map an signal number to a symbolic name string  SYNOPSIS  	const char *strsigno (int signo)  DESCRIPTION  	Given an signal number, returns a pointer to a string containing 	the symbolic name of that signal number, as found in<signal.h>.  	If the supplied signal number is within the valid range of indices 	for symbolic names, but no name is available for the particular 	signal number, then returns the string "Signal NUM", where NUM is 	the signal number.  	If the supplied signal number is not within the range of valid 	indices, then returns NULL.  BUGS  	The contents of the location pointed to are only guaranteed to be 	valid until the next call to strsigno.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|strsigno
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
name|signal_names
operator|==
name|NULL
condition|)
block|{
name|init_signal_tables
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|signo
operator|<
literal|0
operator|)
operator|||
operator|(
name|signo
operator|>=
name|num_signal_names
operator|)
condition|)
block|{
comment|/* Out of range, just return NULL */
name|name
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|signal_names
operator|==
name|NULL
operator|)
operator|||
operator|(
name|signal_names
index|[
name|signo
index|]
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* In range, but no signal_names or no entry at this index. */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Signal %d"
argument_list|,
name|signo
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
expr_stmt|;
block|}
else|else
block|{
comment|/* In range, and a valid name.  Just return the name. */
name|name
operator|=
name|signal_names
index|[
name|signo
index|]
expr_stmt|;
block|}
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  NAME  	strtosigno -- map a symbolic signal name to a numeric value  SYNOPSIS  	int strtosigno (char *name)  DESCRIPTION  	Given the symbolic name of a signal, map it to a signal number. 	If no translation is found, returns 0.  */
end_comment

begin_function
name|int
name|strtosigno
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|signo
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|signal_names
operator|==
name|NULL
condition|)
block|{
name|init_signal_tables
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|signo
operator|=
literal|0
init|;
name|signo
operator|<
name|num_signal_names
condition|;
name|signo
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|signal_names
index|[
name|signo
index|]
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|signal_names
index|[
name|signo
index|]
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|signo
operator|==
name|num_signal_names
condition|)
block|{
name|signo
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|signo
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  NAME  	psignal -- print message about signal to stderr  SYNOPSIS  	void psignal (unsigned signo, char *message);  DESCRIPTION  	Print to the standard error the message, followed by a colon, 	followed by the description of the signal specified by signo, 	followed by a newline. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_PSIGNAL
end_ifndef

begin_function
name|void
name|psignal
parameter_list|(
name|signo
parameter_list|,
name|message
parameter_list|)
name|unsigned
name|signo
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
block|{
if|if
condition|(
name|signal_names
operator|==
name|NULL
condition|)
block|{
name|init_signal_tables
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|signo
operator|<=
literal|0
operator|)
operator|||
operator|(
name|signo
operator|>=
name|sys_nsig
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown signal\n"
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|message
argument_list|,
name|sys_siglist
index|[
name|signo
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! HAVE_PSIGNAL */
end_comment

begin_comment
comment|/* A simple little main that does nothing but print all the signal translations    if MAIN is defined and this file is compiled and linked. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAIN
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function
name|int
name|main
parameter_list|()
block|{
name|int
name|signo
decl_stmt|;
name|int
name|maxsigno
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|maxsigno
operator|=
name|signo_max
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%d entries in names table.\n"
argument_list|,
name|num_signal_names
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d entries in messages table.\n"
argument_list|,
name|sys_nsig
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d is max useful index.\n"
argument_list|,
name|maxsigno
argument_list|)
expr_stmt|;
comment|/* Keep printing values until we get to the end of *both* tables, not      *either* table.  Note that knowing the maximum useful index does *not*      relieve us of the responsibility of testing the return pointer for      NULL. */
for|for
control|(
name|signo
operator|=
literal|0
init|;
name|signo
operator|<=
name|maxsigno
condition|;
name|signo
operator|++
control|)
block|{
name|name
operator|=
name|strsigno
argument_list|(
name|signo
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|name
operator|==
name|NULL
operator|)
condition|?
literal|"<NULL>"
else|:
name|name
expr_stmt|;
name|msg
operator|=
name|strsignal
argument_list|(
name|signo
argument_list|)
expr_stmt|;
name|msg
operator|=
operator|(
name|msg
operator|==
name|NULL
operator|)
condition|?
literal|"<NULL>"
else|:
name|msg
expr_stmt|;
name|printf
argument_list|(
literal|"%-4d%-18s%s\n"
argument_list|,
name|signo
argument_list|,
name|name
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

