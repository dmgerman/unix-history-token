begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Create and destroy argument vectors (argv's)    Copyright (C) 1992 Free Software Foundation, Inc.    Written by Fred Fish @ Cygnus Support  This file is part of the libiberty library. Libiberty is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  Libiberty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with libiberty; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*  Create and destroy argument vectors.  An argument vector is simply an     array of string pointers, terminated by a NULL pointer. */
end_comment

begin_include
include|#
directive|include
file|"ansidecl.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|isspace
end_ifdef

begin_undef
undef|#
directive|undef
name|isspace
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|isspace
parameter_list|(
name|ch
parameter_list|)
value|((ch) == ' ' || (ch) == '\t')
end_define

begin_comment
comment|/*  Routines imported from standard C runtime libraries. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_function_decl
specifier|extern
name|void
modifier|*
name|memcpy
parameter_list|(
name|void
modifier|*
name|s1
parameter_list|,
specifier|const
name|void
modifier|*
name|s2
parameter_list|,
name|size_t
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* 4.11.2.1 */
end_comment

begin_function_decl
specifier|extern
name|size_t
name|strlen
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* 4.11.6.3 */
end_comment

begin_function_decl
specifier|extern
name|void
modifier|*
name|malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* 4.10.3.3 */
end_comment

begin_function_decl
specifier|extern
name|void
modifier|*
name|realloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* 4.10.3.4 */
end_comment

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* 4.10.3.2 */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|strdup
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Non-ANSI */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !__STDC__ */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
name|_WIN32
operator|||
name|defined
name|__GNUC__
end_if

begin_function_decl
specifier|extern
name|char
modifier|*
name|memcpy
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Copy memory region */
end_comment

begin_function_decl
specifier|extern
name|int
name|strlen
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Count length of string */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Standard memory allocater */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|realloc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Standard memory reallocator */
end_comment

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Free malloc'd memory */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|strdup
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Duplicate a string */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STDC__ */
end_comment

begin_include
include|#
directive|include
file|"alloca-conf.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EOS
end_ifndef

begin_define
define|#
directive|define
name|EOS
value|'\0'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|INITIAL_MAXARGC
value|8
end_define

begin_comment
comment|/* Number of args + NULL in initial argv */
end_comment

begin_comment
comment|/*  NAME  	freeargv -- free an argument vector  SYNOPSIS  	void freeargv (vector) 	char **vector;  DESCRIPTION  	Free an argument vector that was built using buildargv.  Simply scans 	through the vector, freeing the memory for each argument until the 	terminating NULL is found, and then frees the vector itself.  RETURNS  	No value.  */
end_comment

begin_function
name|void
name|freeargv
parameter_list|(
name|vector
parameter_list|)
name|char
modifier|*
modifier|*
name|vector
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|scan
decl_stmt|;
if|if
condition|(
name|vector
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|scan
operator|=
name|vector
init|;
operator|*
name|scan
operator|!=
name|NULL
condition|;
name|scan
operator|++
control|)
block|{
name|free
argument_list|(
operator|*
name|scan
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|vector
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  NAME  	buildargv -- build an argument vector from a string  SYNOPSIS  	char **buildargv (sp) 	char *sp;  DESCRIPTION  	Given a pointer to a string, parse the string extracting fields 	separated by whitespace and optionally enclosed within either single 	or double quotes (which are stripped off), and build a vector of 	pointers to copies of the string for each field.  The input string 	remains unchanged.  	All of the memory for the pointer array and copies of the string 	is obtained from malloc.  All of the memory can be returned to the 	system with the single function call freeargv, which takes the 	returned result of buildargv, as it's argument.  	The memory for the argv array is dynamically expanded as necessary.  RETURNS  	Returns a pointer to the argument vector if successful. Returns NULL 	if the input string pointer is NULL or if there is insufficient 	memory to complete building the argument vector.  NOTES  	In order to provide a working buffer for extracting arguments into, 	with appropriate stripping of quotes and translation of backslash 	sequences, we allocate a working buffer at least as long as the input 	string.  This ensures that we always have enough space in which to 	work, since the extracted arg is never larger than the input string.  	If the input is a null string (as opposed to a NULL pointer), then 	buildarg returns an argv that has one arg, a null string.  	Argv is always kept terminated with a NULL arg pointer, so it can 	be passed to freeargv at any time, or returned, as appropriate. */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|buildargv
parameter_list|(
name|input
parameter_list|)
name|char
modifier|*
name|input
decl_stmt|;
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|char
modifier|*
name|copybuf
decl_stmt|;
name|int
name|squote
init|=
literal|0
decl_stmt|;
name|int
name|dquote
init|=
literal|0
decl_stmt|;
name|int
name|bsquote
init|=
literal|0
decl_stmt|;
name|int
name|argc
init|=
literal|0
decl_stmt|;
name|int
name|maxargc
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|nargv
decl_stmt|;
if|if
condition|(
name|input
operator|!=
name|NULL
condition|)
block|{
name|copybuf
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|input
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Is a do{}while to always execute the loop once.  Always return an 	 argv, even for null strings.  See NOTES above, test case below. */
do|do
block|{
comment|/* Pick off argv[argc] */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|input
argument_list|)
condition|)
block|{
name|input
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|maxargc
operator|==
literal|0
operator|)
operator|||
operator|(
name|argc
operator|>=
operator|(
name|maxargc
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* argv needs initialization, or expansion */
if|if
condition|(
name|argv
operator|==
name|NULL
condition|)
block|{
name|maxargc
operator|=
name|INITIAL_MAXARGC
expr_stmt|;
name|nargv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|maxargc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|maxargc
operator|*=
literal|2
expr_stmt|;
name|nargv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|argv
argument_list|,
name|maxargc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nargv
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|argv
operator|!=
name|NULL
condition|)
block|{
name|freeargv
argument_list|(
name|argv
argument_list|)
expr_stmt|;
name|argv
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
block|}
name|argv
operator|=
name|nargv
expr_stmt|;
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Begin scanning arg */
name|arg
operator|=
name|copybuf
expr_stmt|;
while|while
condition|(
operator|*
name|input
operator|!=
name|EOS
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|input
argument_list|)
operator|&&
operator|!
name|squote
operator|&&
operator|!
name|dquote
operator|&&
operator|!
name|bsquote
condition|)
block|{
break|break;
block|}
else|else
block|{
if|if
condition|(
name|bsquote
condition|)
block|{
name|bsquote
operator|=
literal|0
expr_stmt|;
operator|*
name|arg
operator|++
operator|=
operator|*
name|input
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|input
operator|==
literal|'\\'
condition|)
block|{
name|bsquote
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|squote
condition|)
block|{
if|if
condition|(
operator|*
name|input
operator|==
literal|'\''
condition|)
block|{
name|squote
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|arg
operator|++
operator|=
operator|*
name|input
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dquote
condition|)
block|{
if|if
condition|(
operator|*
name|input
operator|==
literal|'"'
condition|)
block|{
name|dquote
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|arg
operator|++
operator|=
operator|*
name|input
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|*
name|input
operator|==
literal|'\''
condition|)
block|{
name|squote
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|input
operator|==
literal|'"'
condition|)
block|{
name|dquote
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|arg
operator|++
operator|=
operator|*
name|input
expr_stmt|;
block|}
block|}
name|input
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|arg
operator|=
name|EOS
expr_stmt|;
name|argv
index|[
name|argc
index|]
operator|=
name|strdup
argument_list|(
name|copybuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|argc
index|]
operator|==
name|NULL
condition|)
block|{
name|freeargv
argument_list|(
name|argv
argument_list|)
expr_stmt|;
name|argv
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|argc
operator|++
expr_stmt|;
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|input
argument_list|)
condition|)
block|{
name|input
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|input
operator|!=
name|EOS
condition|)
do|;
block|}
return|return
operator|(
name|argv
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MAIN
end_ifdef

begin_comment
comment|/* Simple little test driver. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tests
index|[]
init|=
block|{
literal|"a simple command line"
block|,
literal|"arg 'foo' is single quoted"
block|,
literal|"arg \"bar\" is double quoted"
block|,
literal|"arg \"foo bar\" has embedded whitespace"
block|,
literal|"arg 'Jack said \\'hi\\'' has single quotes"
block|,
literal|"arg 'Jack said \\\"hi\\\"' has double quotes"
block|,
literal|"a b c d e f g h i j k l m n o p q r s t u v w x y z 1 2 3 4 5 6 7 8 9"
block|,
comment|/* This should be expanded into only one argument.  */
literal|"trailing-whitespace "
block|,
literal|""
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|()
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|test
decl_stmt|;
name|char
modifier|*
modifier|*
name|targs
decl_stmt|;
for|for
control|(
name|test
operator|=
name|tests
init|;
operator|*
name|test
operator|!=
name|NULL
condition|;
name|test
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"buildargv(\"%s\")\n"
argument_list|,
operator|*
name|test
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|argv
operator|=
name|buildargv
argument_list|(
operator|*
name|test
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"failed!\n\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|targs
operator|=
name|argv
init|;
operator|*
name|targs
operator|!=
name|NULL
condition|;
name|targs
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"\t\"%s\"\n"
argument_list|,
operator|*
name|targs
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|freeargv
argument_list|(
name|argv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAIN */
end_comment

end_unit

