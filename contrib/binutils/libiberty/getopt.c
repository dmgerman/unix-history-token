begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Getopt for GNU.    NOTE: getopt is now part of the C library, so if you don't know what    "Keep this file name-space clean" means, talk to roland@gnu.ai.mit.edu    before changing it!     Copyright (C) 1987, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97    	Free Software Foundation, Inc.     NOTE: The canonical source of this file is maintained with the GNU C Library.    Bugs can be reported to bug-glibc@prep.ai.mit.edu.     This program is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any    later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,    USA.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* This tells Alpha OSF/1 not to define a getopt prototype in<stdio.h>.    Ditto for AIX 3.2 and<stdlib.h>.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_NO_PROTO
end_ifndef

begin_define
define|#
directive|define
name|_NO_PROTO
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
operator|!
name|__STDC__
end_if

begin_comment
comment|/* This is a separate conditional since some stdc systems    reject `defined (const)'.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|const
end_ifndef

begin_define
define|#
directive|define
name|const
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* Comment out all this code if we are using the GNU C Library, and are not    actually compiling the library itself.  This code is part of the GNU C    Library, but also included in many other GNU distributions.  Compiling    and linking in this code is a waste when using the GNU C library    (especially if it is a shared library).  Rather than having every GNU    program understand `configure --with-gnu-libc' and omit the object files,    it is simpler to just do this in the source for each such file.  */
end_comment

begin_define
define|#
directive|define
name|GETOPT_INTERFACE_VERSION
value|2
end_define

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_LIBC
argument_list|)
operator|&&
name|defined
argument_list|(
name|__GLIBC__
argument_list|)
operator|&&
name|__GLIBC__
operator|>=
literal|2
end_if

begin_include
include|#
directive|include
file|<gnu-versions.h>
end_include

begin_if
if|#
directive|if
name|_GNU_GETOPT_INTERFACE_VERSION
operator|==
name|GETOPT_INTERFACE_VERSION
end_if

begin_define
define|#
directive|define
name|ELIDE_CODE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ELIDE_CODE
end_ifndef

begin_comment
comment|/* This needs to come after some library #include    to get __GNU_LIBRARY__ defined.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNU_LIBRARY__
end_ifdef

begin_comment
comment|/* Don't include stdlib.h for non-GNU C libraries because some of them    contain conflicting prototypes for getopt.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GNU C library.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_include
include|#
directive|include
file|<unixlib.h>
end_include

begin_if
if|#
directive|if
name|HAVE_STRING_H
operator|-
literal|0
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_
end_ifndef

begin_comment
comment|/* This is for other GNU distributions with internationalized messages.    When compiling libc, the _ macro is predefined.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIBINTL_H
end_ifdef

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_define
define|#
directive|define
name|_
parameter_list|(
name|msgid
parameter_list|)
value|gettext (msgid)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_
parameter_list|(
name|msgid
parameter_list|)
value|(msgid)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This version of `getopt' appears to the caller like standard Unix `getopt'    but it behaves differently for the user, since it allows the user    to intersperse the options with the other arguments.     As `getopt' works, it permutes the elements of ARGV so that,    when it is done, all the options precede everything else.  Thus    all application programs are extended to handle flexible argument order.     Setting the environment variable POSIXLY_CORRECT disables permutation.    Then the behavior is completely standard.     GNU application programs can use a third alternative mode in which    they can distinguish the relative order of options and other arguments.  */
end_comment

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_comment
comment|/* For communication from `getopt' to the caller.    When `getopt' finds an option that takes an argument,    the argument value is returned here.    Also, when `ordering' is RETURN_IN_ORDER,    each non-option ARGV-element is returned here.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|optarg
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index in ARGV of the next element to be scanned.    This is used for communication to and from the caller    and for communication between successive calls to `getopt'.     On entry to `getopt', zero means this is the first call; initialize.     When `getopt' returns -1, this is the index of the first of the    non-option elements that the caller should itself scan.     Otherwise, `optind' communicates from one call to the next    how much of ARGV has been scanned so far.  */
end_comment

begin_comment
comment|/* 1003.2 says this must be 1 before any call.  */
end_comment

begin_decl_stmt
name|int
name|optind
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Formerly, initialization of getopt depended on optind==0, which    causes problems with re-calling getopt as programs generally don't    know that. */
end_comment

begin_decl_stmt
name|int
name|__getopt_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The next char to be scanned in the option-element    in which the last option character we returned was found.    This allows us to pick up the scan where we left off.     If this is zero, or a null string, it means resume the scan    by advancing to the next ARGV-element.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|nextchar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Callers store zero here to inhibit the error message    for unrecognized options.  */
end_comment

begin_decl_stmt
name|int
name|opterr
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to an option character which was unrecognized.    This must be initialized on some systems to avoid linking in the    system's own getopt implementation.  */
end_comment

begin_decl_stmt
name|int
name|optopt
init|=
literal|'?'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Describe how to deal with options that follow non-option ARGV-elements.     If the caller did not specify anything,    the default is REQUIRE_ORDER if the environment variable    POSIXLY_CORRECT is defined, PERMUTE otherwise.     REQUIRE_ORDER means don't recognize them as options;    stop option processing when the first non-option is seen.    This is what Unix does.    This mode of operation is selected by either setting the environment    variable POSIXLY_CORRECT, or using `+' as the first character    of the list of option characters.     PERMUTE is the default.  We permute the contents of ARGV as we scan,    so that eventually all the non-options are at the end.  This allows options    to be given in any order, even with programs that were not written to    expect this.     RETURN_IN_ORDER is an option available to programs that were written    to expect options and other ARGV-elements in any order and that care about    the ordering of the two.  We describe each non-option ARGV-element    as if it were the argument of an option with character code 1.    Using `-' as the first character of the list of option characters    selects this mode of operation.     The special argument `--' forces an end of option-scanning regardless    of the value of `ordering'.  In the case of RETURN_IN_ORDER, only    `--' can cause `getopt' to return -1 with `optind' != ARGC.  */
end_comment

begin_enum
specifier|static
enum|enum
block|{
name|REQUIRE_ORDER
block|,
name|PERMUTE
block|,
name|RETURN_IN_ORDER
block|}
name|ordering
enum|;
end_enum

begin_comment
comment|/* Value of POSIXLY_CORRECT environment variable.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|posixly_correct
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|__GNU_LIBRARY__
end_ifdef

begin_comment
comment|/* We want to avoid inclusion of string.h with non-GNU libraries    because there are many ways it can cause trouble.    On some systems, it contains special magic macros that don't work    in GCC.  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
define|#
directive|define
name|my_index
value|strchr
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Avoid depending on library functions or files    whose names are inconsistent.  */
end_comment

begin_function_decl
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|char
modifier|*
name|my_index
parameter_list|(
name|str
parameter_list|,
name|chr
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|chr
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|str
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
name|chr
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|str
return|;
name|str
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If using GCC, we can safely declare strlen this way.    If not using GCC, it is ok not to declare it.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_comment
comment|/* Note that Motorola Delta 68k R3V7 comes with GCC but not stddef.h.    That was relevant to code that was here before.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
operator|!
name|__STDC__
end_if

begin_comment
comment|/* gcc with -traditional declares the built-in strlen to return int,    and has done so at least since version 2.4.5. -- rms.  */
end_comment

begin_function_decl
specifier|extern
name|int
name|strlen
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __STDC__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __GNUC__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __GNU_LIBRARY__ */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Handle permutation of arguments.  */
end_comment

begin_comment
comment|/* Describe the part of ARGV that contains non-options that have    been skipped.  `first_nonopt' is the index in ARGV of the first of them;    `last_nonopt' is the index after the last of them.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|first_nonopt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|last_nonopt
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_LIBC
end_ifdef

begin_comment
comment|/* Bash 2.0 gives us an environment variable containing flags    indicating ARGV elements that should not be considered arguments.  */
end_comment

begin_comment
comment|/* Defined in getopt_init.c  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|__getopt_nonoption_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nonoption_flags_max_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nonoption_flags_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|original_argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
specifier|const
modifier|*
name|original_argv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make sure the environment variable bash 2.0 puts in the environment    is valid for the getopt call we must make sure that the ARGV passed    to getopt is that one passed to the process.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
name|store_args_and_env
argument_list|(
name|int
name|argc
argument_list|,
name|char
operator|*
specifier|const
operator|*
name|argv
argument_list|)
block|{
comment|/* XXX This is no good solution.  We should rather copy the args so      that we can compare them later.  But we must not use malloc(3).  */
name|original_argc
operator|=
name|argc
expr_stmt|;
name|original_argv
operator|=
name|argv
expr_stmt|;
block|}
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|text_set_element
end_ifdef

begin_expr_stmt
name|text_set_element
argument_list|(
name|__libc_subinit
argument_list|,
name|store_args_and_env
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* text_set_element */
end_comment

begin_define
define|#
directive|define
name|SWAP_FLAGS
parameter_list|(
name|ch1
parameter_list|,
name|ch2
parameter_list|)
define|\
value|if (nonoption_flags_len> 0)						      \     {									      \       char __tmp = __getopt_nonoption_flags[ch1];			      \       __getopt_nonoption_flags[ch1] = __getopt_nonoption_flags[ch2];	      \       __getopt_nonoption_flags[ch2] = __tmp;				      \     }
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !_LIBC */
end_comment

begin_define
define|#
directive|define
name|SWAP_FLAGS
parameter_list|(
name|ch1
parameter_list|,
name|ch2
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _LIBC */
end_comment

begin_comment
comment|/* Exchange two adjacent subsequences of ARGV.    One subsequence is elements [first_nonopt,last_nonopt)    which contains all the non-options that have been skipped so far.    The other is elements [last_nonopt,optind), which contains all    the options processed since those non-options were skipped.     `first_nonopt' and `last_nonopt' are relocated so that they describe    the new indices of the non-options in ARGV after they are moved.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|&&
name|__STDC__
end_if

begin_function_decl
specifier|static
name|void
name|exchange
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|exchange
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|bottom
init|=
name|first_nonopt
decl_stmt|;
name|int
name|middle
init|=
name|last_nonopt
decl_stmt|;
name|int
name|top
init|=
name|optind
decl_stmt|;
name|char
modifier|*
name|tem
decl_stmt|;
comment|/* Exchange the shorter segment with the far end of the longer segment.      That puts the shorter segment into the right place.      It leaves the longer segment in the right place overall,      but it consists of two parts that need to be swapped next.  */
ifdef|#
directive|ifdef
name|_LIBC
comment|/* First make sure the handling of the `__getopt_nonoption_flags'      string can work normally.  Our top argument must be in the range      of the string.  */
if|if
condition|(
name|nonoption_flags_len
operator|>
literal|0
operator|&&
name|top
operator|>=
name|nonoption_flags_max_len
condition|)
block|{
comment|/* We must extend the array.  The user plays games with us and 	 presents new arguments.  */
name|char
modifier|*
name|new_str
init|=
name|malloc
argument_list|(
name|top
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_str
operator|==
name|NULL
condition|)
name|nonoption_flags_len
operator|=
name|nonoption_flags_max_len
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|memset
argument_list|(
name|__mempcpy
argument_list|(
name|new_str
argument_list|,
name|__getopt_nonoption_flags
argument_list|,
name|nonoption_flags_max_len
argument_list|)
argument_list|,
literal|'\0'
argument_list|,
name|top
operator|+
literal|1
operator|-
name|nonoption_flags_max_len
argument_list|)
expr_stmt|;
name|nonoption_flags_max_len
operator|=
name|top
operator|+
literal|1
expr_stmt|;
name|__getopt_nonoption_flags
operator|=
name|new_str
expr_stmt|;
block|}
block|}
endif|#
directive|endif
while|while
condition|(
name|top
operator|>
name|middle
operator|&&
name|middle
operator|>
name|bottom
condition|)
block|{
if|if
condition|(
name|top
operator|-
name|middle
operator|>
name|middle
operator|-
name|bottom
condition|)
block|{
comment|/* Bottom segment is the short one.  */
name|int
name|len
init|=
name|middle
operator|-
name|bottom
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Swap it with the top part of the top segment.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|tem
operator|=
name|argv
index|[
name|bottom
operator|+
name|i
index|]
expr_stmt|;
name|argv
index|[
name|bottom
operator|+
name|i
index|]
operator|=
name|argv
index|[
name|top
operator|-
operator|(
name|middle
operator|-
name|bottom
operator|)
operator|+
name|i
index|]
expr_stmt|;
name|argv
index|[
name|top
operator|-
operator|(
name|middle
operator|-
name|bottom
operator|)
operator|+
name|i
index|]
operator|=
name|tem
expr_stmt|;
name|SWAP_FLAGS
argument_list|(
name|bottom
operator|+
name|i
argument_list|,
name|top
operator|-
operator|(
name|middle
operator|-
name|bottom
operator|)
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Exclude the moved bottom segment from further swapping.  */
name|top
operator|-=
name|len
expr_stmt|;
block|}
else|else
block|{
comment|/* Top segment is the short one.  */
name|int
name|len
init|=
name|top
operator|-
name|middle
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Swap it with the bottom part of the bottom segment.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|tem
operator|=
name|argv
index|[
name|bottom
operator|+
name|i
index|]
expr_stmt|;
name|argv
index|[
name|bottom
operator|+
name|i
index|]
operator|=
name|argv
index|[
name|middle
operator|+
name|i
index|]
expr_stmt|;
name|argv
index|[
name|middle
operator|+
name|i
index|]
operator|=
name|tem
expr_stmt|;
name|SWAP_FLAGS
argument_list|(
name|bottom
operator|+
name|i
argument_list|,
name|middle
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Exclude the moved top segment from further swapping.  */
name|bottom
operator|+=
name|len
expr_stmt|;
block|}
block|}
comment|/* Update records for the slots the non-options now occupy.  */
name|first_nonopt
operator|+=
operator|(
name|optind
operator|-
name|last_nonopt
operator|)
expr_stmt|;
name|last_nonopt
operator|=
name|optind
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the internal data when the first call is made.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|&&
name|__STDC__
end_if

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|_getopt_initialize
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|_getopt_initialize
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|optstring
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
specifier|const
modifier|*
name|argv
decl_stmt|;
specifier|const
name|char
modifier|*
name|optstring
decl_stmt|;
block|{
comment|/* Start processing options with ARGV-element 1 (since ARGV-element 0      is the program name); the sequence of previously skipped      non-option ARGV-elements is empty.  */
name|first_nonopt
operator|=
name|last_nonopt
operator|=
name|optind
expr_stmt|;
name|nextchar
operator|=
name|NULL
expr_stmt|;
name|posixly_correct
operator|=
name|getenv
argument_list|(
literal|"POSIXLY_CORRECT"
argument_list|)
expr_stmt|;
comment|/* Determine how to handle the ordering of options and nonoptions.  */
if|if
condition|(
name|optstring
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|ordering
operator|=
name|RETURN_IN_ORDER
expr_stmt|;
operator|++
name|optstring
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optstring
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
block|{
name|ordering
operator|=
name|REQUIRE_ORDER
expr_stmt|;
operator|++
name|optstring
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|posixly_correct
operator|!=
name|NULL
condition|)
name|ordering
operator|=
name|REQUIRE_ORDER
expr_stmt|;
else|else
name|ordering
operator|=
name|PERMUTE
expr_stmt|;
ifdef|#
directive|ifdef
name|_LIBC
if|if
condition|(
name|posixly_correct
operator|==
name|NULL
operator|&&
name|argc
operator|==
name|original_argc
operator|&&
name|argv
operator|==
name|original_argv
condition|)
block|{
if|if
condition|(
name|nonoption_flags_max_len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|__getopt_nonoption_flags
operator|==
name|NULL
operator|||
name|__getopt_nonoption_flags
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|nonoption_flags_max_len
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|orig_str
init|=
name|__getopt_nonoption_flags
decl_stmt|;
name|int
name|len
init|=
name|nonoption_flags_max_len
operator|=
name|strlen
argument_list|(
name|orig_str
argument_list|)
decl_stmt|;
if|if
condition|(
name|nonoption_flags_max_len
operator|<
name|argc
condition|)
name|nonoption_flags_max_len
operator|=
name|argc
expr_stmt|;
name|__getopt_nonoption_flags
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|nonoption_flags_max_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|__getopt_nonoption_flags
operator|==
name|NULL
condition|)
name|nonoption_flags_max_len
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|memset
argument_list|(
name|__mempcpy
argument_list|(
name|__getopt_nonoption_flags
argument_list|,
name|orig_str
argument_list|,
name|len
argument_list|)
argument_list|,
literal|'\0'
argument_list|,
name|nonoption_flags_max_len
operator|-
name|len
argument_list|)
expr_stmt|;
block|}
block|}
name|nonoption_flags_len
operator|=
name|nonoption_flags_max_len
expr_stmt|;
block|}
else|else
name|nonoption_flags_len
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
name|optstring
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan elements of ARGV (whose length is ARGC) for option characters    given in OPTSTRING.     If an element of ARGV starts with '-', and is not exactly "-" or "--",    then it is an option element.  The characters of this element    (aside from the initial '-') are option characters.  If `getopt'    is called repeatedly, it returns successively each of the option characters    from each of the option elements.     If `getopt' finds another option character, it returns that character,    updating `optind' and `nextchar' so that the next call to `getopt' can    resume the scan with the following option character or ARGV-element.     If there are no more option characters, `getopt' returns -1.    Then `optind' is the index in ARGV of the first ARGV-element    that is not an option.  (The ARGV-elements have been permuted    so that those that are not options now come last.)     OPTSTRING is a string containing the legitimate option characters.    If an option character is seen that is not listed in OPTSTRING,    return '?' after printing an error message.  If you set `opterr' to    zero, the error message is suppressed but we still return '?'.     If a char in OPTSTRING is followed by a colon, that means it wants an arg,    so the following text in the same ARGV-element, or the text of the following    ARGV-element, is returned in `optarg'.  Two colons mean an option that    wants an optional arg; if there is text in the current ARGV-element,    it is returned in `optarg', otherwise `optarg' is set to zero.     If OPTSTRING starts with `-' or `+', it requests different methods of    handling the non-option ARGV-elements.    See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.     Long-named options begin with `--' instead of `-'.    Their names may be abbreviated as long as the abbreviation is unique    or is an exact match for some defined option.  If they have an    argument, it follows the option name in the same ARGV-element, separated    from the option name by a `=', or else the in next ARGV-element.    When `getopt' finds a long-named option, it returns 0 if that option's    `flag' field is nonzero, the value of the option's `val' field    if the `flag' field is zero.     The elements of ARGV aren't really const, because we permute them.    But we pretend they're const in the prototype to be compatible    with other systems.     LONGOPTS is a vector of `struct option' terminated by an    element containing a name which is zero.     LONGIND returns the index in LONGOPT of the long-named option found.    It is only valid when a long-named option has been found by the most    recent call.     If LONG_ONLY is nonzero, '-' as well as '--' can introduce    long-named options.  */
end_comment

begin_function
name|int
name|_getopt_internal
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|optstring
parameter_list|,
name|longopts
parameter_list|,
name|longind
parameter_list|,
name|long_only
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
specifier|const
modifier|*
name|argv
decl_stmt|;
specifier|const
name|char
modifier|*
name|optstring
decl_stmt|;
specifier|const
name|struct
name|option
modifier|*
name|longopts
decl_stmt|;
name|int
modifier|*
name|longind
decl_stmt|;
name|int
name|long_only
decl_stmt|;
block|{
name|optarg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|optind
operator|==
literal|0
operator|||
operator|!
name|__getopt_initialized
condition|)
block|{
if|if
condition|(
name|optind
operator|==
literal|0
condition|)
name|optind
operator|=
literal|1
expr_stmt|;
comment|/* Don't scan ARGV[0], the program name.  */
name|optstring
operator|=
name|_getopt_initialize
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|optstring
argument_list|)
expr_stmt|;
name|__getopt_initialized
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Test whether ARGV[optind] points to a non-option argument.      Either it does not have option syntax, or there is an environment flag      from the shell indicating it is not an option.  The later information      is only used when the used in the GNU libc.  */
ifdef|#
directive|ifdef
name|_LIBC
define|#
directive|define
name|NONOPTION_P
value|(argv[optind][0] != '-' || argv[optind][1] == '\0'	      \ 		     || (optind< nonoption_flags_len			      \&& __getopt_nonoption_flags[optind] == '1'))
else|#
directive|else
define|#
directive|define
name|NONOPTION_P
value|(argv[optind][0] != '-' || argv[optind][1] == '\0')
endif|#
directive|endif
if|if
condition|(
name|nextchar
operator|==
name|NULL
operator|||
operator|*
name|nextchar
operator|==
literal|'\0'
condition|)
block|{
comment|/* Advance to the next ARGV-element.  */
comment|/* Give FIRST_NONOPT& LAST_NONOPT rational values if OPTIND has been 	 moved back by the user (who may also have changed the arguments).  */
if|if
condition|(
name|last_nonopt
operator|>
name|optind
condition|)
name|last_nonopt
operator|=
name|optind
expr_stmt|;
if|if
condition|(
name|first_nonopt
operator|>
name|optind
condition|)
name|first_nonopt
operator|=
name|optind
expr_stmt|;
if|if
condition|(
name|ordering
operator|==
name|PERMUTE
condition|)
block|{
comment|/* If we have just processed some options following some non-options, 	     exchange them so that the options come first.  */
if|if
condition|(
name|first_nonopt
operator|!=
name|last_nonopt
operator|&&
name|last_nonopt
operator|!=
name|optind
condition|)
name|exchange
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|last_nonopt
operator|!=
name|optind
condition|)
name|first_nonopt
operator|=
name|optind
expr_stmt|;
comment|/* Skip any additional non-options 	     and extend the range of non-options previously skipped.  */
while|while
condition|(
name|optind
operator|<
name|argc
operator|&&
name|NONOPTION_P
condition|)
name|optind
operator|++
expr_stmt|;
name|last_nonopt
operator|=
name|optind
expr_stmt|;
block|}
comment|/* The special ARGV-element `--' means premature end of options. 	 Skip it like a null option, 	 then exchange with previous non-options as if it were an option, 	 then skip everything else like a non-option.  */
if|if
condition|(
name|optind
operator|!=
name|argc
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"--"
argument_list|)
condition|)
block|{
name|optind
operator|++
expr_stmt|;
if|if
condition|(
name|first_nonopt
operator|!=
name|last_nonopt
operator|&&
name|last_nonopt
operator|!=
name|optind
condition|)
name|exchange
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|first_nonopt
operator|==
name|last_nonopt
condition|)
name|first_nonopt
operator|=
name|optind
expr_stmt|;
name|last_nonopt
operator|=
name|argc
expr_stmt|;
name|optind
operator|=
name|argc
expr_stmt|;
block|}
comment|/* If we have done all the ARGV-elements, stop the scan 	 and back over any non-options that we skipped and permuted.  */
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
block|{
comment|/* Set the next-arg-index to point at the non-options 	     that we previously skipped, so the caller will digest them.  */
if|if
condition|(
name|first_nonopt
operator|!=
name|last_nonopt
condition|)
name|optind
operator|=
name|first_nonopt
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* If we have come to a non-option and did not permute it, 	 either stop the scan or describe it to the caller and pass it by.  */
if|if
condition|(
name|NONOPTION_P
condition|)
block|{
if|if
condition|(
name|ordering
operator|==
name|REQUIRE_ORDER
condition|)
return|return
operator|-
literal|1
return|;
name|optarg
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* We have found another option-ARGV-element. 	 Skip the initial punctuation.  */
name|nextchar
operator|=
operator|(
name|argv
index|[
name|optind
index|]
operator|+
literal|1
operator|+
operator|(
name|longopts
operator|!=
name|NULL
operator|&&
name|argv
index|[
name|optind
index|]
index|[
literal|1
index|]
operator|==
literal|'-'
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Decode the current option-ARGV-element.  */
comment|/* Check whether the ARGV-element is a long option.       If long_only and the ARGV-element has the form "-f", where f is      a valid short option, don't consider it an abbreviated form of      a long option that starts with f.  Otherwise there would be no      way to give the -f short option.       On the other hand, if there's a long option "fubar" and      the ARGV-element is "-fu", do consider that an abbreviation of      the long option, just like "--fu", and not "-f" with arg "u".       This distinction seems to be the most useful approach.  */
if|if
condition|(
name|longopts
operator|!=
name|NULL
operator|&&
operator|(
name|argv
index|[
name|optind
index|]
index|[
literal|1
index|]
operator|==
literal|'-'
operator|||
operator|(
name|long_only
operator|&&
operator|(
name|argv
index|[
name|optind
index|]
index|[
literal|2
index|]
operator|||
operator|!
name|my_index
argument_list|(
name|optstring
argument_list|,
name|argv
index|[
name|optind
index|]
index|[
literal|1
index|]
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|char
modifier|*
name|nameend
decl_stmt|;
specifier|const
name|struct
name|option
modifier|*
name|p
decl_stmt|;
specifier|const
name|struct
name|option
modifier|*
name|pfound
init|=
name|NULL
decl_stmt|;
name|int
name|exact
init|=
literal|0
decl_stmt|;
name|int
name|ambig
init|=
literal|0
decl_stmt|;
name|int
name|indfound
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|option_index
decl_stmt|;
for|for
control|(
name|nameend
operator|=
name|nextchar
init|;
operator|*
name|nameend
operator|&&
operator|*
name|nameend
operator|!=
literal|'='
condition|;
name|nameend
operator|++
control|)
comment|/* Do nothing.  */
empty_stmt|;
comment|/* Test all long options for either exact match 	 or abbreviated matches.  */
for|for
control|(
name|p
operator|=
name|longopts
operator|,
name|option_index
operator|=
literal|0
init|;
name|p
operator|->
name|name
condition|;
name|p
operator|++
operator|,
name|option_index
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|nextchar
argument_list|,
name|nameend
operator|-
name|nextchar
argument_list|)
condition|)
block|{
if|if
condition|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|nameend
operator|-
name|nextchar
argument_list|)
operator|==
operator|(
name|unsigned
name|int
operator|)
name|strlen
argument_list|(
name|p
operator|->
name|name
argument_list|)
condition|)
block|{
comment|/* Exact match found.  */
name|pfound
operator|=
name|p
expr_stmt|;
name|indfound
operator|=
name|option_index
expr_stmt|;
name|exact
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|pfound
operator|==
name|NULL
condition|)
block|{
comment|/* First nonexact match found.  */
name|pfound
operator|=
name|p
expr_stmt|;
name|indfound
operator|=
name|option_index
expr_stmt|;
block|}
else|else
comment|/* Second or later nonexact match found.  */
name|ambig
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ambig
operator|&&
operator|!
name|exact
condition|)
block|{
if|if
condition|(
name|opterr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: option `%s' is ambiguous\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|nextchar
operator|+=
name|strlen
argument_list|(
name|nextchar
argument_list|)
expr_stmt|;
name|optind
operator|++
expr_stmt|;
name|optopt
operator|=
literal|0
expr_stmt|;
return|return
literal|'?'
return|;
block|}
if|if
condition|(
name|pfound
operator|!=
name|NULL
condition|)
block|{
name|option_index
operator|=
name|indfound
expr_stmt|;
name|optind
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|nameend
condition|)
block|{
comment|/* Don't test has_arg with>, because some C compilers don't 		 allow it to be used on enums.  */
if|if
condition|(
name|pfound
operator|->
name|has_arg
condition|)
name|optarg
operator|=
name|nameend
operator|+
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|opterr
condition|)
if|if
condition|(
name|argv
index|[
name|optind
operator|-
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
comment|/* --option */
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: option `--%s' doesn't allow an argument\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|pfound
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
comment|/* +option or -option */
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: option `%c%s' doesn't allow an argument\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|optind
operator|-
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|pfound
operator|->
name|name
argument_list|)
expr_stmt|;
name|nextchar
operator|+=
name|strlen
argument_list|(
name|nextchar
argument_list|)
expr_stmt|;
name|optopt
operator|=
name|pfound
operator|->
name|val
expr_stmt|;
return|return
literal|'?'
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|pfound
operator|->
name|has_arg
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
name|optarg
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
else|else
block|{
if|if
condition|(
name|opterr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: option `%s' requires an argument\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|optind
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|nextchar
operator|+=
name|strlen
argument_list|(
name|nextchar
argument_list|)
expr_stmt|;
name|optopt
operator|=
name|pfound
operator|->
name|val
expr_stmt|;
return|return
name|optstring
index|[
literal|0
index|]
operator|==
literal|':'
condition|?
literal|':'
else|:
literal|'?'
return|;
block|}
block|}
name|nextchar
operator|+=
name|strlen
argument_list|(
name|nextchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|longind
operator|!=
name|NULL
condition|)
operator|*
name|longind
operator|=
name|option_index
expr_stmt|;
if|if
condition|(
name|pfound
operator|->
name|flag
condition|)
block|{
operator|*
operator|(
name|pfound
operator|->
name|flag
operator|)
operator|=
name|pfound
operator|->
name|val
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|pfound
operator|->
name|val
return|;
block|}
comment|/* Can't find it as a long option.  If this is not getopt_long_only, 	 or the option starts with '--' or is not a valid short 	 option, then it's an error. 	 Otherwise interpret it as a short option.  */
if|if
condition|(
operator|!
name|long_only
operator|||
name|argv
index|[
name|optind
index|]
index|[
literal|1
index|]
operator|==
literal|'-'
operator|||
name|my_index
argument_list|(
name|optstring
argument_list|,
operator|*
name|nextchar
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|opterr
condition|)
block|{
if|if
condition|(
name|argv
index|[
name|optind
index|]
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
comment|/* --option */
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: unrecognized option `--%s'\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|nextchar
argument_list|)
expr_stmt|;
else|else
comment|/* +option or -option */
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: unrecognized option `%c%s'\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
argument_list|,
name|nextchar
argument_list|)
expr_stmt|;
block|}
name|nextchar
operator|=
operator|(
name|char
operator|*
operator|)
literal|""
expr_stmt|;
name|optind
operator|++
expr_stmt|;
name|optopt
operator|=
literal|0
expr_stmt|;
return|return
literal|'?'
return|;
block|}
block|}
comment|/* Look at and handle the next short option-character.  */
block|{
name|char
name|c
init|=
operator|*
name|nextchar
operator|++
decl_stmt|;
name|char
modifier|*
name|temp
init|=
name|my_index
argument_list|(
name|optstring
argument_list|,
name|c
argument_list|)
decl_stmt|;
comment|/* Increment `optind' when we start to process its last character.  */
if|if
condition|(
operator|*
name|nextchar
operator|==
literal|'\0'
condition|)
operator|++
name|optind
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
operator|||
name|c
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|opterr
condition|)
block|{
if|if
condition|(
name|posixly_correct
condition|)
comment|/* 1003.2 specifies the format of this message.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: illegal option -- %c\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: invalid option -- %c\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|optopt
operator|=
name|c
expr_stmt|;
return|return
literal|'?'
return|;
block|}
comment|/* Convenience. Treat POSIX -W foo same as long option --foo */
if|if
condition|(
name|temp
index|[
literal|0
index|]
operator|==
literal|'W'
operator|&&
name|temp
index|[
literal|1
index|]
operator|==
literal|';'
condition|)
block|{
name|char
modifier|*
name|nameend
decl_stmt|;
specifier|const
name|struct
name|option
modifier|*
name|p
decl_stmt|;
specifier|const
name|struct
name|option
modifier|*
name|pfound
init|=
name|NULL
decl_stmt|;
name|int
name|exact
init|=
literal|0
decl_stmt|;
name|int
name|ambig
init|=
literal|0
decl_stmt|;
name|int
name|indfound
init|=
literal|0
decl_stmt|;
name|int
name|option_index
decl_stmt|;
comment|/* This is an option that requires an argument.  */
if|if
condition|(
operator|*
name|nextchar
operator|!=
literal|'\0'
condition|)
block|{
name|optarg
operator|=
name|nextchar
expr_stmt|;
comment|/* If we end this ARGV-element by taking the rest as an arg, 	       we must advance to the next element now.  */
name|optind
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
block|{
if|if
condition|(
name|opterr
condition|)
block|{
comment|/* 1003.2 specifies the format of this message.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: option requires an argument -- %c\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|optopt
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|optstring
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
name|c
operator|=
literal|':'
expr_stmt|;
else|else
name|c
operator|=
literal|'?'
expr_stmt|;
return|return
name|c
return|;
block|}
else|else
comment|/* We already incremented `optind' once; 	     increment it again when taking next ARGV-elt as argument.  */
name|optarg
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
comment|/* optarg is now the argument, see if it's in the 	   table of longopts.  */
for|for
control|(
name|nextchar
operator|=
name|nameend
operator|=
name|optarg
init|;
operator|*
name|nameend
operator|&&
operator|*
name|nameend
operator|!=
literal|'='
condition|;
name|nameend
operator|++
control|)
comment|/* Do nothing.  */
empty_stmt|;
comment|/* Test all long options for either exact match 	   or abbreviated matches.  */
for|for
control|(
name|p
operator|=
name|longopts
operator|,
name|option_index
operator|=
literal|0
init|;
name|p
operator|->
name|name
condition|;
name|p
operator|++
operator|,
name|option_index
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|nextchar
argument_list|,
name|nameend
operator|-
name|nextchar
argument_list|)
condition|)
block|{
if|if
condition|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|nameend
operator|-
name|nextchar
argument_list|)
operator|==
name|strlen
argument_list|(
name|p
operator|->
name|name
argument_list|)
condition|)
block|{
comment|/* Exact match found.  */
name|pfound
operator|=
name|p
expr_stmt|;
name|indfound
operator|=
name|option_index
expr_stmt|;
name|exact
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|pfound
operator|==
name|NULL
condition|)
block|{
comment|/* First nonexact match found.  */
name|pfound
operator|=
name|p
expr_stmt|;
name|indfound
operator|=
name|option_index
expr_stmt|;
block|}
else|else
comment|/* Second or later nonexact match found.  */
name|ambig
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ambig
operator|&&
operator|!
name|exact
condition|)
block|{
if|if
condition|(
name|opterr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: option `-W %s' is ambiguous\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|nextchar
operator|+=
name|strlen
argument_list|(
name|nextchar
argument_list|)
expr_stmt|;
name|optind
operator|++
expr_stmt|;
return|return
literal|'?'
return|;
block|}
if|if
condition|(
name|pfound
operator|!=
name|NULL
condition|)
block|{
name|option_index
operator|=
name|indfound
expr_stmt|;
if|if
condition|(
operator|*
name|nameend
condition|)
block|{
comment|/* Don't test has_arg with>, because some C compilers don't 		   allow it to be used on enums.  */
if|if
condition|(
name|pfound
operator|->
name|has_arg
condition|)
name|optarg
operator|=
name|nameend
operator|+
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|opterr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"\ %s: option `-W %s' doesn't allow an argument\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|pfound
operator|->
name|name
argument_list|)
expr_stmt|;
name|nextchar
operator|+=
name|strlen
argument_list|(
name|nextchar
argument_list|)
expr_stmt|;
return|return
literal|'?'
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|pfound
operator|->
name|has_arg
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
name|optarg
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
else|else
block|{
if|if
condition|(
name|opterr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: option `%s' requires an argument\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|optind
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|nextchar
operator|+=
name|strlen
argument_list|(
name|nextchar
argument_list|)
expr_stmt|;
return|return
name|optstring
index|[
literal|0
index|]
operator|==
literal|':'
condition|?
literal|':'
else|:
literal|'?'
return|;
block|}
block|}
name|nextchar
operator|+=
name|strlen
argument_list|(
name|nextchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|longind
operator|!=
name|NULL
condition|)
operator|*
name|longind
operator|=
name|option_index
expr_stmt|;
if|if
condition|(
name|pfound
operator|->
name|flag
condition|)
block|{
operator|*
operator|(
name|pfound
operator|->
name|flag
operator|)
operator|=
name|pfound
operator|->
name|val
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|pfound
operator|->
name|val
return|;
block|}
name|nextchar
operator|=
name|NULL
expr_stmt|;
return|return
literal|'W'
return|;
comment|/* Let the application handle it.   */
block|}
if|if
condition|(
name|temp
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|temp
index|[
literal|2
index|]
operator|==
literal|':'
condition|)
block|{
comment|/* This is an option that accepts an argument optionally.  */
if|if
condition|(
operator|*
name|nextchar
operator|!=
literal|'\0'
condition|)
block|{
name|optarg
operator|=
name|nextchar
expr_stmt|;
name|optind
operator|++
expr_stmt|;
block|}
else|else
name|optarg
operator|=
name|NULL
expr_stmt|;
name|nextchar
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* This is an option that requires an argument.  */
if|if
condition|(
operator|*
name|nextchar
operator|!=
literal|'\0'
condition|)
block|{
name|optarg
operator|=
name|nextchar
expr_stmt|;
comment|/* If we end this ARGV-element by taking the rest as an arg, 		   we must advance to the next element now.  */
name|optind
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
block|{
if|if
condition|(
name|opterr
condition|)
block|{
comment|/* 1003.2 specifies the format of this message.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: option requires an argument -- %c\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|optopt
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|optstring
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
name|c
operator|=
literal|':'
expr_stmt|;
else|else
name|c
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
comment|/* We already incremented `optind' once; 		 increment it again when taking next ARGV-elt as argument.  */
name|optarg
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
name|nextchar
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
block|}
end_function

begin_function
name|int
name|getopt
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|optstring
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
specifier|const
modifier|*
name|argv
decl_stmt|;
specifier|const
name|char
modifier|*
name|optstring
decl_stmt|;
block|{
return|return
name|_getopt_internal
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|optstring
argument_list|,
operator|(
specifier|const
expr|struct
name|option
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Not ELIDE_CODE.  */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_comment
comment|/* Compile with -DTEST to make an executable for use in testing    the above definition of `getopt'.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|digit_optind
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|this_option_optind
init|=
name|optind
condition|?
name|optind
else|:
literal|1
decl_stmt|;
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"abc:d:0123456789"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
break|break;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|digit_optind
operator|!=
literal|0
operator|&&
name|digit_optind
operator|!=
name|this_option_optind
condition|)
name|printf
argument_list|(
literal|"digits occur in two different argv-elements.\n"
argument_list|)
expr_stmt|;
name|digit_optind
operator|=
name|this_option_optind
expr_stmt|;
name|printf
argument_list|(
literal|"option %c\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|printf
argument_list|(
literal|"option a\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|printf
argument_list|(
literal|"option b\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|printf
argument_list|(
literal|"option c with value `%s'\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"?? getopt returned character code 0%o ??\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|printf
argument_list|(
literal|"non-option ARGV-elements: "
argument_list|)
expr_stmt|;
while|while
condition|(
name|optind
operator|<
name|argc
condition|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|argv
index|[
name|optind
operator|++
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST */
end_comment

end_unit

