begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* IBM S/390-specific support for 32-bit ELF    Copyright 2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by Carl B. Pedersen and Martin Schwidefsky.     This file is part of BFD, the Binary File Descriptor library.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_decl_stmt
specifier|static
name|reloc_howto_type
modifier|*
name|elf_s390_reloc_type_lookup
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_reloc_code_real_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_s390_info_to_howto
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_s390_is_local_label_name
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|link_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elf_s390_link_hash_table_create
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|create_got_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_s390_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_s390_copy_indirect_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_s390_check_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asection
modifier|*
name|elf_s390_gc_mark_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_s390_gc_sweep_hook
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|asection
operator|*
operator|,
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_s390_adjust_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|allocate_dynrelocs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|readonly_dynrelocs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_s390_size_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_s390_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|Elf_Internal_Rela
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_s390_finish_dynamic_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|elf_link_hash_entry
operator|*
operator|,
name|Elf_Internal_Sym
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|elf_reloc_type_class
name|elf_s390_reloc_type_class
name|PARAMS
argument_list|(
operator|(
specifier|const
name|Elf_Internal_Rela
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_s390_finish_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_s390_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_s390_grok_prstatus
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|Elf_Internal_Note
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|USE_RELA
value|1
end_define

begin_comment
comment|/* We want RELA relocations, not REL.  */
end_comment

begin_include
include|#
directive|include
file|"elf/s390.h"
end_include

begin_comment
comment|/* The relocation "howto" table.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf_howto_table
index|[]
init|=
block|{
name|HOWTO
argument_list|(
name|R_390_NONE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|0
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_dont
argument_list|,
comment|/* complain_on_overflow */
name|bfd_elf_generic_reloc
argument_list|,
comment|/* special_function */
literal|"R_390_NONE"
argument_list|,
comment|/* name */
name|false
argument_list|,
comment|/* partial_inplace */
literal|0
argument_list|,
comment|/* src_mask */
literal|0
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_390_8
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_390_8"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x000000ff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_390_12
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|12
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_390_12"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000fff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_390_16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_390_16"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_390_32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_390_32"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_390_PC32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_390_PC32"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_390_GOT12
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|12
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_390_GOT12"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x00000fff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_390_GOT32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_390_GOT32"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_390_PLT32
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_390_PLT32"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_390_COPY
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_390_COPY"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_390_GLOB_DAT
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_390_GLOB_DAT"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_390_JMP_SLOT
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_390_JMP_SLOT"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_390_RELATIVE
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_390_RELATIVE"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_390_GOTOFF
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_390_GOTOFF"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_390_GOTPC
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_390_GOTPC"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_390_GOT16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_390_GOT16"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x0000ffff
argument_list|,
name|false
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_390_PC16
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_390_PC16"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x0000ffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_390_PC16DBL
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_390_PC16DBL"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x0000ffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_390_PLT16DBL
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|16
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_390_PLT16DBL"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0x0000ffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_390_PC32DBL
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_390_PC32DBL"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_390_PLT32DBL
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_390_PLT32DBL"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_390_GOTPCDBL
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_390_GOTPCDBL"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|true
argument_list|)
block|,
name|HOWTO
argument_list|(
name|R_390_GOTENT
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|32
argument_list|,
name|true
argument_list|,
literal|0
argument_list|,
name|complain_overflow_bitfield
argument_list|,
name|bfd_elf_generic_reloc
argument_list|,
literal|"R_390_GOTENT"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0xffffffff
argument_list|,
name|true
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* GNU extension to record C++ vtable hierarchy.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf32_s390_vtinherit_howto
init|=
name|HOWTO
argument_list|(
name|R_390_GNU_VTINHERIT
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|NULL
argument_list|,
literal|"R_390_GNU_VTINHERIT"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|elf32_s390_vtentry_howto
init|=
name|HOWTO
argument_list|(
name|R_390_GNU_VTENTRY
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
name|complain_overflow_dont
argument_list|,
name|_bfd_elf_rel_vtable_reloc_fn
argument_list|,
literal|"R_390_GNU_VTENTRY"
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|false
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|reloc_howto_type
modifier|*
name|elf_s390_reloc_type_lookup
parameter_list|(
name|abfd
parameter_list|,
name|code
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|BFD_RELOC_NONE
case|:
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_390_NONE
index|]
return|;
case|case
name|BFD_RELOC_8
case|:
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_390_8
index|]
return|;
case|case
name|BFD_RELOC_390_12
case|:
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_390_12
index|]
return|;
case|case
name|BFD_RELOC_16
case|:
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_390_16
index|]
return|;
case|case
name|BFD_RELOC_32
case|:
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_390_32
index|]
return|;
case|case
name|BFD_RELOC_CTOR
case|:
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_390_32
index|]
return|;
case|case
name|BFD_RELOC_32_PCREL
case|:
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_390_PC32
index|]
return|;
case|case
name|BFD_RELOC_390_GOT12
case|:
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_390_GOT12
index|]
return|;
case|case
name|BFD_RELOC_32_GOT_PCREL
case|:
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_390_GOT32
index|]
return|;
case|case
name|BFD_RELOC_390_PLT32
case|:
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_390_PLT32
index|]
return|;
case|case
name|BFD_RELOC_390_COPY
case|:
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_390_COPY
index|]
return|;
case|case
name|BFD_RELOC_390_GLOB_DAT
case|:
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_390_GLOB_DAT
index|]
return|;
case|case
name|BFD_RELOC_390_JMP_SLOT
case|:
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_390_JMP_SLOT
index|]
return|;
case|case
name|BFD_RELOC_390_RELATIVE
case|:
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_390_RELATIVE
index|]
return|;
case|case
name|BFD_RELOC_32_GOTOFF
case|:
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_390_GOTOFF
index|]
return|;
case|case
name|BFD_RELOC_390_GOTPC
case|:
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_390_GOTPC
index|]
return|;
case|case
name|BFD_RELOC_390_GOT16
case|:
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_390_GOT16
index|]
return|;
case|case
name|BFD_RELOC_16_PCREL
case|:
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_390_PC16
index|]
return|;
case|case
name|BFD_RELOC_390_PC16DBL
case|:
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_390_PC16DBL
index|]
return|;
case|case
name|BFD_RELOC_390_PLT16DBL
case|:
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_390_PLT16DBL
index|]
return|;
case|case
name|BFD_RELOC_390_PC32DBL
case|:
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_390_PC32DBL
index|]
return|;
case|case
name|BFD_RELOC_390_PLT32DBL
case|:
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_390_PLT32DBL
index|]
return|;
case|case
name|BFD_RELOC_390_GOTPCDBL
case|:
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_390_GOTPCDBL
index|]
return|;
case|case
name|BFD_RELOC_390_GOTENT
case|:
return|return
operator|&
name|elf_howto_table
index|[
operator|(
name|int
operator|)
name|R_390_GOTENT
index|]
return|;
case|case
name|BFD_RELOC_VTABLE_INHERIT
case|:
return|return
operator|&
name|elf32_s390_vtinherit_howto
return|;
case|case
name|BFD_RELOC_VTABLE_ENTRY
case|:
return|return
operator|&
name|elf32_s390_vtentry_howto
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* We need to use ELF32_R_TYPE so we have our own copy of this function,    and elf32-s390.c has its own copy.  */
end_comment

begin_function
specifier|static
name|void
name|elf_s390_info_to_howto
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_390_GNU_VTINHERIT
case|:
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf32_s390_vtinherit_howto
expr_stmt|;
break|break;
case|case
name|R_390_GNU_VTENTRY
case|:
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf32_s390_vtentry_howto
expr_stmt|;
break|break;
default|default:
name|BFD_ASSERT
argument_list|(
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
operator|<
operator|(
name|unsigned
name|int
operator|)
name|R_390_max
argument_list|)
expr_stmt|;
name|cache_ptr
operator|->
name|howto
operator|=
operator|&
name|elf_howto_table
index|[
name|ELF32_R_TYPE
argument_list|(
name|dst
operator|->
name|r_info
argument_list|)
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|boolean
name|elf_s390_is_local_label_name
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'X'
operator|||
name|name
index|[
literal|1
index|]
operator|==
literal|'L'
operator|)
condition|)
return|return
name|true
return|;
return|return
name|_bfd_elf_is_local_label_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Functions for the 390 ELF linker.  */
end_comment

begin_comment
comment|/* The name of the dynamic interpreter.  This is put in the .interp    section.  */
end_comment

begin_define
define|#
directive|define
name|ELF_DYNAMIC_INTERPRETER
value|"/usr/lib/ld.so.1"
end_define

begin_comment
comment|/* The size in bytes of the first entry in the procedure linkage table.  */
end_comment

begin_define
define|#
directive|define
name|PLT_FIRST_ENTRY_SIZE
value|32
end_define

begin_comment
comment|/* The size in bytes of an entry in the procedure linkage table.  */
end_comment

begin_define
define|#
directive|define
name|PLT_ENTRY_SIZE
value|32
end_define

begin_define
define|#
directive|define
name|GOT_ENTRY_SIZE
value|4
end_define

begin_comment
comment|/* The first three entries in a procedure linkage table are reserved,    and the initial contents are unimportant (we zero them out).    Subsequent entries look like this.  See the SVR4 ABI 386    supplement to see how this works.  */
end_comment

begin_comment
comment|/* For the s390, simple addr offset can only be 0 - 4096.    To use the full 2 GB address space, several instructions    are needed to load an address in a register and execute    a branch( or just saving the address)     Furthermore, only r 0 and 1 are free to use!!!  */
end_comment

begin_comment
comment|/* The first 3 words in the GOT are then reserved.    Word 0 is the address of the dynamic table.    Word 1 is a pointer to a structure describing the object    Word 2 is used to point to the loader entry address.     The code for position independand PLT entries looks like this:     r12 holds addr of the current GOT at entry to the PLT     The GOT holds the address in the PLT to be executed.    The loader then gets:    24(15) =  Pointer to the structure describing the object.    28(15) =  Offset in symbol table     The loader  must  then find the module where the function is    and insert the address in the GOT.    Note: 390 can only address +- 64 K relative.         We check if offset> 65536, then make a relative branch -64xxx         back to a previous defined branch  PLT1: BASR 1,0         # 2 bytes       L    1,22(1)     # 4 bytes  Load offset in GOT in r 1       L    1,(1,12)    # 4 bytes  Load address from GOT in r1       BCR  15,1        # 2 bytes  Jump to address RET1: BASR 1,0         # 2 bytes  Return from GOT 1st time       L    1,14(1)     # 4 bytes  Load offset in symol table in r1       BRC  15,-x       # 4 bytes  Jump to start of PLT       .word 0          # 2 bytes filler       .long ?          # 4 bytes  offset in GOT       .long ?          # 4 bytes  offset into symbol table    This was the general case. There are two additional, optimizes PLT   definitions. One for GOT offsets< 4096 and one for GOT offsets< 32768.   First the one for GOT offsets< 4096:  PLT1: L    1,<offset>(12) # 4 bytes  Load address from GOT in R1       BCR  15,1           # 2 bytes  Jump to address       .word 0,0,0         # 6 bytes  filler RET1: BASR 1,0            # 2 bytes  Return from GOT 1st time       L    1,14(1)        # 4 bytes  Load offset in symbol table in r1       BRC  15,-x          # 4 bytes  Jump to start of PLT       .word 0,0,0         # 6 bytes  filler       .long ?             # 4 bytes  offset into symbol table    Second the one for GOT offsets< 32768:  PLT1: LHI  1,<offset>     # 4 bytes  Load offset in GOT to r1       L    1,(1,12)       # 4 bytes  Load address from GOT to r1       BCR  15,1           # 2 bytes  Jump to address       .word 0             # 2 bytes  filler RET1: BASR 1,0            # 2 bytes  Return from GOT 1st time       L    1,14(1)        # 4 bytes  Load offset in symbol table in r1       BRC  15,-x          # 4 bytes  Jump to start of PLT       .word 0,0,0         # 6 bytes  filler       .long ?             # 4 bytes  offset into symbol table  Total = 32 bytes per PLT entry     The code for static build PLT entries looks like this:  PLT1: BASR 1,0         # 2 bytes       L    1,22(1)     # 4 bytes  Load address of GOT entry       L    1,0(0,1)    # 4 bytes  Load address from GOT in r1       BCR  15,1        # 2 bytes  Jump to address RET1: BASR 1,0         # 2 bytes  Return from GOT 1st time       L    1,14(1)     # 4 bytes  Load offset in symbol table in r1       BRC  15,-x       # 4 bytes  Jump to start of PLT       .word 0          # 2 bytes  filler       .long ?          # 4 bytes  address of GOT entry       .long ?          # 4 bytes  offset into symbol table  */
end_comment

begin_define
define|#
directive|define
name|PLT_PIC_ENTRY_WORD0
value|0x0d105810
end_define

begin_define
define|#
directive|define
name|PLT_PIC_ENTRY_WORD1
value|0x10165811
end_define

begin_define
define|#
directive|define
name|PLT_PIC_ENTRY_WORD2
value|0xc00007f1
end_define

begin_define
define|#
directive|define
name|PLT_PIC_ENTRY_WORD3
value|0x0d105810
end_define

begin_define
define|#
directive|define
name|PLT_PIC_ENTRY_WORD4
value|0x100ea7f4
end_define

begin_define
define|#
directive|define
name|PLT_PIC12_ENTRY_WORD0
value|0x5810c000
end_define

begin_define
define|#
directive|define
name|PLT_PIC12_ENTRY_WORD1
value|0x07f10000
end_define

begin_define
define|#
directive|define
name|PLT_PIC12_ENTRY_WORD2
value|0x00000000
end_define

begin_define
define|#
directive|define
name|PLT_PIC12_ENTRY_WORD3
value|0x0d105810
end_define

begin_define
define|#
directive|define
name|PLT_PIC12_ENTRY_WORD4
value|0x100ea7f4
end_define

begin_define
define|#
directive|define
name|PLT_PIC16_ENTRY_WORD0
value|0xa7180000
end_define

begin_define
define|#
directive|define
name|PLT_PIC16_ENTRY_WORD1
value|0x5811c000
end_define

begin_define
define|#
directive|define
name|PLT_PIC16_ENTRY_WORD2
value|0x07f10000
end_define

begin_define
define|#
directive|define
name|PLT_PIC16_ENTRY_WORD3
value|0x0d105810
end_define

begin_define
define|#
directive|define
name|PLT_PIC16_ENTRY_WORD4
value|0x100ea7f4
end_define

begin_define
define|#
directive|define
name|PLT_ENTRY_WORD0
value|0x0d105810
end_define

begin_define
define|#
directive|define
name|PLT_ENTRY_WORD1
value|0x10165810
end_define

begin_define
define|#
directive|define
name|PLT_ENTRY_WORD2
value|0x100007f1
end_define

begin_define
define|#
directive|define
name|PLT_ENTRY_WORD3
value|0x0d105810
end_define

begin_define
define|#
directive|define
name|PLT_ENTRY_WORD4
value|0x100ea7f4
end_define

begin_comment
comment|/* The first PLT entry pushes the offset into the symbol table    from R1 onto the stack at 8(15) and the loader object info    at 12(15), loads the loader address in R1 and jumps to it.  */
end_comment

begin_comment
comment|/* The first entry in the PLT for PIC code:  PLT0:    ST   1,28(15)  # R1 has offset into symbol table    L    1,4(12)   # Get loader ino(object struct address)    ST   1,24(15)  # Store address    L    1,8(12)   # Entry address of loader in R1    BR   1         # Jump to loader     The first entry in the PLT for static code:  PLT0:    ST   1,28(15)      # R1 has offset into symbol table    BASR 1,0    L    1,18(0,1)     # Get address of GOT    MVC  24(4,15),4(1) # Move loader ino to stack    L    1,8(1)        # Get address of loader    BR   1             # Jump to loader    .word 0            # filler    .long got          # address of GOT  */
end_comment

begin_define
define|#
directive|define
name|PLT_PIC_FIRST_ENTRY_WORD0
value|0x5010f01c
end_define

begin_define
define|#
directive|define
name|PLT_PIC_FIRST_ENTRY_WORD1
value|0x5810c004
end_define

begin_define
define|#
directive|define
name|PLT_PIC_FIRST_ENTRY_WORD2
value|0x5010f018
end_define

begin_define
define|#
directive|define
name|PLT_PIC_FIRST_ENTRY_WORD3
value|0x5810c008
end_define

begin_define
define|#
directive|define
name|PLT_PIC_FIRST_ENTRY_WORD4
value|0x07f10000
end_define

begin_define
define|#
directive|define
name|PLT_FIRST_ENTRY_WORD0
value|0x5010f01c
end_define

begin_define
define|#
directive|define
name|PLT_FIRST_ENTRY_WORD1
value|0x0d105810
end_define

begin_define
define|#
directive|define
name|PLT_FIRST_ENTRY_WORD2
value|0x1012D203
end_define

begin_define
define|#
directive|define
name|PLT_FIRST_ENTRY_WORD3
value|0xf0181004
end_define

begin_define
define|#
directive|define
name|PLT_FIRST_ENTRY_WORD4
value|0x58101008
end_define

begin_define
define|#
directive|define
name|PLT_FIRST_ENTRY_WORD5
value|0x07f10000
end_define

begin_comment
comment|/* The s390 linker needs to keep track of the number of relocs that it    decides to copy as dynamic relocs in check_relocs for each symbol.    This is so that it can later discard them if they are found to be    unnecessary.  We store the information in a field extending the    regular ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|elf_s390_dyn_relocs
block|{
name|struct
name|elf_s390_dyn_relocs
modifier|*
name|next
decl_stmt|;
comment|/* The input section of the reloc.  */
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* Total number of relocs copied for the input section.  */
name|bfd_size_type
name|count
decl_stmt|;
comment|/* Number of pc-relative relocs copied for the input section.  */
name|bfd_size_type
name|pc_count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* s390 ELF linker hash entry.  */
end_comment

begin_struct
struct|struct
name|elf_s390_link_hash_entry
block|{
name|struct
name|elf_link_hash_entry
name|elf
decl_stmt|;
comment|/* Track dynamic relocs copied for this symbol.  */
name|struct
name|elf_s390_dyn_relocs
modifier|*
name|dyn_relocs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* s390 ELF linker hash table.  */
end_comment

begin_struct
struct|struct
name|elf_s390_link_hash_table
block|{
name|struct
name|elf_link_hash_table
name|elf
decl_stmt|;
comment|/* Short-cuts to get to dynamic linker sections.  */
name|asection
modifier|*
name|sgot
decl_stmt|;
name|asection
modifier|*
name|sgotplt
decl_stmt|;
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|asection
modifier|*
name|splt
decl_stmt|;
name|asection
modifier|*
name|srelplt
decl_stmt|;
name|asection
modifier|*
name|sdynbss
decl_stmt|;
name|asection
modifier|*
name|srelbss
decl_stmt|;
comment|/* Small local sym to section mapping cache.  */
name|struct
name|sym_sec_cache
name|sym_sec
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Get the s390 ELF linker hash table from a link_info structure.  */
end_comment

begin_define
define|#
directive|define
name|elf_s390_hash_table
parameter_list|(
name|p
parameter_list|)
define|\
value|((struct elf_s390_link_hash_table *) ((p)->hash))
end_define

begin_comment
comment|/* Create an entry in an s390 ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|link_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|entry
operator|=
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_s390_link_hash_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|entry
return|;
block|}
comment|/* Call the allocation method of the superclass.  */
name|entry
operator|=
name|_bfd_elf_link_hash_newfunc
argument_list|(
name|entry
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_s390_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf_s390_link_hash_entry
operator|*
operator|)
name|entry
expr_stmt|;
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|entry
return|;
block|}
end_function

begin_comment
comment|/* Create an s390 ELF linker hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|elf_s390_link_hash_table_create
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|elf_s390_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|elf_s390_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|elf_s390_link_hash_table
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
operator|&
name|ret
operator|->
name|elf
argument_list|,
name|abfd
argument_list|,
name|link_hash_newfunc
argument_list|)
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ret
operator|->
name|sgot
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|sgotplt
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|srelgot
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|splt
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|srelplt
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|sdynbss
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|srelbss
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|sym_sec
operator|.
name|abfd
operator|=
name|NULL
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|elf
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Create .got, .gotplt, and .rela.got sections in DYNOBJ, and set up    shortcuts to them in our hash table.  */
end_comment

begin_function
specifier|static
name|boolean
name|create_got_section
parameter_list|(
name|dynobj
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|elf_s390_link_hash_table
modifier|*
name|htab
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_elf_create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
name|htab
operator|=
name|elf_s390_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sgot
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sgotplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".got.plt"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|sgot
operator|||
operator|!
name|htab
operator|->
name|sgotplt
condition|)
name|abort
argument_list|()
expr_stmt|;
name|htab
operator|->
name|srelgot
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
literal|".rela.got"
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|srelgot
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|srelgot
argument_list|,
operator|(
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator||
name|SEC_READONLY
operator|)
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|htab
operator|->
name|srelgot
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Create .plt, .rela.plt, .got, .got.plt, .rela.got, .dynbss, and    .rela.bss sections in DYNOBJ, and set up shortcuts to them in our    hash table.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_s390_create_dynamic_sections
parameter_list|(
name|dynobj
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|elf_s390_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|elf_s390_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|sgot
operator|&&
operator|!
name|create_got_section
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|_bfd_elf_create_dynamic_sections
argument_list|(
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
name|htab
operator|->
name|splt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|srelplt
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.plt"
argument_list|)
expr_stmt|;
name|htab
operator|->
name|sdynbss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynbss"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
name|htab
operator|->
name|srelbss
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".rela.bss"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|htab
operator|->
name|splt
operator|||
operator|!
name|htab
operator|->
name|srelplt
operator|||
operator|!
name|htab
operator|->
name|sdynbss
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|!
name|htab
operator|->
name|srelbss
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Copy the extra info we tack onto an elf_link_hash_entry.  */
end_comment

begin_function
specifier|static
name|void
name|elf_s390_copy_indirect_symbol
parameter_list|(
name|dir
parameter_list|,
name|ind
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|dir
decl_stmt|,
decl|*
name|ind
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|elf_s390_link_hash_entry
modifier|*
name|edir
decl_stmt|,
modifier|*
name|eind
decl_stmt|;
name|edir
operator|=
operator|(
expr|struct
name|elf_s390_link_hash_entry
operator|*
operator|)
name|dir
expr_stmt|;
name|eind
operator|=
operator|(
expr|struct
name|elf_s390_link_hash_entry
operator|*
operator|)
name|ind
expr_stmt|;
if|if
condition|(
name|eind
operator|->
name|dyn_relocs
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|edir
operator|->
name|dyn_relocs
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_s390_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|elf_s390_dyn_relocs
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|ind
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Add reloc counts against the weak sym to the strong sym 	     list.  Merge any entries against the same section.  */
for|for
control|(
name|pp
operator|=
operator|&
name|eind
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|struct
name|elf_s390_dyn_relocs
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|edir
operator|->
name|dyn_relocs
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
if|if
condition|(
name|q
operator|->
name|sec
operator|==
name|p
operator|->
name|sec
condition|)
block|{
name|q
operator|->
name|pc_count
operator|+=
name|p
operator|->
name|pc_count
expr_stmt|;
name|q
operator|->
name|count
operator|+=
name|p
operator|->
name|count
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|edir
operator|->
name|dyn_relocs
expr_stmt|;
block|}
name|edir
operator|->
name|dyn_relocs
operator|=
name|eind
operator|->
name|dyn_relocs
expr_stmt|;
name|eind
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
block|}
name|_bfd_elf_link_hash_copy_indirect
argument_list|(
name|dir
argument_list|,
name|ind
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Look through the relocs for a section during the first phase, and    allocate space in the global offset table or procedure linkage    table.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_s390_check_relocs
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|struct
name|elf_s390_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel_end
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
return|return
name|true
return|;
name|htab
operator|=
name|elf_s390_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|sreloc
operator|=
name|NULL
expr_stmt|;
name|rel_end
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|rel_end
condition|;
name|rel
operator|++
control|)
block|{
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|NUM_SHDR_ENTRIES
argument_list|(
name|symtab_hdr
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: bad symbol index: %d"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
name|h
operator|=
name|NULL
expr_stmt|;
else|else
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_390_GOT12
case|:
case|case
name|R_390_GOT16
case|:
case|case
name|R_390_GOT32
case|:
case|case
name|R_390_GOTENT
case|:
comment|/* This symbol requires a global offset table entry.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|h
operator|->
name|got
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
comment|/* This is a global offset table entry for a local symbol.  */
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
block|{
name|bfd_size_type
name|size
decl_stmt|;
name|size
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|size
operator|*=
sizeof|sizeof
argument_list|(
name|bfd_signed_vma
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
operator|(
operator|(
name|bfd_signed_vma
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|local_got_refcounts
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
operator|=
name|local_got_refcounts
expr_stmt|;
block|}
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Fall through */
case|case
name|R_390_GOTOFF
case|:
case|case
name|R_390_GOTPC
case|:
case|case
name|R_390_GOTPCDBL
case|:
if|if
condition|(
name|htab
operator|->
name|sgot
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|==
name|NULL
condition|)
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|create_got_section
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
block|}
break|break;
case|case
name|R_390_PLT16DBL
case|:
case|case
name|R_390_PLT32DBL
case|:
case|case
name|R_390_PLT32
case|:
comment|/* This symbol requires a procedure linkage table entry.  We              actually build the entry in adjust_dynamic_symbol,              because this might be a case of linking PIC code which is              never referenced by a dynamic object, in which case we              don't need to generate a procedure linkage table entry              after all.  */
comment|/* If this is a local symbol, we resolve it directly without              creating a procedure linkage table entry.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
continue|continue;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|R_390_8
case|:
case|case
name|R_390_16
case|:
case|case
name|R_390_32
case|:
case|case
name|R_390_PC16
case|:
case|case
name|R_390_PC16DBL
case|:
case|case
name|R_390_PC32DBL
case|:
case|case
name|R_390_PC32
case|:
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|!
name|info
operator|->
name|shared
condition|)
block|{
comment|/* If this reloc is in a read-only section, we might 		 need a copy reloc.  We can't check reliably at this 		 stage whether the section is read-only, as input 		 sections have not yet been mapped to output sections. 		 Tentatively set the flag for now, and correct in 		 adjust_dynamic_symbol.  */
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_NON_GOT_REF
expr_stmt|;
comment|/* We may need a .plt entry if the function this reloc 		 refers to is in a shared lib.  */
name|h
operator|->
name|plt
operator|.
name|refcount
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* If we are creating a shared library, and this is a reloc 	     against a global symbol, or a non PC relative reloc 	     against a local symbol, then we need to copy the reloc 	     into the shared library.  However, if we are linking with 	     -Bsymbolic, we do not need to copy a reloc against a 	     global symbol which is defined in an object we are 	     including in the link (i.e., DEF_REGULAR is set).  At 	     this point we have not seen all the input files, so it is 	     possible that DEF_REGULAR is not set now but will be set 	     later (it is never cleared).  In case of a weak definition, 	     DEF_REGULAR may be cleared later by a strong definition in 	     a shared library. We account for that possibility below by 	     storing information in the relocs_copied field of the hash 	     table entry.  A similar situation occurs when creating 	     shared libraries and symbol visibility changes render the 	     symbol local.  	     If on the other hand, we are creating an executable, we 	     may need to keep relocations for symbols satisfied by a 	     dynamic library if we manage to avoid copy relocs for the 	     symbol.  */
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_390_PC16
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_390_PC16DBL
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_390_PC32DBL
operator|&&
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|!=
name|R_390_PC32
operator|)
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|struct
name|elf_s390_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|struct
name|elf_s390_dyn_relocs
modifier|*
modifier|*
name|head
decl_stmt|;
comment|/* We must copy these reloc types into the output file. 		 Create a reloc section in dynobj and make room for 		 this reloc.  */
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|name
operator|=
operator|(
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|,
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|rel_hdr
operator|.
name|sh_name
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
argument_list|,
name|name
operator|+
literal|5
argument_list|)
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: bad relocation section name `%s\'"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|==
name|NULL
condition|)
name|htab
operator|->
name|elf
operator|.
name|dynobj
operator|=
name|abfd
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
name|sreloc
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
block|{
name|flagword
name|flags
decl_stmt|;
name|sreloc
operator|=
name|bfd_make_section
argument_list|(
name|dynobj
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|flags
operator|=
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_READONLY
operator||
name|SEC_IN_MEMORY
operator||
name|SEC_LINKER_CREATED
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|SEC_ALLOC
operator||
name|SEC_LOAD
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|dynobj
argument_list|,
name|sreloc
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|sreloc
operator|=
name|sreloc
expr_stmt|;
block|}
comment|/* If this is a global symbol, we count the number of 		 relocations we need for this symbol.  */
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|head
operator|=
operator|&
operator|(
operator|(
expr|struct
name|elf_s390_link_hash_entry
operator|*
operator|)
name|h
operator|)
operator|->
name|dyn_relocs
expr_stmt|;
block|}
else|else
block|{
comment|/* Track dynamic relocs needed for local syms too. 		     We really need local syms available to do this 		     easily.  Oh well.  */
name|asection
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|bfd_section_from_r_symndx
argument_list|(
name|abfd
argument_list|,
operator|&
name|htab
operator|->
name|sym_sec
argument_list|,
name|sec
argument_list|,
name|r_symndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|head
operator|=
operator|(
operator|(
expr|struct
name|elf_s390_dyn_relocs
operator|*
operator|*
operator|)
operator|&
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
operator|)
expr_stmt|;
block|}
name|p
operator|=
operator|*
name|head
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
operator|->
name|sec
operator|!=
name|sec
condition|)
block|{
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
expr|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
operator|(
expr|struct
name|elf_s390_dyn_relocs
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|amt
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|p
operator|->
name|next
operator|=
operator|*
name|head
expr_stmt|;
operator|*
name|head
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|sec
operator|=
name|sec
expr_stmt|;
name|p
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pc_count
operator|=
literal|0
expr_stmt|;
block|}
name|p
operator|->
name|count
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_390_PC16
operator|||
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_390_PC16DBL
operator|||
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_390_PC32DBL
operator|||
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_390_PC32
condition|)
name|p
operator|->
name|pc_count
operator|+=
literal|1
expr_stmt|;
block|}
break|break;
comment|/* This relocation describes the C++ object vtable hierarchy. 	     Reconstruct it for later use during GC.  */
case|case
name|R_390_GNU_VTINHERIT
case|:
if|if
condition|(
operator|!
name|_bfd_elf32_gc_record_vtinherit
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
comment|/* This relocation describes which C++ vtable entries are actually 	     used.  Record for later use during GC.  */
case|case
name|R_390_GNU_VTENTRY
case|:
if|if
condition|(
operator|!
name|_bfd_elf32_gc_record_vtentry
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|h
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
condition|)
return|return
name|false
return|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return the section that should be marked against GC for a given    relocation.  */
end_comment

begin_function
specifier|static
name|asection
modifier|*
name|elf_s390_gc_mark_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|rel
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_390_GNU_VTINHERIT
case|:
case|case
name|R_390_GNU_VTENTRY
case|:
break|break;
default|default:
switch|switch
condition|(
name|h
operator|->
name|root
operator|.
name|type
condition|)
block|{
case|case
name|bfd_link_hash_defined
case|:
case|case
name|bfd_link_hash_defweak
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
return|;
case|case
name|bfd_link_hash_common
case|:
return|return
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|c
operator|.
name|p
operator|->
name|section
return|;
default|default:
break|break;
block|}
block|}
block|}
else|else
block|{
return|return
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|sym
operator|->
name|st_shndx
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Update the got entry reference counts for the section being removed.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_s390_gc_sweep_hook
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|local_got_refcounts
decl_stmt|;
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|,
modifier|*
name|relend
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|elf_section_data
argument_list|(
name|sec
argument_list|)
operator|->
name|local_dynrel
operator|=
name|NULL
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|local_got_refcounts
operator|=
name|elf_local_got_refcounts
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|rel
operator|=
name|relocs
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
switch|switch
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_390_GOT12
case|:
case|case
name|R_390_GOT16
case|:
case|case
name|R_390_GOT32
case|:
case|case
name|R_390_GOTOFF
case|:
case|case
name|R_390_GOTPC
case|:
case|case
name|R_390_GOTPCDBL
case|:
case|case
name|R_390_GOTENT
case|:
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|got
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|local_got_refcounts
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|>
literal|0
condition|)
name|local_got_refcounts
index|[
name|r_symndx
index|]
operator|-=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|R_390_8
case|:
case|case
name|R_390_12
case|:
case|case
name|R_390_16
case|:
case|case
name|R_390_32
case|:
case|case
name|R_390_PC16
case|:
case|case
name|R_390_PC16DBL
case|:
case|case
name|R_390_PC32DBL
case|:
case|case
name|R_390_PC32
case|:
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|struct
name|elf_s390_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf_s390_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|elf_s390_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|plt
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf_s390_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
name|pp
operator|=
operator|&
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|sec
operator|==
name|sec
condition|)
block|{
if|if
condition|(
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_390_PC16
operator|||
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_390_PC16DBL
operator|||
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_390_PC32DBL
operator|||
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
operator|==
name|R_390_PC32
condition|)
name|p
operator|->
name|pc_count
operator|-=
literal|1
expr_stmt|;
name|p
operator|->
name|count
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|R_390_PLT16DBL
case|:
case|case
name|R_390_PLT32DBL
case|:
case|case
name|R_390_PLT32
case|:
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|>=
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
name|h
operator|->
name|plt
operator|.
name|refcount
operator|-=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Adjust a symbol defined by a dynamic object and referenced by a    regular object.  The current definition is in some section of the    dynamic object, but we're not including those sections.  We have to    change the definition to something the rest of the link can    understand.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_s390_adjust_dynamic_symbol
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
block|{
name|struct
name|elf_s390_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|elf_s390_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf_s390_dyn_relocs
modifier|*
name|p
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|power_of_two
decl_stmt|;
comment|/* If this is a function, put it in the procedure linkage table.  We      will fill in the contents of the procedure linkage table later      (although we could actually do it here). */
if|if
condition|(
name|h
operator|->
name|type
operator|==
name|STT_FUNC
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_PLT
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|refcount
operator|<=
literal|0
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|==
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_REF_DYNAMIC
operator|)
operator|==
literal|0
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefweak
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_undefined
operator|)
condition|)
block|{
comment|/* This case can occur if we saw a PLT32 reloc in an input              file, but the symbol was never referred to by a dynamic              object, or if all references were garbage collected.  In 	     such a case, we don't actually need to build a procedure 	     linkage table, and we can just do a PC32 reloc instead.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
else|else
comment|/* It's possible that we incorrectly decided a .plt reloc was        needed for an R_390_PC32 reloc to a non-function sym in        check_relocs.  We can't decide accurately between function and        non-function syms in check-relocs;  Objects loaded later in        the link may change h->type.  So fix it now.  */
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* If this is a weak symbol, and there is a real definition, the      processor independent code will have arranged for us to see the      real definition first, and we can just use the same value.  */
if|if
condition|(
name|h
operator|->
name|weakdef
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|weakdef
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* This is a reference to a symbol defined by a dynamic object which      is not a function.  */
comment|/* If we are creating a shared library, we must presume that the      only references to the symbol are via the global offset table.      For such cases we need not do anything here; the relocations will      be handled correctly by relocate_section.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
return|return
name|true
return|;
comment|/* If there are no references to this symbol that do not use the      GOT, we don't need to generate a copy reloc.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_GOT_REF
operator|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
comment|/* If -z nocopyreloc was given, we won't generate them either.  */
if|if
condition|(
name|info
operator|->
name|nocopyreloc
condition|)
block|{
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_GOT_REF
expr_stmt|;
return|return
name|true
return|;
block|}
name|eh
operator|=
operator|(
expr|struct
name|elf_s390_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|s
operator|=
name|p
operator|->
name|sec
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* If we didn't find any dynamic relocs in read-only sections, then      we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_NON_GOT_REF
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* We must allocate the symbol in our .dynbss section, which will      become part of the .bss section of the executable.  There will be      an entry for this symbol in the .dynsym section.  The dynamic      object will contain position independent code, so all references      from the dynamic object to this symbol will go through the global      offset table.  The dynamic linker will use the .dynsym entry to      determine the address it must put in the global offset table, so      both the dynamic object and the regular object will refer to the      same memory location for the variable.  */
name|htab
operator|=
name|elf_s390_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* We must generate a R_390_COPY reloc to tell the dynamic linker to      copy the initial value out of the dynamic object and into the      runtime process image.  */
if|if
condition|(
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|htab
operator|->
name|srelbss
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator||=
name|ELF_LINK_HASH_NEEDS_COPY
expr_stmt|;
block|}
comment|/* We need to figure out the alignment required for this symbol.  I      have no idea how ELF linkers handle this.  */
name|power_of_two
operator|=
name|bfd_log2
argument_list|(
name|h
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
literal|3
condition|)
name|power_of_two
operator|=
literal|3
expr_stmt|;
comment|/* Apply the required alignment.  */
name|s
operator|=
name|htab
operator|->
name|sdynbss
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
name|BFD_ALIGN
argument_list|(
name|s
operator|->
name|_raw_size
argument_list|,
call|(
name|bfd_size_type
call|)
argument_list|(
literal|1
operator|<<
name|power_of_two
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|power_of_two
operator|>
name|bfd_get_section_alignment
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_set_section_alignment
argument_list|(
name|htab
operator|->
name|elf
operator|.
name|dynobj
argument_list|,
name|s
argument_list|,
name|power_of_two
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Define the symbol as being at this point in the section.  */
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* Increment the section size to make room for the symbol.  */
name|s
operator|->
name|_raw_size
operator|+=
name|h
operator|->
name|size
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is the condition under which elf_s390_finish_dynamic_symbol    will be called from elflink.h.  If elflink.h doesn't call our    finish_dynamic_symbol routine, we'll need to do something about    initializing any .plt and .got entries in elf_s390_relocate_section.  */
end_comment

begin_define
define|#
directive|define
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
parameter_list|(
name|DYN
parameter_list|,
name|INFO
parameter_list|,
name|H
parameter_list|)
define|\
value|((DYN)								\&& ((INFO)->shared							\        || ((H)->elf_link_hash_flags& ELF_LINK_FORCED_LOCAL) == 0)	\&& ((H)->dynindx != -1						\        || ((H)->elf_link_hash_flags& ELF_LINK_FORCED_LOCAL) != 0))
end_define

begin_comment
comment|/* Allocate space in .plt, .got and associated reloc sections for    dynamic relocs.  */
end_comment

begin_function
specifier|static
name|boolean
name|allocate_dynrelocs
parameter_list|(
name|h
parameter_list|,
name|inf
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|inf
decl_stmt|;
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_s390_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|struct
name|elf_s390_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf_s390_dyn_relocs
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
condition|)
return|return
name|true
return|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|info
operator|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
expr_stmt|;
name|htab
operator|=
name|elf_s390_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
operator|&&
name|h
operator|->
name|plt
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol. 	 Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf32_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
literal|1
argument_list|,
name|info
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|asection
modifier|*
name|s
init|=
name|htab
operator|->
name|splt
decl_stmt|;
comment|/* If this is the first .plt entry, make room for the special 	     first entry.  */
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_FIRST_ENTRY_SIZE
expr_stmt|;
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
comment|/* If this symbol is not defined in a regular file, and we are 	     not generating a shared library, then set the symbol to this 	     location in the .plt.  This is required to make function 	     pointers compare as equal between the normal executable and 	     the shared library.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|=
name|h
operator|->
name|plt
operator|.
name|offset
expr_stmt|;
block|}
comment|/* Make room for this entry.  */
name|s
operator|->
name|_raw_size
operator|+=
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* We also need to make an entry in the .got.plt section, which 	     will be placed in the .got section by the linker script.  */
name|htab
operator|->
name|sgotplt
operator|->
name|_raw_size
operator|+=
name|GOT_ENTRY_SIZE
expr_stmt|;
comment|/* We also need to make an entry in the .rela.plt section.  */
name|htab
operator|->
name|srelplt
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
block|}
else|else
block|{
name|h
operator|->
name|plt
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|elf_link_hash_flags
operator|&=
operator|~
name|ELF_LINK_HASH_NEEDS_PLT
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|refcount
operator|>
literal|0
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|boolean
name|dyn
decl_stmt|;
comment|/* Make sure this symbol is output as a dynamic symbol. 	 Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf32_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|s
operator|=
name|htab
operator|->
name|sgot
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|offset
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
name|GOT_ENTRY_SIZE
expr_stmt|;
name|dyn
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
expr_stmt|;
if|if
condition|(
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
argument_list|,
name|h
argument_list|)
condition|)
name|htab
operator|->
name|srelgot
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
name|h
operator|->
name|got
operator|.
name|offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf_s390_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|dyn_relocs
operator|==
name|NULL
condition|)
return|return
name|true
return|;
comment|/* In the shared -Bsymbolic case, discard space allocated for      dynamic pc-relative relocs against symbols which turn out to be      defined in regular objects.  For the normal shared case, discard      space for pc-relative relocs that have become local due to symbol      visibility changes.  */
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|!=
literal|0
operator|||
name|info
operator|->
name|symbolic
operator|)
condition|)
block|{
name|struct
name|elf_s390_dyn_relocs
modifier|*
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|eh
operator|->
name|dyn_relocs
init|;
operator|(
name|p
operator|=
operator|*
name|pp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|p
operator|->
name|count
operator|-=
name|p
operator|->
name|pc_count
expr_stmt|;
name|p
operator|->
name|pc_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|count
operator|==
literal|0
condition|)
operator|*
name|pp
operator|=
name|p
operator|->
name|next
expr_stmt|;
else|else
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* For the non-shared case, discard space for relocs against 	 symbols which turn out to need copy relocs or are not 	 dynamic.  */
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_GOT_REF
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Make sure this symbol is output as a dynamic symbol. 	     Undefined weak syms won't yet be marked as dynamic.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_elf32_link_record_dynamic_symbol
argument_list|(
name|info
argument_list|,
name|h
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* If that succeeded, we know we'll be keeping all the 	     relocs.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
condition|)
goto|goto
name|keep
goto|;
block|}
name|eh
operator|->
name|dyn_relocs
operator|=
name|NULL
expr_stmt|;
name|keep
label|:
empty_stmt|;
block|}
comment|/* Finally, allocate space.  */
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|sreloc
init|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|->
name|sreloc
decl_stmt|;
name|sreloc
operator|->
name|_raw_size
operator|+=
name|p
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Find any dynamic relocs that apply to read-only sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|readonly_dynrelocs
parameter_list|(
name|h
parameter_list|,
name|inf
parameter_list|)
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|inf
decl_stmt|;
block|{
name|struct
name|elf_s390_link_hash_entry
modifier|*
name|eh
decl_stmt|;
name|struct
name|elf_s390_dyn_relocs
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|elf_s390_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
for|for
control|(
name|p
operator|=
name|eh
operator|->
name|dyn_relocs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|asection
modifier|*
name|s
init|=
name|p
operator|->
name|sec
operator|->
name|output_section
decl_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|inf
decl_stmt|;
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
comment|/* Not an error, just cut short the traversal.  */
return|return
name|false
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set the sizes of the dynamic sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_s390_size_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|elf_s390_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|boolean
name|relocs
decl_stmt|;
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|htab
operator|=
name|elf_s390_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
if|if
condition|(
name|dynobj
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
comment|/* Set the contents of the .interp section to the interpreter.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|=
sizeof|sizeof
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ELF_DYNAMIC_INTERPRETER
expr_stmt|;
block|}
block|}
comment|/* Set up .got offsets for local syms, and space for local dynamic      relocs.  */
for|for
control|(
name|ibfd
operator|=
name|info
operator|->
name|input_bfds
init|;
name|ibfd
operator|!=
name|NULL
condition|;
name|ibfd
operator|=
name|ibfd
operator|->
name|link_next
control|)
block|{
name|bfd_signed_vma
modifier|*
name|local_got
decl_stmt|;
name|bfd_signed_vma
modifier|*
name|end_local_got
decl_stmt|;
name|bfd_size_type
name|locsymcount
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|asection
modifier|*
name|srela
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
continue|continue;
for|for
control|(
name|s
operator|=
name|ibfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|struct
name|elf_s390_dyn_relocs
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|*
operator|(
operator|(
expr|struct
name|elf_s390_dyn_relocs
operator|*
operator|*
operator|)
operator|&
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|local_dynrel
operator|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|&&
name|bfd_is_abs_section
argument_list|(
name|p
operator|->
name|sec
operator|->
name|output_section
argument_list|)
condition|)
block|{
comment|/* Input section has been discarded, either because 		     it is a copy of a linkonce section or due to 		     linker script /DISCARD/, so we'll be discarding 		     the relocs too.  */
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|count
operator|!=
literal|0
condition|)
block|{
name|srela
operator|=
name|elf_section_data
argument_list|(
name|p
operator|->
name|sec
argument_list|)
operator|->
name|sreloc
expr_stmt|;
name|srela
operator|->
name|_raw_size
operator|+=
name|p
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|sec
operator|->
name|output_section
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|!=
literal|0
condition|)
name|info
operator|->
name|flags
operator||=
name|DF_TEXTREL
expr_stmt|;
block|}
block|}
block|}
name|local_got
operator|=
name|elf_local_got_refcounts
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_got
condition|)
continue|continue;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|locsymcount
operator|=
name|symtab_hdr
operator|->
name|sh_info
expr_stmt|;
name|end_local_got
operator|=
name|local_got
operator|+
name|locsymcount
expr_stmt|;
name|s
operator|=
name|htab
operator|->
name|sgot
expr_stmt|;
name|srela
operator|=
name|htab
operator|->
name|srelgot
expr_stmt|;
for|for
control|(
init|;
name|local_got
operator|<
name|end_local_got
condition|;
operator|++
name|local_got
control|)
block|{
if|if
condition|(
operator|*
name|local_got
operator|>
literal|0
condition|)
block|{
operator|*
name|local_got
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|+=
name|GOT_ENTRY_SIZE
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
name|srela
operator|->
name|_raw_size
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|local_got
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* Allocate global sym .plt and .got entries, and space for global      sym dynamic relocs.  */
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|allocate_dynrelocs
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
comment|/* We now have determined the sizes of the various dynamic sections.      Allocate memory for them.  */
name|relocs
operator|=
name|false
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dynobj
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LINKER_CREATED
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|s
operator|==
name|htab
operator|->
name|splt
operator|||
name|s
operator|==
name|htab
operator|->
name|sgot
operator|||
name|s
operator|==
name|htab
operator|->
name|sgotplt
condition|)
block|{
comment|/* Strip this section if we don't need it; see the 	     comment below.  */
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|bfd_get_section_name
argument_list|(
name|dynobj
argument_list|,
name|s
argument_list|)
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|!=
literal|0
operator|&&
name|s
operator|!=
name|htab
operator|->
name|srelplt
condition|)
name|relocs
operator|=
name|true
expr_stmt|;
comment|/* We use the reloc_count field as a counter if we need 	     to copy relocs into the output file.  */
name|s
operator|->
name|reloc_count
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* It's not one of our sections, so don't allocate space.  */
continue|continue;
block|}
if|if
condition|(
name|s
operator|->
name|_raw_size
operator|==
literal|0
condition|)
block|{
comment|/* If we don't need this section, strip it from the 	     output file.  This is to handle .rela.bss and 	     .rela.plt.  We must create it in 	     create_dynamic_sections, because it must be created 	     before the linker maps input sections to output 	     sections.  The linker does that before 	     adjust_dynamic_symbol is called, and it is that 	     function which decides whether anything needs to go 	     into these sections.  */
name|_bfd_strip_section_from_output
argument_list|(
name|info
argument_list|,
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Allocate memory for the section contents.  We use bfd_zalloc 	 here in case unused entries are not reclaimed before the 	 section's contents are written out.  This should not happen, 	 but this way if it does, we get a R_390_NONE reloc instead 	 of garbage.  */
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|dynobj
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
comment|/* Add some entries to the .dynamic section.  We fill in the 	 values later, in elf_s390_finish_dynamic_sections, but we 	 must add the entries now so that we get the correct size for 	 the .dynamic section.  The DT_DEBUG entry is filled in by the 	 dynamic linker and used by the debugger.  */
define|#
directive|define
name|add_dynamic_entry
parameter_list|(
name|TAG
parameter_list|,
name|VAL
parameter_list|)
define|\
value|bfd_elf32_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_DEBUG
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|htab
operator|->
name|splt
operator|->
name|_raw_size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTGOT
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTRELSZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_PLTREL
argument_list|,
name|DT_RELA
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_JMPREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|relocs
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELA
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELASZ
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_RELAENT
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If any dynamic relocs apply to a read-only section, 	     then we need a DT_TEXTREL entry.  */
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|==
literal|0
condition|)
name|elf_link_hash_traverse
argument_list|(
operator|&
name|htab
operator|->
name|elf
argument_list|,
name|readonly_dynrelocs
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|flags
operator|&
name|DF_TEXTREL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|add_dynamic_entry
argument_list|(
name|DT_TEXTREL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
undef|#
directive|undef
name|add_dynamic_entry
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Relocate a 390 ELF section.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_s390_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|local_syms
parameter_list|,
name|local_sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relocs
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|local_syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|local_sections
decl_stmt|;
block|{
name|struct
name|elf_s390_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
modifier|*
name|sym_hashes
decl_stmt|;
name|bfd_vma
modifier|*
name|local_got_offsets
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|rel
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|relend
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|relocateable
condition|)
return|return
name|true
return|;
name|htab
operator|=
name|elf_s390_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|input_bfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|sym_hashes
operator|=
name|elf_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|local_got_offsets
operator|=
name|elf_local_got_offsets
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|relocs
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|int
name|r_type
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|unsigned
name|long
name|r_symndx
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|off
decl_stmt|;
name|bfd_vma
name|relocation
decl_stmt|;
name|boolean
name|unresolved_reloc
decl_stmt|;
name|bfd_reloc_status_type
name|r
decl_stmt|;
name|r_type
operator|=
name|ELF32_R_TYPE
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_type
operator|==
operator|(
name|int
operator|)
name|R_390_GNU_VTINHERIT
operator|||
name|r_type
operator|==
operator|(
name|int
operator|)
name|R_390_GNU_VTENTRY
condition|)
continue|continue;
if|if
condition|(
name|r_type
operator|<
literal|0
operator|||
name|r_type
operator|>=
operator|(
name|int
operator|)
name|R_390_max
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|howto
operator|=
name|elf_howto_table
operator|+
name|r_type
expr_stmt|;
name|r_symndx
operator|=
name|ELF32_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
name|unresolved_reloc
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|r_symndx
operator|<
name|symtab_hdr
operator|->
name|sh_info
condition|)
block|{
name|sym
operator|=
name|local_syms
operator|+
name|r_symndx
expr_stmt|;
name|sec
operator|=
name|local_sections
index|[
name|r_symndx
index|]
expr_stmt|;
name|relocation
operator|=
name|_bfd_elf_rela_local_sym
argument_list|(
name|output_bfd
argument_list|,
name|sym
argument_list|,
name|sec
argument_list|,
name|rel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|h
operator|=
name|sym_hashes
index|[
name|r_symndx
operator|-
name|symtab_hdr
operator|->
name|sh_info
index|]
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|output_section
operator|==
name|NULL
condition|)
block|{
comment|/* Set a flag that will be cleared later if we find a 		     relocation value for this symbol.  output_section 		     is typically NULL for symbols satisfied by a shared 		     library.  */
name|unresolved_reloc
operator|=
name|true
expr_stmt|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|relocation
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
name|info
operator|->
name|allow_shlib_undefined
operator|)
operator|&&
operator|!
name|info
operator|->
name|no_undefined
operator|&&
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|==
name|STV_DEFAULT
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
operator|(
operator|!
name|info
operator|->
name|shared
operator|||
name|info
operator|->
name|no_undefined
operator|||
name|ELF_ST_VISIBILITY
argument_list|(
name|h
operator|->
name|other
argument_list|)
operator|)
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|relocation
operator|=
literal|0
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_390_GOT12
case|:
case|case
name|R_390_GOT16
case|:
case|case
name|R_390_GOT32
case|:
case|case
name|R_390_GOTENT
case|:
comment|/* Relocation is to the entry for this symbol in the global              offset table.  */
if|if
condition|(
name|htab
operator|->
name|sgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
block|{
name|boolean
name|dyn
decl_stmt|;
name|off
operator|=
name|h
operator|->
name|got
operator|.
name|offset
expr_stmt|;
name|dyn
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
expr_stmt|;
if|if
condition|(
operator|!
name|WILL_CALL_FINISH_DYNAMIC_SYMBOL
argument_list|(
name|dyn
argument_list|,
name|info
argument_list|,
name|h
argument_list|)
operator|||
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|)
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|)
condition|)
block|{
comment|/* This is actually a static link, or it is a                      -Bsymbolic link and the symbol is defined                      locally, or the symbol was forced to be local                      because of a version file.  We must initialize                      this entry in the global offset table.  Since the                      offset must always be a multiple of 2, we use the                      least significant bit to record whether we have                      initialized it already.                       When doing a dynamic link, we create a .rel.got                      relocation entry to initialize the value.  This                      is done in the finish_dynamic_symbol routine.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
name|h
operator|->
name|got
operator|.
name|offset
operator||=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|unresolved_reloc
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|local_got_offsets
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|off
operator|=
name|local_got_offsets
index|[
name|r_symndx
index|]
expr_stmt|;
comment|/* The offset must always be a multiple of 4.  We use                  the least significant bit to record whether we have                  already generated the necessary reloc.  */
if|if
condition|(
operator|(
name|off
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|off
operator|&=
operator|~
literal|1
expr_stmt|;
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|relocation
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|asection
modifier|*
name|srelgot
decl_stmt|;
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|Elf32_External_Rela
modifier|*
name|loc
decl_stmt|;
name|srelgot
operator|=
name|htab
operator|->
name|srelgot
expr_stmt|;
if|if
condition|(
name|srelgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|off
operator|)
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_390_RELATIVE
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
expr_stmt|;
name|loc
operator|=
operator|(
name|Elf32_External_Rela
operator|*
operator|)
name|srelgot
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|srelgot
operator|->
name|reloc_count
operator|++
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
name|local_got_offsets
index|[
name|r_symndx
index|]
operator||=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|off
operator|>=
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|abort
argument_list|()
expr_stmt|;
name|relocation
operator|=
name|htab
operator|->
name|sgot
operator|->
name|output_offset
operator|+
name|off
expr_stmt|;
comment|/* 	   * For @GOTENT the relocation is against the offset between 	   * the instruction and the symbols entry in the GOT and not 	   * between the start of the GOT and the symbols entry. We 	   * add the vma of the GOT to get the correct value. 	   */
if|if
condition|(
name|r_type
operator|==
name|R_390_GOTENT
condition|)
name|relocation
operator|+=
name|htab
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|R_390_GOTOFF
case|:
comment|/* Relocation is relative to the start of the global offset              table.  */
comment|/* Note that sgot->output_offset is not involved in this              calculation.  We always want the start of .got.  If we              defined _GLOBAL_OFFSET_TABLE in a different way, as is              permitted by the ABI, we might have to change this              calculation.  */
name|relocation
operator|-=
name|htab
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|R_390_GOTPC
case|:
case|case
name|R_390_GOTPCDBL
case|:
comment|/* Use global offset table as symbol value.  */
name|relocation
operator|=
name|htab
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
name|unresolved_reloc
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|R_390_PLT16DBL
case|:
case|case
name|R_390_PLT32DBL
case|:
case|case
name|R_390_PLT32
case|:
comment|/* Relocation is to the entry for this symbol in the              procedure linkage table.  */
comment|/* Resolve a PLT32 reloc against a local symbol directly,              without using the procedure linkage table.  */
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
operator|||
name|htab
operator|->
name|splt
operator|==
name|NULL
condition|)
block|{
comment|/* We didn't make a PLT entry for this symbol.  This                  happens when statically linking PIC code, or when                  using -Bsymbolic.  */
break|break;
block|}
name|relocation
operator|=
operator|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|)
expr_stmt|;
name|unresolved_reloc
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|R_390_8
case|:
case|case
name|R_390_16
case|:
case|case
name|R_390_32
case|:
case|case
name|R_390_PC16
case|:
case|case
name|R_390_PC16DBL
case|:
case|case
name|R_390_PC32DBL
case|:
case|case
name|R_390_PC32
case|:
comment|/* r_symndx will be zero only for relocs against symbols 	     from removed linkonce sections, or sections discarded by 	     a linker script.  */
if|if
condition|(
name|r_symndx
operator|==
literal|0
operator|||
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
operator|(
name|r_type
operator|!=
name|R_390_PC16
operator|&&
name|r_type
operator|!=
name|R_390_PC16DBL
operator|&&
name|r_type
operator|!=
name|R_390_PC32DBL
operator|&&
name|r_type
operator|!=
name|R_390_PC32
operator|)
operator|||
operator|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
operator|!
name|info
operator|->
name|symbolic
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|info
operator|->
name|shared
operator|&&
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_NON_GOT_REF
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefweak
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|)
operator|)
condition|)
block|{
name|Elf_Internal_Rela
name|outrel
decl_stmt|;
name|boolean
name|skip
decl_stmt|,
name|relocate
decl_stmt|;
name|asection
modifier|*
name|sreloc
decl_stmt|;
name|Elf32_External_Rela
modifier|*
name|loc
decl_stmt|;
comment|/* When generating a shared object, these relocations 		 are copied into the output file to be resolved at run 		 time.  */
name|skip
operator|=
name|false
expr_stmt|;
name|relocate
operator|=
name|false
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|=
name|_bfd_elf_section_offset
argument_list|(
name|output_bfd
argument_list|,
name|info
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
name|skip
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|outrel
operator|.
name|r_offset
operator|==
operator|(
name|bfd_vma
operator|)
operator|-
literal|2
condition|)
name|skip
operator|=
name|true
operator|,
name|relocate
operator|=
name|true
expr_stmt|;
name|outrel
operator|.
name|r_offset
operator|+=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|)
expr_stmt|;
if|if
condition|(
name|skip
condition|)
name|memset
argument_list|(
operator|&
name|outrel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|outrel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
name|h
operator|->
name|dynindx
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|r_type
operator|==
name|R_390_PC16
operator|||
name|r_type
operator|==
name|R_390_PC16DBL
operator|||
name|r_type
operator|==
name|R_390_PC32DBL
operator|||
name|r_type
operator|==
name|R_390_PC32
operator|||
operator|!
name|info
operator|->
name|shared
operator|||
operator|!
name|info
operator|->
name|symbolic
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|r_type
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
else|else
block|{
comment|/* This symbol is local, or marked to become local.  */
name|relocate
operator|=
name|true
expr_stmt|;
name|outrel
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_390_RELATIVE
argument_list|)
expr_stmt|;
name|outrel
operator|.
name|r_addend
operator|=
name|relocation
operator|+
name|rel
operator|->
name|r_addend
expr_stmt|;
block|}
name|sreloc
operator|=
name|elf_section_data
argument_list|(
name|input_section
argument_list|)
operator|->
name|sreloc
expr_stmt|;
if|if
condition|(
name|sreloc
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|loc
operator|=
operator|(
name|Elf32_External_Rela
operator|*
operator|)
name|sreloc
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|sreloc
operator|->
name|reloc_count
operator|++
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|outrel
argument_list|,
name|loc
argument_list|)
expr_stmt|;
comment|/* If this reloc is against an external symbol, we do                  not want to fiddle with the addend.  Otherwise, we                  need to include the symbol value so that it becomes                  an addend for the dynamic reloc.  */
if|if
condition|(
operator|!
name|relocate
condition|)
continue|continue;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|unresolved_reloc
operator|&&
operator|!
operator|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_DEBUGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_DYNAMIC
operator|)
operator|!=
literal|0
operator|)
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s(%s+0x%lx): unresolvable relocation against symbol `%s'"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
name|r
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|,
name|relocation
argument_list|,
name|rel
operator|->
name|r_addend
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|bfd_reloc_ok
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
else|else
block|{
name|name
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|input_bfd
argument_list|,
name|symtab_hdr
operator|->
name|sh_link
argument_list|,
name|sym
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|name
operator|=
name|bfd_section_name
argument_list|(
name|input_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
name|bfd_reloc_overflow
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_offset
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s(%s+0x%lx): reloc against `%s': error %d"
argument_list|)
argument_list|,
name|bfd_archive_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|bfd_get_section_name
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|rel
operator|->
name|r_offset
argument_list|,
name|name
argument_list|,
operator|(
name|int
operator|)
name|r
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Finish up dynamic symbol handling.  We set the contents of various    dynamic sections here.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_s390_finish_dynamic_symbol
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|h
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|elf_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|Elf_Internal_Sym
modifier|*
name|sym
decl_stmt|;
block|{
name|struct
name|elf_s390_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|htab
operator|=
name|elf_s390_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|bfd_vma
name|plt_index
decl_stmt|;
name|bfd_vma
name|got_offset
decl_stmt|;
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|Elf32_External_Rela
modifier|*
name|loc
decl_stmt|;
name|bfd_vma
name|relative_offset
decl_stmt|;
comment|/* This symbol has an entry in the procedure linkage table.  Set          it up.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
name|htab
operator|->
name|splt
operator|==
name|NULL
operator|||
name|htab
operator|->
name|sgotplt
operator|==
name|NULL
operator|||
name|htab
operator|->
name|srelplt
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Calc. index no.          Current offset - size first entry / entry size.  */
name|plt_index
operator|=
operator|(
name|h
operator|->
name|plt
operator|.
name|offset
operator|-
name|PLT_FIRST_ENTRY_SIZE
operator|)
operator|/
name|PLT_ENTRY_SIZE
expr_stmt|;
comment|/* Offset in GOT is PLT index plus GOT headers(3) times 4,          addr& GOT addr.  */
name|got_offset
operator|=
operator|(
name|plt_index
operator|+
literal|3
operator|)
operator|*
name|GOT_ENTRY_SIZE
expr_stmt|;
comment|/* S390 uses halfwords for relative branch calc!  */
name|relative_offset
operator|=
operator|-
operator|(
operator|(
name|PLT_FIRST_ENTRY_SIZE
operator|+
operator|(
name|PLT_ENTRY_SIZE
operator|*
name|plt_index
operator|)
operator|+
literal|18
operator|)
operator|/
literal|2
operator|)
expr_stmt|;
comment|/* If offset is> 32768, branch to a previous branch          390 can only handle +-64 K jumps.  */
if|if
condition|(
operator|-
literal|32768
operator|>
operator|(
name|int
operator|)
name|relative_offset
condition|)
name|relative_offset
operator|=
operator|-
call|(
name|unsigned
call|)
argument_list|(
operator|(
operator|(
literal|65536
operator|/
name|PLT_ENTRY_SIZE
operator|-
literal|1
operator|)
operator|*
name|PLT_ENTRY_SIZE
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/* Fill in the entry in the procedure linkage table.  */
if|if
condition|(
operator|!
name|info
operator|->
name|shared
condition|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_ENTRY_WORD0
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_ENTRY_WORD1
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_ENTRY_WORD2
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_ENTRY_WORD3
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|12
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_ENTRY_WORD4
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|16
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
operator|+
operator|(
name|relative_offset
operator|<<
literal|16
operator|)
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|20
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|htab
operator|->
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgotplt
operator|->
name|output_offset
operator|+
name|got_offset
operator|)
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|24
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|got_offset
operator|<
literal|4096
condition|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_PIC12_ENTRY_WORD0
operator|+
name|got_offset
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_PIC12_ENTRY_WORD1
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_PIC12_ENTRY_WORD2
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_PIC12_ENTRY_WORD3
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|12
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_PIC12_ENTRY_WORD4
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|16
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
operator|+
operator|(
name|relative_offset
operator|<<
literal|16
operator|)
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|20
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|24
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|got_offset
operator|<
literal|32768
condition|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_PIC16_ENTRY_WORD0
operator|+
name|got_offset
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_PIC16_ENTRY_WORD1
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_PIC16_ENTRY_WORD2
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_PIC16_ENTRY_WORD3
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|12
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_PIC16_ENTRY_WORD4
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|16
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
operator|+
operator|(
name|relative_offset
operator|<<
literal|16
operator|)
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|20
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|24
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_PIC_ENTRY_WORD0
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_PIC_ENTRY_WORD1
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_PIC_ENTRY_WORD2
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_PIC_ENTRY_WORD3
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|12
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_PIC_ENTRY_WORD4
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|16
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
operator|+
operator|(
name|relative_offset
operator|<<
literal|16
operator|)
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|20
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|got_offset
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|24
argument_list|)
expr_stmt|;
block|}
comment|/* Insert offset into  reloc. table here.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|plt_index
operator|*
sizeof|sizeof
argument_list|(
name|Elf32_External_Rela
argument_list|)
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|28
argument_list|)
expr_stmt|;
comment|/* Fill in the entry in the global offset table.          Points to instruction after GOT offset.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|htab
operator|->
name|splt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|splt
operator|->
name|output_offset
operator|+
name|h
operator|->
name|plt
operator|.
name|offset
operator|+
literal|12
operator|)
argument_list|,
name|htab
operator|->
name|sgotplt
operator|->
name|contents
operator|+
name|got_offset
argument_list|)
expr_stmt|;
comment|/* Fill in the entry in the .rela.plt section.  */
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgotplt
operator|->
name|output_offset
operator|+
name|got_offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_390_JMP_SLOT
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
operator|(
name|Elf32_External_Rela
operator|*
operator|)
name|htab
operator|->
name|srelplt
operator|->
name|contents
operator|+
name|plt_index
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Mark the symbol as undefined, rather than as defined in 	     the .plt section.  Leave the value alone.  This is a clue 	     for the dynamic linker, to make function pointer 	     comparisons work between an application and shared 	     library.  */
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
block|}
block|}
if|if
condition|(
name|h
operator|->
name|got
operator|.
name|offset
operator|!=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
condition|)
block|{
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|Elf32_External_Rela
modifier|*
name|loc
decl_stmt|;
comment|/* This symbol has an entry in the global offset table.  Set it          up.  */
if|if
condition|(
name|htab
operator|->
name|sgot
operator|==
name|NULL
operator|||
name|htab
operator|->
name|srelgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|htab
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgot
operator|->
name|output_offset
operator|+
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* If this is a static link, or it is a -Bsymbolic link and the 	 symbol is defined locally or was forced to be local because 	 of a version file, we just want to emit a RELATIVE reloc. 	 The entry in the global offset table will already have been 	 initialized in the relocate_section function.  */
if|if
condition|(
name|info
operator|->
name|shared
operator|&&
operator|(
name|info
operator|->
name|symbolic
operator|||
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_FORCED_LOCAL
operator|)
operator|)
operator|&&
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_DEF_REGULAR
operator|)
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
literal|1
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
literal|0
argument_list|,
name|R_390_RELATIVE
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
name|BFD_ASSERT
argument_list|(
operator|(
name|h
operator|->
name|got
operator|.
name|offset
operator|&
literal|1
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|htab
operator|->
name|sgot
operator|->
name|contents
operator|+
name|h
operator|->
name|got
operator|.
name|offset
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_390_GLOB_DAT
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
name|loc
operator|=
operator|(
name|Elf32_External_Rela
operator|*
operator|)
name|htab
operator|->
name|srelgot
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|htab
operator|->
name|srelgot
operator|->
name|reloc_count
operator|++
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|h
operator|->
name|elf_link_hash_flags
operator|&
name|ELF_LINK_HASH_NEEDS_COPY
operator|)
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Rela
name|rela
decl_stmt|;
name|Elf32_External_Rela
modifier|*
name|loc
decl_stmt|;
comment|/* This symbols needs a copy reloc.  Set it up.  */
if|if
condition|(
name|h
operator|->
name|dynindx
operator|==
operator|-
literal|1
operator|||
operator|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
operator|)
operator|||
name|htab
operator|->
name|srelbss
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|rela
operator|.
name|r_offset
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
name|rela
operator|.
name|r_info
operator|=
name|ELF32_R_INFO
argument_list|(
name|h
operator|->
name|dynindx
argument_list|,
name|R_390_COPY
argument_list|)
expr_stmt|;
name|rela
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
operator|(
name|Elf32_External_Rela
operator|*
operator|)
name|htab
operator|->
name|srelbss
operator|->
name|contents
expr_stmt|;
name|loc
operator|+=
name|htab
operator|->
name|srelbss
operator|->
name|reloc_count
operator|++
expr_stmt|;
name|bfd_elf32_swap_reloca_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|rela
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
comment|/* Mark some specially defined symbols as absolute.  */
if|if
condition|(
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_DYNAMIC"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
literal|"_PROCEDURE_LINKAGE_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
name|sym
operator|->
name|st_shndx
operator|=
name|SHN_ABS
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Used to decide how to sort relocs in an optimal manner for the    dynamic linker, before writing them out.  */
end_comment

begin_function
specifier|static
name|enum
name|elf_reloc_type_class
name|elf_s390_reloc_type_class
parameter_list|(
name|rela
parameter_list|)
specifier|const
name|Elf_Internal_Rela
modifier|*
name|rela
decl_stmt|;
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|ELF32_R_TYPE
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
condition|)
block|{
case|case
name|R_390_RELATIVE
case|:
return|return
name|reloc_class_relative
return|;
case|case
name|R_390_JMP_SLOT
case|:
return|return
name|reloc_class_plt
return|;
case|case
name|R_390_COPY
case|:
return|return
name|reloc_class_copy
return|;
default|default:
return|return
name|reloc_class_normal
return|;
block|}
block|}
end_function

begin_comment
comment|/* Finish up the dynamic sections.  */
end_comment

begin_function
specifier|static
name|boolean
name|elf_s390_finish_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|elf_s390_link_hash_table
modifier|*
name|htab
decl_stmt|;
name|bfd
modifier|*
name|dynobj
decl_stmt|;
name|asection
modifier|*
name|sdyn
decl_stmt|;
name|htab
operator|=
name|elf_s390_hash_table
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|dynobj
operator|=
name|htab
operator|->
name|elf
operator|.
name|dynobj
expr_stmt|;
name|sdyn
operator|=
name|bfd_get_section_by_name
argument_list|(
name|dynobj
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|htab
operator|->
name|elf
operator|.
name|dynamic_sections_created
condition|)
block|{
name|Elf32_External_Dyn
modifier|*
name|dyncon
decl_stmt|,
modifier|*
name|dynconend
decl_stmt|;
if|if
condition|(
name|sdyn
operator|==
name|NULL
operator|||
name|htab
operator|->
name|sgot
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dyncon
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
name|sdyn
operator|->
name|contents
expr_stmt|;
name|dynconend
operator|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
operator|(
name|sdyn
operator|->
name|contents
operator|+
name|sdyn
operator|->
name|_raw_size
operator|)
expr_stmt|;
for|for
control|(
init|;
name|dyncon
operator|<
name|dynconend
condition|;
name|dyncon
operator|++
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_elf32_swap_dyn_in
argument_list|(
name|dynobj
argument_list|,
name|dyncon
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
default|default:
continue|continue;
case|case
name|DT_PLTGOT
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|htab
operator|->
name|sgot
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|DT_JMPREL
case|:
name|dyn
operator|.
name|d_un
operator|.
name|d_ptr
operator|=
name|htab
operator|->
name|srelplt
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|s
operator|=
name|htab
operator|->
name|srelplt
operator|->
name|output_section
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|_cooked_size
operator|!=
literal|0
condition|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_cooked_size
expr_stmt|;
else|else
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|s
operator|->
name|_raw_size
expr_stmt|;
break|break;
block|}
name|bfd_elf32_swap_dyn_out
argument_list|(
name|output_bfd
argument_list|,
operator|&
name|dyn
argument_list|,
name|dyncon
argument_list|)
expr_stmt|;
block|}
comment|/* Fill in the special first entry in the procedure linkage table.  */
if|if
condition|(
name|htab
operator|->
name|splt
operator|&&
name|htab
operator|->
name|splt
operator|->
name|_raw_size
operator|>
literal|0
condition|)
block|{
name|memset
argument_list|(
name|htab
operator|->
name|splt
operator|->
name|contents
argument_list|,
literal|0
argument_list|,
name|PLT_FIRST_ENTRY_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|shared
condition|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_PIC_FIRST_ENTRY_WORD0
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_PIC_FIRST_ENTRY_WORD1
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_PIC_FIRST_ENTRY_WORD2
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_PIC_FIRST_ENTRY_WORD3
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
literal|12
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_PIC_FIRST_ENTRY_WORD4
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_FIRST_ENTRY_WORD0
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_FIRST_ENTRY_WORD1
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_FIRST_ENTRY_WORD2
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_FIRST_ENTRY_WORD3
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
literal|12
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_FIRST_ENTRY_WORD4
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
literal|16
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|PLT_FIRST_ENTRY_WORD5
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
literal|20
argument_list|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|htab
operator|->
name|sgotplt
operator|->
name|output_section
operator|->
name|vma
operator|+
name|htab
operator|->
name|sgotplt
operator|->
name|output_offset
argument_list|,
name|htab
operator|->
name|splt
operator|->
name|contents
operator|+
literal|24
argument_list|)
expr_stmt|;
block|}
name|elf_section_data
argument_list|(
name|htab
operator|->
name|splt
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|4
expr_stmt|;
block|}
block|}
if|if
condition|(
name|htab
operator|->
name|sgotplt
condition|)
block|{
comment|/* Fill in the first three entries in the global offset table.  */
if|if
condition|(
name|htab
operator|->
name|sgotplt
operator|->
name|_raw_size
operator|>
literal|0
condition|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|sdyn
operator|==
name|NULL
condition|?
operator|(
name|bfd_vma
operator|)
literal|0
else|:
name|sdyn
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sdyn
operator|->
name|output_offset
operator|)
argument_list|,
name|htab
operator|->
name|sgotplt
operator|->
name|contents
argument_list|)
expr_stmt|;
comment|/* One entry for shared object struct ptr.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|htab
operator|->
name|sgotplt
operator|->
name|contents
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* One entry for _dl_runtime_resolve.  */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|htab
operator|->
name|sgotplt
operator|->
name|contents
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
name|elf_section_data
argument_list|(
name|htab
operator|->
name|sgotplt
operator|->
name|output_section
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|4
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|elf_s390_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|bfd_arch_s390
argument_list|,
name|bfd_mach_s390_31
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|elf_s390_grok_prstatus
parameter_list|(
name|abfd
parameter_list|,
name|note
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Note
modifier|*
name|note
decl_stmt|;
block|{
name|int
name|offset
decl_stmt|;
name|unsigned
name|int
name|raw_size
decl_stmt|;
switch|switch
condition|(
name|note
operator|->
name|descsz
condition|)
block|{
default|default:
return|return
name|false
return|;
case|case
literal|224
case|:
comment|/* S/390 Linux.  */
comment|/* pr_cursig */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_signal
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* pr_pid */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|core_pid
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|->
name|descdata
operator|+
literal|24
argument_list|)
expr_stmt|;
comment|/* pr_reg */
name|offset
operator|=
literal|72
expr_stmt|;
name|raw_size
operator|=
literal|144
expr_stmt|;
break|break;
block|}
comment|/* Make a ".reg/999" section.  */
return|return
name|_bfd_elfcore_make_pseudosection
argument_list|(
name|abfd
argument_list|,
literal|".reg"
argument_list|,
name|raw_size
argument_list|,
name|note
operator|->
name|descpos
operator|+
name|offset
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TARGET_BIG_SYM
value|bfd_elf32_s390_vec
end_define

begin_define
define|#
directive|define
name|TARGET_BIG_NAME
value|"elf32-s390"
end_define

begin_define
define|#
directive|define
name|ELF_ARCH
value|bfd_arch_s390
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_CODE
value|EM_S390
end_define

begin_define
define|#
directive|define
name|ELF_MACHINE_ALT1
value|EM_S390_OLD
end_define

begin_define
define|#
directive|define
name|ELF_MAXPAGESIZE
value|0x1000
end_define

begin_define
define|#
directive|define
name|elf_backend_can_gc_sections
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_can_refcount
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_want_got_plt
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_readonly
value|1
end_define

begin_define
define|#
directive|define
name|elf_backend_want_plt_sym
value|0
end_define

begin_define
define|#
directive|define
name|elf_backend_got_header_size
value|12
end_define

begin_define
define|#
directive|define
name|elf_backend_plt_header_size
value|PLT_ENTRY_SIZE
end_define

begin_define
define|#
directive|define
name|elf_backend_rela_normal
value|1
end_define

begin_define
define|#
directive|define
name|elf_info_to_howto
value|elf_s390_info_to_howto
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_is_local_label_name
value|elf_s390_is_local_label_name
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_link_hash_table_create
value|elf_s390_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|bfd_elf32_bfd_reloc_type_lookup
value|elf_s390_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|elf_backend_adjust_dynamic_symbol
value|elf_s390_adjust_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_check_relocs
value|elf_s390_check_relocs
end_define

begin_define
define|#
directive|define
name|elf_backend_copy_indirect_symbol
value|elf_s390_copy_indirect_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_create_dynamic_sections
value|elf_s390_create_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_sections
value|elf_s390_finish_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_finish_dynamic_symbol
value|elf_s390_finish_dynamic_symbol
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_mark_hook
value|elf_s390_gc_mark_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_gc_sweep_hook
value|elf_s390_gc_sweep_hook
end_define

begin_define
define|#
directive|define
name|elf_backend_reloc_type_class
value|elf_s390_reloc_type_class
end_define

begin_define
define|#
directive|define
name|elf_backend_relocate_section
value|elf_s390_relocate_section
end_define

begin_define
define|#
directive|define
name|elf_backend_size_dynamic_sections
value|elf_s390_size_dynamic_sections
end_define

begin_define
define|#
directive|define
name|elf_backend_reloc_type_class
value|elf_s390_reloc_type_class
end_define

begin_define
define|#
directive|define
name|elf_backend_grok_prstatus
value|elf_s390_grok_prstatus
end_define

begin_define
define|#
directive|define
name|elf_backend_object_p
value|elf_s390_object_p
end_define

begin_include
include|#
directive|include
file|"elf32-target.h"
end_include

end_unit

