begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for linux flavored i386 a.out binaries.    Copyright 1992, 1993, 1994, 1995, 1996, 1997, 2001, 2002    Free Software Foundation, Inc.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_define
define|#
directive|define
name|TARGET_PAGE_SIZE
value|4096
end_define

begin_define
define|#
directive|define
name|ZMAGIC_DISK_BLOCK_SIZE
value|1024
end_define

begin_define
define|#
directive|define
name|SEGMENT_SIZE
value|TARGET_PAGE_SIZE
end_define

begin_define
define|#
directive|define
name|TEXT_START_ADDR
value|0x0
end_define

begin_define
define|#
directive|define
name|N_SHARED_LIB
parameter_list|(
name|x
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|BYTES_IN_WORD
value|4
end_define

begin_define
define|#
directive|define
name|MACHTYPE_OK
parameter_list|(
name|mtype
parameter_list|)
value|((mtype) == M_386 || (mtype) == M_UNKNOWN)
end_define

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"aout/aout64.h"
end_include

begin_include
include|#
directive|include
file|"aout/stab_gnu.h"
end_include

begin_include
include|#
directive|include
file|"aout/ar.h"
end_include

begin_include
include|#
directive|include
file|"libaout.h"
end_include

begin_comment
comment|/* BFD a.out internal data structures */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_ARCH
value|bfd_arch_i386
end_define

begin_comment
comment|/* Do not "beautify" the CONCAT* macro args.  Traditional C will not    remove whitespace added here, and thus will fail to concatenate    the tokens.  */
end_comment

begin_define
define|#
directive|define
name|MY
parameter_list|(
name|OP
parameter_list|)
value|CONCAT2 (i386linux_,OP)
end_define

begin_define
define|#
directive|define
name|TARGETNAME
value|"a.out-i386-linux"
end_define

begin_function_decl
specifier|extern
specifier|const
name|bfd_target
name|MY
parameter_list|(
name|vec
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* We always generate QMAGIC files in preference to ZMAGIC files.  It    would be possible to make this a linker option, if that ever    becomes important.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|MY_final_link_callback
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|file_ptr
operator|*
operator|,
name|file_ptr
operator|*
operator|,
name|file_ptr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|i386linux_bfd_final_link
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|i386linux_write_object_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|boolean
name|i386linux_bfd_final_link
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|obj_aout_subformat
argument_list|(
name|abfd
argument_list|)
operator|=
name|q_magic_format
expr_stmt|;
return|return
name|NAME
argument_list|(
name|aout
argument_list|,
name|final_link
argument_list|)
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|,
name|MY_final_link_callback
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MY_bfd_final_link
value|i386linux_bfd_final_link
end_define

begin_comment
comment|/* Set the machine type correctly.  */
end_comment

begin_function
specifier|static
name|boolean
name|i386linux_write_object_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|external_exec
name|exec_bytes
decl_stmt|;
name|struct
name|internal_exec
modifier|*
name|execp
init|=
name|exec_hdr
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|N_SET_MACHTYPE
argument_list|(
operator|*
name|execp
argument_list|,
name|M_386
argument_list|)
expr_stmt|;
name|obj_reloc_entry_size
argument_list|(
name|abfd
argument_list|)
operator|=
name|RELOC_STD_SIZE
expr_stmt|;
name|WRITE_HEADERS
argument_list|(
name|abfd
argument_list|,
name|execp
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MY_write_object_contents
value|i386linux_write_object_contents
end_define

begin_escape
end_escape

begin_comment
comment|/* Code to link against Linux a.out shared libraries.  */
end_comment

begin_comment
comment|/* See if a symbol name is a reference to the global offset table.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GOT_REF_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|GOT_REF_PREFIX
value|"__GOT_"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IS_GOT_SYM
parameter_list|(
name|name
parameter_list|)
define|\
value|(strncmp (name, GOT_REF_PREFIX, sizeof GOT_REF_PREFIX - 1) == 0)
end_define

begin_comment
comment|/* See if a symbol name is a reference to the procedure linkage table.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PLT_REF_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|PLT_REF_PREFIX
value|"__PLT_"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IS_PLT_SYM
parameter_list|(
name|name
parameter_list|)
define|\
value|(strncmp (name, PLT_REF_PREFIX, sizeof PLT_REF_PREFIX - 1) == 0)
end_define

begin_comment
comment|/* This string is used to generate specialized error messages.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NEEDS_SHRLIB
end_ifndef

begin_define
define|#
directive|define
name|NEEDS_SHRLIB
value|"__NEEDS_SHRLIB_"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This special symbol is a set vector that contains a list of    pointers to fixup tables.  It will be present in any dynamicly    linked file.  The linker generated fixup table should also be added    to the list, and it should always appear in the second slot (the    first one is a dummy with a magic number that is defined in    crt0.o).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SHARABLE_CONFLICTS
end_ifndef

begin_define
define|#
directive|define
name|SHARABLE_CONFLICTS
value|"__SHARABLE_CONFLICTS__"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We keep a list of fixups.  The terminology is a bit strange, but    each fixup contains two 32 bit numbers.  A regular fixup contains    an address and a pointer, and at runtime we should store the    address at the location pointed to by the pointer.  A builtin fixup    contains two pointers, and we should read the address using one    pointer and store it at the location pointed to by the other    pointer.  Builtin fixups come into play when we have duplicate    __GOT__ symbols for the same variable.  The builtin fixup will copy    the GOT pointer from one over into the other.  */
end_comment

begin_struct
struct|struct
name|fixup
block|{
name|struct
name|fixup
modifier|*
name|next
decl_stmt|;
name|struct
name|linux_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
comment|/* Nonzero if this is a jump instruction that needs to be fixed,      zero if this is just a pointer */
name|char
name|jump
decl_stmt|;
name|char
name|builtin
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* We don't need a special hash table entry structure, but we do need    to keep some information between linker passes, so we use a special    hash table.  */
end_comment

begin_struct
struct|struct
name|linux_link_hash_entry
block|{
name|struct
name|aout_link_hash_entry
name|root
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|linux_link_hash_table
block|{
name|struct
name|aout_link_hash_table
name|root
decl_stmt|;
comment|/* First dynamic object found in link.  */
name|bfd
modifier|*
name|dynobj
decl_stmt|;
comment|/* Number of fixups.  */
name|size_t
name|fixup_count
decl_stmt|;
comment|/* Number of builtin fixups.  */
name|size_t
name|local_builtins
decl_stmt|;
comment|/* List of fixups.  */
name|struct
name|fixup
modifier|*
name|fixup_list
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|linux_link_hash_newfunc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|linux_link_hash_table_create
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fixup
modifier|*
name|new_fixup
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|linux_link_hash_entry
operator|*
operator|,
name|bfd_vma
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|linux_link_create_dynamic_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|linux_add_one_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|flagword
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
specifier|const
name|char
operator|*
operator|,
name|boolean
operator|,
name|boolean
operator|,
expr|struct
name|bfd_link_hash_entry
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|linux_tally_symbols
name|PARAMS
argument_list|(
operator|(
expr|struct
name|linux_link_hash_entry
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|linux_finish_dynamic_link
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Routine to create an entry in an Linux link hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_hash_entry
modifier|*
name|linux_link_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|linux_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|linux_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|linux_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|linux_link_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|linux_link_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|linux_link_hash_entry
operator|*
operator|)
name|NAME
argument_list|(
name|aout
argument_list|,
name|link_hash_newfunc
argument_list|)
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
block|{
comment|/* Set local fields; there aren't any.  */
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Create a Linux link hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|bfd_link_hash_table
modifier|*
name|linux_link_hash_table_create
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|linux_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|bfd_size_type
name|amt
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|linux_link_hash_table
argument_list|)
decl_stmt|;
name|ret
operator|=
operator|(
expr|struct
name|linux_link_hash_table
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|amt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|linux_link_hash_table
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_link_hash_table
operator|*
operator|)
name|NULL
return|;
if|if
condition|(
operator|!
name|NAME
argument_list|(
name|aout
argument_list|,
name|link_hash_table_init
argument_list|)
argument_list|(
operator|&
name|ret
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|linux_link_hash_newfunc
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|bfd_link_hash_table
operator|*
operator|)
name|NULL
return|;
block|}
name|ret
operator|->
name|dynobj
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|fixup_count
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|local_builtins
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|fixup_list
operator|=
name|NULL
expr_stmt|;
return|return
operator|&
name|ret
operator|->
name|root
operator|.
name|root
return|;
block|}
end_function

begin_comment
comment|/* Look up an entry in a Linux link hash table.  */
end_comment

begin_define
define|#
directive|define
name|linux_link_hash_lookup
parameter_list|(
name|table
parameter_list|,
name|string
parameter_list|,
name|create
parameter_list|,
name|copy
parameter_list|,
name|follow
parameter_list|)
define|\
value|((struct linux_link_hash_entry *) \    aout_link_hash_lookup (&(table)->root, (string), (create), (copy),\ 			  (follow)))
end_define

begin_comment
comment|/* Traverse a Linux link hash table.  */
end_comment

begin_define
define|#
directive|define
name|linux_link_hash_traverse
parameter_list|(
name|table
parameter_list|,
name|func
parameter_list|,
name|info
parameter_list|)
define|\
value|(aout_link_hash_traverse						\    (&(table)->root,							\     (boolean (*) PARAMS ((struct aout_link_hash_entry *, PTR))) (func),	\     (info)))
end_define

begin_comment
comment|/* Get the Linux link hash table from the info structure.  This is    just a cast.  */
end_comment

begin_define
define|#
directive|define
name|linux_hash_table
parameter_list|(
name|p
parameter_list|)
value|((struct linux_link_hash_table *) ((p)->hash))
end_define

begin_comment
comment|/* Store the information for a new fixup.  */
end_comment

begin_function
specifier|static
name|struct
name|fixup
modifier|*
name|new_fixup
parameter_list|(
name|info
parameter_list|,
name|h
parameter_list|,
name|value
parameter_list|,
name|builtin
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|struct
name|linux_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
name|int
name|builtin
decl_stmt|;
block|{
name|struct
name|fixup
modifier|*
name|f
decl_stmt|;
name|f
operator|=
operator|(
expr|struct
name|fixup
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
operator|&
name|info
operator|->
name|hash
operator|->
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fixup
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
name|f
return|;
name|f
operator|->
name|next
operator|=
name|linux_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|fixup_list
expr_stmt|;
name|linux_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|fixup_list
operator|=
name|f
expr_stmt|;
name|f
operator|->
name|h
operator|=
name|h
expr_stmt|;
name|f
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|f
operator|->
name|builtin
operator|=
name|builtin
expr_stmt|;
name|f
operator|->
name|jump
operator|=
literal|0
expr_stmt|;
operator|++
name|linux_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|fixup_count
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/* We come here once we realize that we are going to link to a shared    library.  We need to create a special section that contains the    fixup table, and we ultimately need to add a pointer to this into    the set vector for SHARABLE_CONFLICTS.  At this point we do not    know the size of the section, but that's OK - we just need to    create it for now.  */
end_comment

begin_function
specifier|static
name|boolean
name|linux_link_create_dynamic_sections
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|flagword
name|flags
decl_stmt|;
specifier|register
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* Note that we set the SEC_IN_MEMORY flag.  */
name|flags
operator|=
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_HAS_CONTENTS
operator||
name|SEC_IN_MEMORY
expr_stmt|;
comment|/* We choose to use the name ".linux-dynamic" for the fixup table.      Why not? */
name|s
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
literal|".linux-dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|flags
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|false
return|;
name|s
operator|->
name|_raw_size
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|contents
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Function to add a single symbol to the linker hash table.  This is    a wrapper around _bfd_generic_link_add_one_symbol which handles the    tweaking needed for dynamic linking support.  */
end_comment

begin_function
specifier|static
name|boolean
name|linux_add_one_symbol
parameter_list|(
name|info
parameter_list|,
name|abfd
parameter_list|,
name|name
parameter_list|,
name|flags
parameter_list|,
name|section
parameter_list|,
name|value
parameter_list|,
name|string
parameter_list|,
name|copy
parameter_list|,
name|collect
parameter_list|,
name|hashp
parameter_list|)
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|boolean
name|copy
decl_stmt|;
name|boolean
name|collect
decl_stmt|;
name|struct
name|bfd_link_hash_entry
modifier|*
modifier|*
name|hashp
decl_stmt|;
block|{
name|struct
name|linux_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|boolean
name|insert
decl_stmt|;
comment|/* Look up and see if we already have this symbol in the hash table.      If we do, and the defining entry is from a shared library, we      need to create the dynamic sections.       FIXME: What if abfd->xvec != info->hash->creator?  We may want to      be able to link Linux a.out and ELF objects together, but serious      confusion is possible.  */
name|insert
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
operator|&&
name|linux_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|==
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|SHARABLE_CONFLICTS
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|flags
operator|&
name|BSF_CONSTRUCTOR
operator|)
operator|!=
literal|0
operator|&&
name|abfd
operator|->
name|xvec
operator|==
name|info
operator|->
name|hash
operator|->
name|creator
condition|)
block|{
if|if
condition|(
operator|!
name|linux_link_create_dynamic_sections
argument_list|(
name|abfd
argument_list|,
name|info
argument_list|)
condition|)
return|return
name|false
return|;
name|linux_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|=
name|abfd
expr_stmt|;
name|insert
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|section
argument_list|)
operator|&&
name|abfd
operator|->
name|xvec
operator|==
name|info
operator|->
name|hash
operator|->
name|creator
condition|)
block|{
name|h
operator|=
name|linux_link_hash_lookup
argument_list|(
name|linux_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|name
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
name|struct
name|fixup
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|hashp
operator|!=
name|NULL
condition|)
operator|*
name|hashp
operator|=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|h
expr_stmt|;
name|f
operator|=
name|new_fixup
argument_list|(
name|info
argument_list|,
name|h
argument_list|,
name|value
argument_list|,
operator|!
name|IS_PLT_SYM
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|f
operator|->
name|jump
operator|=
name|IS_PLT_SYM
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
comment|/* Do the usual procedure for adding a symbol.  */
if|if
condition|(
operator|!
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|abfd
argument_list|,
name|name
argument_list|,
name|flags
argument_list|,
name|section
argument_list|,
name|value
argument_list|,
name|string
argument_list|,
name|copy
argument_list|,
name|collect
argument_list|,
name|hashp
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Insert a pointer to our table in the set vector.  The dynamic      linker requires this information */
if|if
condition|(
name|insert
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* Here we do our special thing to add the pointer to the 	 dynamic section in the SHARABLE_CONFLICTS set vector.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|linux_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
literal|".linux-dynamic"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_bfd_generic_link_add_one_symbol
argument_list|(
name|info
argument_list|,
name|linux_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
name|SHARABLE_CONFLICTS
argument_list|,
name|BSF_GLOBAL
operator||
name|BSF_CONSTRUCTOR
argument_list|,
name|s
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|NULL
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* We will crawl the hash table and come here for every global symbol.    We will examine each entry and see if there are indications that we    need to add a fixup.  There are two possible cases - one is where    you have duplicate definitions of PLT or GOT symbols - these will    have already been caught and added as "builtin" fixups.  If we find    that the corresponding non PLT/GOT symbol is also present, we    convert it to a regular fixup instead.     This function is called via linux_link_hash_traverse.  */
end_comment

begin_function
specifier|static
name|boolean
name|linux_tally_symbols
parameter_list|(
name|h
parameter_list|,
name|data
parameter_list|)
name|struct
name|linux_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|PTR
name|data
decl_stmt|;
block|{
name|struct
name|bfd_link_info
modifier|*
name|info
init|=
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|fixup
modifier|*
name|f
decl_stmt|,
modifier|*
name|f1
decl_stmt|;
name|int
name|is_plt
decl_stmt|;
name|struct
name|linux_link_hash_entry
modifier|*
name|h1
decl_stmt|,
modifier|*
name|h2
decl_stmt|;
name|boolean
name|exists
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_warning
condition|)
name|h
operator|=
operator|(
expr|struct
name|linux_link_hash_entry
operator|*
operator|)
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|i
operator|.
name|link
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_undefined
operator|&&
name|strncmp
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|NEEDS_SHRLIB
argument_list|,
sizeof|sizeof
name|NEEDS_SHRLIB
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|alloc
init|=
name|NULL
decl_stmt|;
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
operator|+
sizeof|sizeof
name|NEEDS_SHRLIB
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|alloc
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|bfd_size_type
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|alloc
operator|==
name|NULL
condition|)
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Output file requires shared library `%s'\n"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|strcpy
argument_list|(
name|alloc
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|alloc
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Output file requires shared library `%s.so.%s'\n"
argument_list|)
argument_list|,
name|alloc
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|alloc
argument_list|)
expr_stmt|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If this symbol is not a PLT/GOT, we do not even need to look at it */
name|is_plt
operator|=
name|IS_PLT_SYM
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_plt
operator|||
name|IS_GOT_SYM
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
condition|)
block|{
comment|/* Look up this symbol twice.  Once just as a regular lookup, 	 and then again following all of the indirect links until we 	 reach a real symbol.  */
name|h1
operator|=
name|linux_link_hash_lookup
argument_list|(
name|linux_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
operator|+
sizeof|sizeof
name|PLT_REF_PREFIX
operator|-
literal|1
operator|)
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* h2 does not follow indirect symbols. */
name|h2
operator|=
name|linux_link_hash_lookup
argument_list|(
name|linux_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
operator|+
sizeof|sizeof
name|PLT_REF_PREFIX
operator|-
literal|1
operator|)
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* The real symbol must exist but if it is also an ABS symbol, 	 there is no need to have a fixup.  This is because they both 	 came from the same library.  If on the other hand, we had to 	 use an indirect symbol to get to the real symbol, we add the 	 fixup anyway, since there are cases where these symbols come 	 from different shared libraries */
if|if
condition|(
name|h1
operator|!=
name|NULL
operator|&&
operator|(
operator|(
operator|(
name|h1
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h1
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
operator|&&
operator|!
name|bfd_is_abs_section
argument_list|(
name|h1
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
operator|)
operator|||
name|h2
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_indirect
operator|)
condition|)
block|{
comment|/* See if there is a "builtin" fixup already present 	     involving this symbol.  If so, convert it to a regular 	     fixup.  In the end, this relaxes some of the requirements 	     about the order of performing fixups.  */
name|exists
operator|=
name|false
expr_stmt|;
for|for
control|(
name|f1
operator|=
name|linux_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|fixup_list
init|;
name|f1
operator|!=
name|NULL
condition|;
name|f1
operator|=
name|f1
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|f1
operator|->
name|h
operator|!=
name|h
operator|&&
name|f1
operator|->
name|h
operator|!=
name|h1
operator|)
operator|||
operator|(
operator|!
name|f1
operator|->
name|builtin
operator|&&
operator|!
name|f1
operator|->
name|jump
operator|)
condition|)
continue|continue;
if|if
condition|(
name|f1
operator|->
name|h
operator|==
name|h1
condition|)
name|exists
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|exists
operator|&&
name|bfd_is_abs_section
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
condition|)
block|{
name|f
operator|=
name|new_fixup
argument_list|(
name|info
argument_list|,
name|h1
argument_list|,
name|f1
operator|->
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|f
operator|->
name|jump
operator|=
name|is_plt
expr_stmt|;
block|}
name|f1
operator|->
name|h
operator|=
name|h1
expr_stmt|;
name|f1
operator|->
name|jump
operator|=
name|is_plt
expr_stmt|;
name|f1
operator|->
name|builtin
operator|=
literal|0
expr_stmt|;
name|exists
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|exists
operator|&&
name|bfd_is_abs_section
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
condition|)
block|{
name|f
operator|=
name|new_fixup
argument_list|(
name|info
argument_list|,
name|h1
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
comment|/* FIXME: No way to return error.  */
name|abort
argument_list|()
expr_stmt|;
block|}
name|f
operator|->
name|jump
operator|=
name|is_plt
expr_stmt|;
block|}
block|}
comment|/* Quick and dirty way of stripping these symbols from the 	 symtab. */
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
argument_list|)
condition|)
name|h
operator|->
name|root
operator|.
name|written
operator|=
name|true
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is called to set the size of the .linux-dynamic section is.    It is called by the Linux linker emulation before_allocation    routine.  We have finished reading all of the input files, and now    we just scan the hash tables to find out how many additional fixups    are required.  */
end_comment

begin_function
name|boolean
name|bfd_i386linux_size_dynamic_sections
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|fixup
modifier|*
name|f
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|output_bfd
operator|->
name|xvec
operator|!=
operator|&
name|MY
argument_list|(
name|vec
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* First find the fixups... */
name|linux_link_hash_traverse
argument_list|(
name|linux_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
name|linux_tally_symbols
argument_list|,
operator|(
name|PTR
operator|)
name|info
argument_list|)
expr_stmt|;
comment|/* If there are builtin fixups, leave room for a marker.  This is      used by the dynamic linker so that it knows that all that follow      are builtin fixups instead of regular fixups.  */
for|for
control|(
name|f
operator|=
name|linux_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|fixup_list
init|;
name|f
operator|!=
name|NULL
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
if|if
condition|(
name|f
operator|->
name|builtin
condition|)
block|{
operator|++
name|linux_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|fixup_count
expr_stmt|;
operator|++
name|linux_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|local_builtins
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|linux_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|linux_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|fixup_count
operator|>
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Allocate memory for our fixup table.  We will fill it in later.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|linux_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
literal|".linux-dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|s
operator|->
name|_raw_size
operator|=
name|linux_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|fixup_count
operator|+
literal|1
expr_stmt|;
name|s
operator|->
name|_raw_size
operator|*=
literal|8
expr_stmt|;
name|s
operator|->
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|output_bfd
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|memset
argument_list|(
name|s
operator|->
name|contents
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|)
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* We come here once we are ready to actually write the fixup table to    the output file.  Scan the fixup tables and so forth and generate    the stuff we need.  */
end_comment

begin_function
specifier|static
name|boolean
name|linux_finish_dynamic_link
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|,
modifier|*
name|os
decl_stmt|,
modifier|*
name|is
decl_stmt|;
name|bfd_byte
modifier|*
name|fixup_table
decl_stmt|;
name|struct
name|linux_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|fixup
modifier|*
name|f
decl_stmt|;
name|unsigned
name|int
name|new_addr
decl_stmt|;
name|int
name|section_offset
decl_stmt|;
name|unsigned
name|int
name|fixups_written
decl_stmt|;
if|if
condition|(
name|linux_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
operator|==
name|NULL
condition|)
return|return
name|true
return|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|linux_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|dynobj
argument_list|,
literal|".linux-dynamic"
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|os
operator|=
name|s
operator|->
name|output_section
expr_stmt|;
name|fixups_written
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|LINUX_LINK_DEBUG
name|printf
argument_list|(
literal|"Fixup table file offset: %x  VMA: %x\n"
argument_list|,
name|os
operator|->
name|filepos
operator|+
name|s
operator|->
name|output_offset
argument_list|,
name|os
operator|->
name|vma
operator|+
name|s
operator|->
name|output_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fixup_table
operator|=
name|s
operator|->
name|contents
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|linux_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|fixup_count
argument_list|,
name|fixup_table
argument_list|)
expr_stmt|;
name|fixup_table
operator|+=
literal|4
expr_stmt|;
comment|/* Fill in fixup table.  */
for|for
control|(
name|f
operator|=
name|linux_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|fixup_list
init|;
name|f
operator|!=
name|NULL
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
if|if
condition|(
name|f
operator|->
name|builtin
condition|)
continue|continue;
if|if
condition|(
name|f
operator|->
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|f
operator|->
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Symbol %s not defined for fixups\n"
argument_list|)
argument_list|,
name|f
operator|->
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|is
operator|=
name|f
operator|->
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|section_offset
operator|=
name|is
operator|->
name|output_section
operator|->
name|vma
operator|+
name|is
operator|->
name|output_offset
expr_stmt|;
name|new_addr
operator|=
name|f
operator|->
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|section_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|LINUX_LINK_DEBUG
name|printf
argument_list|(
literal|"Fixup(%d) %s: %x %x\n"
argument_list|,
name|f
operator|->
name|jump
argument_list|,
name|f
operator|->
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|new_addr
argument_list|,
name|f
operator|->
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|f
operator|->
name|jump
condition|)
block|{
comment|/* Relative address */
name|new_addr
operator|=
name|new_addr
operator|-
operator|(
name|f
operator|->
name|value
operator|+
literal|5
operator|)
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|new_addr
argument_list|,
name|fixup_table
argument_list|)
expr_stmt|;
name|fixup_table
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|f
operator|->
name|value
operator|+
literal|1
argument_list|,
name|fixup_table
argument_list|)
expr_stmt|;
name|fixup_table
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|new_addr
argument_list|,
name|fixup_table
argument_list|)
expr_stmt|;
name|fixup_table
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|f
operator|->
name|value
argument_list|,
name|fixup_table
argument_list|)
expr_stmt|;
name|fixup_table
operator|+=
literal|4
expr_stmt|;
block|}
operator|++
name|fixups_written
expr_stmt|;
block|}
if|if
condition|(
name|linux_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|local_builtins
operator|!=
literal|0
condition|)
block|{
comment|/* Special marker so we know to switch to the other type of fixup */
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|fixup_table
argument_list|)
expr_stmt|;
name|fixup_table
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|fixup_table
argument_list|)
expr_stmt|;
name|fixup_table
operator|+=
literal|4
expr_stmt|;
operator|++
name|fixups_written
expr_stmt|;
for|for
control|(
name|f
operator|=
name|linux_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|fixup_list
init|;
name|f
operator|!=
name|NULL
condition|;
name|f
operator|=
name|f
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|f
operator|->
name|builtin
condition|)
continue|continue;
if|if
condition|(
name|f
operator|->
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|f
operator|->
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Symbol %s not defined for fixups\n"
argument_list|)
argument_list|,
name|f
operator|->
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|root
operator|.
name|string
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|is
operator|=
name|f
operator|->
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|section_offset
operator|=
name|is
operator|->
name|output_section
operator|->
name|vma
operator|+
name|is
operator|->
name|output_offset
expr_stmt|;
name|new_addr
operator|=
name|f
operator|->
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|section_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|LINUX_LINK_DEBUG
name|printf
argument_list|(
literal|"Fixup(B) %s: %x %x\n"
argument_list|,
name|f
operator|->
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|new_addr
argument_list|,
name|f
operator|->
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|new_addr
argument_list|,
name|fixup_table
argument_list|)
expr_stmt|;
name|fixup_table
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
name|f
operator|->
name|value
argument_list|,
name|fixup_table
argument_list|)
expr_stmt|;
name|fixup_table
operator|+=
literal|4
expr_stmt|;
operator|++
name|fixups_written
expr_stmt|;
block|}
block|}
if|if
condition|(
name|linux_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|fixup_count
operator|!=
name|fixups_written
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"Warning: fixup count mismatch\n"
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|linux_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|fixup_count
operator|>
name|fixups_written
condition|)
block|{
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|fixup_table
argument_list|)
expr_stmt|;
name|fixup_table
operator|+=
literal|4
expr_stmt|;
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|fixup_table
argument_list|)
expr_stmt|;
name|fixup_table
operator|+=
literal|4
expr_stmt|;
operator|++
name|fixups_written
expr_stmt|;
block|}
block|}
name|h
operator|=
name|linux_link_hash_lookup
argument_list|(
name|linux_hash_table
argument_list|(
name|info
argument_list|)
argument_list|,
literal|"__BUILTIN_FIXUPS__"
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
operator|&&
operator|(
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
block|{
name|is
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|section_offset
operator|=
name|is
operator|->
name|output_section
operator|->
name|vma
operator|+
name|is
operator|->
name|output_offset
expr_stmt|;
name|new_addr
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|section_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|LINUX_LINK_DEBUG
name|printf
argument_list|(
literal|"Builtin fixup table at %x\n"
argument_list|,
name|new_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
name|new_addr
argument_list|,
name|fixup_table
argument_list|)
expr_stmt|;
block|}
else|else
name|bfd_put_32
argument_list|(
name|output_bfd
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|fixup_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|output_bfd
argument_list|,
call|(
name|file_ptr
call|)
argument_list|(
name|os
operator|->
name|filepos
operator|+
name|s
operator|->
name|output_offset
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_bwrite
argument_list|(
operator|(
name|PTR
operator|)
name|s
operator|->
name|contents
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|,
name|output_bfd
argument_list|)
operator|!=
name|s
operator|->
name|_raw_size
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MY_bfd_link_hash_table_create
value|linux_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|MY_add_one_symbol
value|linux_add_one_symbol
end_define

begin_define
define|#
directive|define
name|MY_finish_dynamic_link
value|linux_finish_dynamic_link
end_define

begin_define
define|#
directive|define
name|MY_zmagic_contiguous
value|1
end_define

begin_include
include|#
directive|include
file|"aout-target.h"
end_include

end_unit

