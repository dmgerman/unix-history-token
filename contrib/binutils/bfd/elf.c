begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ELF executable support for BFD.    Copyright 1993, 1994, 1995, 1996, 1997 Free Software Foundation, Inc.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*  SECTION 	ELF backends  	BFD support for ELF formats is being worked on. 	Currently, the best supported back ends are for sparc and i386 	(running svr4 or Solaris 2).  	Documentation of the internals of the support code still needs 	to be written.  The code is changing quickly enough that we 	haven't bothered yet.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_define
define|#
directive|define
name|ARCH_SIZE
value|0
end_define

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_expr_stmt
specifier|static
name|INLINE
expr|struct
name|elf_segment_map
operator|*
name|make_mapping
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|*
operator|,
name|unsigned
name|int
operator|,
name|unsigned
name|int
operator|,
name|boolean
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|boolean
name|map_sections_to_segments
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elf_sort_sections
name|PARAMS
argument_list|(
operator|(
specifier|const
name|PTR
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|assign_file_positions_for_segments
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|assign_file_positions_except_relocs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|prep_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|swap_out_syms
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_strtab_hash
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|copy_private_bfd_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|elf_read
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|long
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_fake_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|assign_section_numbers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|int
name|sym_is_global
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asymbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|elf_map_symbols
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_size_type
name|get_program_header_size
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Swap version information in and out.  The version information is    currently size independent.  If that ever changes, this code will    need to move into elfcode.h.  */
end_comment

begin_comment
comment|/* Swap in a Verdef structure.  */
end_comment

begin_function
name|void
name|_bfd_elf_swap_verdef_in
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf_External_Verdef
modifier|*
name|src
decl_stmt|;
name|Elf_Internal_Verdef
modifier|*
name|dst
decl_stmt|;
block|{
name|dst
operator|->
name|vd_version
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_version
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vd_flags
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_flags
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vd_ndx
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_ndx
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vd_cnt
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_cnt
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vd_hash
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_hash
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vd_aux
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_aux
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vd_next
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap out a Verdef structure.  */
end_comment

begin_function
name|void
name|_bfd_elf_swap_verdef_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf_Internal_Verdef
modifier|*
name|src
decl_stmt|;
name|Elf_External_Verdef
modifier|*
name|dst
decl_stmt|;
block|{
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_version
argument_list|,
name|dst
operator|->
name|vd_version
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_flags
argument_list|,
name|dst
operator|->
name|vd_flags
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_ndx
argument_list|,
name|dst
operator|->
name|vd_ndx
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_cnt
argument_list|,
name|dst
operator|->
name|vd_cnt
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_hash
argument_list|,
name|dst
operator|->
name|vd_hash
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_aux
argument_list|,
name|dst
operator|->
name|vd_aux
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vd_next
argument_list|,
name|dst
operator|->
name|vd_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap in a Verdaux structure.  */
end_comment

begin_function
name|void
name|_bfd_elf_swap_verdaux_in
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf_External_Verdaux
modifier|*
name|src
decl_stmt|;
name|Elf_Internal_Verdaux
modifier|*
name|dst
decl_stmt|;
block|{
name|dst
operator|->
name|vda_name
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vda_name
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vda_next
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vda_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap out a Verdaux structure.  */
end_comment

begin_function
name|void
name|_bfd_elf_swap_verdaux_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf_Internal_Verdaux
modifier|*
name|src
decl_stmt|;
name|Elf_External_Verdaux
modifier|*
name|dst
decl_stmt|;
block|{
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vda_name
argument_list|,
name|dst
operator|->
name|vda_name
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vda_next
argument_list|,
name|dst
operator|->
name|vda_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap in a Verneed structure.  */
end_comment

begin_function
name|void
name|_bfd_elf_swap_verneed_in
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf_External_Verneed
modifier|*
name|src
decl_stmt|;
name|Elf_Internal_Verneed
modifier|*
name|dst
decl_stmt|;
block|{
name|dst
operator|->
name|vn_version
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vn_version
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vn_cnt
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vn_cnt
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vn_file
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vn_file
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vn_aux
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vn_aux
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vn_next
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vn_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap out a Verneed structure.  */
end_comment

begin_function
name|void
name|_bfd_elf_swap_verneed_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf_Internal_Verneed
modifier|*
name|src
decl_stmt|;
name|Elf_External_Verneed
modifier|*
name|dst
decl_stmt|;
block|{
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vn_version
argument_list|,
name|dst
operator|->
name|vn_version
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vn_cnt
argument_list|,
name|dst
operator|->
name|vn_cnt
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vn_file
argument_list|,
name|dst
operator|->
name|vn_file
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vn_aux
argument_list|,
name|dst
operator|->
name|vn_aux
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vn_next
argument_list|,
name|dst
operator|->
name|vn_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap in a Vernaux structure.  */
end_comment

begin_function
name|void
name|_bfd_elf_swap_vernaux_in
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf_External_Vernaux
modifier|*
name|src
decl_stmt|;
name|Elf_Internal_Vernaux
modifier|*
name|dst
decl_stmt|;
block|{
name|dst
operator|->
name|vna_hash
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vna_hash
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vna_flags
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vna_flags
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vna_other
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vna_other
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vna_name
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vna_name
argument_list|)
expr_stmt|;
name|dst
operator|->
name|vna_next
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vna_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap out a Vernaux structure.  */
end_comment

begin_function
name|void
name|_bfd_elf_swap_vernaux_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf_Internal_Vernaux
modifier|*
name|src
decl_stmt|;
name|Elf_External_Vernaux
modifier|*
name|dst
decl_stmt|;
block|{
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vna_hash
argument_list|,
name|dst
operator|->
name|vna_hash
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vna_flags
argument_list|,
name|dst
operator|->
name|vna_flags
argument_list|)
expr_stmt|;
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vna_other
argument_list|,
name|dst
operator|->
name|vna_other
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vna_name
argument_list|,
name|dst
operator|->
name|vna_name
argument_list|)
expr_stmt|;
name|bfd_h_put_32
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vna_next
argument_list|,
name|dst
operator|->
name|vna_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap in a Versym structure.  */
end_comment

begin_function
name|void
name|_bfd_elf_swap_versym_in
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf_External_Versym
modifier|*
name|src
decl_stmt|;
name|Elf_Internal_Versym
modifier|*
name|dst
decl_stmt|;
block|{
name|dst
operator|->
name|vs_vers
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vs_vers
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Swap out a Versym structure.  */
end_comment

begin_function
name|void
name|_bfd_elf_swap_versym_out
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|Elf_Internal_Versym
modifier|*
name|src
decl_stmt|;
name|Elf_External_Versym
modifier|*
name|dst
decl_stmt|;
block|{
name|bfd_h_put_16
argument_list|(
name|abfd
argument_list|,
name|src
operator|->
name|vs_vers
argument_list|,
name|dst
operator|->
name|vs_vers
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Standard ELF hash function.  Do not change this function; you will    cause invalid hash tables to be generated.  (Well, you would if this    were being used yet.)  */
end_comment

begin_function
name|unsigned
name|long
name|bfd_elf_hash
parameter_list|(
name|name
parameter_list|)
name|CONST
name|unsigned
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|unsigned
name|long
name|h
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|g
decl_stmt|;
name|int
name|ch
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|name
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|h
operator|=
operator|(
name|h
operator|<<
literal|4
operator|)
operator|+
name|ch
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|=
operator|(
name|h
operator|&
literal|0xf0000000
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|h
operator|^=
name|g
operator|>>
literal|24
expr_stmt|;
name|h
operator|&=
operator|~
name|g
expr_stmt|;
block|}
block|}
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/* Read a specified number of bytes at a specified offset in an ELF    file, into a newly allocated buffer, and return a pointer to the    buffer. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|elf_read
parameter_list|(
name|abfd
parameter_list|,
name|offset
parameter_list|,
name|size
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|buf
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|size
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_system_call
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_function
name|boolean
name|bfd_elf_mkobject
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
comment|/* this just does initialization */
comment|/* coff_mkobject zalloc's space for tdata.coff_obj_data ... */
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|=
operator|(
expr|struct
name|elf_obj_tdata
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_obj_tdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
comment|/* since everything is done at close time, do we need any      initialization? */
return|return
name|true
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|bfd_elf_get_str_section
parameter_list|(
name|abfd
parameter_list|,
name|shindex
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|shindex
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|i_shdrp
decl_stmt|;
name|char
modifier|*
name|shstrtab
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|unsigned
name|int
name|shstrtabsize
decl_stmt|;
name|i_shdrp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_shdrp
operator|==
literal|0
operator|||
name|i_shdrp
index|[
name|shindex
index|]
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|shstrtab
operator|=
operator|(
name|char
operator|*
operator|)
name|i_shdrp
index|[
name|shindex
index|]
operator|->
name|contents
expr_stmt|;
if|if
condition|(
name|shstrtab
operator|==
name|NULL
condition|)
block|{
comment|/* No cached one, attempt to read, and cache what we read. */
name|offset
operator|=
name|i_shdrp
index|[
name|shindex
index|]
operator|->
name|sh_offset
expr_stmt|;
name|shstrtabsize
operator|=
name|i_shdrp
index|[
name|shindex
index|]
operator|->
name|sh_size
expr_stmt|;
name|shstrtab
operator|=
name|elf_read
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|shstrtabsize
argument_list|)
expr_stmt|;
name|i_shdrp
index|[
name|shindex
index|]
operator|->
name|contents
operator|=
operator|(
name|PTR
operator|)
name|shstrtab
expr_stmt|;
block|}
return|return
name|shstrtab
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|bfd_elf_string_from_elf_section
parameter_list|(
name|abfd
parameter_list|,
name|shindex
parameter_list|,
name|strindex
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|shindex
decl_stmt|;
name|unsigned
name|int
name|strindex
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
if|if
condition|(
name|strindex
operator|==
literal|0
condition|)
return|return
literal|""
return|;
name|hdr
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|contents
operator|==
name|NULL
operator|&&
name|bfd_elf_get_str_section
argument_list|(
name|abfd
argument_list|,
name|shindex
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|hdr
operator|->
name|contents
operator|)
operator|+
name|strindex
return|;
block|}
end_function

begin_comment
comment|/* Make a BFD section from an ELF section.  We store a pointer to the    BFD section in the bfd_section field of the header.  */
end_comment

begin_function
name|boolean
name|_bfd_elf_make_section_from_shdr
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|asection
modifier|*
name|newsect
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
if|if
condition|(
name|hdr
operator|->
name|bfd_section
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|bfd_section
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|newsect
operator|=
name|bfd_make_section_anyway
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsect
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|newsect
operator|->
name|filepos
operator|=
name|hdr
operator|->
name|sh_offset
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_vma
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|,
name|hdr
operator|->
name|sh_addr
argument_list|)
operator|||
operator|!
name|bfd_set_section_size
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|,
name|hdr
operator|->
name|sh_size
argument_list|)
operator|||
operator|!
name|bfd_set_section_alignment
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|,
name|bfd_log2
argument_list|(
name|hdr
operator|->
name|sh_addralign
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
name|flags
operator|=
name|SEC_NO_FLAGS
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|!=
name|SHT_NOBITS
condition|)
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|flags
operator||=
name|SEC_ALLOC
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|!=
name|SHT_NOBITS
condition|)
name|flags
operator||=
name|SEC_LOAD
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_WRITE
operator|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|SEC_READONLY
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_EXECINSTR
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|SEC_CODE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|SEC_DATA
expr_stmt|;
comment|/* The debugging sections appear to be recognized only by name, not      any sort of flag.  */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".debug"
argument_list|,
sizeof|sizeof
expr|".debug"
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".line"
argument_list|,
sizeof|sizeof
expr|".line"
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".stab"
argument_list|,
sizeof|sizeof
expr|".stab"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|SEC_DEBUGGING
expr_stmt|;
comment|/* As a GNU extension, if the name begins with .gnu.linkonce, we      only link a single copy of the section.  This is used to support      g++.  g++ will emit each template expansion in its own section.      The symbols will be defined as weak, so that multiple definitions      are permitted.  The GNU linker extension is to actually discard      all but one of the sections.  */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|".gnu.linkonce"
argument_list|,
sizeof|sizeof
expr|".gnu.linkonce"
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|SEC_LINK_ONCE
operator||
name|SEC_LINK_DUPLICATES_DISCARD
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_set_section_flags
argument_list|(
name|abfd
argument_list|,
name|newsect
argument_list|,
name|flags
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Phdr
modifier|*
name|phdr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Look through the phdrs to see if we need to adjust the lma.  */
name|phdr
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|phdr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_phnum
condition|;
name|i
operator|++
operator|,
name|phdr
operator|++
control|)
block|{
if|if
condition|(
name|phdr
operator|->
name|p_type
operator|==
name|PT_LOAD
operator|&&
name|phdr
operator|->
name|p_paddr
operator|!=
literal|0
operator|&&
name|phdr
operator|->
name|p_vaddr
operator|!=
name|phdr
operator|->
name|p_paddr
operator|&&
name|phdr
operator|->
name|p_vaddr
operator|<=
name|hdr
operator|->
name|sh_addr
operator|&&
name|phdr
operator|->
name|p_vaddr
operator|+
name|phdr
operator|->
name|p_memsz
operator|>=
name|hdr
operator|->
name|sh_addr
operator|+
name|hdr
operator|->
name|sh_size
operator|&&
operator|(
operator|(
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
operator|||
operator|(
name|phdr
operator|->
name|p_offset
operator|<=
name|hdr
operator|->
name|sh_offset
operator|&&
operator|(
name|phdr
operator|->
name|p_offset
operator|+
name|phdr
operator|->
name|p_filesz
operator|>=
name|hdr
operator|->
name|sh_offset
operator|+
name|hdr
operator|->
name|sh_size
operator|)
operator|)
operator|)
condition|)
block|{
name|newsect
operator|->
name|lma
operator|+=
name|phdr
operator|->
name|p_paddr
operator|-
name|phdr
operator|->
name|p_vaddr
expr_stmt|;
break|break;
block|}
block|}
block|}
name|hdr
operator|->
name|bfd_section
operator|=
name|newsect
expr_stmt|;
name|elf_section_data
argument_list|(
name|newsect
argument_list|)
operator|->
name|this_hdr
operator|=
operator|*
name|hdr
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* INTERNAL_FUNCTION 	bfd_elf_find_section  SYNOPSIS 	struct elf_internal_shdr *bfd_elf_find_section (bfd *abfd, char *name);  DESCRIPTION 	Helper functions for GDB to locate the string tables. 	Since BFD hides string tables from callers, GDB needs to use an 	internal hook to find them.  Sun's .stabstr, in particular, 	isn't even pointed to by the .stab section, so ordinary 	mechanisms wouldn't work to find it, even if we had some. */
end_comment

begin_function
name|struct
name|elf_internal_shdr
modifier|*
name|bfd_elf_find_section
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|i_shdrp
decl_stmt|;
name|char
modifier|*
name|shstrtab
decl_stmt|;
name|unsigned
name|int
name|max
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|i_shdrp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_shdrp
operator|!=
name|NULL
condition|)
block|{
name|shstrtab
operator|=
name|bfd_elf_get_str_section
argument_list|(
name|abfd
argument_list|,
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
argument_list|)
expr_stmt|;
if|if
condition|(
name|shstrtab
operator|!=
name|NULL
condition|)
block|{
name|max
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shnum
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|&
name|shstrtab
index|[
name|i_shdrp
index|[
name|i
index|]
operator|->
name|sh_name
index|]
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|i_shdrp
index|[
name|i
index|]
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|bfd_elf_section_type_names
index|[]
init|=
block|{
literal|"SHT_NULL"
block|,
literal|"SHT_PROGBITS"
block|,
literal|"SHT_SYMTAB"
block|,
literal|"SHT_STRTAB"
block|,
literal|"SHT_RELA"
block|,
literal|"SHT_HASH"
block|,
literal|"SHT_DYNAMIC"
block|,
literal|"SHT_NOTE"
block|,
literal|"SHT_NOBITS"
block|,
literal|"SHT_REL"
block|,
literal|"SHT_SHLIB"
block|,
literal|"SHT_DYNSYM"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ELF relocs are against symbols.  If we are producing relocateable    output, and the reloc is against an external symbol, and nothing    has given us any additional addend, the resulting reloc will also    be against the same symbol.  In such a case, we don't want to    change anything about the way the reloc is handled, since it will    all be done at final link time.  Rather than put special case code    into bfd_perform_relocation, all the reloc types use this howto    function.  It just short circuits the reloc if producing    relocateable output against an external symbol.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|bfd_reloc_status_type
name|bfd_elf_generic_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
if|if
condition|(
name|output_bfd
operator|!=
operator|(
name|bfd
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|symbol
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|!
name|reloc_entry
operator|->
name|howto
operator|->
name|partial_inplace
operator|||
name|reloc_entry
operator|->
name|addend
operator|==
literal|0
operator|)
condition|)
block|{
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
return|return
name|bfd_reloc_continue
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print out the program headers.  */
end_comment

begin_function
name|boolean
name|_bfd_elf_print_private_bfd_data
parameter_list|(
name|abfd
parameter_list|,
name|farg
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|farg
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
init|=
operator|(
name|FILE
operator|*
operator|)
name|farg
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|p
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_byte
modifier|*
name|dynbuf
init|=
name|NULL
decl_stmt|;
name|p
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|phdr
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nProgram Header:\n"
argument_list|)
expr_stmt|;
name|c
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_phnum
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|p_type
condition|)
block|{
case|case
name|PT_NULL
case|:
name|s
operator|=
literal|"NULL"
expr_stmt|;
break|break;
case|case
name|PT_LOAD
case|:
name|s
operator|=
literal|"LOAD"
expr_stmt|;
break|break;
case|case
name|PT_DYNAMIC
case|:
name|s
operator|=
literal|"DYNAMIC"
expr_stmt|;
break|break;
case|case
name|PT_INTERP
case|:
name|s
operator|=
literal|"INTERP"
expr_stmt|;
break|break;
case|case
name|PT_NOTE
case|:
name|s
operator|=
literal|"NOTE"
expr_stmt|;
break|break;
case|case
name|PT_SHLIB
case|:
name|s
operator|=
literal|"SHLIB"
expr_stmt|;
break|break;
case|case
name|PT_PHDR
case|:
name|s
operator|=
literal|"PHDR"
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x%lx"
argument_list|,
name|p
operator|->
name|p_type
argument_list|)
expr_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%8s off    0x"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|f
argument_list|,
name|p
operator|->
name|p_offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" vaddr 0x"
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|f
argument_list|,
name|p
operator|->
name|p_vaddr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" paddr 0x"
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|f
argument_list|,
name|p
operator|->
name|p_paddr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" align 2**%u\n"
argument_list|,
name|bfd_log2
argument_list|(
name|p
operator|->
name|p_align
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"         filesz 0x"
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|f
argument_list|,
name|p
operator|->
name|p_filesz
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" memsz 0x"
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|f
argument_list|,
name|p
operator|->
name|p_memsz
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" flags %c%c%c"
argument_list|,
operator|(
name|p
operator|->
name|p_flags
operator|&
name|PF_R
operator|)
operator|!=
literal|0
condition|?
literal|'r'
else|:
literal|'-'
argument_list|,
operator|(
name|p
operator|->
name|p_flags
operator|&
name|PF_W
operator|)
operator|!=
literal|0
condition|?
literal|'w'
else|:
literal|'-'
argument_list|,
operator|(
name|p
operator|->
name|p_flags
operator|&
name|PF_X
operator|)
operator|!=
literal|0
condition|?
literal|'x'
else|:
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|p_flags
operator|&
operator|~
operator|(
name|PF_R
operator||
name|PF_W
operator||
name|PF_X
operator|)
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" %lx"
argument_list|,
name|p
operator|->
name|p_flags
operator|&
operator|~
operator|(
name|PF_R
operator||
name|PF_W
operator||
name|PF_X
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|int
name|elfsec
decl_stmt|;
name|unsigned
name|long
name|link
decl_stmt|;
name|bfd_byte
modifier|*
name|extdyn
decl_stmt|,
modifier|*
name|extdynend
decl_stmt|;
name|size_t
name|extdynsize
decl_stmt|;
name|void
argument_list|(
argument|*swap_dyn_in
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
specifier|const
name|PTR
operator|,
name|Elf_Internal_Dyn
operator|*
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nDynamic Section:\n"
argument_list|)
expr_stmt|;
name|dynbuf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynbuf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
operator|(
name|PTR
operator|)
name|dynbuf
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|elfsec
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|elfsec
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error_return
goto|;
name|link
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|elfsec
index|]
operator|->
name|sh_link
expr_stmt|;
name|extdynsize
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|sizeof_dyn
expr_stmt|;
name|swap_dyn_in
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|swap_dyn_in
expr_stmt|;
name|extdyn
operator|=
name|dynbuf
expr_stmt|;
name|extdynend
operator|=
name|extdyn
operator|+
name|s
operator|->
name|_raw_size
expr_stmt|;
for|for
control|(
init|;
name|extdyn
operator|<
name|extdynend
condition|;
name|extdyn
operator|+=
name|extdynsize
control|)
block|{
name|Elf_Internal_Dyn
name|dyn
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|ab
index|[
literal|20
index|]
decl_stmt|;
name|boolean
name|stringp
decl_stmt|;
call|(
modifier|*
name|swap_dyn_in
call|)
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|extdyn
argument_list|,
operator|&
name|dyn
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyn
operator|.
name|d_tag
operator|==
name|DT_NULL
condition|)
break|break;
name|stringp
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
name|dyn
operator|.
name|d_tag
condition|)
block|{
default|default:
name|sprintf
argument_list|(
name|ab
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|dyn
operator|.
name|d_tag
argument_list|)
expr_stmt|;
name|name
operator|=
name|ab
expr_stmt|;
break|break;
case|case
name|DT_NEEDED
case|:
name|name
operator|=
literal|"NEEDED"
expr_stmt|;
name|stringp
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
name|name
operator|=
literal|"PLTRELSZ"
expr_stmt|;
break|break;
case|case
name|DT_PLTGOT
case|:
name|name
operator|=
literal|"PLTGOT"
expr_stmt|;
break|break;
case|case
name|DT_HASH
case|:
name|name
operator|=
literal|"HASH"
expr_stmt|;
break|break;
case|case
name|DT_STRTAB
case|:
name|name
operator|=
literal|"STRTAB"
expr_stmt|;
break|break;
case|case
name|DT_SYMTAB
case|:
name|name
operator|=
literal|"SYMTAB"
expr_stmt|;
break|break;
case|case
name|DT_RELA
case|:
name|name
operator|=
literal|"RELA"
expr_stmt|;
break|break;
case|case
name|DT_RELASZ
case|:
name|name
operator|=
literal|"RELASZ"
expr_stmt|;
break|break;
case|case
name|DT_RELAENT
case|:
name|name
operator|=
literal|"RELAENT"
expr_stmt|;
break|break;
case|case
name|DT_STRSZ
case|:
name|name
operator|=
literal|"STRSZ"
expr_stmt|;
break|break;
case|case
name|DT_SYMENT
case|:
name|name
operator|=
literal|"SYMENT"
expr_stmt|;
break|break;
case|case
name|DT_INIT
case|:
name|name
operator|=
literal|"INIT"
expr_stmt|;
break|break;
case|case
name|DT_FINI
case|:
name|name
operator|=
literal|"FINI"
expr_stmt|;
break|break;
case|case
name|DT_SONAME
case|:
name|name
operator|=
literal|"SONAME"
expr_stmt|;
name|stringp
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|DT_RPATH
case|:
name|name
operator|=
literal|"RPATH"
expr_stmt|;
name|stringp
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|DT_SYMBOLIC
case|:
name|name
operator|=
literal|"SYMBOLIC"
expr_stmt|;
break|break;
case|case
name|DT_REL
case|:
name|name
operator|=
literal|"REL"
expr_stmt|;
break|break;
case|case
name|DT_RELSZ
case|:
name|name
operator|=
literal|"RELSZ"
expr_stmt|;
break|break;
case|case
name|DT_RELENT
case|:
name|name
operator|=
literal|"RELENT"
expr_stmt|;
break|break;
case|case
name|DT_PLTREL
case|:
name|name
operator|=
literal|"PLTREL"
expr_stmt|;
break|break;
case|case
name|DT_DEBUG
case|:
name|name
operator|=
literal|"DEBUG"
expr_stmt|;
break|break;
case|case
name|DT_TEXTREL
case|:
name|name
operator|=
literal|"TEXTREL"
expr_stmt|;
break|break;
case|case
name|DT_JMPREL
case|:
name|name
operator|=
literal|"JMPREL"
expr_stmt|;
break|break;
case|case
name|DT_AUXILIARY
case|:
name|name
operator|=
literal|"AUXILIARY"
expr_stmt|;
name|stringp
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|DT_FILTER
case|:
name|name
operator|=
literal|"FILTER"
expr_stmt|;
name|stringp
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|DT_VERSYM
case|:
name|name
operator|=
literal|"VERSYM"
expr_stmt|;
break|break;
case|case
name|DT_VERDEF
case|:
name|name
operator|=
literal|"VERDEF"
expr_stmt|;
break|break;
case|case
name|DT_VERDEFNUM
case|:
name|name
operator|=
literal|"VERDEFNUM"
expr_stmt|;
break|break;
case|case
name|DT_VERNEED
case|:
name|name
operator|=
literal|"VERNEED"
expr_stmt|;
break|break;
case|case
name|DT_VERNEEDNUM
case|:
name|name
operator|=
literal|"VERNEEDNUM"
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"  %-11s "
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stringp
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"0x%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|dyn
operator|.
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|string
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|link
argument_list|,
name|dyn
operator|.
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dynbuf
argument_list|)
expr_stmt|;
name|dynbuf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|elf_dynverdef
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
operator|&&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verdef
operator|==
name|NULL
operator|)
operator|||
operator|(
name|elf_dynverref
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
operator|&&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verref
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|_bfd_elf_slurp_version_tables
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|elf_dynverdef
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Verdef
modifier|*
name|t
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nVersion definitions:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verdef
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|vd_nextdef
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%d 0x%2.2x 0x%8.8lx %s\n"
argument_list|,
name|t
operator|->
name|vd_ndx
argument_list|,
name|t
operator|->
name|vd_flags
argument_list|,
name|t
operator|->
name|vd_hash
argument_list|,
name|t
operator|->
name|vd_nodename
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|vd_auxptr
operator|->
name|vda_nextptr
operator|!=
name|NULL
condition|)
block|{
name|Elf_Internal_Verdaux
modifier|*
name|a
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|t
operator|->
name|vd_auxptr
operator|->
name|vda_nextptr
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|vda_nextptr
control|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s "
argument_list|,
name|a
operator|->
name|vda_nodename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|elf_dynverref
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Verneed
modifier|*
name|t
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\nVersion References:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verref
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|vn_nextref
control|)
block|{
name|Elf_Internal_Vernaux
modifier|*
name|a
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"  required from %s:\n"
argument_list|,
name|t
operator|->
name|vn_filename
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|t
operator|->
name|vn_auxptr
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|vna_nextptr
control|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"    0x%8.8lx 0x%2.2x %2.2d %s\n"
argument_list|,
name|a
operator|->
name|vna_hash
argument_list|,
name|a
operator|->
name|vna_flags
argument_list|,
name|a
operator|->
name|vna_other
argument_list|,
name|a
operator|->
name|vna_nodename
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|dynbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dynbuf
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Display ELF-specific fields of a symbol.  */
end_comment

begin_function
name|void
name|bfd_elf_print_symbol
parameter_list|(
name|abfd
parameter_list|,
name|filep
parameter_list|,
name|symbol
parameter_list|,
name|how
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|PTR
name|filep
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|bfd_print_symbol_type
name|how
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
init|=
operator|(
name|FILE
operator|*
operator|)
name|filep
decl_stmt|;
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|bfd_print_symbol_name
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_more
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"elf "
argument_list|)
expr_stmt|;
name|fprintf_vma
argument_list|(
name|file
argument_list|,
name|symbol
operator|->
name|value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %lx"
argument_list|,
operator|(
name|long
operator|)
name|symbol
operator|->
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_print_symbol_all
case|:
block|{
name|CONST
name|char
modifier|*
name|section_name
decl_stmt|;
name|section_name
operator|=
name|symbol
operator|->
name|section
condition|?
name|symbol
operator|->
name|section
operator|->
name|name
else|:
literal|"(*none*)"
expr_stmt|;
name|bfd_print_symbol_vandf
argument_list|(
operator|(
name|PTR
operator|)
name|file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s\t"
argument_list|,
name|section_name
argument_list|)
expr_stmt|;
comment|/* Print the "other" value for a symbol.  For common symbols, 	   we've already printed the size; now print the alignment. 	   For other symbols, we have no specified alignment, and 	   we've printed the address; now print the size.  */
name|fprintf_vma
argument_list|(
name|file
argument_list|,
operator|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|?
operator|(
operator|(
name|elf_symbol_type
operator|*
operator|)
name|symbol
operator|)
operator|->
name|internal_elf_sym
operator|.
name|st_value
else|:
operator|(
operator|(
name|elf_symbol_type
operator|*
operator|)
name|symbol
operator|)
operator|->
name|internal_elf_sym
operator|.
name|st_size
operator|)
argument_list|)
expr_stmt|;
comment|/* If we have version information, print it.  */
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynversym_section
operator|!=
literal|0
operator|&&
operator|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynverdef_section
operator|!=
literal|0
operator|||
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynverref_section
operator|!=
literal|0
operator|)
condition|)
block|{
name|unsigned
name|int
name|vernum
decl_stmt|;
specifier|const
name|char
modifier|*
name|version_string
decl_stmt|;
name|vernum
operator|=
operator|(
operator|(
name|elf_symbol_type
operator|*
operator|)
name|symbol
operator|)
operator|->
name|version
operator|&
name|VERSYM_VERSION
expr_stmt|;
if|if
condition|(
name|vernum
operator|==
literal|0
condition|)
name|version_string
operator|=
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
name|vernum
operator|==
literal|1
condition|)
name|version_string
operator|=
literal|"Base"
expr_stmt|;
elseif|else
if|if
condition|(
name|vernum
operator|<=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cverdefs
condition|)
name|version_string
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verdef
index|[
name|vernum
operator|-
literal|1
index|]
operator|.
name|vd_nodename
expr_stmt|;
else|else
block|{
name|Elf_Internal_Verneed
modifier|*
name|t
decl_stmt|;
name|version_string
operator|=
literal|""
expr_stmt|;
for|for
control|(
name|t
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verref
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|vn_nextref
control|)
block|{
name|Elf_Internal_Vernaux
modifier|*
name|a
decl_stmt|;
for|for
control|(
name|a
operator|=
name|t
operator|->
name|vn_auxptr
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|vna_nextptr
control|)
block|{
if|if
condition|(
name|a
operator|->
name|vna_other
operator|==
name|vernum
condition|)
block|{
name|version_string
operator|=
name|a
operator|->
name|vna_nodename
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|(
operator|(
operator|(
name|elf_symbol_type
operator|*
operator|)
name|symbol
operator|)
operator|->
name|version
operator|&
name|VERSYM_HIDDEN
operator|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  %-11s"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" (%s)"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|10
operator|-
name|strlen
argument_list|(
name|version_string
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the st_other field is not zero, print it.  */
if|if
condition|(
operator|(
operator|(
name|elf_symbol_type
operator|*
operator|)
name|symbol
operator|)
operator|->
name|internal_elf_sym
operator|.
name|st_other
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" 0x%02x"
argument_list|,
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
operator|(
name|elf_symbol_type
operator|*
operator|)
name|symbol
argument_list|)
operator|->
name|internal_elf_sym
operator|.
name|st_other
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
name|symbol
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create an entry in an ELF linker hash table.  */
end_comment

begin_function
name|struct
name|bfd_hash_entry
modifier|*
name|_bfd_elf_link_hash_newfunc
parameter_list|(
name|entry
parameter_list|,
name|table
parameter_list|,
name|string
parameter_list|)
name|struct
name|bfd_hash_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bfd_hash_table
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|elf_link_hash_entry
modifier|*
name|ret
init|=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|entry
decl_stmt|;
comment|/* Allocate the structure if it has not already been allocated by a      subclass.  */
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|bfd_hash_allocate
argument_list|(
name|table
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_hash_entry
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
comment|/* Call the allocation method of the superclass.  */
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|_bfd_link_hash_newfunc
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
argument_list|,
name|table
argument_list|,
name|string
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
operator|(
expr|struct
name|elf_link_hash_entry
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Set local fields.  */
name|ret
operator|->
name|indx
operator|=
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|dynindx
operator|=
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|dynstr_index
operator|=
literal|0
expr_stmt|;
name|ret
operator|->
name|weakdef
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|got_offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|plt_offset
operator|=
operator|(
name|bfd_vma
operator|)
operator|-
literal|1
expr_stmt|;
name|ret
operator|->
name|linker_section_pointer
operator|=
operator|(
name|elf_linker_section_pointers_t
operator|*
operator|)
literal|0
expr_stmt|;
name|ret
operator|->
name|verinfo
operator|.
name|verdef
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|type
operator|=
name|STT_NOTYPE
expr_stmt|;
name|ret
operator|->
name|other
operator|=
literal|0
expr_stmt|;
comment|/* Assume that we have been called by a non-ELF symbol reader.          This flag is then reset by the code which reads an ELF input          file.  This ensures that a symbol created by a non-ELF symbol          reader will have the flag set correctly.  */
name|ret
operator|->
name|elf_link_hash_flags
operator|=
name|ELF_LINK_NON_ELF
expr_stmt|;
block|}
return|return
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|)
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Initialize an ELF linker hash table.  */
end_comment

begin_decl_stmt
name|boolean
name|_bfd_elf_link_hash_table_init
argument_list|(
name|table
argument_list|,
name|abfd
argument_list|,
name|newfunc
argument_list|)
decl|struct
name|elf_link_hash_table
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bfd_hash_entry
modifier|*
argument_list|(
operator|*
name|newfunc
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|bfd_hash_entry
operator|*
operator|,
expr|struct
name|bfd_hash_table
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|table
operator|->
name|dynamic_sections_created
operator|=
name|false
expr_stmt|;
name|table
operator|->
name|dynobj
operator|=
name|NULL
expr_stmt|;
comment|/* The first dynamic symbol is a dummy.  */
name|table
operator|->
name|dynsymcount
operator|=
literal|1
expr_stmt|;
name|table
operator|->
name|dynstr
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|bucketcount
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|needed
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|hgot
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|stab_info
operator|=
name|NULL
expr_stmt|;
return|return
name|_bfd_link_hash_table_init
argument_list|(
operator|&
name|table
operator|->
name|root
argument_list|,
name|abfd
argument_list|,
name|newfunc
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Create an ELF linker hash table.  */
end_comment

begin_function
name|struct
name|bfd_link_hash_table
modifier|*
name|_bfd_elf_link_hash_table_create
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|elf_link_hash_table
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
operator|(
expr|struct
name|elf_link_hash_table
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_link_hash_table
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|(
expr|struct
name|elf_link_hash_table
operator|*
operator|)
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|_bfd_elf_link_hash_table_init
argument_list|(
name|ret
argument_list|,
name|abfd
argument_list|,
name|_bfd_elf_link_hash_newfunc
argument_list|)
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|&
name|ret
operator|->
name|root
return|;
block|}
end_function

begin_comment
comment|/* This is a hook for the ELF emulation code in the generic linker to    tell the backend linker what file name to use for the DT_NEEDED    entry for a dynamic object.  The generic linker passes name as an    empty string to indicate that no DT_NEEDED entry should be made.  */
end_comment

begin_function
name|void
name|bfd_elf_set_dt_needed_name
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|&&
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_object
condition|)
name|elf_dt_name
argument_list|(
name|abfd
argument_list|)
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the list of DT_NEEDED entries for a link.  This is a hook for    the ELF emulation code.  */
end_comment

begin_function
name|struct
name|bfd_link_needed_list
modifier|*
name|bfd_elf_get_needed_list
parameter_list|(
name|abfd
parameter_list|,
name|info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
block|{
if|if
condition|(
name|info
operator|->
name|hash
operator|->
name|creator
operator|->
name|flavour
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|NULL
return|;
return|return
name|elf_hash_table
argument_list|(
name|info
argument_list|)
operator|->
name|needed
return|;
block|}
end_function

begin_comment
comment|/* Get the name actually used for a dynamic object for a link.  This    is the SONAME entry if there is one.  Otherwise, it is the string    passed to bfd_elf_set_dt_needed_name, or it is the filename.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|bfd_elf_get_dt_soname
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_target_elf_flavour
operator|&&
name|bfd_get_format
argument_list|(
name|abfd
argument_list|)
operator|==
name|bfd_object
condition|)
return|return
name|elf_dt_name
argument_list|(
name|abfd
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocate an ELF string table--force the first byte to be zero.  */
end_comment

begin_function
name|struct
name|bfd_strtab_hash
modifier|*
name|_bfd_elf_stringtab_init
parameter_list|()
block|{
name|struct
name|bfd_strtab_hash
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|_bfd_stringtab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
block|{
name|bfd_size_type
name|loc
decl_stmt|;
name|loc
operator|=
name|_bfd_stringtab_add
argument_list|(
name|ret
argument_list|,
literal|""
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|loc
operator|==
literal|0
operator|||
name|loc
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|==
operator|(
name|bfd_size_type
operator|)
operator|-
literal|1
condition|)
block|{
name|_bfd_stringtab_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ELF .o/exec file reading */
end_comment

begin_comment
comment|/* Create a new bfd section from an ELF section header. */
end_comment

begin_function
name|boolean
name|bfd_section_from_shdr
parameter_list|(
name|abfd
parameter_list|,
name|shindex
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|shindex
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
init|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
decl_stmt|;
name|Elf_Internal_Ehdr
modifier|*
name|ehdr
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|elf_string_from_elf_strtab
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hdr
operator|->
name|sh_type
condition|)
block|{
case|case
name|SHT_NULL
case|:
comment|/* Inactive section. Throw it away.  */
return|return
name|true
return|;
case|case
name|SHT_PROGBITS
case|:
comment|/* Normal section with contents.  */
case|case
name|SHT_DYNAMIC
case|:
comment|/* Dynamic linking information.  */
case|case
name|SHT_NOBITS
case|:
comment|/* .bss section.  */
case|case
name|SHT_HASH
case|:
comment|/* .hash section.  */
case|case
name|SHT_NOTE
case|:
comment|/* .note section.  */
return|return
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
return|;
case|case
name|SHT_SYMTAB
case|:
comment|/* A symbol table */
if|if
condition|(
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
operator|==
name|shindex
condition|)
return|return
name|true
return|;
name|BFD_ASSERT
argument_list|(
name|hdr
operator|->
name|sh_entsize
operator|==
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
operator|=
name|shindex
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
operator|=
operator|*
name|hdr
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
operator|=
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|abfd
operator|->
name|flags
operator||=
name|HAS_SYMS
expr_stmt|;
comment|/* Sometimes a shared object will map in the symbol table.  If          SHF_ALLOC is set, and this is a shared object, then we also          treat this section as a BFD section.  We can not base the          decision purely on SHF_ALLOC, because that flag is sometimes          set in a relocateable object file, which would confuse the          linker.  */
if|if
condition|(
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
case|case
name|SHT_DYNSYM
case|:
comment|/* A dynamic symbol table */
if|if
condition|(
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|==
name|shindex
condition|)
return|return
name|true
return|;
name|BFD_ASSERT
argument_list|(
name|hdr
operator|->
name|sh_entsize
operator|==
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|=
name|shindex
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynsymtab_hdr
operator|=
operator|*
name|hdr
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
operator|=
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynsymtab_hdr
expr_stmt|;
name|abfd
operator|->
name|flags
operator||=
name|HAS_SYMS
expr_stmt|;
comment|/* Besides being a symbol table, we also treat this as a regular 	 section, so that objcopy can handle it.  */
return|return
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
return|;
case|case
name|SHT_STRTAB
case|:
comment|/* A string table */
if|if
condition|(
name|hdr
operator|->
name|bfd_section
operator|!=
name|NULL
condition|)
return|return
name|true
return|;
if|if
condition|(
name|ehdr
operator|->
name|e_shstrndx
operator|==
name|shindex
condition|)
block|{
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|shstrtab_hdr
operator|=
operator|*
name|hdr
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|shstrtab_hdr
expr_stmt|;
return|return
name|true
return|;
block|}
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ehdr
operator|->
name|e_shnum
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr2
init|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|hdr2
operator|->
name|sh_link
operator|==
name|shindex
condition|)
block|{
if|if
condition|(
operator|!
name|bfd_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|i
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
operator|==
name|i
condition|)
block|{
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|strtab_hdr
operator|=
operator|*
name|hdr
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|strtab_hdr
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|==
name|i
condition|)
block|{
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynstrtab_hdr
operator|=
operator|*
name|hdr
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
operator|=
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynstrtab_hdr
expr_stmt|;
comment|/* We also treat this as a regular section, so 		       that objcopy can handle it.  */
break|break;
block|}
if|#
directive|if
literal|0
comment|/* Not handling other string tables specially right now.  */
block|hdr2 = elf_elfsections (abfd)[i];
comment|/* in case it moved */
comment|/* We have a strtab for some random other section.  */
block|newsect = (asection *) hdr2->bfd_section; 		if (!newsect) 		  break; 		hdr->bfd_section = newsect; 		hdr2 =&elf_section_data (newsect)->str_hdr; 		*hdr2 = *hdr; 		elf_elfsections (abfd)[shindex] = hdr2;
endif|#
directive|endif
block|}
block|}
block|}
return|return
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
return|;
case|case
name|SHT_REL
case|:
case|case
name|SHT_RELA
case|:
comment|/* *These* do a lot of work -- but build no sections!  */
block|{
name|asection
modifier|*
name|target_sect
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr2
decl_stmt|;
comment|/* For some incomprehensible reason Oracle distributes 	   libraries for Solaris in which some of the objects have 	   bogus sh_link fields.  It would be nice if we could just 	   reject them, but, unfortunately, some people need to use 	   them.  We scan through the section headers; if we find only 	   one suitable symbol table, we clobber the sh_link to point 	   to it.  I hope this doesn't break anything.  */
if|if
condition|(
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|hdr
operator|->
name|sh_link
index|]
operator|->
name|sh_type
operator|!=
name|SHT_SYMTAB
operator|&&
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|hdr
operator|->
name|sh_link
index|]
operator|->
name|sh_type
operator|!=
name|SHT_DYNSYM
condition|)
block|{
name|int
name|scan
decl_stmt|;
name|int
name|found
decl_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|scan
operator|=
literal|1
init|;
name|scan
operator|<
name|ehdr
operator|->
name|e_shnum
condition|;
name|scan
operator|++
control|)
block|{
if|if
condition|(
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|scan
index|]
operator|->
name|sh_type
operator|==
name|SHT_SYMTAB
operator|||
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|scan
index|]
operator|->
name|sh_type
operator|==
name|SHT_DYNSYM
condition|)
block|{
if|if
condition|(
name|found
operator|!=
literal|0
condition|)
block|{
name|found
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|found
operator|=
name|scan
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
operator|!=
literal|0
condition|)
name|hdr
operator|->
name|sh_link
operator|=
name|found
expr_stmt|;
block|}
comment|/* Get the symbol table.  */
if|if
condition|(
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|hdr
operator|->
name|sh_link
index|]
operator|->
name|sh_type
operator|==
name|SHT_SYMTAB
operator|&&
operator|!
name|bfd_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_link
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If this reloc section does not use the main symbol table we 	   don't treat it as a reloc section.  BFD can't adequately 	   represent such a section, so at least for now, we don't 	   try.  We just present it as a normal section.  */
if|if
condition|(
name|hdr
operator|->
name|sh_link
operator|!=
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
return|;
if|if
condition|(
operator|!
name|bfd_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_info
argument_list|)
condition|)
return|return
name|false
return|;
name|target_sect
operator|=
name|bfd_section_from_elf_index
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_sect
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|(
name|target_sect
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|target_sect
operator|->
name|reloc_count
operator|==
literal|0
condition|)
name|hdr2
operator|=
operator|&
name|elf_section_data
argument_list|(
name|target_sect
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
else|else
block|{
name|BFD_ASSERT
argument_list|(
name|elf_section_data
argument_list|(
name|target_sect
argument_list|)
operator|->
name|rel_hdr2
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|hdr2
operator|=
operator|(
name|Elf_Internal_Shdr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr2
argument_list|)
argument_list|)
expr_stmt|;
name|elf_section_data
argument_list|(
name|target_sect
argument_list|)
operator|->
name|rel_hdr2
operator|=
name|hdr2
expr_stmt|;
block|}
operator|*
name|hdr2
operator|=
operator|*
name|hdr
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|shindex
index|]
operator|=
name|hdr2
expr_stmt|;
name|target_sect
operator|->
name|reloc_count
operator|+=
name|hdr
operator|->
name|sh_size
operator|/
name|hdr
operator|->
name|sh_entsize
expr_stmt|;
name|target_sect
operator|->
name|flags
operator||=
name|SEC_RELOC
expr_stmt|;
name|target_sect
operator|->
name|relocation
operator|=
name|NULL
expr_stmt|;
name|target_sect
operator|->
name|rel_filepos
operator|=
name|hdr
operator|->
name|sh_offset
expr_stmt|;
name|abfd
operator|->
name|flags
operator||=
name|HAS_RELOC
expr_stmt|;
return|return
name|true
return|;
block|}
break|break;
case|case
name|SHT_GNU_verdef
case|:
name|elf_dynverdef
argument_list|(
name|abfd
argument_list|)
operator|=
name|shindex
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynverdef_hdr
operator|=
operator|*
name|hdr
expr_stmt|;
return|return
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
return|;
break|break;
case|case
name|SHT_GNU_versym
case|:
name|elf_dynversym
argument_list|(
name|abfd
argument_list|)
operator|=
name|shindex
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynversym_hdr
operator|=
operator|*
name|hdr
expr_stmt|;
return|return
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
return|;
break|break;
case|case
name|SHT_GNU_verneed
case|:
name|elf_dynverref
argument_list|(
name|abfd
argument_list|)
operator|=
name|shindex
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynverref_hdr
operator|=
operator|*
name|hdr
expr_stmt|;
return|return
name|_bfd_elf_make_section_from_shdr
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
return|;
break|break;
case|case
name|SHT_SHLIB
case|:
return|return
name|true
return|;
default|default:
comment|/* Check for any processor-specific section types.  */
block|{
if|if
condition|(
name|bed
operator|->
name|elf_backend_section_from_shdr
condition|)
call|(
modifier|*
name|bed
operator|->
name|elf_backend_section_from_shdr
call|)
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Given an ELF section number, retrieve the corresponding BFD    section.  */
end_comment

begin_function
name|asection
modifier|*
name|bfd_section_from_elf_index
parameter_list|(
name|abfd
parameter_list|,
name|index
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
block|{
name|BFD_ASSERT
argument_list|(
name|index
operator|>
literal|0
operator|&&
name|index
operator|<
name|SHN_LORESERVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shnum
condition|)
return|return
name|NULL
return|;
return|return
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
index|[
name|index
index|]
operator|->
name|bfd_section
return|;
block|}
end_function

begin_function
name|boolean
name|_bfd_elf_new_section_hook
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
block|{
name|struct
name|bfd_elf_section_data
modifier|*
name|sdata
decl_stmt|;
name|sdata
operator|=
operator|(
expr|struct
name|bfd_elf_section_data
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sdata
condition|)
return|return
name|false
return|;
name|sec
operator|->
name|used_by_bfd
operator|=
operator|(
name|PTR
operator|)
name|sdata
expr_stmt|;
name|memset
argument_list|(
name|sdata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sdata
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Create a new bfd section from an ELF program header.     Since program segments have no names, we generate a synthetic name    of the form segment<NUM>, where NUM is generally the index in the    program header table.  For segments that are split (see below) we    generate the names segment<NUM>a and segment<NUM>b.     Note that some program segments may have a file size that is different than    (less than) the memory size.  All this means is that at execution the    system must allocate the amount of memory specified by the memory size,    but only initialize it with the first "file size" bytes read from the    file.  This would occur for example, with program segments consisting    of combined data+bss.     To handle the above situation, this routine generates TWO bfd sections    for the single program segment.  The first has the length specified by    the file size of the segment, and the second has the length specified    by the difference between the two sizes.  In effect, the segment is split    into it's initialized and uninitialized parts.   */
end_comment

begin_function
name|boolean
name|bfd_section_from_phdr
parameter_list|(
name|abfd
parameter_list|,
name|hdr
parameter_list|,
name|index
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|hdr
decl_stmt|;
name|int
name|index
decl_stmt|;
block|{
name|asection
modifier|*
name|newsect
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|namebuf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|split
decl_stmt|;
name|split
operator|=
operator|(
operator|(
name|hdr
operator|->
name|p_memsz
operator|>
literal|0
operator|)
operator|&&
operator|(
name|hdr
operator|->
name|p_filesz
operator|>
literal|0
operator|)
operator|&&
operator|(
name|hdr
operator|->
name|p_memsz
operator|>
name|hdr
operator|->
name|p_filesz
operator|)
operator|)
expr_stmt|;
name|sprintf
argument_list|(
name|namebuf
argument_list|,
name|split
condition|?
literal|"segment%da"
else|:
literal|"segment%d"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|strlen
argument_list|(
name|namebuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|false
return|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
name|newsect
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsect
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|newsect
operator|->
name|vma
operator|=
name|hdr
operator|->
name|p_vaddr
expr_stmt|;
name|newsect
operator|->
name|lma
operator|=
name|hdr
operator|->
name|p_paddr
expr_stmt|;
name|newsect
operator|->
name|_raw_size
operator|=
name|hdr
operator|->
name|p_filesz
expr_stmt|;
name|newsect
operator|->
name|filepos
operator|=
name|hdr
operator|->
name|p_offset
expr_stmt|;
name|newsect
operator|->
name|flags
operator||=
name|SEC_HAS_CONTENTS
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|p_type
operator|==
name|PT_LOAD
condition|)
block|{
name|newsect
operator|->
name|flags
operator||=
name|SEC_ALLOC
expr_stmt|;
name|newsect
operator|->
name|flags
operator||=
name|SEC_LOAD
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|p_flags
operator|&
name|PF_X
condition|)
block|{
comment|/* FIXME: all we known is that it has execute PERMISSION, 	     may be data. */
name|newsect
operator|->
name|flags
operator||=
name|SEC_CODE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|hdr
operator|->
name|p_flags
operator|&
name|PF_W
operator|)
condition|)
block|{
name|newsect
operator|->
name|flags
operator||=
name|SEC_READONLY
expr_stmt|;
block|}
if|if
condition|(
name|split
condition|)
block|{
name|sprintf
argument_list|(
name|namebuf
argument_list|,
literal|"segment%db"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|strlen
argument_list|(
name|namebuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
return|return
name|false
return|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
name|newsect
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsect
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|newsect
operator|->
name|vma
operator|=
name|hdr
operator|->
name|p_vaddr
operator|+
name|hdr
operator|->
name|p_filesz
expr_stmt|;
name|newsect
operator|->
name|lma
operator|=
name|hdr
operator|->
name|p_paddr
operator|+
name|hdr
operator|->
name|p_filesz
expr_stmt|;
name|newsect
operator|->
name|_raw_size
operator|=
name|hdr
operator|->
name|p_memsz
operator|-
name|hdr
operator|->
name|p_filesz
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|p_type
operator|==
name|PT_LOAD
condition|)
block|{
name|newsect
operator|->
name|flags
operator||=
name|SEC_ALLOC
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|p_flags
operator|&
name|PF_X
condition|)
name|newsect
operator|->
name|flags
operator||=
name|SEC_CODE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|hdr
operator|->
name|p_flags
operator|&
name|PF_W
operator|)
condition|)
name|newsect
operator|->
name|flags
operator||=
name|SEC_READONLY
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set up an ELF internal section header for a section.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|elf_fake_sections
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|,
name|failedptrarg
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|asect
decl_stmt|;
name|PTR
name|failedptrarg
decl_stmt|;
block|{
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|boolean
modifier|*
name|failedptr
init|=
operator|(
name|boolean
operator|*
operator|)
name|failedptrarg
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|this_hdr
decl_stmt|;
if|if
condition|(
operator|*
name|failedptr
condition|)
block|{
comment|/* We already failed; just get out of the bfd_map_over_sections          loop.  */
return|return;
block|}
name|this_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|asect
argument_list|)
operator|->
name|this_hdr
expr_stmt|;
name|this_hdr
operator|->
name|sh_name
operator|=
operator|(
name|unsigned
name|long
operator|)
name|_bfd_stringtab_add
argument_list|(
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|asect
operator|->
name|name
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_hdr
operator|->
name|sh_name
operator|==
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
block|{
operator|*
name|failedptr
operator|=
name|true
expr_stmt|;
return|return;
block|}
name|this_hdr
operator|->
name|sh_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|||
name|asect
operator|->
name|user_set_vma
condition|)
name|this_hdr
operator|->
name|sh_addr
operator|=
name|asect
operator|->
name|vma
expr_stmt|;
else|else
name|this_hdr
operator|->
name|sh_addr
operator|=
literal|0
expr_stmt|;
name|this_hdr
operator|->
name|sh_offset
operator|=
literal|0
expr_stmt|;
name|this_hdr
operator|->
name|sh_size
operator|=
name|asect
operator|->
name|_raw_size
expr_stmt|;
name|this_hdr
operator|->
name|sh_link
operator|=
literal|0
expr_stmt|;
name|this_hdr
operator|->
name|sh_addralign
operator|=
literal|1
operator|<<
name|asect
operator|->
name|alignment_power
expr_stmt|;
comment|/* The sh_entsize and sh_info fields may have been set already by      copy_private_section_data.  */
name|this_hdr
operator|->
name|bfd_section
operator|=
name|asect
expr_stmt|;
name|this_hdr
operator|->
name|contents
operator|=
name|NULL
expr_stmt|;
comment|/* FIXME: This should not be based on section names.  */
if|if
condition|(
name|strcmp
argument_list|(
name|asect
operator|->
name|name
argument_list|,
literal|".dynstr"
argument_list|)
operator|==
literal|0
condition|)
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_STRTAB
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|asect
operator|->
name|name
argument_list|,
literal|".hash"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_HASH
expr_stmt|;
name|this_hdr
operator|->
name|sh_entsize
operator|=
name|bed
operator|->
name|s
operator|->
name|arch_size
operator|/
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|asect
operator|->
name|name
argument_list|,
literal|".dynsym"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_DYNSYM
expr_stmt|;
name|this_hdr
operator|->
name|sh_entsize
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|asect
operator|->
name|name
argument_list|,
literal|".dynamic"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_DYNAMIC
expr_stmt|;
name|this_hdr
operator|->
name|sh_entsize
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_dyn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|asect
operator|->
name|name
argument_list|,
literal|".rela"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|use_rela_p
condition|)
block|{
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_RELA
expr_stmt|;
name|this_hdr
operator|->
name|sh_entsize
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_rela
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|asect
operator|->
name|name
argument_list|,
literal|".rel"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|use_rela_p
condition|)
block|{
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_REL
expr_stmt|;
name|this_hdr
operator|->
name|sh_entsize
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_rel
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|asect
operator|->
name|name
argument_list|,
literal|".note"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_NOTE
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|asect
operator|->
name|name
argument_list|,
literal|".stab"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|asect
operator|->
name|name
operator|+
name|strlen
argument_list|(
name|asect
operator|->
name|name
argument_list|)
operator|-
literal|3
argument_list|,
literal|"str"
argument_list|)
operator|==
literal|0
condition|)
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_STRTAB
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|asect
operator|->
name|name
argument_list|,
literal|".gnu.version"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_GNU_versym
expr_stmt|;
name|this_hdr
operator|->
name|sh_entsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_External_Versym
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|asect
operator|->
name|name
argument_list|,
literal|".gnu.version_d"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_GNU_verdef
expr_stmt|;
name|this_hdr
operator|->
name|sh_entsize
operator|=
literal|0
expr_stmt|;
comment|/* objcopy or strip will copy over sh_info, but may not set          cverdefs.  The linker will set cverdefs, but sh_info will be          zero.  */
if|if
condition|(
name|this_hdr
operator|->
name|sh_info
operator|==
literal|0
condition|)
name|this_hdr
operator|->
name|sh_info
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cverdefs
expr_stmt|;
else|else
name|BFD_ASSERT
argument_list|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cverdefs
operator|==
literal|0
operator|||
name|this_hdr
operator|->
name|sh_info
operator|==
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cverdefs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|asect
operator|->
name|name
argument_list|,
literal|".gnu.version_r"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_GNU_verneed
expr_stmt|;
name|this_hdr
operator|->
name|sh_entsize
operator|=
literal|0
expr_stmt|;
comment|/* objcopy or strip will copy over sh_info, but may not set          cverrefs.  The linker will set cverrefs, but sh_info will be          zero.  */
if|if
condition|(
name|this_hdr
operator|->
name|sh_info
operator|==
literal|0
condition|)
name|this_hdr
operator|->
name|sh_info
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cverrefs
expr_stmt|;
else|else
name|BFD_ASSERT
argument_list|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cverrefs
operator|==
literal|0
operator|||
name|this_hdr
operator|->
name|sh_info
operator|==
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cverrefs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
operator|)
condition|)
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_NOBITS
expr_stmt|;
else|else
block|{
comment|/* Who knows?  */
name|this_hdr
operator|->
name|sh_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|this_hdr
operator|->
name|sh_flags
operator||=
name|SHF_ALLOC
expr_stmt|;
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|==
literal|0
condition|)
name|this_hdr
operator|->
name|sh_flags
operator||=
name|SHF_WRITE
expr_stmt|;
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
name|this_hdr
operator|->
name|sh_flags
operator||=
name|SHF_EXECINSTR
expr_stmt|;
comment|/* Check for processor-specific section types.  */
block|{
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|bed
operator|->
name|elf_backend_fake_sections
condition|)
call|(
modifier|*
name|bed
operator|->
name|elf_backend_fake_sections
call|)
argument_list|(
name|abfd
argument_list|,
name|this_hdr
argument_list|,
name|asect
argument_list|)
expr_stmt|;
block|}
comment|/* If the section has relocs, set up a section header for the      SHT_REL[A] section.  */
if|if
condition|(
operator|(
name|asect
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|rela_hdr
decl_stmt|;
name|int
name|use_rela_p
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|use_rela_p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|rela_hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|asect
argument_list|)
operator|->
name|rel_hdr
expr_stmt|;
name|name
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
expr|".rela"
operator|+
name|strlen
argument_list|(
name|asect
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
operator|*
name|failedptr
operator|=
name|true
expr_stmt|;
return|return;
block|}
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s%s"
argument_list|,
name|use_rela_p
condition|?
literal|".rela"
else|:
literal|".rel"
argument_list|,
name|asect
operator|->
name|name
argument_list|)
expr_stmt|;
name|rela_hdr
operator|->
name|sh_name
operator|=
operator|(
name|unsigned
name|int
operator|)
name|_bfd_stringtab_add
argument_list|(
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|name
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|rela_hdr
operator|->
name|sh_name
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
block|{
operator|*
name|failedptr
operator|=
name|true
expr_stmt|;
return|return;
block|}
name|rela_hdr
operator|->
name|sh_type
operator|=
name|use_rela_p
condition|?
name|SHT_RELA
else|:
name|SHT_REL
expr_stmt|;
name|rela_hdr
operator|->
name|sh_entsize
operator|=
operator|(
name|use_rela_p
condition|?
name|bed
operator|->
name|s
operator|->
name|sizeof_rela
else|:
name|bed
operator|->
name|s
operator|->
name|sizeof_rel
operator|)
expr_stmt|;
name|rela_hdr
operator|->
name|sh_addralign
operator|=
name|bed
operator|->
name|s
operator|->
name|file_align
expr_stmt|;
name|rela_hdr
operator|->
name|sh_flags
operator|=
literal|0
expr_stmt|;
name|rela_hdr
operator|->
name|sh_addr
operator|=
literal|0
expr_stmt|;
name|rela_hdr
operator|->
name|sh_size
operator|=
literal|0
expr_stmt|;
name|rela_hdr
operator|->
name|sh_offset
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Assign all ELF section numbers.  The dummy first section is handled here    too.  The link/info pointers for the standard section types are filled    in here too, while we're at it.  */
end_comment

begin_function
specifier|static
name|boolean
name|assign_section_numbers
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|elf_obj_tdata
modifier|*
name|t
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|unsigned
name|int
name|section_number
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|i_shdrp
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|section_number
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|struct
name|bfd_elf_section_data
modifier|*
name|d
init|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|d
operator|->
name|this_idx
operator|=
name|section_number
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
condition|)
name|d
operator|->
name|rel_idx
operator|=
literal|0
expr_stmt|;
else|else
name|d
operator|->
name|rel_idx
operator|=
name|section_number
operator|++
expr_stmt|;
block|}
name|t
operator|->
name|shstrtab_section
operator|=
name|section_number
operator|++
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shstrndx
operator|=
name|t
operator|->
name|shstrtab_section
expr_stmt|;
name|t
operator|->
name|shstrtab_hdr
operator|.
name|sh_size
operator|=
name|_bfd_stringtab_size
argument_list|(
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|symcount
operator|>
literal|0
condition|)
block|{
name|t
operator|->
name|symtab_section
operator|=
name|section_number
operator|++
expr_stmt|;
name|t
operator|->
name|strtab_section
operator|=
name|section_number
operator|++
expr_stmt|;
block|}
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shnum
operator|=
name|section_number
expr_stmt|;
comment|/* Set up the list of section header pointers, in agreement with the      indices.  */
name|i_shdrp
operator|=
operator|(
operator|(
name|Elf_Internal_Shdr
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|section_number
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Shdr
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|i_shdrp
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|i_shdrp
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|Elf_Internal_Shdr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Shdr
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|i_shdrp
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|bfd_release
argument_list|(
name|abfd
argument_list|,
name|i_shdrp
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|memset
argument_list|(
name|i_shdrp
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Internal_Shdr
argument_list|)
argument_list|)
expr_stmt|;
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
operator|=
name|i_shdrp
expr_stmt|;
name|i_shdrp
index|[
name|t
operator|->
name|shstrtab_section
index|]
operator|=
operator|&
name|t
operator|->
name|shstrtab_hdr
expr_stmt|;
if|if
condition|(
name|abfd
operator|->
name|symcount
operator|>
literal|0
condition|)
block|{
name|i_shdrp
index|[
name|t
operator|->
name|symtab_section
index|]
operator|=
operator|&
name|t
operator|->
name|symtab_hdr
expr_stmt|;
name|i_shdrp
index|[
name|t
operator|->
name|strtab_section
index|]
operator|=
operator|&
name|t
operator|->
name|strtab_hdr
expr_stmt|;
name|t
operator|->
name|symtab_hdr
operator|.
name|sh_link
operator|=
name|t
operator|->
name|strtab_section
expr_stmt|;
block|}
for|for
control|(
name|sec
operator|=
name|abfd
operator|->
name|sections
init|;
name|sec
condition|;
name|sec
operator|=
name|sec
operator|->
name|next
control|)
block|{
name|struct
name|bfd_elf_section_data
modifier|*
name|d
init|=
name|elf_section_data
argument_list|(
name|sec
argument_list|)
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|i_shdrp
index|[
name|d
operator|->
name|this_idx
index|]
operator|=
operator|&
name|d
operator|->
name|this_hdr
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rel_idx
operator|!=
literal|0
condition|)
name|i_shdrp
index|[
name|d
operator|->
name|rel_idx
index|]
operator|=
operator|&
name|d
operator|->
name|rel_hdr
expr_stmt|;
comment|/* Fill in the sh_link and sh_info fields while we're at it.  */
comment|/* sh_link of a reloc section is the section index of the symbol 	 table.  sh_info is the section index of the section to which 	 the relocation entries apply.  */
if|if
condition|(
name|d
operator|->
name|rel_idx
operator|!=
literal|0
condition|)
block|{
name|d
operator|->
name|rel_hdr
operator|.
name|sh_link
operator|=
name|t
operator|->
name|symtab_section
expr_stmt|;
name|d
operator|->
name|rel_hdr
operator|.
name|sh_info
operator|=
name|d
operator|->
name|this_idx
expr_stmt|;
block|}
switch|switch
condition|(
name|d
operator|->
name|this_hdr
operator|.
name|sh_type
condition|)
block|{
case|case
name|SHT_REL
case|:
case|case
name|SHT_RELA
case|:
comment|/* A reloc section which we are treating as a normal BFD 	     section.  sh_link is the section index of the symbol 	     table.  sh_info is the section index of the section to 	     which the relocation entries apply.  We assume that an 	     allocated reloc section uses the dynamic symbol table. 	     FIXME: How can we be sure?  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|d
operator|->
name|this_hdr
operator|.
name|sh_link
operator|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_idx
expr_stmt|;
comment|/* We look up the section the relocs apply to by name.  */
name|name
operator|=
name|sec
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|this_hdr
operator|.
name|sh_type
operator|==
name|SHT_REL
condition|)
name|name
operator|+=
literal|4
expr_stmt|;
else|else
name|name
operator|+=
literal|5
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|d
operator|->
name|this_hdr
operator|.
name|sh_info
operator|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
case|case
name|SHT_STRTAB
case|:
comment|/* We assume that a section named .stab*str is a stabs 	     string section.  We look for a section with the same name 	     but without the trailing ``str'', and set its sh_link 	     field to point to this section.  */
if|if
condition|(
name|strncmp
argument_list|(
name|sec
operator|->
name|name
argument_list|,
literal|".stab"
argument_list|,
sizeof|sizeof
expr|".stab"
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|sec
operator|->
name|name
operator|+
name|strlen
argument_list|(
name|sec
operator|->
name|name
argument_list|)
operator|-
literal|3
argument_list|,
literal|"str"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|alc
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
name|alc
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|alc
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|strncpy
argument_list|(
name|alc
argument_list|,
name|sec
operator|->
name|name
argument_list|,
name|len
operator|-
literal|3
argument_list|)
expr_stmt|;
name|alc
index|[
name|len
operator|-
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|alc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|alc
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_link
operator|=
name|d
operator|->
name|this_idx
expr_stmt|;
comment|/* This is a .stab section.  */
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|=
literal|4
operator|+
literal|2
operator|*
operator|(
name|bed
operator|->
name|s
operator|->
name|arch_size
operator|/
literal|8
operator|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SHT_DYNAMIC
case|:
case|case
name|SHT_DYNSYM
case|:
case|case
name|SHT_GNU_verneed
case|:
case|case
name|SHT_GNU_verdef
case|:
comment|/* sh_link is the section header index of the string table 	     used for the dynamic entries, or the symbol table, or the 	     version strings.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynstr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|d
operator|->
name|this_hdr
operator|.
name|sh_link
operator|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
case|case
name|SHT_HASH
case|:
case|case
name|SHT_GNU_versym
case|:
comment|/* sh_link is the section header index of the symbol table 	     this hash table or version table is for.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynsym"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
name|d
operator|->
name|this_hdr
operator|.
name|sh_link
operator|=
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_idx
expr_stmt|;
break|break;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Map symbol from it's internal number to the external number, moving    all local symbols to be at the head of the list.  */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|sym_is_global
parameter_list|(
name|abfd
parameter_list|,
name|sym
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
block|{
comment|/* If the backend has a special mapping, use it.  */
if|if
condition|(
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_sym_is_global
condition|)
return|return
operator|(
operator|(
operator|*
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|elf_backend_sym_is_global
operator|)
operator|(
name|abfd
operator|,
name|sym
operator|)
operator|)
return|;
return|return
operator|(
operator|(
name|sym
operator|->
name|flags
operator|&
operator|(
name|BSF_GLOBAL
operator||
name|BSF_WEAK
operator|)
operator|)
operator|!=
literal|0
operator|||
name|bfd_is_und_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|||
name|bfd_is_com_section
argument_list|(
name|bfd_get_section
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|elf_map_symbols
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|int
name|symcount
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|syms
init|=
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|sect_syms
decl_stmt|;
name|int
name|num_locals
init|=
literal|0
decl_stmt|;
name|int
name|num_globals
init|=
literal|0
decl_stmt|;
name|int
name|num_locals2
init|=
literal|0
decl_stmt|;
name|int
name|num_globals2
init|=
literal|0
decl_stmt|;
name|int
name|max_index
init|=
literal|0
decl_stmt|;
name|int
name|num_sections
init|=
literal|0
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|asection
modifier|*
name|asect
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|new_syms
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"elf_map_symbols\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Add a section symbol for each BFD section.  FIXME: Is this really      necessary?  */
for|for
control|(
name|asect
operator|=
name|abfd
operator|->
name|sections
init|;
name|asect
condition|;
name|asect
operator|=
name|asect
operator|->
name|next
control|)
block|{
if|if
condition|(
name|max_index
operator|<
name|asect
operator|->
name|index
condition|)
name|max_index
operator|=
name|asect
operator|->
name|index
expr_stmt|;
block|}
name|max_index
operator|++
expr_stmt|;
name|sect_syms
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|max_index
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect_syms
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|elf_section_syms
argument_list|(
name|abfd
argument_list|)
operator|=
name|sect_syms
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|symcount
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|syms
index|[
name|idx
index|]
operator|->
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|syms
index|[
name|idx
index|]
operator|->
name|value
operator|+
name|syms
index|[
name|idx
index|]
operator|->
name|section
operator|->
name|vma
operator|)
operator|==
literal|0
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|syms
index|[
name|idx
index|]
operator|->
name|section
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|owner
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sec
operator|->
name|owner
operator|!=
name|abfd
condition|)
block|{
if|if
condition|(
name|sec
operator|->
name|output_offset
operator|!=
literal|0
condition|)
continue|continue;
name|sec
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec
operator|->
name|owner
operator|==
name|abfd
argument_list|)
expr_stmt|;
block|}
name|sect_syms
index|[
name|sec
operator|->
name|index
index|]
operator|=
name|syms
index|[
name|idx
index|]
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|asect
operator|=
name|abfd
operator|->
name|sections
init|;
name|asect
condition|;
name|asect
operator|=
name|asect
operator|->
name|next
control|)
block|{
name|asymbol
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|sect_syms
index|[
name|asect
operator|->
name|index
index|]
operator|!=
name|NULL
condition|)
continue|continue;
name|sym
operator|=
name|bfd_make_empty_symbol
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|sym
operator|->
name|the_bfd
operator|=
name|abfd
expr_stmt|;
name|sym
operator|->
name|name
operator|=
name|asect
operator|->
name|name
expr_stmt|;
name|sym
operator|->
name|value
operator|=
literal|0
expr_stmt|;
comment|/* Set the flags to 0 to indicate that this one was newly added.  */
name|sym
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|sym
operator|->
name|section
operator|=
name|asect
expr_stmt|;
name|sect_syms
index|[
name|asect
operator|->
name|index
index|]
operator|=
name|sym
expr_stmt|;
name|num_sections
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"creating section symbol, name = %s, value = 0x%.8lx, index = %d, section = 0x%.8lx\n"
argument_list|,
name|asect
operator|->
name|name
argument_list|,
operator|(
name|long
operator|)
name|asect
operator|->
name|vma
argument_list|,
name|asect
operator|->
name|index
argument_list|,
operator|(
name|long
operator|)
name|asect
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Classify all of the symbols.  */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|symcount
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|sym_is_global
argument_list|(
name|abfd
argument_list|,
name|syms
index|[
name|idx
index|]
argument_list|)
condition|)
name|num_locals
operator|++
expr_stmt|;
else|else
name|num_globals
operator|++
expr_stmt|;
block|}
for|for
control|(
name|asect
operator|=
name|abfd
operator|->
name|sections
init|;
name|asect
condition|;
name|asect
operator|=
name|asect
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sect_syms
index|[
name|asect
operator|->
name|index
index|]
operator|!=
name|NULL
operator|&&
name|sect_syms
index|[
name|asect
operator|->
name|index
index|]
operator|->
name|flags
operator|==
literal|0
condition|)
block|{
name|sect_syms
index|[
name|asect
operator|->
name|index
index|]
operator|->
name|flags
operator|=
name|BSF_SECTION_SYM
expr_stmt|;
if|if
condition|(
operator|!
name|sym_is_global
argument_list|(
name|abfd
argument_list|,
name|sect_syms
index|[
name|asect
operator|->
name|index
index|]
argument_list|)
condition|)
name|num_locals
operator|++
expr_stmt|;
else|else
name|num_globals
operator|++
expr_stmt|;
name|sect_syms
index|[
name|asect
operator|->
name|index
index|]
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Now sort the symbols so the local symbols are first.  */
name|new_syms
operator|=
operator|(
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|num_locals
operator|+
name|num_globals
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|new_syms
operator|==
name|NULL
condition|)
return|return
name|false
return|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|symcount
condition|;
name|idx
operator|++
control|)
block|{
name|asymbol
modifier|*
name|sym
init|=
name|syms
index|[
name|idx
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|sym_is_global
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|)
condition|)
name|i
operator|=
name|num_locals2
operator|++
expr_stmt|;
else|else
name|i
operator|=
name|num_locals
operator|+
name|num_globals2
operator|++
expr_stmt|;
name|new_syms
index|[
name|i
index|]
operator|=
name|sym
expr_stmt|;
name|sym
operator|->
name|udata
operator|.
name|i
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
for|for
control|(
name|asect
operator|=
name|abfd
operator|->
name|sections
init|;
name|asect
condition|;
name|asect
operator|=
name|asect
operator|->
name|next
control|)
block|{
if|if
condition|(
name|sect_syms
index|[
name|asect
operator|->
name|index
index|]
operator|!=
name|NULL
operator|&&
name|sect_syms
index|[
name|asect
operator|->
name|index
index|]
operator|->
name|flags
operator|==
literal|0
condition|)
block|{
name|asymbol
modifier|*
name|sym
init|=
name|sect_syms
index|[
name|asect
operator|->
name|index
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sym
operator|->
name|flags
operator|=
name|BSF_SECTION_SYM
expr_stmt|;
if|if
condition|(
operator|!
name|sym_is_global
argument_list|(
name|abfd
argument_list|,
name|sym
argument_list|)
condition|)
name|i
operator|=
name|num_locals2
operator|++
expr_stmt|;
else|else
name|i
operator|=
name|num_locals
operator|+
name|num_globals2
operator|++
expr_stmt|;
name|new_syms
index|[
name|i
index|]
operator|=
name|sym
expr_stmt|;
name|sym
operator|->
name|udata
operator|.
name|i
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|bfd_set_symtab
argument_list|(
name|abfd
argument_list|,
name|new_syms
argument_list|,
name|num_locals
operator|+
name|num_globals
argument_list|)
expr_stmt|;
name|elf_num_locals
argument_list|(
name|abfd
argument_list|)
operator|=
name|num_locals
expr_stmt|;
name|elf_num_globals
argument_list|(
name|abfd
argument_list|)
operator|=
name|num_globals
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Align to the maximum file alignment that could be required for any    ELF data structure.  */
end_comment

begin_decl_stmt
specifier|static
name|INLINE
name|file_ptr
name|align_file_position
name|PARAMS
argument_list|(
operator|(
name|file_ptr
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|INLINE
name|file_ptr
name|align_file_position
parameter_list|(
name|off
parameter_list|,
name|align
parameter_list|)
name|file_ptr
name|off
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
return|return
operator|(
name|off
operator|+
name|align
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|align
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Assign a file position to a section, optionally aligning to the    required section alignment.  */
end_comment

begin_function
name|INLINE
name|file_ptr
name|_bfd_elf_assign_file_position_for_section
parameter_list|(
name|i_shdrp
parameter_list|,
name|offset
parameter_list|,
name|align
parameter_list|)
name|Elf_Internal_Shdr
modifier|*
name|i_shdrp
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|boolean
name|align
decl_stmt|;
block|{
if|if
condition|(
name|align
condition|)
block|{
name|unsigned
name|int
name|al
decl_stmt|;
name|al
operator|=
name|i_shdrp
operator|->
name|sh_addralign
expr_stmt|;
if|if
condition|(
name|al
operator|>
literal|1
condition|)
name|offset
operator|=
name|BFD_ALIGN
argument_list|(
name|offset
argument_list|,
name|al
argument_list|)
expr_stmt|;
block|}
name|i_shdrp
operator|->
name|sh_offset
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|i_shdrp
operator|->
name|bfd_section
operator|!=
name|NULL
condition|)
name|i_shdrp
operator|->
name|bfd_section
operator|->
name|filepos
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|i_shdrp
operator|->
name|sh_type
operator|!=
name|SHT_NOBITS
condition|)
name|offset
operator|+=
name|i_shdrp
operator|->
name|sh_size
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Compute the file positions we are going to put the sections at, and    otherwise prepare to begin writing out the ELF file.  If LINK_INFO    is not NULL, this is being called by the ELF backend linker.  */
end_comment

begin_function
name|boolean
name|_bfd_elf_compute_section_file_positions
parameter_list|(
name|abfd
parameter_list|,
name|link_info
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
block|{
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|boolean
name|failed
decl_stmt|;
name|struct
name|bfd_strtab_hash
modifier|*
name|strtab
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|shstrtab_hdr
decl_stmt|;
if|if
condition|(
name|abfd
operator|->
name|output_has_begun
condition|)
return|return
name|true
return|;
comment|/* Do any elf backend specific processing first.  */
if|if
condition|(
name|bed
operator|->
name|elf_backend_begin_write_processing
condition|)
call|(
modifier|*
name|bed
operator|->
name|elf_backend_begin_write_processing
call|)
argument_list|(
name|abfd
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prep_headers
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
name|failed
operator|=
name|false
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|elf_fake_sections
argument_list|,
operator|&
name|failed
argument_list|)
expr_stmt|;
if|if
condition|(
name|failed
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|assign_section_numbers
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* The backend linker builds symbol table information itself.  */
if|if
condition|(
name|link_info
operator|==
name|NULL
operator|&&
name|abfd
operator|->
name|symcount
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|swap_out_syms
argument_list|(
name|abfd
argument_list|,
operator|&
name|strtab
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|shstrtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|shstrtab_hdr
expr_stmt|;
comment|/* sh_name was set in prep_headers.  */
name|shstrtab_hdr
operator|->
name|sh_type
operator|=
name|SHT_STRTAB
expr_stmt|;
name|shstrtab_hdr
operator|->
name|sh_flags
operator|=
literal|0
expr_stmt|;
name|shstrtab_hdr
operator|->
name|sh_addr
operator|=
literal|0
expr_stmt|;
name|shstrtab_hdr
operator|->
name|sh_size
operator|=
name|_bfd_stringtab_size
argument_list|(
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|shstrtab_hdr
operator|->
name|sh_entsize
operator|=
literal|0
expr_stmt|;
name|shstrtab_hdr
operator|->
name|sh_link
operator|=
literal|0
expr_stmt|;
name|shstrtab_hdr
operator|->
name|sh_info
operator|=
literal|0
expr_stmt|;
comment|/* sh_offset is set in assign_file_positions_except_relocs.  */
name|shstrtab_hdr
operator|->
name|sh_addralign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|assign_file_positions_except_relocs
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|link_info
operator|==
name|NULL
operator|&&
name|abfd
operator|->
name|symcount
operator|>
literal|0
condition|)
block|{
name|file_ptr
name|off
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|off
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|next_file_pos
expr_stmt|;
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|off
operator|=
name|_bfd_elf_assign_file_position_for_section
argument_list|(
name|hdr
argument_list|,
name|off
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|strtab_hdr
expr_stmt|;
name|off
operator|=
name|_bfd_elf_assign_file_position_for_section
argument_list|(
name|hdr
argument_list|,
name|off
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|next_file_pos
operator|=
name|off
expr_stmt|;
comment|/* Now that we know where the .strtab section goes, write it          out.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|_bfd_stringtab_emit
argument_list|(
name|abfd
argument_list|,
name|strtab
argument_list|)
condition|)
return|return
name|false
return|;
name|_bfd_stringtab_free
argument_list|(
name|strtab
argument_list|)
expr_stmt|;
block|}
name|abfd
operator|->
name|output_has_begun
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Create a mapping from a set of sections to a program segment.  */
end_comment

begin_expr_stmt
specifier|static
name|INLINE
expr|struct
name|elf_segment_map
operator|*
name|make_mapping
argument_list|(
argument|abfd
argument_list|,
argument|sections
argument_list|,
argument|from
argument_list|,
argument|to
argument_list|,
argument|phdr
argument_list|)
name|bfd
operator|*
name|abfd
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|asection
modifier|*
modifier|*
name|sections
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|to
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|phdr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|asection
modifier|*
modifier|*
name|hdrpp
decl_stmt|;
name|m
operator|=
operator|(
operator|(
expr|struct
name|elf_segment_map
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|elf_segment_map
argument_list|)
operator|+
operator|(
name|to
operator|-
name|from
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
operator|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|m
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|p_type
operator|=
name|PT_LOAD
expr_stmt|;
for|for
control|(
name|i
operator|=
name|from
operator|,
name|hdrpp
operator|=
name|sections
operator|+
name|from
init|;
name|i
operator|<
name|to
condition|;
name|i
operator|++
operator|,
name|hdrpp
operator|++
control|)
name|m
operator|->
name|sections
index|[
name|i
operator|-
name|from
index|]
operator|=
operator|*
name|hdrpp
expr_stmt|;
name|m
operator|->
name|count
operator|=
name|to
operator|-
name|from
expr_stmt|;
if|if
condition|(
name|from
operator|==
literal|0
operator|&&
name|phdr
condition|)
block|{
comment|/* Include the headers in the first PT_LOAD segment.  */
name|m
operator|->
name|includes_filehdr
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|includes_phdrs
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_block

begin_comment
comment|/* Set up a mapping from BFD sections to program segments.  */
end_comment

begin_function
specifier|static
name|boolean
name|map_sections_to_segments
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asection
modifier|*
modifier|*
name|sections
init|=
name|NULL
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|struct
name|elf_segment_map
modifier|*
name|mfirst
decl_stmt|;
name|struct
name|elf_segment_map
modifier|*
modifier|*
name|pm
decl_stmt|;
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|;
name|asection
modifier|*
name|last_hdr
decl_stmt|;
name|unsigned
name|int
name|phdr_index
decl_stmt|;
name|bfd_vma
name|maxpagesize
decl_stmt|;
name|asection
modifier|*
modifier|*
name|hdrpp
decl_stmt|;
name|boolean
name|phdr_in_section
init|=
name|true
decl_stmt|;
name|boolean
name|writable
decl_stmt|;
name|asection
modifier|*
name|dynsec
decl_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
operator|!=
name|NULL
condition|)
return|return
name|true
return|;
if|if
condition|(
name|bfd_count_sections
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
comment|/* Select the allocated sections, and sort them.  */
name|sections
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|bfd_count_sections
argument_list|(
name|abfd
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sections
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|sections
index|[
name|i
index|]
operator|=
name|s
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
block|}
name|BFD_ASSERT
argument_list|(
name|i
operator|<=
name|bfd_count_sections
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|i
expr_stmt|;
name|qsort
argument_list|(
name|sections
argument_list|,
operator|(
name|size_t
operator|)
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|,
name|elf_sort_sections
argument_list|)
expr_stmt|;
comment|/* Build the mapping.  */
name|mfirst
operator|=
name|NULL
expr_stmt|;
name|pm
operator|=
operator|&
name|mfirst
expr_stmt|;
comment|/* If we have a .interp section, then create a PT_PHDR segment for      the program headers and a PT_INTERP segment for the .interp      section.  */
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
operator|=
operator|(
operator|(
expr|struct
name|elf_segment_map
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_segment_map
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|m
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|p_type
operator|=
name|PT_PHDR
expr_stmt|;
comment|/* FIXME: UnixWare and Solaris set PF_X, Irix 5 does not.  */
name|m
operator|->
name|p_flags
operator|=
name|PF_R
operator||
name|PF_X
expr_stmt|;
name|m
operator|->
name|p_flags_valid
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|includes_phdrs
operator|=
literal|1
expr_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
name|pm
operator|=
operator|&
name|m
operator|->
name|next
expr_stmt|;
name|m
operator|=
operator|(
operator|(
expr|struct
name|elf_segment_map
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_segment_map
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|m
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|p_type
operator|=
name|PT_INTERP
expr_stmt|;
name|m
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
name|pm
operator|=
operator|&
name|m
operator|->
name|next
expr_stmt|;
block|}
comment|/* Look through the sections.  We put sections in the same program      segment when the start of the second section can be placed within      a few bytes of the end of the first section.  */
name|last_hdr
operator|=
name|NULL
expr_stmt|;
name|phdr_index
operator|=
literal|0
expr_stmt|;
name|maxpagesize
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|maxpagesize
expr_stmt|;
name|writable
operator|=
name|false
expr_stmt|;
name|dynsec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynsec
operator|!=
name|NULL
operator|&&
operator|(
name|dynsec
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
name|dynsec
operator|=
name|NULL
expr_stmt|;
comment|/* Deal with -Ttext or something similar such that the first section      is not adjacent to the program headers.  This is an      approximation, since at this point we don't know exactly how many      program headers we will need.  */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|bfd_size_type
name|phdr_size
decl_stmt|;
name|phdr_size
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|program_header_size
expr_stmt|;
if|if
condition|(
name|phdr_size
operator|==
literal|0
condition|)
name|phdr_size
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|sizeof_phdr
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|==
literal|0
operator|||
name|sections
index|[
literal|0
index|]
operator|->
name|lma
operator|%
name|maxpagesize
operator|<
name|phdr_size
operator|%
name|maxpagesize
condition|)
name|phdr_in_section
operator|=
name|false
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|hdrpp
operator|=
name|sections
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|hdrpp
operator|++
control|)
block|{
name|asection
modifier|*
name|hdr
decl_stmt|;
name|boolean
name|new_segment
decl_stmt|;
name|hdr
operator|=
operator|*
name|hdrpp
expr_stmt|;
comment|/* See if this section and the last one will fit in the same          segment.  */
if|if
condition|(
name|last_hdr
operator|==
name|NULL
condition|)
block|{
comment|/* If we don't have a segment yet, then we don't need a new 	     one (we build the last one after this loop).  */
name|new_segment
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|last_hdr
operator|->
name|lma
operator|-
name|last_hdr
operator|->
name|vma
operator|!=
name|hdr
operator|->
name|lma
operator|-
name|hdr
operator|->
name|vma
condition|)
block|{
comment|/* If this section has a different relation between the              virtual address and the load address, then we need a new              segment.  */
name|new_segment
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|BFD_ALIGN
argument_list|(
name|last_hdr
operator|->
name|lma
operator|+
name|last_hdr
operator|->
name|_raw_size
argument_list|,
name|maxpagesize
argument_list|)
operator|<
name|hdr
operator|->
name|lma
condition|)
block|{
comment|/* If putting this section in this segment would force us to              skip a page in the segment, then we need a new segment.  */
name|new_segment
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* If the file is not demand paged, which means that we              don't require the sections to be correctly aligned in the              file, then there is no other reason for a new segment.  */
name|new_segment
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|last_hdr
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
operator|&&
operator|(
name|hdr
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* We don't want to put a loadable section after a              nonloadable section in the same segment.  */
name|new_segment
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|writable
operator|&&
operator|(
name|hdr
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|==
literal|0
operator|&&
operator|(
name|BFD_ALIGN
argument_list|(
name|last_hdr
operator|->
name|lma
operator|+
name|last_hdr
operator|->
name|_raw_size
argument_list|,
name|maxpagesize
argument_list|)
operator|==
name|hdr
operator|->
name|lma
operator|)
condition|)
block|{
comment|/* We don't want to put a writable section in a read only              segment, unless they are on the same page in memory              anyhow.  We already know that the last section does not              bring us past the current section on the page, so the              only case in which the new section is not on the same              page as the previous section is when the previous section              ends precisely on a page boundary.  */
name|new_segment
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, we can use the same segment.  */
name|new_segment
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|new_segment
condition|)
block|{
if|if
condition|(
operator|(
name|hdr
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|==
literal|0
condition|)
name|writable
operator|=
name|true
expr_stmt|;
name|last_hdr
operator|=
name|hdr
expr_stmt|;
continue|continue;
block|}
comment|/* We need a new program segment.  We must create a new program          header holding all the sections from phdr_index until hdr.  */
name|m
operator|=
name|make_mapping
argument_list|(
name|abfd
argument_list|,
name|sections
argument_list|,
name|phdr_index
argument_list|,
name|i
argument_list|,
name|phdr_in_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
name|pm
operator|=
operator|&
name|m
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|==
literal|0
condition|)
name|writable
operator|=
name|true
expr_stmt|;
else|else
name|writable
operator|=
name|false
expr_stmt|;
name|last_hdr
operator|=
name|hdr
expr_stmt|;
name|phdr_index
operator|=
name|i
expr_stmt|;
name|phdr_in_section
operator|=
name|false
expr_stmt|;
block|}
comment|/* Create a final PT_LOAD program segment.  */
if|if
condition|(
name|last_hdr
operator|!=
name|NULL
condition|)
block|{
name|m
operator|=
name|make_mapping
argument_list|(
name|abfd
argument_list|,
name|sections
argument_list|,
name|phdr_index
argument_list|,
name|i
argument_list|,
name|phdr_in_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
name|pm
operator|=
operator|&
name|m
operator|->
name|next
expr_stmt|;
block|}
comment|/* If there is a .dynamic section, throw in a PT_DYNAMIC segment.  */
if|if
condition|(
name|dynsec
operator|!=
name|NULL
condition|)
block|{
name|m
operator|=
operator|(
operator|(
expr|struct
name|elf_segment_map
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_segment_map
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|m
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|p_type
operator|=
name|PT_DYNAMIC
expr_stmt|;
name|m
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|=
name|dynsec
expr_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
name|pm
operator|=
operator|&
name|m
operator|->
name|next
expr_stmt|;
block|}
comment|/* For each loadable .note section, add a PT_NOTE segment.  We don't      use bfd_get_section_by_name, because if we link together      nonloadable .note sections and loadable .note sections, we will      generate two .note sections in the output file.  FIXME: Using      names for section types is bogus anyhow.  */
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".note"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m
operator|=
operator|(
operator|(
expr|struct
name|elf_segment_map
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elf_segment_map
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|m
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|p_type
operator|=
name|PT_NOTE
expr_stmt|;
name|m
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|=
name|s
expr_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
name|pm
operator|=
operator|&
name|m
operator|->
name|next
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
name|sections
operator|=
name|NULL
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
operator|=
name|mfirst
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Sort sections by VMA.  */
end_comment

begin_function
specifier|static
name|int
name|elf_sort_sections
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
specifier|const
name|PTR
name|arg1
decl_stmt|;
specifier|const
name|PTR
name|arg2
decl_stmt|;
block|{
specifier|const
name|asection
modifier|*
name|sec1
init|=
operator|*
operator|(
specifier|const
name|asection
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
specifier|const
name|asection
modifier|*
name|sec2
init|=
operator|*
operator|(
specifier|const
name|asection
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
if|if
condition|(
name|sec1
operator|->
name|vma
operator|<
name|sec2
operator|->
name|vma
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|sec1
operator|->
name|vma
operator|>
name|sec2
operator|->
name|vma
condition|)
return|return
literal|1
return|;
comment|/* Sort by LMA.  Normally the LMA and the VMA will be the same, and      this will do nothing.  */
if|if
condition|(
name|sec1
operator|->
name|lma
operator|<
name|sec2
operator|->
name|lma
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|sec1
operator|->
name|lma
operator|>
name|sec2
operator|->
name|lma
condition|)
return|return
literal|1
return|;
comment|/* Put !SEC_LOAD sections after SEC_LOAD ones.  */
define|#
directive|define
name|TOEND
parameter_list|(
name|x
parameter_list|)
value|(((x)->flags& SEC_LOAD) == 0)
if|if
condition|(
name|TOEND
argument_list|(
name|sec1
argument_list|)
condition|)
if|if
condition|(
name|TOEND
argument_list|(
name|sec2
argument_list|)
condition|)
return|return
name|sec1
operator|->
name|target_index
operator|-
name|sec2
operator|->
name|target_index
return|;
else|else
return|return
literal|1
return|;
if|if
condition|(
name|TOEND
argument_list|(
name|sec2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
undef|#
directive|undef
name|TOEND
comment|/* Sort by size, to put zero sized sections before others at the      same address.  */
if|if
condition|(
name|sec1
operator|->
name|_raw_size
operator|<
name|sec2
operator|->
name|_raw_size
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|sec1
operator|->
name|_raw_size
operator|>
name|sec2
operator|->
name|_raw_size
condition|)
return|return
literal|1
return|;
return|return
name|sec1
operator|->
name|target_index
operator|-
name|sec2
operator|->
name|target_index
return|;
block|}
end_function

begin_comment
comment|/* Assign file positions to the sections based on the mapping from    sections to segments.  This function also sets up some fields in    the file header, and writes out the program headers.  */
end_comment

begin_function
specifier|static
name|boolean
name|assign_file_positions_for_segments
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
specifier|const
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|;
name|unsigned
name|int
name|alloc
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|phdrs
decl_stmt|;
name|file_ptr
name|off
decl_stmt|,
name|voff
decl_stmt|;
name|bfd_vma
name|filehdr_vaddr
decl_stmt|,
name|filehdr_paddr
decl_stmt|;
name|bfd_vma
name|phdrs_vaddr
decl_stmt|,
name|phdrs_paddr
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|map_sections_to_segments
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
block|}
if|if
condition|(
name|bed
operator|->
name|elf_backend_modify_segment_map
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|bed
operator|->
name|elf_backend_modify_segment_map
call|)
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
operator|++
name|count
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_phoff
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_ehdr
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_phentsize
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_phdr
expr_stmt|;
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_phnum
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
name|true
return|;
comment|/* If we already counted the number of program segments, make sure      that we allocated enough space.  This happens when SIZEOF_HEADERS      is used in a linker script.  */
name|alloc
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|program_header_size
operator|/
name|bed
operator|->
name|s
operator|->
name|sizeof_phdr
expr_stmt|;
if|if
condition|(
name|alloc
operator|!=
literal|0
operator|&&
name|count
operator|>
name|alloc
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: Not enough room for program headers (allocated %u, need %u)"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|alloc
argument_list|,
name|count
argument_list|)
operator|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|alloc
operator|==
literal|0
condition|)
name|alloc
operator|=
name|count
expr_stmt|;
name|phdrs
operator|=
operator|(
operator|(
name|Elf_Internal_Phdr
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|alloc
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Phdr
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|phdrs
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|off
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_ehdr
expr_stmt|;
name|off
operator|+=
name|alloc
operator|*
name|bed
operator|->
name|s
operator|->
name|sizeof_phdr
expr_stmt|;
name|filehdr_vaddr
operator|=
literal|0
expr_stmt|;
name|filehdr_paddr
operator|=
literal|0
expr_stmt|;
name|phdrs_vaddr
operator|=
literal|0
expr_stmt|;
name|phdrs_paddr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
operator|,
name|p
operator|=
name|phdrs
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
operator|,
name|p
operator|++
control|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secpp
decl_stmt|;
comment|/* If elf_segment_map is not from map_sections_to_segments, the          sections may not be correctly ordered.  */
if|if
condition|(
name|m
operator|->
name|count
operator|>
literal|0
condition|)
name|qsort
argument_list|(
name|m
operator|->
name|sections
argument_list|,
operator|(
name|size_t
operator|)
name|m
operator|->
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|,
name|elf_sort_sections
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_type
operator|=
name|m
operator|->
name|p_type
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|p_flags_valid
condition|)
name|p
operator|->
name|p_flags
operator|=
name|m
operator|->
name|p_flags
expr_stmt|;
else|else
name|p
operator|->
name|p_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_type
operator|==
name|PT_LOAD
operator|&&
name|m
operator|->
name|count
operator|>
literal|0
operator|&&
operator|(
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|!=
literal|0
condition|)
name|off
operator|+=
operator|(
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|->
name|vma
operator|-
name|off
operator|)
operator|%
name|bed
operator|->
name|maxpagesize
expr_stmt|;
else|else
name|off
operator|+=
operator|(
operator|(
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|->
name|vma
operator|-
name|off
operator|)
operator|%
operator|(
literal|1
operator|<<
name|bfd_get_section_alignment
argument_list|(
name|abfd
argument_list|,
name|m
operator|->
name|sections
index|[
literal|0
index|]
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|count
operator|==
literal|0
condition|)
name|p
operator|->
name|p_vaddr
operator|=
literal|0
expr_stmt|;
else|else
name|p
operator|->
name|p_vaddr
operator|=
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|p_paddr_valid
condition|)
name|p
operator|->
name|p_paddr
operator|=
name|m
operator|->
name|p_paddr
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|->
name|count
operator|==
literal|0
condition|)
name|p
operator|->
name|p_paddr
operator|=
literal|0
expr_stmt|;
else|else
name|p
operator|->
name|p_paddr
operator|=
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|->
name|lma
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_type
operator|==
name|PT_LOAD
operator|&&
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|!=
literal|0
condition|)
name|p
operator|->
name|p_align
operator|=
name|bed
operator|->
name|maxpagesize
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|->
name|count
operator|==
literal|0
condition|)
name|p
operator|->
name|p_align
operator|=
name|bed
operator|->
name|s
operator|->
name|file_align
expr_stmt|;
else|else
name|p
operator|->
name|p_align
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|p_offset
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|p_filesz
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|p_memsz
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|includes_filehdr
condition|)
block|{
if|if
condition|(
operator|!
name|m
operator|->
name|p_flags_valid
condition|)
name|p
operator|->
name|p_flags
operator||=
name|PF_R
expr_stmt|;
name|p
operator|->
name|p_offset
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|p_filesz
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_ehdr
expr_stmt|;
name|p
operator|->
name|p_memsz
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_ehdr
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|count
operator|>
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|p
operator|->
name|p_type
operator|==
name|PT_LOAD
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_vaddr
operator|-=
name|off
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|p_paddr_valid
condition|)
name|p
operator|->
name|p_paddr
operator|-=
name|off
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|p_type
operator|==
name|PT_LOAD
condition|)
block|{
name|filehdr_vaddr
operator|=
name|p
operator|->
name|p_vaddr
expr_stmt|;
name|filehdr_paddr
operator|=
name|p
operator|->
name|p_paddr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
operator|->
name|includes_phdrs
condition|)
block|{
if|if
condition|(
operator|!
name|m
operator|->
name|p_flags_valid
condition|)
name|p
operator|->
name|p_flags
operator||=
name|PF_R
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|includes_filehdr
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_type
operator|==
name|PT_LOAD
condition|)
block|{
name|phdrs_vaddr
operator|=
name|p
operator|->
name|p_vaddr
operator|+
name|bed
operator|->
name|s
operator|->
name|sizeof_ehdr
expr_stmt|;
name|phdrs_paddr
operator|=
name|p
operator|->
name|p_paddr
operator|+
name|bed
operator|->
name|s
operator|->
name|sizeof_ehdr
expr_stmt|;
block|}
block|}
else|else
block|{
name|p
operator|->
name|p_offset
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_ehdr
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|count
operator|>
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
name|p
operator|->
name|p_type
operator|==
name|PT_LOAD
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_vaddr
operator|-=
name|off
operator|-
name|p
operator|->
name|p_offset
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|p_paddr_valid
condition|)
name|p
operator|->
name|p_paddr
operator|-=
name|off
operator|-
name|p
operator|->
name|p_offset
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|p_type
operator|==
name|PT_LOAD
condition|)
block|{
name|phdrs_vaddr
operator|=
name|p
operator|->
name|p_vaddr
expr_stmt|;
name|phdrs_paddr
operator|=
name|p
operator|->
name|p_paddr
expr_stmt|;
block|}
block|}
name|p
operator|->
name|p_filesz
operator|+=
name|alloc
operator|*
name|bed
operator|->
name|s
operator|->
name|sizeof_phdr
expr_stmt|;
name|p
operator|->
name|p_memsz
operator|+=
name|alloc
operator|*
name|bed
operator|->
name|s
operator|->
name|sizeof_phdr
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|p_type
operator|==
name|PT_LOAD
condition|)
block|{
if|if
condition|(
operator|!
name|m
operator|->
name|includes_filehdr
operator|&&
operator|!
name|m
operator|->
name|includes_phdrs
condition|)
name|p
operator|->
name|p_offset
operator|=
name|off
expr_stmt|;
else|else
block|{
name|file_ptr
name|adjust
decl_stmt|;
name|adjust
operator|=
name|off
operator|-
operator|(
name|p
operator|->
name|p_offset
operator|+
name|p
operator|->
name|p_filesz
operator|)
expr_stmt|;
name|p
operator|->
name|p_filesz
operator|+=
name|adjust
expr_stmt|;
name|p
operator|->
name|p_memsz
operator|+=
name|adjust
expr_stmt|;
block|}
block|}
name|voff
operator|=
name|off
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|secpp
operator|=
name|m
operator|->
name|sections
init|;
name|i
operator|<
name|m
operator|->
name|count
condition|;
name|i
operator|++
operator|,
name|secpp
operator|++
control|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|flagword
name|flags
decl_stmt|;
name|bfd_size_type
name|align
decl_stmt|;
name|sec
operator|=
operator|*
name|secpp
expr_stmt|;
name|flags
operator|=
name|sec
operator|->
name|flags
expr_stmt|;
name|align
operator|=
literal|1
operator|<<
name|bfd_get_section_alignment
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_type
operator|==
name|PT_LOAD
condition|)
block|{
name|bfd_vma
name|adjust
decl_stmt|;
comment|/* The section VMA must equal the file position modulo                  the page size.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|!=
literal|0
condition|)
name|adjust
operator|=
operator|(
name|sec
operator|->
name|vma
operator|-
name|voff
operator|)
operator|%
name|bed
operator|->
name|maxpagesize
expr_stmt|;
else|else
name|adjust
operator|=
operator|(
name|sec
operator|->
name|vma
operator|-
name|voff
operator|)
operator|%
name|align
expr_stmt|;
if|if
condition|(
name|adjust
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|p
operator|->
name|p_memsz
operator|+=
name|adjust
expr_stmt|;
name|off
operator|+=
name|adjust
expr_stmt|;
name|voff
operator|+=
name|adjust
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
name|p
operator|->
name|p_filesz
operator|+=
name|adjust
expr_stmt|;
block|}
block|}
name|sec
operator|->
name|filepos
operator|=
name|off
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
name|off
operator|+=
name|sec
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
condition|)
name|voff
operator|+=
name|sec
operator|->
name|_raw_size
expr_stmt|;
block|}
name|p
operator|->
name|p_memsz
operator|+=
name|sec
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
name|p
operator|->
name|p_filesz
operator|+=
name|sec
operator|->
name|_raw_size
expr_stmt|;
if|if
condition|(
name|align
operator|>
name|p
operator|->
name|p_align
condition|)
name|p
operator|->
name|p_align
operator|=
name|align
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|p_flags_valid
condition|)
block|{
name|p
operator|->
name|p_flags
operator||=
name|PF_R
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_CODE
operator|)
operator|!=
literal|0
condition|)
name|p
operator|->
name|p_flags
operator||=
name|PF_X
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|==
literal|0
condition|)
name|p
operator|->
name|p_flags
operator||=
name|PF_W
expr_stmt|;
block|}
block|}
block|}
comment|/* Now that we have set the section file positions, we can set up      the file positions for the non PT_LOAD segments.  */
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
operator|,
name|p
operator|=
name|phdrs
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
operator|,
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|p_type
operator|!=
name|PT_LOAD
operator|&&
name|m
operator|->
name|count
operator|>
literal|0
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|!
name|m
operator|->
name|includes_filehdr
operator|&&
operator|!
name|m
operator|->
name|includes_phdrs
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_offset
operator|=
name|m
operator|->
name|sections
index|[
literal|0
index|]
operator|->
name|filepos
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|includes_filehdr
condition|)
block|{
name|p
operator|->
name|p_vaddr
operator|=
name|filehdr_vaddr
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|p_paddr_valid
condition|)
name|p
operator|->
name|p_paddr
operator|=
name|filehdr_paddr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|includes_phdrs
condition|)
block|{
name|p
operator|->
name|p_vaddr
operator|=
name|phdrs_vaddr
expr_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|p_paddr_valid
condition|)
name|p
operator|->
name|p_paddr
operator|=
name|phdrs_paddr
expr_stmt|;
block|}
block|}
block|}
comment|/* Clear out any program headers we allocated but did not use.  */
for|for
control|(
init|;
name|count
operator|<
name|alloc
condition|;
name|count
operator|++
operator|,
name|p
operator|++
control|)
block|{
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_type
operator|=
name|PT_NULL
expr_stmt|;
block|}
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|phdr
operator|=
name|phdrs
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|next_file_pos
operator|=
name|off
expr_stmt|;
comment|/* Write out the program headers.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|bed
operator|->
name|s
operator|->
name|sizeof_ehdr
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bed
operator|->
name|s
operator|->
name|write_out_phdrs
argument_list|(
name|abfd
argument_list|,
name|phdrs
argument_list|,
name|alloc
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Get the size of the program header.     If this is called by the linker before any of the section VMA's are set, it    can't calculate the correct value for a strange memory layout.  This only    happens when SIZEOF_HEADERS is used in a linker script.  In this case,    SORTED_HDRS is NULL and we assume the normal scenario of one text and one    data segment (exclusive of .interp and .dynamic).     ??? User written scripts must either not use SIZEOF_HEADERS, or assume there    will be two segments.  */
end_comment

begin_function
specifier|static
name|bfd_size_type
name|get_program_header_size
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|size_t
name|segs
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
comment|/* We can't return a different result each time we're called.  */
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|program_header_size
operator|!=
literal|0
condition|)
return|return
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|program_header_size
return|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
operator|!=
name|NULL
condition|)
block|{
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|;
name|segs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|segment_map
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
operator|++
name|segs
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|program_header_size
operator|=
name|segs
operator|*
name|bed
operator|->
name|s
operator|->
name|sizeof_phdr
expr_stmt|;
return|return
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|program_header_size
return|;
block|}
comment|/* Assume we will need exactly two PT_LOAD segments: one for text      and one for data.  */
name|segs
operator|=
literal|2
expr_stmt|;
name|s
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* If we have a loadable interpreter section, we need a 	 PT_INTERP segment.  In this case, assume we also need a 	 PT_PHDR segment, although that may not be true for all 	 targets.  */
name|segs
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
literal|".dynamic"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* We need a PT_DYNAMIC segment.  */
operator|++
name|segs
expr_stmt|;
block|}
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|s
operator|->
name|name
argument_list|,
literal|".note"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We need a PT_NOTE segment.  */
operator|++
name|segs
expr_stmt|;
block|}
block|}
comment|/* Let the backend count up any program headers it might need.  */
if|if
condition|(
name|bed
operator|->
name|elf_backend_additional_program_headers
condition|)
block|{
name|int
name|a
decl_stmt|;
name|a
operator|=
call|(
modifier|*
name|bed
operator|->
name|elf_backend_additional_program_headers
call|)
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|segs
operator|+=
name|a
expr_stmt|;
block|}
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|program_header_size
operator|=
name|segs
operator|*
name|bed
operator|->
name|s
operator|->
name|sizeof_phdr
expr_stmt|;
return|return
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|program_header_size
return|;
block|}
end_function

begin_comment
comment|/* Work out the file positions of all the sections.  This is called by    _bfd_elf_compute_section_file_positions.  All the section sizes and    VMAs must be known before this is called.     We do not consider reloc sections at this point, unless they form    part of the loadable image.  Reloc sections are assigned file    positions in assign_file_positions_for_relocs, which is called by    write_object_contents and final_link.     We also don't set the positions of the .symtab and .strtab here.  */
end_comment

begin_function
specifier|static
name|boolean
name|assign_file_positions_except_relocs
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|elf_obj_tdata
modifier|*
specifier|const
name|tdata
init|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|Elf_Internal_Ehdr
modifier|*
specifier|const
name|i_ehdrp
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
modifier|*
specifier|const
name|i_shdrpp
init|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|file_ptr
name|off
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
operator|(
name|EXEC_P
operator||
name|DYNAMIC
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|hdrpp
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Start after the ELF header.  */
name|off
operator|=
name|i_ehdrp
operator|->
name|e_ehsize
expr_stmt|;
comment|/* We are not creating an executable, which means that we are 	 not creating a program header, and that the actual order of 	 the sections in the file is unimportant.  */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|hdrpp
operator|=
name|i_shdrpp
operator|+
literal|1
init|;
name|i
operator|<
name|i_ehdrp
operator|->
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|hdrpp
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
operator|*
name|hdrpp
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_REL
operator|||
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_RELA
condition|)
block|{
name|hdr
operator|->
name|sh_offset
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|i
operator|==
name|tdata
operator|->
name|symtab_section
operator|||
name|i
operator|==
name|tdata
operator|->
name|strtab_section
condition|)
block|{
name|hdr
operator|->
name|sh_offset
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
name|off
operator|=
name|_bfd_elf_assign_file_position_for_section
argument_list|(
name|hdr
argument_list|,
name|off
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|hdrpp
decl_stmt|;
comment|/* Assign file positions for the loaded sections based on the          assignment of sections to segments.  */
if|if
condition|(
operator|!
name|assign_file_positions_for_segments
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Assign file positions for the other sections.  */
name|off
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|next_file_pos
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|hdrpp
operator|=
name|i_shdrpp
operator|+
literal|1
init|;
name|i
operator|<
name|i_ehdrp
operator|->
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|hdrpp
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|hdr
operator|=
operator|*
name|hdrpp
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|bfd_section
operator|!=
name|NULL
operator|&&
name|hdr
operator|->
name|bfd_section
operator|->
name|filepos
operator|!=
literal|0
condition|)
name|hdr
operator|->
name|sh_offset
operator|=
name|hdr
operator|->
name|bfd_section
operator|->
name|filepos
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|hdr
operator|->
name|sh_flags
operator|&
name|SHF_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: warning: allocated section `%s' not in segment"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|hdr
operator|->
name|bfd_section
operator|==
name|NULL
condition|?
literal|"*unknown*"
else|:
name|hdr
operator|->
name|bfd_section
operator|->
name|name
operator|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|D_PAGED
operator|)
operator|!=
literal|0
condition|)
name|off
operator|+=
operator|(
name|hdr
operator|->
name|sh_addr
operator|-
name|off
operator|)
operator|%
name|bed
operator|->
name|maxpagesize
expr_stmt|;
else|else
name|off
operator|+=
operator|(
name|hdr
operator|->
name|sh_addr
operator|-
name|off
operator|)
operator|%
name|hdr
operator|->
name|sh_addralign
expr_stmt|;
name|off
operator|=
name|_bfd_elf_assign_file_position_for_section
argument_list|(
name|hdr
argument_list|,
name|off
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_REL
operator|||
name|hdr
operator|->
name|sh_type
operator|==
name|SHT_RELA
operator|||
name|hdr
operator|==
name|i_shdrpp
index|[
name|tdata
operator|->
name|symtab_section
index|]
operator|||
name|hdr
operator|==
name|i_shdrpp
index|[
name|tdata
operator|->
name|strtab_section
index|]
condition|)
name|hdr
operator|->
name|sh_offset
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|off
operator|=
name|_bfd_elf_assign_file_position_for_section
argument_list|(
name|hdr
argument_list|,
name|off
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Place the section headers.  */
name|off
operator|=
name|align_file_position
argument_list|(
name|off
argument_list|,
name|bed
operator|->
name|s
operator|->
name|file_align
argument_list|)
expr_stmt|;
name|i_ehdrp
operator|->
name|e_shoff
operator|=
name|off
expr_stmt|;
name|off
operator|+=
name|i_ehdrp
operator|->
name|e_shnum
operator|*
name|i_ehdrp
operator|->
name|e_shentsize
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|next_file_pos
operator|=
name|off
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|boolean
name|prep_headers
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
comment|/* Elf file header, internal form */
name|Elf_Internal_Phdr
modifier|*
name|i_phdrp
init|=
literal|0
decl_stmt|;
comment|/* Program header table, internal form */
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|i_shdrp
decl_stmt|;
comment|/* Section header table, internal form */
name|int
name|count
decl_stmt|;
name|struct
name|bfd_strtab_hash
modifier|*
name|shstrtab
decl_stmt|;
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|i_shdrp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|shstrtab
operator|=
name|_bfd_elf_stringtab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|shstrtab
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
operator|=
name|shstrtab
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG0
index|]
operator|=
name|ELFMAG0
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG1
index|]
operator|=
name|ELFMAG1
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG2
index|]
operator|=
name|ELFMAG2
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_MAG3
index|]
operator|=
name|ELFMAG3
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|=
name|bed
operator|->
name|s
operator|->
name|elfclass
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_DATA
index|]
operator|=
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|?
name|ELFDATA2MSB
else|:
name|ELFDATA2LSB
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ident
index|[
name|EI_VERSION
index|]
operator|=
name|bed
operator|->
name|s
operator|->
name|ev_current
expr_stmt|;
for|for
control|(
name|count
operator|=
name|EI_PAD
init|;
name|count
operator|<
name|EI_NIDENT
condition|;
name|count
operator|++
control|)
name|i_ehdrp
operator|->
name|e_ident
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
condition|)
name|i_ehdrp
operator|->
name|e_type
operator|=
name|ET_DYN
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
operator|)
operator|!=
literal|0
condition|)
name|i_ehdrp
operator|->
name|e_type
operator|=
name|ET_EXEC
expr_stmt|;
else|else
name|i_ehdrp
operator|->
name|e_type
operator|=
name|ET_REL
expr_stmt|;
switch|switch
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_arch_unknown
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_NONE
expr_stmt|;
break|break;
case|case
name|bfd_arch_sparc
case|:
if|if
condition|(
name|bed
operator|->
name|s
operator|->
name|arch_size
operator|==
literal|64
condition|)
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_SPARC64
expr_stmt|;
else|else
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_SPARC
expr_stmt|;
break|break;
case|case
name|bfd_arch_i386
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_386
expr_stmt|;
break|break;
case|case
name|bfd_arch_m68k
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_68K
expr_stmt|;
break|break;
case|case
name|bfd_arch_m88k
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_88K
expr_stmt|;
break|break;
case|case
name|bfd_arch_i860
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_860
expr_stmt|;
break|break;
case|case
name|bfd_arch_mips
case|:
comment|/* MIPS Rxxxx */
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_MIPS
expr_stmt|;
comment|/* only MIPS R3000 */
break|break;
case|case
name|bfd_arch_hppa
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_PARISC
expr_stmt|;
break|break;
case|case
name|bfd_arch_powerpc
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_PPC
expr_stmt|;
break|break;
case|case
name|bfd_arch_alpha
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_ALPHA
expr_stmt|;
break|break;
case|case
name|bfd_arch_sh
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_SH
expr_stmt|;
break|break;
case|case
name|bfd_arch_d10v
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_CYGNUS_D10V
expr_stmt|;
break|break;
case|case
name|bfd_arch_m32r
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_CYGNUS_M32R
expr_stmt|;
break|break;
case|case
name|bfd_arch_mn10200
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_CYGNUS_MN10200
expr_stmt|;
break|break;
case|case
name|bfd_arch_mn10300
case|:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_CYGNUS_MN10300
expr_stmt|;
break|break;
comment|/* also note that EM_M32, AT&T WE32100 is unknown to bfd */
default|default:
name|i_ehdrp
operator|->
name|e_machine
operator|=
name|EM_NONE
expr_stmt|;
block|}
name|i_ehdrp
operator|->
name|e_version
operator|=
name|bed
operator|->
name|s
operator|->
name|ev_current
expr_stmt|;
name|i_ehdrp
operator|->
name|e_ehsize
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_ehdr
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
comment|/* Quick and dirty hack to brand the file as a FreeBSD ELF file. */
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|i_ehdrp
operator|->
name|e_ident
index|[
literal|8
index|]
argument_list|,
literal|"FreeBSD"
argument_list|,
name|EI_NIDENT
operator|-
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* no program header, for now. */
name|i_ehdrp
operator|->
name|e_phoff
operator|=
literal|0
expr_stmt|;
name|i_ehdrp
operator|->
name|e_phentsize
operator|=
literal|0
expr_stmt|;
name|i_ehdrp
operator|->
name|e_phnum
operator|=
literal|0
expr_stmt|;
comment|/* each bfd section is section header entry */
name|i_ehdrp
operator|->
name|e_entry
operator|=
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|i_ehdrp
operator|->
name|e_shentsize
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_shdr
expr_stmt|;
comment|/* if we're building an executable, we'll need a program header table */
if|if
condition|(
name|abfd
operator|->
name|flags
operator|&
name|EXEC_P
condition|)
block|{
comment|/* it all happens later */
if|#
directive|if
literal|0
block|i_ehdrp->e_phentsize = sizeof (Elf_External_Phdr);
comment|/* elf_build_phdrs() returns a (NULL-terminated) array of 	 Elf_Internal_Phdrs */
block|i_phdrp = elf_build_phdrs (abfd, i_ehdrp, i_shdrp,&i_ehdrp->e_phnum);       i_ehdrp->e_phoff = outbase;       outbase += i_ehdrp->e_phentsize * i_ehdrp->e_phnum;
endif|#
directive|endif
block|}
else|else
block|{
name|i_ehdrp
operator|->
name|e_phentsize
operator|=
literal|0
expr_stmt|;
name|i_phdrp
operator|=
literal|0
expr_stmt|;
name|i_ehdrp
operator|->
name|e_phoff
operator|=
literal|0
expr_stmt|;
block|}
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_name
operator|=
operator|(
name|unsigned
name|int
operator|)
name|_bfd_stringtab_add
argument_list|(
name|shstrtab
argument_list|,
literal|".symtab"
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|strtab_hdr
operator|.
name|sh_name
operator|=
operator|(
name|unsigned
name|int
operator|)
name|_bfd_stringtab_add
argument_list|(
name|shstrtab
argument_list|,
literal|".strtab"
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|shstrtab_hdr
operator|.
name|sh_name
operator|=
operator|(
name|unsigned
name|int
operator|)
name|_bfd_stringtab_add
argument_list|(
name|shstrtab
argument_list|,
literal|".shstrtab"
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_name
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
operator|||
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
operator|.
name|sh_name
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
operator|||
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|shstrtab_hdr
operator|.
name|sh_name
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Assign file positions for all the reloc sections which are not part    of the loadable file image.  */
end_comment

begin_function
name|void
name|_bfd_elf_assign_file_positions_for_relocs
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|file_ptr
name|off
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|shdrpp
decl_stmt|;
name|off
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|next_file_pos
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|shdrpp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
init|;
name|i
operator|<
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shnum
condition|;
name|i
operator|++
operator|,
name|shdrpp
operator|++
control|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|shdrp
decl_stmt|;
name|shdrp
operator|=
operator|*
name|shdrpp
expr_stmt|;
if|if
condition|(
operator|(
name|shdrp
operator|->
name|sh_type
operator|==
name|SHT_REL
operator|||
name|shdrp
operator|->
name|sh_type
operator|==
name|SHT_RELA
operator|)
operator|&&
name|shdrp
operator|->
name|sh_offset
operator|==
operator|-
literal|1
condition|)
name|off
operator|=
name|_bfd_elf_assign_file_position_for_section
argument_list|(
name|shdrp
argument_list|,
name|off
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|next_file_pos
operator|=
name|off
expr_stmt|;
block|}
end_function

begin_function
name|boolean
name|_bfd_elf_write_object_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|Elf_Internal_Ehdr
modifier|*
name|i_ehdrp
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|i_shdrp
decl_stmt|;
name|boolean
name|failed
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
if|if
condition|(
operator|!
name|abfd
operator|->
name|output_has_begun
operator|&&
operator|!
name|_bfd_elf_compute_section_file_positions
argument_list|(
name|abfd
argument_list|,
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
name|i_shdrp
operator|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|i_ehdrp
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|failed
operator|=
name|false
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|bed
operator|->
name|s
operator|->
name|write_relocs
argument_list|,
operator|&
name|failed
argument_list|)
expr_stmt|;
if|if
condition|(
name|failed
condition|)
return|return
name|false
return|;
name|_bfd_elf_assign_file_positions_for_relocs
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
comment|/* After writing the headers, we need to write the sections too... */
for|for
control|(
name|count
operator|=
literal|1
init|;
name|count
operator|<
name|i_ehdrp
operator|->
name|e_shnum
condition|;
name|count
operator|++
control|)
block|{
if|if
condition|(
name|bed
operator|->
name|elf_backend_section_processing
condition|)
call|(
modifier|*
name|bed
operator|->
name|elf_backend_section_processing
call|)
argument_list|(
name|abfd
argument_list|,
name|i_shdrp
index|[
name|count
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_shdrp
index|[
name|count
index|]
operator|->
name|contents
condition|)
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|i_shdrp
index|[
name|count
index|]
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|bfd_write
argument_list|(
name|i_shdrp
index|[
name|count
index|]
operator|->
name|contents
argument_list|,
name|i_shdrp
index|[
name|count
index|]
operator|->
name|sh_size
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|i_shdrp
index|[
name|count
index|]
operator|->
name|sh_size
operator|)
condition|)
return|return
name|false
return|;
block|}
block|}
comment|/* Write out the section header names.  */
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|shstrtab_hdr
operator|.
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|_bfd_stringtab_emit
argument_list|(
name|abfd
argument_list|,
name|elf_shstrtab
argument_list|(
name|abfd
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bed
operator|->
name|elf_backend_final_write_processing
condition|)
call|(
modifier|*
name|bed
operator|->
name|elf_backend_final_write_processing
call|)
argument_list|(
name|abfd
argument_list|,
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|linker
argument_list|)
expr_stmt|;
return|return
name|bed
operator|->
name|s
operator|->
name|write_shdrs_and_ehdr
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* given a section, search the header to find them... */
end_comment

begin_function
name|int
name|_bfd_elf_section_from_bfd_section
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|sec
modifier|*
name|asect
decl_stmt|;
block|{
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
modifier|*
name|i_shdrp
init|=
name|elf_elfsections
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|int
name|index
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|int
name|maxindex
init|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_shnum
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|maxindex
condition|;
name|index
operator|++
control|)
block|{
name|hdr
operator|=
name|i_shdrp
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|bfd_section
operator|==
name|asect
condition|)
return|return
name|index
return|;
block|}
if|if
condition|(
name|bed
operator|->
name|elf_backend_section_from_bfd_section
condition|)
block|{
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|maxindex
condition|;
name|index
operator|++
control|)
block|{
name|int
name|retval
decl_stmt|;
name|hdr
operator|=
name|i_shdrp
index|[
name|index
index|]
expr_stmt|;
name|retval
operator|=
name|index
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|bed
operator|->
name|elf_backend_section_from_bfd_section
call|)
argument_list|(
name|abfd
argument_list|,
name|hdr
argument_list|,
name|asect
argument_list|,
operator|&
name|retval
argument_list|)
condition|)
return|return
name|retval
return|;
block|}
block|}
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|asect
argument_list|)
condition|)
return|return
name|SHN_ABS
return|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|asect
argument_list|)
condition|)
return|return
name|SHN_COMMON
return|;
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|asect
argument_list|)
condition|)
return|return
name|SHN_UNDEF
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given a BFD symbol, return the index in the ELF symbol table, or -1    on error.  */
end_comment

begin_function
name|int
name|_bfd_elf_symbol_from_bfd_symbol
parameter_list|(
name|abfd
parameter_list|,
name|asym_ptr_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|asym_ptr_ptr
decl_stmt|;
block|{
name|asymbol
modifier|*
name|asym_ptr
init|=
operator|*
name|asym_ptr_ptr
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|flagword
name|flags
init|=
name|asym_ptr
operator|->
name|flags
decl_stmt|;
comment|/* When gas creates relocations against local labels, it creates its      own symbol for the section, but does put the symbol into the      symbol chain, so udata is 0.  When the linker is generating      relocatable output, this section symbol may be for one of the      input sections rather than the output section.  */
if|if
condition|(
name|asym_ptr
operator|->
name|udata
operator|.
name|i
operator|==
literal|0
operator|&&
operator|(
name|flags
operator|&
name|BSF_SECTION_SYM
operator|)
operator|&&
name|asym_ptr
operator|->
name|section
condition|)
block|{
name|int
name|indx
decl_stmt|;
if|if
condition|(
name|asym_ptr
operator|->
name|section
operator|->
name|output_section
operator|!=
name|NULL
condition|)
name|indx
operator|=
name|asym_ptr
operator|->
name|section
operator|->
name|output_section
operator|->
name|index
expr_stmt|;
else|else
name|indx
operator|=
name|asym_ptr
operator|->
name|section
operator|->
name|index
expr_stmt|;
if|if
condition|(
name|elf_section_syms
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
condition|)
name|asym_ptr
operator|->
name|udata
operator|.
name|i
operator|=
name|elf_section_syms
argument_list|(
name|abfd
argument_list|)
index|[
name|indx
index|]
operator|->
name|udata
operator|.
name|i
expr_stmt|;
block|}
name|idx
operator|=
name|asym_ptr
operator|->
name|udata
operator|.
name|i
expr_stmt|;
if|if
condition|(
name|idx
operator|==
literal|0
condition|)
block|{
comment|/* This case can occur when using --strip-symbol on a symbol          which is used in a relocation entry.  */
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: symbol `%s' required but not present"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|asym_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_no_symbols
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|#
directive|if
name|DEBUG
operator|&
literal|4
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"elf_symbol_from_bfd_symbol 0x%.8lx, name = %s, sym num = %d, flags = 0x%.8lx%s\n"
argument_list|,
operator|(
name|long
operator|)
name|asym_ptr
argument_list|,
name|asym_ptr
operator|->
name|name
argument_list|,
name|idx
argument_list|,
name|flags
argument_list|,
name|elf_symbol_flags
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* Copy private BFD data.  This copies any program header information.  */
end_comment

begin_function
specifier|static
name|boolean
name|copy_private_bfd_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
name|Elf_Internal_Ehdr
modifier|*
name|iehdr
decl_stmt|;
name|struct
name|elf_segment_map
modifier|*
name|mfirst
decl_stmt|;
name|struct
name|elf_segment_map
modifier|*
modifier|*
name|pm
decl_stmt|;
name|Elf_Internal_Phdr
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|true
return|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|phdr
operator|==
name|NULL
condition|)
return|return
name|true
return|;
name|iehdr
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
expr_stmt|;
name|mfirst
operator|=
name|NULL
expr_stmt|;
name|pm
operator|=
operator|&
name|mfirst
expr_stmt|;
name|c
operator|=
name|elf_elfheader
argument_list|(
name|ibfd
argument_list|)
operator|->
name|e_phnum
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|phdr
init|;
name|i
operator|<
name|c
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
name|unsigned
name|int
name|csecs
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|struct
name|elf_segment_map
modifier|*
name|m
decl_stmt|;
name|unsigned
name|int
name|isec
decl_stmt|;
name|csecs
operator|=
literal|0
expr_stmt|;
comment|/* The complicated case when p_vaddr is 0 is to handle the 	 Solaris linker, which generates a PT_INTERP section with 	 p_vaddr and p_memsz set to 0.  */
for|for
control|(
name|s
operator|=
name|ibfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
operator|(
operator|(
name|s
operator|->
name|vma
operator|>=
name|p
operator|->
name|p_vaddr
operator|&&
operator|(
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|_raw_size
operator|<=
name|p
operator|->
name|p_vaddr
operator|+
name|p
operator|->
name|p_memsz
operator|||
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|_raw_size
operator|<=
name|p
operator|->
name|p_vaddr
operator|+
name|p
operator|->
name|p_filesz
operator|)
operator|)
operator|||
operator|(
name|p
operator|->
name|p_vaddr
operator|==
literal|0
operator|&&
name|p
operator|->
name|p_filesz
operator|>
literal|0
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|bfd_vma
operator|)
name|s
operator|->
name|filepos
operator|>=
name|p
operator|->
name|p_offset
operator|&&
operator|(
operator|(
name|bfd_vma
operator|)
name|s
operator|->
name|filepos
operator|+
name|s
operator|->
name|_raw_size
operator|<=
name|p
operator|->
name|p_offset
operator|+
name|p
operator|->
name|p_filesz
operator|)
operator|)
operator|)
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
name|s
operator|->
name|output_section
operator|!=
name|NULL
condition|)
operator|++
name|csecs
expr_stmt|;
name|m
operator|=
operator|(
operator|(
expr|struct
name|elf_segment_map
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|obfd
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|elf_segment_map
argument_list|)
operator|+
operator|(
operator|(
name|size_t
operator|)
name|csecs
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
operator|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|m
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|p_type
operator|=
name|p
operator|->
name|p_type
expr_stmt|;
name|m
operator|->
name|p_flags
operator|=
name|p
operator|->
name|p_flags
expr_stmt|;
name|m
operator|->
name|p_flags_valid
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|p_paddr
operator|=
name|p
operator|->
name|p_paddr
expr_stmt|;
name|m
operator|->
name|p_paddr_valid
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|includes_filehdr
operator|=
operator|(
name|p
operator|->
name|p_offset
operator|==
literal|0
operator|&&
name|p
operator|->
name|p_filesz
operator|>=
name|iehdr
operator|->
name|e_ehsize
operator|)
expr_stmt|;
name|m
operator|->
name|includes_phdrs
operator|=
operator|(
name|p
operator|->
name|p_offset
operator|<=
operator|(
name|bfd_vma
operator|)
name|iehdr
operator|->
name|e_phoff
operator|&&
operator|(
name|p
operator|->
name|p_offset
operator|+
name|p
operator|->
name|p_filesz
operator|>=
operator|(
operator|(
name|bfd_vma
operator|)
name|iehdr
operator|->
name|e_phoff
operator|+
name|iehdr
operator|->
name|e_phnum
operator|*
name|iehdr
operator|->
name|e_phentsize
operator|)
operator|)
operator|)
expr_stmt|;
name|isec
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|ibfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|s
operator|->
name|vma
operator|>=
name|p
operator|->
name|p_vaddr
operator|&&
operator|(
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|_raw_size
operator|<=
name|p
operator|->
name|p_vaddr
operator|+
name|p
operator|->
name|p_memsz
operator|||
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|_raw_size
operator|<=
name|p
operator|->
name|p_vaddr
operator|+
name|p
operator|->
name|p_filesz
operator|)
operator|)
operator|||
operator|(
name|p
operator|->
name|p_vaddr
operator|==
literal|0
operator|&&
name|p
operator|->
name|p_filesz
operator|>
literal|0
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_HAS_CONTENTS
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|bfd_vma
operator|)
name|s
operator|->
name|filepos
operator|>=
name|p
operator|->
name|p_offset
operator|&&
operator|(
operator|(
name|bfd_vma
operator|)
name|s
operator|->
name|filepos
operator|+
name|s
operator|->
name|_raw_size
operator|<=
name|p
operator|->
name|p_offset
operator|+
name|p
operator|->
name|p_filesz
operator|)
operator|)
operator|)
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|!=
literal|0
operator|&&
name|s
operator|->
name|output_section
operator|!=
name|NULL
condition|)
block|{
name|m
operator|->
name|sections
index|[
name|isec
index|]
operator|=
name|s
operator|->
name|output_section
expr_stmt|;
operator|++
name|isec
expr_stmt|;
block|}
block|}
name|BFD_ASSERT
argument_list|(
name|isec
operator|==
name|csecs
argument_list|)
expr_stmt|;
name|m
operator|->
name|count
operator|=
name|csecs
expr_stmt|;
operator|*
name|pm
operator|=
name|m
expr_stmt|;
name|pm
operator|=
operator|&
name|m
operator|->
name|next
expr_stmt|;
block|}
name|elf_tdata
argument_list|(
name|obfd
argument_list|)
operator|->
name|segment_map
operator|=
name|mfirst
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Copy private section information.  This copies over the entsize    field, and sometimes the info field.  */
end_comment

begin_function
name|boolean
name|_bfd_elf_copy_private_section_data
parameter_list|(
name|ibfd
parameter_list|,
name|isec
parameter_list|,
name|obfd
parameter_list|,
name|osec
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|asection
modifier|*
name|isec
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|asection
modifier|*
name|osec
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|ihdr
decl_stmt|,
modifier|*
name|ohdr
decl_stmt|;
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_elf_flavour
operator|||
name|obfd
operator|->
name|xvec
operator|->
name|flavour
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|true
return|;
comment|/* Copy over private BFD data if it has not already been copied.      This must be done here, rather than in the copy_private_bfd_data      entry point, because the latter is called after the section      contents have been set, which means that the program headers have      already been worked out.  */
if|if
condition|(
name|elf_tdata
argument_list|(
name|obfd
argument_list|)
operator|->
name|segment_map
operator|==
name|NULL
operator|&&
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|phdr
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* Only set up the segments when all the sections have been set          up.  */
for|for
control|(
name|s
operator|=
name|ibfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|s
operator|->
name|output_section
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|copy_private_bfd_data
argument_list|(
name|ibfd
argument_list|,
name|obfd
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
name|ihdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|isec
argument_list|)
operator|->
name|this_hdr
expr_stmt|;
name|ohdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|osec
argument_list|)
operator|->
name|this_hdr
expr_stmt|;
name|ohdr
operator|->
name|sh_entsize
operator|=
name|ihdr
operator|->
name|sh_entsize
expr_stmt|;
if|if
condition|(
name|ihdr
operator|->
name|sh_type
operator|==
name|SHT_SYMTAB
operator|||
name|ihdr
operator|->
name|sh_type
operator|==
name|SHT_DYNSYM
operator|||
name|ihdr
operator|->
name|sh_type
operator|==
name|SHT_GNU_verneed
operator|||
name|ihdr
operator|->
name|sh_type
operator|==
name|SHT_GNU_verdef
condition|)
name|ohdr
operator|->
name|sh_info
operator|=
name|ihdr
operator|->
name|sh_info
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Copy private symbol information.  If this symbol is in a section    which we did not map into a BFD section, try to map the section    index correctly.  We use special macro definitions for the mapped    section indices; these definitions are interpreted by the    swap_out_syms function.  */
end_comment

begin_define
define|#
directive|define
name|MAP_ONESYMTAB
value|(SHN_LORESERVE - 1)
end_define

begin_define
define|#
directive|define
name|MAP_DYNSYMTAB
value|(SHN_LORESERVE - 2)
end_define

begin_define
define|#
directive|define
name|MAP_STRTAB
value|(SHN_LORESERVE - 3)
end_define

begin_define
define|#
directive|define
name|MAP_SHSTRTAB
value|(SHN_LORESERVE - 4)
end_define

begin_function
name|boolean
name|_bfd_elf_copy_private_symbol_data
parameter_list|(
name|ibfd
parameter_list|,
name|isymarg
parameter_list|,
name|obfd
parameter_list|,
name|osymarg
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|asymbol
modifier|*
name|isymarg
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|asymbol
modifier|*
name|osymarg
decl_stmt|;
block|{
name|elf_symbol_type
modifier|*
name|isym
decl_stmt|,
modifier|*
name|osym
decl_stmt|;
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|ibfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
operator|||
name|bfd_get_flavour
argument_list|(
name|obfd
argument_list|)
operator|!=
name|bfd_target_elf_flavour
condition|)
return|return
name|true
return|;
name|isym
operator|=
name|elf_symbol_from
argument_list|(
name|ibfd
argument_list|,
name|isymarg
argument_list|)
expr_stmt|;
name|osym
operator|=
name|elf_symbol_from
argument_list|(
name|obfd
argument_list|,
name|osymarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|!=
name|NULL
operator|&&
name|osym
operator|!=
name|NULL
operator|&&
name|bfd_is_abs_section
argument_list|(
name|isym
operator|->
name|symbol
operator|.
name|section
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|shndx
decl_stmt|;
name|shndx
operator|=
name|isym
operator|->
name|internal_elf_sym
operator|.
name|st_shndx
expr_stmt|;
if|if
condition|(
name|shndx
operator|==
name|elf_onesymtab
argument_list|(
name|ibfd
argument_list|)
condition|)
name|shndx
operator|=
name|MAP_ONESYMTAB
expr_stmt|;
elseif|else
if|if
condition|(
name|shndx
operator|==
name|elf_dynsymtab
argument_list|(
name|ibfd
argument_list|)
condition|)
name|shndx
operator|=
name|MAP_DYNSYMTAB
expr_stmt|;
elseif|else
if|if
condition|(
name|shndx
operator|==
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|strtab_section
condition|)
name|shndx
operator|=
name|MAP_STRTAB
expr_stmt|;
elseif|else
if|if
condition|(
name|shndx
operator|==
name|elf_tdata
argument_list|(
name|ibfd
argument_list|)
operator|->
name|shstrtab_section
condition|)
name|shndx
operator|=
name|MAP_SHSTRTAB
expr_stmt|;
name|osym
operator|->
name|internal_elf_sym
operator|.
name|st_shndx
operator|=
name|shndx
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Swap out the symbols.  */
end_comment

begin_function
specifier|static
name|boolean
name|swap_out_syms
parameter_list|(
name|abfd
parameter_list|,
name|sttp
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|struct
name|bfd_strtab_hash
modifier|*
modifier|*
name|sttp
decl_stmt|;
block|{
name|struct
name|elf_backend_data
modifier|*
name|bed
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|elf_map_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Dump out the symtabs. */
block|{
name|int
name|symcount
init|=
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|syms
init|=
name|bfd_get_outsymbols
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
name|struct
name|bfd_strtab_hash
modifier|*
name|stt
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symtab_hdr
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|symstrtab_hdr
decl_stmt|;
name|char
modifier|*
name|outbound_syms
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|stt
operator|=
name|_bfd_elf_stringtab_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|stt
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|symtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_type
operator|=
name|SHT_SYMTAB
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_entsize
operator|=
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_size
operator|=
name|symtab_hdr
operator|->
name|sh_entsize
operator|*
operator|(
name|symcount
operator|+
literal|1
operator|)
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_info
operator|=
name|elf_num_locals
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
expr_stmt|;
name|symtab_hdr
operator|->
name|sh_addralign
operator|=
name|bed
operator|->
name|s
operator|->
name|file_align
expr_stmt|;
name|symstrtab_hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|strtab_hdr
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_type
operator|=
name|SHT_STRTAB
expr_stmt|;
name|outbound_syms
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
literal|1
operator|+
name|symcount
operator|)
operator|*
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|outbound_syms
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|symtab_hdr
operator|->
name|contents
operator|=
operator|(
name|PTR
operator|)
name|outbound_syms
expr_stmt|;
comment|/* now generate the data (for "contents") */
block|{
comment|/* Fill in zeroth symbol and swap it out.  */
name|Elf_Internal_Sym
name|sym
decl_stmt|;
name|sym
operator|.
name|st_name
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_value
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_info
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|SHN_UNDEF
expr_stmt|;
name|bed
operator|->
name|s
operator|->
name|swap_symbol_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|,
operator|(
name|PTR
operator|)
name|outbound_syms
argument_list|)
expr_stmt|;
name|outbound_syms
operator|+=
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
block|}
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|symcount
condition|;
name|idx
operator|++
control|)
block|{
name|Elf_Internal_Sym
name|sym
decl_stmt|;
name|bfd_vma
name|value
init|=
name|syms
index|[
name|idx
index|]
operator|->
name|value
decl_stmt|;
name|elf_symbol_type
modifier|*
name|type_ptr
decl_stmt|;
name|flagword
name|flags
init|=
name|syms
index|[
name|idx
index|]
operator|->
name|flags
decl_stmt|;
name|int
name|type
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|BSF_SECTION_SYM
condition|)
comment|/* Section symbols have no names.  */
name|sym
operator|.
name|st_name
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|sym
operator|.
name|st_name
operator|=
operator|(
name|unsigned
name|long
operator|)
name|_bfd_stringtab_add
argument_list|(
name|stt
argument_list|,
name|syms
index|[
name|idx
index|]
operator|->
name|name
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|st_name
operator|==
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
return|return
name|false
return|;
block|}
name|type_ptr
operator|=
name|elf_symbol_from
argument_list|(
name|abfd
argument_list|,
name|syms
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|syms
index|[
name|idx
index|]
operator|->
name|section
argument_list|)
condition|)
block|{
comment|/* ELF common symbols put the alignment into the `value' field, 	       and the size into the `size' field.  This is backwards from 	       how BFD handles it, so reverse it here.  */
name|sym
operator|.
name|st_size
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|type_ptr
operator|==
name|NULL
operator|||
name|type_ptr
operator|->
name|internal_elf_sym
operator|.
name|st_value
operator|==
literal|0
condition|)
name|sym
operator|.
name|st_value
operator|=
name|value
operator|>=
literal|16
condition|?
literal|16
else|:
operator|(
literal|1
operator|<<
name|bfd_log2
argument_list|(
name|value
argument_list|)
operator|)
expr_stmt|;
else|else
name|sym
operator|.
name|st_value
operator|=
name|type_ptr
operator|->
name|internal_elf_sym
operator|.
name|st_value
expr_stmt|;
name|sym
operator|.
name|st_shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|syms
index|[
name|idx
index|]
operator|->
name|section
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|asection
modifier|*
name|sec
init|=
name|syms
index|[
name|idx
index|]
operator|->
name|section
decl_stmt|;
name|int
name|shndx
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|output_section
condition|)
block|{
name|value
operator|+=
name|sec
operator|->
name|output_offset
expr_stmt|;
name|sec
operator|=
name|sec
operator|->
name|output_section
expr_stmt|;
block|}
name|value
operator|+=
name|sec
operator|->
name|vma
expr_stmt|;
name|sym
operator|.
name|st_value
operator|=
name|value
expr_stmt|;
name|sym
operator|.
name|st_size
operator|=
name|type_ptr
condition|?
name|type_ptr
operator|->
name|internal_elf_sym
operator|.
name|st_size
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|bfd_is_abs_section
argument_list|(
name|sec
argument_list|)
operator|&&
name|type_ptr
operator|!=
name|NULL
operator|&&
name|type_ptr
operator|->
name|internal_elf_sym
operator|.
name|st_shndx
operator|!=
literal|0
condition|)
block|{
comment|/* This symbol is in a real ELF section which we did                    not create as a BFD section.  Undo the mapping done                    by copy_private_symbol_data.  */
name|shndx
operator|=
name|type_ptr
operator|->
name|internal_elf_sym
operator|.
name|st_shndx
expr_stmt|;
switch|switch
condition|(
name|shndx
condition|)
block|{
case|case
name|MAP_ONESYMTAB
case|:
name|shndx
operator|=
name|elf_onesymtab
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
break|break;
case|case
name|MAP_DYNSYMTAB
case|:
name|shndx
operator|=
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
break|break;
case|case
name|MAP_STRTAB
case|:
name|shndx
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|strtab_section
expr_stmt|;
break|break;
case|case
name|MAP_SHSTRTAB
case|:
name|shndx
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|shstrtab_section
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
else|else
block|{
name|shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|shndx
operator|==
operator|-
literal|1
condition|)
block|{
name|asection
modifier|*
name|sec2
decl_stmt|;
comment|/* Writing this would be a hell of a lot easier if 		       we had some decent documentation on bfd, and 		       knew what to expect of the library, and what to 		       demand of applications.  For example, it 		       appears that `objcopy' might not set the 		       section of a symbol to be a section that is 		       actually in the output file.  */
name|sec2
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|sec
operator|->
name|name
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|sec2
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|shndx
operator|=
name|_bfd_elf_section_from_bfd_section
argument_list|(
name|abfd
argument_list|,
name|sec2
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|shndx
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|sym
operator|.
name|st_shndx
operator|=
name|shndx
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|BSF_FUNCTION
operator|)
operator|!=
literal|0
condition|)
name|type
operator|=
name|STT_FUNC
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|BSF_OBJECT
operator|)
operator|!=
literal|0
condition|)
name|type
operator|=
name|STT_OBJECT
expr_stmt|;
else|else
name|type
operator|=
name|STT_NOTYPE
expr_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|syms
index|[
name|idx
index|]
operator|->
name|section
argument_list|)
condition|)
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_GLOBAL
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|syms
index|[
name|idx
index|]
operator|->
name|section
argument_list|)
condition|)
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
operator|(
operator|(
name|flags
operator|&
name|BSF_WEAK
operator|)
condition|?
name|STB_WEAK
else|:
name|STB_GLOBAL
operator|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|BSF_SECTION_SYM
condition|)
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_SECTION
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|BSF_FILE
condition|)
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|STT_FILE
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|bind
init|=
name|STB_LOCAL
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|BSF_LOCAL
condition|)
name|bind
operator|=
name|STB_LOCAL
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|BSF_WEAK
condition|)
name|bind
operator|=
name|STB_WEAK
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|BSF_GLOBAL
condition|)
name|bind
operator|=
name|STB_GLOBAL
expr_stmt|;
name|sym
operator|.
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|bind
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type_ptr
operator|!=
name|NULL
condition|)
name|sym
operator|.
name|st_other
operator|=
name|type_ptr
operator|->
name|internal_elf_sym
operator|.
name|st_other
expr_stmt|;
else|else
name|sym
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
name|bed
operator|->
name|s
operator|->
name|swap_symbol_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|sym
argument_list|,
operator|(
name|PTR
operator|)
name|outbound_syms
argument_list|)
expr_stmt|;
name|outbound_syms
operator|+=
name|bed
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
block|}
operator|*
name|sttp
operator|=
name|stt
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_size
operator|=
name|_bfd_stringtab_size
argument_list|(
name|stt
argument_list|)
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_type
operator|=
name|SHT_STRTAB
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_flags
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_addr
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_entsize
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_link
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_info
operator|=
literal|0
expr_stmt|;
name|symstrtab_hdr
operator|->
name|sh_addralign
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return the number of bytes required to hold the symtab vector.     Note that we base it on the count plus 1, since we will null terminate    the vector allocated based on this size.  However, the ELF symbol table    always has a dummy entry as symbol #0, so it ends up even.  */
end_comment

begin_function
name|long
name|_bfd_elf_get_symtab_upper_bound
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|long
name|symcount
decl_stmt|;
name|long
name|symtab_size
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
init|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|symtab_hdr
decl_stmt|;
name|symcount
operator|=
name|hdr
operator|->
name|sh_size
operator|/
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
name|symtab_size
operator|=
operator|(
name|symcount
operator|-
literal|1
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
operator|)
expr_stmt|;
return|return
name|symtab_size
return|;
block|}
end_function

begin_function
name|long
name|_bfd_elf_get_dynamic_symtab_upper_bound
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|long
name|symcount
decl_stmt|;
name|long
name|symtab_size
decl_stmt|;
name|Elf_Internal_Shdr
modifier|*
name|hdr
init|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynsymtab_hdr
decl_stmt|;
if|if
condition|(
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|symcount
operator|=
name|hdr
operator|->
name|sh_size
operator|/
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|sizeof_sym
expr_stmt|;
name|symtab_size
operator|=
operator|(
name|symcount
operator|-
literal|1
operator|+
literal|1
operator|)
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|asymbol
operator|*
argument_list|)
operator|)
expr_stmt|;
return|return
name|symtab_size
return|;
block|}
end_function

begin_function
name|long
name|_bfd_elf_get_reloc_upper_bound
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|asect
decl_stmt|;
block|{
return|return
operator|(
name|asect
operator|->
name|reloc_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Canonicalize the relocs.  */
end_comment

begin_function
name|long
name|_bfd_elf_canonicalize_reloc
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|relptr
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|relptr
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
name|arelent
modifier|*
name|tblptr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|slurp_reloc_table
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|symbols
argument_list|,
name|false
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|tblptr
operator|=
name|section
operator|->
name|relocation
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|section
operator|->
name|reloc_count
condition|;
name|i
operator|++
control|)
operator|*
name|relptr
operator|++
operator|=
name|tblptr
operator|++
expr_stmt|;
operator|*
name|relptr
operator|=
name|NULL
expr_stmt|;
return|return
name|section
operator|->
name|reloc_count
return|;
block|}
end_function

begin_function
name|long
name|_bfd_elf_get_symtab
parameter_list|(
name|abfd
parameter_list|,
name|alocation
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|alocation
decl_stmt|;
block|{
name|long
name|symcount
init|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|slurp_symbol_table
argument_list|(
name|abfd
argument_list|,
name|alocation
argument_list|,
name|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|symcount
operator|>=
literal|0
condition|)
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|=
name|symcount
expr_stmt|;
return|return
name|symcount
return|;
block|}
end_function

begin_function
name|long
name|_bfd_elf_canonicalize_dynamic_symtab
parameter_list|(
name|abfd
parameter_list|,
name|alocation
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|alocation
decl_stmt|;
block|{
return|return
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|slurp_symbol_table
argument_list|(
name|abfd
argument_list|,
name|alocation
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the size required for the dynamic reloc entries.  Any    section that was actually installed in the BFD, and has type    SHT_REL or SHT_RELA, and uses the dynamic symbol table, is    considered to be a dynamic reloc section.  */
end_comment

begin_function
name|long
name|_bfd_elf_get_dynamic_reloc_upper_bound
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|long
name|ret
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ret
operator|=
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_link
operator|==
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|==
name|SHT_REL
operator|||
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|==
name|SHT_RELA
operator|)
condition|)
name|ret
operator|+=
operator|(
operator|(
name|s
operator|->
name|_raw_size
operator|/
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|arelent
operator|*
argument_list|)
operator|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Canonicalize the dynamic relocation entries.  Note that we return    the dynamic relocations as a single block, although they are    actually associated with particular sections; the interface, which    was designed for SunOS style shared libraries, expects that there    is only one set of dynamic relocs.  Any section that was actually    installed in the BFD, and has type SHT_REL or SHT_RELA, and uses    the dynamic symbol table, is considered to be a dynamic reloc    section.  */
end_comment

begin_function
name|long
name|_bfd_elf_canonicalize_dynamic_reloc
parameter_list|(
name|abfd
parameter_list|,
name|storage
parameter_list|,
name|syms
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|storage
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|syms
decl_stmt|;
block|{
name|boolean
argument_list|(
argument|*slurp_relocs
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|asymbol
operator|*
operator|*
operator|,
name|boolean
operator|)
argument_list|)
expr_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|long
name|ret
decl_stmt|;
if|if
condition|(
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|slurp_relocs
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|slurp_reloc_table
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_link
operator|==
name|elf_dynsymtab
argument_list|(
name|abfd
argument_list|)
operator|&&
operator|(
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|==
name|SHT_REL
operator|||
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_type
operator|==
name|SHT_RELA
operator|)
condition|)
block|{
name|arelent
modifier|*
name|p
decl_stmt|;
name|long
name|count
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|slurp_relocs
call|)
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|syms
argument_list|,
name|true
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|count
operator|=
name|s
operator|->
name|_raw_size
operator|/
name|elf_section_data
argument_list|(
name|s
argument_list|)
operator|->
name|this_hdr
operator|.
name|sh_entsize
expr_stmt|;
name|p
operator|=
name|s
operator|->
name|relocation
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
operator|*
name|storage
operator|++
operator|=
name|p
operator|++
expr_stmt|;
name|ret
operator|+=
name|count
expr_stmt|;
block|}
block|}
operator|*
name|storage
operator|=
name|NULL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read in the version information.  */
end_comment

begin_function
name|boolean
name|_bfd_elf_slurp_version_tables
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|elf_dynverdef
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|Elf_External_Verdef
modifier|*
name|everdef
decl_stmt|;
name|Elf_Internal_Verdef
modifier|*
name|iverdef
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynverdef_hdr
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verdef
operator|=
operator|(
operator|(
name|Elf_Internal_Verdef
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_info
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Verdef
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verdef
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cverdefs
operator|=
name|hdr
operator|->
name|sh_info
expr_stmt|;
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|contents
argument_list|,
literal|1
argument_list|,
name|hdr
operator|->
name|sh_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|hdr
operator|->
name|sh_size
condition|)
goto|goto
name|error_return
goto|;
name|everdef
operator|=
operator|(
name|Elf_External_Verdef
operator|*
operator|)
name|contents
expr_stmt|;
name|iverdef
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verdef
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|->
name|sh_info
condition|;
name|i
operator|++
operator|,
name|iverdef
operator|++
control|)
block|{
name|Elf_External_Verdaux
modifier|*
name|everdaux
decl_stmt|;
name|Elf_Internal_Verdaux
modifier|*
name|iverdaux
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|_bfd_elf_swap_verdef_in
argument_list|(
name|abfd
argument_list|,
name|everdef
argument_list|,
name|iverdef
argument_list|)
expr_stmt|;
name|iverdef
operator|->
name|vd_bfd
operator|=
name|abfd
expr_stmt|;
name|iverdef
operator|->
name|vd_auxptr
operator|=
operator|(
operator|(
name|Elf_Internal_Verdaux
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
operator|(
name|iverdef
operator|->
name|vd_cnt
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Verdaux
argument_list|)
operator|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|iverdef
operator|->
name|vd_auxptr
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|everdaux
operator|=
operator|(
operator|(
name|Elf_External_Verdaux
operator|*
operator|)
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|everdef
operator|+
name|iverdef
operator|->
name|vd_aux
operator|)
operator|)
expr_stmt|;
name|iverdaux
operator|=
name|iverdef
operator|->
name|vd_auxptr
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|iverdef
operator|->
name|vd_cnt
condition|;
name|j
operator|++
operator|,
name|iverdaux
operator|++
control|)
block|{
name|_bfd_elf_swap_verdaux_in
argument_list|(
name|abfd
argument_list|,
name|everdaux
argument_list|,
name|iverdaux
argument_list|)
expr_stmt|;
name|iverdaux
operator|->
name|vda_nodename
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_link
argument_list|,
name|iverdaux
operator|->
name|vda_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|iverdaux
operator|->
name|vda_nodename
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|j
operator|+
literal|1
operator|<
name|iverdef
operator|->
name|vd_cnt
condition|)
name|iverdaux
operator|->
name|vda_nextptr
operator|=
name|iverdaux
operator|+
literal|1
expr_stmt|;
else|else
name|iverdaux
operator|->
name|vda_nextptr
operator|=
name|NULL
expr_stmt|;
name|everdaux
operator|=
operator|(
operator|(
name|Elf_External_Verdaux
operator|*
operator|)
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|everdaux
operator|+
name|iverdaux
operator|->
name|vda_next
operator|)
operator|)
expr_stmt|;
block|}
name|iverdef
operator|->
name|vd_nodename
operator|=
name|iverdef
operator|->
name|vd_auxptr
operator|->
name|vda_nodename
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|hdr
operator|->
name|sh_info
condition|)
name|iverdef
operator|->
name|vd_nextdef
operator|=
name|iverdef
operator|+
literal|1
expr_stmt|;
else|else
name|iverdef
operator|->
name|vd_nextdef
operator|=
name|NULL
expr_stmt|;
name|everdef
operator|=
operator|(
operator|(
name|Elf_External_Verdef
operator|*
operator|)
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|everdef
operator|+
name|iverdef
operator|->
name|vd_next
operator|)
operator|)
expr_stmt|;
block|}
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
name|contents
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|elf_dynverref
argument_list|(
name|abfd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
name|Elf_External_Verneed
modifier|*
name|everneed
decl_stmt|;
name|Elf_Internal_Verneed
modifier|*
name|iverneed
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|hdr
operator|=
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|dynverref_hdr
expr_stmt|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verref
operator|=
operator|(
operator|(
name|Elf_Internal_Verneed
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_info
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Verneed
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verref
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|cverrefs
operator|=
name|hdr
operator|->
name|sh_info
expr_stmt|;
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|hdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|||
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|contents
argument_list|,
literal|1
argument_list|,
name|hdr
operator|->
name|sh_size
argument_list|,
name|abfd
argument_list|)
operator|!=
name|hdr
operator|->
name|sh_size
condition|)
goto|goto
name|error_return
goto|;
name|everneed
operator|=
operator|(
name|Elf_External_Verneed
operator|*
operator|)
name|contents
expr_stmt|;
name|iverneed
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|verref
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|->
name|sh_info
condition|;
name|i
operator|++
operator|,
name|iverneed
operator|++
control|)
block|{
name|Elf_External_Vernaux
modifier|*
name|evernaux
decl_stmt|;
name|Elf_Internal_Vernaux
modifier|*
name|ivernaux
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|_bfd_elf_swap_verneed_in
argument_list|(
name|abfd
argument_list|,
name|everneed
argument_list|,
name|iverneed
argument_list|)
expr_stmt|;
name|iverneed
operator|->
name|vn_bfd
operator|=
name|abfd
expr_stmt|;
name|iverneed
operator|->
name|vn_filename
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_link
argument_list|,
name|iverneed
operator|->
name|vn_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|iverneed
operator|->
name|vn_filename
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|iverneed
operator|->
name|vn_auxptr
operator|=
operator|(
operator|(
name|Elf_Internal_Vernaux
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|iverneed
operator|->
name|vn_cnt
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Internal_Vernaux
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|evernaux
operator|=
operator|(
operator|(
name|Elf_External_Vernaux
operator|*
operator|)
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|everneed
operator|+
name|iverneed
operator|->
name|vn_aux
operator|)
operator|)
expr_stmt|;
name|ivernaux
operator|=
name|iverneed
operator|->
name|vn_auxptr
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|iverneed
operator|->
name|vn_cnt
condition|;
name|j
operator|++
operator|,
name|ivernaux
operator|++
control|)
block|{
name|_bfd_elf_swap_vernaux_in
argument_list|(
name|abfd
argument_list|,
name|evernaux
argument_list|,
name|ivernaux
argument_list|)
expr_stmt|;
name|ivernaux
operator|->
name|vna_nodename
operator|=
name|bfd_elf_string_from_elf_section
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_link
argument_list|,
name|ivernaux
operator|->
name|vna_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivernaux
operator|->
name|vna_nodename
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|j
operator|+
literal|1
operator|<
name|iverneed
operator|->
name|vn_cnt
condition|)
name|ivernaux
operator|->
name|vna_nextptr
operator|=
name|ivernaux
operator|+
literal|1
expr_stmt|;
else|else
name|ivernaux
operator|->
name|vna_nextptr
operator|=
name|NULL
expr_stmt|;
name|evernaux
operator|=
operator|(
operator|(
name|Elf_External_Vernaux
operator|*
operator|)
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|evernaux
operator|+
name|ivernaux
operator|->
name|vna_next
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|hdr
operator|->
name|sh_info
condition|)
name|iverneed
operator|->
name|vn_nextref
operator|=
name|iverneed
operator|+
literal|1
expr_stmt|;
else|else
name|iverneed
operator|->
name|vn_nextref
operator|=
name|NULL
expr_stmt|;
name|everneed
operator|=
operator|(
operator|(
name|Elf_External_Verneed
operator|*
operator|)
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|everneed
operator|+
name|iverneed
operator|->
name|vn_next
operator|)
operator|)
expr_stmt|;
block|}
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
name|contents
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|asymbol
modifier|*
name|_bfd_elf_make_empty_symbol
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|elf_symbol_type
modifier|*
name|newsym
decl_stmt|;
name|newsym
operator|=
operator|(
name|elf_symbol_type
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|elf_symbol_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newsym
condition|)
return|return
name|NULL
return|;
else|else
block|{
name|newsym
operator|->
name|symbol
operator|.
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
operator|&
name|newsym
operator|->
name|symbol
return|;
block|}
block|}
end_function

begin_function
name|void
name|_bfd_elf_get_symbol_info
parameter_list|(
name|ignore_abfd
parameter_list|,
name|symbol
parameter_list|,
name|ret
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
name|symbol_info
modifier|*
name|ret
decl_stmt|;
block|{
name|bfd_symbol_info
argument_list|(
name|symbol
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return whether a symbol name implies a local symbol.  Most targets    use this function for the is_local_label_name entry point, but some    override it.  */
end_comment

begin_function
name|boolean
name|_bfd_elf_is_local_label_name
parameter_list|(
name|abfd
parameter_list|,
name|name
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
comment|/* Normal local symbols start with ``.L''.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'L'
condition|)
return|return
name|true
return|;
comment|/* At least some SVR4 compilers (e.g., UnixWare 2.1 cc) generate      DWARF debugging symbols starting with ``..''.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
return|return
name|true
return|;
comment|/* gcc will sometimes generate symbols beginning with ``_.L_'' when      emitting DWARF debugging output.  I suspect this is actually a      small bug in gcc (it calls ASM_OUTPUT_LABEL when it should call      ASM_GENERATE_INTERNAL_LABEL, and this causes the leading      underscore to be emitted on some ELF targets).  For ease of use,      we treat such symbols as local.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'L'
operator|&&
name|name
index|[
literal|3
index|]
operator|==
literal|'_'
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_function
name|alent
modifier|*
name|_bfd_elf_get_lineno
parameter_list|(
name|ignore_abfd
parameter_list|,
name|symbol
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|asymbol
modifier|*
name|symbol
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|boolean
name|_bfd_elf_set_arch_mach
parameter_list|(
name|abfd
parameter_list|,
name|arch
parameter_list|,
name|machine
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
name|unsigned
name|long
name|machine
decl_stmt|;
block|{
comment|/* If this isn't the right architecture for this backend, and this      isn't the generic backend, fail.  */
if|if
condition|(
name|arch
operator|!=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|arch
operator|&&
name|arch
operator|!=
name|bfd_arch_unknown
operator|&&
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|arch
operator|!=
name|bfd_arch_unknown
condition|)
return|return
name|false
return|;
return|return
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|machine
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find the nearest line to a particular section and offset, for error    reporting.  */
end_comment

begin_function
name|boolean
name|_bfd_elf_find_nearest_line
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|symbols
parameter_list|,
name|offset
parameter_list|,
name|filename_ptr
parameter_list|,
name|functionname_ptr
parameter_list|,
name|line_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
name|bfd_vma
name|offset
decl_stmt|;
name|CONST
name|char
modifier|*
modifier|*
name|filename_ptr
decl_stmt|;
name|CONST
name|char
modifier|*
modifier|*
name|functionname_ptr
decl_stmt|;
name|unsigned
name|int
modifier|*
name|line_ptr
decl_stmt|;
block|{
name|boolean
name|found
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|asymbol
modifier|*
name|func
decl_stmt|;
name|bfd_vma
name|low_func
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_stab_section_find_nearest_line
argument_list|(
name|abfd
argument_list|,
name|symbols
argument_list|,
name|section
argument_list|,
name|offset
argument_list|,
operator|&
name|found
argument_list|,
name|filename_ptr
argument_list|,
name|functionname_ptr
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|line_info
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|found
condition|)
return|return
name|true
return|;
if|if
condition|(
name|symbols
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|filename
operator|=
name|NULL
expr_stmt|;
name|func
operator|=
name|NULL
expr_stmt|;
name|low_func
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|symbols
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
block|{
name|elf_symbol_type
modifier|*
name|q
decl_stmt|;
name|q
operator|=
operator|(
name|elf_symbol_type
operator|*
operator|)
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|bfd_get_section
argument_list|(
operator|&
name|q
operator|->
name|symbol
argument_list|)
operator|!=
name|section
condition|)
continue|continue;
switch|switch
condition|(
name|ELF_ST_TYPE
argument_list|(
name|q
operator|->
name|internal_elf_sym
operator|.
name|st_info
argument_list|)
condition|)
block|{
default|default:
break|break;
case|case
name|STT_FILE
case|:
name|filename
operator|=
name|bfd_asymbol_name
argument_list|(
operator|&
name|q
operator|->
name|symbol
argument_list|)
expr_stmt|;
break|break;
case|case
name|STT_FUNC
case|:
if|if
condition|(
name|q
operator|->
name|symbol
operator|.
name|section
operator|==
name|section
operator|&&
name|q
operator|->
name|symbol
operator|.
name|value
operator|>=
name|low_func
operator|&&
name|q
operator|->
name|symbol
operator|.
name|value
operator|<=
name|offset
condition|)
block|{
name|func
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|q
expr_stmt|;
name|low_func
operator|=
name|q
operator|->
name|symbol
operator|.
name|value
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
return|return
name|false
return|;
operator|*
name|filename_ptr
operator|=
name|filename
expr_stmt|;
operator|*
name|functionname_ptr
operator|=
name|bfd_asymbol_name
argument_list|(
name|func
argument_list|)
expr_stmt|;
operator|*
name|line_ptr
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|int
name|_bfd_elf_sizeof_headers
parameter_list|(
name|abfd
parameter_list|,
name|reloc
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|boolean
name|reloc
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|sizeof_ehdr
expr_stmt|;
if|if
condition|(
operator|!
name|reloc
condition|)
name|ret
operator|+=
name|get_program_header_size
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|boolean
name|_bfd_elf_set_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|sec_ptr
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
name|Elf_Internal_Shdr
modifier|*
name|hdr
decl_stmt|;
if|if
condition|(
operator|!
name|abfd
operator|->
name|output_has_begun
operator|&&
operator|!
name|_bfd_elf_compute_section_file_positions
argument_list|(
name|abfd
argument_list|,
operator|(
expr|struct
name|bfd_link_info
operator|*
operator|)
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
name|hdr
operator|=
operator|&
name|elf_section_data
argument_list|(
name|section
argument_list|)
operator|->
name|this_hdr
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|hdr
operator|->
name|sh_offset
operator|+
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|false
return|;
if|if
condition|(
name|bfd_write
argument_list|(
name|location
argument_list|,
literal|1
argument_list|,
name|count
argument_list|,
name|abfd
argument_list|)
operator|!=
name|count
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|void
name|_bfd_elf_no_info_to_howto
parameter_list|(
name|abfd
parameter_list|,
name|cache_ptr
parameter_list|,
name|dst
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|cache_ptr
decl_stmt|;
name|Elf_Internal_Rela
modifier|*
name|dst
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|void _bfd_elf_no_info_to_howto_rel (abfd, cache_ptr, dst)      bfd *abfd;      arelent *cache_ptr;      Elf_Internal_Rel *dst; {   abort (); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Try to convert a non-ELF reloc into an ELF one.  */
end_comment

begin_function
name|boolean
name|_bfd_elf_validate_reloc
parameter_list|(
name|abfd
parameter_list|,
name|areloc
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|areloc
decl_stmt|;
block|{
comment|/* Check whether we really have an ELF howto. */
if|if
condition|(
operator|(
operator|*
name|areloc
operator|->
name|sym_ptr_ptr
operator|)
operator|->
name|the_bfd
operator|->
name|xvec
operator|!=
name|abfd
operator|->
name|xvec
condition|)
block|{
name|bfd_reloc_code_real_type
name|code
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
comment|/* Alien reloc: Try to determine its type to replace it with an 	 equivalent ELF reloc. */
if|if
condition|(
name|areloc
operator|->
name|howto
operator|->
name|pc_relative
condition|)
block|{
switch|switch
condition|(
name|areloc
operator|->
name|howto
operator|->
name|bitsize
condition|)
block|{
case|case
literal|8
case|:
name|code
operator|=
name|BFD_RELOC_8_PCREL
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|code
operator|=
name|BFD_RELOC_12_PCREL
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|code
operator|=
name|BFD_RELOC_16_PCREL
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|code
operator|=
name|BFD_RELOC_24_PCREL
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|code
operator|=
name|BFD_RELOC_32_PCREL
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|code
operator|=
name|BFD_RELOC_64_PCREL
expr_stmt|;
break|break;
default|default:
goto|goto
name|fail
goto|;
block|}
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|areloc
operator|->
name|howto
operator|->
name|pcrel_offset
operator|!=
name|howto
operator|->
name|pcrel_offset
condition|)
block|{
if|if
condition|(
name|howto
operator|->
name|pcrel_offset
condition|)
name|areloc
operator|->
name|addend
operator|+=
name|areloc
operator|->
name|address
expr_stmt|;
else|else
name|areloc
operator|->
name|addend
operator|-=
name|areloc
operator|->
name|address
expr_stmt|;
comment|/* addend is unsigned!! */
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|areloc
operator|->
name|howto
operator|->
name|bitsize
condition|)
block|{
case|case
literal|8
case|:
name|code
operator|=
name|BFD_RELOC_8
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|code
operator|=
name|BFD_RELOC_14
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|code
operator|=
name|BFD_RELOC_16
expr_stmt|;
break|break;
case|case
literal|26
case|:
name|code
operator|=
name|BFD_RELOC_26
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|code
operator|=
name|BFD_RELOC_32
expr_stmt|;
break|break;
case|case
literal|64
case|:
name|code
operator|=
name|BFD_RELOC_64
expr_stmt|;
break|break;
default|default:
goto|goto
name|fail
goto|;
block|}
name|howto
operator|=
name|bfd_reloc_type_lookup
argument_list|(
name|abfd
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|howto
condition|)
name|areloc
operator|->
name|howto
operator|=
name|howto
expr_stmt|;
else|else
goto|goto
name|fail
goto|;
block|}
return|return
name|true
return|;
name|fail
label|:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: unsupported relocation type %s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|areloc
operator|->
name|howto
operator|->
name|name
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

end_unit

