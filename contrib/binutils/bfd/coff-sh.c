begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for Hitachi Super-H COFF binaries.    Copyright 1993, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.    Contributed by Cygnus Support.    Written by Steve Chamberlain,<sac@cygnus.com>.    Relaxing code written by Ian Lance Taylor,<ian@cygnus.com>.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"coff/sh.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_comment
comment|/* Internal functions.  */
end_comment

begin_decl_stmt
specifier|static
name|bfd_reloc_status_type
name|sh_reloc
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|arelent
operator|*
operator|,
name|asymbol
operator|*
operator|,
name|PTR
operator|,
name|asection
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|get_symbol_value
name|PARAMS
argument_list|(
operator|(
name|asymbol
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_merge_private_data
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_relax_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_relax_delete_bytes
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_vma
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_opcode
modifier|*
name|sh_insn_info
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_align_loads
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
expr|struct
name|internal_reloc
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_swap_insns
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_relocate_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
expr|struct
name|internal_reloc
operator|*
operator|,
expr|struct
name|internal_syment
operator|*
operator|,
name|asection
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bfd_byte
modifier|*
name|sh_coff_get_relocated_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|struct
name|bfd_link_info
operator|*
operator|,
expr|struct
name|bfd_link_order
operator|*
operator|,
name|bfd_byte
operator|*
operator|,
name|boolean
operator|,
name|asymbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default section alignment to 2**4.  */
end_comment

begin_define
define|#
directive|define
name|COFF_DEFAULT_SECTION_ALIGNMENT_POWER
value|(4)
end_define

begin_comment
comment|/* Generate long file names.  */
end_comment

begin_define
define|#
directive|define
name|COFF_LONG_FILENAMES
end_define

begin_comment
comment|/* The supported relocations.  There are a lot of relocations defined    in coff/internal.h which we do not expect to ever see.  */
end_comment

begin_decl_stmt
specifier|static
name|reloc_howto_type
name|sh_coff_howtos
index|[]
init|=
block|{
block|{
literal|0
block|}
block|,
block|{
literal|1
block|}
block|,
block|{
literal|2
block|}
block|,
block|{
literal|3
block|}
block|,
comment|/* R_SH_PCREL8 */
block|{
literal|4
block|}
block|,
comment|/* R_SH_PCREL16 */
block|{
literal|5
block|}
block|,
comment|/* R_SH_HIGH8 */
block|{
literal|6
block|}
block|,
comment|/* R_SH_IMM24 */
block|{
literal|7
block|}
block|,
comment|/* R_SH_LOW16 */
block|{
literal|8
block|}
block|,
block|{
literal|9
block|}
block|,
comment|/* R_SH_PCDISP8BY4 */
name|HOWTO
argument_list|(
name|R_SH_PCDISP8BY2
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|sh_reloc
argument_list|,
comment|/* special_function */
literal|"r_pcdisp8by2"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xff
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
block|{
literal|11
block|}
block|,
comment|/* R_SH_PCDISP8 */
name|HOWTO
argument_list|(
name|R_SH_PCDISP
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|12
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_signed
argument_list|,
comment|/* complain_on_overflow */
name|sh_reloc
argument_list|,
comment|/* special_function */
literal|"r_pcdisp12by2"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xfff
argument_list|,
comment|/* src_mask */
literal|0xfff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
block|{
literal|13
block|}
block|,
name|HOWTO
argument_list|(
name|R_SH_IMM32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|sh_reloc
argument_list|,
comment|/* special_function */
literal|"r_imm32"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
block|{
literal|15
block|}
block|,
block|{
literal|16
block|}
block|,
comment|/* R_SH_IMM8 */
block|{
literal|17
block|}
block|,
comment|/* R_SH_IMM8BY2 */
block|{
literal|18
block|}
block|,
comment|/* R_SH_IMM8BY4 */
block|{
literal|19
block|}
block|,
comment|/* R_SH_IMM4 */
block|{
literal|20
block|}
block|,
comment|/* R_SH_IMM4BY2 */
block|{
literal|21
block|}
block|,
comment|/* R_SH_IMM4BY4 */
name|HOWTO
argument_list|(
name|R_SH_PCRELIMM8BY2
argument_list|,
comment|/* type */
literal|1
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_reloc
argument_list|,
comment|/* special_function */
literal|"r_pcrelimm8by2"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xff
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_PCRELIMM8BY4
argument_list|,
comment|/* type */
literal|2
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
name|true
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_unsigned
argument_list|,
comment|/* complain_on_overflow */
name|sh_reloc
argument_list|,
comment|/* special_function */
literal|"r_pcrelimm8by4"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xff
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
name|true
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_IMM16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|sh_reloc
argument_list|,
comment|/* special_function */
literal|"r_imm16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_SWITCH16
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|sh_reloc
argument_list|,
comment|/* special_function */
literal|"r_switch16"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_SWITCH32
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|sh_reloc
argument_list|,
comment|/* special_function */
literal|"r_switch32"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_USES
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|1
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|16
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|sh_reloc
argument_list|,
comment|/* special_function */
literal|"r_uses"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffff
argument_list|,
comment|/* src_mask */
literal|0xffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_COUNT
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|sh_reloc
argument_list|,
comment|/* special_function */
literal|"r_count"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_ALIGN
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|sh_reloc
argument_list|,
comment|/* special_function */
literal|"r_align"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_CODE
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|sh_reloc
argument_list|,
comment|/* special_function */
literal|"r_code"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_DATA
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|sh_reloc
argument_list|,
comment|/* special_function */
literal|"r_data"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
name|R_SH_LABEL
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|2
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|32
argument_list|,
comment|/* bitsize */
name|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
name|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
name|sh_reloc
argument_list|,
comment|/* special_function */
literal|"r_label"
argument_list|,
comment|/* name */
name|true
argument_list|,
comment|/* partial_inplace */
literal|0xffffffff
argument_list|,
comment|/* src_mask */
literal|0xffffffff
argument_list|,
comment|/* dst_mask */
name|false
argument_list|)
block|,
comment|/* pcrel_offset */
name|HOWTO
argument_list|(
argument|R_SH_SWITCH8
argument_list|,
comment|/* type */
literal|0
argument_list|,
comment|/* rightshift */
literal|0
argument_list|,
comment|/* size (0 = byte, 1 = short, 2 = long) */
literal|8
argument_list|,
comment|/* bitsize */
argument|false
argument_list|,
comment|/* pc_relative */
literal|0
argument_list|,
comment|/* bitpos */
argument|complain_overflow_bitfield
argument_list|,
comment|/* complain_on_overflow */
argument|sh_reloc
argument_list|,
comment|/* special_function */
literal|"r_switch8"
argument_list|,
comment|/* name */
argument|true
argument_list|,
comment|/* partial_inplace */
literal|0xff
argument_list|,
comment|/* src_mask */
literal|0xff
argument_list|,
comment|/* dst_mask */
argument|false
argument_list|)
comment|/* pcrel_offset */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SH_COFF_HOWTO_COUNT
value|(sizeof sh_coff_howtos / sizeof sh_coff_howtos[0])
end_define

begin_comment
comment|/* Check for a bad magic number.  */
end_comment

begin_define
define|#
directive|define
name|BADMAG
parameter_list|(
name|x
parameter_list|)
value|SHBADMAG(x)
end_define

begin_comment
comment|/* Customize coffcode.h (this is not currently used).  */
end_comment

begin_define
define|#
directive|define
name|SH
value|1
end_define

begin_comment
comment|/* FIXME: This should not be set here.  */
end_comment

begin_define
define|#
directive|define
name|__A_MAGIC_SET__
end_define

begin_comment
comment|/* Swap the r_offset field in and out.  */
end_comment

begin_define
define|#
directive|define
name|SWAP_IN_RELOC_OFFSET
value|bfd_h_get_32
end_define

begin_define
define|#
directive|define
name|SWAP_OUT_RELOC_OFFSET
value|bfd_h_put_32
end_define

begin_comment
comment|/* Swap out extra information in the reloc structure.  */
end_comment

begin_define
define|#
directive|define
name|SWAP_OUT_RELOC_EXTRA
parameter_list|(
name|abfd
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|)
define|\
value|do						\     {						\       dst->r_stuff[0] = 'S';			\       dst->r_stuff[1] = 'C';			\     }						\   while (0)
end_define

begin_comment
comment|/* Get the value of a symbol, when performing a relocation.  */
end_comment

begin_function
specifier|static
name|long
name|get_symbol_value
parameter_list|(
name|symbol
parameter_list|)
name|asymbol
modifier|*
name|symbol
decl_stmt|;
block|{
name|bfd_vma
name|relocation
decl_stmt|;
if|if
condition|(
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
name|relocation
operator|=
literal|0
expr_stmt|;
else|else
name|relocation
operator|=
operator|(
name|symbol
operator|->
name|value
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
return|return
name|relocation
return|;
block|}
end_function

begin_comment
comment|/* This macro is used in coffcode.h to get the howto corresponding to    an internal reloc.  */
end_comment

begin_define
define|#
directive|define
name|RTYPE2HOWTO
parameter_list|(
name|relent
parameter_list|,
name|internal
parameter_list|)
define|\
value|((relent)->howto =				\    ((internal)->r_type< SH_COFF_HOWTO_COUNT	\     ?&sh_coff_howtos[(internal)->r_type]	\     : (reloc_howto_type *) NULL))
end_define

begin_comment
comment|/* This is the same as the macro in coffcode.h, except that it copies    r_offset into reloc_entry->addend for some relocs.  */
end_comment

begin_define
define|#
directive|define
name|CALC_ADDEND
parameter_list|(
name|abfd
parameter_list|,
name|ptr
parameter_list|,
name|reloc
parameter_list|,
name|cache_ptr
parameter_list|)
define|\
value|{                                                             \     coff_symbol_type *coffsym = (coff_symbol_type *) NULL;      \     if (ptr&& bfd_asymbol_bfd (ptr) != abfd)                   \       coffsym = (obj_symbols (abfd)                             \                  + (cache_ptr->sym_ptr_ptr - symbols));         \     else if (ptr)                                               \       coffsym = coff_symbol_from (abfd, ptr);                   \     if (coffsym != (coff_symbol_type *) NULL                    \&& coffsym->native->u.syment.n_scnum == 0)              \       cache_ptr->addend = 0;                                    \     else if (ptr&& bfd_asymbol_bfd (ptr) == abfd               \&& ptr->section != (asection *) NULL)              \       cache_ptr->addend = - (ptr->section->vma + ptr->value);   \     else                                                        \       cache_ptr->addend = 0;                                    \     if ((reloc).r_type == R_SH_SWITCH8				\ 	|| (reloc).r_type == R_SH_SWITCH16			\ 	|| (reloc).r_type == R_SH_SWITCH32			\ 	|| (reloc).r_type == R_SH_USES				\ 	|| (reloc).r_type == R_SH_COUNT				\ 	|| (reloc).r_type == R_SH_ALIGN)			\       cache_ptr->addend = (reloc).r_offset;			\   }
end_define

begin_comment
comment|/* This is the howto function for the SH relocations.  */
end_comment

begin_function
specifier|static
name|bfd_reloc_status_type
name|sh_reloc
parameter_list|(
name|abfd
parameter_list|,
name|reloc_entry
parameter_list|,
name|symbol_in
parameter_list|,
name|data
parameter_list|,
name|input_section
parameter_list|,
name|output_bfd
parameter_list|,
name|error_message
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|arelent
modifier|*
name|reloc_entry
decl_stmt|;
name|asymbol
modifier|*
name|symbol_in
decl_stmt|;
name|PTR
name|data
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|char
modifier|*
modifier|*
name|error_message
decl_stmt|;
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
name|bfd_vma
name|sym_value
decl_stmt|;
name|unsigned
name|short
name|r_type
decl_stmt|;
name|bfd_vma
name|addr
init|=
name|reloc_entry
operator|->
name|address
decl_stmt|;
name|bfd_byte
modifier|*
name|hit_data
init|=
name|addr
operator|+
operator|(
name|bfd_byte
operator|*
operator|)
name|data
decl_stmt|;
name|r_type
operator|=
name|reloc_entry
operator|->
name|howto
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|output_bfd
operator|!=
name|NULL
condition|)
block|{
comment|/* Partial linking--do nothing.  */
name|reloc_entry
operator|->
name|address
operator|+=
name|input_section
operator|->
name|output_offset
expr_stmt|;
return|return
name|bfd_reloc_ok
return|;
block|}
comment|/* Almost all relocs have to do with relaxing.  If any work must be      done for them, it has been done in sh_relax_section.  */
if|if
condition|(
name|r_type
operator|!=
name|R_SH_IMM32
operator|&&
operator|(
name|r_type
operator|!=
name|R_SH_PCDISP
operator|||
operator|(
name|symbol_in
operator|->
name|flags
operator|&
name|BSF_LOCAL
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|bfd_reloc_ok
return|;
if|if
condition|(
name|symbol_in
operator|!=
name|NULL
operator|&&
name|bfd_is_und_section
argument_list|(
name|symbol_in
operator|->
name|section
argument_list|)
condition|)
return|return
name|bfd_reloc_undefined
return|;
name|sym_value
operator|=
name|get_symbol_value
argument_list|(
name|symbol_in
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r_type
condition|)
block|{
case|case
name|R_SH_IMM32
case|:
name|insn
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|insn
operator|+=
name|sym_value
operator|+
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_PCDISP
case|:
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
name|sym_value
operator|+=
name|reloc_entry
operator|->
name|addend
expr_stmt|;
name|sym_value
operator|-=
operator|(
name|input_section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|input_section
operator|->
name|output_offset
operator|+
name|addr
operator|+
literal|4
operator|)
expr_stmt|;
name|sym_value
operator|+=
operator|(
name|insn
operator|&
literal|0xfff
operator|)
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|insn
operator|&
literal|0x800
condition|)
name|sym_value
operator|-=
literal|0x1000
expr_stmt|;
name|insn
operator|=
operator|(
name|insn
operator|&
literal|0xf000
operator|)
operator||
operator|(
name|sym_value
operator|&
literal|0xfff
operator|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|hit_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_value
operator|<
operator|(
name|bfd_vma
operator|)
operator|-
literal|0x1000
operator|||
name|sym_value
operator|>=
literal|0x1000
condition|)
return|return
name|bfd_reloc_overflow
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
name|bfd_reloc_ok
return|;
block|}
end_function

begin_comment
comment|/* This routine checks for linking big and little endian objects    together.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_merge_private_data
parameter_list|(
name|ibfd
parameter_list|,
name|obfd
parameter_list|)
name|bfd
modifier|*
name|ibfd
decl_stmt|;
name|bfd
modifier|*
name|obfd
decl_stmt|;
block|{
if|if
condition|(
name|ibfd
operator|->
name|xvec
operator|->
name|byteorder
operator|!=
name|obfd
operator|->
name|xvec
operator|->
name|byteorder
operator|&&
name|obfd
operator|->
name|xvec
operator|->
name|byteorder
operator|!=
name|BFD_ENDIAN_UNKNOWN
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: compiled for a %s endian system and target is %s endian"
argument_list|,
name|bfd_get_filename
argument_list|(
name|ibfd
argument_list|)
argument_list|,
name|bfd_big_endian
argument_list|(
name|ibfd
argument_list|)
condition|?
literal|"big"
else|:
literal|"little"
argument_list|,
name|bfd_big_endian
argument_list|(
name|obfd
argument_list|)
condition|?
literal|"big"
else|:
literal|"little"
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_define
define|#
directive|define
name|coff_bfd_merge_private_bfd_data
value|sh_merge_private_data
end_define

begin_comment
comment|/* We can do relaxing.  */
end_comment

begin_define
define|#
directive|define
name|coff_bfd_relax_section
value|sh_relax_section
end_define

begin_comment
comment|/* We use the special COFF backend linker.  */
end_comment

begin_define
define|#
directive|define
name|coff_relocate_section
value|sh_relocate_section
end_define

begin_comment
comment|/* When relaxing, we need to use special code to get the relocated    section contents.  */
end_comment

begin_define
define|#
directive|define
name|coff_bfd_get_relocated_section_contents
define|\
value|sh_coff_get_relocated_section_contents
end_define

begin_include
include|#
directive|include
file|"coffcode.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* This function handles relaxing on the SH.     Function calls on the SH look like this:         movl  L1,r0        ...        jsr   @r0        ...      L1:        .long function     The compiler and assembler will cooperate to create R_SH_USES    relocs on the jsr instructions.  The r_offset field of the    R_SH_USES reloc is the PC relative offset to the instruction which    loads the register (the r_offset field is computed as though it    were a jump instruction, so the offset value is actually from four    bytes past the instruction).  The linker can use this reloc to    determine just which function is being called, and thus decide    whether it is possible to replace the jsr with a bsr.     If multiple function calls are all based on a single register load    (i.e., the same function is called multiple times), the compiler    guarantees that each function call will have an R_SH_USES reloc.    Therefore, if the linker is able to convert each R_SH_USES reloc    which refers to that address, it can safely eliminate the register    load.     When the assembler creates an R_SH_USES reloc, it examines it to    determine which address is being loaded (L1 in the above example).    It then counts the number of references to that address, and    creates an R_SH_COUNT reloc at that address.  The r_offset field of    the R_SH_COUNT reloc will be the number of references.  If the    linker is able to eliminate a register load, it can use the    R_SH_COUNT reloc to see whether it can also eliminate the function    address.     SH relaxing also handles another, unrelated, matter.  On the SH, if    a load or store instruction is not aligned on a four byte boundary,    the memory cycle interferes with the 32 bit instruction fetch,    causing a one cycle bubble in the pipeline.  Therefore, we try to    align load and store instructions on four byte boundaries if we    can, by swapping them with one of the adjacent instructions.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_relax_section
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|link_info
parameter_list|,
name|again
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|boolean
modifier|*
name|again
decl_stmt|;
block|{
name|struct
name|internal_reloc
modifier|*
name|internal_relocs
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|free_relocs
init|=
name|NULL
decl_stmt|;
name|boolean
name|have_code
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|bfd_byte
modifier|*
name|free_contents
init|=
name|NULL
decl_stmt|;
operator|*
name|again
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|link_info
operator|->
name|relocateable
operator|||
operator|(
name|sec
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|sec
operator|->
name|reloc_count
operator|==
literal|0
condition|)
return|return
name|true
return|;
comment|/* If this is the first time we have been called for this section,      initialize the cooked size.  */
if|if
condition|(
name|sec
operator|->
name|_cooked_size
operator|==
literal|0
condition|)
name|sec
operator|->
name|_cooked_size
operator|=
name|sec
operator|->
name|_raw_size
expr_stmt|;
name|internal_relocs
operator|=
operator|(
name|_bfd_coff_read_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|link_info
operator|->
name|keep_memory
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
operator|(
expr|struct
name|internal_reloc
operator|*
operator|)
name|NULL
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free_relocs
operator|=
name|internal_relocs
expr_stmt|;
name|have_code
operator|=
name|false
expr_stmt|;
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|laddr
decl_stmt|,
name|paddr
decl_stmt|,
name|symval
decl_stmt|;
name|unsigned
name|short
name|insn
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irelfn
decl_stmt|,
modifier|*
name|irelscan
decl_stmt|,
modifier|*
name|irelcount
decl_stmt|;
name|struct
name|internal_syment
name|sym
decl_stmt|;
name|bfd_signed_vma
name|foff
decl_stmt|;
if|if
condition|(
name|irel
operator|->
name|r_type
operator|==
name|R_SH_CODE
condition|)
name|have_code
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|irel
operator|->
name|r_type
operator|!=
name|R_SH_USES
condition|)
continue|continue;
comment|/* Get the section contents.  */
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|!=
name|NULL
operator|&&
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|contents
expr_stmt|;
else|else
block|{
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|free_contents
operator|=
name|contents
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* The r_offset field of the R_SH_USES reloc will point us to          the register load.  The 4 is because the r_offset field is          computed as though it were a jump offset, which are based          from 4 bytes after the jump instruction.  */
name|laddr
operator|=
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
operator|+
literal|4
expr_stmt|;
comment|/* Careful to sign extend the 32-bit offset.  */
name|laddr
operator|+=
operator|(
operator|(
name|irel
operator|->
name|r_offset
operator|&
literal|0xffffffff
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
if|if
condition|(
name|laddr
operator|>=
name|sec
operator|->
name|_raw_size
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: 0x%lx: warning: bad R_SH_USES offset"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|irel
operator|->
name|r_vaddr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|laddr
argument_list|)
expr_stmt|;
comment|/* If the instruction is not mov.l NN,rN, we don't know what to do.  */
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xf000
operator|)
operator|!=
literal|0xd000
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: 0x%lx: warning: R_SH_USES points to unrecognized insn 0x%x"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|irel
operator|->
name|r_vaddr
argument_list|,
name|insn
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* Get the address from which the register is being loaded.  The       	 displacement in the mov.l instruction is quadrupled.  It is a       	 displacement from four bytes after the movl instruction, but,       	 before adding in the PC address, two least significant bits       	 of the PC are cleared.  We assume that the section is aligned       	 on a four byte boundary.  */
name|paddr
operator|=
name|insn
operator|&
literal|0xff
expr_stmt|;
name|paddr
operator|*=
literal|4
expr_stmt|;
name|paddr
operator|+=
operator|(
name|laddr
operator|+
literal|4
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
if|if
condition|(
name|paddr
operator|>=
name|sec
operator|->
name|_raw_size
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: 0x%lx: warning: bad R_SH_USES load offset"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|irel
operator|->
name|r_vaddr
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* Get the reloc for the address from which the register is          being loaded.  This reloc will tell us which function is          actually being called.  */
name|paddr
operator|+=
name|sec
operator|->
name|vma
expr_stmt|;
for|for
control|(
name|irelfn
operator|=
name|internal_relocs
init|;
name|irelfn
operator|<
name|irelend
condition|;
name|irelfn
operator|++
control|)
if|if
condition|(
name|irelfn
operator|->
name|r_vaddr
operator|==
name|paddr
operator|&&
name|irelfn
operator|->
name|r_type
operator|==
name|R_SH_IMM32
condition|)
break|break;
if|if
condition|(
name|irelfn
operator|>=
name|irelend
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: 0x%lx: warning: could not find expected reloc"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|paddr
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* Get the value of the symbol referred to by the reloc.  */
if|if
condition|(
operator|!
name|_bfd_coff_get_external_symbols
argument_list|(
name|abfd
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|bfd_coff_swap_sym_in
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
operator|+
operator|(
name|irelfn
operator|->
name|r_symndx
operator|*
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
operator|)
operator|)
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|n_scnum
operator|!=
literal|0
operator|&&
name|sym
operator|.
name|n_scnum
operator|!=
name|sec
operator|->
name|target_index
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: 0x%lx: warning: symbol in unexpected section"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|paddr
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sym
operator|.
name|n_sclass
operator|!=
name|C_EXT
condition|)
block|{
name|symval
operator|=
operator|(
name|sym
operator|.
name|n_value
operator|-
name|sec
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|obj_coff_sym_hashes
argument_list|(
name|abfd
argument_list|)
index|[
name|irelfn
operator|->
name|r_symndx
index|]
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defined
operator|&&
name|h
operator|->
name|root
operator|.
name|type
operator|!=
name|bfd_link_hash_defweak
condition|)
block|{
comment|/* This appears to be a reference to an undefined                  symbol.  Just ignore it--it will be caught by the                  regular reloc processing.  */
continue|continue;
block|}
name|symval
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
name|symval
operator|+=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|paddr
operator|-
name|sec
operator|->
name|vma
argument_list|)
expr_stmt|;
comment|/* See if this function call can be shortened.  */
name|foff
operator|=
operator|(
name|symval
operator|-
operator|(
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
literal|4
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|foff
operator|<
operator|-
literal|0x1000
operator|||
name|foff
operator|>=
literal|0x1000
condition|)
block|{
comment|/* After all that work, we can't shorten this function call.  */
continue|continue;
block|}
comment|/* Shorten the function call.  */
comment|/* For simplicity of coding, we are going to modify the section 	 contents, the section relocs, and the BFD symbol table.  We 	 must tell the rest of the code not to free up this 	 information.  It would be possible to instead create a table 	 of changes which have to be made, as is done in coff-mips.c; 	 that would be more work, but would require less memory when 	 the linker is run.  */
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|sec
operator|->
name|used_by_bfd
operator|=
operator|(
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|coff_section_tdata
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|used_by_bfd
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|keep_relocs
operator|=
name|true
expr_stmt|;
name|free_relocs
operator|=
name|NULL
expr_stmt|;
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|contents
operator|=
name|contents
expr_stmt|;
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|keep_contents
operator|=
name|true
expr_stmt|;
name|free_contents
operator|=
name|NULL
expr_stmt|;
name|obj_coff_keep_syms
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
comment|/* Replace the jsr with a bsr.  */
comment|/* Change the R_SH_USES reloc into an R_SH_PCDISP reloc, and          replace the jsr with a bsr.  */
name|irel
operator|->
name|r_type
operator|=
name|R_SH_PCDISP
expr_stmt|;
name|irel
operator|->
name|r_symndx
operator|=
name|irelfn
operator|->
name|r_symndx
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|n_sclass
operator|!=
name|C_EXT
condition|)
block|{
comment|/* If this needs to be changed because of future relaxing,              it will be handled here like other internal PCDISP              relocs.  */
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
literal|0xb000
operator||
operator|(
operator|(
name|foff
operator|>>
literal|1
operator|)
operator|&
literal|0xfff
operator|)
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We can't fully resolve this yet, because the external              symbol value may be changed by future relaxing.  We let              the final link phase handle it.  */
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
literal|0xb000
argument_list|,
name|contents
operator|+
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
argument_list|)
expr_stmt|;
block|}
comment|/* See if there is another R_SH_USES reloc referring to the same          register load.  */
for|for
control|(
name|irelscan
operator|=
name|internal_relocs
init|;
name|irelscan
operator|<
name|irelend
condition|;
name|irelscan
operator|++
control|)
if|if
condition|(
name|irelscan
operator|->
name|r_type
operator|==
name|R_SH_USES
operator|&&
name|laddr
operator|==
name|irelscan
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
operator|+
literal|4
operator|+
name|irelscan
operator|->
name|r_offset
condition|)
break|break;
if|if
condition|(
name|irelscan
operator|<
name|irelend
condition|)
block|{
comment|/* Some other function call depends upon this register load, 	     and we have not yet converted that function call. 	     Indeed, we may never be able to convert it.  There is 	     nothing else we can do at this point.  */
continue|continue;
block|}
comment|/* Look for a R_SH_COUNT reloc on the location where the          function address is stored.  Do this before deleting any          bytes, to avoid confusion about the address.  */
for|for
control|(
name|irelcount
operator|=
name|internal_relocs
init|;
name|irelcount
operator|<
name|irelend
condition|;
name|irelcount
operator|++
control|)
if|if
condition|(
name|irelcount
operator|->
name|r_vaddr
operator|==
name|paddr
operator|&&
name|irelcount
operator|->
name|r_type
operator|==
name|R_SH_COUNT
condition|)
break|break;
comment|/* Delete the register load.  */
if|if
condition|(
operator|!
name|sh_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|laddr
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
comment|/* That will change things, so, just in case it permits some          other function call to come within range, we should relax          again.  Note that this is not required, and it may be slow.  */
operator|*
name|again
operator|=
name|true
expr_stmt|;
comment|/* Now check whether we got a COUNT reloc.  */
if|if
condition|(
name|irelcount
operator|>=
name|irelend
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: 0x%lx: warning: could not find expected COUNT reloc"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|paddr
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* The number of uses is stored in the r_offset field.  We've          just deleted one.  */
if|if
condition|(
name|irelcount
operator|->
name|r_offset
operator|==
literal|0
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: 0x%lx: warning: bad count"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|paddr
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
operator|--
name|irelcount
operator|->
name|r_offset
expr_stmt|;
comment|/* If there are no more uses, we can delete the address.  Reload          the address from irelfn, in case it was changed by the          previous call to sh_relax_delete_bytes.  */
if|if
condition|(
name|irelcount
operator|->
name|r_offset
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|sh_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|irelfn
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
argument_list|,
literal|4
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
comment|/* We've done all we can with that function call.  */
block|}
comment|/* Look for load and store instructions that we can align on four      byte boundaries.  */
if|if
condition|(
name|have_code
condition|)
block|{
name|boolean
name|swapped
decl_stmt|;
comment|/* Get the section contents.  */
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|!=
name|NULL
operator|&&
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|contents
operator|!=
name|NULL
condition|)
name|contents
operator|=
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|contents
expr_stmt|;
else|else
block|{
name|contents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|sec
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|free_contents
operator|=
name|contents
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|sec
operator|->
name|_raw_size
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|sh_align_loads
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|internal_relocs
argument_list|,
name|contents
argument_list|,
operator|&
name|swapped
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|swapped
condition|)
block|{
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|sec
operator|->
name|used_by_bfd
operator|=
operator|(
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|coff_section_tdata
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|used_by_bfd
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
block|}
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|internal_relocs
expr_stmt|;
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|keep_relocs
operator|=
name|true
expr_stmt|;
name|free_relocs
operator|=
name|NULL
expr_stmt|;
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|contents
operator|=
name|contents
expr_stmt|;
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|keep_contents
operator|=
name|true
expr_stmt|;
name|free_contents
operator|=
name|NULL
expr_stmt|;
name|obj_coff_keep_syms
argument_list|(
name|abfd
argument_list|)
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|free_relocs
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|free_relocs
argument_list|)
expr_stmt|;
name|free_relocs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|free_contents
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|link_info
operator|->
name|keep_memory
condition|)
name|free
argument_list|(
name|free_contents
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Cache the section contents for coff_link_input_bfd.  */
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|sec
operator|->
name|used_by_bfd
operator|=
operator|(
operator|(
name|PTR
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|coff_section_tdata
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|used_by_bfd
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|relocs
operator|=
name|NULL
expr_stmt|;
block|}
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|contents
operator|=
name|contents
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|free_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_contents
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|free_contents
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Delete some bytes from a section while relaxing.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_relax_delete_bytes
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|addr
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irelalign
decl_stmt|;
name|bfd_vma
name|toaddr
decl_stmt|;
name|bfd_byte
modifier|*
name|esym
decl_stmt|,
modifier|*
name|esymend
decl_stmt|;
name|bfd_size_type
name|symesz
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
modifier|*
name|sym_hash
decl_stmt|;
name|asection
modifier|*
name|o
decl_stmt|;
name|contents
operator|=
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|contents
expr_stmt|;
comment|/* The deletion must stop at the next ALIGN reloc for an aligment      power larger than the number of bytes we are deleting.  */
name|irelalign
operator|=
name|NULL
expr_stmt|;
name|toaddr
operator|=
name|sec
operator|->
name|_cooked_size
expr_stmt|;
name|irel
operator|=
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|relocs
expr_stmt|;
name|irelend
operator|=
name|irel
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
if|if
condition|(
name|irel
operator|->
name|r_type
operator|==
name|R_SH_ALIGN
operator|&&
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
operator|>
name|addr
operator|&&
name|count
operator|<
operator|(
literal|1
operator|<<
name|irel
operator|->
name|r_offset
operator|)
condition|)
block|{
name|irelalign
operator|=
name|irel
expr_stmt|;
name|toaddr
operator|=
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
expr_stmt|;
break|break;
block|}
block|}
comment|/* Actually delete the bytes.  */
name|memmove
argument_list|(
name|contents
operator|+
name|addr
argument_list|,
name|contents
operator|+
name|addr
operator|+
name|count
argument_list|,
name|toaddr
operator|-
name|addr
operator|-
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|irelalign
operator|==
name|NULL
condition|)
name|sec
operator|->
name|_cooked_size
operator|-=
name|count
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
define|#
directive|define
name|NOP_OPCODE
value|(0x0009)
name|BFD_ASSERT
argument_list|(
operator|(
name|count
operator|&
literal|1
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|+=
literal|2
control|)
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|NOP_OPCODE
argument_list|,
name|contents
operator|+
name|toaddr
operator|-
name|count
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust all the relocs.  */
for|for
control|(
name|irel
operator|=
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|)
operator|->
name|relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|nraddr
decl_stmt|,
name|stop
decl_stmt|;
name|bfd_vma
name|start
init|=
literal|0
decl_stmt|;
name|int
name|insn
init|=
literal|0
decl_stmt|;
name|struct
name|internal_syment
name|sym
decl_stmt|;
name|int
name|off
decl_stmt|,
name|adjust
decl_stmt|,
name|oinsn
decl_stmt|;
name|bfd_signed_vma
name|voff
init|=
literal|0
decl_stmt|;
name|boolean
name|overflow
decl_stmt|;
comment|/* Get the new reloc address.  */
name|nraddr
operator|=
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
expr_stmt|;
if|if
condition|(
operator|(
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
operator|>
name|addr
operator|&&
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
operator|<
name|toaddr
operator|)
operator|||
operator|(
name|irel
operator|->
name|r_type
operator|==
name|R_SH_ALIGN
operator|&&
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
operator|==
name|toaddr
operator|)
condition|)
name|nraddr
operator|-=
name|count
expr_stmt|;
comment|/* See if this reloc was for the bytes we have deleted, in which 	 case we no longer care about it.  Don't delete relocs which 	 represent addresses, though.  */
if|if
condition|(
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
operator|>=
name|addr
operator|&&
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
operator|<
name|addr
operator|+
name|count
operator|&&
name|irel
operator|->
name|r_type
operator|!=
name|R_SH_ALIGN
operator|&&
name|irel
operator|->
name|r_type
operator|!=
name|R_SH_CODE
operator|&&
name|irel
operator|->
name|r_type
operator|!=
name|R_SH_DATA
operator|&&
name|irel
operator|->
name|r_type
operator|!=
name|R_SH_LABEL
condition|)
name|irel
operator|->
name|r_type
operator|=
name|R_SH_UNUSED
expr_stmt|;
comment|/* If this is a PC relative reloc, see if the range it covers          includes the bytes we have deleted.  */
switch|switch
condition|(
name|irel
operator|->
name|r_type
condition|)
block|{
default|default:
break|break;
case|case
name|R_SH_PCDISP8BY2
case|:
case|case
name|R_SH_PCDISP
case|:
case|case
name|R_SH_PCRELIMM8BY2
case|:
case|case
name|R_SH_PCRELIMM8BY4
case|:
name|start
operator|=
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
expr_stmt|;
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|irel
operator|->
name|r_type
condition|)
block|{
default|default:
name|start
operator|=
name|stop
operator|=
name|addr
expr_stmt|;
break|break;
case|case
name|R_SH_IMM32
case|:
comment|/* If this reloc is against a symbol defined in this              section, and the symbol will not be adjusted below, we              must check the addend to see it will put the value in              range to be adjusted, and hence must be changed.  */
name|bfd_coff_swap_sym_in
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
operator|+
operator|(
name|irel
operator|->
name|r_symndx
operator|*
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
operator|)
operator|)
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|n_sclass
operator|!=
name|C_EXT
operator|&&
name|sym
operator|.
name|n_scnum
operator|==
name|sec
operator|->
name|target_index
operator|&&
operator|(
operator|(
name|bfd_vma
operator|)
name|sym
operator|.
name|n_value
operator|<=
name|addr
operator|||
operator|(
name|bfd_vma
operator|)
name|sym
operator|.
name|n_value
operator|>=
name|toaddr
operator|)
condition|)
block|{
name|bfd_vma
name|val
decl_stmt|;
name|val
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
name|val
operator|+=
name|sym
operator|.
name|n_value
expr_stmt|;
if|if
condition|(
name|val
operator|>=
name|addr
operator|&&
name|val
operator|<
name|toaddr
condition|)
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|val
operator|-
name|count
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
block|}
name|start
operator|=
name|stop
operator|=
name|addr
expr_stmt|;
break|break;
case|case
name|R_SH_PCDISP8BY2
case|:
name|off
operator|=
name|insn
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|off
operator|&
literal|0x80
condition|)
name|off
operator|-=
literal|0x100
expr_stmt|;
name|stop
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|bfd_signed_vma
operator|)
name|start
operator|+
literal|4
operator|+
name|off
operator|*
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_PCDISP
case|:
name|bfd_coff_swap_sym_in
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
operator|+
operator|(
name|irel
operator|->
name|r_symndx
operator|*
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
operator|)
operator|)
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|n_sclass
operator|==
name|C_EXT
condition|)
name|start
operator|=
name|stop
operator|=
name|addr
expr_stmt|;
else|else
block|{
name|off
operator|=
name|insn
operator|&
literal|0xfff
expr_stmt|;
if|if
condition|(
name|off
operator|&
literal|0x800
condition|)
name|off
operator|-=
literal|0x1000
expr_stmt|;
name|stop
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|bfd_signed_vma
operator|)
name|start
operator|+
literal|4
operator|+
name|off
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|R_SH_PCRELIMM8BY2
case|:
name|off
operator|=
name|insn
operator|&
literal|0xff
expr_stmt|;
name|stop
operator|=
name|start
operator|+
literal|4
operator|+
name|off
operator|*
literal|2
expr_stmt|;
break|break;
case|case
name|R_SH_PCRELIMM8BY4
case|:
name|off
operator|=
name|insn
operator|&
literal|0xff
expr_stmt|;
name|stop
operator|=
operator|(
name|start
operator|&
operator|~
operator|(
name|bfd_vma
operator|)
literal|3
operator|)
operator|+
literal|4
operator|+
name|off
operator|*
literal|4
expr_stmt|;
break|break;
case|case
name|R_SH_SWITCH8
case|:
case|case
name|R_SH_SWITCH16
case|:
case|case
name|R_SH_SWITCH32
case|:
comment|/* These relocs types represent 	       .word L2-L1 	     The r_offset field holds the difference between the reloc 	     address and L1.  That is the start of the reloc, and 	     adding in the contents gives us the top.  We must adjust 	     both the r_offset field and the section contents.  */
name|start
operator|=
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
expr_stmt|;
name|stop
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|bfd_signed_vma
operator|)
name|start
operator|-
operator|(
name|long
operator|)
name|irel
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|>
name|addr
operator|&&
name|start
operator|<
name|toaddr
operator|&&
operator|(
name|stop
operator|<=
name|addr
operator|||
name|stop
operator|>=
name|toaddr
operator|)
condition|)
name|irel
operator|->
name|r_offset
operator|+=
name|count
expr_stmt|;
elseif|else
if|if
condition|(
name|stop
operator|>
name|addr
operator|&&
name|stop
operator|<
name|toaddr
operator|&&
operator|(
name|start
operator|<=
name|addr
operator|||
name|start
operator|>=
name|toaddr
operator|)
condition|)
name|irel
operator|->
name|r_offset
operator|-=
name|count
expr_stmt|;
name|start
operator|=
name|stop
expr_stmt|;
if|if
condition|(
name|irel
operator|->
name|r_type
operator|==
name|R_SH_SWITCH16
condition|)
name|voff
operator|=
name|bfd_get_signed_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|irel
operator|->
name|r_type
operator|==
name|R_SH_SWITCH8
condition|)
name|voff
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
else|else
name|voff
operator|=
name|bfd_get_signed_32
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
name|stop
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|bfd_signed_vma
operator|)
name|start
operator|+
name|voff
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_USES
case|:
name|start
operator|=
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
expr_stmt|;
name|stop
operator|=
call|(
name|bfd_vma
call|)
argument_list|(
operator|(
name|bfd_signed_vma
operator|)
name|start
operator|+
operator|(
name|long
operator|)
name|irel
operator|->
name|r_offset
operator|+
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|start
operator|>
name|addr
operator|&&
name|start
operator|<
name|toaddr
operator|&&
operator|(
name|stop
operator|<=
name|addr
operator|||
name|stop
operator|>=
name|toaddr
operator|)
condition|)
name|adjust
operator|=
name|count
expr_stmt|;
elseif|else
if|if
condition|(
name|stop
operator|>
name|addr
operator|&&
name|stop
operator|<
name|toaddr
operator|&&
operator|(
name|start
operator|<=
name|addr
operator|||
name|start
operator|>=
name|toaddr
operator|)
condition|)
name|adjust
operator|=
operator|-
name|count
expr_stmt|;
else|else
name|adjust
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|adjust
operator|!=
literal|0
condition|)
block|{
name|oinsn
operator|=
name|insn
expr_stmt|;
name|overflow
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
name|irel
operator|->
name|r_type
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|R_SH_PCDISP8BY2
case|:
case|case
name|R_SH_PCRELIMM8BY2
case|:
name|insn
operator|+=
name|adjust
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|oinsn
operator|&
literal|0xff00
operator|)
operator|!=
operator|(
name|insn
operator|&
literal|0xff00
operator|)
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_PCDISP
case|:
name|insn
operator|+=
name|adjust
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|oinsn
operator|&
literal|0xf000
operator|)
operator|!=
operator|(
name|insn
operator|&
literal|0xf000
operator|)
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_PCRELIMM8BY4
case|:
name|BFD_ASSERT
argument_list|(
name|adjust
operator|==
name|count
operator|||
name|count
operator|>=
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
literal|4
condition|)
name|insn
operator|+=
name|adjust
operator|/
literal|4
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|irel
operator|->
name|r_vaddr
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
operator|++
name|insn
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|oinsn
operator|&
literal|0xff00
operator|)
operator|!=
operator|(
name|insn
operator|&
literal|0xff00
operator|)
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_SWITCH8
case|:
name|voff
operator|+=
name|adjust
expr_stmt|;
if|if
condition|(
name|voff
operator|<
literal|0
operator|||
name|voff
operator|>=
literal|0xff
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_8
argument_list|(
name|abfd
argument_list|,
name|voff
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_SWITCH16
case|:
name|voff
operator|+=
name|adjust
expr_stmt|;
if|if
condition|(
name|voff
operator|<
operator|-
literal|0x8000
operator|||
name|voff
operator|>=
literal|0x8000
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_signed_16
argument_list|(
name|abfd
argument_list|,
name|voff
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_SWITCH32
case|:
name|voff
operator|+=
name|adjust
expr_stmt|;
name|bfd_put_signed_32
argument_list|(
name|abfd
argument_list|,
name|voff
argument_list|,
name|contents
operator|+
name|nraddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_USES
case|:
name|irel
operator|->
name|r_offset
operator|+=
name|adjust
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|overflow
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: 0x%lx: fatal: reloc overflow while relaxing"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|irel
operator|->
name|r_vaddr
argument_list|)
operator|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|irel
operator|->
name|r_vaddr
operator|=
name|nraddr
operator|+
name|sec
operator|->
name|vma
expr_stmt|;
block|}
comment|/* Look through all the other sections.  If there contain any IMM32      relocs against internal symbols which we are not going to adjust      below, we may need to adjust the addends.  */
for|for
control|(
name|o
operator|=
name|abfd
operator|->
name|sections
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|struct
name|internal_reloc
modifier|*
name|internal_relocs
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irelscan
decl_stmt|,
modifier|*
name|irelscanend
decl_stmt|;
name|bfd_byte
modifier|*
name|ocontents
decl_stmt|;
if|if
condition|(
name|o
operator|==
name|sec
operator|||
operator|(
name|o
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|==
literal|0
operator|||
name|o
operator|->
name|reloc_count
operator|==
literal|0
condition|)
continue|continue;
comment|/* We always cache the relocs.  Perhaps, if info->keep_memory is          false, we should free them, if we are permitted to, when we          leave sh_coff_relax_section.  */
name|internal_relocs
operator|=
operator|(
name|_bfd_coff_read_internal_relocs
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
name|true
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
operator|(
expr|struct
name|internal_reloc
operator|*
operator|)
name|NULL
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|ocontents
operator|=
name|NULL
expr_stmt|;
name|irelscanend
operator|=
name|internal_relocs
operator|+
name|o
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irelscan
operator|=
name|internal_relocs
init|;
name|irelscan
operator|<
name|irelscanend
condition|;
name|irelscan
operator|++
control|)
block|{
name|struct
name|internal_syment
name|sym
decl_stmt|;
if|if
condition|(
name|irelscan
operator|->
name|r_type
operator|!=
name|R_SH_IMM32
condition|)
continue|continue;
name|bfd_coff_swap_sym_in
argument_list|(
name|abfd
argument_list|,
operator|(
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
operator|+
operator|(
name|irelscan
operator|->
name|r_symndx
operator|*
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
operator|)
operator|)
argument_list|,
operator|&
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|.
name|n_sclass
operator|!=
name|C_EXT
operator|&&
name|sym
operator|.
name|n_scnum
operator|==
name|sec
operator|->
name|target_index
operator|&&
operator|(
operator|(
name|bfd_vma
operator|)
name|sym
operator|.
name|n_value
operator|<=
name|addr
operator|||
operator|(
name|bfd_vma
operator|)
name|sym
operator|.
name|n_value
operator|>=
name|toaddr
operator|)
condition|)
block|{
name|bfd_vma
name|val
decl_stmt|;
if|if
condition|(
name|ocontents
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
operator|->
name|contents
operator|!=
name|NULL
condition|)
name|ocontents
operator|=
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
operator|->
name|contents
expr_stmt|;
else|else
block|{
comment|/* We always cache the section contents.                          Perhaps, if info->keep_memory is false, we                          should free them, if we are permitted to,                          when we leave sh_coff_relax_section.  */
name|ocontents
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|o
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ocontents
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|,
name|ocontents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|o
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|false
return|;
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
operator|->
name|contents
operator|=
name|ocontents
expr_stmt|;
block|}
block|}
name|val
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
name|ocontents
operator|+
name|irelscan
operator|->
name|r_vaddr
operator|-
name|o
operator|->
name|vma
argument_list|)
expr_stmt|;
name|val
operator|+=
name|sym
operator|.
name|n_value
expr_stmt|;
if|if
condition|(
name|val
operator|>=
name|addr
operator|&&
name|val
operator|<
name|toaddr
condition|)
name|bfd_put_32
argument_list|(
name|abfd
argument_list|,
name|val
operator|-
name|count
argument_list|,
name|ocontents
operator|+
name|irelscan
operator|->
name|r_vaddr
operator|-
name|o
operator|->
name|vma
argument_list|)
expr_stmt|;
name|coff_section_data
argument_list|(
name|abfd
argument_list|,
name|o
argument_list|)
operator|->
name|keep_contents
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
comment|/* Adjusting the internal symbols will not work if something has      already retrieved the generic symbols.  It would be possible to      make this work by adjusting the generic symbols at the same time.      However, this case should not arise in normal usage.  */
if|if
condition|(
name|obj_symbols
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
operator|||
name|obj_raw_syments
argument_list|(
name|abfd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: fatal: generic symbols retrieved before relaxing"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_invalid_operation
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Adjust all the symbols.  */
name|sym_hash
operator|=
name|obj_coff_sym_hashes
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|symesz
operator|=
name|bfd_coff_symesz
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|esym
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|esymend
operator|=
name|esym
operator|+
name|obj_raw_syment_count
argument_list|(
name|abfd
argument_list|)
operator|*
name|symesz
expr_stmt|;
while|while
condition|(
name|esym
operator|<
name|esymend
condition|)
block|{
name|struct
name|internal_syment
name|isym
decl_stmt|;
name|bfd_coff_swap_sym_in
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
name|esym
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|isym
argument_list|)
expr_stmt|;
if|if
condition|(
name|isym
operator|.
name|n_scnum
operator|==
name|sec
operator|->
name|target_index
operator|&&
operator|(
name|bfd_vma
operator|)
name|isym
operator|.
name|n_value
operator|>
name|addr
operator|&&
operator|(
name|bfd_vma
operator|)
name|isym
operator|.
name|n_value
operator|<
name|toaddr
condition|)
block|{
name|isym
operator|.
name|n_value
operator|-=
name|count
expr_stmt|;
name|bfd_coff_swap_sym_out
argument_list|(
name|abfd
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|isym
argument_list|,
operator|(
name|PTR
operator|)
name|esym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sym_hash
operator|!=
name|NULL
condition|)
block|{
name|BFD_ASSERT
argument_list|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|>=
name|addr
operator|&&
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|<
name|toaddr
argument_list|)
expr_stmt|;
operator|(
operator|*
name|sym_hash
operator|)
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|-=
name|count
expr_stmt|;
block|}
block|}
name|esym
operator|+=
operator|(
name|isym
operator|.
name|n_numaux
operator|+
literal|1
operator|)
operator|*
name|symesz
expr_stmt|;
name|sym_hash
operator|+=
name|isym
operator|.
name|n_numaux
operator|+
literal|1
expr_stmt|;
block|}
comment|/* See if we can move the ALIGN reloc forward.  We have adjusted      r_vaddr for it already.  */
if|if
condition|(
name|irelalign
operator|!=
name|NULL
condition|)
block|{
name|bfd_vma
name|alignto
decl_stmt|,
name|alignaddr
decl_stmt|;
name|alignto
operator|=
name|BFD_ALIGN
argument_list|(
name|toaddr
argument_list|,
literal|1
operator|<<
name|irelalign
operator|->
name|r_offset
argument_list|)
expr_stmt|;
name|alignaddr
operator|=
name|BFD_ALIGN
argument_list|(
name|irelalign
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
argument_list|,
literal|1
operator|<<
name|irelalign
operator|->
name|r_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|alignto
operator|!=
name|alignaddr
condition|)
block|{
comment|/* Tail recursion.  */
return|return
name|sh_relax_delete_bytes
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|alignaddr
argument_list|,
name|alignto
operator|-
name|alignaddr
argument_list|)
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is yet another version of the SH opcode table, used to rapidly    get information about a particular instruction.  */
end_comment

begin_comment
comment|/* The opcode map is represented by an array of these structures.  The    array is indexed by the high order four bits in the instruction.  */
end_comment

begin_struct
struct|struct
name|sh_major_opcode
block|{
comment|/* A pointer to the instruction list.  This is an array which      contains all the instructions with this major opcode.  */
specifier|const
name|struct
name|sh_minor_opcode
modifier|*
name|minor_opcodes
decl_stmt|;
comment|/* The number of elements in minor_opcodes.  */
name|unsigned
name|short
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure holds information for a set of SH opcodes.  The    instruction code is anded with the mask value, and the resulting    value is used to search the order opcode list.  */
end_comment

begin_struct
struct|struct
name|sh_minor_opcode
block|{
comment|/* The sorted opcode list.  */
specifier|const
name|struct
name|sh_opcode
modifier|*
name|opcodes
decl_stmt|;
comment|/* The number of elements in opcodes.  */
name|unsigned
name|short
name|count
decl_stmt|;
comment|/* The mask value to use when searching the opcode list.  */
name|unsigned
name|short
name|mask
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This structure holds information for an SH instruction.  An array    of these structures is sorted in order by opcode.  */
end_comment

begin_struct
struct|struct
name|sh_opcode
block|{
comment|/* The code for this instruction, after it has been anded with the      mask value in the sh_major_opcode structure.  */
name|unsigned
name|short
name|opcode
decl_stmt|;
comment|/* Flags for this instruction.  */
name|unsigned
name|short
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Flag which appear in the sh_opcode structure.  */
end_comment

begin_comment
comment|/* This instruction loads a value from memory.  */
end_comment

begin_define
define|#
directive|define
name|LOAD
value|(0x1)
end_define

begin_comment
comment|/* This instruction stores a value to memory.  */
end_comment

begin_define
define|#
directive|define
name|STORE
value|(0x2)
end_define

begin_comment
comment|/* This instruction is a branch.  */
end_comment

begin_define
define|#
directive|define
name|BRANCH
value|(0x4)
end_define

begin_comment
comment|/* This instruction has a delay slot.  */
end_comment

begin_define
define|#
directive|define
name|DELAY
value|(0x8)
end_define

begin_comment
comment|/* This instruction uses the value in the register in the field at    mask 0x0f00 of the instruction.  */
end_comment

begin_define
define|#
directive|define
name|USES1
value|(0x10)
end_define

begin_comment
comment|/* This instruction uses the value in the register in the field at    mask 0x00f0 of the instruction.  */
end_comment

begin_define
define|#
directive|define
name|USES2
value|(0x20)
end_define

begin_comment
comment|/* This instruction uses the value in register 0.  */
end_comment

begin_define
define|#
directive|define
name|USESR0
value|(0x40)
end_define

begin_comment
comment|/* This instruction sets the value in the register in the field at    mask 0x0f00 of the instruction.  */
end_comment

begin_define
define|#
directive|define
name|SETS1
value|(0x80)
end_define

begin_comment
comment|/* This instruction sets the value in the register in the field at    mask 0x00f0 of the instruction.  */
end_comment

begin_define
define|#
directive|define
name|SETS2
value|(0x100)
end_define

begin_comment
comment|/* This instruction sets register 0.  */
end_comment

begin_define
define|#
directive|define
name|SETSR0
value|(0x200)
end_define

begin_comment
comment|/* This instruction sets a special register.  */
end_comment

begin_define
define|#
directive|define
name|SETSSP
value|(0x400)
end_define

begin_comment
comment|/* This instruction uses a special register.  */
end_comment

begin_define
define|#
directive|define
name|USESSP
value|(0x800)
end_define

begin_comment
comment|/* This instruction uses the floating point register in the field at    mask 0x0f00 of the instruction.  */
end_comment

begin_define
define|#
directive|define
name|USESF1
value|(0x1000)
end_define

begin_comment
comment|/* This instruction uses the floating point register in the field at    mask 0x00f0 of the instruction.  */
end_comment

begin_define
define|#
directive|define
name|USESF2
value|(0x2000)
end_define

begin_comment
comment|/* This instruction uses floating point register 0.  */
end_comment

begin_define
define|#
directive|define
name|USESF0
value|(0x4000)
end_define

begin_comment
comment|/* This instruction sets the floating point register in the field at    mask 0x0f00 of the instruction.  */
end_comment

begin_define
define|#
directive|define
name|SETSF1
value|(0x8000)
end_define

begin_decl_stmt
specifier|static
name|boolean
name|sh_insn_uses_reg
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
specifier|const
expr|struct
name|sh_opcode
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_insn_uses_freg
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
specifier|const
expr|struct
name|sh_opcode
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_insns_conflict
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
specifier|const
expr|struct
name|sh_opcode
operator|*
operator|,
name|unsigned
name|int
operator|,
specifier|const
expr|struct
name|sh_opcode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|sh_load_use
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
specifier|const
expr|struct
name|sh_opcode
operator|*
operator|,
name|unsigned
name|int
operator|,
specifier|const
expr|struct
name|sh_opcode
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The opcode maps.  */
end_comment

begin_define
define|#
directive|define
name|MAP
parameter_list|(
name|a
parameter_list|)
value|a, sizeof a / sizeof a[0]
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_opcode
name|sh_opcode00
index|[]
init|=
block|{
block|{
literal|0x0008
block|,
name|SETSSP
block|}
block|,
comment|/* clrt */
block|{
literal|0x0009
block|,
literal|0
block|}
block|,
comment|/* nop */
block|{
literal|0x000b
block|,
name|BRANCH
operator||
name|DELAY
operator||
name|USESSP
block|}
block|,
comment|/* rts */
block|{
literal|0x0018
block|,
name|SETSSP
block|}
block|,
comment|/* sett */
block|{
literal|0x0019
block|,
name|SETSSP
block|}
block|,
comment|/* div0u */
block|{
literal|0x001b
block|,
literal|0
block|}
block|,
comment|/* sleep */
block|{
literal|0x0028
block|,
name|SETSSP
block|}
block|,
comment|/* clrmac */
block|{
literal|0x002b
block|,
name|BRANCH
operator||
name|DELAY
operator||
name|SETSSP
block|}
block|,
comment|/* rte */
block|{
literal|0x0038
block|,
name|USESSP
operator||
name|SETSSP
block|}
block|,
comment|/* ldtlb */
block|{
literal|0x0048
block|,
name|SETSSP
block|}
block|,
comment|/* clrs */
block|{
literal|0x0058
block|,
name|SETSSP
block|}
comment|/* sets */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_opcode
name|sh_opcode01
index|[]
init|=
block|{
block|{
literal|0x0002
block|,
name|SETS1
operator||
name|USESSP
block|}
block|,
comment|/* stc sr,rn */
block|{
literal|0x0003
block|,
name|BRANCH
operator||
name|DELAY
operator||
name|USES1
operator||
name|SETSSP
block|}
block|,
comment|/* bsrf rn */
block|{
literal|0x000a
block|,
name|SETS1
operator||
name|USESSP
block|}
block|,
comment|/* sts mach,rn */
block|{
literal|0x0012
block|,
name|SETS1
operator||
name|USESSP
block|}
block|,
comment|/* stc gbr,rn */
block|{
literal|0x001a
block|,
name|SETS1
operator||
name|USESSP
block|}
block|,
comment|/* sts macl,rn */
block|{
literal|0x0022
block|,
name|SETS1
operator||
name|USESSP
block|}
block|,
comment|/* stc vbr,rn */
block|{
literal|0x0023
block|,
name|BRANCH
operator||
name|DELAY
operator||
name|USES1
block|}
block|,
comment|/* braf rn */
block|{
literal|0x0029
block|,
name|SETS1
operator||
name|USESSP
block|}
block|,
comment|/* movt rn */
block|{
literal|0x002a
block|,
name|SETS1
operator||
name|USESSP
block|}
block|,
comment|/* sts pr,rn */
block|{
literal|0x0032
block|,
name|SETS1
operator||
name|USESSP
block|}
block|,
comment|/* stc ssr,rn */
block|{
literal|0x0042
block|,
name|SETS1
operator||
name|USESSP
block|}
block|,
comment|/* stc spc,rn */
block|{
literal|0x005a
block|,
name|SETS1
operator||
name|USESSP
block|}
block|,
comment|/* sts fpul,rn */
block|{
literal|0x006a
block|,
name|SETS1
operator||
name|USESSP
block|}
block|,
comment|/* sts fpscr,rn */
block|{
literal|0x0082
block|,
name|SETS1
operator||
name|USESSP
block|}
block|,
comment|/* stc r0_bank,rn */
block|{
literal|0x0083
block|,
name|LOAD
operator||
name|USES1
block|}
block|,
comment|/* pref @rn */
block|{
literal|0x0092
block|,
name|SETS1
operator||
name|USESSP
block|}
block|,
comment|/* stc r1_bank,rn */
block|{
literal|0x00a2
block|,
name|SETS1
operator||
name|USESSP
block|}
block|,
comment|/* stc r2_bank,rn */
block|{
literal|0x00b2
block|,
name|SETS1
operator||
name|USESSP
block|}
block|,
comment|/* stc r3_bank,rn */
block|{
literal|0x00c2
block|,
name|SETS1
operator||
name|USESSP
block|}
block|,
comment|/* stc r4_bank,rn */
block|{
literal|0x00d2
block|,
name|SETS1
operator||
name|USESSP
block|}
block|,
comment|/* stc r5_bank,rn */
block|{
literal|0x00e2
block|,
name|SETS1
operator||
name|USESSP
block|}
block|,
comment|/* stc r6_bank,rn */
block|{
literal|0x00f2
block|,
name|SETS1
operator||
name|USESSP
block|}
comment|/* stc r7_bank,rn */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_opcode
name|sh_opcode02
index|[]
init|=
block|{
block|{
literal|0x0004
block|,
name|STORE
operator||
name|USES1
operator||
name|USES2
operator||
name|USESR0
block|}
block|,
comment|/* mov.b rm,@(r0,rn) */
block|{
literal|0x0005
block|,
name|STORE
operator||
name|USES1
operator||
name|USES2
operator||
name|USESR0
block|}
block|,
comment|/* mov.w rm,@(r0,rn) */
block|{
literal|0x0006
block|,
name|STORE
operator||
name|USES1
operator||
name|USES2
operator||
name|USESR0
block|}
block|,
comment|/* mov.l rm,@(r0,rn) */
block|{
literal|0x0007
block|,
name|SETSSP
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* mul.l rm,rn */
block|{
literal|0x000c
block|,
name|LOAD
operator||
name|SETS1
operator||
name|USES2
operator||
name|USESR0
block|}
block|,
comment|/* mov.b @(r0,rm),rn */
block|{
literal|0x000d
block|,
name|LOAD
operator||
name|SETS1
operator||
name|USES2
operator||
name|USESR0
block|}
block|,
comment|/* mov.w @(r0,rm),rn */
block|{
literal|0x000e
block|,
name|LOAD
operator||
name|SETS1
operator||
name|USES2
operator||
name|USESR0
block|}
block|,
comment|/* mov.l @(r0,rm),rn */
block|{
literal|0x000f
block|,
name|LOAD
operator||
name|SETS1
operator||
name|SETS2
operator||
name|SETSSP
operator||
name|USES1
operator||
name|USES2
operator||
name|USESSP
block|}
block|,
comment|/* mac.l @rm+,@rn+ */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_minor_opcode
name|sh_opcode0
index|[]
init|=
block|{
block|{
name|MAP
argument_list|(
name|sh_opcode00
argument_list|)
block|,
literal|0xffff
block|}
block|,
block|{
name|MAP
argument_list|(
name|sh_opcode01
argument_list|)
block|,
literal|0xf0ff
block|}
block|,
block|{
name|MAP
argument_list|(
name|sh_opcode02
argument_list|)
block|,
literal|0xf00f
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_opcode
name|sh_opcode10
index|[]
init|=
block|{
block|{
literal|0x1000
block|,
name|STORE
operator||
name|USES1
operator||
name|USES2
block|}
comment|/* mov.l rm,@(disp,rn) */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_minor_opcode
name|sh_opcode1
index|[]
init|=
block|{
block|{
name|MAP
argument_list|(
name|sh_opcode10
argument_list|)
block|,
literal|0xf000
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_opcode
name|sh_opcode20
index|[]
init|=
block|{
block|{
literal|0x2000
block|,
name|STORE
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* mov.b rm,@rn */
block|{
literal|0x2001
block|,
name|STORE
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* mov.w rm,@rn */
block|{
literal|0x2002
block|,
name|STORE
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* mov.l rm,@rn */
block|{
literal|0x2004
block|,
name|STORE
operator||
name|SETS1
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* mov.b rm,@-rn */
block|{
literal|0x2005
block|,
name|STORE
operator||
name|SETS1
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* mov.w rm,@-rn */
block|{
literal|0x2006
block|,
name|STORE
operator||
name|SETS1
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* mov.l rm,@-rn */
block|{
literal|0x2007
block|,
name|SETSSP
operator||
name|USES1
operator||
name|USES2
operator||
name|USESSP
block|}
block|,
comment|/* div0s */
block|{
literal|0x2008
block|,
name|SETSSP
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* tst rm,rn */
block|{
literal|0x2009
block|,
name|SETS1
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* and rm,rn */
block|{
literal|0x200a
block|,
name|SETS1
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* xor rm,rn */
block|{
literal|0x200b
block|,
name|SETS1
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* or rm,rn */
block|{
literal|0x200c
block|,
name|SETSSP
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* cmp/str rm,rn */
block|{
literal|0x200d
block|,
name|SETS1
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* xtrct rm,rn */
block|{
literal|0x200e
block|,
name|SETSSP
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* mulu.w rm,rn */
block|{
literal|0x200f
block|,
name|SETSSP
operator||
name|USES1
operator||
name|USES2
block|}
comment|/* muls.w rm,rn */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_minor_opcode
name|sh_opcode2
index|[]
init|=
block|{
block|{
name|MAP
argument_list|(
name|sh_opcode20
argument_list|)
block|,
literal|0xf00f
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_opcode
name|sh_opcode30
index|[]
init|=
block|{
block|{
literal|0x3000
block|,
name|SETSSP
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* cmp/eq rm,rn */
block|{
literal|0x3002
block|,
name|SETSSP
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* cmp/hs rm,rn */
block|{
literal|0x3003
block|,
name|SETSSP
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* cmp/ge rm,rn */
block|{
literal|0x3004
block|,
name|SETSSP
operator||
name|USESSP
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* div1 rm,rn */
block|{
literal|0x3005
block|,
name|SETSSP
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* dmulu.l rm,rn */
block|{
literal|0x3006
block|,
name|SETSSP
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* cmp/hi rm,rn */
block|{
literal|0x3007
block|,
name|SETSSP
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* cmp/gt rm,rn */
block|{
literal|0x3008
block|,
name|SETS1
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* sub rm,rn */
block|{
literal|0x300a
block|,
name|SETS1
operator||
name|SETSSP
operator||
name|USES1
operator||
name|USES2
operator||
name|USESSP
block|}
block|,
comment|/* subc rm,rn */
block|{
literal|0x300b
block|,
name|SETS1
operator||
name|SETSSP
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* subv rm,rn */
block|{
literal|0x300c
block|,
name|SETS1
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* add rm,rn */
block|{
literal|0x300d
block|,
name|SETSSP
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* dmuls.l rm,rn */
block|{
literal|0x300e
block|,
name|SETS1
operator||
name|SETSSP
operator||
name|USES1
operator||
name|USES2
operator||
name|USESSP
block|}
block|,
comment|/* addc rm,rn */
block|{
literal|0x300f
block|,
name|SETS1
operator||
name|SETSSP
operator||
name|USES1
operator||
name|USES2
block|}
comment|/* addv rm,rn */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_minor_opcode
name|sh_opcode3
index|[]
init|=
block|{
block|{
name|MAP
argument_list|(
name|sh_opcode30
argument_list|)
block|,
literal|0xf00f
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_opcode
name|sh_opcode40
index|[]
init|=
block|{
block|{
literal|0x4000
block|,
name|SETS1
operator||
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* shll rn */
block|{
literal|0x4001
block|,
name|SETS1
operator||
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* shlr rn */
block|{
literal|0x4002
block|,
name|STORE
operator||
name|SETS1
operator||
name|USES1
operator||
name|USESSP
block|}
block|,
comment|/* sts.l mach,@-rn */
block|{
literal|0x4003
block|,
name|STORE
operator||
name|SETS1
operator||
name|USES1
operator||
name|USESSP
block|}
block|,
comment|/* stc.l sr,@-rn */
block|{
literal|0x4004
block|,
name|SETS1
operator||
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* rotl rn */
block|{
literal|0x4005
block|,
name|SETS1
operator||
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* rotr rn */
block|{
literal|0x4006
block|,
name|LOAD
operator||
name|SETS1
operator||
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* lds.l @rm+,mach */
block|{
literal|0x4007
block|,
name|LOAD
operator||
name|SETS1
operator||
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* ldc.l @rm+,sr */
block|{
literal|0x4008
block|,
name|SETS1
operator||
name|USES1
block|}
block|,
comment|/* shll2 rn */
block|{
literal|0x4009
block|,
name|SETS1
operator||
name|USES1
block|}
block|,
comment|/* shlr2 rn */
block|{
literal|0x400a
block|,
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* lds rm,mach */
block|{
literal|0x400b
block|,
name|BRANCH
operator||
name|DELAY
operator||
name|USES1
block|}
block|,
comment|/* jsr @rn */
block|{
literal|0x400e
block|,
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* ldc rm,sr */
block|{
literal|0x4010
block|,
name|SETS1
operator||
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* dt rn */
block|{
literal|0x4011
block|,
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* cmp/pz rn */
block|{
literal|0x4012
block|,
name|STORE
operator||
name|SETS1
operator||
name|USES1
operator||
name|USESSP
block|}
block|,
comment|/* sts.l macl,@-rn */
block|{
literal|0x4013
block|,
name|STORE
operator||
name|SETS1
operator||
name|USES1
operator||
name|USESSP
block|}
block|,
comment|/* stc.l gbr,@-rn */
block|{
literal|0x4015
block|,
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* cmp/pl rn */
block|{
literal|0x4016
block|,
name|LOAD
operator||
name|SETS1
operator||
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* lds.l @rm+,macl */
block|{
literal|0x4017
block|,
name|LOAD
operator||
name|SETS1
operator||
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* ldc.l @rm+,gbr */
block|{
literal|0x4018
block|,
name|SETS1
operator||
name|USES1
block|}
block|,
comment|/* shll8 rn */
block|{
literal|0x4019
block|,
name|SETS1
operator||
name|USES1
block|}
block|,
comment|/* shlr8 rn */
block|{
literal|0x401a
block|,
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* lds rm,macl */
block|{
literal|0x401b
block|,
name|LOAD
operator||
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* tas.b @rn */
block|{
literal|0x401e
block|,
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* ldc rm,gbr */
block|{
literal|0x4020
block|,
name|SETS1
operator||
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* shal rn */
block|{
literal|0x4021
block|,
name|SETS1
operator||
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* shar rn */
block|{
literal|0x4022
block|,
name|STORE
operator||
name|SETS1
operator||
name|USES1
operator||
name|USESSP
block|}
block|,
comment|/* sts.l pr,@-rn */
block|{
literal|0x4023
block|,
name|STORE
operator||
name|SETS1
operator||
name|USES1
operator||
name|USESSP
block|}
block|,
comment|/* stc.l vbr,@-rn */
block|{
literal|0x4024
block|,
name|SETS1
operator||
name|SETSSP
operator||
name|USES1
operator||
name|USESSP
block|}
block|,
comment|/* rotcl rn */
block|{
literal|0x4025
block|,
name|SETS1
operator||
name|SETSSP
operator||
name|USES1
operator||
name|USESSP
block|}
block|,
comment|/* rotcr rn */
block|{
literal|0x4026
block|,
name|LOAD
operator||
name|SETS1
operator||
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* lds.l @rm+,pr */
block|{
literal|0x4027
block|,
name|LOAD
operator||
name|SETS1
operator||
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* ldc.l @rm+,vbr */
block|{
literal|0x4028
block|,
name|SETS1
operator||
name|USES1
block|}
block|,
comment|/* shll16 rn */
block|{
literal|0x4029
block|,
name|SETS1
operator||
name|USES1
block|}
block|,
comment|/* shlr16 rn */
block|{
literal|0x402a
block|,
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* lds rm,pr */
block|{
literal|0x402b
block|,
name|BRANCH
operator||
name|DELAY
operator||
name|USES1
block|}
block|,
comment|/* jmp @rn */
block|{
literal|0x402e
block|,
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* ldc rm,vbr */
block|{
literal|0x4033
block|,
name|STORE
operator||
name|SETS1
operator||
name|USES1
operator||
name|USESSP
block|}
block|,
comment|/* stc.l ssr,@-rn */
block|{
literal|0x4037
block|,
name|LOAD
operator||
name|SETS1
operator||
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* ldc.l @rm+,ssr */
block|{
literal|0x403e
block|,
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* ldc rm,ssr */
block|{
literal|0x4043
block|,
name|STORE
operator||
name|SETS1
operator||
name|USES1
operator||
name|USESSP
block|}
block|,
comment|/* stc.l spc,@-rn */
block|{
literal|0x4047
block|,
name|LOAD
operator||
name|SETS1
operator||
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* ldc.l @rm+,spc */
block|{
literal|0x404e
block|,
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* ldc rm,spc */
block|{
literal|0x4052
block|,
name|STORE
operator||
name|SETS1
operator||
name|USES1
operator||
name|USESSP
block|}
block|,
comment|/* sts.l fpul,@-rn */
block|{
literal|0x4056
block|,
name|LOAD
operator||
name|SETS1
operator||
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* lds.l @rm+,fpul */
block|{
literal|0x405a
block|,
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* lds.l rm,fpul */
block|{
literal|0x4062
block|,
name|STORE
operator||
name|SETS1
operator||
name|USES1
operator||
name|USESSP
block|}
block|,
comment|/* sts.l fpscr,@-rn */
block|{
literal|0x4066
block|,
name|LOAD
operator||
name|SETS1
operator||
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* lds.l @rm+,fpscr */
block|{
literal|0x406a
block|,
name|SETSSP
operator||
name|USES1
block|}
comment|/* lds rm,fpscr */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_opcode
name|sh_opcode41
index|[]
init|=
block|{
block|{
literal|0x4083
block|,
name|STORE
operator||
name|SETS1
operator||
name|USES1
operator||
name|USESSP
block|}
block|,
comment|/* stc.l rx_bank,@-rn */
block|{
literal|0x4087
block|,
name|LOAD
operator||
name|SETS1
operator||
name|SETSSP
operator||
name|USES1
block|}
block|,
comment|/* ldc.l @rm+,rx_bank */
block|{
literal|0x408e
block|,
name|SETSSP
operator||
name|USES1
block|}
comment|/* ldc rm,rx_bank */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_opcode
name|sh_opcode42
index|[]
init|=
block|{
block|{
literal|0x400c
block|,
name|SETS1
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* shad rm,rn */
block|{
literal|0x400d
block|,
name|SETS1
operator||
name|USES1
operator||
name|USES2
block|}
block|,
comment|/* shld rm,rn */
block|{
literal|0x400f
block|,
name|LOAD
operator||
name|SETS1
operator||
name|SETS2
operator||
name|SETSSP
operator||
name|USES1
operator||
name|USES2
operator||
name|USESSP
block|}
block|,
comment|/* mac.w @rm+,@rn+ */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_minor_opcode
name|sh_opcode4
index|[]
init|=
block|{
block|{
name|MAP
argument_list|(
name|sh_opcode40
argument_list|)
block|,
literal|0xf0ff
block|}
block|,
block|{
name|MAP
argument_list|(
name|sh_opcode41
argument_list|)
block|,
literal|0xf08f
block|}
block|,
block|{
name|MAP
argument_list|(
name|sh_opcode42
argument_list|)
block|,
literal|0xf00f
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_opcode
name|sh_opcode50
index|[]
init|=
block|{
block|{
literal|0x5000
block|,
name|LOAD
operator||
name|SETS1
operator||
name|USES2
block|}
comment|/* mov.l @(disp,rm),rn */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_minor_opcode
name|sh_opcode5
index|[]
init|=
block|{
block|{
name|MAP
argument_list|(
name|sh_opcode50
argument_list|)
block|,
literal|0xf000
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_opcode
name|sh_opcode60
index|[]
init|=
block|{
block|{
literal|0x6000
block|,
name|LOAD
operator||
name|SETS1
operator||
name|USES2
block|}
block|,
comment|/* mov.b @rm,rn */
block|{
literal|0x6001
block|,
name|LOAD
operator||
name|SETS1
operator||
name|USES2
block|}
block|,
comment|/* mov.w @rm,rn */
block|{
literal|0x6002
block|,
name|LOAD
operator||
name|SETS1
operator||
name|USES2
block|}
block|,
comment|/* mov.l @rm,rn */
block|{
literal|0x6003
block|,
name|SETS1
operator||
name|USES2
block|}
block|,
comment|/* mov rm,rn */
block|{
literal|0x6004
block|,
name|LOAD
operator||
name|SETS1
operator||
name|SETS2
operator||
name|USES2
block|}
block|,
comment|/* mov.b @rm+,rn */
block|{
literal|0x6005
block|,
name|LOAD
operator||
name|SETS1
operator||
name|SETS2
operator||
name|USES2
block|}
block|,
comment|/* mov.w @rm+,rn */
block|{
literal|0x6006
block|,
name|LOAD
operator||
name|SETS1
operator||
name|SETS2
operator||
name|USES2
block|}
block|,
comment|/* mov.l @rm+,rn */
block|{
literal|0x6007
block|,
name|SETS1
operator||
name|USES2
block|}
block|,
comment|/* not rm,rn */
block|{
literal|0x6008
block|,
name|SETS1
operator||
name|USES2
block|}
block|,
comment|/* swap.b rm,rn */
block|{
literal|0x6009
block|,
name|SETS1
operator||
name|USES2
block|}
block|,
comment|/* swap.w rm,rn */
block|{
literal|0x600a
block|,
name|SETS1
operator||
name|SETSSP
operator||
name|USES2
operator||
name|USESSP
block|}
block|,
comment|/* negc rm,rn */
block|{
literal|0x600b
block|,
name|SETS1
operator||
name|USES2
block|}
block|,
comment|/* neg rm,rn */
block|{
literal|0x600c
block|,
name|SETS1
operator||
name|USES2
block|}
block|,
comment|/* extu.b rm,rn */
block|{
literal|0x600d
block|,
name|SETS1
operator||
name|USES2
block|}
block|,
comment|/* extu.w rm,rn */
block|{
literal|0x600e
block|,
name|SETS1
operator||
name|USES2
block|}
block|,
comment|/* exts.b rm,rn */
block|{
literal|0x600f
block|,
name|SETS1
operator||
name|USES2
block|}
comment|/* exts.w rm,rn */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_minor_opcode
name|sh_opcode6
index|[]
init|=
block|{
block|{
name|MAP
argument_list|(
name|sh_opcode60
argument_list|)
block|,
literal|0xf00f
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_opcode
name|sh_opcode70
index|[]
init|=
block|{
block|{
literal|0x7000
block|,
name|SETS1
operator||
name|USES1
block|}
comment|/* add #imm,rn */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_minor_opcode
name|sh_opcode7
index|[]
init|=
block|{
block|{
name|MAP
argument_list|(
name|sh_opcode70
argument_list|)
block|,
literal|0xf000
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_opcode
name|sh_opcode80
index|[]
init|=
block|{
block|{
literal|0x8000
block|,
name|STORE
operator||
name|USES2
operator||
name|USESR0
block|}
block|,
comment|/* mov.b r0,@(disp,rn) */
block|{
literal|0x8100
block|,
name|STORE
operator||
name|USES2
operator||
name|USESR0
block|}
block|,
comment|/* mov.w r0,@(disp,rn) */
block|{
literal|0x8400
block|,
name|LOAD
operator||
name|SETSR0
operator||
name|USES2
block|}
block|,
comment|/* mov.b @(disp,rm),r0 */
block|{
literal|0x8500
block|,
name|LOAD
operator||
name|SETSR0
operator||
name|USES2
block|}
block|,
comment|/* mov.w @(disp,rn),r0 */
block|{
literal|0x8800
block|,
name|SETSSP
operator||
name|USESR0
block|}
block|,
comment|/* cmp/eq #imm,r0 */
block|{
literal|0x8900
block|,
name|BRANCH
operator||
name|USESSP
block|}
block|,
comment|/* bt label */
block|{
literal|0x8b00
block|,
name|BRANCH
operator||
name|USESSP
block|}
block|,
comment|/* bf label */
block|{
literal|0x8d00
block|,
name|BRANCH
operator||
name|DELAY
operator||
name|USESSP
block|}
block|,
comment|/* bt/s label */
block|{
literal|0x8f00
block|,
name|BRANCH
operator||
name|DELAY
operator||
name|USESSP
block|}
comment|/* bf/s label */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_minor_opcode
name|sh_opcode8
index|[]
init|=
block|{
block|{
name|MAP
argument_list|(
name|sh_opcode80
argument_list|)
block|,
literal|0xff00
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_opcode
name|sh_opcode90
index|[]
init|=
block|{
block|{
literal|0x9000
block|,
name|LOAD
operator||
name|SETS1
block|}
comment|/* mov.w @(disp,pc),rn */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_minor_opcode
name|sh_opcode9
index|[]
init|=
block|{
block|{
name|MAP
argument_list|(
name|sh_opcode90
argument_list|)
block|,
literal|0xf000
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_opcode
name|sh_opcodea0
index|[]
init|=
block|{
block|{
literal|0xa000
block|,
name|BRANCH
operator||
name|DELAY
block|}
comment|/* bra label */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_minor_opcode
name|sh_opcodea
index|[]
init|=
block|{
block|{
name|MAP
argument_list|(
name|sh_opcodea0
argument_list|)
block|,
literal|0xf000
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_opcode
name|sh_opcodeb0
index|[]
init|=
block|{
block|{
literal|0xb000
block|,
name|BRANCH
operator||
name|DELAY
block|}
comment|/* bsr label */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_minor_opcode
name|sh_opcodeb
index|[]
init|=
block|{
block|{
name|MAP
argument_list|(
name|sh_opcodeb0
argument_list|)
block|,
literal|0xf000
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_opcode
name|sh_opcodec0
index|[]
init|=
block|{
block|{
literal|0xc000
block|,
name|STORE
operator||
name|USESR0
operator||
name|USESSP
block|}
block|,
comment|/* mov.b r0,@(disp,gbr) */
block|{
literal|0xc100
block|,
name|STORE
operator||
name|USESR0
operator||
name|USESSP
block|}
block|,
comment|/* mov.w r0,@(disp,gbr) */
block|{
literal|0xc200
block|,
name|STORE
operator||
name|USESR0
operator||
name|USESSP
block|}
block|,
comment|/* mov.l r0,@(disp,gbr) */
block|{
literal|0xc300
block|,
name|BRANCH
operator||
name|USESSP
block|}
block|,
comment|/* trapa #imm */
block|{
literal|0xc400
block|,
name|LOAD
operator||
name|SETSR0
operator||
name|USESSP
block|}
block|,
comment|/* mov.b @(disp,gbr),r0 */
block|{
literal|0xc500
block|,
name|LOAD
operator||
name|SETSR0
operator||
name|USESSP
block|}
block|,
comment|/* mov.w @(disp,gbr),r0 */
block|{
literal|0xc600
block|,
name|LOAD
operator||
name|SETSR0
operator||
name|USESSP
block|}
block|,
comment|/* mov.l @(disp,gbr),r0 */
block|{
literal|0xc700
block|,
name|SETSR0
block|}
block|,
comment|/* mova @(disp,pc),r0 */
block|{
literal|0xc800
block|,
name|SETSSP
operator||
name|USESR0
block|}
block|,
comment|/* tst #imm,r0 */
block|{
literal|0xc900
block|,
name|SETSR0
operator||
name|USESR0
block|}
block|,
comment|/* and #imm,r0 */
block|{
literal|0xca00
block|,
name|SETSR0
operator||
name|USESR0
block|}
block|,
comment|/* xor #imm,r0 */
block|{
literal|0xcb00
block|,
name|SETSR0
operator||
name|USESR0
block|}
block|,
comment|/* or #imm,r0 */
block|{
literal|0xcc00
block|,
name|LOAD
operator||
name|SETSSP
operator||
name|USESR0
operator||
name|USESSP
block|}
block|,
comment|/* tst.b #imm,@(r0,gbr) */
block|{
literal|0xcd00
block|,
name|LOAD
operator||
name|STORE
operator||
name|USESR0
operator||
name|USESSP
block|}
block|,
comment|/* and.b #imm,@(r0,gbr) */
block|{
literal|0xce00
block|,
name|LOAD
operator||
name|STORE
operator||
name|USESR0
operator||
name|USESSP
block|}
block|,
comment|/* xor.b #imm,@(r0,gbr) */
block|{
literal|0xcf00
block|,
name|LOAD
operator||
name|STORE
operator||
name|USESR0
operator||
name|USESSP
block|}
comment|/* or.b #imm,@(r0,gbr) */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_minor_opcode
name|sh_opcodec
index|[]
init|=
block|{
block|{
name|MAP
argument_list|(
name|sh_opcodec0
argument_list|)
block|,
literal|0xff00
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_opcode
name|sh_opcoded0
index|[]
init|=
block|{
block|{
literal|0xd000
block|,
name|LOAD
operator||
name|SETS1
block|}
comment|/* mov.l @(disp,pc),rn */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_minor_opcode
name|sh_opcoded
index|[]
init|=
block|{
block|{
name|MAP
argument_list|(
name|sh_opcoded0
argument_list|)
block|,
literal|0xf000
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_opcode
name|sh_opcodee0
index|[]
init|=
block|{
block|{
literal|0xe000
block|,
name|SETS1
block|}
comment|/* mov #imm,rn */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_minor_opcode
name|sh_opcodee
index|[]
init|=
block|{
block|{
name|MAP
argument_list|(
name|sh_opcodee0
argument_list|)
block|,
literal|0xf000
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_opcode
name|sh_opcodef0
index|[]
init|=
block|{
block|{
literal|0xf000
block|,
name|SETSF1
operator||
name|USESF1
operator||
name|USESF2
block|}
block|,
comment|/* fadd fm,fn */
block|{
literal|0xf001
block|,
name|SETSF1
operator||
name|USESF1
operator||
name|USESF2
block|}
block|,
comment|/* fsub fm,fn */
block|{
literal|0xf002
block|,
name|SETSF1
operator||
name|USESF1
operator||
name|USESF2
block|}
block|,
comment|/* fmul fm,fn */
block|{
literal|0xf003
block|,
name|SETSF1
operator||
name|USESF1
operator||
name|USESF2
block|}
block|,
comment|/* fdiv fm,fn */
block|{
literal|0xf004
block|,
name|SETSSP
operator||
name|USESF1
operator||
name|USESF2
block|}
block|,
comment|/* fcmp/eq fm,fn */
block|{
literal|0xf005
block|,
name|SETSSP
operator||
name|USESF1
operator||
name|USESF2
block|}
block|,
comment|/* fcmp/gt fm,fn */
block|{
literal|0xf006
block|,
name|LOAD
operator||
name|SETSF1
operator||
name|USES2
operator||
name|USESR0
block|}
block|,
comment|/* fmov.s @(r0,rm),fn */
block|{
literal|0xf007
block|,
name|STORE
operator||
name|USES1
operator||
name|USESF2
operator||
name|USESR0
block|}
block|,
comment|/* fmov.s fm,@(r0,rn) */
block|{
literal|0xf008
block|,
name|LOAD
operator||
name|SETSF1
operator||
name|USES2
block|}
block|,
comment|/* fmov.s @rm,fn */
block|{
literal|0xf009
block|,
name|LOAD
operator||
name|SETS2
operator||
name|SETSF1
operator||
name|USES2
block|}
block|,
comment|/* fmov.s @rm+,fn */
block|{
literal|0xf00a
block|,
name|STORE
operator||
name|USES1
operator||
name|USESF2
block|}
block|,
comment|/* fmov.s fm,@rn */
block|{
literal|0xf00b
block|,
name|STORE
operator||
name|SETS1
operator||
name|USES1
operator||
name|USESF2
block|}
block|,
comment|/* fmov.s fm,@-rn */
block|{
literal|0xf00c
block|,
name|SETSF1
operator||
name|USESF2
block|}
block|,
comment|/* fmov fm,fn */
block|{
literal|0xf00e
block|,
name|SETSF1
operator||
name|USESF1
operator||
name|USESF2
operator||
name|USESF0
block|}
comment|/* fmac f0,fm,fn */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_opcode
name|sh_opcodef1
index|[]
init|=
block|{
block|{
literal|0xf00d
block|,
name|SETSF1
operator||
name|USESSP
block|}
block|,
comment|/* fsts fpul,fn */
block|{
literal|0xf01d
block|,
name|SETSSP
operator||
name|USESF1
block|}
block|,
comment|/* flds fn,fpul */
block|{
literal|0xf02d
block|,
name|SETSF1
operator||
name|USESSP
block|}
block|,
comment|/* float fpul,fn */
block|{
literal|0xf03d
block|,
name|SETSSP
operator||
name|USESF1
block|}
block|,
comment|/* ftrc fn,fpul */
block|{
literal|0xf04d
block|,
name|SETSF1
operator||
name|USESF1
block|}
block|,
comment|/* fneg fn */
block|{
literal|0xf05d
block|,
name|SETSF1
operator||
name|USESF1
block|}
block|,
comment|/* fabs fn */
block|{
literal|0xf06d
block|,
name|SETSF1
operator||
name|USESF1
block|}
block|,
comment|/* fsqrt fn */
block|{
literal|0xf07d
block|,
name|SETSSP
operator||
name|USESF1
block|}
block|,
comment|/* ftst/nan fn */
block|{
literal|0xf08d
block|,
name|SETSF1
block|}
block|,
comment|/* fldi0 fn */
block|{
literal|0xf09d
block|,
name|SETSF1
block|}
comment|/* fldi1 fn */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_minor_opcode
name|sh_opcodef
index|[]
init|=
block|{
block|{
name|MAP
argument_list|(
name|sh_opcodef0
argument_list|)
block|,
literal|0xf00f
block|}
block|,
block|{
name|MAP
argument_list|(
name|sh_opcodef1
argument_list|)
block|,
literal|0xf0ff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sh_major_opcode
name|sh_opcodes
index|[]
init|=
block|{
block|{
name|MAP
argument_list|(
argument|sh_opcode0
argument_list|)
block|}
block|,
block|{
name|MAP
argument_list|(
argument|sh_opcode1
argument_list|)
block|}
block|,
block|{
name|MAP
argument_list|(
argument|sh_opcode2
argument_list|)
block|}
block|,
block|{
name|MAP
argument_list|(
argument|sh_opcode3
argument_list|)
block|}
block|,
block|{
name|MAP
argument_list|(
argument|sh_opcode4
argument_list|)
block|}
block|,
block|{
name|MAP
argument_list|(
argument|sh_opcode5
argument_list|)
block|}
block|,
block|{
name|MAP
argument_list|(
argument|sh_opcode6
argument_list|)
block|}
block|,
block|{
name|MAP
argument_list|(
argument|sh_opcode7
argument_list|)
block|}
block|,
block|{
name|MAP
argument_list|(
argument|sh_opcode8
argument_list|)
block|}
block|,
block|{
name|MAP
argument_list|(
argument|sh_opcode9
argument_list|)
block|}
block|,
block|{
name|MAP
argument_list|(
argument|sh_opcodea
argument_list|)
block|}
block|,
block|{
name|MAP
argument_list|(
argument|sh_opcodeb
argument_list|)
block|}
block|,
block|{
name|MAP
argument_list|(
argument|sh_opcodec
argument_list|)
block|}
block|,
block|{
name|MAP
argument_list|(
argument|sh_opcoded
argument_list|)
block|}
block|,
block|{
name|MAP
argument_list|(
argument|sh_opcodee
argument_list|)
block|}
block|,
block|{
name|MAP
argument_list|(
argument|sh_opcodef
argument_list|)
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given an instruction, return a pointer to the corresponding    sh_opcode structure.  Return NULL if the instruction is not    recognized.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|sh_opcode
modifier|*
name|sh_insn_info
parameter_list|(
name|insn
parameter_list|)
name|unsigned
name|int
name|insn
decl_stmt|;
block|{
specifier|const
name|struct
name|sh_major_opcode
modifier|*
name|maj
decl_stmt|;
specifier|const
name|struct
name|sh_minor_opcode
modifier|*
name|min
decl_stmt|,
modifier|*
name|minend
decl_stmt|;
name|maj
operator|=
operator|&
name|sh_opcodes
index|[
operator|(
name|insn
operator|&
literal|0xf000
operator|)
operator|>>
literal|12
index|]
expr_stmt|;
name|min
operator|=
name|maj
operator|->
name|minor_opcodes
expr_stmt|;
name|minend
operator|=
name|min
operator|+
name|maj
operator|->
name|count
expr_stmt|;
for|for
control|(
init|;
name|min
operator|<
name|minend
condition|;
name|min
operator|++
control|)
block|{
name|unsigned
name|int
name|l
decl_stmt|;
specifier|const
name|struct
name|sh_opcode
modifier|*
name|op
decl_stmt|,
modifier|*
name|opend
decl_stmt|;
name|l
operator|=
name|insn
operator|&
name|min
operator|->
name|mask
expr_stmt|;
name|op
operator|=
name|min
operator|->
name|opcodes
expr_stmt|;
name|opend
operator|=
name|op
operator|+
name|min
operator|->
name|count
expr_stmt|;
comment|/* Since the opcodes tables are sorted, we could use a binary          search here if the count were above some cutoff value.  */
for|for
control|(
init|;
name|op
operator|<
name|opend
condition|;
name|op
operator|++
control|)
if|if
condition|(
name|op
operator|->
name|opcode
operator|==
name|l
condition|)
return|return
name|op
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* See whether an instruction uses a general purpose register.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_insn_uses_reg
parameter_list|(
name|insn
parameter_list|,
name|op
parameter_list|,
name|reg
parameter_list|)
name|unsigned
name|int
name|insn
decl_stmt|;
specifier|const
name|struct
name|sh_opcode
modifier|*
name|op
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
block|{
name|unsigned
name|int
name|f
decl_stmt|;
name|f
operator|=
name|op
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|&
name|USES1
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|insn
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
operator|)
operator|==
name|reg
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|(
name|f
operator|&
name|USES2
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|insn
operator|&
literal|0x00f0
operator|)
operator|>>
literal|4
operator|)
operator|==
name|reg
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|(
name|f
operator|&
name|USESR0
operator|)
operator|!=
literal|0
operator|&&
name|reg
operator|==
literal|0
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* See whether an instruction uses a floating point register.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_insn_uses_freg
parameter_list|(
name|insn
parameter_list|,
name|op
parameter_list|,
name|freg
parameter_list|)
name|unsigned
name|int
name|insn
decl_stmt|;
specifier|const
name|struct
name|sh_opcode
modifier|*
name|op
decl_stmt|;
name|unsigned
name|int
name|freg
decl_stmt|;
block|{
name|unsigned
name|int
name|f
decl_stmt|;
name|f
operator|=
name|op
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|&
name|USESF1
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|insn
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
operator|)
operator|==
name|freg
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|(
name|f
operator|&
name|USESF2
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|insn
operator|&
literal|0x00f0
operator|)
operator|>>
literal|4
operator|)
operator|==
name|freg
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|(
name|f
operator|&
name|USESF0
operator|)
operator|!=
literal|0
operator|&&
name|freg
operator|==
literal|0
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* See whether instructions I1 and I2 conflict, assuming I1 comes    before I2.  OP1 and OP2 are the corresponding sh_opcode structures.    This should return true if there is a conflict, or false if the    instructions can be swapped safely.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_insns_conflict
parameter_list|(
name|i1
parameter_list|,
name|op1
parameter_list|,
name|i2
parameter_list|,
name|op2
parameter_list|)
name|unsigned
name|int
name|i1
decl_stmt|;
specifier|const
name|struct
name|sh_opcode
modifier|*
name|op1
decl_stmt|;
name|unsigned
name|int
name|i2
decl_stmt|;
specifier|const
name|struct
name|sh_opcode
modifier|*
name|op2
decl_stmt|;
block|{
name|unsigned
name|int
name|f1
decl_stmt|,
name|f2
decl_stmt|;
name|f1
operator|=
name|op1
operator|->
name|flags
expr_stmt|;
name|f2
operator|=
name|op2
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|(
name|f1
operator|&
operator|(
name|BRANCH
operator||
name|DELAY
operator|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|f2
operator|&
operator|(
name|BRANCH
operator||
name|DELAY
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|(
name|f1
operator|&
name|SETSSP
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|f2
operator|&
name|USESSP
operator|)
operator|!=
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|(
name|f2
operator|&
name|SETSSP
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|f1
operator|&
name|USESSP
operator|)
operator|!=
literal|0
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|(
name|f1
operator|&
name|SETS1
operator|)
operator|!=
literal|0
operator|&&
name|sh_insn_uses_reg
argument_list|(
name|i2
argument_list|,
name|op2
argument_list|,
operator|(
name|i1
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|(
name|f1
operator|&
name|SETS2
operator|)
operator|!=
literal|0
operator|&&
name|sh_insn_uses_reg
argument_list|(
name|i2
argument_list|,
name|op2
argument_list|,
operator|(
name|i1
operator|&
literal|0x00f0
operator|)
operator|>>
literal|4
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|(
name|f1
operator|&
name|SETSR0
operator|)
operator|!=
literal|0
operator|&&
name|sh_insn_uses_reg
argument_list|(
name|i2
argument_list|,
name|op2
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|(
name|f1
operator|&
name|SETSF1
operator|)
operator|!=
literal|0
operator|&&
name|sh_insn_uses_freg
argument_list|(
name|i2
argument_list|,
name|op2
argument_list|,
operator|(
name|i1
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|(
name|f2
operator|&
name|SETS1
operator|)
operator|!=
literal|0
operator|&&
name|sh_insn_uses_reg
argument_list|(
name|i1
argument_list|,
name|op1
argument_list|,
operator|(
name|i2
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|(
name|f2
operator|&
name|SETS2
operator|)
operator|!=
literal|0
operator|&&
name|sh_insn_uses_reg
argument_list|(
name|i1
argument_list|,
name|op1
argument_list|,
operator|(
name|i2
operator|&
literal|0x00f0
operator|)
operator|>>
literal|4
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|(
name|f2
operator|&
name|SETSR0
operator|)
operator|!=
literal|0
operator|&&
name|sh_insn_uses_reg
argument_list|(
name|i1
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|(
name|f2
operator|&
name|SETSF1
operator|)
operator|!=
literal|0
operator|&&
name|sh_insn_uses_freg
argument_list|(
name|i1
argument_list|,
name|op1
argument_list|,
operator|(
name|i2
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* The instructions do not conflict.  */
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* I1 is a load instruction, and I2 is some other instruction.  Return    true if I1 loads a register which I2 uses.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_load_use
parameter_list|(
name|i1
parameter_list|,
name|op1
parameter_list|,
name|i2
parameter_list|,
name|op2
parameter_list|)
name|unsigned
name|int
name|i1
decl_stmt|;
specifier|const
name|struct
name|sh_opcode
modifier|*
name|op1
decl_stmt|;
name|unsigned
name|int
name|i2
decl_stmt|;
specifier|const
name|struct
name|sh_opcode
modifier|*
name|op2
decl_stmt|;
block|{
name|unsigned
name|int
name|f1
decl_stmt|;
name|f1
operator|=
name|op1
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|(
name|f1
operator|&
name|LOAD
operator|)
operator|==
literal|0
condition|)
return|return
name|false
return|;
comment|/* If both SETS1 and SETSSP are set, that means a load to a special      register using postincrement addressing mode, which we don't care      about here.  */
if|if
condition|(
operator|(
name|f1
operator|&
name|SETS1
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|f1
operator|&
name|SETSSP
operator|)
operator|==
literal|0
operator|&&
name|sh_insn_uses_reg
argument_list|(
name|i2
argument_list|,
name|op2
argument_list|,
operator|(
name|i1
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|(
name|f1
operator|&
name|SETSR0
operator|)
operator|!=
literal|0
operator|&&
name|sh_insn_uses_reg
argument_list|(
name|i2
argument_list|,
name|op2
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|(
name|f1
operator|&
name|SETSF1
operator|)
operator|!=
literal|0
operator|&&
name|sh_insn_uses_freg
argument_list|(
name|i2
argument_list|,
name|op2
argument_list|,
operator|(
name|i1
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Try to align loads and stores within a span of memory.  This is    called by both the ELF and the COFF sh targets.  ABFD and SEC are    the BFD and section we are examining.  CONTENTS is the contents of    the section.  SWAP is the routine to call to swap two instructions.    RELOCS is a pointer to the internal relocation information, to be    passed to SWAP.  PLABEL is a pointer to the current label in a    sorted list of labels; LABEL_END is the end of the list.  START and    STOP are the range of memory to examine.  If a swap is made,    *PSWAPPED is set to true.  */
end_comment

begin_function_decl
name|boolean
name|_bfd_sh_align_load_span
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|contents
parameter_list|,
name|swap
parameter_list|,
name|relocs
parameter_list|,
name|plabel
parameter_list|,
name|label_end
parameter_list|,
name|start
parameter_list|,
name|stop
parameter_list|,
name|pswapped
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
function_decl|boolean
parameter_list|(
function_decl|*swap
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|,
name|bfd_byte
operator|*
operator|,
name|bfd_vma
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|PTR
name|relocs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_vma
modifier|*
modifier|*
name|plabel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_vma
modifier|*
name|label_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_vma
name|start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bfd_vma
name|stop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
modifier|*
name|pswapped
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bfd_vma
name|i
decl_stmt|;
comment|/* Instructions should be aligned on 2 byte boundaries.  */
if|if
condition|(
operator|(
name|start
operator|&
literal|1
operator|)
operator|==
literal|1
condition|)
operator|++
name|start
expr_stmt|;
comment|/* Now look through the unaligned addresses.  */
name|i
operator|=
name|start
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
literal|2
operator|)
operator|==
literal|0
condition|)
name|i
operator|+=
literal|2
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|stop
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|unsigned
name|int
name|insn
decl_stmt|;
specifier|const
name|struct
name|sh_opcode
modifier|*
name|op
decl_stmt|;
name|unsigned
name|int
name|prev_insn
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|sh_opcode
modifier|*
name|prev_op
init|=
name|NULL
decl_stmt|;
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|i
argument_list|)
expr_stmt|;
name|op
operator|=
name|sh_insn_info
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|NULL
operator|||
operator|(
name|op
operator|->
name|flags
operator|&
operator|(
name|LOAD
operator||
name|STORE
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* This is a load or store which is not on a four byte boundary.  */
while|while
condition|(
operator|*
name|plabel
operator|<
name|label_end
operator|&&
operator|*
operator|*
name|plabel
operator|<
name|i
condition|)
operator|++
operator|*
name|plabel
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|start
condition|)
block|{
name|prev_insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|i
operator|-
literal|2
argument_list|)
expr_stmt|;
name|prev_op
operator|=
name|sh_insn_info
argument_list|(
name|prev_insn
argument_list|)
expr_stmt|;
comment|/* If the load/store instruction is in a delay slot, we 	     can't swap.  */
if|if
condition|(
name|prev_op
operator|==
name|NULL
operator|||
operator|(
name|prev_op
operator|->
name|flags
operator|&
name|DELAY
operator|)
operator|!=
literal|0
condition|)
continue|continue;
block|}
if|if
condition|(
name|i
operator|>
name|start
operator|&&
operator|(
operator|*
name|plabel
operator|>=
name|label_end
operator|||
operator|*
operator|*
name|plabel
operator|!=
name|i
operator|)
operator|&&
name|prev_op
operator|!=
name|NULL
operator|&&
operator|(
name|prev_op
operator|->
name|flags
operator|&
operator|(
name|LOAD
operator||
name|STORE
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|!
name|sh_insns_conflict
argument_list|(
name|prev_insn
argument_list|,
name|prev_op
argument_list|,
name|insn
argument_list|,
name|op
argument_list|)
condition|)
block|{
name|boolean
name|ok
decl_stmt|;
comment|/* The load/store instruction does not have a label, and 	     there is a previous instruction; PREV_INSN is not 	     itself a load/store instruction, and PREV_INSN and 	     INSN do not conflict.  */
name|ok
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|start
operator|+
literal|4
condition|)
block|{
name|unsigned
name|int
name|prev2_insn
decl_stmt|;
specifier|const
name|struct
name|sh_opcode
modifier|*
name|prev2_op
decl_stmt|;
name|prev2_insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|i
operator|-
literal|4
argument_list|)
expr_stmt|;
name|prev2_op
operator|=
name|sh_insn_info
argument_list|(
name|prev2_insn
argument_list|)
expr_stmt|;
comment|/* If the instruction before PREV_INSN has a delay 		 slot--that is, PREV_INSN is in a delay slot--we 		 can not swap.  */
if|if
condition|(
name|prev2_op
operator|==
name|NULL
operator|||
operator|(
name|prev2_op
operator|->
name|flags
operator|&
name|DELAY
operator|)
operator|!=
literal|0
condition|)
name|ok
operator|=
name|false
expr_stmt|;
comment|/* If the instruction before PREV_INSN is a load, 		 and it sets a register which INSN uses, then 		 putting INSN immediately after PREV_INSN will 		 cause a pipeline bubble, so there is no point to 		 making the swap.  */
if|if
condition|(
name|ok
operator|&&
operator|(
name|prev2_op
operator|->
name|flags
operator|&
name|LOAD
operator|)
operator|!=
literal|0
operator|&&
name|sh_load_use
argument_list|(
name|prev2_insn
argument_list|,
name|prev2_op
argument_list|,
name|insn
argument_list|,
name|op
argument_list|)
condition|)
name|ok
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|swap
call|)
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|relocs
argument_list|,
name|contents
argument_list|,
name|i
operator|-
literal|2
argument_list|)
condition|)
return|return
name|false
return|;
operator|*
name|pswapped
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
block|}
while|while
condition|(
operator|*
name|plabel
operator|<
name|label_end
operator|&&
operator|*
operator|*
name|plabel
operator|<
name|i
operator|+
literal|2
condition|)
operator|++
operator|*
name|plabel
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|2
operator|<
name|stop
operator|&&
operator|(
operator|*
name|plabel
operator|>=
name|label_end
operator|||
operator|*
operator|*
name|plabel
operator|!=
name|i
operator|+
literal|2
operator|)
condition|)
block|{
name|unsigned
name|int
name|next_insn
decl_stmt|;
specifier|const
name|struct
name|sh_opcode
modifier|*
name|next_op
decl_stmt|;
comment|/* There is an instruction after the load/store 	     instruction, and it does not have a label.  */
name|next_insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|i
operator|+
literal|2
argument_list|)
expr_stmt|;
name|next_op
operator|=
name|sh_insn_info
argument_list|(
name|next_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_op
operator|!=
name|NULL
operator|&&
operator|(
name|next_op
operator|->
name|flags
operator|&
operator|(
name|LOAD
operator||
name|STORE
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|!
name|sh_insns_conflict
argument_list|(
name|insn
argument_list|,
name|op
argument_list|,
name|next_insn
argument_list|,
name|next_op
argument_list|)
condition|)
block|{
name|boolean
name|ok
decl_stmt|;
comment|/* NEXT_INSN is not itself a load/store instruction, 		 and it does not conflict with INSN.  */
name|ok
operator|=
name|true
expr_stmt|;
comment|/* If PREV_INSN is a load, and it sets a register 		 which NEXT_INSN uses, then putting NEXT_INSN 		 immediately after PREV_INSN will cause a pipeline 		 bubble, so there is no reason to make this swap.  */
if|if
condition|(
name|prev_op
operator|!=
name|NULL
operator|&&
operator|(
name|prev_op
operator|->
name|flags
operator|&
name|LOAD
operator|)
operator|!=
literal|0
operator|&&
name|sh_load_use
argument_list|(
name|prev_insn
argument_list|,
name|prev_op
argument_list|,
name|next_insn
argument_list|,
name|next_op
argument_list|)
condition|)
name|ok
operator|=
name|false
expr_stmt|;
comment|/* If INSN is a load, and it sets a register which 		 the insn after NEXT_INSN uses, then doing the 		 swap will cause a pipeline bubble, so there is no 		 reason to make the swap.  However, if the insn 		 after NEXT_INSN is itself a load or store 		 instruction, then it is misaligned, so 		 optimistically hope that it will be swapped 		 itself, and just live with the pipeline bubble if 		 it isn't.  */
if|if
condition|(
name|ok
operator|&&
name|i
operator|+
literal|4
operator|<
name|stop
operator|&&
operator|(
name|op
operator|->
name|flags
operator|&
name|LOAD
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|next2_insn
decl_stmt|;
specifier|const
name|struct
name|sh_opcode
modifier|*
name|next2_op
decl_stmt|;
name|next2_insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|i
operator|+
literal|4
argument_list|)
expr_stmt|;
name|next2_op
operator|=
name|sh_insn_info
argument_list|(
name|next2_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|next2_op
operator|->
name|flags
operator|&
operator|(
name|LOAD
operator||
name|STORE
operator|)
operator|)
operator|==
literal|0
operator|&&
name|sh_load_use
argument_list|(
name|insn
argument_list|,
name|op
argument_list|,
name|next2_insn
argument_list|,
name|next2_op
argument_list|)
condition|)
name|ok
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|swap
call|)
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|relocs
argument_list|,
name|contents
argument_list|,
name|i
argument_list|)
condition|)
return|return
name|false
return|;
operator|*
name|pswapped
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_block

begin_comment
comment|/* Look for loads and stores which we can align to four byte    boundaries.  See the longer comment above sh_relax_section for why    this is desirable.  This sets *PSWAPPED if some instruction was    swapped.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_align_loads
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|internal_relocs
parameter_list|,
name|contents
parameter_list|,
name|pswapped
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|internal_relocs
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|boolean
modifier|*
name|pswapped
decl_stmt|;
block|{
name|struct
name|internal_reloc
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
name|bfd_vma
modifier|*
name|labels
init|=
name|NULL
decl_stmt|;
name|bfd_vma
modifier|*
name|label
decl_stmt|,
modifier|*
name|label_end
decl_stmt|;
operator|*
name|pswapped
operator|=
name|false
expr_stmt|;
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
comment|/* Get all the addresses with labels on them.  */
name|labels
operator|=
operator|(
name|bfd_vma
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|sec
operator|->
name|reloc_count
operator|*
sizeof|sizeof
argument_list|(
name|bfd_vma
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|labels
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|label_end
operator|=
name|labels
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
if|if
condition|(
name|irel
operator|->
name|r_type
operator|==
name|R_SH_LABEL
condition|)
block|{
operator|*
name|label_end
operator|=
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
expr_stmt|;
operator|++
name|label_end
expr_stmt|;
block|}
block|}
comment|/* Note that the assembler currently always outputs relocs in      address order.  If that ever changes, this code will need to sort      the label values and the relocs.  */
name|label
operator|=
name|labels
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|bfd_vma
name|start
decl_stmt|,
name|stop
decl_stmt|;
if|if
condition|(
name|irel
operator|->
name|r_type
operator|!=
name|R_SH_CODE
condition|)
continue|continue;
name|start
operator|=
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
expr_stmt|;
for|for
control|(
name|irel
operator|++
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
if|if
condition|(
name|irel
operator|->
name|r_type
operator|==
name|R_SH_DATA
condition|)
break|break;
if|if
condition|(
name|irel
operator|<
name|irelend
condition|)
name|stop
operator|=
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
expr_stmt|;
else|else
name|stop
operator|=
name|sec
operator|->
name|_cooked_size
expr_stmt|;
if|if
condition|(
operator|!
name|_bfd_sh_align_load_span
argument_list|(
name|abfd
argument_list|,
name|sec
argument_list|,
name|contents
argument_list|,
name|sh_swap_insns
argument_list|,
operator|(
name|PTR
operator|)
name|internal_relocs
argument_list|,
operator|&
name|label
argument_list|,
name|label_end
argument_list|,
name|start
argument_list|,
name|stop
argument_list|,
name|pswapped
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
block|}
name|free
argument_list|(
name|labels
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|labels
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|labels
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Swap two SH instructions.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_swap_insns
parameter_list|(
name|abfd
parameter_list|,
name|sec
parameter_list|,
name|relocs
parameter_list|,
name|contents
parameter_list|,
name|addr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|PTR
name|relocs
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
block|{
name|struct
name|internal_reloc
modifier|*
name|internal_relocs
init|=
operator|(
expr|struct
name|internal_reloc
operator|*
operator|)
name|relocs
decl_stmt|;
name|unsigned
name|short
name|i1
decl_stmt|,
name|i2
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|irel
decl_stmt|,
modifier|*
name|irelend
decl_stmt|;
comment|/* Swap the instructions themselves.  */
name|i1
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|addr
argument_list|)
expr_stmt|;
name|i2
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|contents
operator|+
name|addr
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|i2
argument_list|,
name|contents
operator|+
name|addr
argument_list|)
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|i1
argument_list|,
name|contents
operator|+
name|addr
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Adjust all reloc addresses.  */
name|irelend
operator|=
name|internal_relocs
operator|+
name|sec
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
name|irel
operator|=
name|internal_relocs
init|;
name|irel
operator|<
name|irelend
condition|;
name|irel
operator|++
control|)
block|{
name|int
name|type
decl_stmt|,
name|add
decl_stmt|;
comment|/* There are a few special types of relocs that we don't want to          adjust.  These relocs do not apply to the instruction itself,          but are only associated with the address.  */
name|type
operator|=
name|irel
operator|->
name|r_type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|R_SH_ALIGN
operator|||
name|type
operator|==
name|R_SH_CODE
operator|||
name|type
operator|==
name|R_SH_DATA
operator|||
name|type
operator|==
name|R_SH_LABEL
condition|)
continue|continue;
comment|/* If an R_SH_USES reloc points to one of the addresses being          swapped, we must adjust it.  It would be incorrect to do this          for a jump, though, since we want to execute both          instructions after the jump.  (We have avoided swapping          around a label, so the jump will not wind up executing an          instruction it shouldn't).  */
if|if
condition|(
name|type
operator|==
name|R_SH_USES
condition|)
block|{
name|bfd_vma
name|off
decl_stmt|;
name|off
operator|=
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
operator|+
literal|4
operator|+
name|irel
operator|->
name|r_offset
expr_stmt|;
if|if
condition|(
name|off
operator|==
name|addr
condition|)
name|irel
operator|->
name|r_offset
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|off
operator|==
name|addr
operator|+
literal|2
condition|)
name|irel
operator|->
name|r_offset
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
operator|==
name|addr
condition|)
block|{
name|irel
operator|->
name|r_vaddr
operator|+=
literal|2
expr_stmt|;
name|add
operator|=
operator|-
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
operator|==
name|addr
operator|+
literal|2
condition|)
block|{
name|irel
operator|->
name|r_vaddr
operator|-=
literal|2
expr_stmt|;
name|add
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|add
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|add
operator|!=
literal|0
condition|)
block|{
name|bfd_byte
modifier|*
name|loc
decl_stmt|;
name|unsigned
name|short
name|insn
decl_stmt|,
name|oinsn
decl_stmt|;
name|boolean
name|overflow
decl_stmt|;
name|loc
operator|=
name|contents
operator|+
name|irel
operator|->
name|r_vaddr
operator|-
name|sec
operator|->
name|vma
expr_stmt|;
name|overflow
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
default|default:
break|break;
case|case
name|R_SH_PCDISP8BY2
case|:
case|case
name|R_SH_PCRELIMM8BY2
case|:
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|oinsn
operator|=
name|insn
expr_stmt|;
name|insn
operator|+=
name|add
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|oinsn
operator|&
literal|0xff00
operator|)
operator|!=
operator|(
name|insn
operator|&
literal|0xff00
operator|)
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|loc
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_PCDISP
case|:
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|oinsn
operator|=
name|insn
expr_stmt|;
name|insn
operator|+=
name|add
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|oinsn
operator|&
literal|0xf000
operator|)
operator|!=
operator|(
name|insn
operator|&
literal|0xf000
operator|)
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|loc
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_SH_PCRELIMM8BY4
case|:
comment|/* This reloc ignores the least significant 3 bits of                  the program counter before adding in the offset.                  This means that if ADDR is at an even address, the                  swap will not affect the offset.  If ADDR is an at an                  odd address, then the instruction will be crossing a                  four byte boundary, and must be adjusted.  */
if|if
condition|(
operator|(
name|addr
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
block|{
name|insn
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|oinsn
operator|=
name|insn
expr_stmt|;
name|insn
operator|+=
name|add
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|oinsn
operator|&
literal|0xff00
operator|)
operator|!=
operator|(
name|insn
operator|&
literal|0xff00
operator|)
condition|)
name|overflow
operator|=
name|true
expr_stmt|;
name|bfd_put_16
argument_list|(
name|abfd
argument_list|,
name|insn
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|overflow
condition|)
block|{
operator|(
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: 0x%lx: fatal: reloc overflow while relaxing"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|irel
operator|->
name|r_vaddr
argument_list|)
operator|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is a modification of _bfd_coff_generic_relocate_section, which    will handle SH relaxing.  */
end_comment

begin_function
specifier|static
name|boolean
name|sh_relocate_section
parameter_list|(
name|output_bfd
parameter_list|,
name|info
parameter_list|,
name|input_bfd
parameter_list|,
name|input_section
parameter_list|,
name|contents
parameter_list|,
name|relocs
parameter_list|,
name|syms
parameter_list|,
name|sections
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|info
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|relocs
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|syms
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sections
decl_stmt|;
block|{
name|struct
name|internal_reloc
modifier|*
name|rel
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|relend
decl_stmt|;
name|rel
operator|=
name|relocs
expr_stmt|;
name|relend
operator|=
name|rel
operator|+
name|input_section
operator|->
name|reloc_count
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|relend
condition|;
name|rel
operator|++
control|)
block|{
name|long
name|symndx
decl_stmt|;
name|struct
name|coff_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|sym
decl_stmt|;
name|bfd_vma
name|addend
decl_stmt|;
name|bfd_vma
name|val
decl_stmt|;
name|reloc_howto_type
modifier|*
name|howto
decl_stmt|;
name|bfd_reloc_status_type
name|rstat
decl_stmt|;
comment|/* Almost all relocs have to do with relaxing.  If any work must          be done for them, it has been done in sh_relax_section.  */
if|if
condition|(
name|rel
operator|->
name|r_type
operator|!=
name|R_SH_IMM32
operator|&&
name|rel
operator|->
name|r_type
operator|!=
name|R_SH_PCDISP
condition|)
continue|continue;
name|symndx
operator|=
name|rel
operator|->
name|r_symndx
expr_stmt|;
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
block|{
name|h
operator|=
name|NULL
expr_stmt|;
name|sym
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|symndx
operator|<
literal|0
operator|||
operator|(
name|unsigned
name|long
operator|)
name|symndx
operator|>=
name|obj_raw_syment_count
argument_list|(
name|input_bfd
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
literal|"%s: illegal symbol index %ld in relocs"
argument_list|,
name|bfd_get_filename
argument_list|(
name|input_bfd
argument_list|)
argument_list|,
name|symndx
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|h
operator|=
name|obj_coff_sym_hashes
argument_list|(
name|input_bfd
argument_list|)
index|[
name|symndx
index|]
expr_stmt|;
name|sym
operator|=
name|syms
operator|+
name|symndx
expr_stmt|;
block|}
if|if
condition|(
name|sym
operator|!=
name|NULL
operator|&&
name|sym
operator|->
name|n_scnum
operator|!=
literal|0
condition|)
name|addend
operator|=
operator|-
name|sym
operator|->
name|n_value
expr_stmt|;
else|else
name|addend
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rel
operator|->
name|r_type
operator|==
name|R_SH_PCDISP
condition|)
name|addend
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|rel
operator|->
name|r_type
operator|>=
name|SH_COFF_HOWTO_COUNT
condition|)
name|howto
operator|=
name|NULL
expr_stmt|;
else|else
name|howto
operator|=
operator|&
name|sh_coff_howtos
index|[
name|rel
operator|->
name|r_type
index|]
expr_stmt|;
if|if
condition|(
name|howto
operator|==
name|NULL
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
comment|/* There is nothing to do for an internal PCDISP reloc.  */
if|if
condition|(
name|rel
operator|->
name|r_type
operator|==
name|R_SH_PCDISP
condition|)
continue|continue;
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
block|{
name|sec
operator|=
name|bfd_abs_section_ptr
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sec
operator|=
name|sections
index|[
name|symndx
index|]
expr_stmt|;
name|val
operator|=
operator|(
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|+
name|sym
operator|->
name|n_value
operator|-
name|sec
operator|->
name|vma
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
condition|)
block|{
name|asection
modifier|*
name|sec
decl_stmt|;
name|sec
operator|=
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|section
expr_stmt|;
name|val
operator|=
operator|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|sec
operator|->
name|output_section
operator|->
name|vma
operator|+
name|sec
operator|->
name|output_offset
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|info
operator|->
name|relocateable
condition|)
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|info
argument_list|,
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
block|}
name|rstat
operator|=
name|_bfd_final_link_relocate
argument_list|(
name|howto
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|contents
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|,
name|val
argument_list|,
name|addend
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rstat
condition|)
block|{
default|default:
name|abort
argument_list|()
expr_stmt|;
case|case
name|bfd_reloc_ok
case|:
break|break;
case|case
name|bfd_reloc_overflow
case|:
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|buf
index|[
name|SYMNMLEN
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|symndx
operator|==
operator|-
literal|1
condition|)
name|name
operator|=
literal|"*ABS*"
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|name
operator|=
name|h
operator|->
name|root
operator|.
name|root
operator|.
name|string
expr_stmt|;
elseif|else
if|if
condition|(
name|sym
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_zeroes
operator|==
literal|0
operator|&&
name|sym
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
operator|!=
literal|0
condition|)
name|name
operator|=
name|obj_coff_strings
argument_list|(
name|input_bfd
argument_list|)
operator|+
name|sym
operator|->
name|_n
operator|.
name|_n_n
operator|.
name|_n_offset
expr_stmt|;
else|else
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
name|sym
operator|->
name|_n
operator|.
name|_n_name
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
name|buf
index|[
name|SYMNMLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|buf
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|info
operator|->
name|callbacks
operator|->
name|reloc_overflow
call|)
argument_list|(
name|info
argument_list|,
name|name
argument_list|,
name|howto
operator|->
name|name
argument_list|,
operator|(
name|bfd_vma
operator|)
literal|0
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|rel
operator|->
name|r_vaddr
operator|-
name|input_section
operator|->
name|vma
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is a version of bfd_generic_get_relocated_section_contents    which uses sh_relocate_section.  */
end_comment

begin_function
specifier|static
name|bfd_byte
modifier|*
name|sh_coff_get_relocated_section_contents
parameter_list|(
name|output_bfd
parameter_list|,
name|link_info
parameter_list|,
name|link_order
parameter_list|,
name|data
parameter_list|,
name|relocateable
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|output_bfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|boolean
name|relocateable
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
name|asection
modifier|*
name|input_section
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
name|bfd
modifier|*
name|input_bfd
init|=
name|input_section
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
modifier|*
name|sections
init|=
name|NULL
decl_stmt|;
name|struct
name|internal_reloc
modifier|*
name|internal_relocs
init|=
name|NULL
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|internal_syms
init|=
name|NULL
decl_stmt|;
comment|/* We only need to handle the case of relaxing, or of having a      particular set of section contents, specially.  */
if|if
condition|(
name|relocateable
operator|||
name|coff_section_data
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
operator|==
name|NULL
operator|||
name|coff_section_data
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
operator|->
name|contents
operator|==
name|NULL
condition|)
return|return
name|bfd_generic_get_relocated_section_contents
argument_list|(
name|output_bfd
argument_list|,
name|link_info
argument_list|,
name|link_order
argument_list|,
name|data
argument_list|,
name|relocateable
argument_list|,
name|symbols
argument_list|)
return|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|coff_section_data
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
operator|->
name|contents
argument_list|,
name|input_section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|input_section
operator|->
name|flags
operator|&
name|SEC_RELOC
operator|)
operator|!=
literal|0
operator|&&
name|input_section
operator|->
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|bfd_size_type
name|symesz
init|=
name|bfd_coff_symesz
argument_list|(
name|input_bfd
argument_list|)
decl_stmt|;
name|bfd_byte
modifier|*
name|esym
decl_stmt|,
modifier|*
name|esymend
decl_stmt|;
name|struct
name|internal_syment
modifier|*
name|isymp
decl_stmt|;
name|asection
modifier|*
modifier|*
name|secpp
decl_stmt|;
if|if
condition|(
operator|!
name|_bfd_coff_get_external_symbols
argument_list|(
name|input_bfd
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|internal_relocs
operator|=
operator|(
name|_bfd_coff_read_internal_relocs
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|false
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|NULL
argument_list|,
name|false
argument_list|,
operator|(
expr|struct
name|internal_reloc
operator|*
operator|)
name|NULL
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_relocs
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|internal_syms
operator|=
operator|(
operator|(
expr|struct
name|internal_syment
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|obj_raw_syment_count
argument_list|(
name|input_bfd
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|internal_syment
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|internal_syms
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|sections
operator|=
operator|(
name|asection
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|obj_raw_syment_count
argument_list|(
name|input_bfd
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|asection
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sections
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|isymp
operator|=
name|internal_syms
expr_stmt|;
name|secpp
operator|=
name|sections
expr_stmt|;
name|esym
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|obj_coff_external_syms
argument_list|(
name|input_bfd
argument_list|)
expr_stmt|;
name|esymend
operator|=
name|esym
operator|+
name|obj_raw_syment_count
argument_list|(
name|input_bfd
argument_list|)
operator|*
name|symesz
expr_stmt|;
while|while
condition|(
name|esym
operator|<
name|esymend
condition|)
block|{
name|bfd_coff_swap_sym_in
argument_list|(
name|input_bfd
argument_list|,
operator|(
name|PTR
operator|)
name|esym
argument_list|,
operator|(
name|PTR
operator|)
name|isymp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isymp
operator|->
name|n_scnum
operator|!=
literal|0
condition|)
operator|*
name|secpp
operator|=
name|coff_section_from_bfd_index
argument_list|(
name|input_bfd
argument_list|,
name|isymp
operator|->
name|n_scnum
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|isymp
operator|->
name|n_value
operator|==
literal|0
condition|)
operator|*
name|secpp
operator|=
name|bfd_und_section_ptr
expr_stmt|;
else|else
operator|*
name|secpp
operator|=
name|bfd_com_section_ptr
expr_stmt|;
block|}
name|esym
operator|+=
operator|(
name|isymp
operator|->
name|n_numaux
operator|+
literal|1
operator|)
operator|*
name|symesz
expr_stmt|;
name|secpp
operator|+=
name|isymp
operator|->
name|n_numaux
operator|+
literal|1
expr_stmt|;
name|isymp
operator|+=
name|isymp
operator|->
name|n_numaux
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sh_relocate_section
argument_list|(
name|output_bfd
argument_list|,
name|link_info
argument_list|,
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|data
argument_list|,
name|internal_relocs
argument_list|,
name|internal_syms
argument_list|,
name|sections
argument_list|)
condition|)
goto|goto
name|error_return
goto|;
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
name|sections
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|internal_syms
argument_list|)
expr_stmt|;
name|internal_syms
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
name|internal_relocs
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|data
return|;
name|error_return
label|:
if|if
condition|(
name|internal_relocs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|internal_relocs
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_syms
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|internal_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|sections
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sections
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* The target vectors.  */
end_comment

begin_decl_stmt
specifier|const
name|bfd_target
name|shcoff_vec
init|=
block|{
literal|"coff-sh"
block|,
comment|/* name */
name|bfd_target_coff_flavour
block|,
name|BFD_ENDIAN_BIG
block|,
comment|/* data byte order is big */
name|BFD_ENDIAN_BIG
block|,
comment|/* header byte order is big */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|BFD_IS_RELAXABLE
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
literal|'_'
block|,
comment|/* leading symbol underscore */
literal|'/'
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|coff_object_p
block|,
comment|/* bfd_check_format */
name|bfd_generic_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
comment|/* bfd_set_format */
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_write_object_contents
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_archive_coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|COFF_SWAP_TABLE
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|bfd_target
name|shlcoff_vec
init|=
block|{
literal|"coff-shl"
block|,
comment|/* name */
name|bfd_target_coff_flavour
block|,
name|BFD_ENDIAN_LITTLE
block|,
comment|/* data byte order is little */
name|BFD_ENDIAN_LITTLE
block|,
comment|/* header byte order is little endian too*/
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|BFD_IS_RELAXABLE
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
literal|'_'
block|,
comment|/* leading symbol underscore */
literal|'/'
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* data */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|coff_object_p
block|,
comment|/* bfd_check_format */
name|bfd_generic_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
comment|/* bfd_set_format */
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_write_object_contents
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_archive_coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|COFF_SWAP_TABLE
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some people want versions of the SH COFF target which do not align    to 16 byte boundaries.  We implement that by adding a couple of new    target vectors.  These are just like the ones above, but they    change the default section alignment.  To generate them in the    assembler, use -small.  To use them in the linker, use -b    coff-sh{l}-small and -oformat coff-sh{l}-small.     Yes, this is a horrible hack.  A general solution for setting    section alignment in COFF is rather complex.  ELF handles this    correctly.  */
end_comment

begin_comment
comment|/* Only recognize the small versions if the target was not defaulted.    Otherwise we won't recognize the non default endianness.  */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|coff_small_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
name|abfd
operator|->
name|target_defaulted
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|coff_object_p
argument_list|(
name|abfd
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set the section alignment for the small versions.  */
end_comment

begin_function
specifier|static
name|boolean
name|coff_small_new_section_hook
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|coff_new_section_hook
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We must align to at least a four byte boundary, because longword      accesses must be on a four byte boundary.  */
if|if
condition|(
name|section
operator|->
name|alignment_power
operator|==
name|COFF_DEFAULT_SECTION_ALIGNMENT_POWER
condition|)
name|section
operator|->
name|alignment_power
operator|=
literal|2
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* This is copied from bfd_coff_std_swap_table so that we can change    the default section alignment power.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|bfd_coff_backend_data
name|bfd_coff_small_swap_table
init|=
block|{
name|coff_swap_aux_in
block|,
name|coff_swap_sym_in
block|,
name|coff_swap_lineno_in
block|,
name|coff_swap_aux_out
block|,
name|coff_swap_sym_out
block|,
name|coff_swap_lineno_out
block|,
name|coff_swap_reloc_out
block|,
name|coff_swap_filehdr_out
block|,
name|coff_swap_aouthdr_out
block|,
name|coff_swap_scnhdr_out
block|,
name|FILHSZ
block|,
name|AOUTSZ
block|,
name|SCNHSZ
block|,
name|SYMESZ
block|,
name|AUXESZ
block|,
name|RELSZ
block|,
name|LINESZ
block|,
ifdef|#
directive|ifdef
name|COFF_LONG_FILENAMES
name|true
block|,
else|#
directive|else
name|false
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COFF_LONG_SECTION_NAMES
name|true
block|,
else|#
directive|else
name|false
block|,
endif|#
directive|endif
literal|2
block|,
name|coff_swap_filehdr_in
block|,
name|coff_swap_aouthdr_in
block|,
name|coff_swap_scnhdr_in
block|,
name|coff_swap_reloc_in
block|,
name|coff_bad_format_hook
block|,
name|coff_set_arch_mach_hook
block|,
name|coff_mkobject_hook
block|,
name|styp_to_sec_flags
block|,
name|coff_set_alignment_hook
block|,
name|coff_slurp_symbol_table
block|,
name|symname_in_debug_hook
block|,
name|coff_pointerize_aux_hook
block|,
name|coff_print_aux
block|,
name|coff_reloc16_extra_cases
block|,
name|coff_reloc16_estimate
block|,
name|coff_sym_is_global
block|,
name|coff_compute_section_file_positions
block|,
name|coff_start_final_link
block|,
name|coff_relocate_section
block|,
name|coff_rtype_to_howto
block|,
name|coff_adjust_symndx
block|,
name|coff_link_add_one_symbol
block|,
name|coff_link_output_has_begun
block|,
name|coff_final_link_postscript
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|coff_small_close_and_cleanup
define|\
value|coff_close_and_cleanup
end_define

begin_define
define|#
directive|define
name|coff_small_bfd_free_cached_info
define|\
value|coff_bfd_free_cached_info
end_define

begin_define
define|#
directive|define
name|coff_small_get_section_contents
define|\
value|coff_get_section_contents
end_define

begin_define
define|#
directive|define
name|coff_small_get_section_contents_in_window
define|\
value|coff_get_section_contents_in_window
end_define

begin_decl_stmt
specifier|const
name|bfd_target
name|shcoff_small_vec
init|=
block|{
literal|"coff-sh-small"
block|,
comment|/* name */
name|bfd_target_coff_flavour
block|,
name|BFD_ENDIAN_BIG
block|,
comment|/* data byte order is big */
name|BFD_ENDIAN_BIG
block|,
comment|/* header byte order is big */
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|BFD_IS_RELAXABLE
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
literal|'_'
block|,
comment|/* leading symbol underscore */
literal|'/'
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|coff_small_object_p
block|,
comment|/* bfd_check_format */
name|bfd_generic_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
comment|/* bfd_set_format */
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_write_object_contents
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|coff_small
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_archive_coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
operator|(
name|PTR
operator|)
operator|&
name|bfd_coff_small_swap_table
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|bfd_target
name|shlcoff_small_vec
init|=
block|{
literal|"coff-shl-small"
block|,
comment|/* name */
name|bfd_target_coff_flavour
block|,
name|BFD_ENDIAN_LITTLE
block|,
comment|/* data byte order is little */
name|BFD_ENDIAN_LITTLE
block|,
comment|/* header byte order is little endian too*/
operator|(
name|HAS_RELOC
operator||
name|EXEC_P
operator||
comment|/* object flags */
name|HAS_LINENO
operator||
name|HAS_DEBUG
operator||
name|HAS_SYMS
operator||
name|HAS_LOCALS
operator||
name|WP_TEXT
operator||
name|BFD_IS_RELAXABLE
operator|)
block|,
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator||
name|SEC_RELOC
operator|)
block|,
literal|'_'
block|,
comment|/* leading symbol underscore */
literal|'/'
block|,
comment|/* ar_pad_char */
literal|15
block|,
comment|/* ar_max_namelen */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* data */
name|bfd_getl64
block|,
name|bfd_getl_signed_64
block|,
name|bfd_putl64
block|,
name|bfd_getl32
block|,
name|bfd_getl_signed_32
block|,
name|bfd_putl32
block|,
name|bfd_getl16
block|,
name|bfd_getl_signed_16
block|,
name|bfd_putl16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|coff_small_object_p
block|,
comment|/* bfd_check_format */
name|bfd_generic_archive_p
block|,
name|_bfd_dummy_target
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
comment|/* bfd_set_format */
name|bfd_false
block|}
block|,
block|{
name|bfd_false
block|,
name|coff_write_object_contents
block|,
comment|/* bfd_write_contents */
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|}
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|coff_small
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_archive_coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|coff
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
operator|(
name|PTR
operator|)
operator|&
name|bfd_coff_small_swap_table
block|}
decl_stmt|;
end_decl_stmt

end_unit

