begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* BFD back-end for Intel Hex objects.    Copyright 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.    Written by Ian Lance Taylor of Cygnus Support<ian@cygnus.com>.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This is what Intel Hex files look like:  1. INTEL FORMATS  A. Intel 1     16-bit address-field format, for files 64k bytes in length or less.     DATA RECORD    Byte 1	Header = colon(:)    2..3		The number of data bytes in hex notation    4..5		High byte of the record load address    6..7		Low byte of the record load address    8..9		Record type, must be "00"    10..x	Data bytes in hex notation: 	x = (number of bytes - 1) * 2 + 11    x+1..x+2	Checksum in hex notation    x+3..x+4	Carriage return, line feed     END RECORD    Byte 1	Header = colon (:)    2..3		The byte count, must be "00"    4..7		Transfer-address (usually "0000") 		the jump-to address, execution start address    8..9		Record type, must be "01"    10..11	Checksum, in hex notation    12..13	Carriage return, line feed  B. INTEL 2     MCS-86 format, using a 20-bit address for files larger than 64K bytes.     DATA RECORD    Byte 1	Header = colon (:)    2..3		The byte count of this record, hex notation    4..5		High byte of the record load address    6..7		Low byte of the record load address    8..9		Record type, must be "00"    10..x	The data bytes in hex notation: 	x = (number of data bytes - 1) * 2 + 11    x+1..x+2	Checksum in hex notation    x+3..x+4	Carriage return, line feed     EXTENDED ADDRESS RECORD    Byte 1	Header = colon(:)    2..3		The byte count, must be "02"    4..7		Load address, must be "0000"    8..9		Record type, must be "02"    10..11	High byte of the offset address    12..13	Low byte of the offset address    14..15	Checksum in hex notation    16..17	Carriage return, line feed     The checksums are the two's complement of the 8-bit sum    without carry of the byte count, offset address, and the    record type.     START ADDRESS RECORD    Byte 1	Header = colon (:)    2..3		The byte count, must be "04"    4..7		Load address, must be "0000"    8..9		Record type, must be "03"    10..13	8086 CS value    14..17	8086 IP value    18..19	Checksum in hex notation    20..21	Carriage return, line feed  Another document reports these additional types:     EXTENDED LINEAR ADDRESS RECORD    Byte 1	Header = colon (:)    2..3		The byte count, must be "02"    4..7		Load address, must be "0000"    8..9		Record type, must be "04"    10..13	Upper 16 bits of address of subsequent records    14..15	Checksum in hex notation    16..17	Carriage return, line feed     START LINEAR ADDRESS RECORD    Byte 1	Header = colon (:)    2..3		The byte count, must be "02"    4..7		Load address, must be "0000"    8..9		Record type, must be "05"    10..13	Upper 16 bits of start address    14..15	Checksum in hex notation    16..17	Carriage return, line feed  The MRI compiler uses this, which is a repeat of type 5:    EXTENDED START RECORD    Byte 1	Header = colon (:)    2..3		The byte count, must be "04"    4..7		Load address, must be "0000"    8..9		Record type, must be "05"    10..13	Upper 16 bits of start address    14..17	Lower 16 bits of start address    18..19	Checksum in hex notation    20..21	Carriage return, line feed */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"libiberty.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_decl_stmt
specifier|static
name|void
name|ihex_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ihex_mkobject
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|INLINE
name|int
name|ihex_get_byte
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|boolean
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ihex_bad_byte
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|,
name|int
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ihex_scan
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_target
modifier|*
name|ihex_object_p
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ihex_read_section
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|bfd_byte
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ihex_get_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ihex_set_section_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|,
name|file_ptr
operator|,
name|bfd_size_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ihex_write_record
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|bfd_size_type
operator|,
name|bfd_vma
operator|,
name|unsigned
name|int
operator|,
name|bfd_byte
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ihex_write_object_contents
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asymbol
modifier|*
name|ihex_make_empty_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|ihex_set_arch_mach
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
expr|enum
name|bfd_architecture
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ihex_sizeof_headers
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of bytes we put on one line during output.  */
end_comment

begin_define
define|#
directive|define
name|CHUNK
value|16
end_define

begin_comment
comment|/* Macros for converting between hex and binary. */
end_comment

begin_define
define|#
directive|define
name|NIBBLE
parameter_list|(
name|x
parameter_list|)
value|(hex_value (x))
end_define

begin_define
define|#
directive|define
name|HEX2
parameter_list|(
name|buffer
parameter_list|)
value|((NIBBLE ((buffer)[0])<< 4) + NIBBLE ((buffer)[1]))
end_define

begin_define
define|#
directive|define
name|HEX4
parameter_list|(
name|buffer
parameter_list|)
value|((HEX2 (buffer)<< 8) + HEX2 ((buffer) + 2))
end_define

begin_define
define|#
directive|define
name|ISHEX
parameter_list|(
name|x
parameter_list|)
value|(hex_p (x))
end_define

begin_comment
comment|/* When we write out an ihex value, the values can not be output as    they are seen.  Instead, we hold them in memory in this structure.  */
end_comment

begin_struct
struct|struct
name|ihex_data_list
block|{
name|struct
name|ihex_data_list
modifier|*
name|next
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|bfd_vma
name|where
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The ihex tdata information.  */
end_comment

begin_struct
struct|struct
name|ihex_data_struct
block|{
name|struct
name|ihex_data_list
modifier|*
name|head
decl_stmt|;
name|struct
name|ihex_data_list
modifier|*
name|tail
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Initialize by filling in the hex conversion array.  */
end_comment

begin_function
specifier|static
name|void
name|ihex_init
parameter_list|()
block|{
specifier|static
name|boolean
name|inited
decl_stmt|;
if|if
condition|(
operator|!
name|inited
condition|)
block|{
name|inited
operator|=
name|true
expr_stmt|;
name|hex_init
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create an ihex object.  */
end_comment

begin_function
specifier|static
name|boolean
name|ihex_mkobject
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
if|if
condition|(
name|abfd
operator|->
name|tdata
operator|.
name|ihex_data
operator|==
name|NULL
condition|)
block|{
name|struct
name|ihex_data_struct
modifier|*
name|tdata
decl_stmt|;
name|tdata
operator|=
operator|(
operator|(
expr|struct
name|ihex_data_struct
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ihex_data_struct
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|tdata
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|abfd
operator|->
name|tdata
operator|.
name|ihex_data
operator|=
name|tdata
expr_stmt|;
name|tdata
operator|->
name|head
operator|=
name|NULL
expr_stmt|;
name|tdata
operator|->
name|tail
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Read a byte from a BFD.  Set *ERRORPTR if an error occurred.    Return EOF on error or end of file.  */
end_comment

begin_function
specifier|static
name|INLINE
name|int
name|ihex_get_byte
parameter_list|(
name|abfd
parameter_list|,
name|errorptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|boolean
modifier|*
name|errorptr
decl_stmt|;
block|{
name|bfd_byte
name|c
decl_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|!=
name|bfd_error_file_truncated
condition|)
operator|*
name|errorptr
operator|=
name|true
expr_stmt|;
return|return
name|EOF
return|;
block|}
return|return
call|(
name|int
call|)
argument_list|(
name|c
operator|&
literal|0xff
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Report a problem in an Intel Hex file.  */
end_comment

begin_function
specifier|static
name|void
name|ihex_bad_byte
parameter_list|(
name|abfd
parameter_list|,
name|lineno
parameter_list|,
name|c
parameter_list|,
name|error
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|lineno
decl_stmt|;
name|int
name|c
decl_stmt|;
name|boolean
name|error
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
operator|!
name|error
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_file_truncated
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\\%03o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
else|else
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s:%d: unexpected character `%s' in Intel Hex file\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|lineno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read an Intel hex file and turn it into sections.  We create a new    section for each contiguous set of bytes.  */
end_comment

begin_function
specifier|static
name|boolean
name|ihex_scan
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|bfd_vma
name|segbase
decl_stmt|;
name|bfd_vma
name|extbase
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|int
name|lineno
decl_stmt|;
name|boolean
name|error
decl_stmt|;
name|bfd_byte
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|size_t
name|bufsize
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|abfd
operator|->
name|start_address
operator|=
literal|0
expr_stmt|;
name|segbase
operator|=
literal|0
expr_stmt|;
name|extbase
operator|=
literal|0
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|false
expr_stmt|;
name|bufsize
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|ihex_get_byte
argument_list|(
name|abfd
argument_list|,
operator|&
name|error
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|lineno
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|':'
condition|)
block|{
name|ihex_bad_byte
argument_list|(
name|abfd
argument_list|,
name|lineno
argument_list|,
name|c
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
else|else
block|{
name|file_ptr
name|pos
decl_stmt|;
name|char
name|hdr
index|[
literal|8
index|]
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
name|unsigned
name|int
name|chars
decl_stmt|;
name|unsigned
name|int
name|chksum
decl_stmt|;
comment|/* This is a data record.  */
name|pos
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Read the header bytes.  */
if|if
condition|(
name|bfd_read
argument_list|(
name|hdr
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|8
condition|)
goto|goto
name|error_return
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ISHEX
argument_list|(
name|hdr
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|ihex_bad_byte
argument_list|(
name|abfd
argument_list|,
name|lineno
argument_list|,
name|hdr
index|[
name|i
index|]
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
block|}
name|len
operator|=
name|HEX2
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|HEX4
argument_list|(
name|hdr
operator|+
literal|2
argument_list|)
expr_stmt|;
name|type
operator|=
name|HEX2
argument_list|(
name|hdr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* Read the data bytes.  */
name|chars
operator|=
name|len
operator|*
literal|2
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|chars
operator|>=
name|bufsize
condition|)
block|{
name|buf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_realloc
argument_list|(
name|buf
argument_list|,
name|chars
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|bufsize
operator|=
name|chars
expr_stmt|;
block|}
if|if
condition|(
name|bfd_read
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|chars
argument_list|,
name|abfd
argument_list|)
operator|!=
name|chars
condition|)
goto|goto
name|error_return
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chars
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ISHEX
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|ihex_bad_byte
argument_list|(
name|abfd
argument_list|,
name|lineno
argument_list|,
name|hdr
index|[
name|i
index|]
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
block|}
comment|/* Check the checksum.  */
name|chksum
operator|=
name|len
operator|+
name|addr
operator|+
operator|(
name|addr
operator|>>
literal|8
operator|)
operator|+
name|type
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|chksum
operator|+=
name|HEX2
argument_list|(
name|buf
operator|+
literal|2
operator|*
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|-
name|chksum
operator|)
operator|&
literal|0xff
operator|)
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|HEX2
argument_list|(
name|buf
operator|+
literal|2
operator|*
name|i
argument_list|)
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s:%d: bad checksum in Intel Hex file (expected %u, found %u)"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|lineno
argument_list|,
operator|(
operator|-
name|chksum
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|HEX2
argument_list|(
name|buf
operator|+
literal|2
operator|*
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|0
case|:
comment|/* This is a data record.  */
if|if
condition|(
name|sec
operator|!=
name|NULL
operator|&&
name|sec
operator|->
name|vma
operator|+
name|sec
operator|->
name|_raw_size
operator|==
name|extbase
operator|+
name|segbase
operator|+
name|addr
condition|)
block|{
comment|/* This data goes at the end of the section we are                      currently building.  */
name|sec
operator|->
name|_raw_size
operator|+=
name|len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|char
name|secbuf
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|secname
decl_stmt|;
name|sprintf
argument_list|(
name|secbuf
argument_list|,
literal|".sec%d"
argument_list|,
name|bfd_count_sections
argument_list|(
name|abfd
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|secname
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|strlen
argument_list|(
name|secbuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|secname
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|strcpy
argument_list|(
name|secname
argument_list|,
name|secbuf
argument_list|)
expr_stmt|;
name|sec
operator|=
name|bfd_make_section
argument_list|(
name|abfd
argument_list|,
name|secname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|sec
operator|->
name|flags
operator|=
name|SEC_HAS_CONTENTS
operator||
name|SEC_LOAD
operator||
name|SEC_ALLOC
expr_stmt|;
name|sec
operator|->
name|vma
operator|=
name|extbase
operator|+
name|segbase
operator|+
name|addr
expr_stmt|;
name|sec
operator|->
name|lma
operator|=
name|extbase
operator|+
name|segbase
operator|+
name|addr
expr_stmt|;
name|sec
operator|->
name|_raw_size
operator|=
name|len
expr_stmt|;
name|sec
operator|->
name|filepos
operator|=
name|pos
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
comment|/* An end record.  */
if|if
condition|(
name|abfd
operator|->
name|start_address
operator|==
literal|0
condition|)
name|abfd
operator|->
name|start_address
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
literal|2
case|:
comment|/* An extended address record.  */
if|if
condition|(
name|len
operator|!=
literal|2
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s:%d: bad extended address record length in Intel Hex file"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|segbase
operator|=
name|HEX4
argument_list|(
name|buf
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* An extended start address record.  */
if|if
condition|(
name|len
operator|!=
literal|4
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s:%d: bad extended start address length in Intel Hex file"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|abfd
operator|->
name|start_address
operator|+=
operator|(
name|HEX4
argument_list|(
name|buf
argument_list|)
operator|<<
literal|4
operator|)
operator|+
name|HEX4
argument_list|(
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* An extended linear address record.  */
if|if
condition|(
name|len
operator|!=
literal|2
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s:%d: bad extended linear address record length in Intel Hex file"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|extbase
operator|=
name|HEX4
argument_list|(
name|buf
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* An extended linear start address record.  */
if|if
condition|(
name|len
operator|!=
literal|2
operator|&&
name|len
operator|!=
literal|4
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s:%d: bad extended linear start address length in Intel Hex file"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|len
operator|==
literal|2
condition|)
name|abfd
operator|->
name|start_address
operator|+=
name|HEX4
argument_list|(
name|buf
argument_list|)
operator|<<
literal|16
expr_stmt|;
else|else
name|abfd
operator|->
name|start_address
operator|=
operator|(
name|HEX4
argument_list|(
name|buf
argument_list|)
operator|<<
literal|16
operator|)
operator|+
name|HEX4
argument_list|(
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
name|sec
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s:%d: unrecognized ihex type %u in Intel Hex file\n"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|lineno
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
block|}
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|error_return
goto|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Try to recognize an Intel Hex file.  */
end_comment

begin_function
specifier|static
specifier|const
name|bfd_target
modifier|*
name|ihex_object_p
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|bfd_byte
name|b
index|[
literal|9
index|]
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
name|ihex_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|bfd_read
argument_list|(
name|b
argument_list|,
literal|1
argument_list|,
literal|9
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|9
condition|)
block|{
if|if
condition|(
name|bfd_get_error
argument_list|()
operator|==
name|bfd_error_file_truncated
condition|)
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|b
index|[
literal|0
index|]
operator|!=
literal|':'
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|9
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ISHEX
argument_list|(
name|b
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|type
operator|=
name|HEX2
argument_list|(
name|b
operator|+
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|>
literal|5
condition|)
block|{
name|bfd_set_error
argument_list|(
name|bfd_error_wrong_format
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* OK, it looks like it really is an Intel Hex file.  */
if|if
condition|(
operator|!
name|ihex_mkobject
argument_list|(
name|abfd
argument_list|)
operator|||
operator|!
name|ihex_scan
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|abfd
operator|->
name|xvec
return|;
block|}
end_function

begin_comment
comment|/* Read the contents of a section in an Intel Hex file.  */
end_comment

begin_function
specifier|static
name|boolean
name|ihex_read_section
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|contents
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd_byte
modifier|*
name|contents
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|bfd_byte
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|size_t
name|bufsize
decl_stmt|;
name|boolean
name|error
decl_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|filepos
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|p
operator|=
name|contents
expr_stmt|;
name|bufsize
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|false
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|ihex_get_byte
argument_list|(
name|abfd
argument_list|,
operator|&
name|error
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|char
name|hdr
index|[
literal|8
index|]
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\r'
operator|||
name|c
operator|==
literal|'\n'
condition|)
continue|continue;
comment|/* This is called after ihex_scan has succeeded, so we ought to          know the exact format.  */
name|BFD_ASSERT
argument_list|(
name|c
operator|==
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_read
argument_list|(
name|hdr
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|8
condition|)
goto|goto
name|error_return
goto|;
name|len
operator|=
name|HEX2
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|HEX4
argument_list|(
name|hdr
operator|+
literal|2
argument_list|)
expr_stmt|;
name|type
operator|=
name|HEX2
argument_list|(
name|hdr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* We should only see type 0 records here.  */
if|if
condition|(
name|type
operator|!=
literal|0
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: internal error in ihex_read_section"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|len
operator|*
literal|2
operator|>
name|bufsize
condition|)
block|{
name|buf
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_realloc
argument_list|(
name|buf
argument_list|,
name|len
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
goto|goto
name|error_return
goto|;
name|bufsize
operator|=
name|len
operator|*
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|bfd_read
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|len
operator|*
literal|2
argument_list|,
name|abfd
argument_list|)
operator|!=
name|len
operator|*
literal|2
condition|)
goto|goto
name|error_return
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|HEX2
argument_list|(
name|buf
operator|+
literal|2
operator|*
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|p
operator|-
name|contents
argument_list|)
operator|>=
name|section
operator|->
name|_raw_size
condition|)
block|{
comment|/* We've read everything in the section.  */
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Skip the checksum.  */
if|if
condition|(
name|bfd_read
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|2
condition|)
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
call|(
name|bfd_size_type
call|)
argument_list|(
name|p
operator|-
name|contents
argument_list|)
operator|<
name|section
operator|->
name|_raw_size
condition|)
block|{
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: bad section length in ihex_read_section"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|error_return
label|:
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Get the contents of a section in an Intel Hex file.  */
end_comment

begin_function
specifier|static
name|boolean
name|ihex_get_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
if|if
condition|(
name|section
operator|->
name|used_by_bfd
operator|==
name|NULL
condition|)
block|{
name|section
operator|->
name|used_by_bfd
operator|=
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|section
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|->
name|used_by_bfd
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|ihex_read_section
argument_list|(
name|abfd
argument_list|,
name|section
argument_list|,
name|section
operator|->
name|used_by_bfd
argument_list|)
condition|)
return|return
name|false
return|;
block|}
name|memcpy
argument_list|(
name|location
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|section
operator|->
name|used_by_bfd
operator|+
name|offset
argument_list|,
operator|(
name|size_t
operator|)
name|count
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Set the contents of a section in an Intel Hex file.  */
end_comment

begin_function
specifier|static
name|boolean
name|ihex_set_section_contents
parameter_list|(
name|abfd
parameter_list|,
name|section
parameter_list|,
name|location
parameter_list|,
name|offset
parameter_list|,
name|count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|PTR
name|location
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
block|{
name|struct
name|ihex_data_list
modifier|*
name|n
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|struct
name|ihex_data_struct
modifier|*
name|tdata
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
operator|||
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_ALLOC
operator|)
operator|==
literal|0
operator|||
operator|(
name|section
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|n
operator|=
operator|(
operator|(
expr|struct
name|ihex_data_list
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ihex_data_list
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|data
operator|=
operator|(
name|bfd_byte
operator|*
operator|)
name|bfd_alloc
argument_list|(
name|abfd
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return
name|false
return|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|location
argument_list|,
operator|(
name|size_t
operator|)
name|count
argument_list|)
expr_stmt|;
name|n
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|n
operator|->
name|where
operator|=
name|section
operator|->
name|lma
operator|+
name|offset
expr_stmt|;
name|n
operator|->
name|size
operator|=
name|count
expr_stmt|;
comment|/* Sort the records by address.  Optimize for the common case of      adding a record to the end of the list.  */
name|tdata
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|ihex_data
expr_stmt|;
if|if
condition|(
name|tdata
operator|->
name|tail
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|where
operator|>=
name|tdata
operator|->
name|tail
operator|->
name|where
condition|)
block|{
name|tdata
operator|->
name|tail
operator|->
name|next
operator|=
name|n
expr_stmt|;
name|n
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|tdata
operator|->
name|tail
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|struct
name|ihex_data_list
modifier|*
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|tdata
operator|->
name|head
init|;
operator|*
name|pp
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|pp
operator|)
operator|->
name|where
operator|<
name|n
operator|->
name|where
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|next
control|)
empty_stmt|;
name|n
operator|->
name|next
operator|=
operator|*
name|pp
expr_stmt|;
operator|*
name|pp
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|next
operator|==
name|NULL
condition|)
name|tdata
operator|->
name|tail
operator|=
name|n
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write a record out to an Intel Hex file.  */
end_comment

begin_function
specifier|static
name|boolean
name|ihex_write_record
parameter_list|(
name|abfd
parameter_list|,
name|count
parameter_list|,
name|addr
parameter_list|,
name|type
parameter_list|,
name|data
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
name|bfd_vma
name|addr
decl_stmt|;
name|unsigned
name|int
name|type
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
name|digs
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
name|char
name|buf
index|[
literal|9
operator|+
name|CHUNK
operator|*
literal|2
operator|+
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|chksum
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
define|#
directive|define
name|TOHEX
parameter_list|(
name|buf
parameter_list|,
name|v
parameter_list|)
define|\
value|((buf)[0] = digs[((v)>> 4)& 0xf], (buf)[1] = digs[(v)& 0xf])
name|buf
index|[
literal|0
index|]
operator|=
literal|':'
expr_stmt|;
name|TOHEX
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|TOHEX
argument_list|(
name|buf
operator|+
literal|3
argument_list|,
operator|(
name|addr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|TOHEX
argument_list|(
name|buf
operator|+
literal|5
argument_list|,
name|addr
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|TOHEX
argument_list|(
name|buf
operator|+
literal|7
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|chksum
operator|=
name|count
operator|+
name|addr
operator|+
operator|(
name|addr
operator|>>
literal|8
operator|)
operator|+
name|type
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|buf
operator|+
literal|9
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
literal|2
operator|,
name|data
operator|++
control|)
block|{
name|TOHEX
argument_list|(
name|p
argument_list|,
operator|*
name|data
argument_list|)
expr_stmt|;
name|chksum
operator|+=
operator|*
name|data
expr_stmt|;
block|}
name|TOHEX
argument_list|(
name|p
argument_list|,
operator|(
operator|-
name|chksum
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
literal|'\r'
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|bfd_write
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
literal|9
operator|+
name|count
operator|*
literal|2
operator|+
literal|4
argument_list|,
name|abfd
argument_list|)
operator|!=
literal|9
operator|+
name|count
operator|*
literal|2
operator|+
literal|4
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Write out an Intel Hex file.  */
end_comment

begin_function
specifier|static
name|boolean
name|ihex_write_object_contents
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|bfd_vma
name|segbase
decl_stmt|;
name|bfd_vma
name|extbase
decl_stmt|;
name|struct
name|ihex_data_list
modifier|*
name|l
decl_stmt|;
name|segbase
operator|=
literal|0
expr_stmt|;
name|extbase
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|l
operator|=
name|abfd
operator|->
name|tdata
operator|.
name|ihex_data
operator|->
name|head
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|bfd_vma
name|where
decl_stmt|;
name|bfd_byte
modifier|*
name|p
decl_stmt|;
name|bfd_size_type
name|count
decl_stmt|;
name|where
operator|=
name|l
operator|->
name|where
expr_stmt|;
name|p
operator|=
name|l
operator|->
name|data
expr_stmt|;
name|count
operator|=
name|l
operator|->
name|size
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|bfd_size_type
name|now
decl_stmt|;
name|now
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|now
operator|>
name|CHUNK
condition|)
name|now
operator|=
name|CHUNK
expr_stmt|;
if|if
condition|(
name|where
operator|>
name|segbase
operator|+
name|extbase
operator|+
literal|0xffff
condition|)
block|{
name|bfd_byte
name|addr
index|[
literal|2
index|]
decl_stmt|;
comment|/* We need a new base address.  */
if|if
condition|(
name|where
operator|<=
literal|0xfffff
condition|)
block|{
comment|/* The addresses should be sorted.  */
name|BFD_ASSERT
argument_list|(
name|extbase
operator|==
literal|0
argument_list|)
expr_stmt|;
name|segbase
operator|=
name|where
operator|&
literal|0xf0000
expr_stmt|;
name|addr
index|[
literal|0
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|segbase
operator|>>
literal|12
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|segbase
operator|>>
literal|4
argument_list|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|!
name|ihex_write_record
argument_list|(
name|abfd
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|addr
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
comment|/* The extended address record and the extended                      linear address record are combined, at least by                      some readers.  We need an extended linear address                      record here, so if we've already written out an                      extended address record, zero it out to avoid                      confusion.  */
if|if
condition|(
name|segbase
operator|!=
literal|0
condition|)
block|{
name|addr
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ihex_write_record
argument_list|(
name|abfd
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
name|addr
argument_list|)
condition|)
return|return
name|false
return|;
name|segbase
operator|=
literal|0
expr_stmt|;
block|}
name|extbase
operator|=
name|where
operator|&
literal|0xffff0000
expr_stmt|;
if|if
condition|(
name|where
operator|>
name|extbase
operator|+
literal|0xffff
condition|)
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|sprintf_vma
argument_list|(
name|buf
argument_list|,
name|where
argument_list|)
expr_stmt|;
call|(
modifier|*
name|_bfd_error_handler
call|)
argument_list|(
name|_
argument_list|(
literal|"%s: address 0x%s out of range for Intex Hex file"
argument_list|)
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|bfd_set_error
argument_list|(
name|bfd_error_bad_value
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|addr
index|[
literal|0
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|extbase
operator|>>
literal|24
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|extbase
operator|>>
literal|16
argument_list|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|!
name|ihex_write_record
argument_list|(
name|abfd
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
name|addr
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|ihex_write_record
argument_list|(
name|abfd
argument_list|,
name|now
argument_list|,
name|where
operator|-
operator|(
name|extbase
operator|+
name|segbase
operator|)
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
condition|)
return|return
name|false
return|;
name|where
operator|+=
name|now
expr_stmt|;
name|p
operator|+=
name|now
expr_stmt|;
name|count
operator|-=
name|now
expr_stmt|;
block|}
block|}
if|if
condition|(
name|abfd
operator|->
name|start_address
operator|!=
literal|0
condition|)
block|{
name|bfd_vma
name|start
decl_stmt|;
name|bfd_byte
name|startbuf
index|[
literal|4
index|]
decl_stmt|;
name|start
operator|=
name|abfd
operator|->
name|start_address
expr_stmt|;
if|if
condition|(
name|start
operator|<=
literal|0xfffff
condition|)
block|{
name|startbuf
index|[
literal|0
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
operator|(
name|start
operator|&
literal|0xf0000
operator|)
operator|>>
literal|12
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|startbuf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|startbuf
index|[
literal|2
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|start
operator|>>
literal|8
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|startbuf
index|[
literal|3
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|start
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|!
name|ihex_write_record
argument_list|(
name|abfd
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
name|startbuf
argument_list|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
name|startbuf
index|[
literal|0
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|start
operator|>>
literal|24
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|startbuf
index|[
literal|1
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|start
operator|>>
literal|16
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|startbuf
index|[
literal|2
index|]
operator|=
call|(
name|bfd_byte
call|)
argument_list|(
name|start
operator|>>
literal|8
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|startbuf
index|[
literal|3
index|]
operator|=
operator|(
name|bfd_byte
operator|)
name|start
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|!
name|ihex_write_record
argument_list|(
name|abfd
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|5
argument_list|,
name|startbuf
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|ihex_write_record
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Make an empty symbol.  This is required only because    bfd_make_section_anyway wants to create a symbol for the section.  */
end_comment

begin_function
specifier|static
name|asymbol
modifier|*
name|ihex_make_empty_symbol
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|asymbol
modifier|*
name|new
decl_stmt|;
name|new
operator|=
operator|(
name|asymbol
operator|*
operator|)
name|bfd_zalloc
argument_list|(
name|abfd
argument_list|,
sizeof|sizeof
argument_list|(
name|asymbol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|NULL
condition|)
name|new
operator|->
name|the_bfd
operator|=
name|abfd
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Set the architecture for the output file.  The architecture is    irrelevant, so we ignore errors about unknown architectures.  */
end_comment

begin_function
specifier|static
name|boolean
name|ihex_set_arch_mach
parameter_list|(
name|abfd
parameter_list|,
name|arch
parameter_list|,
name|mach
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
name|unsigned
name|long
name|mach
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|bfd_default_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|arch
argument_list|,
name|mach
argument_list|)
condition|)
block|{
if|if
condition|(
name|arch
operator|!=
name|bfd_arch_unknown
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Get the size of the headers, for the linker.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|ihex_sizeof_headers
parameter_list|(
name|abfd
parameter_list|,
name|exec
parameter_list|)
name|bfd
modifier|*
name|abfd
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|boolean
name|exec
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Some random definitions for the target vector.  */
end_comment

begin_define
define|#
directive|define
name|ihex_close_and_cleanup
value|_bfd_generic_close_and_cleanup
end_define

begin_define
define|#
directive|define
name|ihex_bfd_free_cached_info
value|_bfd_generic_bfd_free_cached_info
end_define

begin_define
define|#
directive|define
name|ihex_new_section_hook
value|_bfd_generic_new_section_hook
end_define

begin_define
define|#
directive|define
name|ihex_get_section_contents_in_window
define|\
value|_bfd_generic_get_section_contents_in_window
end_define

begin_define
define|#
directive|define
name|ihex_get_symtab_upper_bound
value|bfd_0l
end_define

begin_define
define|#
directive|define
name|ihex_get_symtab
define|\
value|((long (*) PARAMS ((bfd *, asymbol **))) bfd_0l)
end_define

begin_define
define|#
directive|define
name|ihex_print_symbol
value|_bfd_nosymbols_print_symbol
end_define

begin_define
define|#
directive|define
name|ihex_get_symbol_info
value|_bfd_nosymbols_get_symbol_info
end_define

begin_define
define|#
directive|define
name|ihex_bfd_is_local_label_name
value|_bfd_nosymbols_bfd_is_local_label_name
end_define

begin_define
define|#
directive|define
name|ihex_get_lineno
value|_bfd_nosymbols_get_lineno
end_define

begin_define
define|#
directive|define
name|ihex_find_nearest_line
value|_bfd_nosymbols_find_nearest_line
end_define

begin_define
define|#
directive|define
name|ihex_bfd_make_debug_symbol
value|_bfd_nosymbols_bfd_make_debug_symbol
end_define

begin_define
define|#
directive|define
name|ihex_read_minisymbols
value|_bfd_nosymbols_read_minisymbols
end_define

begin_define
define|#
directive|define
name|ihex_minisymbol_to_symbol
value|_bfd_nosymbols_minisymbol_to_symbol
end_define

begin_define
define|#
directive|define
name|ihex_get_reloc_upper_bound
define|\
value|((long (*) PARAMS ((bfd *, asection *))) bfd_0l)
end_define

begin_define
define|#
directive|define
name|ihex_canonicalize_reloc
define|\
value|((long (*) PARAMS ((bfd *, asection *, arelent **, asymbol **))) bfd_0l)
end_define

begin_define
define|#
directive|define
name|ihex_bfd_reloc_type_lookup
value|_bfd_norelocs_bfd_reloc_type_lookup
end_define

begin_define
define|#
directive|define
name|ihex_bfd_get_relocated_section_contents
define|\
value|bfd_generic_get_relocated_section_contents
end_define

begin_define
define|#
directive|define
name|ihex_bfd_relax_section
value|bfd_generic_relax_section
end_define

begin_define
define|#
directive|define
name|ihex_bfd_gc_sections
value|bfd_generic_gc_sections
end_define

begin_define
define|#
directive|define
name|ihex_bfd_link_hash_table_create
value|_bfd_generic_link_hash_table_create
end_define

begin_define
define|#
directive|define
name|ihex_bfd_link_add_symbols
value|_bfd_generic_link_add_symbols
end_define

begin_define
define|#
directive|define
name|ihex_bfd_final_link
value|_bfd_generic_final_link
end_define

begin_define
define|#
directive|define
name|ihex_bfd_link_split_section
value|_bfd_generic_link_split_section
end_define

begin_comment
comment|/* The Intel Hex target vector.  */
end_comment

begin_decl_stmt
specifier|const
name|bfd_target
name|ihex_vec
init|=
block|{
literal|"ihex"
block|,
comment|/* name */
name|bfd_target_ihex_flavour
block|,
name|BFD_ENDIAN_UNKNOWN
block|,
comment|/* target byte order */
name|BFD_ENDIAN_UNKNOWN
block|,
comment|/* target headers byte order */
literal|0
block|,
comment|/* object flags */
operator|(
name|SEC_HAS_CONTENTS
operator||
name|SEC_ALLOC
operator||
name|SEC_LOAD
operator|)
block|,
comment|/* section flags */
literal|0
block|,
comment|/* leading underscore */
literal|' '
block|,
comment|/* ar_pad_char */
literal|16
block|,
comment|/* ar_max_namelen */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* data */
name|bfd_getb64
block|,
name|bfd_getb_signed_64
block|,
name|bfd_putb64
block|,
name|bfd_getb32
block|,
name|bfd_getb_signed_32
block|,
name|bfd_putb32
block|,
name|bfd_getb16
block|,
name|bfd_getb_signed_16
block|,
name|bfd_putb16
block|,
comment|/* hdrs */
block|{
name|_bfd_dummy_target
block|,
name|ihex_object_p
block|,
comment|/* bfd_check_format */
name|_bfd_dummy_target
block|,
name|_bfd_dummy_target
block|,   }
block|,
block|{
name|bfd_false
block|,
name|ihex_mkobject
block|,
name|_bfd_generic_mkarchive
block|,
name|bfd_false
block|,   }
block|,
block|{
comment|/* bfd_write_contents */
name|bfd_false
block|,
name|ihex_write_object_contents
block|,
name|_bfd_write_archive_contents
block|,
name|bfd_false
block|,   }
block|,
name|BFD_JUMP_TABLE_GENERIC
argument_list|(
name|ihex
argument_list|)
block|,
name|BFD_JUMP_TABLE_COPY
argument_list|(
name|_bfd_generic
argument_list|)
block|,
name|BFD_JUMP_TABLE_CORE
argument_list|(
name|_bfd_nocore
argument_list|)
block|,
name|BFD_JUMP_TABLE_ARCHIVE
argument_list|(
name|_bfd_noarchive
argument_list|)
block|,
name|BFD_JUMP_TABLE_SYMBOLS
argument_list|(
name|ihex
argument_list|)
block|,
name|BFD_JUMP_TABLE_RELOCS
argument_list|(
name|ihex
argument_list|)
block|,
name|BFD_JUMP_TABLE_WRITE
argument_list|(
name|ihex
argument_list|)
block|,
name|BFD_JUMP_TABLE_LINK
argument_list|(
name|ihex
argument_list|)
block|,
name|BFD_JUMP_TABLE_DYNAMIC
argument_list|(
name|_bfd_nodynamic
argument_list|)
block|,
name|NULL
block|,
operator|(
name|PTR
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

end_unit

