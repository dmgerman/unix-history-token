begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* 8 and 16 bit COFF relocation functions, for BFD.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 2000    Free Software Foundation, Inc.    Written by Cygnus Support.  This file is part of BFD, the Binary File Descriptor library.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Most of this hacked by Steve Chamberlain<sac@cygnus.com>.  */
end_comment

begin_comment
comment|/* These routines are used by coff-h8300 and coff-z8k to do    relocation.     FIXME: This code should be rewritten to support the new COFF    linker.  Basically, they need to deal with COFF relocs rather than    BFD generic relocs.  They should store the relocs in some location    where coff_link_input_bfd can find them (and coff_link_input_bfd    should be changed to use this location rather than rereading the    file) (unless info->keep_memory is false, in which case they should    free up the relocs after dealing with them).  */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"sysdep.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_include
include|#
directive|include
file|"bfdlink.h"
end_include

begin_include
include|#
directive|include
file|"genlink.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_function
name|bfd_vma
name|bfd_coff_reloc16_get_value
parameter_list|(
name|reloc
parameter_list|,
name|link_info
parameter_list|,
name|input_section
parameter_list|)
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
block|{
name|bfd_vma
name|value
decl_stmt|;
name|asymbol
modifier|*
name|symbol
init|=
operator|*
operator|(
name|reloc
operator|->
name|sym_ptr_ptr
operator|)
decl_stmt|;
comment|/* A symbol holds a pointer to a section, and an offset from the      base of the section.  To relocate, we find where the section will      live in the output and add that in.  */
if|if
condition|(
name|bfd_is_und_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
operator|||
name|bfd_is_com_section
argument_list|(
name|symbol
operator|->
name|section
argument_list|)
condition|)
block|{
name|struct
name|bfd_link_hash_entry
modifier|*
name|h
decl_stmt|;
comment|/* The symbol is undefined in this BFD.  Look it up in the 	 global linker hash table.  FIXME: This should be changed when 	 we convert this stuff to use a specific final_link function 	 and change the interface to bfd_relax_section to not require 	 the generic symbols.  */
name|h
operator|=
name|bfd_wrapped_link_hash_lookup
argument_list|(
name|input_section
operator|->
name|owner
argument_list|,
name|link_info
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
operator|(
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_defweak
operator|)
condition|)
name|value
operator|=
operator|(
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|value
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_section
operator|->
name|vma
operator|+
name|h
operator|->
name|u
operator|.
name|def
operator|.
name|section
operator|->
name|output_offset
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|h
operator|!=
operator|(
expr|struct
name|bfd_link_hash_entry
operator|*
operator|)
name|NULL
operator|&&
name|h
operator|->
name|type
operator|==
name|bfd_link_hash_common
condition|)
name|value
operator|=
name|h
operator|->
name|u
operator|.
name|c
operator|.
name|size
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|link_info
operator|->
name|callbacks
operator|->
name|undefined_symbol
call|)
argument_list|(
name|link_info
argument_list|,
name|bfd_asymbol_name
argument_list|(
name|symbol
argument_list|)
argument_list|,
name|input_section
operator|->
name|owner
argument_list|,
name|input_section
argument_list|,
name|reloc
operator|->
name|address
argument_list|,
name|true
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|value
operator|=
name|symbol
operator|->
name|value
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_offset
operator|+
name|symbol
operator|->
name|section
operator|->
name|output_section
operator|->
name|vma
expr_stmt|;
block|}
comment|/* Add the value contained in the relocation.  */
name|value
operator|+=
name|reloc
operator|->
name|addend
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_function
name|void
name|bfd_perform_slip
parameter_list|(
name|abfd
parameter_list|,
name|slip
parameter_list|,
name|input_section
parameter_list|,
name|value
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|slip
decl_stmt|;
name|asection
modifier|*
name|input_section
decl_stmt|;
name|bfd_vma
name|value
decl_stmt|;
block|{
name|asymbol
modifier|*
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|_bfd_generic_link_get_symbols
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|s
operator|!=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* Find all symbols past this point, and make them know      what's happened.  */
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|asymbol
modifier|*
name|p
init|=
operator|*
name|s
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|section
operator|==
name|input_section
condition|)
block|{
comment|/* This was pointing into this section, so mangle it.  */
if|if
condition|(
name|p
operator|->
name|value
operator|>
name|value
condition|)
block|{
name|p
operator|->
name|value
operator|-=
name|slip
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|udata
operator|.
name|p
operator|!=
name|NULL
condition|)
block|{
name|struct
name|generic_link_hash_entry
modifier|*
name|h
decl_stmt|;
name|h
operator|=
operator|(
expr|struct
name|generic_link_hash_entry
operator|*
operator|)
name|p
operator|->
name|udata
operator|.
name|p
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defined
operator|||
name|h
operator|->
name|root
operator|.
name|type
operator|==
name|bfd_link_hash_defweak
argument_list|)
expr_stmt|;
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|-=
name|slip
expr_stmt|;
name|BFD_ASSERT
argument_list|(
name|h
operator|->
name|root
operator|.
name|u
operator|.
name|def
operator|.
name|value
operator|==
name|p
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|s
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|boolean
name|bfd_coff_reloc16_relax_section
parameter_list|(
name|abfd
parameter_list|,
name|i
parameter_list|,
name|link_info
parameter_list|,
name|again
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|i
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|boolean
modifier|*
name|again
decl_stmt|;
block|{
comment|/* Get enough memory to hold the stuff.  */
name|bfd
modifier|*
name|input_bfd
init|=
name|i
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
name|input_section
init|=
name|i
decl_stmt|;
name|int
modifier|*
name|shrinks
decl_stmt|;
name|int
name|shrink
init|=
literal|0
decl_stmt|;
name|long
name|reloc_size
init|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|reloc_vector
init|=
name|NULL
decl_stmt|;
name|long
name|reloc_count
decl_stmt|;
comment|/* We only do global relaxation once.  It is not safe to do it multiple      times (see discussion of the "shrinks" array below).  */
operator|*
name|again
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|reloc_size
operator|<
literal|0
condition|)
return|return
name|false
return|;
name|reloc_vector
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
name|reloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reloc_vector
operator|&&
name|reloc_size
operator|>
literal|0
condition|)
return|return
name|false
return|;
comment|/* Get the relocs and think about them.  */
name|reloc_count
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|reloc_vector
argument_list|,
name|_bfd_generic_link_get_symbols
argument_list|(
name|input_bfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_count
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|reloc_vector
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* The reloc16.c and related relaxing code is very simple, the price      for that simplicity is we can only call this function once for      each section.       So, to get the best results within that limitation, we do multiple      relaxing passes over each section here.  That involves keeping track      of the "shrink" at each reloc in the section.  This allows us to      accurately determine the relative location of two relocs within      this section.       In theory, if we kept the "shrinks" array for each section for the      entire link, we could use the generic relaxing code in the linker      and get better results, particularly for jsr->bsr and 24->16 bit      memory reference relaxations.  */
if|if
condition|(
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|int
name|another_pass
init|=
literal|0
decl_stmt|;
comment|/* Allocate and initialize the shrinks array for this section.          The last element is used as an accumlator of shrinks.  */
name|shrinks
operator|=
operator|(
name|int
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|reloc_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|shrinks
argument_list|,
literal|0
argument_list|,
operator|(
name|reloc_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Loop until nothing changes in this section.  */
do|do
block|{
name|arelent
modifier|*
modifier|*
name|parent
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|long
name|j
decl_stmt|;
name|another_pass
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|parent
operator|=
name|reloc_vector
init|;
operator|*
name|parent
condition|;
name|parent
operator|++
operator|,
name|i
operator|++
control|)
block|{
comment|/* Let the target/machine dependent code examine each reloc 	       in this section and attempt to shrink it.  */
name|shrink
operator|=
name|bfd_coff_reloc16_estimate
argument_list|(
name|abfd
argument_list|,
name|input_section
argument_list|,
operator|*
name|parent
argument_list|,
name|shrinks
index|[
name|i
index|]
argument_list|,
name|link_info
argument_list|)
expr_stmt|;
comment|/* If it shrunk, note it in the shrinks array and set up for 	       another pass.  */
if|if
condition|(
name|shrink
operator|!=
name|shrinks
index|[
name|i
index|]
condition|)
block|{
name|another_pass
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<=
name|reloc_count
condition|;
name|j
operator|++
control|)
name|shrinks
index|[
name|j
index|]
operator|+=
name|shrink
operator|-
name|shrinks
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|another_pass
condition|)
do|;
name|shrink
operator|=
name|shrinks
index|[
name|reloc_count
index|]
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|shrinks
argument_list|)
expr_stmt|;
block|}
name|input_section
operator|->
name|_cooked_size
operator|-=
name|shrink
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reloc_vector
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|bfd_byte
modifier|*
name|bfd_coff_reloc16_get_relocated_section_contents
parameter_list|(
name|in_abfd
parameter_list|,
name|link_info
parameter_list|,
name|link_order
parameter_list|,
name|data
parameter_list|,
name|relocateable
parameter_list|,
name|symbols
parameter_list|)
name|bfd
modifier|*
name|in_abfd
decl_stmt|;
name|struct
name|bfd_link_info
modifier|*
name|link_info
decl_stmt|;
name|struct
name|bfd_link_order
modifier|*
name|link_order
decl_stmt|;
name|bfd_byte
modifier|*
name|data
decl_stmt|;
name|boolean
name|relocateable
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbols
decl_stmt|;
block|{
comment|/* Get enough memory to hold the stuff.  */
name|bfd
modifier|*
name|input_bfd
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
operator|->
name|owner
decl_stmt|;
name|asection
modifier|*
name|input_section
init|=
name|link_order
operator|->
name|u
operator|.
name|indirect
operator|.
name|section
decl_stmt|;
name|long
name|reloc_size
init|=
name|bfd_get_reloc_upper_bound
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|)
decl_stmt|;
name|arelent
modifier|*
modifier|*
name|reloc_vector
decl_stmt|;
name|long
name|reloc_count
decl_stmt|;
if|if
condition|(
name|reloc_size
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* If producing relocateable output, don't bother to relax.  */
if|if
condition|(
name|relocateable
condition|)
return|return
name|bfd_generic_get_relocated_section_contents
argument_list|(
name|in_abfd
argument_list|,
name|link_info
argument_list|,
name|link_order
argument_list|,
name|data
argument_list|,
name|relocateable
argument_list|,
name|symbols
argument_list|)
return|;
comment|/* Read in the section.  */
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|input_section
operator|->
name|_raw_size
argument_list|)
condition|)
return|return
name|NULL
return|;
name|reloc_vector
operator|=
operator|(
name|arelent
operator|*
operator|*
operator|)
name|bfd_malloc
argument_list|(
operator|(
name|size_t
operator|)
name|reloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reloc_vector
operator|&&
name|reloc_size
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
name|reloc_count
operator|=
name|bfd_canonicalize_reloc
argument_list|(
name|input_bfd
argument_list|,
name|input_section
argument_list|,
name|reloc_vector
argument_list|,
name|symbols
argument_list|)
expr_stmt|;
if|if
condition|(
name|reloc_count
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|reloc_vector
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|reloc_count
operator|>
literal|0
condition|)
block|{
name|arelent
modifier|*
modifier|*
name|parent
init|=
name|reloc_vector
decl_stmt|;
name|arelent
modifier|*
name|reloc
decl_stmt|;
name|unsigned
name|int
name|dst_address
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|src_address
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|run
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
comment|/* Find how long a run we can do.  */
while|while
condition|(
name|dst_address
operator|<
name|link_order
operator|->
name|size
condition|)
block|{
name|reloc
operator|=
operator|*
name|parent
expr_stmt|;
if|if
condition|(
name|reloc
condition|)
block|{
comment|/* Note that the relaxing didn't tie up the addresses in the 		 relocation, so we use the original address to work out the 		 run of non-relocated data.  */
name|run
operator|=
name|reloc
operator|->
name|address
operator|-
name|src_address
expr_stmt|;
name|parent
operator|++
expr_stmt|;
block|}
else|else
block|{
name|run
operator|=
name|link_order
operator|->
name|size
operator|-
name|dst_address
expr_stmt|;
block|}
comment|/* Copy the bytes.  */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|run
condition|;
name|idx
operator|++
control|)
name|data
index|[
name|dst_address
operator|++
index|]
operator|=
name|data
index|[
name|src_address
operator|++
index|]
expr_stmt|;
comment|/* Now do the relocation.  */
if|if
condition|(
name|reloc
condition|)
block|{
name|bfd_coff_reloc16_extra_cases
argument_list|(
name|input_bfd
argument_list|,
name|link_info
argument_list|,
name|link_order
argument_list|,
name|reloc
argument_list|,
name|data
argument_list|,
operator|&
name|src_address
argument_list|,
operator|&
name|dst_address
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reloc_vector
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

end_unit

